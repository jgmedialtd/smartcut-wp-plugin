import { I as Rg, i as fk } from "./vendor-pako-Bv9j8L58.js";
const V1 = Object.freeze({
  status: "aborted"
});
function Re(e, t, r) {
  function i(a, u) {
    var c;
    Object.defineProperty(a, "_zod", {
      value: a._zod ?? {},
      enumerable: !1
    }), (c = a._zod).traits ?? (c.traits = /* @__PURE__ */ new Set()), a._zod.traits.add(e), t(a, u);
    for (const f in s.prototype)
      f in a || Object.defineProperty(a, f, { value: s.prototype[f].bind(a) });
    a._zod.constr = s, a._zod.def = u;
  }
  const n = r?.Parent ?? Object;
  class o extends n {
  }
  Object.defineProperty(o, "name", { value: e });
  function s(a) {
    var u;
    const c = r?.Parent ? new o() : this;
    i(c, a), (u = c._zod).deferred ?? (u.deferred = []);
    for (const f of c._zod.deferred)
      f();
    return c;
  }
  return Object.defineProperty(s, "init", { value: i }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => r?.Parent && a instanceof r.Parent ? !0 : a?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
const W1 = Symbol("zod_brand");
let Xi = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}, _u = class extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
};
const Zs = {};
function pn(e) {
  return e && Object.assign(Zs, e), Zs;
}
function hk(e) {
  return e;
}
function pk(e) {
  return e;
}
function dk(e) {
}
function mk(e) {
  throw new Error();
}
function yk(e) {
}
function td(e) {
  const t = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e).filter(([i, n]) => t.indexOf(+i) === -1).map(([i, n]) => n);
}
function it(e, t = "|") {
  return e.map((r) => jt(r)).join(t);
}
function Vs(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Fa(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function ho(e) {
  return e == null;
}
function wu(e) {
  const t = e.startsWith("^") ? 1 : 0, r = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, r);
}
function G1(e, t) {
  const r = (e.toString().split(".")[1] || "").length, i = t.toString();
  let n = (i.split(".")[1] || "").length;
  if (n === 0 && /\d?e-\d?/.test(i)) {
    const u = i.match(/\d?e-(\d?)/);
    u?.[1] && (n = Number.parseInt(u[1]));
  }
  const o = r > n ? r : n, s = Number.parseInt(e.toFixed(o).replace(".", "")), a = Number.parseInt(t.toFixed(o).replace(".", ""));
  return s % a / 10 ** o;
}
const Dg = Symbol("evaluating");
function Wt(e, t, r) {
  let i;
  Object.defineProperty(e, t, {
    get() {
      if (i !== Dg)
        return i === void 0 && (i = Dg, i = r()), i;
    },
    set(n) {
      Object.defineProperty(e, t, {
        value: n
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function gk(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function Li(e, t, r) {
  Object.defineProperty(e, t, {
    value: r,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function _i(...e) {
  const t = {};
  for (const r of e) {
    const i = Object.getOwnPropertyDescriptors(r);
    Object.assign(t, i);
  }
  return Object.defineProperties({}, t);
}
function vk(e) {
  return _i(e._zod.def);
}
function bk(e, t) {
  return t ? t.reduce((r, i) => r?.[i], e) : e;
}
function _k(e) {
  const t = Object.keys(e), r = t.map((i) => e[i]);
  return Promise.all(r).then((i) => {
    const n = {};
    for (let o = 0; o < t.length; o++)
      n[t[o]] = i[o];
    return n;
  });
}
function wk(e = 10) {
  const t = "abcdefghijklmnopqrstuvwxyz";
  let r = "";
  for (let i = 0; i < e; i++)
    r += t[Math.floor(Math.random() * t.length)];
  return r;
}
function Jh(e) {
  return JSON.stringify(e);
}
const rd = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function To(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const K1 = Fa(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function to(e) {
  if (To(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(To(r) === !1 || Object.prototype.hasOwnProperty.call(r, "isPrototypeOf") === !1);
}
function Ou(e) {
  return to(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
function Ok(e) {
  let t = 0;
  for (const r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t++;
  return t;
}
const $k = (e) => {
  const t = typeof e;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, Ws = /* @__PURE__ */ new Set(["string", "number", "symbol"]), H1 = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function Ci(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Un(e, t, r) {
  const i = new e._zod.constr(t ?? e._zod.def);
  return (!t || r?.parent) && (i._zod.parent = e), i;
}
function Je(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function Sk(e) {
  let t;
  return new Proxy({}, {
    get(r, i, n) {
      return t ?? (t = e()), Reflect.get(t, i, n);
    },
    set(r, i, n, o) {
      return t ?? (t = e()), Reflect.set(t, i, n, o);
    },
    has(r, i) {
      return t ?? (t = e()), Reflect.has(t, i);
    },
    deleteProperty(r, i) {
      return t ?? (t = e()), Reflect.deleteProperty(t, i);
    },
    ownKeys(r) {
      return t ?? (t = e()), Reflect.ownKeys(t);
    },
    getOwnPropertyDescriptor(r, i) {
      return t ?? (t = e()), Reflect.getOwnPropertyDescriptor(t, i);
    },
    defineProperty(r, i, n) {
      return t ?? (t = e()), Reflect.defineProperty(t, i, n);
    }
  });
}
function jt(e) {
  return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function J1(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const Y1 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, X1 = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function Q1(e, t) {
  const r = e._zod.def, i = _i(e._zod.def, {
    get shape() {
      const n = {};
      for (const o in t) {
        if (!(o in r.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && (n[o] = r.shape[o]);
      }
      return Li(this, "shape", n), n;
    },
    checks: []
  });
  return Un(e, i);
}
function eO(e, t) {
  const r = e._zod.def, i = _i(e._zod.def, {
    get shape() {
      const n = { ...e._zod.def.shape };
      for (const o in t) {
        if (!(o in r.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && delete n[o];
      }
      return Li(this, "shape", n), n;
    },
    checks: []
  });
  return Un(e, i);
}
function tO(e, t) {
  if (!to(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const r = e._zod.def.checks;
  if (r && r.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const n = _i(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return Li(this, "shape", o), o;
    },
    checks: []
  });
  return Un(e, n);
}
function rO(e, t) {
  if (!to(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const r = {
    ...e._zod.def,
    get shape() {
      const i = { ...e._zod.def.shape, ...t };
      return Li(this, "shape", i), i;
    },
    checks: e._zod.def.checks
  };
  return Un(e, r);
}
function nO(e, t) {
  const r = _i(e._zod.def, {
    get shape() {
      const i = { ...e._zod.def.shape, ...t._zod.def.shape };
      return Li(this, "shape", i), i;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Un(e, r);
}
function iO(e, t, r) {
  const i = _i(t._zod.def, {
    get shape() {
      const n = t._zod.def.shape, o = { ...n };
      if (r)
        for (const s in r) {
          if (!(s in n))
            throw new Error(`Unrecognized key: "${s}"`);
          r[s] && (o[s] = e ? new e({
            type: "optional",
            innerType: n[s]
          }) : n[s]);
        }
      else
        for (const s in n)
          o[s] = e ? new e({
            type: "optional",
            innerType: n[s]
          }) : n[s];
      return Li(this, "shape", o), o;
    },
    checks: []
  });
  return Un(t, i);
}
function oO(e, t, r) {
  const i = _i(t._zod.def, {
    get shape() {
      const n = t._zod.def.shape, o = { ...n };
      if (r)
        for (const s in r) {
          if (!(s in o))
            throw new Error(`Unrecognized key: "${s}"`);
          r[s] && (o[s] = new e({
            type: "nonoptional",
            innerType: n[s]
          }));
        }
      else
        for (const s in n)
          o[s] = new e({
            type: "nonoptional",
            innerType: n[s]
          });
      return Li(this, "shape", o), o;
    },
    checks: []
  });
  return Un(t, i);
}
function Ki(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let r = t; r < e.issues.length; r++)
    if (e.issues[r]?.continue !== !0)
      return !0;
  return !1;
}
function Vn(e, t) {
  return t.map((r) => {
    var i;
    return (i = r).path ?? (i.path = []), r.path.unshift(e), r;
  });
}
function ba(e) {
  return typeof e == "string" ? e : e?.message;
}
function Gn(e, t, r) {
  const i = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const n = ba(e.inst?._zod.def?.error?.(e)) ?? ba(t?.error?.(e)) ?? ba(r.customError?.(e)) ?? ba(r.localeError?.(e)) ?? "Invalid input";
    i.message = n;
  }
  return delete i.inst, delete i.continue, t?.reportInput || delete i.input, i;
}
function $u(e) {
  return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown";
}
function Su(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function No(...e) {
  const [t, r, i] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: r,
    inst: i
  } : { ...t };
}
function Ek(e) {
  return Object.entries(e).filter(([t, r]) => Number.isNaN(Number.parseInt(t, 10))).map((t) => t[1]);
}
function aO(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    r[i] = t.charCodeAt(i);
  return r;
}
function sO(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += String.fromCharCode(e[r]);
  return btoa(t);
}
function xk(e) {
  const t = e.replace(/-/g, "+").replace(/_/g, "/"), r = "=".repeat((4 - t.length % 4) % 4);
  return aO(t + r);
}
function Ak(e) {
  return sO(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function jk(e) {
  const t = e.replace(/^0x/, "");
  if (t.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  const r = new Uint8Array(t.length / 2);
  for (let i = 0; i < t.length; i += 2)
    r[i / 2] = Number.parseInt(t.slice(i, i + 2), 16);
  return r;
}
function kk(e) {
  return Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}
class Pk {
  constructor(...t) {
  }
}
const uO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, BIGINT_FORMAT_RANGES: X1, Class: Pk, NUMBER_FORMAT_RANGES: Y1, aborted: Ki, allowsEval: K1, assert: yk, assertEqual: hk, assertIs: dk, assertNever: mk, assertNotEqual: pk, assignProp: Li, base64ToUint8Array: aO, base64urlToUint8Array: xk, cached: Fa, captureStackTrace: rd, cleanEnum: Ek, cleanRegex: wu, clone: Un, cloneDef: vk, createTransparentProxy: Sk, defineLazy: Wt, esc: Jh, escapeRegex: Ci, extend: tO, finalizeIssue: Gn, floatSafeRemainder: G1, getElementAtPath: bk, getEnumValues: td, getLengthableOrigin: Su, getParsedType: $k, getSizableOrigin: $u, hexToUint8Array: jk, isObject: To, isPlainObject: to, issue: No, joinValues: it, jsonStringifyReplacer: Vs, merge: nO, mergeDefs: _i, normalizeParams: Je, nullish: ho, numKeys: Ok, objectClone: gk, omit: eO, optionalKeys: J1, partial: iO, pick: Q1, prefixIssues: Vn, primitiveTypes: H1, promiseAllObject: _k, propertyKeyTypes: Ws, randomString: wk, required: oO, safeExtend: rO, shallowClone: Ou, stringifyPrimitive: jt, uint8ArrayToBase64: sO, uint8ArrayToBase64url: Ak, uint8ArrayToHex: kk, unwrapMessage: ba }, Symbol.toStringTag, { value: "Module" })), cO = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, Vs, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, nd = Re("$ZodError", cO), Tn = Re("$ZodError", cO, { Parent: Error });
function id(e, t = (r) => r.message) {
  const r = {}, i = [];
  for (const n of e.issues)
    n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [], r[n.path[0]].push(t(n))) : i.push(t(n));
  return { formErrors: i, fieldErrors: r };
}
function od(e, t = (r) => r.message) {
  const r = { _errors: [] }, i = (n) => {
    for (const o of n.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((s) => i({ issues: s }));
      else if (o.code === "invalid_key")
        i({ issues: o.issues });
      else if (o.code === "invalid_element")
        i({ issues: o.issues });
      else if (o.path.length === 0)
        r._errors.push(t(o));
      else {
        let s = r, a = 0;
        for (; a < o.path.length; ) {
          const u = o.path[a];
          a === o.path.length - 1 ? (s[u] = s[u] || { _errors: [] }, s[u]._errors.push(t(o))) : s[u] = s[u] || { _errors: [] }, s = s[u], a++;
        }
      }
  };
  return i(e), r;
}
function lO(e, t = (r) => r.message) {
  const r = { errors: [] }, i = (n, o = []) => {
    var s, a;
    for (const u of n.issues)
      if (u.code === "invalid_union" && u.errors.length)
        u.errors.map((c) => i({ issues: c }, u.path));
      else if (u.code === "invalid_key")
        i({ issues: u.issues }, u.path);
      else if (u.code === "invalid_element")
        i({ issues: u.issues }, u.path);
      else {
        const c = [...o, ...u.path];
        if (c.length === 0) {
          r.errors.push(t(u));
          continue;
        }
        let f = r, h = 0;
        for (; h < c.length; ) {
          const y = c[h], p = h === c.length - 1;
          typeof y == "string" ? (f.properties ?? (f.properties = {}), (s = f.properties)[y] ?? (s[y] = { errors: [] }), f = f.properties[y]) : (f.items ?? (f.items = []), (a = f.items)[y] ?? (a[y] = { errors: [] }), f = f.items[y]), p && f.errors.push(t(u)), h++;
        }
      }
  };
  return i(e), r;
}
function fO(e) {
  const t = [], r = e.map((i) => typeof i == "object" ? i.key : i);
  for (const i of r)
    typeof i == "number" ? t.push(`[${i}]`) : typeof i == "symbol" ? t.push(`[${JSON.stringify(String(i))}]`) : /[^\w$]/.test(i) ? t.push(`[${JSON.stringify(i)}]`) : (t.length && t.push("."), t.push(i));
  return t.join("");
}
function hO(e) {
  const t = [], r = [...e.issues].sort((i, n) => (i.path ?? []).length - (n.path ?? []).length);
  for (const i of r)
    t.push(`✖ ${i.message}`), i.path?.length && t.push(`  → at ${fO(i.path)}`);
  return t.join(`
`);
}
const La = (e) => (t, r, i, n) => {
  const o = i ? Object.assign(i, { async: !1 }) : { async: !1 }, s = t._zod.run({ value: r, issues: [] }, o);
  if (s instanceof Promise)
    throw new Xi();
  if (s.issues.length) {
    const a = new (n?.Err ?? e)(s.issues.map((u) => Gn(u, o, pn())));
    throw rd(a, n?.callee), a;
  }
  return s.value;
}, Yh = /* @__PURE__ */ La(Tn), Ba = (e) => async (t, r, i, n) => {
  const o = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: r, issues: [] }, o);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new (n?.Err ?? e)(s.issues.map((u) => Gn(u, o, pn())));
    throw rd(a, n?.callee), a;
  }
  return s.value;
}, Xh = /* @__PURE__ */ Ba(Tn), qa = (e) => (t, r, i) => {
  const n = i ? { ...i, async: !1 } : { async: !1 }, o = t._zod.run({ value: r, issues: [] }, n);
  if (o instanceof Promise)
    throw new Xi();
  return o.issues.length ? {
    success: !1,
    error: new (e ?? nd)(o.issues.map((s) => Gn(s, n, pn())))
  } : { success: !0, data: o.value };
}, pO = /* @__PURE__ */ qa(Tn), Za = (e) => async (t, r, i) => {
  const n = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: r, issues: [] }, n);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new e(o.issues.map((s) => Gn(s, n, pn())))
  } : { success: !0, data: o.value };
}, dO = /* @__PURE__ */ Za(Tn), ad = (e) => (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return La(e)(t, r, n);
}, Ik = /* @__PURE__ */ ad(Tn), sd = (e) => (t, r, i) => La(e)(t, r, i), Tk = /* @__PURE__ */ sd(Tn), ud = (e) => async (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Ba(e)(t, r, n);
}, Nk = /* @__PURE__ */ ud(Tn), cd = (e) => async (t, r, i) => Ba(e)(t, r, i), Ck = /* @__PURE__ */ cd(Tn), ld = (e) => (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return qa(e)(t, r, n);
}, Rk = /* @__PURE__ */ ld(Tn), fd = (e) => (t, r, i) => qa(e)(t, r, i), Dk = /* @__PURE__ */ fd(Tn), hd = (e) => async (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Za(e)(t, r, n);
}, zk = /* @__PURE__ */ hd(Tn), pd = (e) => async (t, r, i) => Za(e)(t, r, i), Uk = /* @__PURE__ */ pd(Tn), mO = /^[cC][^\s-]{8,}$/, yO = /^[0-9a-z]+$/, gO = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, vO = /^[0-9a-vA-V]{20}$/, bO = /^[A-Za-z0-9]{27}$/, _O = /^[a-zA-Z0-9_-]{21}$/, wO = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Mk = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, OO = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Co = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, Fk = /* @__PURE__ */ Co(4), Lk = /* @__PURE__ */ Co(6), Bk = /* @__PURE__ */ Co(7), $O = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, qk = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, Zk = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, SO = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, Vk = SO, Wk = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, Gk = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function EO() {
  return new RegExp(Gk, "u");
}
const xO = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, AO = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, jO = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, kO = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, PO = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, dd = /^[A-Za-z0-9_-]*$/, md = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, IO = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, TO = /^\+(?:[0-9]){6,14}[0-9]$/, NO = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", CO = /* @__PURE__ */ new RegExp(`^${NO}$`);
function RO(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function DO(e) {
  return new RegExp(`^${RO(e)}$`);
}
function zO(e) {
  const t = RO({ precision: e.precision }), r = ["Z"];
  e.local && r.push(""), e.offset && r.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const i = `${t}(?:${r.join("|")})`;
  return new RegExp(`^${NO}T(?:${i})$`);
}
const UO = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, MO = /^-?\d+n?$/, FO = /^-?\d+$/, LO = /^-?\d+(?:\.\d+)?/, BO = /^(?:true|false)$/i, qO = /^null$/i, ZO = /^undefined$/i, VO = /^[^A-Z]*$/, WO = /^[^a-z]*$/, GO = /^[0-9a-fA-F]*$/;
function Va(e, t) {
  return new RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
}
function Wa(e) {
  return new RegExp(`^[A-Za-z0-9_-]{${e}}$`);
}
const Kk = /^[0-9a-fA-F]{32}$/, Hk = /* @__PURE__ */ Va(22, "=="), Jk = /* @__PURE__ */ Wa(22), Yk = /^[0-9a-fA-F]{40}$/, Xk = /* @__PURE__ */ Va(27, "="), Qk = /* @__PURE__ */ Wa(27), eP = /^[0-9a-fA-F]{64}$/, tP = /* @__PURE__ */ Va(43, "="), rP = /* @__PURE__ */ Wa(43), nP = /^[0-9a-fA-F]{96}$/, iP = /* @__PURE__ */ Va(64, ""), oP = /* @__PURE__ */ Wa(64), aP = /^[0-9a-fA-F]{128}$/, sP = /* @__PURE__ */ Va(86, "=="), uP = /* @__PURE__ */ Wa(86), yd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, base64: PO, base64url: dd, bigint: MO, boolean: BO, browserEmail: Wk, cidrv4: jO, cidrv6: kO, cuid: mO, cuid2: yO, date: CO, datetime: zO, domain: IO, duration: wO, e164: TO, email: $O, emoji: EO, extendedDuration: Mk, guid: OO, hex: GO, hostname: md, html5Email: qk, idnEmail: Vk, integer: FO, ipv4: xO, ipv6: AO, ksuid: bO, lowercase: VO, md5_base64: Hk, md5_base64url: Jk, md5_hex: Kk, nanoid: _O, null: qO, number: LO, rfc5322Email: Zk, sha1_base64: Xk, sha1_base64url: Qk, sha1_hex: Yk, sha256_base64: tP, sha256_base64url: rP, sha256_hex: eP, sha384_base64: iP, sha384_base64url: oP, sha384_hex: nP, sha512_base64: sP, sha512_base64url: uP, sha512_hex: aP, string: UO, time: DO, ulid: gO, undefined: ZO, unicodeEmail: SO, uppercase: WO, uuid: Co, uuid4: Fk, uuid6: Lk, uuid7: Bk, xid: vO }, Symbol.toStringTag, { value: "Module" })), Cr = /* @__PURE__ */ Re("$ZodCheck", (e, t) => {
  var r;
  e._zod ?? (e._zod = {}), e._zod.def = t, (r = e._zod).onattach ?? (r.onattach = []);
}), KO = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, gd = /* @__PURE__ */ Re("$ZodCheckLessThan", (e, t) => {
  Cr.init(e, t);
  const r = KO[typeof t.value];
  e._zod.onattach.push((i) => {
    const n = i._zod.bag, o = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? n.maximum = t.value : n.exclusiveMaximum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value <= t.value : i.value < t.value) || i.issues.push({
      origin: r,
      code: "too_big",
      maximum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), vd = /* @__PURE__ */ Re("$ZodCheckGreaterThan", (e, t) => {
  Cr.init(e, t);
  const r = KO[typeof t.value];
  e._zod.onattach.push((i) => {
    const n = i._zod.bag, o = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? n.minimum = t.value : n.exclusiveMinimum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value >= t.value : i.value > t.value) || i.issues.push({
      origin: r,
      code: "too_small",
      minimum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), HO = /* @__PURE__ */ Re("$ZodCheckMultipleOf", (e, t) => {
  Cr.init(e, t), e._zod.onattach.push((r) => {
    var i;
    (i = r._zod.bag).multipleOf ?? (i.multipleOf = t.value);
  }), e._zod.check = (r) => {
    if (typeof r.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof r.value == "bigint" ? r.value % t.value === BigInt(0) : G1(r.value, t.value) === 0) || r.issues.push({
      origin: typeof r.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), JO = /* @__PURE__ */ Re("$ZodCheckNumberFormat", (e, t) => {
  Cr.init(e, t), t.format = t.format || "float64";
  const r = t.format?.includes("int"), i = r ? "int" : "number", [n, o] = Y1[t.format];
  e._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = t.format, a.minimum = n, a.maximum = o, r && (a.pattern = FO);
  }), e._zod.check = (s) => {
    const a = s.value;
    if (r) {
      if (!Number.isInteger(a)) {
        s.issues.push({
          expected: i,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: a,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(a)) {
        a > 0 ? s.issues.push({
          input: a,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        }) : s.issues.push({
          input: a,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        });
        return;
      }
    }
    a < n && s.issues.push({
      origin: "number",
      input: a,
      code: "too_small",
      minimum: n,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), a > o && s.issues.push({
      origin: "number",
      input: a,
      code: "too_big",
      maximum: o,
      inst: e
    });
  };
}), YO = /* @__PURE__ */ Re("$ZodCheckBigIntFormat", (e, t) => {
  Cr.init(e, t);
  const [r, i] = X1[t.format];
  e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.format = t.format, o.minimum = r, o.maximum = i;
  }), e._zod.check = (n) => {
    const o = n.value;
    o < r && n.issues.push({
      origin: "bigint",
      input: o,
      code: "too_small",
      minimum: r,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), o > i && n.issues.push({
      origin: "bigint",
      input: o,
      code: "too_big",
      maximum: i,
      inst: e
    });
  };
}), XO = /* @__PURE__ */ Re("$ZodCheckMaxSize", (e, t) => {
  var r;
  Cr.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !ho(n) && n.size !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const n = i.value;
    n.size <= t.maximum || i.issues.push({
      origin: $u(n),
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), QO = /* @__PURE__ */ Re("$ZodCheckMinSize", (e, t) => {
  var r;
  Cr.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !ho(n) && n.size !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const n = i.value;
    n.size >= t.minimum || i.issues.push({
      origin: $u(n),
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), e$ = /* @__PURE__ */ Re("$ZodCheckSizeEquals", (e, t) => {
  var r;
  Cr.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !ho(n) && n.size !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.minimum = t.size, n.maximum = t.size, n.size = t.size;
  }), e._zod.check = (i) => {
    const n = i.value, o = n.size;
    if (o === t.size)
      return;
    const s = o > t.size;
    i.issues.push({
      origin: $u(n),
      ...s ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), t$ = /* @__PURE__ */ Re("$ZodCheckMaxLength", (e, t) => {
  var r;
  Cr.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !ho(n) && n.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const n = i.value;
    if (n.length <= t.maximum)
      return;
    const s = Su(n);
    i.issues.push({
      origin: s,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), r$ = /* @__PURE__ */ Re("$ZodCheckMinLength", (e, t) => {
  var r;
  Cr.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !ho(n) && n.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const n = i.value;
    if (n.length >= t.minimum)
      return;
    const s = Su(n);
    i.issues.push({
      origin: s,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), n$ = /* @__PURE__ */ Re("$ZodCheckLengthEquals", (e, t) => {
  var r;
  Cr.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !ho(n) && n.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.minimum = t.length, n.maximum = t.length, n.length = t.length;
  }), e._zod.check = (i) => {
    const n = i.value, o = n.length;
    if (o === t.length)
      return;
    const s = Su(n), a = o > t.length;
    i.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Ga = /* @__PURE__ */ Re("$ZodCheckStringFormat", (e, t) => {
  var r, i;
  Cr.init(e, t), e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.format = t.format, t.pattern && (o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t.pattern));
  }), t.pattern ? (r = e._zod).check ?? (r.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: n.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (i = e._zod).check ?? (i.check = () => {
  });
}), i$ = /* @__PURE__ */ Re("$ZodCheckRegex", (e, t) => {
  Ga.init(e, t), e._zod.check = (r) => {
    t.pattern.lastIndex = 0, !t.pattern.test(r.value) && r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: r.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), o$ = /* @__PURE__ */ Re("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = VO), Ga.init(e, t);
}), a$ = /* @__PURE__ */ Re("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = WO), Ga.init(e, t);
}), s$ = /* @__PURE__ */ Re("$ZodCheckIncludes", (e, t) => {
  Cr.init(e, t);
  const r = Ci(t.includes), i = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${r}` : r);
  t.pattern = i, e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(i);
  }), e._zod.check = (n) => {
    n.value.includes(t.includes, t.position) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), u$ = /* @__PURE__ */ Re("$ZodCheckStartsWith", (e, t) => {
  Cr.init(e, t);
  const r = new RegExp(`^${Ci(t.prefix)}.*`);
  t.pattern ?? (t.pattern = r), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.startsWith(t.prefix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), c$ = /* @__PURE__ */ Re("$ZodCheckEndsWith", (e, t) => {
  Cr.init(e, t);
  const r = new RegExp(`.*${Ci(t.suffix)}$`);
  t.pattern ?? (t.pattern = r), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.endsWith(t.suffix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function zg(e, t, r) {
  e.issues.length && t.issues.push(...Vn(r, e.issues));
}
const l$ = /* @__PURE__ */ Re("$ZodCheckProperty", (e, t) => {
  Cr.init(e, t), e._zod.check = (r) => {
    const i = t.schema._zod.run({
      value: r.value[t.property],
      issues: []
    }, {});
    if (i instanceof Promise)
      return i.then((n) => zg(n, r, t.property));
    zg(i, r, t.property);
  };
}), f$ = /* @__PURE__ */ Re("$ZodCheckMimeType", (e, t) => {
  Cr.init(e, t);
  const r = new Set(t.mime);
  e._zod.onattach.push((i) => {
    i._zod.bag.mime = t.mime;
  }), e._zod.check = (i) => {
    r.has(i.value.type) || i.issues.push({
      code: "invalid_value",
      values: t.mime,
      input: i.value.type,
      inst: e,
      continue: !t.abort
    });
  };
}), h$ = /* @__PURE__ */ Re("$ZodCheckOverwrite", (e, t) => {
  Cr.init(e, t), e._zod.check = (r) => {
    r.value = t.tx(r.value);
  };
});
let p$ = class {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const i = t.split(`
`).filter((s) => s), n = Math.min(...i.map((s) => s.length - s.trimStart().length)), o = i.map((s) => s.slice(n)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of o)
      this.content.push(s);
  }
  compile() {
    const t = Function, r = this?.args, n = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new t(...r, n.join(`
`));
  }
};
const d$ = {
  major: 4,
  minor: 1,
  patch: 12
}, Ct = /* @__PURE__ */ Re("$ZodType", (e, t) => {
  var r;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = d$;
  const i = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && i.unshift(e);
  for (const n of i)
    for (const o of n._zod.onattach)
      o(e);
  if (i.length === 0)
    (r = e._zod).deferred ?? (r.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const n = (s, a, u) => {
      let c = Ki(s), f;
      for (const h of a) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(s))
            continue;
        } else if (c)
          continue;
        const y = s.issues.length, p = h._zod.check(s);
        if (p instanceof Promise && u?.async === !1)
          throw new Xi();
        if (f || p instanceof Promise)
          f = (f ?? Promise.resolve()).then(async () => {
            await p, s.issues.length !== y && (c || (c = Ki(s, y)));
          });
        else {
          if (s.issues.length === y)
            continue;
          c || (c = Ki(s, y));
        }
      }
      return f ? f.then(() => s) : s;
    }, o = (s, a, u) => {
      if (Ki(s))
        return s.aborted = !0, s;
      const c = n(a, i, u);
      if (c instanceof Promise) {
        if (u.async === !1)
          throw new Xi();
        return c.then((f) => e._zod.parse(f, u));
      }
      return e._zod.parse(c, u);
    };
    e._zod.run = (s, a) => {
      if (a.skipChecks)
        return e._zod.parse(s, a);
      if (a.direction === "backward") {
        const c = e._zod.parse({ value: s.value, issues: [] }, { ...a, skipChecks: !0 });
        return c instanceof Promise ? c.then((f) => o(f, s, a)) : o(c, s, a);
      }
      const u = e._zod.parse(s, a);
      if (u instanceof Promise) {
        if (a.async === !1)
          throw new Xi();
        return u.then((c) => n(c, i, a));
      }
      return n(u, i, a);
    };
  }
  e["~standard"] = {
    validate: (n) => {
      try {
        const o = pO(e, n);
        return o.success ? { value: o.data } : { issues: o.error?.issues };
      } catch {
        return dO(e, n).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), Ka = /* @__PURE__ */ Re("$ZodString", (e, t) => {
  Ct.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? UO(e._zod.bag), e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = String(r.value);
      } catch {
      }
    return typeof r.value == "string" || r.issues.push({
      expected: "string",
      code: "invalid_type",
      input: r.value,
      inst: e
    }), r;
  };
}), dr = /* @__PURE__ */ Re("$ZodStringFormat", (e, t) => {
  Ga.init(e, t), Ka.init(e, t);
}), m$ = /* @__PURE__ */ Re("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = OO), dr.init(e, t);
}), y$ = /* @__PURE__ */ Re("$ZodUUID", (e, t) => {
  if (t.version) {
    const i = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (i === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = Co(i));
  } else
    t.pattern ?? (t.pattern = Co());
  dr.init(e, t);
}), g$ = /* @__PURE__ */ Re("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = $O), dr.init(e, t);
}), v$ = /* @__PURE__ */ Re("$ZodURL", (e, t) => {
  dr.init(e, t), e._zod.check = (r) => {
    try {
      const i = r.value.trim(), n = new URL(i);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(n.hostname) || r.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: md.source,
        input: r.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(n.protocol.endsWith(":") ? n.protocol.slice(0, -1) : n.protocol) || r.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: r.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? r.value = n.href : r.value = i;
      return;
    } catch {
      r.issues.push({
        code: "invalid_format",
        format: "url",
        input: r.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), b$ = /* @__PURE__ */ Re("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = EO()), dr.init(e, t);
}), _$ = /* @__PURE__ */ Re("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = _O), dr.init(e, t);
}), w$ = /* @__PURE__ */ Re("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = mO), dr.init(e, t);
}), O$ = /* @__PURE__ */ Re("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = yO), dr.init(e, t);
}), $$ = /* @__PURE__ */ Re("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = gO), dr.init(e, t);
}), S$ = /* @__PURE__ */ Re("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = vO), dr.init(e, t);
}), E$ = /* @__PURE__ */ Re("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = bO), dr.init(e, t);
}), x$ = /* @__PURE__ */ Re("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = zO(t)), dr.init(e, t);
}), A$ = /* @__PURE__ */ Re("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = CO), dr.init(e, t);
}), j$ = /* @__PURE__ */ Re("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = DO(t)), dr.init(e, t);
}), k$ = /* @__PURE__ */ Re("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = wO), dr.init(e, t);
}), P$ = /* @__PURE__ */ Re("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = xO), dr.init(e, t), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.format = "ipv4";
  });
}), I$ = /* @__PURE__ */ Re("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = AO), dr.init(e, t), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.format = "ipv6";
  }), e._zod.check = (r) => {
    try {
      new URL(`http://[${r.value}]`);
    } catch {
      r.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: r.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), T$ = /* @__PURE__ */ Re("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = jO), dr.init(e, t);
}), N$ = /* @__PURE__ */ Re("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = kO), dr.init(e, t), e._zod.check = (r) => {
    const i = r.value.split("/");
    try {
      if (i.length !== 2)
        throw new Error();
      const [n, o] = i;
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${n}]`);
    } catch {
      r.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: r.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function bd(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const C$ = /* @__PURE__ */ Re("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = PO), dr.init(e, t), e._zod.onattach.push((r) => {
    r._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (r) => {
    bd(r.value) || r.issues.push({
      code: "invalid_format",
      format: "base64",
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function R$(e) {
  if (!dd.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (i) => i === "-" ? "+" : "/"), r = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return bd(r);
}
const D$ = /* @__PURE__ */ Re("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = dd), dr.init(e, t), e._zod.onattach.push((r) => {
    r._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (r) => {
    R$(r.value) || r.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), z$ = /* @__PURE__ */ Re("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = TO), dr.init(e, t);
});
function U$(e, t = null) {
  try {
    const r = e.split(".");
    if (r.length !== 3)
      return !1;
    const [i] = r;
    if (!i)
      return !1;
    const n = JSON.parse(atob(i));
    return !("typ" in n && n?.typ !== "JWT" || !n.alg || t && (!("alg" in n) || n.alg !== t));
  } catch {
    return !1;
  }
}
const M$ = /* @__PURE__ */ Re("$ZodJWT", (e, t) => {
  dr.init(e, t), e._zod.check = (r) => {
    U$(r.value, t.alg) || r.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), F$ = /* @__PURE__ */ Re("$ZodCustomStringFormat", (e, t) => {
  dr.init(e, t), e._zod.check = (r) => {
    t.fn(r.value) || r.issues.push({
      code: "invalid_format",
      format: t.format,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), _d = /* @__PURE__ */ Re("$ZodNumber", (e, t) => {
  Ct.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? LO, e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = Number(r.value);
      } catch {
      }
    const n = r.value;
    if (typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n))
      return r;
    const o = typeof n == "number" ? Number.isNaN(n) ? "NaN" : Number.isFinite(n) ? void 0 : "Infinity" : void 0;
    return r.issues.push({
      expected: "number",
      code: "invalid_type",
      input: n,
      inst: e,
      ...o ? { received: o } : {}
    }), r;
  };
}), L$ = /* @__PURE__ */ Re("$ZodNumber", (e, t) => {
  JO.init(e, t), _d.init(e, t);
}), wd = /* @__PURE__ */ Re("$ZodBoolean", (e, t) => {
  Ct.init(e, t), e._zod.pattern = BO, e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = !!r.value;
      } catch {
      }
    const n = r.value;
    return typeof n == "boolean" || r.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), Od = /* @__PURE__ */ Re("$ZodBigInt", (e, t) => {
  Ct.init(e, t), e._zod.pattern = MO, e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = BigInt(r.value);
      } catch {
      }
    return typeof r.value == "bigint" || r.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: r.value,
      inst: e
    }), r;
  };
}), B$ = /* @__PURE__ */ Re("$ZodBigInt", (e, t) => {
  YO.init(e, t), Od.init(e, t);
}), q$ = /* @__PURE__ */ Re("$ZodSymbol", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    return typeof n == "symbol" || r.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), Z$ = /* @__PURE__ */ Re("$ZodUndefined", (e, t) => {
  Ct.init(e, t), e._zod.pattern = ZO, e._zod.values = /* @__PURE__ */ new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (r, i) => {
    const n = r.value;
    return typeof n > "u" || r.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), V$ = /* @__PURE__ */ Re("$ZodNull", (e, t) => {
  Ct.init(e, t), e._zod.pattern = qO, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (r, i) => {
    const n = r.value;
    return n === null || r.issues.push({
      expected: "null",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), W$ = /* @__PURE__ */ Re("$ZodAny", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r) => r;
}), G$ = /* @__PURE__ */ Re("$ZodUnknown", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r) => r;
}), K$ = /* @__PURE__ */ Re("$ZodNever", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => (r.issues.push({
    expected: "never",
    code: "invalid_type",
    input: r.value,
    inst: e
  }), r);
}), H$ = /* @__PURE__ */ Re("$ZodVoid", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    return typeof n > "u" || r.issues.push({
      expected: "void",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), J$ = /* @__PURE__ */ Re("$ZodDate", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = new Date(r.value);
      } catch {
      }
    const n = r.value, o = n instanceof Date;
    return o && !Number.isNaN(n.getTime()) || r.issues.push({
      expected: "date",
      code: "invalid_type",
      input: n,
      ...o ? { received: "Invalid Date" } : {},
      inst: e
    }), r;
  };
});
function Ug(e, t, r) {
  e.issues.length && t.issues.push(...Vn(r, e.issues)), t.value[r] = e.value;
}
const Y$ = /* @__PURE__ */ Re("$ZodArray", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    if (!Array.isArray(n))
      return r.issues.push({
        expected: "array",
        code: "invalid_type",
        input: n,
        inst: e
      }), r;
    r.value = Array(n.length);
    const o = [];
    for (let s = 0; s < n.length; s++) {
      const a = n[s], u = t.element._zod.run({
        value: a,
        issues: []
      }, i);
      u instanceof Promise ? o.push(u.then((c) => Ug(c, r, s))) : Ug(u, r, s);
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
});
function Gs(e, t, r, i) {
  e.issues.length && t.issues.push(...Vn(r, e.issues)), e.value === void 0 ? r in i && (t.value[r] = void 0) : t.value[r] = e.value;
}
function X$(e) {
  const t = Object.keys(e.shape);
  for (const i of t)
    if (!e.shape?.[i]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${i}": expected a Zod schema`);
  const r = J1(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(r)
  };
}
function Q$(e, t, r, i, n, o) {
  const s = [], a = n.keySet, u = n.catchall._zod, c = u.def.type;
  for (const f of Object.keys(t)) {
    if (a.has(f))
      continue;
    if (c === "never") {
      s.push(f);
      continue;
    }
    const h = u.run({ value: t[f], issues: [] }, i);
    h instanceof Promise ? e.push(h.then((y) => Gs(y, r, f, t))) : Gs(h, r, f, t);
  }
  return s.length && r.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: t,
    inst: o
  }), e.length ? Promise.all(e).then(() => r) : r;
}
const eS = /* @__PURE__ */ Re("$ZodObject", (e, t) => {
  if (Ct.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const a = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const u = { ...a };
        return Object.defineProperty(t, "shape", {
          value: u
        }), u;
      }
    });
  }
  const i = Fa(() => X$(t));
  Wt(e._zod, "propValues", () => {
    const a = t.shape, u = {};
    for (const c in a) {
      const f = a[c]._zod;
      if (f.values) {
        u[c] ?? (u[c] = /* @__PURE__ */ new Set());
        for (const h of f.values)
          u[c].add(h);
      }
    }
    return u;
  });
  const n = To, o = t.catchall;
  let s;
  e._zod.parse = (a, u) => {
    s ?? (s = i.value);
    const c = a.value;
    if (!n(c))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: c,
        inst: e
      }), a;
    a.value = {};
    const f = [], h = s.shape;
    for (const y of s.keys) {
      const l = h[y]._zod.run({ value: c[y], issues: [] }, u);
      l instanceof Promise ? f.push(l.then((d) => Gs(d, a, y, c))) : Gs(l, a, y, c);
    }
    return o ? Q$(f, c, a, u, i.value, e) : f.length ? Promise.all(f).then(() => a) : a;
  };
}), tS = /* @__PURE__ */ Re("$ZodObjectJIT", (e, t) => {
  eS.init(e, t);
  const r = e._zod.parse, i = Fa(() => X$(t)), n = (y) => {
    const p = new p$(["shape", "payload", "ctx"]), l = i.value, d = (_) => {
      const b = Jh(_);
      return `shape[${b}]._zod.run({ value: input[${b}], issues: [] }, ctx)`;
    };
    p.write("const input = payload.value;");
    const v = /* @__PURE__ */ Object.create(null);
    let m = 0;
    for (const _ of l.keys)
      v[_] = `key_${m++}`;
    p.write("const newResult = {};");
    for (const _ of l.keys) {
      const b = v[_], w = Jh(_);
      p.write(`const ${b} = ${d(_)};`), p.write(`
        if (${b}.issues.length) {
          payload.issues = payload.issues.concat(${b}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${w}, ...iss.path] : [${w}]
          })));
        }
        
        
        if (${b}.value === undefined) {
          if (${w} in input) {
            newResult[${w}] = undefined;
          }
        } else {
          newResult[${w}] = ${b}.value;
        }
        
      `);
    }
    p.write("payload.value = newResult;"), p.write("return payload;");
    const g = p.compile();
    return (_, b) => g(y, _, b);
  };
  let o;
  const s = To, a = !Zs.jitless, c = a && K1.value, f = t.catchall;
  let h;
  e._zod.parse = (y, p) => {
    h ?? (h = i.value);
    const l = y.value;
    return s(l) ? a && c && p?.async === !1 && p.jitless !== !0 ? (o || (o = n(t.shape)), y = o(y, p), f ? Q$([], l, y, p, h, e) : y) : r(y, p) : (y.issues.push({
      expected: "object",
      code: "invalid_type",
      input: l,
      inst: e
    }), y);
  };
});
function Mg(e, t, r, i) {
  for (const o of e)
    if (o.issues.length === 0)
      return t.value = o.value, t;
  const n = e.filter((o) => !Ki(o));
  return n.length === 1 ? (t.value = n[0].value, n[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: r,
    errors: e.map((o) => o.issues.map((s) => Gn(s, i, pn())))
  }), t);
}
const $d = /* @__PURE__ */ Re("$ZodUnion", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "optin", () => t.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), Wt(e._zod, "optout", () => t.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), Wt(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values))
      return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), Wt(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      const n = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${n.map((o) => wu(o.source)).join("|")})$`);
    }
  });
  const r = t.options.length === 1, i = t.options[0]._zod.run;
  e._zod.parse = (n, o) => {
    if (r)
      return i(n, o);
    let s = !1;
    const a = [];
    for (const u of t.options) {
      const c = u._zod.run({
        value: n.value,
        issues: []
      }, o);
      if (c instanceof Promise)
        a.push(c), s = !0;
      else {
        if (c.issues.length === 0)
          return c;
        a.push(c);
      }
    }
    return s ? Promise.all(a).then((u) => Mg(u, n, e, o)) : Mg(a, n, e, o);
  };
}), rS = /* @__PURE__ */ Re("$ZodDiscriminatedUnion", (e, t) => {
  $d.init(e, t);
  const r = e._zod.parse;
  Wt(e._zod, "propValues", () => {
    const n = {};
    for (const o of t.options) {
      const s = o._zod.propValues;
      if (!s || Object.keys(s).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const [a, u] of Object.entries(s)) {
        n[a] || (n[a] = /* @__PURE__ */ new Set());
        for (const c of u)
          n[a].add(c);
      }
    }
    return n;
  });
  const i = Fa(() => {
    const n = t.options, o = /* @__PURE__ */ new Map();
    for (const s of n) {
      const a = s._zod.propValues?.[t.discriminator];
      if (!a || a.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);
      for (const u of a) {
        if (o.has(u))
          throw new Error(`Duplicate discriminator value "${String(u)}"`);
        o.set(u, s);
      }
    }
    return o;
  });
  e._zod.parse = (n, o) => {
    const s = n.value;
    if (!To(s))
      return n.issues.push({
        code: "invalid_type",
        expected: "object",
        input: s,
        inst: e
      }), n;
    const a = i.value.get(s?.[t.discriminator]);
    return a ? a._zod.run(n, o) : t.unionFallback ? r(n, o) : (n.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: s,
      path: [t.discriminator],
      inst: e
    }), n);
  };
}), nS = /* @__PURE__ */ Re("$ZodIntersection", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value, o = t.left._zod.run({ value: n, issues: [] }, i), s = t.right._zod.run({ value: n, issues: [] }, i);
    return o instanceof Promise || s instanceof Promise ? Promise.all([o, s]).then(([u, c]) => Fg(r, u, c)) : Fg(r, o, s);
  };
});
function Qh(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (to(e) && to(t)) {
    const r = Object.keys(t), i = Object.keys(e).filter((o) => r.indexOf(o) !== -1), n = { ...e, ...t };
    for (const o of i) {
      const s = Qh(e[o], t[o]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...s.mergeErrorPath]
        };
      n[o] = s.data;
    }
    return { valid: !0, data: n };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const r = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = t[i], s = Qh(n, o);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...s.mergeErrorPath]
        };
      r.push(s.data);
    }
    return { valid: !0, data: r };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Fg(e, t, r) {
  if (t.issues.length && e.issues.push(...t.issues), r.issues.length && e.issues.push(...r.issues), Ki(e))
    return e;
  const i = Qh(t.value, r.value);
  if (!i.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`);
  return e.value = i.data, e;
}
const Sd = /* @__PURE__ */ Re("$ZodTuple", (e, t) => {
  Ct.init(e, t);
  const r = t.items, i = r.length - [...r].reverse().findIndex((n) => n._zod.optin !== "optional");
  e._zod.parse = (n, o) => {
    const s = n.value;
    if (!Array.isArray(s))
      return n.issues.push({
        input: s,
        inst: e,
        expected: "tuple",
        code: "invalid_type"
      }), n;
    n.value = [];
    const a = [];
    if (!t.rest) {
      const c = s.length > r.length, f = s.length < i - 1;
      if (c || f)
        return n.issues.push({
          ...c ? { code: "too_big", maximum: r.length } : { code: "too_small", minimum: r.length },
          input: s,
          inst: e,
          origin: "array"
        }), n;
    }
    let u = -1;
    for (const c of r) {
      if (u++, u >= s.length && u >= i)
        continue;
      const f = c._zod.run({
        value: s[u],
        issues: []
      }, o);
      f instanceof Promise ? a.push(f.then((h) => ys(h, n, u))) : ys(f, n, u);
    }
    if (t.rest) {
      const c = s.slice(r.length);
      for (const f of c) {
        u++;
        const h = t.rest._zod.run({
          value: f,
          issues: []
        }, o);
        h instanceof Promise ? a.push(h.then((y) => ys(y, n, u))) : ys(h, n, u);
      }
    }
    return a.length ? Promise.all(a).then(() => n) : n;
  };
});
function ys(e, t, r) {
  e.issues.length && t.issues.push(...Vn(r, e.issues)), t.value[r] = e.value;
}
const iS = /* @__PURE__ */ Re("$ZodRecord", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    if (!to(n))
      return r.issues.push({
        expected: "record",
        code: "invalid_type",
        input: n,
        inst: e
      }), r;
    const o = [];
    if (t.keyType._zod.values) {
      const s = t.keyType._zod.values;
      r.value = {};
      for (const u of s)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          const c = t.valueType._zod.run({ value: n[u], issues: [] }, i);
          c instanceof Promise ? o.push(c.then((f) => {
            f.issues.length && r.issues.push(...Vn(u, f.issues)), r.value[u] = f.value;
          })) : (c.issues.length && r.issues.push(...Vn(u, c.issues)), r.value[u] = c.value);
        }
      let a;
      for (const u in n)
        s.has(u) || (a = a ?? [], a.push(u));
      a && a.length > 0 && r.issues.push({
        code: "unrecognized_keys",
        input: n,
        inst: e,
        keys: a
      });
    } else {
      r.value = {};
      for (const s of Reflect.ownKeys(n)) {
        if (s === "__proto__")
          continue;
        const a = t.keyType._zod.run({ value: s, issues: [] }, i);
        if (a instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (a.issues.length) {
          r.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: a.issues.map((c) => Gn(c, i, pn())),
            input: s,
            path: [s],
            inst: e
          }), r.value[a.value] = a.value;
          continue;
        }
        const u = t.valueType._zod.run({ value: n[s], issues: [] }, i);
        u instanceof Promise ? o.push(u.then((c) => {
          c.issues.length && r.issues.push(...Vn(s, c.issues)), r.value[a.value] = c.value;
        })) : (u.issues.length && r.issues.push(...Vn(s, u.issues)), r.value[a.value] = u.value);
      }
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
}), oS = /* @__PURE__ */ Re("$ZodMap", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    if (!(n instanceof Map))
      return r.issues.push({
        expected: "map",
        code: "invalid_type",
        input: n,
        inst: e
      }), r;
    const o = [];
    r.value = /* @__PURE__ */ new Map();
    for (const [s, a] of n) {
      const u = t.keyType._zod.run({ value: s, issues: [] }, i), c = t.valueType._zod.run({ value: a, issues: [] }, i);
      u instanceof Promise || c instanceof Promise ? o.push(Promise.all([u, c]).then(([f, h]) => {
        Lg(f, h, r, s, n, e, i);
      })) : Lg(u, c, r, s, n, e, i);
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
});
function Lg(e, t, r, i, n, o, s) {
  e.issues.length && (Ws.has(typeof i) ? r.issues.push(...Vn(i, e.issues)) : r.issues.push({
    code: "invalid_key",
    origin: "map",
    input: n,
    inst: o,
    issues: e.issues.map((a) => Gn(a, s, pn()))
  })), t.issues.length && (Ws.has(typeof i) ? r.issues.push(...Vn(i, t.issues)) : r.issues.push({
    origin: "map",
    code: "invalid_element",
    input: n,
    inst: o,
    key: i,
    issues: t.issues.map((a) => Gn(a, s, pn()))
  })), r.value.set(e.value, t.value);
}
const aS = /* @__PURE__ */ Re("$ZodSet", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    if (!(n instanceof Set))
      return r.issues.push({
        input: n,
        inst: e,
        expected: "set",
        code: "invalid_type"
      }), r;
    const o = [];
    r.value = /* @__PURE__ */ new Set();
    for (const s of n) {
      const a = t.valueType._zod.run({ value: s, issues: [] }, i);
      a instanceof Promise ? o.push(a.then((u) => Bg(u, r))) : Bg(a, r);
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
});
function Bg(e, t) {
  e.issues.length && t.issues.push(...e.issues), t.value.add(e.value);
}
const sS = /* @__PURE__ */ Re("$ZodEnum", (e, t) => {
  Ct.init(e, t);
  const r = td(t.entries), i = new Set(r);
  e._zod.values = i, e._zod.pattern = new RegExp(`^(${r.filter((n) => Ws.has(typeof n)).map((n) => typeof n == "string" ? Ci(n) : n.toString()).join("|")})$`), e._zod.parse = (n, o) => {
    const s = n.value;
    return i.has(s) || n.issues.push({
      code: "invalid_value",
      values: r,
      input: s,
      inst: e
    }), n;
  };
}), uS = /* @__PURE__ */ Re("$ZodLiteral", (e, t) => {
  if (Ct.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  e._zod.values = new Set(t.values), e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? Ci(r) : r ? Ci(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, i) => {
    const n = r.value;
    return e._zod.values.has(n) || r.issues.push({
      code: "invalid_value",
      values: t.values,
      input: n,
      inst: e
    }), r;
  };
}), cS = /* @__PURE__ */ Re("$ZodFile", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    return n instanceof File || r.issues.push({
      expected: "file",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), lS = /* @__PURE__ */ Re("$ZodTransform", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      throw new _u(e.constructor.name);
    const n = t.transform(r.value, r);
    if (i.async)
      return (n instanceof Promise ? n : Promise.resolve(n)).then((s) => (r.value = s, r));
    if (n instanceof Promise)
      throw new Xi();
    return r.value = n, r;
  };
});
function qg(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const fS = /* @__PURE__ */ Re("$ZodOptional", (e, t) => {
  Ct.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", Wt(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), Wt(e._zod, "pattern", () => {
    const r = t.innerType._zod.pattern;
    return r ? new RegExp(`^(${wu(r.source)})?$`) : void 0;
  }), e._zod.parse = (r, i) => {
    if (t.innerType._zod.optin === "optional") {
      const n = t.innerType._zod.run(r, i);
      return n instanceof Promise ? n.then((o) => qg(o, r.value)) : qg(n, r.value);
    }
    return r.value === void 0 ? r : t.innerType._zod.run(r, i);
  };
}), hS = /* @__PURE__ */ Re("$ZodNullable", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "optin", () => t.innerType._zod.optin), Wt(e._zod, "optout", () => t.innerType._zod.optout), Wt(e._zod, "pattern", () => {
    const r = t.innerType._zod.pattern;
    return r ? new RegExp(`^(${wu(r.source)}|null)$`) : void 0;
  }), Wt(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (r, i) => r.value === null ? r : t.innerType._zod.run(r, i);
}), pS = /* @__PURE__ */ Re("$ZodDefault", (e, t) => {
  Ct.init(e, t), e._zod.optin = "optional", Wt(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(r, i);
    if (r.value === void 0)
      return r.value = t.defaultValue, r;
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => Zg(o, t)) : Zg(n, t);
  };
});
function Zg(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const dS = /* @__PURE__ */ Re("$ZodPrefault", (e, t) => {
  Ct.init(e, t), e._zod.optin = "optional", Wt(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (r, i) => (i.direction === "backward" || r.value === void 0 && (r.value = t.defaultValue), t.innerType._zod.run(r, i));
}), mS = /* @__PURE__ */ Re("$ZodNonOptional", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "values", () => {
    const r = t.innerType._zod.values;
    return r ? new Set([...r].filter((i) => i !== void 0)) : void 0;
  }), e._zod.parse = (r, i) => {
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => Vg(o, e)) : Vg(n, e);
  };
});
function Vg(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const yS = /* @__PURE__ */ Re("$ZodSuccess", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      throw new _u("ZodSuccess");
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => (r.value = o.issues.length === 0, r)) : (r.value = n.issues.length === 0, r);
  };
}), gS = /* @__PURE__ */ Re("$ZodCatch", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "optin", () => t.innerType._zod.optin), Wt(e._zod, "optout", () => t.innerType._zod.optout), Wt(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(r, i);
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => (r.value = o.value, o.issues.length && (r.value = t.catchValue({
      ...r,
      error: {
        issues: o.issues.map((s) => Gn(s, i, pn()))
      },
      input: r.value
    }), r.issues = []), r)) : (r.value = n.value, n.issues.length && (r.value = t.catchValue({
      ...r,
      error: {
        issues: n.issues.map((o) => Gn(o, i, pn()))
      },
      input: r.value
    }), r.issues = []), r);
  };
}), vS = /* @__PURE__ */ Re("$ZodNaN", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => ((typeof r.value != "number" || !Number.isNaN(r.value)) && r.issues.push({
    input: r.value,
    inst: e,
    expected: "nan",
    code: "invalid_type"
  }), r);
}), bS = /* @__PURE__ */ Re("$ZodPipe", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "values", () => t.in._zod.values), Wt(e._zod, "optin", () => t.in._zod.optin), Wt(e._zod, "optout", () => t.out._zod.optout), Wt(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (r, i) => {
    if (i.direction === "backward") {
      const o = t.out._zod.run(r, i);
      return o instanceof Promise ? o.then((s) => gs(s, t.in, i)) : gs(o, t.in, i);
    }
    const n = t.in._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => gs(o, t.out, i)) : gs(n, t.out, i);
  };
});
function gs(e, t, r) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, r);
}
const Ed = /* @__PURE__ */ Re("$ZodCodec", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "values", () => t.in._zod.values), Wt(e._zod, "optin", () => t.in._zod.optin), Wt(e._zod, "optout", () => t.out._zod.optout), Wt(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (r, i) => {
    if ((i.direction || "forward") === "forward") {
      const o = t.in._zod.run(r, i);
      return o instanceof Promise ? o.then((s) => vs(s, t, i)) : vs(o, t, i);
    } else {
      const o = t.out._zod.run(r, i);
      return o instanceof Promise ? o.then((s) => vs(s, t, i)) : vs(o, t, i);
    }
  };
});
function vs(e, t, r) {
  if (e.issues.length)
    return e.aborted = !0, e;
  if ((r.direction || "forward") === "forward") {
    const n = t.transform(e.value, e);
    return n instanceof Promise ? n.then((o) => bs(e, o, t.out, r)) : bs(e, n, t.out, r);
  } else {
    const n = t.reverseTransform(e.value, e);
    return n instanceof Promise ? n.then((o) => bs(e, o, t.in, r)) : bs(e, n, t.in, r);
  }
}
function bs(e, t, r, i) {
  return e.issues.length ? (e.aborted = !0, e) : r._zod.run({ value: t, issues: e.issues }, i);
}
const _S = /* @__PURE__ */ Re("$ZodReadonly", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "propValues", () => t.innerType._zod.propValues), Wt(e._zod, "values", () => t.innerType._zod.values), Wt(e._zod, "optin", () => t.innerType._zod.optin), Wt(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(r, i);
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then(Wg) : Wg(n);
  };
});
function Wg(e) {
  return e.value = Object.freeze(e.value), e;
}
const wS = /* @__PURE__ */ Re("$ZodTemplateLiteral", (e, t) => {
  Ct.init(e, t);
  const r = [];
  for (const i of t.parts)
    if (typeof i == "object" && i !== null) {
      if (!i._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...i._zod.traits].shift()}`);
      const n = i._zod.pattern instanceof RegExp ? i._zod.pattern.source : i._zod.pattern;
      if (!n)
        throw new Error(`Invalid template literal part: ${i._zod.traits}`);
      const o = n.startsWith("^") ? 1 : 0, s = n.endsWith("$") ? n.length - 1 : n.length;
      r.push(n.slice(o, s));
    } else if (i === null || H1.has(typeof i))
      r.push(Ci(`${i}`));
    else
      throw new Error(`Invalid template literal part: ${i}`);
  e._zod.pattern = new RegExp(`^${r.join("")}$`), e._zod.parse = (i, n) => typeof i.value != "string" ? (i.issues.push({
    input: i.value,
    inst: e,
    expected: "template_literal",
    code: "invalid_type"
  }), i) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(i.value) || i.issues.push({
    input: i.value,
    inst: e,
    code: "invalid_format",
    format: t.format ?? "template_literal",
    pattern: e._zod.pattern.source
  }), i);
}), OS = /* @__PURE__ */ Re("$ZodFunction", (e, t) => (Ct.init(e, t), e._def = t, e._zod.def = t, e.implement = (r) => {
  if (typeof r != "function")
    throw new Error("implement() must be called with a function");
  return function(...i) {
    const n = e._def.input ? Yh(e._def.input, i) : i, o = Reflect.apply(r, this, n);
    return e._def.output ? Yh(e._def.output, o) : o;
  };
}, e.implementAsync = (r) => {
  if (typeof r != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...i) {
    const n = e._def.input ? await Xh(e._def.input, i) : i, o = await Reflect.apply(r, this, n);
    return e._def.output ? await Xh(e._def.output, o) : o;
  };
}, e._zod.parse = (r, i) => typeof r.value != "function" ? (r.issues.push({
  code: "invalid_type",
  expected: "function",
  input: r.value,
  inst: e
}), r) : (e._def.output && e._def.output._zod.def.type === "promise" ? r.value = e.implementAsync(r.value) : r.value = e.implement(r.value), r), e.input = (...r) => {
  const i = e.constructor;
  return Array.isArray(r[0]) ? new i({
    type: "function",
    input: new Sd({
      type: "tuple",
      items: r[0],
      rest: r[1]
    }),
    output: e._def.output
  }) : new i({
    type: "function",
    input: r[0],
    output: e._def.output
  });
}, e.output = (r) => {
  const i = e.constructor;
  return new i({
    type: "function",
    input: e._def.input,
    output: r
  });
}, e)), $S = /* @__PURE__ */ Re("$ZodPromise", (e, t) => {
  Ct.init(e, t), e._zod.parse = (r, i) => Promise.resolve(r.value).then((n) => t.innerType._zod.run({ value: n, issues: [] }, i));
}), SS = /* @__PURE__ */ Re("$ZodLazy", (e, t) => {
  Ct.init(e, t), Wt(e._zod, "innerType", () => t.getter()), Wt(e._zod, "pattern", () => e._zod.innerType._zod.pattern), Wt(e._zod, "propValues", () => e._zod.innerType._zod.propValues), Wt(e._zod, "optin", () => e._zod.innerType._zod.optin ?? void 0), Wt(e._zod, "optout", () => e._zod.innerType._zod.optout ?? void 0), e._zod.parse = (r, i) => e._zod.innerType._zod.run(r, i);
}), ES = /* @__PURE__ */ Re("$ZodCustom", (e, t) => {
  Cr.init(e, t), Ct.init(e, t), e._zod.parse = (r, i) => r, e._zod.check = (r) => {
    const i = r.value, n = t.fn(i);
    if (n instanceof Promise)
      return n.then((o) => Gg(o, r, i, e));
    Gg(n, r, i, e);
  };
});
function Gg(e, t, r, i) {
  if (!e) {
    const n = {
      code: "custom",
      input: r,
      inst: i,
      // incorporates params.error into issue reporting
      path: [...i._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !i._zod.def.abort
      // params: inst._zod.def.params,
    };
    i._zod.def.params && (n.params = i._zod.def.params), t.issues.push(No(n));
  }
}
const cP = () => {
  const e = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${n.expected}، ولكن تم إدخال ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `مدخلات غير مقبولة: يفترض إدخال ${jt(n.values[0])}` : `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? ` أكبر من اللازم: يفترض أن تكون ${n.origin ?? "القيمة"} ${o} ${n.maximum.toString()} ${s.unit ?? "عنصر"}` : `أكبر من اللازم: يفترض أن تكون ${n.origin ?? "القيمة"} ${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `أصغر من اللازم: يفترض لـ ${n.origin} أن يكون ${o} ${n.minimum.toString()} ${s.unit}` : `أصغر من اللازم: يفترض لـ ${n.origin} أن يكون ${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `نَص غير مقبول: يجب أن يبدأ بـ "${n.prefix}"` : o.format === "ends_with" ? `نَص غير مقبول: يجب أن ينتهي بـ "${o.suffix}"` : o.format === "includes" ? `نَص غير مقبول: يجب أن يتضمَّن "${o.includes}"` : o.format === "regex" ? `نَص غير مقبول: يجب أن يطابق النمط ${o.pattern}` : `${i[o.format] ?? n.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${n.divisor}`;
      case "unrecognized_keys":
        return `معرف${n.keys.length > 1 ? "ات" : ""} غريب${n.keys.length > 1 ? "ة" : ""}: ${it(n.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${n.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${n.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
function lP() {
  return {
    localeError: cP()
  };
}
const fP = () => {
  const e = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${n.expected}, daxil olan ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Yanlış dəyər: gözlənilən ${jt(n.values[0])}` : `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Çox böyük: gözlənilən ${n.origin ?? "dəyər"} ${o}${n.maximum.toString()} ${s.unit ?? "element"}` : `Çox böyük: gözlənilən ${n.origin ?? "dəyər"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Çox kiçik: gözlənilən ${n.origin} ${o}${n.minimum.toString()} ${s.unit}` : `Çox kiçik: gözlənilən ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Yanlış mətn: "${o.prefix}" ilə başlamalıdır` : o.format === "ends_with" ? `Yanlış mətn: "${o.suffix}" ilə bitməlidir` : o.format === "includes" ? `Yanlış mətn: "${o.includes}" daxil olmalıdır` : o.format === "regex" ? `Yanlış mətn: ${o.pattern} şablonuna uyğun olmalıdır` : `Yanlış ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${n.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${n.keys.length > 1 ? "lar" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${n.origin} daxilində yanlış dəyər`;
      default:
        return "Yanlış dəyər";
    }
  };
};
function hP() {
  return {
    localeError: fP()
  };
}
function Kg(e, t, r, i) {
  const n = Math.abs(e), o = n % 10, s = n % 100;
  return s >= 11 && s <= 19 ? i : o === 1 ? t : o >= 2 && o <= 4 ? r : i;
}
const pP = () => {
  const e = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "лік";
      case "object": {
        if (Array.isArray(n))
          return "масіў";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${n.expected}, атрымана ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Няправільны ўвод: чакалася ${jt(n.values[0])}` : `Няправільны варыянт: чакаўся адзін з ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        if (s) {
          const a = Number(n.maximum), u = Kg(a, s.unit.one, s.unit.few, s.unit.many);
          return `Занадта вялікі: чакалася, што ${n.origin ?? "значэнне"} павінна ${s.verb} ${o}${n.maximum.toString()} ${u}`;
        }
        return `Занадта вялікі: чакалася, што ${n.origin ?? "значэнне"} павінна быць ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        if (s) {
          const a = Number(n.minimum), u = Kg(a, s.unit.one, s.unit.few, s.unit.many);
          return `Занадта малы: чакалася, што ${n.origin} павінна ${s.verb} ${o}${n.minimum.toString()} ${u}`;
        }
        return `Занадта малы: чакалася, што ${n.origin} павінна быць ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Няправільны радок: павінен пачынацца з "${o.prefix}"` : o.format === "ends_with" ? `Няправільны радок: павінен заканчвацца на "${o.suffix}"` : o.format === "includes" ? `Няправільны радок: павінен змяшчаць "${o.includes}"` : o.format === "regex" ? `Няправільны радок: павінен адпавядаць шаблону ${o.pattern}` : `Няправільны ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${n.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${n.keys.length > 1 ? "ключы" : "ключ"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${n.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${n.origin}`;
      default:
        return "Няправільны ўвод";
    }
  };
};
function dP() {
  return {
    localeError: pP()
  };
}
const mP = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "число";
    case "object": {
      if (Array.isArray(e))
        return "масив";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, yP = () => {
  const e = {
    string: { unit: "символа", verb: "да съдържа" },
    file: { unit: "байта", verb: "да съдържа" },
    array: { unit: "елемента", verb: "да съдържа" },
    set: { unit: "елемента", verb: "да съдържа" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const r = {
    regex: "вход",
    email: "имейл адрес",
    url: "URL",
    emoji: "емоджи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO време",
    date: "ISO дата",
    time: "ISO време",
    duration: "ISO продължителност",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "base64-кодиран низ",
    base64url: "base64url-кодиран низ",
    json_string: "JSON низ",
    e164: "E.164 номер",
    jwt: "JWT",
    template_literal: "вход"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Невалиден вход: очакван ${i.expected}, получен ${mP(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Невалиден вход: очакван ${jt(i.values[0])}` : `Невалидна опция: очаквано едно от ${it(i.values, "|")}`;
      case "too_big": {
        const n = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Твърде голямо: очаква се ${i.origin ?? "стойност"} да съдържа ${n}${i.maximum.toString()} ${o.unit ?? "елемента"}` : `Твърде голямо: очаква се ${i.origin ?? "стойност"} да бъде ${n}${i.maximum.toString()}`;
      }
      case "too_small": {
        const n = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Твърде малко: очаква се ${i.origin} да съдържа ${n}${i.minimum.toString()} ${o.unit}` : `Твърде малко: очаква се ${i.origin} да бъде ${n}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = i;
        if (n.format === "starts_with")
          return `Невалиден низ: трябва да започва с "${n.prefix}"`;
        if (n.format === "ends_with")
          return `Невалиден низ: трябва да завършва с "${n.suffix}"`;
        if (n.format === "includes")
          return `Невалиден низ: трябва да включва "${n.includes}"`;
        if (n.format === "regex")
          return `Невалиден низ: трябва да съвпада с ${n.pattern}`;
        let o = "Невалиден";
        return n.format === "emoji" && (o = "Невалидно"), n.format === "datetime" && (o = "Невалидно"), n.format === "date" && (o = "Невалидна"), n.format === "time" && (o = "Невалидно"), n.format === "duration" && (o = "Невалидна"), `${o} ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Невалидно число: трябва да бъде кратно на ${i.divisor}`;
      case "unrecognized_keys":
        return `Неразпознат${i.keys.length > 1 ? "и" : ""} ключ${i.keys.length > 1 ? "ове" : ""}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return `Невалиден ключ в ${i.origin}`;
      case "invalid_union":
        return "Невалиден вход";
      case "invalid_element":
        return `Невалидна стойност в ${i.origin}`;
      default:
        return "Невалиден вход";
    }
  };
};
function gP() {
  return {
    localeError: yP()
  };
}
const vP = () => {
  const e = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${n.expected}, s'ha rebut ${r(n.input)}`;
      // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Valor invàlid: s'esperava ${jt(n.values[0])}` : `Opció invàlida: s'esperava una de ${it(n.values, " o ")}`;
      case "too_big": {
        const o = n.inclusive ? "com a màxim" : "menys de", s = t(n.origin);
        return s ? `Massa gran: s'esperava que ${n.origin ?? "el valor"} contingués ${o} ${n.maximum.toString()} ${s.unit ?? "elements"}` : `Massa gran: s'esperava que ${n.origin ?? "el valor"} fos ${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? "com a mínim" : "més de", s = t(n.origin);
        return s ? `Massa petit: s'esperava que ${n.origin} contingués ${o} ${n.minimum.toString()} ${s.unit}` : `Massa petit: s'esperava que ${n.origin} fos ${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Format invàlid: ha de començar amb "${o.prefix}"` : o.format === "ends_with" ? `Format invàlid: ha d'acabar amb "${o.suffix}"` : o.format === "includes" ? `Format invàlid: ha d'incloure "${o.includes}"` : o.format === "regex" ? `Format invàlid: ha de coincidir amb el patró ${o.pattern}` : `Format invàlid per a ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clau${n.keys.length > 1 ? "s" : ""} no reconeguda${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${n.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
      case "invalid_element":
        return `Element invàlid a ${n.origin}`;
      default:
        return "Entrada invàlida";
    }
  };
};
function bP() {
  return {
    localeError: vP()
  };
}
const _P = () => {
  const e = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "číslo";
      case "string":
        return "řetězec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(n))
          return "pole";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${n.expected}, obdrženo ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Neplatný vstup: očekáváno ${jt(n.values[0])}` : `Neplatná možnost: očekávána jedna z hodnot ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Hodnota je příliš velká: ${n.origin ?? "hodnota"} musí mít ${o}${n.maximum.toString()} ${s.unit ?? "prvků"}` : `Hodnota je příliš velká: ${n.origin ?? "hodnota"} musí být ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Hodnota je příliš malá: ${n.origin ?? "hodnota"} musí mít ${o}${n.minimum.toString()} ${s.unit ?? "prvků"}` : `Hodnota je příliš malá: ${n.origin ?? "hodnota"} musí být ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Neplatný řetězec: musí začínat na "${o.prefix}"` : o.format === "ends_with" ? `Neplatný řetězec: musí končit na "${o.suffix}"` : o.format === "includes" ? `Neplatný řetězec: musí obsahovat "${o.includes}"` : o.format === "regex" ? `Neplatný řetězec: musí odpovídat vzoru ${o.pattern}` : `Neplatný formát ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${n.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${n.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${n.origin}`;
      default:
        return "Neplatný vstup";
    }
  };
};
function wP() {
  return {
    localeError: _P()
  };
}
const OP = () => {
  const e = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  }, t = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "sæt",
    file: "fil"
  };
  function r(s) {
    return e[s] ?? null;
  }
  function i(s) {
    return t[s] ?? s;
  }
  const n = (s) => {
    const a = typeof s;
    switch (a) {
      case "number":
        return Number.isNaN(s) ? "NaN" : "tal";
      case "object":
        return Array.isArray(s) ? "liste" : s === null ? "null" : Object.getPrototypeOf(s) !== Object.prototype && s.constructor ? s.constructor.name : "objekt";
    }
    return a;
  }, o = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslæt",
    date: "ISO-dato",
    time: "ISO-klokkeslæt",
    duration: "ISO-varighed",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (s) => {
    switch (s.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${i(s.expected)}, fik ${i(n(s.input))}`;
      case "invalid_value":
        return s.values.length === 1 ? `Ugyldig værdi: forventede ${jt(s.values[0])}` : `Ugyldigt valg: forventede en af følgende ${it(s.values, "|")}`;
      case "too_big": {
        const a = s.inclusive ? "<=" : "<", u = r(s.origin), c = i(s.origin);
        return u ? `For stor: forventede ${c ?? "value"} ${u.verb} ${a} ${s.maximum.toString()} ${u.unit ?? "elementer"}` : `For stor: forventede ${c ?? "value"} havde ${a} ${s.maximum.toString()}`;
      }
      case "too_small": {
        const a = s.inclusive ? ">=" : ">", u = r(s.origin), c = i(s.origin);
        return u ? `For lille: forventede ${c} ${u.verb} ${a} ${s.minimum.toString()} ${u.unit}` : `For lille: forventede ${c} havde ${a} ${s.minimum.toString()}`;
      }
      case "invalid_format": {
        const a = s;
        return a.format === "starts_with" ? `Ugyldig streng: skal starte med "${a.prefix}"` : a.format === "ends_with" ? `Ugyldig streng: skal ende med "${a.suffix}"` : a.format === "includes" ? `Ugyldig streng: skal indeholde "${a.includes}"` : a.format === "regex" ? `Ugyldig streng: skal matche mønsteret ${a.pattern}` : `Ugyldig ${o[a.format] ?? s.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal være deleligt med ${s.divisor}`;
      case "unrecognized_keys":
        return `${s.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${it(s.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøgle i ${s.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig værdi i ${s.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function $P() {
  return {
    localeError: OP()
  };
}
const SP = () => {
  const e = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(n))
          return "Array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${n.expected}, erhalten ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ungültige Eingabe: erwartet ${jt(n.values[0])}` : `Ungültige Option: erwartet eine von ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Zu groß: erwartet, dass ${n.origin ?? "Wert"} ${o}${n.maximum.toString()} ${s.unit ?? "Elemente"} hat` : `Zu groß: erwartet, dass ${n.origin ?? "Wert"} ${o}${n.maximum.toString()} ist`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Zu klein: erwartet, dass ${n.origin} ${o}${n.minimum.toString()} ${s.unit} hat` : `Zu klein: erwartet, dass ${n.origin} ${o}${n.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ungültiger String: muss mit "${o.prefix}" beginnen` : o.format === "ends_with" ? `Ungültiger String: muss mit "${o.suffix}" enden` : o.format === "includes" ? `Ungültiger String: muss "${o.includes}" enthalten` : o.format === "regex" ? `Ungültiger String: muss dem Muster ${o.pattern} entsprechen` : `Ungültig: ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${n.divisor} sein`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${n.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${n.origin}`;
      default:
        return "Ungültige Eingabe";
    }
  };
};
function EP() {
  return {
    localeError: SP()
  };
}
const xP = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, AP = () => {
  const e = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const r = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Invalid input: expected ${i.expected}, received ${xP(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Invalid input: expected ${jt(i.values[0])}` : `Invalid option: expected one of ${it(i.values, "|")}`;
      case "too_big": {
        const n = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Too big: expected ${i.origin ?? "value"} to have ${n}${i.maximum.toString()} ${o.unit ?? "elements"}` : `Too big: expected ${i.origin ?? "value"} to be ${n}${i.maximum.toString()}`;
      }
      case "too_small": {
        const n = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Too small: expected ${i.origin} to have ${n}${i.minimum.toString()} ${o.unit}` : `Too small: expected ${i.origin} to be ${n}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = i;
        return n.format === "starts_with" ? `Invalid string: must start with "${n.prefix}"` : n.format === "ends_with" ? `Invalid string: must end with "${n.suffix}"` : n.format === "includes" ? `Invalid string: must include "${n.includes}"` : n.format === "regex" ? `Invalid string: must match pattern ${n.pattern}` : `Invalid ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${i.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${i.keys.length > 1 ? "s" : ""}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${i.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${i.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function xS() {
  return {
    localeError: AP()
  };
}
const jP = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray(e))
        return "tabelo";
      if (e === null)
        return "senvalora";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, kP = () => {
  const e = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const r = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${i.expected}, riceviĝis ${jP(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Nevalida enigo: atendiĝis ${jt(i.values[0])}` : `Nevalida opcio: atendiĝis unu el ${it(i.values, "|")}`;
      case "too_big": {
        const n = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Tro granda: atendiĝis ke ${i.origin ?? "valoro"} havu ${n}${i.maximum.toString()} ${o.unit ?? "elementojn"}` : `Tro granda: atendiĝis ke ${i.origin ?? "valoro"} havu ${n}${i.maximum.toString()}`;
      }
      case "too_small": {
        const n = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Tro malgranda: atendiĝis ke ${i.origin} havu ${n}${i.minimum.toString()} ${o.unit}` : `Tro malgranda: atendiĝis ke ${i.origin} estu ${n}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = i;
        return n.format === "starts_with" ? `Nevalida karaktraro: devas komenciĝi per "${n.prefix}"` : n.format === "ends_with" ? `Nevalida karaktraro: devas finiĝi per "${n.suffix}"` : n.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${n.includes}"` : n.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${n.pattern}` : `Nevalida ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${i.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${i.keys.length > 1 ? "j" : ""} ŝlosilo${i.keys.length > 1 ? "j" : ""}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${i.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${i.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function PP() {
  return {
    localeError: kP()
  };
}
const IP = () => {
  const e = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  }, t = {
    string: "texto",
    number: "número",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "número grande",
    symbol: "símbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "función",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeración",
    union: "unión",
    literal: "literal",
    promise: "promesa",
    void: "vacío",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function r(s) {
    return e[s] ?? null;
  }
  function i(s) {
    return t[s] ?? s;
  }
  const n = (s) => {
    const a = typeof s;
    switch (a) {
      case "number":
        return Number.isNaN(s) ? "NaN" : "number";
      case "object":
        return Array.isArray(s) ? "array" : s === null ? "null" : Object.getPrototypeOf(s) !== Object.prototype ? s.constructor.name : "object";
    }
    return a;
  }, o = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (s) => {
    switch (s.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${i(s.expected)}, recibido ${i(n(s.input))}`;
      // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return s.values.length === 1 ? `Entrada inválida: se esperaba ${jt(s.values[0])}` : `Opción inválida: se esperaba una de ${it(s.values, "|")}`;
      case "too_big": {
        const a = s.inclusive ? "<=" : "<", u = r(s.origin), c = i(s.origin);
        return u ? `Demasiado grande: se esperaba que ${c ?? "valor"} tuviera ${a}${s.maximum.toString()} ${u.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${c ?? "valor"} fuera ${a}${s.maximum.toString()}`;
      }
      case "too_small": {
        const a = s.inclusive ? ">=" : ">", u = r(s.origin), c = i(s.origin);
        return u ? `Demasiado pequeño: se esperaba que ${c} tuviera ${a}${s.minimum.toString()} ${u.unit}` : `Demasiado pequeño: se esperaba que ${c} fuera ${a}${s.minimum.toString()}`;
      }
      case "invalid_format": {
        const a = s;
        return a.format === "starts_with" ? `Cadena inválida: debe comenzar con "${a.prefix}"` : a.format === "ends_with" ? `Cadena inválida: debe terminar en "${a.suffix}"` : a.format === "includes" ? `Cadena inválida: debe incluir "${a.includes}"` : a.format === "regex" ? `Cadena inválida: debe coincidir con el patrón ${a.pattern}` : `Inválido ${o[a.format] ?? s.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${s.divisor}`;
      case "unrecognized_keys":
        return `Llave${s.keys.length > 1 ? "s" : ""} desconocida${s.keys.length > 1 ? "s" : ""}: ${it(s.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${i(s.origin)}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${i(s.origin)}`;
      default:
        return "Entrada inválida";
    }
  };
};
function TP() {
  return {
    localeError: IP()
  };
}
const NP = () => {
  const e = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "عدد";
      case "object": {
        if (Array.isArray(n))
          return "آرایه";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${n.expected} می‌بود، ${r(n.input)} دریافت شد`;
      case "invalid_value":
        return n.values.length === 1 ? `ورودی نامعتبر: می‌بایست ${jt(n.values[0])} می‌بود` : `گزینه نامعتبر: می‌بایست یکی از ${it(n.values, "|")} می‌بود`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `خیلی بزرگ: ${n.origin ?? "مقدار"} باید ${o}${n.maximum.toString()} ${s.unit ?? "عنصر"} باشد` : `خیلی بزرگ: ${n.origin ?? "مقدار"} باید ${o}${n.maximum.toString()} باشد`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `خیلی کوچک: ${n.origin} باید ${o}${n.minimum.toString()} ${s.unit} باشد` : `خیلی کوچک: ${n.origin} باید ${o}${n.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `رشته نامعتبر: باید با "${o.prefix}" شروع شود` : o.format === "ends_with" ? `رشته نامعتبر: باید با "${o.suffix}" تمام شود` : o.format === "includes" ? `رشته نامعتبر: باید شامل "${o.includes}" باشد` : o.format === "regex" ? `رشته نامعتبر: باید با الگوی ${o.pattern} مطابقت داشته باشد` : `${i[o.format] ?? n.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${n.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${n.keys.length > 1 ? "های" : ""} ناشناس: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${n.origin}`;
      case "invalid_union":
        return "ورودی نامعتبر";
      case "invalid_element":
        return `مقدار نامعتبر در ${n.origin}`;
      default:
        return "ورودی نامعتبر";
    }
  };
};
function CP() {
  return {
    localeError: NP()
  };
}
const RP = () => {
  const e = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${n.expected}, oli ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Virheellinen syöte: täytyy olla ${jt(n.values[0])}` : `Virheellinen valinta: täytyy olla yksi seuraavista: ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Liian suuri: ${s.subject} täytyy olla ${o}${n.maximum.toString()} ${s.unit}`.trim() : `Liian suuri: arvon täytyy olla ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Liian pieni: ${s.subject} täytyy olla ${o}${n.minimum.toString()} ${s.unit}`.trim() : `Liian pieni: arvon täytyy olla ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Virheellinen syöte: täytyy alkaa "${o.prefix}"` : o.format === "ends_with" ? `Virheellinen syöte: täytyy loppua "${o.suffix}"` : o.format === "includes" ? `Virheellinen syöte: täytyy sisältää "${o.includes}"` : o.format === "regex" ? `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${o.pattern}` : `Virheellinen ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${n.divisor} monikerta`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syöte";
    }
  };
};
function DP() {
  return {
    localeError: RP()
  };
}
const zP = () => {
  const e = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(n))
          return "tableau";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Entrée invalide : ${n.expected} attendu, ${r(n.input)} reçu`;
      case "invalid_value":
        return n.values.length === 1 ? `Entrée invalide : ${jt(n.values[0])} attendu` : `Option invalide : une valeur parmi ${it(n.values, "|")} attendue`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Trop grand : ${n.origin ?? "valeur"} doit ${s.verb} ${o}${n.maximum.toString()} ${s.unit ?? "élément(s)"}` : `Trop grand : ${n.origin ?? "valeur"} doit être ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Trop petit : ${n.origin} doit ${s.verb} ${o}${n.minimum.toString()} ${s.unit}` : `Trop petit : ${n.origin} doit être ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Chaîne invalide : doit commencer par "${o.prefix}"` : o.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${o.suffix}"` : o.format === "includes" ? `Chaîne invalide : doit inclure "${o.includes}"` : o.format === "regex" ? `Chaîne invalide : doit correspondre au modèle ${o.pattern}` : `${i[o.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clé${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entrée invalide";
    }
  };
};
function UP() {
  return {
    localeError: zP()
  };
}
const MP = () => {
  const e = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${n.expected}, reçu ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Entrée invalide : attendu ${jt(n.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "≤" : "<", s = t(n.origin);
        return s ? `Trop grand : attendu que ${n.origin ?? "la valeur"} ait ${o}${n.maximum.toString()} ${s.unit}` : `Trop grand : attendu que ${n.origin ?? "la valeur"} soit ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? "≥" : ">", s = t(n.origin);
        return s ? `Trop petit : attendu que ${n.origin} ait ${o}${n.minimum.toString()} ${s.unit}` : `Trop petit : attendu que ${n.origin} soit ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Chaîne invalide : doit commencer par "${o.prefix}"` : o.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${o.suffix}"` : o.format === "includes" ? `Chaîne invalide : doit inclure "${o.includes}"` : o.format === "regex" ? `Chaîne invalide : doit correspondre au motif ${o.pattern}` : `${i[o.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clé${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entrée invalide";
    }
  };
};
function FP() {
  return {
    localeError: MP()
  };
}
const LP = () => {
  const e = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${n.expected}, התקבל ${r(n.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `קלט לא תקין: צריך ${jt(n.values[0])}` : `קלט לא תקין: צריך אחת מהאפשרויות  ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `גדול מדי: ${n.origin ?? "value"} צריך להיות ${o}${n.maximum.toString()} ${s.unit ?? "elements"}` : `גדול מדי: ${n.origin ?? "value"} צריך להיות ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `קטן מדי: ${n.origin} צריך להיות ${o}${n.minimum.toString()} ${s.unit}` : `קטן מדי: ${n.origin} צריך להיות ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `מחרוזת לא תקינה: חייבת להתחיל ב"${o.prefix}"` : o.format === "ends_with" ? `מחרוזת לא תקינה: חייבת להסתיים ב "${o.suffix}"` : o.format === "includes" ? `מחרוזת לא תקינה: חייבת לכלול "${o.includes}"` : o.format === "regex" ? `מחרוזת לא תקינה: חייבת להתאים לתבנית ${o.pattern}` : `${i[o.format] ?? n.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${n.divisor}`;
      case "unrecognized_keys":
        return `מפתח${n.keys.length > 1 ? "ות" : ""} לא מזוה${n.keys.length > 1 ? "ים" : "ה"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${n.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${n.origin}`;
      default:
        return "קלט לא תקין";
    }
  };
};
function BP() {
  return {
    localeError: LP()
  };
}
const qP = () => {
  const e = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "szám";
      case "object": {
        if (Array.isArray(n))
          return "tömb";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${n.expected}, a kapott érték ${r(n.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Érvénytelen bemenet: a várt érték ${jt(n.values[0])}` : `Érvénytelen opció: valamelyik érték várt ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Túl nagy: ${n.origin ?? "érték"} mérete túl nagy ${o}${n.maximum.toString()} ${s.unit ?? "elem"}` : `Túl nagy: a bemeneti érték ${n.origin ?? "érték"} túl nagy: ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Túl kicsi: a bemeneti érték ${n.origin} mérete túl kicsi ${o}${n.minimum.toString()} ${s.unit}` : `Túl kicsi: a bemeneti érték ${n.origin} túl kicsi ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Érvénytelen string: "${o.prefix}" értékkel kell kezdődnie` : o.format === "ends_with" ? `Érvénytelen string: "${o.suffix}" értékkel kell végződnie` : o.format === "includes" ? `Érvénytelen string: "${o.includes}" értéket kell tartalmaznia` : o.format === "regex" ? `Érvénytelen string: ${o.pattern} mintának kell megfelelnie` : `Érvénytelen ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${n.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${n.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${n.origin}`;
      default:
        return "Érvénytelen bemenet";
    }
  };
};
function ZP() {
  return {
    localeError: qP()
  };
}
const VP = () => {
  const e = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${n.expected}, diterima ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Input tidak valid: diharapkan ${jt(n.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Terlalu besar: diharapkan ${n.origin ?? "value"} memiliki ${o}${n.maximum.toString()} ${s.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${n.origin ?? "value"} menjadi ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Terlalu kecil: diharapkan ${n.origin} memiliki ${o}${n.minimum.toString()} ${s.unit}` : `Terlalu kecil: diharapkan ${n.origin} menjadi ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${o.prefix}"` : o.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${o.suffix}"` : o.format === "includes" ? `String tidak valid: harus menyertakan "${o.includes}"` : o.format === "regex" ? `String tidak valid: harus sesuai pola ${o.pattern}` : `${i[o.format] ?? n.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${n.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${n.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function WP() {
  return {
    localeError: VP()
  };
}
const GP = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "númer";
    case "object": {
      if (Array.isArray(e))
        return "fylki";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, KP = () => {
  const e = {
    string: { unit: "stafi", verb: "að hafa" },
    file: { unit: "bæti", verb: "að hafa" },
    array: { unit: "hluti", verb: "að hafa" },
    set: { unit: "hluti", verb: "að hafa" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const r = {
    regex: "gildi",
    email: "netfang",
    url: "vefslóð",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tími",
    date: "ISO dagsetning",
    time: "ISO tími",
    duration: "ISO tímalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tölugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Rangt gildi: Þú slóst inn ${GP(i.input)} þar sem á að vera ${i.expected}`;
      case "invalid_value":
        return i.values.length === 1 ? `Rangt gildi: gert ráð fyrir ${jt(i.values[0])}` : `Ógilt val: má vera eitt af eftirfarandi ${it(i.values, "|")}`;
      case "too_big": {
        const n = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Of stórt: gert er ráð fyrir að ${i.origin ?? "gildi"} hafi ${n}${i.maximum.toString()} ${o.unit ?? "hluti"}` : `Of stórt: gert er ráð fyrir að ${i.origin ?? "gildi"} sé ${n}${i.maximum.toString()}`;
      }
      case "too_small": {
        const n = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Of lítið: gert er ráð fyrir að ${i.origin} hafi ${n}${i.minimum.toString()} ${o.unit}` : `Of lítið: gert er ráð fyrir að ${i.origin} sé ${n}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = i;
        return n.format === "starts_with" ? `Ógildur strengur: verður að byrja á "${n.prefix}"` : n.format === "ends_with" ? `Ógildur strengur: verður að enda á "${n.suffix}"` : n.format === "includes" ? `Ógildur strengur: verður að innihalda "${n.includes}"` : n.format === "regex" ? `Ógildur strengur: verður að fylgja mynstri ${n.pattern}` : `Rangt ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Röng tala: verður að vera margfeldi af ${i.divisor}`;
      case "unrecognized_keys":
        return `Óþekkt ${i.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill í ${i.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi í ${i.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function HP() {
  return {
    localeError: KP()
  };
}
const JP = () => {
  const e = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(n))
          return "vettore";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Input non valido: atteso ${n.expected}, ricevuto ${r(n.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Input non valido: atteso ${jt(n.values[0])}` : `Opzione non valida: atteso uno tra ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Troppo grande: ${n.origin ?? "valore"} deve avere ${o}${n.maximum.toString()} ${s.unit ?? "elementi"}` : `Troppo grande: ${n.origin ?? "valore"} deve essere ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Troppo piccolo: ${n.origin} deve avere ${o}${n.minimum.toString()} ${s.unit}` : `Troppo piccolo: ${n.origin} deve essere ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Stringa non valida: deve iniziare con "${o.prefix}"` : o.format === "ends_with" ? `Stringa non valida: deve terminare con "${o.suffix}"` : o.format === "includes" ? `Stringa non valida: deve includere "${o.includes}"` : o.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${o.pattern}` : `Invalid ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${n.divisor}`;
      case "unrecognized_keys":
        return `Chiav${n.keys.length > 1 ? "i" : "e"} non riconosciut${n.keys.length > 1 ? "e" : "a"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${n.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${n.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function YP() {
  return {
    localeError: JP()
  };
}
const XP = () => {
  const e = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "数値";
      case "object": {
        if (Array.isArray(n))
          return "配列";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `無効な入力: ${n.expected}が期待されましたが、${r(n.input)}が入力されました`;
      case "invalid_value":
        return n.values.length === 1 ? `無効な入力: ${jt(n.values[0])}が期待されました` : `無効な選択: ${it(n.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const o = n.inclusive ? "以下である" : "より小さい", s = t(n.origin);
        return s ? `大きすぎる値: ${n.origin ?? "値"}は${n.maximum.toString()}${s.unit ?? "要素"}${o}必要があります` : `大きすぎる値: ${n.origin ?? "値"}は${n.maximum.toString()}${o}必要があります`;
      }
      case "too_small": {
        const o = n.inclusive ? "以上である" : "より大きい", s = t(n.origin);
        return s ? `小さすぎる値: ${n.origin}は${n.minimum.toString()}${s.unit}${o}必要があります` : `小さすぎる値: ${n.origin}は${n.minimum.toString()}${o}必要があります`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `無効な文字列: "${o.prefix}"で始まる必要があります` : o.format === "ends_with" ? `無効な文字列: "${o.suffix}"で終わる必要があります` : o.format === "includes" ? `無効な文字列: "${o.includes}"を含む必要があります` : o.format === "regex" ? `無効な文字列: パターン${o.pattern}に一致する必要があります` : `無効な${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${n.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${n.keys.length > 1 ? "群" : ""}: ${it(n.keys, "、")}`;
      case "invalid_key":
        return `${n.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${n.origin}内の無効な値`;
      default:
        return "無効な入力";
    }
  };
};
function QP() {
  return {
    localeError: XP()
  };
}
const eI = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "რიცხვი";
    case "object": {
      if (Array.isArray(e))
        return "მასივი";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return {
    string: "სტრინგი",
    boolean: "ბულეანი",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "ფუნქცია"
  }[t] ?? t;
}, tI = () => {
  const e = {
    string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" },
    file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" },
    array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" },
    set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const r = {
    regex: "შეყვანა",
    email: "ელ-ფოსტის მისამართი",
    url: "URL",
    emoji: "ემოჯი",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "თარიღი-დრო",
    date: "თარიღი",
    time: "დრო",
    duration: "ხანგრძლივობა",
    ipv4: "IPv4 მისამართი",
    ipv6: "IPv6 მისამართი",
    cidrv4: "IPv4 დიაპაზონი",
    cidrv6: "IPv6 დიაპაზონი",
    base64: "base64-კოდირებული სტრინგი",
    base64url: "base64url-კოდირებული სტრინგი",
    json_string: "JSON სტრინგი",
    e164: "E.164 ნომერი",
    jwt: "JWT",
    template_literal: "შეყვანა"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `არასწორი შეყვანა: მოსალოდნელი ${i.expected}, მიღებული ${eI(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `არასწორი შეყვანა: მოსალოდნელი ${jt(i.values[0])}` : `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${it(i.values, "|")}-დან`;
      case "too_big": {
        const n = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `ზედმეტად დიდი: მოსალოდნელი ${i.origin ?? "მნიშვნელობა"} ${o.verb} ${n}${i.maximum.toString()} ${o.unit}` : `ზედმეტად დიდი: მოსალოდნელი ${i.origin ?? "მნიშვნელობა"} იყოს ${n}${i.maximum.toString()}`;
      }
      case "too_small": {
        const n = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `ზედმეტად პატარა: მოსალოდნელი ${i.origin} ${o.verb} ${n}${i.minimum.toString()} ${o.unit}` : `ზედმეტად პატარა: მოსალოდნელი ${i.origin} იყოს ${n}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = i;
        return n.format === "starts_with" ? `არასწორი სტრინგი: უნდა იწყებოდეს "${n.prefix}"-ით` : n.format === "ends_with" ? `არასწორი სტრინგი: უნდა მთავრდებოდეს "${n.suffix}"-ით` : n.format === "includes" ? `არასწორი სტრინგი: უნდა შეიცავდეს "${n.includes}"-ს` : n.format === "regex" ? `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${n.pattern}` : `არასწორი ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `არასწორი რიცხვი: უნდა იყოს ${i.divisor}-ის ჯერადი`;
      case "unrecognized_keys":
        return `უცნობი გასაღებ${i.keys.length > 1 ? "ები" : "ი"}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return `არასწორი გასაღები ${i.origin}-ში`;
      case "invalid_union":
        return "არასწორი შეყვანა";
      case "invalid_element":
        return `არასწორი მნიშვნელობა ${i.origin}-ში`;
      default:
        return "არასწორი შეყვანა";
    }
  };
};
function rI() {
  return {
    localeError: tI()
  };
}
const nI = () => {
  const e = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      case "object": {
        if (Array.isArray(n))
          return "អារេ (Array)";
        if (n === null)
          return "គ្មានតម្លៃ (null)";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${n.expected} ប៉ុន្តែទទួលបាន ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${jt(n.values[0])}` : `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `ធំពេក៖ ត្រូវការ ${n.origin ?? "តម្លៃ"} ${o} ${n.maximum.toString()} ${s.unit ?? "ធាតុ"}` : `ធំពេក៖ ត្រូវការ ${n.origin ?? "តម្លៃ"} ${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `តូចពេក៖ ត្រូវការ ${n.origin} ${o} ${n.minimum.toString()} ${s.unit}` : `តូចពេក៖ ត្រូវការ ${n.origin} ${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${o.prefix}"` : o.format === "ends_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${o.suffix}"` : o.format === "includes" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${o.includes}"` : o.format === "regex" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${o.pattern}` : `មិនត្រឹមត្រូវ៖ ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${n.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${n.origin}`;
      case "invalid_union":
        return "ទិន្នន័យមិនត្រឹមត្រូវ";
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${n.origin}`;
      default:
        return "ទិន្នន័យមិនត្រឹមត្រូវ";
    }
  };
};
function AS() {
  return {
    localeError: nI()
  };
}
function iI() {
  return AS();
}
const oI = () => {
  const e = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${n.expected}, 받은 타입은 ${r(n.input)}입니다`;
      case "invalid_value":
        return n.values.length === 1 ? `잘못된 입력: 값은 ${jt(n.values[0])} 이어야 합니다` : `잘못된 옵션: ${it(n.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const o = n.inclusive ? "이하" : "미만", s = o === "미만" ? "이어야 합니다" : "여야 합니다", a = t(n.origin), u = a?.unit ?? "요소";
        return a ? `${n.origin ?? "값"}이 너무 큽니다: ${n.maximum.toString()}${u} ${o}${s}` : `${n.origin ?? "값"}이 너무 큽니다: ${n.maximum.toString()} ${o}${s}`;
      }
      case "too_small": {
        const o = n.inclusive ? "이상" : "초과", s = o === "이상" ? "이어야 합니다" : "여야 합니다", a = t(n.origin), u = a?.unit ?? "요소";
        return a ? `${n.origin ?? "값"}이 너무 작습니다: ${n.minimum.toString()}${u} ${o}${s}` : `${n.origin ?? "값"}이 너무 작습니다: ${n.minimum.toString()} ${o}${s}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `잘못된 문자열: "${o.prefix}"(으)로 시작해야 합니다` : o.format === "ends_with" ? `잘못된 문자열: "${o.suffix}"(으)로 끝나야 합니다` : o.format === "includes" ? `잘못된 문자열: "${o.includes}"을(를) 포함해야 합니다` : o.format === "regex" ? `잘못된 문자열: 정규식 ${o.pattern} 패턴과 일치해야 합니다` : `잘못된 ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${n.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${n.origin}`;
      case "invalid_union":
        return "잘못된 입력";
      case "invalid_element":
        return `잘못된 값: ${n.origin}`;
      default:
        return "잘못된 입력";
    }
  };
};
function aI() {
  return {
    localeError: oI()
  };
}
const sI = (e) => _a(typeof e, e), _a = (e, t = void 0) => {
  switch (e) {
    case "number":
      return Number.isNaN(t) ? "NaN" : "skaičius";
    case "bigint":
      return "sveikasis skaičius";
    case "string":
      return "eilutė";
    case "boolean":
      return "loginė reikšmė";
    case "undefined":
    case "void":
      return "neapibrėžta reikšmė";
    case "function":
      return "funkcija";
    case "symbol":
      return "simbolis";
    case "object":
      return t === void 0 ? "nežinomas objektas" : t === null ? "nulinė reikšmė" : Array.isArray(t) ? "masyvas" : Object.getPrototypeOf(t) !== Object.prototype && t.constructor ? t.constructor.name : "objektas";
    //Zod types below
    case "null":
      return "nulinė reikšmė";
  }
  return e;
}, aa = (e) => e.charAt(0).toUpperCase() + e.slice(1);
function Hg(e) {
  const t = Math.abs(e), r = t % 10, i = t % 100;
  return i >= 11 && i <= 19 || r === 0 ? "many" : r === 1 ? "one" : "few";
}
const uI = () => {
  const e = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simbolių"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne ilgesnė kaip",
          notInclusive: "turi būti trumpesnė kaip"
        },
        bigger: {
          inclusive: "turi būti ne trumpesnė kaip",
          notInclusive: "turi būti ilgesnė kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "baitų"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne didesnis kaip",
          notInclusive: "turi būti mažesnis kaip"
        },
        bigger: {
          inclusive: "turi būti ne mažesnis kaip",
          notInclusive: "turi būti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    }
  };
  function t(i, n, o, s) {
    const a = e[i] ?? null;
    return a === null ? a : {
      unit: a.unit[n],
      verb: a.verb[s][o ? "inclusive" : "notInclusive"]
    };
  }
  const r = {
    regex: "įvestis",
    email: "el. pašto adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukmė",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 užkoduota eilutė",
    base64url: "base64url užkoduota eilutė",
    json_string: "JSON eilutė",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "įvestis"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Gautas tipas ${sI(i.input)}, o tikėtasi - ${_a(i.expected)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Privalo būti ${jt(i.values[0])}` : `Privalo būti vienas iš ${it(i.values, "|")} pasirinkimų`;
      case "too_big": {
        const n = _a(i.origin), o = t(i.origin, Hg(Number(i.maximum)), i.inclusive ?? !1, "smaller");
        if (o?.verb)
          return `${aa(n ?? i.origin ?? "reikšmė")} ${o.verb} ${i.maximum.toString()} ${o.unit ?? "elementų"}`;
        const s = i.inclusive ? "ne didesnis kaip" : "mažesnis kaip";
        return `${aa(n ?? i.origin ?? "reikšmė")} turi būti ${s} ${i.maximum.toString()} ${o?.unit}`;
      }
      case "too_small": {
        const n = _a(i.origin), o = t(i.origin, Hg(Number(i.minimum)), i.inclusive ?? !1, "bigger");
        if (o?.verb)
          return `${aa(n ?? i.origin ?? "reikšmė")} ${o.verb} ${i.minimum.toString()} ${o.unit ?? "elementų"}`;
        const s = i.inclusive ? "ne mažesnis kaip" : "didesnis kaip";
        return `${aa(n ?? i.origin ?? "reikšmė")} turi būti ${s} ${i.minimum.toString()} ${o?.unit}`;
      }
      case "invalid_format": {
        const n = i;
        return n.format === "starts_with" ? `Eilutė privalo prasidėti "${n.prefix}"` : n.format === "ends_with" ? `Eilutė privalo pasibaigti "${n.suffix}"` : n.format === "includes" ? `Eilutė privalo įtraukti "${n.includes}"` : n.format === "regex" ? `Eilutė privalo atitikti ${n.pattern}` : `Neteisingas ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Skaičius privalo būti ${i.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpažint${i.keys.length > 1 ? "i" : "as"} rakt${i.keys.length > 1 ? "ai" : "as"}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga įvestis";
      case "invalid_element": {
        const n = _a(i.origin);
        return `${aa(n ?? i.origin ?? "reikšmė")} turi klaidingą įvestį`;
      }
      default:
        return "Klaidinga įvestis";
    }
  };
};
function cI() {
  return {
    localeError: uI()
  };
}
const lI = () => {
  const e = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "број";
      case "object": {
        if (Array.isArray(n))
          return "низа";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${n.expected}, примено ${r(n.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Invalid input: expected ${jt(n.values[0])}` : `Грешана опција: се очекува една ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Премногу голем: се очекува ${n.origin ?? "вредноста"} да има ${o}${n.maximum.toString()} ${s.unit ?? "елементи"}` : `Премногу голем: се очекува ${n.origin ?? "вредноста"} да биде ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Премногу мал: се очекува ${n.origin} да има ${o}${n.minimum.toString()} ${s.unit}` : `Премногу мал: се очекува ${n.origin} да биде ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Неважечка низа: мора да започнува со "${o.prefix}"` : o.format === "ends_with" ? `Неважечка низа: мора да завршува со "${o.suffix}"` : o.format === "includes" ? `Неважечка низа: мора да вклучува "${o.includes}"` : o.format === "regex" ? `Неважечка низа: мора да одгоара на патернот ${o.pattern}` : `Invalid ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${n.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${n.origin}`;
      default:
        return "Грешен внес";
    }
  };
};
function fI() {
  return {
    localeError: lI()
  };
}
const hI = () => {
  const e = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${n.expected}, diterima ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Input tidak sah: dijangka ${jt(n.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Terlalu besar: dijangka ${n.origin ?? "nilai"} ${s.verb} ${o}${n.maximum.toString()} ${s.unit ?? "elemen"}` : `Terlalu besar: dijangka ${n.origin ?? "nilai"} adalah ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Terlalu kecil: dijangka ${n.origin} ${s.verb} ${o}${n.minimum.toString()} ${s.unit}` : `Terlalu kecil: dijangka ${n.origin} adalah ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${o.prefix}"` : o.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${o.suffix}"` : o.format === "includes" ? `String tidak sah: mesti mengandungi "${o.includes}"` : o.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${o.pattern}` : `${i[o.format] ?? n.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${n.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${n.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function pI() {
  return {
    localeError: hI()
  };
}
const dI = () => {
  const e = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${n.expected}, ontving ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ongeldige invoer: verwacht ${jt(n.values[0])}` : `Ongeldige optie: verwacht één van ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Te lang: verwacht dat ${n.origin ?? "waarde"} ${o}${n.maximum.toString()} ${s.unit ?? "elementen"} bevat` : `Te lang: verwacht dat ${n.origin ?? "waarde"} ${o}${n.maximum.toString()} is`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Te kort: verwacht dat ${n.origin} ${o}${n.minimum.toString()} ${s.unit} bevat` : `Te kort: verwacht dat ${n.origin} ${o}${n.minimum.toString()} is`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ongeldige tekst: moet met "${o.prefix}" beginnen` : o.format === "ends_with" ? `Ongeldige tekst: moet op "${o.suffix}" eindigen` : o.format === "includes" ? `Ongeldige tekst: moet "${o.includes}" bevatten` : o.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${o.pattern}` : `Ongeldig: ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${n.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${n.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${n.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function mI() {
  return {
    localeError: dI()
  };
}
const yI = () => {
  const e = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(n))
          return "liste";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${n.expected}, fikk ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ugyldig verdi: forventet ${jt(n.values[0])}` : `Ugyldig valg: forventet en av ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `For stor(t): forventet ${n.origin ?? "value"} til å ha ${o}${n.maximum.toString()} ${s.unit ?? "elementer"}` : `For stor(t): forventet ${n.origin ?? "value"} til å ha ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `For lite(n): forventet ${n.origin} til å ha ${o}${n.minimum.toString()} ${s.unit}` : `For lite(n): forventet ${n.origin} til å ha ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ugyldig streng: må starte med "${o.prefix}"` : o.format === "ends_with" ? `Ugyldig streng: må ende med "${o.suffix}"` : o.format === "includes" ? `Ugyldig streng: må inneholde "${o.includes}"` : o.format === "regex" ? `Ugyldig streng: må matche mønsteret ${o.pattern}` : `Ugyldig ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${n.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${n.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function gI() {
  return {
    localeError: yI()
  };
}
const vI = () => {
  const e = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(n))
          return "saf";
        if (n === null)
          return "gayb";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${n.expected}, alınan ${r(n.input)}`;
      // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Fâsit giren: umulan ${jt(n.values[0])}` : `Fâsit tercih: mûteberler ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Fazla büyük: ${n.origin ?? "value"}, ${o}${n.maximum.toString()} ${s.unit ?? "elements"} sahip olmalıydı.` : `Fazla büyük: ${n.origin ?? "value"}, ${o}${n.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Fazla küçük: ${n.origin}, ${o}${n.minimum.toString()} ${s.unit} sahip olmalıydı.` : `Fazla küçük: ${n.origin}, ${o}${n.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Fâsit metin: "${o.prefix}" ile başlamalı.` : o.format === "ends_with" ? `Fâsit metin: "${o.suffix}" ile bitmeli.` : o.format === "includes" ? `Fâsit metin: "${o.includes}" ihtivâ etmeli.` : o.format === "regex" ? `Fâsit metin: ${o.pattern} nakşına uymalı.` : `Fâsit ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${n.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${n.origin} için tanınmayan kıymet var.`;
      default:
        return "Kıymet tanınamadı.";
    }
  };
};
function bI() {
  return {
    localeError: vI()
  };
}
const _I = () => {
  const e = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "عدد";
      case "object": {
        if (Array.isArray(n))
          return "ارې";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${n.expected} وای, مګر ${r(n.input)} ترلاسه شو`;
      case "invalid_value":
        return n.values.length === 1 ? `ناسم ورودي: باید ${jt(n.values[0])} وای` : `ناسم انتخاب: باید یو له ${it(n.values, "|")} څخه وای`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `ډیر لوی: ${n.origin ?? "ارزښت"} باید ${o}${n.maximum.toString()} ${s.unit ?? "عنصرونه"} ولري` : `ډیر لوی: ${n.origin ?? "ارزښت"} باید ${o}${n.maximum.toString()} وي`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `ډیر کوچنی: ${n.origin} باید ${o}${n.minimum.toString()} ${s.unit} ولري` : `ډیر کوچنی: ${n.origin} باید ${o}${n.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `ناسم متن: باید د "${o.prefix}" سره پیل شي` : o.format === "ends_with" ? `ناسم متن: باید د "${o.suffix}" سره پای ته ورسيږي` : o.format === "includes" ? `ناسم متن: باید "${o.includes}" ولري` : o.format === "regex" ? `ناسم متن: باید د ${o.pattern} سره مطابقت ولري` : `${i[o.format] ?? n.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${n.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${n.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${n.origin} کې`;
      case "invalid_union":
        return "ناسمه ورودي";
      case "invalid_element":
        return `ناسم عنصر په ${n.origin} کې`;
      default:
        return "ناسمه ورودي";
    }
  };
};
function wI() {
  return {
    localeError: _I()
  };
}
const OI = () => {
  const e = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(n))
          return "tablica";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${n.expected}, otrzymano ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Nieprawidłowe dane wejściowe: oczekiwano ${jt(n.values[0])}` : `Nieprawidłowa opcja: oczekiwano jednej z wartości ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Za duża wartość: oczekiwano, że ${n.origin ?? "wartość"} będzie mieć ${o}${n.maximum.toString()} ${s.unit ?? "elementów"}` : `Zbyt duż(y/a/e): oczekiwano, że ${n.origin ?? "wartość"} będzie wynosić ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Za mała wartość: oczekiwano, że ${n.origin ?? "wartość"} będzie mieć ${o}${n.minimum.toString()} ${s.unit ?? "elementów"}` : `Zbyt mał(y/a/e): oczekiwano, że ${n.origin ?? "wartość"} będzie wynosić ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Nieprawidłowy ciąg znaków: musi zaczynać się od "${o.prefix}"` : o.format === "ends_with" ? `Nieprawidłowy ciąg znaków: musi kończyć się na "${o.suffix}"` : o.format === "includes" ? `Nieprawidłowy ciąg znaków: musi zawierać "${o.includes}"` : o.format === "regex" ? `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${o.pattern}` : `Nieprawidłow(y/a/e) ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${n.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${n.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${n.origin}`;
      default:
        return "Nieprawidłowe dane wejściowe";
    }
  };
};
function $I() {
  return {
    localeError: OI()
  };
}
const SI = () => {
  const e = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "número";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "nulo";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${n.expected}, recebido ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Entrada inválida: esperado ${jt(n.values[0])}` : `Opção inválida: esperada uma das ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Muito grande: esperado que ${n.origin ?? "valor"} tivesse ${o}${n.maximum.toString()} ${s.unit ?? "elementos"}` : `Muito grande: esperado que ${n.origin ?? "valor"} fosse ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Muito pequeno: esperado que ${n.origin} tivesse ${o}${n.minimum.toString()} ${s.unit}` : `Muito pequeno: esperado que ${n.origin} fosse ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Texto inválido: deve começar com "${o.prefix}"` : o.format === "ends_with" ? `Texto inválido: deve terminar com "${o.suffix}"` : o.format === "includes" ? `Texto inválido: deve incluir "${o.includes}"` : o.format === "regex" ? `Texto inválido: deve corresponder ao padrão ${o.pattern}` : `${i[o.format] ?? n.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Chave${n.keys.length > 1 ? "s" : ""} desconhecida${n.keys.length > 1 ? "s" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${n.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${n.origin}`;
      default:
        return "Campo inválido";
    }
  };
};
function EI() {
  return {
    localeError: SI()
  };
}
function Jg(e, t, r, i) {
  const n = Math.abs(e), o = n % 10, s = n % 100;
  return s >= 11 && s <= 19 ? i : o === 1 ? t : o >= 2 && o <= 4 ? r : i;
}
const xI = () => {
  const e = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "число";
      case "object": {
        if (Array.isArray(n))
          return "массив";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${n.expected}, получено ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Неверный ввод: ожидалось ${jt(n.values[0])}` : `Неверный вариант: ожидалось одно из ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        if (s) {
          const a = Number(n.maximum), u = Jg(a, s.unit.one, s.unit.few, s.unit.many);
          return `Слишком большое значение: ожидалось, что ${n.origin ?? "значение"} будет иметь ${o}${n.maximum.toString()} ${u}`;
        }
        return `Слишком большое значение: ожидалось, что ${n.origin ?? "значение"} будет ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        if (s) {
          const a = Number(n.minimum), u = Jg(a, s.unit.one, s.unit.few, s.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${n.origin} будет иметь ${o}${n.minimum.toString()} ${u}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${n.origin} будет ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Неверная строка: должна начинаться с "${o.prefix}"` : o.format === "ends_with" ? `Неверная строка: должна заканчиваться на "${o.suffix}"` : o.format === "includes" ? `Неверная строка: должна содержать "${o.includes}"` : o.format === "regex" ? `Неверная строка: должна соответствовать шаблону ${o.pattern}` : `Неверный ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${n.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${n.keys.length > 1 ? "ые" : "ый"} ключ${n.keys.length > 1 ? "и" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${n.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${n.origin}`;
      default:
        return "Неверные входные данные";
    }
  };
};
function AI() {
  return {
    localeError: xI()
  };
}
const jI = () => {
  const e = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "število";
      case "object": {
        if (Array.isArray(n))
          return "tabela";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${n.expected}, prejeto ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Neveljaven vnos: pričakovano ${jt(n.values[0])}` : `Neveljavna možnost: pričakovano eno izmed ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Preveliko: pričakovano, da bo ${n.origin ?? "vrednost"} imelo ${o}${n.maximum.toString()} ${s.unit ?? "elementov"}` : `Preveliko: pričakovano, da bo ${n.origin ?? "vrednost"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Premajhno: pričakovano, da bo ${n.origin} imelo ${o}${n.minimum.toString()} ${s.unit}` : `Premajhno: pričakovano, da bo ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Neveljaven niz: mora se začeti z "${o.prefix}"` : o.format === "ends_with" ? `Neveljaven niz: mora se končati z "${o.suffix}"` : o.format === "includes" ? `Neveljaven niz: mora vsebovati "${o.includes}"` : o.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${o.pattern}` : `Neveljaven ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${n.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${n.keys.length > 1 ? "i ključi" : " ključ"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${n.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${n.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function kI() {
  return {
    localeError: jI()
  };
}
const PI = () => {
  const e = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(n))
          return "lista";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${n.expected}, fick ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ogiltig inmatning: förväntat ${jt(n.values[0])}` : `Ogiltigt val: förväntade en av ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `För stor(t): förväntade ${n.origin ?? "värdet"} att ha ${o}${n.maximum.toString()} ${s.unit ?? "element"}` : `För stor(t): förväntat ${n.origin ?? "värdet"} att ha ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `För lite(t): förväntade ${n.origin ?? "värdet"} att ha ${o}${n.minimum.toString()} ${s.unit}` : `För lite(t): förväntade ${n.origin ?? "värdet"} att ha ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ogiltig sträng: måste börja med "${o.prefix}"` : o.format === "ends_with" ? `Ogiltig sträng: måste sluta med "${o.suffix}"` : o.format === "includes" ? `Ogiltig sträng: måste innehålla "${o.includes}"` : o.format === "regex" ? `Ogiltig sträng: måste matcha mönstret "${o.pattern}"` : `Ogiltig(t) ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${n.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${n.origin ?? "värdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function II() {
  return {
    localeError: PI()
  };
}
const TI = () => {
  const e = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "எண் அல்லாதது" : "எண்";
      case "object": {
        if (Array.isArray(n))
          return "அணி";
        if (n === null)
          return "வெறுமை";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${n.expected}, பெறப்பட்டது ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${jt(n.values[0])}` : `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${it(n.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${n.origin ?? "மதிப்பு"} ${o}${n.maximum.toString()} ${s.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்` : `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${n.origin ?? "மதிப்பு"} ${o}${n.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${n.origin} ${o}${n.minimum.toString()} ${s.unit} ஆக இருக்க வேண்டும்` : `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${n.origin} ${o}${n.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `தவறான சரம்: "${o.prefix}" இல் தொடங்க வேண்டும்` : o.format === "ends_with" ? `தவறான சரம்: "${o.suffix}" இல் முடிவடைய வேண்டும்` : o.format === "includes" ? `தவறான சரம்: "${o.includes}" ஐ உள்ளடக்க வேண்டும்` : o.format === "regex" ? `தவறான சரம்: ${o.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்` : `தவறான ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${n.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${n.keys.length > 1 ? "கள்" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${n.origin} இல் தவறான மதிப்பு`;
      default:
        return "தவறான உள்ளீடு";
    }
  };
};
function NI() {
  return {
    localeError: TI()
  };
}
const CI = () => {
  const e = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      case "object": {
        if (Array.isArray(n))
          return "อาร์เรย์ (Array)";
        if (n === null)
          return "ไม่มีค่า (null)";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${n.expected} แต่ได้รับ ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `ค่าไม่ถูกต้อง: ควรเป็น ${jt(n.values[0])}` : `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "ไม่เกิน" : "น้อยกว่า", s = t(n.origin);
        return s ? `เกินกำหนด: ${n.origin ?? "ค่า"} ควรมี${o} ${n.maximum.toString()} ${s.unit ?? "รายการ"}` : `เกินกำหนด: ${n.origin ?? "ค่า"} ควรมี${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? "อย่างน้อย" : "มากกว่า", s = t(n.origin);
        return s ? `น้อยกว่ากำหนด: ${n.origin} ควรมี${o} ${n.minimum.toString()} ${s.unit}` : `น้อยกว่ากำหนด: ${n.origin} ควรมี${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${o.prefix}"` : o.format === "ends_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${o.suffix}"` : o.format === "includes" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${o.includes}" อยู่ในข้อความ` : o.format === "regex" ? `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${o.pattern}` : `รูปแบบไม่ถูกต้อง: ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${n.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${n.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${n.origin}`;
      default:
        return "ข้อมูลไม่ถูกต้อง";
    }
  };
};
function RI() {
  return {
    localeError: CI()
  };
}
const DI = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, zI = () => {
  const e = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function t(i) {
    return e[i] ?? null;
  }
  const r = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (i) => {
    switch (i.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${i.expected}, alınan ${DI(i.input)}`;
      case "invalid_value":
        return i.values.length === 1 ? `Geçersiz değer: beklenen ${jt(i.values[0])}` : `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${it(i.values, "|")}`;
      case "too_big": {
        const n = i.inclusive ? "<=" : "<", o = t(i.origin);
        return o ? `Çok büyük: beklenen ${i.origin ?? "değer"} ${n}${i.maximum.toString()} ${o.unit ?? "öğe"}` : `Çok büyük: beklenen ${i.origin ?? "değer"} ${n}${i.maximum.toString()}`;
      }
      case "too_small": {
        const n = i.inclusive ? ">=" : ">", o = t(i.origin);
        return o ? `Çok küçük: beklenen ${i.origin} ${n}${i.minimum.toString()} ${o.unit}` : `Çok küçük: beklenen ${i.origin} ${n}${i.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = i;
        return n.format === "starts_with" ? `Geçersiz metin: "${n.prefix}" ile başlamalı` : n.format === "ends_with" ? `Geçersiz metin: "${n.suffix}" ile bitmeli` : n.format === "includes" ? `Geçersiz metin: "${n.includes}" içermeli` : n.format === "regex" ? `Geçersiz metin: ${n.pattern} desenine uymalı` : `Geçersiz ${r[n.format] ?? i.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${i.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${i.keys.length > 1 ? "lar" : ""}: ${it(i.keys, ", ")}`;
      case "invalid_key":
        return `${i.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${i.origin} içinde geçersiz değer`;
      default:
        return "Geçersiz değer";
    }
  };
};
function UI() {
  return {
    localeError: zI()
  };
}
const MI = () => {
  const e = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "число";
      case "object": {
        if (Array.isArray(n))
          return "масив";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${n.expected}, отримано ${r(n.input)}`;
      // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Неправильні вхідні дані: очікується ${jt(n.values[0])}` : `Неправильна опція: очікується одне з ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Занадто велике: очікується, що ${n.origin ?? "значення"} ${s.verb} ${o}${n.maximum.toString()} ${s.unit ?? "елементів"}` : `Занадто велике: очікується, що ${n.origin ?? "значення"} буде ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Занадто мале: очікується, що ${n.origin} ${s.verb} ${o}${n.minimum.toString()} ${s.unit}` : `Занадто мале: очікується, що ${n.origin} буде ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Неправильний рядок: повинен починатися з "${o.prefix}"` : o.format === "ends_with" ? `Неправильний рядок: повинен закінчуватися на "${o.suffix}"` : o.format === "includes" ? `Неправильний рядок: повинен містити "${o.includes}"` : o.format === "regex" ? `Неправильний рядок: повинен відповідати шаблону ${o.pattern}` : `Неправильний ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${n.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${n.keys.length > 1 ? "і" : ""}: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${n.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${n.origin}`;
      default:
        return "Неправильні вхідні дані";
    }
  };
};
function jS() {
  return {
    localeError: MI()
  };
}
function FI() {
  return jS();
}
const LI = () => {
  const e = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "نمبر";
      case "object": {
        if (Array.isArray(n))
          return "آرے";
        if (n === null)
          return "نل";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${n.expected} متوقع تھا، ${r(n.input)} موصول ہوا`;
      case "invalid_value":
        return n.values.length === 1 ? `غلط ان پٹ: ${jt(n.values[0])} متوقع تھا` : `غلط آپشن: ${it(n.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `بہت بڑا: ${n.origin ?? "ویلیو"} کے ${o}${n.maximum.toString()} ${s.unit ?? "عناصر"} ہونے متوقع تھے` : `بہت بڑا: ${n.origin ?? "ویلیو"} کا ${o}${n.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `بہت چھوٹا: ${n.origin} کے ${o}${n.minimum.toString()} ${s.unit} ہونے متوقع تھے` : `بہت چھوٹا: ${n.origin} کا ${o}${n.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `غلط سٹرنگ: "${o.prefix}" سے شروع ہونا چاہیے` : o.format === "ends_with" ? `غلط سٹرنگ: "${o.suffix}" پر ختم ہونا چاہیے` : o.format === "includes" ? `غلط سٹرنگ: "${o.includes}" شامل ہونا چاہیے` : o.format === "regex" ? `غلط سٹرنگ: پیٹرن ${o.pattern} سے میچ ہونا چاہیے` : `غلط ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${n.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${n.keys.length > 1 ? "ز" : ""}: ${it(n.keys, "، ")}`;
      case "invalid_key":
        return `${n.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${n.origin} میں غلط ویلیو`;
      default:
        return "غلط ان پٹ";
    }
  };
};
function BI() {
  return {
    localeError: LI()
  };
}
const qI = () => {
  const e = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "số";
      case "object": {
        if (Array.isArray(n))
          return "mảng";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${n.expected}, nhận được ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Đầu vào không hợp lệ: mong đợi ${jt(n.values[0])}` : `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Quá lớn: mong đợi ${n.origin ?? "giá trị"} ${s.verb} ${o}${n.maximum.toString()} ${s.unit ?? "phần tử"}` : `Quá lớn: mong đợi ${n.origin ?? "giá trị"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Quá nhỏ: mong đợi ${n.origin} ${s.verb} ${o}${n.minimum.toString()} ${s.unit}` : `Quá nhỏ: mong đợi ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Chuỗi không hợp lệ: phải bắt đầu bằng "${o.prefix}"` : o.format === "ends_with" ? `Chuỗi không hợp lệ: phải kết thúc bằng "${o.suffix}"` : o.format === "includes" ? `Chuỗi không hợp lệ: phải bao gồm "${o.includes}"` : o.format === "regex" ? `Chuỗi không hợp lệ: phải khớp với mẫu ${o.pattern}` : `${i[o.format] ?? n.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${n.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${n.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${n.origin}`;
      default:
        return "Đầu vào không hợp lệ";
    }
  };
};
function ZI() {
  return {
    localeError: qI()
  };
}
const VI = () => {
  const e = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "非数字(NaN)" : "数字";
      case "object": {
        if (Array.isArray(n))
          return "数组";
        if (n === null)
          return "空值(null)";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `无效输入：期望 ${n.expected}，实际接收 ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `无效输入：期望 ${jt(n.values[0])}` : `无效选项：期望以下之一 ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `数值过大：期望 ${n.origin ?? "值"} ${o}${n.maximum.toString()} ${s.unit ?? "个元素"}` : `数值过大：期望 ${n.origin ?? "值"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `数值过小：期望 ${n.origin} ${o}${n.minimum.toString()} ${s.unit}` : `数值过小：期望 ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `无效字符串：必须以 "${o.prefix}" 开头` : o.format === "ends_with" ? `无效字符串：必须以 "${o.suffix}" 结尾` : o.format === "includes" ? `无效字符串：必须包含 "${o.includes}"` : o.format === "regex" ? `无效字符串：必须满足正则表达式 ${o.pattern}` : `无效${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${n.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${n.origin} 中包含无效值(value)`;
      default:
        return "无效输入";
    }
  };
};
function WI() {
  return {
    localeError: VI()
  };
}
const GI = () => {
  const e = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${n.expected}，但收到 ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `無效的輸入值：預期為 ${jt(n.values[0])}` : `無效的選項：預期為以下其中之一 ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `數值過大：預期 ${n.origin ?? "值"} 應為 ${o}${n.maximum.toString()} ${s.unit ?? "個元素"}` : `數值過大：預期 ${n.origin ?? "值"} 應為 ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `數值過小：預期 ${n.origin} 應為 ${o}${n.minimum.toString()} ${s.unit}` : `數值過小：預期 ${n.origin} 應為 ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `無效的字串：必須以 "${o.prefix}" 開頭` : o.format === "ends_with" ? `無效的字串：必須以 "${o.suffix}" 結尾` : o.format === "includes" ? `無效的字串：必須包含 "${o.includes}"` : o.format === "regex" ? `無效的字串：必須符合格式 ${o.pattern}` : `無效的 ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${n.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${n.keys.length > 1 ? "們" : ""}：${it(n.keys, "、")}`;
      case "invalid_key":
        return `${n.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${n.origin} 中有無效的值`;
      default:
        return "無效的輸入值";
    }
  };
};
function KI() {
  return {
    localeError: GI()
  };
}
const HI = () => {
  const e = {
    string: { unit: "àmi", verb: "ní" },
    file: { unit: "bytes", verb: "ní" },
    array: { unit: "nkan", verb: "ní" },
    set: { unit: "nkan", verb: "ní" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const r = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "nọ́mbà";
      case "object": {
        if (Array.isArray(n))
          return "akopọ";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, i = {
    regex: "ẹ̀rọ ìbáwọlé",
    email: "àdírẹ́sì ìmẹ́lì",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "àkókò ISO",
    date: "ọjọ́ ISO",
    time: "àkókò ISO",
    duration: "àkókò tó pé ISO",
    ipv4: "àdírẹ́sì IPv4",
    ipv6: "àdírẹ́sì IPv6",
    cidrv4: "àgbègbè IPv4",
    cidrv6: "àgbègbè IPv6",
    base64: "ọ̀rọ̀ tí a kọ́ ní base64",
    base64url: "ọ̀rọ̀ base64url",
    json_string: "ọ̀rọ̀ JSON",
    e164: "nọ́mbà E.164",
    jwt: "JWT",
    template_literal: "ẹ̀rọ ìbáwọlé"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ìbáwọlé aṣìṣe: a ní láti fi ${n.expected}, àmọ̀ a rí ${r(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ìbáwọlé aṣìṣe: a ní láti fi ${jt(n.values[0])}` : `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${it(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", s = t(n.origin);
        return s ? `Tó pọ̀ jù: a ní láti jẹ́ pé ${n.origin ?? "iye"} ${s.verb} ${o}${n.maximum} ${s.unit}` : `Tó pọ̀ jù: a ní láti jẹ́ ${o}${n.maximum}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", s = t(n.origin);
        return s ? `Kéré ju: a ní láti jẹ́ pé ${n.origin} ${s.verb} ${o}${n.minimum} ${s.unit}` : `Kéré ju: a ní láti jẹ́ ${o}${n.minimum}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${o.prefix}"` : o.format === "ends_with" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${o.suffix}"` : o.format === "includes" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${o.includes}"` : o.format === "regex" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${o.pattern}` : `Aṣìṣe: ${i[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${n.divisor}`;
      case "unrecognized_keys":
        return `Bọtìnì àìmọ̀: ${it(n.keys, ", ")}`;
      case "invalid_key":
        return `Bọtìnì aṣìṣe nínú ${n.origin}`;
      case "invalid_union":
        return "Ìbáwọlé aṣìṣe";
      case "invalid_element":
        return `Iye aṣìṣe nínú ${n.origin}`;
      default:
        return "Ìbáwọlé aṣìṣe";
    }
  };
};
function JI() {
  return {
    localeError: HI()
  };
}
const kS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, ar: lP, az: hP, be: dP, bg: gP, ca: bP, cs: wP, da: $P, de: EP, en: xS, eo: PP, es: TP, fa: CP, fi: DP, fr: UP, frCA: FP, he: BP, hu: ZP, id: WP, is: HP, it: YP, ja: QP, ka: rI, kh: iI, km: AS, ko: aI, lt: cI, mk: fI, ms: pI, nl: mI, no: gI, ota: bI, pl: $I, ps: wI, pt: EI, ru: AI, sl: kI, sv: II, ta: NI, th: RI, tr: UI, ua: FI, uk: jS, ur: BI, vi: ZI, yo: JI, zhCN: WI, zhTW: KI }, Symbol.toStringTag, { value: "Module" })), PS = Symbol("ZodOutput"), IS = Symbol("ZodInput");
let xd = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...r) {
    const i = r[0];
    if (this._map.set(t, i), i && typeof i == "object" && "id" in i) {
      if (this._idmap.has(i.id))
        throw new Error(`ID ${i.id} already exists in the registry`);
      this._idmap.set(i.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const r = this._map.get(t);
    return r && typeof r == "object" && "id" in r && this._idmap.delete(r.id), this._map.delete(t), this;
  }
  get(t) {
    const r = t._zod.parent;
    if (r) {
      const i = { ...this.get(r) ?? {} };
      delete i.id;
      const n = { ...i, ...this._map.get(t) };
      return Object.keys(n).length ? n : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
};
function Ad() {
  return new xd();
}
const Hi = /* @__PURE__ */ Ad();
function TS(e, t) {
  return new e({
    type: "string",
    ...Je(t)
  });
}
function NS(e, t) {
  return new e({
    type: "string",
    coerce: !0,
    ...Je(t)
  });
}
function jd(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Ks(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function kd(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Pd(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...Je(t)
  });
}
function Id(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...Je(t)
  });
}
function Td(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...Je(t)
  });
}
function Eu(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Nd(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Cd(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Rd(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Dd(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function zd(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Ud(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Md(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Fd(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Ld(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Bd(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function qd(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Zd(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Vd(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Wd(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
function Gd(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...Je(t)
  });
}
const CS = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function RS(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...Je(t)
  });
}
function DS(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...Je(t)
  });
}
function zS(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...Je(t)
  });
}
function US(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...Je(t)
  });
}
function MS(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...Je(t)
  });
}
function FS(e, t) {
  return new e({
    type: "number",
    coerce: !0,
    checks: [],
    ...Je(t)
  });
}
function LS(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...Je(t)
  });
}
function BS(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...Je(t)
  });
}
function qS(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...Je(t)
  });
}
function ZS(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...Je(t)
  });
}
function VS(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...Je(t)
  });
}
function WS(e, t) {
  return new e({
    type: "boolean",
    ...Je(t)
  });
}
function GS(e, t) {
  return new e({
    type: "boolean",
    coerce: !0,
    ...Je(t)
  });
}
function KS(e, t) {
  return new e({
    type: "bigint",
    ...Je(t)
  });
}
function HS(e, t) {
  return new e({
    type: "bigint",
    coerce: !0,
    ...Je(t)
  });
}
function JS(e, t) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...Je(t)
  });
}
function YS(e, t) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...Je(t)
  });
}
function XS(e, t) {
  return new e({
    type: "symbol",
    ...Je(t)
  });
}
function QS(e, t) {
  return new e({
    type: "undefined",
    ...Je(t)
  });
}
function eE(e, t) {
  return new e({
    type: "null",
    ...Je(t)
  });
}
function tE(e) {
  return new e({
    type: "any"
  });
}
function rE(e) {
  return new e({
    type: "unknown"
  });
}
function nE(e, t) {
  return new e({
    type: "never",
    ...Je(t)
  });
}
function iE(e, t) {
  return new e({
    type: "void",
    ...Je(t)
  });
}
function oE(e, t) {
  return new e({
    type: "date",
    ...Je(t)
  });
}
function aE(e, t) {
  return new e({
    type: "date",
    coerce: !0,
    ...Je(t)
  });
}
function sE(e, t) {
  return new e({
    type: "nan",
    ...Je(t)
  });
}
function ro(e, t) {
  return new gd({
    check: "less_than",
    ...Je(t),
    value: e,
    inclusive: !1
  });
}
function Wn(e, t) {
  return new gd({
    check: "less_than",
    ...Je(t),
    value: e,
    inclusive: !0
  });
}
function no(e, t) {
  return new vd({
    check: "greater_than",
    ...Je(t),
    value: e,
    inclusive: !1
  });
}
function kn(e, t) {
  return new vd({
    check: "greater_than",
    ...Je(t),
    value: e,
    inclusive: !0
  });
}
function uE(e) {
  return no(0, e);
}
function cE(e) {
  return ro(0, e);
}
function lE(e) {
  return Wn(0, e);
}
function fE(e) {
  return kn(0, e);
}
function Pa(e, t) {
  return new HO({
    check: "multiple_of",
    ...Je(t),
    value: e
  });
}
function xu(e, t) {
  return new XO({
    check: "max_size",
    ...Je(t),
    maximum: e
  });
}
function Ia(e, t) {
  return new QO({
    check: "min_size",
    ...Je(t),
    minimum: e
  });
}
function Kd(e, t) {
  return new e$({
    check: "size_equals",
    ...Je(t),
    size: e
  });
}
function Au(e, t) {
  return new t$({
    check: "max_length",
    ...Je(t),
    maximum: e
  });
}
function Ro(e, t) {
  return new r$({
    check: "min_length",
    ...Je(t),
    minimum: e
  });
}
function ju(e, t) {
  return new n$({
    check: "length_equals",
    ...Je(t),
    length: e
  });
}
function Hd(e, t) {
  return new i$({
    check: "string_format",
    format: "regex",
    ...Je(t),
    pattern: e
  });
}
function Jd(e) {
  return new o$({
    check: "string_format",
    format: "lowercase",
    ...Je(e)
  });
}
function Yd(e) {
  return new a$({
    check: "string_format",
    format: "uppercase",
    ...Je(e)
  });
}
function Xd(e, t) {
  return new s$({
    check: "string_format",
    format: "includes",
    ...Je(t),
    includes: e
  });
}
function Qd(e, t) {
  return new u$({
    check: "string_format",
    format: "starts_with",
    ...Je(t),
    prefix: e
  });
}
function em(e, t) {
  return new c$({
    check: "string_format",
    format: "ends_with",
    ...Je(t),
    suffix: e
  });
}
function hE(e, t, r) {
  return new l$({
    check: "property",
    property: e,
    schema: t,
    ...Je(r)
  });
}
function tm(e, t) {
  return new f$({
    check: "mime_type",
    mime: e,
    ...Je(t)
  });
}
function po(e) {
  return new h$({
    check: "overwrite",
    tx: e
  });
}
function rm(e) {
  return po((t) => t.normalize(e));
}
function nm() {
  return po((e) => e.trim());
}
function im() {
  return po((e) => e.toLowerCase());
}
function om() {
  return po((e) => e.toUpperCase());
}
function pE(e, t, r) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...Je(r)
  });
}
function YI(e, t, r) {
  return new e({
    type: "union",
    options: t,
    ...Je(r)
  });
}
function XI(e, t, r, i) {
  return new e({
    type: "union",
    options: r,
    discriminator: t,
    ...Je(i)
  });
}
function QI(e, t, r) {
  return new e({
    type: "intersection",
    left: t,
    right: r
  });
}
function eT(e, t, r, i) {
  const n = r instanceof Ct, o = n ? i : r, s = n ? r : null;
  return new e({
    type: "tuple",
    items: t,
    rest: s,
    ...Je(o)
  });
}
function tT(e, t, r, i) {
  return new e({
    type: "record",
    keyType: t,
    valueType: r,
    ...Je(i)
  });
}
function rT(e, t, r, i) {
  return new e({
    type: "map",
    keyType: t,
    valueType: r,
    ...Je(i)
  });
}
function nT(e, t, r) {
  return new e({
    type: "set",
    valueType: t,
    ...Je(r)
  });
}
function iT(e, t, r) {
  const i = Array.isArray(t) ? Object.fromEntries(t.map((n) => [n, n])) : t;
  return new e({
    type: "enum",
    entries: i,
    ...Je(r)
  });
}
function oT(e, t, r) {
  return new e({
    type: "enum",
    entries: t,
    ...Je(r)
  });
}
function aT(e, t, r) {
  return new e({
    type: "literal",
    values: Array.isArray(t) ? t : [t],
    ...Je(r)
  });
}
function dE(e, t) {
  return new e({
    type: "file",
    ...Je(t)
  });
}
function sT(e, t) {
  return new e({
    type: "transform",
    transform: t
  });
}
function uT(e, t) {
  return new e({
    type: "optional",
    innerType: t
  });
}
function cT(e, t) {
  return new e({
    type: "nullable",
    innerType: t
  });
}
function lT(e, t, r) {
  return new e({
    type: "default",
    innerType: t,
    get defaultValue() {
      return typeof r == "function" ? r() : Ou(r);
    }
  });
}
function fT(e, t, r) {
  return new e({
    type: "nonoptional",
    innerType: t,
    ...Je(r)
  });
}
function hT(e, t) {
  return new e({
    type: "success",
    innerType: t
  });
}
function pT(e, t, r) {
  return new e({
    type: "catch",
    innerType: t,
    catchValue: typeof r == "function" ? r : () => r
  });
}
function dT(e, t, r) {
  return new e({
    type: "pipe",
    in: t,
    out: r
  });
}
function mT(e, t) {
  return new e({
    type: "readonly",
    innerType: t
  });
}
function yT(e, t, r) {
  return new e({
    type: "template_literal",
    parts: t,
    ...Je(r)
  });
}
function gT(e, t) {
  return new e({
    type: "lazy",
    getter: t
  });
}
function vT(e, t) {
  return new e({
    type: "promise",
    innerType: t
  });
}
function mE(e, t, r) {
  const i = Je(r);
  return i.abort ?? (i.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...i
  });
}
function yE(e, t, r) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...Je(r)
  });
}
function gE(e) {
  const t = vE((r) => (r.addIssue = (i) => {
    if (typeof i == "string")
      r.issues.push(No(i, r.value, t._zod.def));
    else {
      const n = i;
      n.fatal && (n.continue = !1), n.code ?? (n.code = "custom"), n.input ?? (n.input = r.value), n.inst ?? (n.inst = t), n.continue ?? (n.continue = !t._zod.def.abort), r.issues.push(No(n));
    }
  }, e(r.value, r)));
  return t;
}
function vE(e, t) {
  const r = new Cr({
    check: "custom",
    ...Je(t)
  });
  return r._zod.check = e, r;
}
function bE(e, t) {
  const r = Je(t);
  let i = r.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], n = r.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  r.case !== "sensitive" && (i = i.map((p) => typeof p == "string" ? p.toLowerCase() : p), n = n.map((p) => typeof p == "string" ? p.toLowerCase() : p));
  const o = new Set(i), s = new Set(n), a = e.Codec ?? Ed, u = e.Boolean ?? wd, c = e.String ?? Ka, f = new c({ type: "string", error: r.error }), h = new u({ type: "boolean", error: r.error }), y = new a({
    type: "pipe",
    in: f,
    out: h,
    transform: ((p, l) => {
      let d = p;
      return r.case !== "sensitive" && (d = d.toLowerCase()), o.has(d) ? !0 : s.has(d) ? !1 : (l.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...o, ...s],
        input: l.value,
        inst: y,
        continue: !1
      }), {});
    }),
    reverseTransform: ((p, l) => p === !0 ? i[0] || "true" : n[0] || "false"),
    error: r.error
  });
  return y;
}
function Ha(e, t, r, i = {}) {
  const n = Je(i), o = {
    ...Je(i),
    check: "string_format",
    type: "string",
    format: t,
    fn: typeof r == "function" ? r : (a) => r.test(a),
    ...n
  };
  return r instanceof RegExp && (o.pattern = r), new e(o);
}
class ep {
  constructor(t) {
    this.counter = 0, this.metadataRegistry = t?.metadata ?? Hi, this.target = t?.target ?? "draft-2020-12", this.unrepresentable = t?.unrepresentable ?? "throw", this.override = t?.override ?? (() => {
    }), this.io = t?.io ?? "output", this.seen = /* @__PURE__ */ new Map();
  }
  process(t, r = { path: [], schemaPath: [] }) {
    var i;
    const n = t._zod.def, o = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    }, s = this.seen.get(t);
    if (s)
      return s.count++, r.schemaPath.includes(t) && (s.cycle = r.path), s.schema;
    const a = { schema: {}, count: 1, cycle: void 0, path: r.path };
    this.seen.set(t, a);
    const u = t._zod.toJSONSchema?.();
    if (u)
      a.schema = u;
    else {
      const h = {
        ...r,
        schemaPath: [...r.schemaPath, t],
        path: r.path
      }, y = t._zod.parent;
      if (y)
        a.ref = y, this.process(y, h), this.seen.get(y).isParent = !0;
      else {
        const p = a.schema;
        switch (n.type) {
          case "string": {
            const l = p;
            l.type = "string";
            const { minimum: d, maximum: v, format: m, patterns: g, contentEncoding: _ } = t._zod.bag;
            if (typeof d == "number" && (l.minLength = d), typeof v == "number" && (l.maxLength = v), m && (l.format = o[m] ?? m, l.format === "" && delete l.format), _ && (l.contentEncoding = _), g && g.size > 0) {
              const b = [...g];
              b.length === 1 ? l.pattern = b[0].source : b.length > 1 && (a.schema.allOf = [
                ...b.map((w) => ({
                  ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                  pattern: w.source
                }))
              ]);
            }
            break;
          }
          case "number": {
            const l = p, { minimum: d, maximum: v, format: m, multipleOf: g, exclusiveMaximum: _, exclusiveMinimum: b } = t._zod.bag;
            typeof m == "string" && m.includes("int") ? l.type = "integer" : l.type = "number", typeof b == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (l.minimum = b, l.exclusiveMinimum = !0) : l.exclusiveMinimum = b), typeof d == "number" && (l.minimum = d, typeof b == "number" && this.target !== "draft-4" && (b >= d ? delete l.minimum : delete l.exclusiveMinimum)), typeof _ == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (l.maximum = _, l.exclusiveMaximum = !0) : l.exclusiveMaximum = _), typeof v == "number" && (l.maximum = v, typeof _ == "number" && this.target !== "draft-4" && (_ <= v ? delete l.maximum : delete l.exclusiveMaximum)), typeof g == "number" && (l.multipleOf = g);
            break;
          }
          case "boolean": {
            const l = p;
            l.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw")
              throw new Error("BigInt cannot be represented in JSON Schema");
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw")
              throw new Error("Symbols cannot be represented in JSON Schema");
            break;
          }
          case "null": {
            this.target === "openapi-3.0" ? (p.type = "string", p.nullable = !0, p.enum = [null]) : p.type = "null";
            break;
          }
          case "any":
            break;
          case "unknown":
            break;
          case "undefined": {
            if (this.unrepresentable === "throw")
              throw new Error("Undefined cannot be represented in JSON Schema");
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw")
              throw new Error("Void cannot be represented in JSON Schema");
            break;
          }
          case "never": {
            p.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw")
              throw new Error("Date cannot be represented in JSON Schema");
            break;
          }
          case "array": {
            const l = p, { minimum: d, maximum: v } = t._zod.bag;
            typeof d == "number" && (l.minItems = d), typeof v == "number" && (l.maxItems = v), l.type = "array", l.items = this.process(n.element, { ...h, path: [...h.path, "items"] });
            break;
          }
          case "object": {
            const l = p;
            l.type = "object", l.properties = {};
            const d = n.shape;
            for (const g in d)
              l.properties[g] = this.process(d[g], {
                ...h,
                path: [...h.path, "properties", g]
              });
            const v = new Set(Object.keys(d)), m = new Set([...v].filter((g) => {
              const _ = n.shape[g]._zod;
              return this.io === "input" ? _.optin === void 0 : _.optout === void 0;
            }));
            m.size > 0 && (l.required = Array.from(m)), n.catchall?._zod.def.type === "never" ? l.additionalProperties = !1 : n.catchall ? n.catchall && (l.additionalProperties = this.process(n.catchall, {
              ...h,
              path: [...h.path, "additionalProperties"]
            })) : this.io === "output" && (l.additionalProperties = !1);
            break;
          }
          case "union": {
            const l = p, d = n.options.map((v, m) => this.process(v, {
              ...h,
              path: [...h.path, "anyOf", m]
            }));
            l.anyOf = d;
            break;
          }
          case "intersection": {
            const l = p, d = this.process(n.left, {
              ...h,
              path: [...h.path, "allOf", 0]
            }), v = this.process(n.right, {
              ...h,
              path: [...h.path, "allOf", 1]
            }), m = (_) => "allOf" in _ && Object.keys(_).length === 1, g = [
              ...m(d) ? d.allOf : [d],
              ...m(v) ? v.allOf : [v]
            ];
            l.allOf = g;
            break;
          }
          case "tuple": {
            const l = p;
            l.type = "array";
            const d = this.target === "draft-2020-12" ? "prefixItems" : "items", v = this.target === "draft-2020-12" || this.target === "openapi-3.0" ? "items" : "additionalItems", m = n.items.map((w, A) => this.process(w, {
              ...h,
              path: [...h.path, d, A]
            })), g = n.rest ? this.process(n.rest, {
              ...h,
              path: [...h.path, v, ...this.target === "openapi-3.0" ? [n.items.length] : []]
            }) : null;
            this.target === "draft-2020-12" ? (l.prefixItems = m, g && (l.items = g)) : this.target === "openapi-3.0" ? (l.items = {
              anyOf: m
            }, g && l.items.anyOf.push(g), l.minItems = m.length, g || (l.maxItems = m.length)) : (l.items = m, g && (l.additionalItems = g));
            const { minimum: _, maximum: b } = t._zod.bag;
            typeof _ == "number" && (l.minItems = _), typeof b == "number" && (l.maxItems = b);
            break;
          }
          case "record": {
            const l = p;
            l.type = "object", (this.target === "draft-7" || this.target === "draft-2020-12") && (l.propertyNames = this.process(n.keyType, {
              ...h,
              path: [...h.path, "propertyNames"]
            })), l.additionalProperties = this.process(n.valueType, {
              ...h,
              path: [...h.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw")
              throw new Error("Map cannot be represented in JSON Schema");
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw")
              throw new Error("Set cannot be represented in JSON Schema");
            break;
          }
          case "enum": {
            const l = p, d = td(n.entries);
            d.every((v) => typeof v == "number") && (l.type = "number"), d.every((v) => typeof v == "string") && (l.type = "string"), l.enum = d;
            break;
          }
          case "literal": {
            const l = p, d = [];
            for (const v of n.values)
              if (v === void 0) {
                if (this.unrepresentable === "throw")
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
              } else if (typeof v == "bigint") {
                if (this.unrepresentable === "throw")
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                d.push(Number(v));
              } else
                d.push(v);
            if (d.length !== 0) if (d.length === 1) {
              const v = d[0];
              l.type = v === null ? "null" : typeof v, this.target === "draft-4" || this.target === "openapi-3.0" ? l.enum = [v] : l.const = v;
            } else
              d.every((v) => typeof v == "number") && (l.type = "number"), d.every((v) => typeof v == "string") && (l.type = "string"), d.every((v) => typeof v == "boolean") && (l.type = "string"), d.every((v) => v === null) && (l.type = "null"), l.enum = d;
            break;
          }
          case "file": {
            const l = p, d = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            }, { minimum: v, maximum: m, mime: g } = t._zod.bag;
            v !== void 0 && (d.minLength = v), m !== void 0 && (d.maxLength = m), g ? g.length === 1 ? (d.contentMediaType = g[0], Object.assign(l, d)) : l.anyOf = g.map((_) => ({ ...d, contentMediaType: _ })) : Object.assign(l, d);
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw")
              throw new Error("Transforms cannot be represented in JSON Schema");
            break;
          }
          case "nullable": {
            const l = this.process(n.innerType, h);
            this.target === "openapi-3.0" ? (a.ref = n.innerType, p.nullable = !0) : p.anyOf = [l, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(n.innerType, h), a.ref = n.innerType;
            break;
          }
          case "success": {
            const l = p;
            l.type = "boolean";
            break;
          }
          case "default": {
            this.process(n.innerType, h), a.ref = n.innerType, p.default = JSON.parse(JSON.stringify(n.defaultValue));
            break;
          }
          case "prefault": {
            this.process(n.innerType, h), a.ref = n.innerType, this.io === "input" && (p._prefault = JSON.parse(JSON.stringify(n.defaultValue)));
            break;
          }
          case "catch": {
            this.process(n.innerType, h), a.ref = n.innerType;
            let l;
            try {
              l = n.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            p.default = l;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw")
              throw new Error("NaN cannot be represented in JSON Schema");
            break;
          }
          case "template_literal": {
            const l = p, d = t._zod.pattern;
            if (!d)
              throw new Error("Pattern not found in template literal");
            l.type = "string", l.pattern = d.source;
            break;
          }
          case "pipe": {
            const l = this.io === "input" ? n.in._zod.def.type === "transform" ? n.out : n.in : n.out;
            this.process(l, h), a.ref = l;
            break;
          }
          case "readonly": {
            this.process(n.innerType, h), a.ref = n.innerType, p.readOnly = !0;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(n.innerType, h), a.ref = n.innerType;
            break;
          }
          case "optional": {
            this.process(n.innerType, h), a.ref = n.innerType;
            break;
          }
          case "lazy": {
            const l = t._zod.innerType;
            this.process(l, h), a.ref = l;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw")
              throw new Error("Custom types cannot be represented in JSON Schema");
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw")
              throw new Error("Function types cannot be represented in JSON Schema");
            break;
          }
        }
      }
    }
    const c = this.metadataRegistry.get(t);
    return c && Object.assign(a.schema, c), this.io === "input" && Yr(t) && (delete a.schema.examples, delete a.schema.default), this.io === "input" && a.schema._prefault && ((i = a.schema).default ?? (i.default = a.schema._prefault)), delete a.schema._prefault, this.seen.get(t).schema;
  }
  emit(t, r) {
    const i = {
      cycles: r?.cycles ?? "ref",
      reused: r?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: r?.external ?? void 0
    }, n = this.seen.get(t);
    if (!n)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const o = (f) => {
      const h = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (i.external) {
        const d = i.external.registry.get(f[0])?.id, v = i.external.uri ?? ((g) => g);
        if (d)
          return { ref: v(d) };
        const m = f[1].defId ?? f[1].schema.id ?? `schema${this.counter++}`;
        return f[1].defId = m, { defId: m, ref: `${v("__shared")}#/${h}/${m}` };
      }
      if (f[1] === n)
        return { ref: "#" };
      const p = `#/${h}/`, l = f[1].schema.id ?? `__schema${this.counter++}`;
      return { defId: l, ref: p + l };
    }, s = (f) => {
      if (f[1].schema.$ref)
        return;
      const h = f[1], { ref: y, defId: p } = o(f);
      h.def = { ...h.schema }, p && (h.defId = p);
      const l = h.schema;
      for (const d in l)
        delete l[d];
      l.$ref = y;
    };
    if (i.cycles === "throw")
      for (const f of this.seen.entries()) {
        const h = f[1];
        if (h.cycle)
          throw new Error(`Cycle detected: #/${h.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    for (const f of this.seen.entries()) {
      const h = f[1];
      if (t === f[0]) {
        s(f);
        continue;
      }
      if (i.external) {
        const p = i.external.registry.get(f[0])?.id;
        if (t !== f[0] && p) {
          s(f);
          continue;
        }
      }
      if (this.metadataRegistry.get(f[0])?.id) {
        s(f);
        continue;
      }
      if (h.cycle) {
        s(f);
        continue;
      }
      if (h.count > 1 && i.reused === "ref") {
        s(f);
        continue;
      }
    }
    const a = (f, h) => {
      const y = this.seen.get(f), p = y.def ?? y.schema, l = { ...p };
      if (y.ref === null)
        return;
      const d = y.ref;
      if (y.ref = null, d) {
        a(d, h);
        const v = this.seen.get(d).schema;
        v.$ref && (h.target === "draft-7" || h.target === "draft-4" || h.target === "openapi-3.0") ? (p.allOf = p.allOf ?? [], p.allOf.push(v)) : (Object.assign(p, v), Object.assign(p, l));
      }
      y.isParent || this.override({
        zodSchema: f,
        jsonSchema: p,
        path: y.path ?? []
      });
    };
    for (const f of [...this.seen.entries()].reverse())
      a(f[0], { target: this.target });
    const u = {};
    if (this.target === "draft-2020-12" ? u.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? u.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? u.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), i.external?.uri) {
      const f = i.external.registry.get(t)?.id;
      if (!f)
        throw new Error("Schema is missing an `id` property");
      u.$id = i.external.uri(f);
    }
    Object.assign(u, n.def);
    const c = i.external?.defs ?? {};
    for (const f of this.seen.entries()) {
      const h = f[1];
      h.def && h.defId && (c[h.defId] = h.def);
    }
    i.external || Object.keys(c).length > 0 && (this.target === "draft-2020-12" ? u.$defs = c : u.definitions = c);
    try {
      return JSON.parse(JSON.stringify(u));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function _E(e, t) {
  if (e instanceof xd) {
    const i = new ep(t), n = {};
    for (const a of e._idmap.entries()) {
      const [u, c] = a;
      i.process(c);
    }
    const o = {}, s = {
      registry: e,
      uri: t?.uri,
      defs: n
    };
    for (const a of e._idmap.entries()) {
      const [u, c] = a;
      o[u] = i.emit(c, {
        ...t,
        external: s
      });
    }
    if (Object.keys(n).length > 0) {
      const a = i.target === "draft-2020-12" ? "$defs" : "definitions";
      o.__shared = {
        [a]: n
      };
    }
    return { schemas: o };
  }
  const r = new ep(t);
  return r.process(e), r.emit(e, t);
}
function Yr(e, t) {
  const r = t ?? { seen: /* @__PURE__ */ new Set() };
  if (r.seen.has(e))
    return !1;
  r.seen.add(e);
  const n = e._zod.def;
  switch (n.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return Yr(n.element, r);
    case "object": {
      for (const o in n.shape)
        if (Yr(n.shape[o], r))
          return !0;
      return !1;
    }
    case "union": {
      for (const o of n.options)
        if (Yr(o, r))
          return !0;
      return !1;
    }
    case "intersection":
      return Yr(n.left, r) || Yr(n.right, r);
    case "tuple": {
      for (const o of n.items)
        if (Yr(o, r))
          return !0;
      return !!(n.rest && Yr(n.rest, r));
    }
    case "record":
      return Yr(n.keyType, r) || Yr(n.valueType, r);
    case "map":
      return Yr(n.keyType, r) || Yr(n.valueType, r);
    case "set":
      return Yr(n.valueType, r);
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Yr(n.innerType, r);
    case "lazy":
      return Yr(n.getter(), r);
    case "default":
      return Yr(n.innerType, r);
    case "prefault":
      return Yr(n.innerType, r);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return Yr(n.in, r) || Yr(n.out, r);
    case "success":
      return !1;
    case "catch":
      return !1;
    case "function":
      return !1;
  }
  throw new Error(`Unknown schema type: ${n.type}`);
}
const bT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), _T = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, $ZodAny: W$, $ZodArray: Y$, $ZodAsyncError: Xi, $ZodBase64: C$, $ZodBase64URL: D$, $ZodBigInt: Od, $ZodBigIntFormat: B$, $ZodBoolean: wd, $ZodCIDRv4: T$, $ZodCIDRv6: N$, $ZodCUID: w$, $ZodCUID2: O$, $ZodCatch: gS, $ZodCheck: Cr, $ZodCheckBigIntFormat: YO, $ZodCheckEndsWith: c$, $ZodCheckGreaterThan: vd, $ZodCheckIncludes: s$, $ZodCheckLengthEquals: n$, $ZodCheckLessThan: gd, $ZodCheckLowerCase: o$, $ZodCheckMaxLength: t$, $ZodCheckMaxSize: XO, $ZodCheckMimeType: f$, $ZodCheckMinLength: r$, $ZodCheckMinSize: QO, $ZodCheckMultipleOf: HO, $ZodCheckNumberFormat: JO, $ZodCheckOverwrite: h$, $ZodCheckProperty: l$, $ZodCheckRegex: i$, $ZodCheckSizeEquals: e$, $ZodCheckStartsWith: u$, $ZodCheckStringFormat: Ga, $ZodCheckUpperCase: a$, $ZodCodec: Ed, $ZodCustom: ES, $ZodCustomStringFormat: F$, $ZodDate: J$, $ZodDefault: pS, $ZodDiscriminatedUnion: rS, $ZodE164: z$, $ZodEmail: g$, $ZodEmoji: b$, $ZodEncodeError: _u, $ZodEnum: sS, $ZodError: nd, $ZodFile: cS, $ZodFunction: OS, $ZodGUID: m$, $ZodIPv4: P$, $ZodIPv6: I$, $ZodISODate: A$, $ZodISODateTime: x$, $ZodISODuration: k$, $ZodISOTime: j$, $ZodIntersection: nS, $ZodJWT: M$, $ZodKSUID: E$, $ZodLazy: SS, $ZodLiteral: uS, $ZodMap: oS, $ZodNaN: vS, $ZodNanoID: _$, $ZodNever: K$, $ZodNonOptional: mS, $ZodNull: V$, $ZodNullable: hS, $ZodNumber: _d, $ZodNumberFormat: L$, $ZodObject: eS, $ZodObjectJIT: tS, $ZodOptional: fS, $ZodPipe: bS, $ZodPrefault: dS, $ZodPromise: $S, $ZodReadonly: _S, $ZodRealError: Tn, $ZodRecord: iS, $ZodRegistry: xd, $ZodSet: aS, $ZodString: Ka, $ZodStringFormat: dr, $ZodSuccess: yS, $ZodSymbol: q$, $ZodTemplateLiteral: wS, $ZodTransform: lS, $ZodTuple: Sd, $ZodType: Ct, $ZodULID: $$, $ZodURL: v$, $ZodUUID: y$, $ZodUndefined: Z$, $ZodUnion: $d, $ZodUnknown: G$, $ZodVoid: H$, $ZodXID: S$, $brand: W1, $constructor: Re, $input: IS, $output: PS, Doc: p$, JSONSchema: bT, JSONSchemaGenerator: ep, NEVER: V1, TimePrecision: CS, _any: tE, _array: pE, _base64: Zd, _base64url: Vd, _bigint: KS, _boolean: WS, _catch: pT, _check: vE, _cidrv4: Bd, _cidrv6: qd, _coercedBigint: HS, _coercedBoolean: GS, _coercedDate: aE, _coercedNumber: FS, _coercedString: NS, _cuid: Rd, _cuid2: Dd, _custom: mE, _date: oE, _decode: sd, _decodeAsync: cd, _default: lT, _discriminatedUnion: XI, _e164: Wd, _email: jd, _emoji: Nd, _encode: ad, _encodeAsync: ud, _endsWith: em, _enum: iT, _file: dE, _float32: BS, _float64: qS, _gt: no, _gte: kn, _guid: Ks, _includes: Xd, _int: LS, _int32: ZS, _int64: JS, _intersection: QI, _ipv4: Fd, _ipv6: Ld, _isoDate: DS, _isoDateTime: RS, _isoDuration: US, _isoTime: zS, _jwt: Gd, _ksuid: Md, _lazy: gT, _length: ju, _literal: aT, _lowercase: Jd, _lt: ro, _lte: Wn, _map: rT, _max: Wn, _maxLength: Au, _maxSize: xu, _mime: tm, _min: kn, _minLength: Ro, _minSize: Ia, _multipleOf: Pa, _nan: sE, _nanoid: Cd, _nativeEnum: oT, _negative: cE, _never: nE, _nonnegative: fE, _nonoptional: fT, _nonpositive: lE, _normalize: rm, _null: eE, _nullable: cT, _number: MS, _optional: uT, _overwrite: po, _parse: La, _parseAsync: Ba, _pipe: dT, _positive: uE, _promise: vT, _property: hE, _readonly: mT, _record: tT, _refine: yE, _regex: Hd, _safeDecode: fd, _safeDecodeAsync: pd, _safeEncode: ld, _safeEncodeAsync: hd, _safeParse: qa, _safeParseAsync: Za, _set: nT, _size: Kd, _startsWith: Qd, _string: TS, _stringFormat: Ha, _stringbool: bE, _success: hT, _superRefine: gE, _symbol: XS, _templateLiteral: yT, _toLowerCase: im, _toUpperCase: om, _transform: sT, _trim: nm, _tuple: eT, _uint32: VS, _uint64: YS, _ulid: zd, _undefined: QS, _union: YI, _unknown: rE, _uppercase: Yd, _url: Eu, _uuid: kd, _uuidv4: Pd, _uuidv6: Id, _uuidv7: Td, _void: iE, _xid: Ud, clone: Un, config: pn, decode: Tk, decodeAsync: Ck, encode: Ik, encodeAsync: Nk, flattenError: id, formatError: od, globalConfig: Zs, globalRegistry: Hi, isValidBase64: bd, isValidBase64URL: R$, isValidJWT: U$, locales: kS, parse: Yh, parseAsync: Xh, prettifyError: hO, regexes: yd, registry: Ad, safeDecode: Dk, safeDecodeAsync: Uk, safeEncode: Rk, safeEncodeAsync: zk, safeParse: pO, safeParseAsync: dO, toDotPath: fO, toJSONSchema: _E, treeifyError: lO, util: uO, version: d$ }, Symbol.toStringTag, { value: "Module" })), am = /* @__PURE__ */ Re("ZodISODateTime", (e, t) => {
  x$.init(e, t), _r.init(e, t);
});
function wE(e) {
  return RS(am, e);
}
const sm = /* @__PURE__ */ Re("ZodISODate", (e, t) => {
  A$.init(e, t), _r.init(e, t);
});
function OE(e) {
  return DS(sm, e);
}
const um = /* @__PURE__ */ Re("ZodISOTime", (e, t) => {
  j$.init(e, t), _r.init(e, t);
});
function $E(e) {
  return zS(um, e);
}
const cm = /* @__PURE__ */ Re("ZodISODuration", (e, t) => {
  k$.init(e, t), _r.init(e, t);
});
function SE(e) {
  return US(cm, e);
}
const wT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, ZodISODate: sm, ZodISODateTime: am, ZodISODuration: cm, ZodISOTime: um, date: OE, datetime: wE, duration: SE, time: $E }, Symbol.toStringTag, { value: "Module" })), EE = (e, t) => {
  nd.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (r) => od(e, r)
      // enumerable: false,
    },
    flatten: {
      value: (r) => id(e, r)
      // enumerable: false,
    },
    addIssue: {
      value: (r) => {
        e.issues.push(r), e.message = JSON.stringify(e.issues, Vs, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (r) => {
        e.issues.push(...r), e.message = JSON.stringify(e.issues, Vs, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, OT = Re("ZodError", EE), Nn = Re("ZodError", EE, {
  Parent: Error
}), xE = /* @__PURE__ */ La(Nn), AE = /* @__PURE__ */ Ba(Nn), jE = /* @__PURE__ */ qa(Nn), kE = /* @__PURE__ */ Za(Nn), PE = /* @__PURE__ */ ad(Nn), IE = /* @__PURE__ */ sd(Nn), TE = /* @__PURE__ */ ud(Nn), NE = /* @__PURE__ */ cd(Nn), CE = /* @__PURE__ */ ld(Nn), RE = /* @__PURE__ */ fd(Nn), DE = /* @__PURE__ */ hd(Nn), zE = /* @__PURE__ */ pd(Nn), Mt = /* @__PURE__ */ Re("ZodType", (e, t) => (Ct.init(e, t), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...r) => e.clone(_i(t, {
  checks: [
    ...t.checks ?? [],
    ...r.map((i) => typeof i == "function" ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } } : i)
  ]
})), e.clone = (r, i) => Un(e, r, i), e.brand = () => e, e.register = ((r, i) => (r.add(e, i), e)), e.parse = (r, i) => xE(e, r, i, { callee: e.parse }), e.safeParse = (r, i) => jE(e, r, i), e.parseAsync = async (r, i) => AE(e, r, i, { callee: e.parseAsync }), e.safeParseAsync = async (r, i) => kE(e, r, i), e.spa = e.safeParseAsync, e.encode = (r, i) => PE(e, r, i), e.decode = (r, i) => IE(e, r, i), e.encodeAsync = async (r, i) => TE(e, r, i), e.decodeAsync = async (r, i) => NE(e, r, i), e.safeEncode = (r, i) => CE(e, r, i), e.safeDecode = (r, i) => RE(e, r, i), e.safeEncodeAsync = async (r, i) => DE(e, r, i), e.safeDecodeAsync = async (r, i) => zE(e, r, i), e.refine = (r, i) => e.check($x(r, i)), e.superRefine = (r) => e.check(Sx(r)), e.overwrite = (r) => e.check(po(r)), e.optional = () => Js(e), e.nullable = () => Ys(e), e.nullish = () => Js(Ys(e)), e.nonoptional = (r) => fx(e, r), e.array = () => Cu(e), e.or = (r) => Im([e, r]), e.and = (r) => YE(e, r), e.transform = (r) => Xs(e, Cm(r)), e.default = (r) => ux(e, r), e.prefault = (r) => lx(e, r), e.catch = (r) => dx(e, r), e.pipe = (r) => Xs(e, r), e.readonly = () => gx(e), e.describe = (r) => {
  const i = e.clone();
  return Hi.add(i, { description: r }), i;
}, Object.defineProperty(e, "description", {
  get() {
    return Hi.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...r) => {
  if (r.length === 0)
    return Hi.get(e);
  const i = e.clone();
  return Hi.add(i, r[0]), i;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), lm = /* @__PURE__ */ Re("_ZodString", (e, t) => {
  Ka.init(e, t), Mt.init(e, t);
  const r = e._zod.bag;
  e.format = r.format ?? null, e.minLength = r.minimum ?? null, e.maxLength = r.maximum ?? null, e.regex = (...i) => e.check(Hd(...i)), e.includes = (...i) => e.check(Xd(...i)), e.startsWith = (...i) => e.check(Qd(...i)), e.endsWith = (...i) => e.check(em(...i)), e.min = (...i) => e.check(Ro(...i)), e.max = (...i) => e.check(Au(...i)), e.length = (...i) => e.check(ju(...i)), e.nonempty = (...i) => e.check(Ro(1, ...i)), e.lowercase = (i) => e.check(Jd(i)), e.uppercase = (i) => e.check(Yd(i)), e.trim = () => e.check(nm()), e.normalize = (...i) => e.check(rm(...i)), e.toLowerCase = () => e.check(im()), e.toUpperCase = () => e.check(om());
}), ku = /* @__PURE__ */ Re("ZodString", (e, t) => {
  Ka.init(e, t), lm.init(e, t), e.email = (r) => e.check(jd(fm, r)), e.url = (r) => e.check(Eu(Pu, r)), e.jwt = (r) => e.check(Gd(xm, r)), e.emoji = (r) => e.check(Nd(hm, r)), e.guid = (r) => e.check(Ks(Hs, r)), e.uuid = (r) => e.check(kd(gi, r)), e.uuidv4 = (r) => e.check(Pd(gi, r)), e.uuidv6 = (r) => e.check(Id(gi, r)), e.uuidv7 = (r) => e.check(Td(gi, r)), e.nanoid = (r) => e.check(Cd(pm, r)), e.guid = (r) => e.check(Ks(Hs, r)), e.cuid = (r) => e.check(Rd(dm, r)), e.cuid2 = (r) => e.check(Dd(mm, r)), e.ulid = (r) => e.check(zd(ym, r)), e.base64 = (r) => e.check(Zd($m, r)), e.base64url = (r) => e.check(Vd(Sm, r)), e.xid = (r) => e.check(Ud(gm, r)), e.ksuid = (r) => e.check(Md(vm, r)), e.ipv4 = (r) => e.check(Fd(bm, r)), e.ipv6 = (r) => e.check(Ld(_m, r)), e.cidrv4 = (r) => e.check(Bd(wm, r)), e.cidrv6 = (r) => e.check(qd(Om, r)), e.e164 = (r) => e.check(Wd(Em, r)), e.datetime = (r) => e.check(wE(r)), e.date = (r) => e.check(OE(r)), e.time = (r) => e.check($E(r)), e.duration = (r) => e.check(SE(r));
});
function tp(e) {
  return TS(ku, e);
}
const _r = /* @__PURE__ */ Re("ZodStringFormat", (e, t) => {
  dr.init(e, t), lm.init(e, t);
}), fm = /* @__PURE__ */ Re("ZodEmail", (e, t) => {
  g$.init(e, t), _r.init(e, t);
});
function $T(e) {
  return jd(fm, e);
}
const Hs = /* @__PURE__ */ Re("ZodGUID", (e, t) => {
  m$.init(e, t), _r.init(e, t);
});
function ST(e) {
  return Ks(Hs, e);
}
const gi = /* @__PURE__ */ Re("ZodUUID", (e, t) => {
  y$.init(e, t), _r.init(e, t);
});
function ET(e) {
  return kd(gi, e);
}
function xT(e) {
  return Pd(gi, e);
}
function AT(e) {
  return Id(gi, e);
}
function jT(e) {
  return Td(gi, e);
}
const Pu = /* @__PURE__ */ Re("ZodURL", (e, t) => {
  v$.init(e, t), _r.init(e, t);
});
function kT(e) {
  return Eu(Pu, e);
}
function PT(e) {
  return Eu(Pu, {
    protocol: /^https?$/,
    hostname: IO,
    ...Je(e)
  });
}
const hm = /* @__PURE__ */ Re("ZodEmoji", (e, t) => {
  b$.init(e, t), _r.init(e, t);
});
function IT(e) {
  return Nd(hm, e);
}
const pm = /* @__PURE__ */ Re("ZodNanoID", (e, t) => {
  _$.init(e, t), _r.init(e, t);
});
function TT(e) {
  return Cd(pm, e);
}
const dm = /* @__PURE__ */ Re("ZodCUID", (e, t) => {
  w$.init(e, t), _r.init(e, t);
});
function NT(e) {
  return Rd(dm, e);
}
const mm = /* @__PURE__ */ Re("ZodCUID2", (e, t) => {
  O$.init(e, t), _r.init(e, t);
});
function CT(e) {
  return Dd(mm, e);
}
const ym = /* @__PURE__ */ Re("ZodULID", (e, t) => {
  $$.init(e, t), _r.init(e, t);
});
function RT(e) {
  return zd(ym, e);
}
const gm = /* @__PURE__ */ Re("ZodXID", (e, t) => {
  S$.init(e, t), _r.init(e, t);
});
function DT(e) {
  return Ud(gm, e);
}
const vm = /* @__PURE__ */ Re("ZodKSUID", (e, t) => {
  E$.init(e, t), _r.init(e, t);
});
function zT(e) {
  return Md(vm, e);
}
const bm = /* @__PURE__ */ Re("ZodIPv4", (e, t) => {
  P$.init(e, t), _r.init(e, t);
});
function UT(e) {
  return Fd(bm, e);
}
const _m = /* @__PURE__ */ Re("ZodIPv6", (e, t) => {
  I$.init(e, t), _r.init(e, t);
});
function MT(e) {
  return Ld(_m, e);
}
const wm = /* @__PURE__ */ Re("ZodCIDRv4", (e, t) => {
  T$.init(e, t), _r.init(e, t);
});
function FT(e) {
  return Bd(wm, e);
}
const Om = /* @__PURE__ */ Re("ZodCIDRv6", (e, t) => {
  N$.init(e, t), _r.init(e, t);
});
function LT(e) {
  return qd(Om, e);
}
const $m = /* @__PURE__ */ Re("ZodBase64", (e, t) => {
  C$.init(e, t), _r.init(e, t);
});
function BT(e) {
  return Zd($m, e);
}
const Sm = /* @__PURE__ */ Re("ZodBase64URL", (e, t) => {
  D$.init(e, t), _r.init(e, t);
});
function qT(e) {
  return Vd(Sm, e);
}
const Em = /* @__PURE__ */ Re("ZodE164", (e, t) => {
  z$.init(e, t), _r.init(e, t);
});
function ZT(e) {
  return Wd(Em, e);
}
const xm = /* @__PURE__ */ Re("ZodJWT", (e, t) => {
  M$.init(e, t), _r.init(e, t);
});
function VT(e) {
  return Gd(xm, e);
}
const Ja = /* @__PURE__ */ Re("ZodCustomStringFormat", (e, t) => {
  F$.init(e, t), _r.init(e, t);
});
function WT(e, t, r = {}) {
  return Ha(Ja, e, t, r);
}
function GT(e) {
  return Ha(Ja, "hostname", md, e);
}
function KT(e) {
  return Ha(Ja, "hex", GO, e);
}
function HT(e, t) {
  const r = t?.enc ?? "hex", i = `${e}_${r}`, n = yd[i];
  if (!n)
    throw new Error(`Unrecognized hash format: ${i}`);
  return Ha(Ja, i, n, t);
}
const Iu = /* @__PURE__ */ Re("ZodNumber", (e, t) => {
  _d.init(e, t), Mt.init(e, t), e.gt = (i, n) => e.check(no(i, n)), e.gte = (i, n) => e.check(kn(i, n)), e.min = (i, n) => e.check(kn(i, n)), e.lt = (i, n) => e.check(ro(i, n)), e.lte = (i, n) => e.check(Wn(i, n)), e.max = (i, n) => e.check(Wn(i, n)), e.int = (i) => e.check(rp(i)), e.safe = (i) => e.check(rp(i)), e.positive = (i) => e.check(no(0, i)), e.nonnegative = (i) => e.check(kn(0, i)), e.negative = (i) => e.check(ro(0, i)), e.nonpositive = (i) => e.check(Wn(0, i)), e.multipleOf = (i, n) => e.check(Pa(i, n)), e.step = (i, n) => e.check(Pa(i, n)), e.finite = () => e;
  const r = e._zod.bag;
  e.minValue = Math.max(r.minimum ?? Number.NEGATIVE_INFINITY, r.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(r.maximum ?? Number.POSITIVE_INFINITY, r.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (r.format ?? "").includes("int") || Number.isSafeInteger(r.multipleOf ?? 0.5), e.isFinite = !0, e.format = r.format ?? null;
});
function UE(e) {
  return MS(Iu, e);
}
const Vo = /* @__PURE__ */ Re("ZodNumberFormat", (e, t) => {
  L$.init(e, t), Iu.init(e, t);
});
function rp(e) {
  return LS(Vo, e);
}
function JT(e) {
  return BS(Vo, e);
}
function YT(e) {
  return qS(Vo, e);
}
function XT(e) {
  return ZS(Vo, e);
}
function QT(e) {
  return VS(Vo, e);
}
const Tu = /* @__PURE__ */ Re("ZodBoolean", (e, t) => {
  wd.init(e, t), Mt.init(e, t);
});
function ME(e) {
  return WS(Tu, e);
}
const Nu = /* @__PURE__ */ Re("ZodBigInt", (e, t) => {
  Od.init(e, t), Mt.init(e, t), e.gte = (i, n) => e.check(kn(i, n)), e.min = (i, n) => e.check(kn(i, n)), e.gt = (i, n) => e.check(no(i, n)), e.gte = (i, n) => e.check(kn(i, n)), e.min = (i, n) => e.check(kn(i, n)), e.lt = (i, n) => e.check(ro(i, n)), e.lte = (i, n) => e.check(Wn(i, n)), e.max = (i, n) => e.check(Wn(i, n)), e.positive = (i) => e.check(no(BigInt(0), i)), e.negative = (i) => e.check(ro(BigInt(0), i)), e.nonpositive = (i) => e.check(Wn(BigInt(0), i)), e.nonnegative = (i) => e.check(kn(BigInt(0), i)), e.multipleOf = (i, n) => e.check(Pa(i, n));
  const r = e._zod.bag;
  e.minValue = r.minimum ?? null, e.maxValue = r.maximum ?? null, e.format = r.format ?? null;
});
function e6(e) {
  return KS(Nu, e);
}
const Am = /* @__PURE__ */ Re("ZodBigIntFormat", (e, t) => {
  B$.init(e, t), Nu.init(e, t);
});
function t6(e) {
  return JS(Am, e);
}
function r6(e) {
  return YS(Am, e);
}
const FE = /* @__PURE__ */ Re("ZodSymbol", (e, t) => {
  q$.init(e, t), Mt.init(e, t);
});
function n6(e) {
  return XS(FE, e);
}
const LE = /* @__PURE__ */ Re("ZodUndefined", (e, t) => {
  Z$.init(e, t), Mt.init(e, t);
});
function i6(e) {
  return QS(LE, e);
}
const BE = /* @__PURE__ */ Re("ZodNull", (e, t) => {
  V$.init(e, t), Mt.init(e, t);
});
function qE(e) {
  return eE(BE, e);
}
const ZE = /* @__PURE__ */ Re("ZodAny", (e, t) => {
  W$.init(e, t), Mt.init(e, t);
});
function o6() {
  return tE(ZE);
}
const VE = /* @__PURE__ */ Re("ZodUnknown", (e, t) => {
  G$.init(e, t), Mt.init(e, t);
});
function Do() {
  return rE(VE);
}
const WE = /* @__PURE__ */ Re("ZodNever", (e, t) => {
  K$.init(e, t), Mt.init(e, t);
});
function jm(e) {
  return nE(WE, e);
}
const GE = /* @__PURE__ */ Re("ZodVoid", (e, t) => {
  H$.init(e, t), Mt.init(e, t);
});
function a6(e) {
  return iE(GE, e);
}
const km = /* @__PURE__ */ Re("ZodDate", (e, t) => {
  J$.init(e, t), Mt.init(e, t), e.min = (i, n) => e.check(kn(i, n)), e.max = (i, n) => e.check(Wn(i, n));
  const r = e._zod.bag;
  e.minDate = r.minimum ? new Date(r.minimum) : null, e.maxDate = r.maximum ? new Date(r.maximum) : null;
});
function s6(e) {
  return oE(km, e);
}
const KE = /* @__PURE__ */ Re("ZodArray", (e, t) => {
  Y$.init(e, t), Mt.init(e, t), e.element = t.element, e.min = (r, i) => e.check(Ro(r, i)), e.nonempty = (r) => e.check(Ro(1, r)), e.max = (r, i) => e.check(Au(r, i)), e.length = (r, i) => e.check(ju(r, i)), e.unwrap = () => e.element;
});
function Cu(e, t) {
  return pE(KE, e, t);
}
function u6(e) {
  const t = e._zod.def.shape;
  return Nm(Object.keys(t));
}
const Ru = /* @__PURE__ */ Re("ZodObject", (e, t) => {
  tS.init(e, t), Mt.init(e, t), Wt(e, "shape", () => t.shape), e.keyof = () => Nm(Object.keys(e._zod.def.shape)), e.catchall = (r) => e.clone({ ...e._zod.def, catchall: r }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Do() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Do() }), e.strict = () => e.clone({ ...e._zod.def, catchall: jm() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (r) => tO(e, r), e.safeExtend = (r) => rO(e, r), e.merge = (r) => nO(e, r), e.pick = (r) => Q1(e, r), e.omit = (r) => eO(e, r), e.partial = (...r) => iO(Rm, e, r[0]), e.required = (...r) => oO(Dm, e, r[0]);
});
function c6(e, t) {
  const r = {
    type: "object",
    shape: e ?? {},
    ...Je(t)
  };
  return new Ru(r);
}
function l6(e, t) {
  return new Ru({
    type: "object",
    shape: e,
    catchall: jm(),
    ...Je(t)
  });
}
function f6(e, t) {
  return new Ru({
    type: "object",
    shape: e,
    catchall: Do(),
    ...Je(t)
  });
}
const Pm = /* @__PURE__ */ Re("ZodUnion", (e, t) => {
  $d.init(e, t), Mt.init(e, t), e.options = t.options;
});
function Im(e, t) {
  return new Pm({
    type: "union",
    options: e,
    ...Je(t)
  });
}
const HE = /* @__PURE__ */ Re("ZodDiscriminatedUnion", (e, t) => {
  Pm.init(e, t), rS.init(e, t);
});
function h6(e, t, r) {
  return new HE({
    type: "union",
    options: t,
    discriminator: e,
    ...Je(r)
  });
}
const JE = /* @__PURE__ */ Re("ZodIntersection", (e, t) => {
  nS.init(e, t), Mt.init(e, t);
});
function YE(e, t) {
  return new JE({
    type: "intersection",
    left: e,
    right: t
  });
}
const XE = /* @__PURE__ */ Re("ZodTuple", (e, t) => {
  Sd.init(e, t), Mt.init(e, t), e.rest = (r) => e.clone({
    ...e._zod.def,
    rest: r
  });
});
function QE(e, t, r) {
  const i = t instanceof Ct, n = i ? r : t, o = i ? t : null;
  return new XE({
    type: "tuple",
    items: e,
    rest: o,
    ...Je(n)
  });
}
const Tm = /* @__PURE__ */ Re("ZodRecord", (e, t) => {
  iS.init(e, t), Mt.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function ex(e, t, r) {
  return new Tm({
    type: "record",
    keyType: e,
    valueType: t,
    ...Je(r)
  });
}
function p6(e, t, r) {
  const i = Un(e);
  return i._zod.values = void 0, new Tm({
    type: "record",
    keyType: i,
    valueType: t,
    ...Je(r)
  });
}
const tx = /* @__PURE__ */ Re("ZodMap", (e, t) => {
  oS.init(e, t), Mt.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function d6(e, t, r) {
  return new tx({
    type: "map",
    keyType: e,
    valueType: t,
    ...Je(r)
  });
}
const rx = /* @__PURE__ */ Re("ZodSet", (e, t) => {
  aS.init(e, t), Mt.init(e, t), e.min = (...r) => e.check(Ia(...r)), e.nonempty = (r) => e.check(Ia(1, r)), e.max = (...r) => e.check(xu(...r)), e.size = (...r) => e.check(Kd(...r));
});
function m6(e, t) {
  return new rx({
    type: "set",
    valueType: e,
    ...Je(t)
  });
}
const Ta = /* @__PURE__ */ Re("ZodEnum", (e, t) => {
  sS.init(e, t), Mt.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const r = new Set(Object.keys(t.entries));
  e.extract = (i, n) => {
    const o = {};
    for (const s of i)
      if (r.has(s))
        o[s] = t.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new Ta({
      ...t,
      checks: [],
      ...Je(n),
      entries: o
    });
  }, e.exclude = (i, n) => {
    const o = { ...t.entries };
    for (const s of i)
      if (r.has(s))
        delete o[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new Ta({
      ...t,
      checks: [],
      ...Je(n),
      entries: o
    });
  };
});
function Nm(e, t) {
  const r = Array.isArray(e) ? Object.fromEntries(e.map((i) => [i, i])) : e;
  return new Ta({
    type: "enum",
    entries: r,
    ...Je(t)
  });
}
function y6(e, t) {
  return new Ta({
    type: "enum",
    entries: e,
    ...Je(t)
  });
}
const nx = /* @__PURE__ */ Re("ZodLiteral", (e, t) => {
  uS.init(e, t), Mt.init(e, t), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function g6(e, t) {
  return new nx({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...Je(t)
  });
}
const ix = /* @__PURE__ */ Re("ZodFile", (e, t) => {
  cS.init(e, t), Mt.init(e, t), e.min = (r, i) => e.check(Ia(r, i)), e.max = (r, i) => e.check(xu(r, i)), e.mime = (r, i) => e.check(tm(Array.isArray(r) ? r : [r], i));
});
function v6(e) {
  return dE(ix, e);
}
const ox = /* @__PURE__ */ Re("ZodTransform", (e, t) => {
  lS.init(e, t), Mt.init(e, t), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      throw new _u(e.constructor.name);
    r.addIssue = (o) => {
      if (typeof o == "string")
        r.issues.push(No(o, r.value, t));
      else {
        const s = o;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = r.value), s.inst ?? (s.inst = e), r.issues.push(No(s));
      }
    };
    const n = t.transform(r.value, r);
    return n instanceof Promise ? n.then((o) => (r.value = o, r)) : (r.value = n, r);
  };
});
function Cm(e) {
  return new ox({
    type: "transform",
    transform: e
  });
}
const Rm = /* @__PURE__ */ Re("ZodOptional", (e, t) => {
  fS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Js(e) {
  return new Rm({
    type: "optional",
    innerType: e
  });
}
const ax = /* @__PURE__ */ Re("ZodNullable", (e, t) => {
  hS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Ys(e) {
  return new ax({
    type: "nullable",
    innerType: e
  });
}
function b6(e) {
  return Js(Ys(e));
}
const sx = /* @__PURE__ */ Re("ZodDefault", (e, t) => {
  pS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function ux(e, t) {
  return new sx({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Ou(t);
    }
  });
}
const cx = /* @__PURE__ */ Re("ZodPrefault", (e, t) => {
  dS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function lx(e, t) {
  return new cx({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Ou(t);
    }
  });
}
const Dm = /* @__PURE__ */ Re("ZodNonOptional", (e, t) => {
  mS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function fx(e, t) {
  return new Dm({
    type: "nonoptional",
    innerType: e,
    ...Je(t)
  });
}
const hx = /* @__PURE__ */ Re("ZodSuccess", (e, t) => {
  yS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function _6(e) {
  return new hx({
    type: "success",
    innerType: e
  });
}
const px = /* @__PURE__ */ Re("ZodCatch", (e, t) => {
  gS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function dx(e, t) {
  return new px({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const mx = /* @__PURE__ */ Re("ZodNaN", (e, t) => {
  vS.init(e, t), Mt.init(e, t);
});
function w6(e) {
  return sE(mx, e);
}
const zm = /* @__PURE__ */ Re("ZodPipe", (e, t) => {
  bS.init(e, t), Mt.init(e, t), e.in = t.in, e.out = t.out;
});
function Xs(e, t) {
  return new zm({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const Um = /* @__PURE__ */ Re("ZodCodec", (e, t) => {
  zm.init(e, t), Ed.init(e, t);
});
function O6(e, t, r) {
  return new Um({
    type: "pipe",
    in: e,
    out: t,
    transform: r.decode,
    reverseTransform: r.encode
  });
}
const yx = /* @__PURE__ */ Re("ZodReadonly", (e, t) => {
  _S.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function gx(e) {
  return new yx({
    type: "readonly",
    innerType: e
  });
}
const vx = /* @__PURE__ */ Re("ZodTemplateLiteral", (e, t) => {
  wS.init(e, t), Mt.init(e, t);
});
function $6(e, t) {
  return new vx({
    type: "template_literal",
    parts: e,
    ...Je(t)
  });
}
const bx = /* @__PURE__ */ Re("ZodLazy", (e, t) => {
  SS.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.getter();
});
function _x(e) {
  return new bx({
    type: "lazy",
    getter: e
  });
}
const wx = /* @__PURE__ */ Re("ZodPromise", (e, t) => {
  $S.init(e, t), Mt.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function S6(e) {
  return new wx({
    type: "promise",
    innerType: e
  });
}
const Ox = /* @__PURE__ */ Re("ZodFunction", (e, t) => {
  OS.init(e, t), Mt.init(e, t);
});
function Yg(e) {
  return new Ox({
    type: "function",
    input: Array.isArray(e?.input) ? QE(e?.input) : e?.input ?? Cu(Do()),
    output: e?.output ?? Do()
  });
}
const Du = /* @__PURE__ */ Re("ZodCustom", (e, t) => {
  ES.init(e, t), Mt.init(e, t);
});
function E6(e) {
  const t = new Cr({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return t._zod.check = e, t;
}
function x6(e, t) {
  return mE(Du, e ?? (() => !0), t);
}
function $x(e, t = {}) {
  return yE(Du, e, t);
}
function Sx(e) {
  return gE(e);
}
function A6(e, t = {
  error: `Input not instance of ${e.name}`
}) {
  const r = new Du({
    type: "custom",
    check: "custom",
    fn: (i) => i instanceof e,
    abort: !0,
    ...Je(t)
  });
  return r._zod.bag.Class = e, r;
}
const j6 = (...e) => bE({
  Codec: Um,
  Boolean: Tu,
  String: ku
}, ...e);
function k6(e) {
  const t = _x(() => Im([tp(e), UE(), ME(), qE(), Cu(t), ex(tp(), t)]));
  return t;
}
function P6(e, t) {
  return Xs(Cm(e), t);
}
const I6 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function T6(e) {
  pn({
    customError: e
  });
}
function N6() {
  return pn().customError;
}
var np;
np || (np = {});
function C6(e) {
  return NS(ku, e);
}
function R6(e) {
  return FS(Iu, e);
}
function D6(e) {
  return GS(Tu, e);
}
function z6(e) {
  return HS(Nu, e);
}
function U6(e) {
  return aE(km, e);
}
const M6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, bigint: z6, boolean: D6, date: U6, number: R6, string: C6 }, Symbol.toStringTag, { value: "Module" }));
pn(xS());
const X7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, $brand: W1, $input: IS, $output: PS, NEVER: V1, TimePrecision: CS, ZodAny: ZE, ZodArray: KE, ZodBase64: $m, ZodBase64URL: Sm, ZodBigInt: Nu, ZodBigIntFormat: Am, ZodBoolean: Tu, ZodCIDRv4: wm, ZodCIDRv6: Om, ZodCUID: dm, ZodCUID2: mm, ZodCatch: px, ZodCodec: Um, ZodCustom: Du, ZodCustomStringFormat: Ja, ZodDate: km, ZodDefault: sx, ZodDiscriminatedUnion: HE, ZodE164: Em, ZodEmail: fm, ZodEmoji: hm, ZodEnum: Ta, ZodError: OT, ZodFile: ix, get ZodFirstPartyTypeKind() {
  return np;
}, ZodFunction: Ox, ZodGUID: Hs, ZodIPv4: bm, ZodIPv6: _m, ZodISODate: sm, ZodISODateTime: am, ZodISODuration: cm, ZodISOTime: um, ZodIntersection: JE, ZodIssueCode: I6, ZodJWT: xm, ZodKSUID: vm, ZodLazy: bx, ZodLiteral: nx, ZodMap: tx, ZodNaN: mx, ZodNanoID: pm, ZodNever: WE, ZodNonOptional: Dm, ZodNull: BE, ZodNullable: ax, ZodNumber: Iu, ZodNumberFormat: Vo, ZodObject: Ru, ZodOptional: Rm, ZodPipe: zm, ZodPrefault: cx, ZodPromise: wx, ZodReadonly: yx, ZodRealError: Nn, ZodRecord: Tm, ZodSet: rx, ZodString: ku, ZodStringFormat: _r, ZodSuccess: hx, ZodSymbol: FE, ZodTemplateLiteral: vx, ZodTransform: ox, ZodTuple: XE, ZodType: Mt, ZodULID: ym, ZodURL: Pu, ZodUUID: gi, ZodUndefined: LE, ZodUnion: Pm, ZodUnknown: VE, ZodVoid: GE, ZodXID: gm, _ZodString: lm, _default: ux, _function: Yg, any: o6, array: Cu, base64: BT, base64url: qT, bigint: e6, boolean: ME, catch: dx, check: E6, cidrv4: FT, cidrv6: LT, clone: Un, codec: O6, coerce: M6, config: pn, core: _T, cuid: NT, cuid2: CT, custom: x6, date: s6, decode: IE, decodeAsync: NE, discriminatedUnion: h6, e164: ZT, email: $T, emoji: IT, encode: PE, encodeAsync: TE, endsWith: em, enum: Nm, file: v6, flattenError: id, float32: JT, float64: YT, formatError: od, function: Yg, getErrorMap: N6, globalRegistry: Hi, gt: no, gte: kn, guid: ST, hash: HT, hex: KT, hostname: GT, httpUrl: PT, includes: Xd, instanceof: A6, int: rp, int32: XT, int64: t6, intersection: YE, ipv4: UT, ipv6: MT, iso: wT, json: k6, jwt: VT, keyof: u6, ksuid: zT, lazy: _x, length: ju, literal: g6, locales: kS, looseObject: f6, lowercase: Jd, lt: ro, lte: Wn, map: d6, maxLength: Au, maxSize: xu, mime: tm, minLength: Ro, minSize: Ia, multipleOf: Pa, nan: w6, nanoid: TT, nativeEnum: y6, negative: cE, never: jm, nonnegative: fE, nonoptional: fx, nonpositive: lE, normalize: rm, null: qE, nullable: Ys, nullish: b6, number: UE, object: c6, optional: Js, overwrite: po, parse: xE, parseAsync: AE, partialRecord: p6, pipe: Xs, positive: uE, prefault: lx, preprocess: P6, prettifyError: hO, promise: S6, property: hE, readonly: gx, record: ex, refine: $x, regex: Hd, regexes: yd, registry: Ad, safeDecode: RE, safeDecodeAsync: zE, safeEncode: CE, safeEncodeAsync: DE, safeParse: jE, safeParseAsync: kE, set: m6, setErrorMap: T6, size: Kd, startsWith: Qd, strictObject: l6, string: tp, stringFormat: WT, stringbool: j6, success: _6, superRefine: Sx, symbol: n6, templateLiteral: $6, toJSONSchema: _E, toLowerCase: im, toUpperCase: om, transform: Cm, treeifyError: lO, trim: nm, tuple: QE, uint32: QT, uint64: r6, ulid: RT, undefined: i6, union: Im, unknown: Do, uppercase: Yd, url: kT, util: uO, uuid: ET, uuidv4: xT, uuidv6: AT, uuidv7: jT, void: a6, xid: DT }, Symbol.toStringTag, { value: "Module" }));
var F6 = typeof global == "object" && global && global.Object === Object && global, L6 = typeof self == "object" && self && self.Object === Object && self, Mm = F6 || L6 || Function("return this")(), zo = Mm.Symbol, Ex = Object.prototype, B6 = Ex.hasOwnProperty, q6 = Ex.toString, sa = zo ? zo.toStringTag : void 0;
function Z6(e) {
  var t = B6.call(e, sa), r = e[sa];
  try {
    e[sa] = void 0;
    var i = !0;
  } catch {
  }
  var n = q6.call(e);
  return i && (t ? e[sa] = r : delete e[sa]), n;
}
var V6 = Object.prototype, W6 = V6.toString;
function G6(e) {
  return W6.call(e);
}
var K6 = "[object Null]", H6 = "[object Undefined]", Xg = zo ? zo.toStringTag : void 0;
function Fm(e) {
  return e == null ? e === void 0 ? H6 : K6 : Xg && Xg in Object(e) ? Z6(e) : G6(e);
}
function Lm(e) {
  return e != null && typeof e == "object";
}
var J6 = "[object Symbol]";
function Bm(e) {
  return typeof e == "symbol" || Lm(e) && Fm(e) == J6;
}
function Y6(e, t) {
  for (var r = -1, i = e == null ? 0 : e.length, n = Array(i); ++r < i; )
    n[r] = t(e[r], r, e);
  return n;
}
var zu = Array.isArray, Qg = zo ? zo.prototype : void 0, ev = Qg ? Qg.toString : void 0;
function xx(e) {
  if (typeof e == "string")
    return e;
  if (zu(e))
    return Y6(e, xx) + "";
  if (Bm(e))
    return ev ? ev.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function Qs(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var X6 = "[object AsyncFunction]", Q6 = "[object Function]", eN = "[object GeneratorFunction]", tN = "[object Proxy]";
function rN(e) {
  if (!Qs(e))
    return !1;
  var t = Fm(e);
  return t == Q6 || t == eN || t == X6 || t == tN;
}
var Pc = Mm["__core-js_shared__"], tv = (function() {
  var e = /[^.]+$/.exec(Pc && Pc.keys && Pc.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function nN(e) {
  return !!tv && tv in e;
}
var iN = Function.prototype, oN = iN.toString;
function aN(e) {
  if (e != null) {
    try {
      return oN.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var sN = /[\\^$.*+?()[\]{}|]/g, uN = /^\[object .+?Constructor\]$/, cN = Function.prototype, lN = Object.prototype, fN = cN.toString, hN = lN.hasOwnProperty, pN = RegExp(
  "^" + fN.call(hN).replace(sN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function dN(e) {
  if (!Qs(e) || nN(e))
    return !1;
  var t = rN(e) ? pN : uN;
  return t.test(aN(e));
}
function mN(e, t) {
  return e?.[t];
}
function qm(e, t) {
  var r = mN(e, t);
  return dN(r) ? r : void 0;
}
var rv = (function() {
  try {
    var e = qm(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
})(), yN = 9007199254740991, gN = /^(?:0|[1-9]\d*)$/;
function Ax(e, t) {
  var r = typeof e;
  return t = t ?? yN, !!t && (r == "number" || r != "symbol" && gN.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function vN(e, t, r) {
  t == "__proto__" && rv ? rv(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
function jx(e, t) {
  return e === t || e !== e && t !== t;
}
var bN = Object.prototype, _N = bN.hasOwnProperty;
function wN(e, t, r) {
  var i = e[t];
  (!(_N.call(e, t) && jx(i, r)) || r === void 0 && !(t in e)) && vN(e, t, r);
}
var ON = 9007199254740991;
function $N(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= ON;
}
var SN = "[object Arguments]";
function nv(e) {
  return Lm(e) && Fm(e) == SN;
}
var kx = Object.prototype, EN = kx.hasOwnProperty, xN = kx.propertyIsEnumerable, AN = nv(/* @__PURE__ */ (function() {
  return arguments;
})()) ? nv : function(e) {
  return Lm(e) && EN.call(e, "callee") && !xN.call(e, "callee");
}, jN = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, kN = /^\w*$/;
function PN(e, t) {
  if (zu(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || Bm(e) ? !0 : kN.test(e) || !jN.test(e) || t != null && e in Object(t);
}
var Na = qm(Object, "create");
function IN() {
  this.__data__ = Na ? Na(null) : {}, this.size = 0;
}
function TN(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var NN = "__lodash_hash_undefined__", CN = Object.prototype, RN = CN.hasOwnProperty;
function DN(e) {
  var t = this.__data__;
  if (Na) {
    var r = t[e];
    return r === NN ? void 0 : r;
  }
  return RN.call(t, e) ? t[e] : void 0;
}
var zN = Object.prototype, UN = zN.hasOwnProperty;
function MN(e) {
  var t = this.__data__;
  return Na ? t[e] !== void 0 : UN.call(t, e);
}
var FN = "__lodash_hash_undefined__";
function LN(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = Na && t === void 0 ? FN : t, this;
}
function io(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
io.prototype.clear = IN;
io.prototype.delete = TN;
io.prototype.get = DN;
io.prototype.has = MN;
io.prototype.set = LN;
function BN() {
  this.__data__ = [], this.size = 0;
}
function Uu(e, t) {
  for (var r = e.length; r--; )
    if (jx(e[r][0], t))
      return r;
  return -1;
}
var qN = Array.prototype, ZN = qN.splice;
function VN(e) {
  var t = this.__data__, r = Uu(t, e);
  if (r < 0)
    return !1;
  var i = t.length - 1;
  return r == i ? t.pop() : ZN.call(t, r, 1), --this.size, !0;
}
function WN(e) {
  var t = this.__data__, r = Uu(t, e);
  return r < 0 ? void 0 : t[r][1];
}
function GN(e) {
  return Uu(this.__data__, e) > -1;
}
function KN(e, t) {
  var r = this.__data__, i = Uu(r, e);
  return i < 0 ? (++this.size, r.push([e, t])) : r[i][1] = t, this;
}
function Wo(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Wo.prototype.clear = BN;
Wo.prototype.delete = VN;
Wo.prototype.get = WN;
Wo.prototype.has = GN;
Wo.prototype.set = KN;
var HN = qm(Mm, "Map");
function JN() {
  this.size = 0, this.__data__ = {
    hash: new io(),
    map: new (HN || Wo)(),
    string: new io()
  };
}
function YN(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Mu(e, t) {
  var r = e.__data__;
  return YN(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function XN(e) {
  var t = Mu(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function QN(e) {
  return Mu(this, e).get(e);
}
function e4(e) {
  return Mu(this, e).has(e);
}
function t4(e, t) {
  var r = Mu(this, e), i = r.size;
  return r.set(e, t), this.size += r.size == i ? 0 : 1, this;
}
function mo(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
mo.prototype.clear = JN;
mo.prototype.delete = XN;
mo.prototype.get = QN;
mo.prototype.has = e4;
mo.prototype.set = t4;
var r4 = "Expected a function";
function Zm(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(r4);
  var r = function() {
    var i = arguments, n = t ? t.apply(this, i) : i[0], o = r.cache;
    if (o.has(n))
      return o.get(n);
    var s = e.apply(this, i);
    return r.cache = o.set(n, s) || o, s;
  };
  return r.cache = new (Zm.Cache || mo)(), r;
}
Zm.Cache = mo;
var n4 = 500;
function i4(e) {
  var t = Zm(e, function(i) {
    return r.size === n4 && r.clear(), i;
  }), r = t.cache;
  return t;
}
var o4 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, a4 = /\\(\\)?/g, s4 = i4(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(o4, function(r, i, n, o) {
    t.push(n ? o.replace(a4, "$1") : i || r);
  }), t;
});
function u4(e) {
  return e == null ? "" : xx(e);
}
function Vm(e, t) {
  return zu(e) ? e : PN(e, t) ? [e] : s4(u4(e));
}
function Wm(e) {
  if (typeof e == "string" || Bm(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function c4(e, t) {
  t = Vm(t, e);
  for (var r = 0, i = t.length; e != null && r < i; )
    e = e[Wm(t[r++])];
  return r && r == i ? e : void 0;
}
function Q7(e, t, r) {
  var i = e == null ? void 0 : c4(e, t);
  return i === void 0 ? r : i;
}
function l4(e, t, r) {
  t = Vm(t, e);
  for (var i = -1, n = t.length, o = !1; ++i < n; ) {
    var s = Wm(t[i]);
    if (!(o = e != null && r(e, s)))
      break;
    e = e[s];
  }
  return o || ++i != n ? o : (n = e == null ? 0 : e.length, !!n && $N(n) && Ax(s, n) && (zu(e) || AN(e)));
}
var f4 = Object.prototype, h4 = f4.hasOwnProperty;
function p4(e, t) {
  return e != null && h4.call(e, t);
}
function eq(e, t) {
  return e != null && l4(e, t, p4);
}
function d4(e, t, r, i) {
  if (!Qs(e))
    return e;
  t = Vm(t, e);
  for (var n = -1, o = t.length, s = o - 1, a = e; a != null && ++n < o; ) {
    var u = Wm(t[n]), c = r;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return e;
    if (n != s) {
      var f = a[u];
      c = void 0, c === void 0 && (c = Qs(f) ? f : Ax(t[n + 1]) ? [] : {});
    }
    wN(a, u, c), a = a[u];
  }
  return e;
}
function tq(e, t, r) {
  return e == null ? e : d4(e, t, r);
}
typeof BigInt > "u" && (BigInt = function(e) {
  if (isNaN(e)) throw new Error("");
  return e;
});
const yt = BigInt(0), Ut = BigInt(1), en = BigInt(2), Sa = BigInt(3), Eo = BigInt(5), _n = BigInt(10);
BigInt(Number.MAX_SAFE_INTEGER);
const m4 = 2e3, ct = {
  s: Ut,
  n: yt,
  d: Ut
};
function pi(e, t) {
  try {
    e = BigInt(e);
  } catch {
    throw ki();
  }
  return e * t;
}
function Fn(e) {
  return typeof e == "bigint" ? e : Math.floor(e);
}
function Sr(e, t) {
  if (t === yt)
    throw Km();
  const r = Object.create(Gm.prototype);
  r.s = e < yt ? -Ut : Ut, e = e < yt ? -e : e;
  const i = Gi(e, t);
  return r.n = e / i, r.d = t / i, r;
}
const y4 = [en * en, en, en * en, en, en * en, en * Sa, en, en * Sa];
function $o(e) {
  const t = /* @__PURE__ */ Object.create(null);
  if (e <= Ut)
    return t[e] = Ut, t;
  const r = (i) => {
    t[i] = (t[i] || yt) + Ut;
  };
  for (; e % en === yt; )
    r(en), e /= en;
  for (; e % Sa === yt; )
    r(Sa), e /= Sa;
  for (; e % Eo === yt; )
    r(Eo), e /= Eo;
  for (let i = 0, n = en + Eo; n * n <= e; ) {
    for (; e % n === yt; )
      r(n), e /= n;
    n += y4[i], i = i + 1 & 7;
  }
  return e > Ut && r(e), t;
}
const Qr = function(e, t) {
  let r = yt, i = Ut, n = Ut;
  if (e != null) if (t !== void 0) {
    if (typeof e == "bigint")
      r = e;
    else {
      if (isNaN(e))
        throw ki();
      if (e % 1 !== 0)
        throw iv();
      r = BigInt(e);
    }
    if (typeof t == "bigint")
      i = t;
    else {
      if (isNaN(t))
        throw ki();
      if (t % 1 !== 0)
        throw iv();
      i = BigInt(t);
    }
    n = r * i;
  } else if (typeof e == "object") {
    if ("d" in e && "n" in e)
      r = BigInt(e.n), i = BigInt(e.d), "s" in e && (r *= BigInt(e.s));
    else if (0 in e)
      r = BigInt(e[0]), 1 in e && (i = BigInt(e[1]));
    else if (typeof e == "bigint")
      r = e;
    else
      throw ki();
    n = r * i;
  } else if (typeof e == "number") {
    if (isNaN(e))
      throw ki();
    if (e < 0 && (n = -Ut, e = -e), e % 1 === 0)
      r = BigInt(e);
    else {
      let o = 1, s = 0, a = 1, u = 1, c = 1, f = 1e7;
      for (e >= 1 && (o = 10 ** Math.floor(1 + Math.log10(e)), e /= o); a <= f && c <= f; ) {
        let h = (s + u) / (a + c);
        if (e === h) {
          a + c <= f ? (r = s + u, i = a + c) : c > a ? (r = u, i = c) : (r = s, i = a);
          break;
        } else
          e > h ? (s += u, a += c) : (u += s, c += a), a > f ? (r = u, i = c) : (r = s, i = a);
      }
      r = BigInt(r) * BigInt(o), i = BigInt(i);
    }
  } else if (typeof e == "string") {
    let o = 0, s = yt, a = yt, u = yt, c = Ut, f = Ut, h = e.replace(/_/g, "").match(/\d+|./g);
    if (h === null)
      throw ki();
    if (h[o] === "-" ? (n = -Ut, o++) : h[o] === "+" && o++, h.length === o + 1 ? a = pi(h[o++], n) : h[o + 1] === "." || h[o] === "." ? (h[o] !== "." && (s = pi(h[o++], n)), o++, (o + 1 === h.length || h[o + 1] === "(" && h[o + 3] === ")" || h[o + 1] === "'" && h[o + 3] === "'") && (a = pi(h[o], n), c = _n ** BigInt(h[o].length), o++), (h[o] === "(" && h[o + 2] === ")" || h[o] === "'" && h[o + 2] === "'") && (u = pi(h[o + 1], n), f = _n ** BigInt(h[o + 1].length) - Ut, o += 3)) : h[o + 1] === "/" || h[o + 1] === ":" ? (a = pi(h[o], n), c = pi(h[o + 2], Ut), o += 3) : h[o + 3] === "/" && h[o + 1] === " " && (s = pi(h[o], n), a = pi(h[o + 2], n), c = pi(h[o + 4], Ut), o += 5), h.length <= o)
      i = c * f, n = /* void */
      r = u + i * s + f * a;
    else
      throw ki();
  } else if (typeof e == "bigint")
    r = e, n = e, i = Ut;
  else
    throw ki();
  if (i === yt)
    throw Km();
  ct.s = n < yt ? -Ut : Ut, ct.n = r < yt ? -r : r, ct.d = i < yt ? -i : i;
};
function g4(e, t, r) {
  let i = Ut;
  for (; t > yt; e = e * e % r, t >>= Ut)
    t & Ut && (i = i * e % r);
  return i;
}
function v4(e, t) {
  for (; t % en === yt; t /= en)
    ;
  for (; t % Eo === yt; t /= Eo)
    ;
  if (t === Ut)
    return yt;
  let r = _n % t, i = 1;
  for (; r !== Ut; i++)
    if (r = r * _n % t, i > m4)
      return yt;
  return BigInt(i);
}
function b4(e, t, r) {
  let i = Ut, n = g4(_n, r, t);
  for (let o = 0; o < 300; o++) {
    if (i === n)
      return BigInt(o);
    i = i * _n % t, n = n * _n % t;
  }
  return 0;
}
function Gi(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  for (; ; ) {
    if (e %= t, !e)
      return t;
    if (t %= e, !t)
      return e;
  }
}
function Gm(e, t) {
  if (Qr(e, t), this instanceof Gm)
    e = Gi(ct.d, ct.n), this.s = ct.s, this.n = ct.n / e, this.d = ct.d / e;
  else
    return Sr(ct.s * ct.n, ct.d);
}
const Km = function() {
  return new Error("Division by Zero");
}, ki = function() {
  return new Error("Invalid argument");
}, iv = function() {
  return new Error("Parameters must be integer");
};
Gm.prototype = {
  s: Ut,
  n: yt,
  d: Ut,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return Sr(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return Sr(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(e, t) {
    return Qr(e, t), Sr(
      this.s * this.n * ct.d + ct.s * this.d * ct.n,
      this.d * ct.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(e, t) {
    return Qr(e, t), Sr(
      this.s * this.n * ct.d - ct.s * this.d * ct.n,
      this.d * ct.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(e, t) {
    return Qr(e, t), Sr(
      this.s * ct.s * this.n * ct.n,
      this.d * ct.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(e, t) {
    return Qr(e, t), Sr(
      this.s * ct.s * this.n * ct.d,
      this.d * ct.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return Sr(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   * Ex: new Fraction(20, 10).mod().equals(0) ? "is Integer"
   **/
  mod: function(e, t) {
    if (e === void 0)
      return Sr(this.s * this.n % this.d, Ut);
    if (Qr(e, t), yt === ct.n * this.d)
      throw Km();
    return Sr(
      this.s * (ct.d * this.n) % (ct.n * this.d),
      ct.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(e, t) {
    return Qr(e, t), Sr(Gi(ct.n, this.n) * Gi(ct.d, this.d), ct.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(e, t) {
    return Qr(e, t), ct.n === yt && this.n === yt ? Sr(yt, Ut) : Sr(ct.n * this.n, Gi(ct.n, this.n) * Gi(ct.d, this.d));
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return Sr(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some integer exponent
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(e, t) {
    if (Qr(e, t), ct.d === Ut)
      return ct.s < yt ? Sr((this.s * this.d) ** ct.n, this.n ** ct.n) : Sr((this.s * this.n) ** ct.n, this.d ** ct.n);
    if (this.s < yt) return null;
    let r = $o(this.n), i = $o(this.d), n = Ut, o = Ut;
    for (let s in r)
      if (s !== "1") {
        if (s === "0") {
          n = yt;
          break;
        }
        if (r[s] *= ct.n, r[s] % ct.d === yt)
          r[s] /= ct.d;
        else return null;
        n *= BigInt(s) ** r[s];
      }
    for (let s in i)
      if (s !== "1") {
        if (i[s] *= ct.n, i[s] % ct.d === yt)
          i[s] /= ct.d;
        else return null;
        o *= BigInt(s) ** i[s];
      }
    return ct.s < yt ? Sr(o, n) : Sr(n, o);
  },
  /**
   * Calculates the logarithm of a fraction to a given rational base
   *
   * Ex: new Fraction(27, 8).log(9, 4) => 3/2
   */
  log: function(e, t) {
    if (Qr(e, t), this.s <= yt || ct.s <= yt) return null;
    const r = /* @__PURE__ */ Object.create(null), i = $o(ct.n), n = $o(ct.d), o = $o(this.n), s = $o(this.d);
    for (const c in n)
      i[c] = (i[c] || yt) - n[c];
    for (const c in s)
      o[c] = (o[c] || yt) - s[c];
    for (const c in i)
      c !== "1" && (r[c] = !0);
    for (const c in o)
      c !== "1" && (r[c] = !0);
    let a = null, u = null;
    for (const c in r) {
      const f = i[c] || yt, h = o[c] || yt;
      if (f === yt) {
        if (h !== yt)
          return null;
        continue;
      }
      let y = h, p = f;
      const l = Gi(y, p);
      if (y /= l, p /= l, a === null && u === null)
        a = y, u = p;
      else if (y * u !== a * p)
        return null;
    }
    return a !== null && u !== null ? Sr(a, u) : null;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(e, t) {
    return Qr(e, t), this.s * this.n * ct.d === ct.s * ct.n * this.d;
  },
  /**
   * Check if this rational number is less than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  lt: function(e, t) {
    return Qr(e, t), this.s * this.n * ct.d < ct.s * ct.n * this.d;
  },
  /**
   * Check if this rational number is less than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  lte: function(e, t) {
    return Qr(e, t), this.s * this.n * ct.d <= ct.s * ct.n * this.d;
  },
  /**
   * Check if this rational number is greater than another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  gt: function(e, t) {
    return Qr(e, t), this.s * this.n * ct.d > ct.s * ct.n * this.d;
  },
  /**
   * Check if this rational number is greater than or equal another
   *
   * Ex: new Fraction(19.6).lt([98, 5]);
   **/
  gte: function(e, t) {
    return Qr(e, t), this.s * this.n * ct.d >= ct.s * ct.n * this.d;
  },
  /**
   * Compare two rational numbers
   * < 0 iff this < that
   * > 0 iff this > that
   * = 0 iff this = that
   *
   * Ex: new Fraction(19.6).compare([98, 5]);
   **/
  compare: function(e, t) {
    Qr(e, t);
    let r = this.s * this.n * ct.d - ct.s * ct.n * this.d;
    return (yt < r) - (r < yt);
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(e) {
    return e = _n ** BigInt(e || 0), Sr(
      Fn(this.s * e * this.n / this.d) + (e * this.n % this.d > yt && this.s >= yt ? Ut : yt),
      e
    );
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(e) {
    return e = _n ** BigInt(e || 0), Sr(
      Fn(this.s * e * this.n / this.d) - (e * this.n % this.d > yt && this.s < yt ? Ut : yt),
      e
    );
  },
  /**
   * Rounds a rational numbers
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(e) {
    return e = _n ** BigInt(e || 0), Sr(
      Fn(this.s * e * this.n / this.d) + this.s * ((this.s >= yt ? Ut : yt) + en * (e * this.n % this.d) > this.d ? Ut : yt),
      e
    );
  },
  /**
    * Rounds a rational number to a multiple of another rational number
    *
    * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
    **/
  roundTo: function(e, t) {
    Qr(e, t);
    const r = this.n * ct.d, i = this.d * ct.n, n = r % i;
    let o = Fn(r / i);
    return n + n >= i && o++, Sr(this.s * o * ct.n, ct.d);
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(e, t) {
    return Qr(e, t), ct.n === yt ? !1 : this.n * ct.d % (ct.n * this.d) === yt;
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return Number(this.s * this.n) / Number(this.d);
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(e = 15) {
    let t = this.n, r = this.d, i = v4(t, r), n = b4(t, r, i), o = this.s < yt ? "-" : "";
    if (o += Fn(t / r), t %= r, t *= _n, t && (o += "."), i) {
      for (let s = n; s--; )
        o += Fn(t / r), t %= r, t *= _n;
      o += "(";
      for (let s = i; s--; )
        o += Fn(t / r), t %= r, t *= _n;
      o += ")";
    } else
      for (let s = e; t && s--; )
        o += Fn(t / r), t %= r, t *= _n;
    return o;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction() => "4 1/3"
   **/
  toFraction: function(e = !1) {
    let t = this.n, r = this.d, i = this.s < yt ? "-" : "";
    if (r === Ut)
      i += t;
    else {
      const n = Fn(t / r);
      e && n > yt && (i += n, i += " ", t %= r), i += t, i += "/", i += r;
    }
    return i;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(e = !1) {
    let t = this.n, r = this.d, i = this.s < yt ? "-" : "";
    if (r === Ut)
      i += t;
    else {
      const n = Fn(t / r);
      e && n > yt && (i += n, t %= r), i += "\\frac{", i += t, i += "}{", i += r, i += "}";
    }
    return i;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    let e = this.n, t = this.d;
    const r = [];
    for (; t; ) {
      r.push(Fn(e / t));
      const i = e % t;
      e = t, t = i;
    }
    return r;
  },
  simplify: function(e = 1e-3) {
    const t = BigInt(Math.ceil(1 / e)), r = this.abs(), i = r.toContinued();
    for (let n = 1; n < i.length; n++) {
      let o = Sr(i[n - 1], Ut);
      for (let a = n - 2; a >= 0; a--)
        o = o.inverse().add(i[a]);
      let s = o.sub(r);
      if (s.n * t < s.d)
        return o.mul(this.s);
    }
    return this;
  }
};
var Px = Object.defineProperty, ze = (e, t) => Px(e, "name", { value: t, configurable: !0 }), Hm = (e, t) => {
  for (var r in t)
    Px(e, r, { get: t[r], enumerable: !0 });
}, eu = {};
Hm(eu, {
  addChainableMethod: () => sy,
  addLengthGuard: () => Qa,
  addMethod: () => iy,
  addProperty: () => ny,
  checkError: () => jn,
  compareByInspect: () => iu,
  eql: () => iA,
  expectTypes: () => Ux,
  flag: () => Dt,
  getActual: () => Lu,
  getMessage: () => Xm,
  getName: () => qu,
  getOperator: () => fy,
  getOwnEnumerableProperties: () => ly,
  getOwnEnumerablePropertySymbols: () => cy,
  getPathInfo: () => ry,
  hasProperty: () => Bu,
  inspect: () => er,
  isNaN: () => ou,
  isNumeric: () => tn,
  isProxyEnabled: () => Xa,
  isRegExp: () => au,
  objDisplay: () => Qi,
  overwriteChainableMethod: () => uy,
  overwriteMethod: () => ay,
  overwriteProperty: () => oy,
  proxify: () => Go,
  test: () => Jm,
  transferFlags: () => Kn,
  type: () => lr
});
var jn = {};
Hm(jn, {
  compatibleConstructor: () => Nx,
  compatibleInstance: () => Tx,
  compatibleMessage: () => Cx,
  getConstructorName: () => Rx,
  getMessage: () => Dx
});
function Fu(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
ze(Fu, "isErrorInstance");
function Ix(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
ze(Ix, "isRegExp");
function Tx(e, t) {
  return Fu(t) && e === t;
}
ze(Tx, "compatibleInstance");
function Nx(e, t) {
  return Fu(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : !1;
}
ze(Nx, "compatibleConstructor");
function Cx(e, t) {
  const r = typeof e == "string" ? e : e.message;
  return Ix(t) ? t.test(r) : typeof t == "string" ? r.indexOf(t) !== -1 : !1;
}
ze(Cx, "compatibleMessage");
function Rx(e) {
  let t = e;
  return Fu(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
ze(Rx, "getConstructorName");
function Dx(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
ze(Dx, "getMessage");
function Dt(e, t, r) {
  let i = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    i[t] = r;
  else
    return i[t];
}
ze(Dt, "flag");
function Jm(e, t) {
  let r = Dt(e, "negate"), i = t[0];
  return r ? !i : i;
}
ze(Jm, "test");
function lr(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
ze(lr, "type");
var _4 = "captureStackTrace" in Error, tr = class zx extends Error {
  static {
    ze(this, "AssertionError");
  }
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(t = "Unspecified AssertionError", r, i) {
    super(t), this.message = t, _4 && Error.captureStackTrace(this, i || zx);
    for (const n in r)
      n in this || (this[n] = r[n]);
  }
  toJSON(t) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: t !== !1 ? this.stack : void 0
    };
  }
};
function Ux(e, t) {
  let r = Dt(e, "message"), i = Dt(e, "ssfi");
  r = r ? r + ": " : "", e = Dt(e, "object"), t = t.map(function(s) {
    return s.toLowerCase();
  }), t.sort();
  let n = t.map(function(s, a) {
    let u = ~["a", "e", "i", "o", "u"].indexOf(s.charAt(0)) ? "an" : "a";
    return (t.length > 1 && a === t.length - 1 ? "or " : "") + u + " " + s;
  }).join(", "), o = lr(e).toLowerCase();
  if (!t.some(function(s) {
    return o === s;
  }))
    throw new tr(
      r + "object tested must be " + n + ", but " + o + " given",
      void 0,
      i
    );
}
ze(Ux, "expectTypes");
function Lu(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
ze(Lu, "getActual");
var ov = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, w4 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, Uo = "…";
function Mx(e, t) {
  const r = ov[w4[t]] || ov[t] || "";
  return r ? `\x1B[${r[0]}m${String(e)}\x1B[${r[1]}m` : String(e);
}
ze(Mx, "colorise");
function Fx({
  showHidden: e = !1,
  depth: t = 2,
  colors: r = !1,
  customInspect: i = !0,
  showProxy: n = !1,
  maxArrayLength: o = 1 / 0,
  breakLength: s = 1 / 0,
  seen: a = [],
  // eslint-disable-next-line no-shadow
  truncate: u = 1 / 0,
  stylize: c = String
} = {}, f) {
  const h = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!r,
    customInspect: !!i,
    showProxy: !!n,
    maxArrayLength: Number(o),
    breakLength: Number(s),
    truncate: Number(u),
    seen: a,
    inspect: f,
    stylize: c
  };
  return h.colors && (h.stylize = Mx), h;
}
ze(Fx, "normaliseOptions");
function Lx(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
ze(Lx, "isHighSurrogate");
function wi(e, t, r = Uo) {
  e = String(e);
  const i = r.length, n = e.length;
  if (i > t && n > i)
    return r;
  if (n > t && n > i) {
    let o = t - i;
    return o > 0 && Lx(e[o - 1]) && (o = o - 1), `${e.slice(0, o)}${r}`;
  }
  return e;
}
ze(wi, "truncate");
function Dn(e, t, r, i = ", ") {
  r = r || t.inspect;
  const n = e.length;
  if (n === 0)
    return "";
  const o = t.truncate;
  let s = "", a = "", u = "";
  for (let c = 0; c < n; c += 1) {
    const f = c + 1 === e.length, h = c + 2 === e.length;
    u = `${Uo}(${e.length - c})`;
    const y = e[c];
    t.truncate = o - s.length - (f ? 0 : i.length);
    const p = a || r(y, t) + (f ? "" : i), l = s.length + p.length, d = l + u.length;
    if (f && l > o && s.length + u.length <= o || !f && !h && d > o || (a = f ? "" : r(e[c + 1], t) + (h ? "" : i), !f && h && d > o && l + a.length > o))
      break;
    if (s += p, !f && !h && l + a.length >= o) {
      u = `${Uo}(${e.length - c - 1})`;
      break;
    }
    u = "";
  }
  return `${s}${u}`;
}
ze(Dn, "inspectList");
function Bx(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
ze(Bx, "quoteComplexKey");
function Mo([e, t], r) {
  return r.truncate -= 2, typeof e == "string" ? e = Bx(e) : typeof e != "number" && (e = `[${r.inspect(e, r)}]`), r.truncate -= e.length, t = r.inspect(t, r), `${e}: ${t}`;
}
ze(Mo, "inspectProperty");
function qx(e, t) {
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return "[]";
  t.truncate -= 4;
  const i = Dn(e, t);
  t.truncate -= i.length;
  let n = "";
  return r.length && (n = Dn(r.map((o) => [o, e[o]]), t, Mo)), `[ ${i}${n ? `, ${n}` : ""} ]`;
}
ze(qx, "inspectArray");
var O4 = /* @__PURE__ */ ze((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function ni(e, t) {
  const r = O4(e);
  t.truncate -= r.length + 4;
  const i = Object.keys(e).slice(e.length);
  if (!e.length && !i.length)
    return `${r}[]`;
  let n = "";
  for (let s = 0; s < e.length; s++) {
    const a = `${t.stylize(wi(e[s], t.truncate), "number")}${s === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= a.length, e[s] !== e.length && t.truncate <= 3) {
      n += `${Uo}(${e.length - e[s] + 1})`;
      break;
    }
    n += a;
  }
  let o = "";
  return i.length && (o = Dn(i.map((s) => [s, e[s]]), t, Mo)), `${r}[ ${n}${o ? `, ${o}` : ""} ]`;
}
ze(ni, "inspectTypedArray");
function Zx(e, t) {
  const r = e.toJSON();
  if (r === null)
    return "Invalid Date";
  const i = r.split("T"), n = i[0];
  return t.stylize(`${n}T${wi(i[1], t.truncate - n.length - 1)}`, "date");
}
ze(Zx, "inspectDate");
function ip(e, t) {
  const r = e[Symbol.toStringTag] || "Function", i = e.name;
  return i ? t.stylize(`[${r} ${wi(i, t.truncate - 11)}]`, "special") : t.stylize(`[${r}]`, "special");
}
ze(ip, "inspectFunction");
function Vx([e, t], r) {
  return r.truncate -= 4, e = r.inspect(e, r), r.truncate -= e.length, t = r.inspect(t, r), `${e} => ${t}`;
}
ze(Vx, "inspectMapEntry");
function Wx(e) {
  const t = [];
  return e.forEach((r, i) => {
    t.push([i, r]);
  }), t;
}
ze(Wx, "mapToEntries");
function Gx(e, t) {
  return e.size === 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Dn(Wx(e), t, Vx)} }`);
}
ze(Gx, "inspectMap");
var $4 = Number.isNaN || ((e) => e !== e);
function op(e, t) {
  return $4(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(wi(String(e), t.truncate), "number");
}
ze(op, "inspectNumber");
function ap(e, t) {
  let r = wi(e.toString(), t.truncate - 1);
  return r !== Uo && (r += "n"), t.stylize(r, "bigint");
}
ze(ap, "inspectBigInt");
function Kx(e, t) {
  const r = e.toString().split("/")[2], i = t.truncate - (2 + r.length), n = e.source;
  return t.stylize(`/${wi(n, i)}/${r}`, "regexp");
}
ze(Kx, "inspectRegExp");
function Hx(e) {
  const t = [];
  return e.forEach((r) => {
    t.push(r);
  }), t;
}
ze(Hx, "arrayFromSet");
function Jx(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Dn(Hx(e), t)} }`);
}
ze(Jx, "inspectSet");
var av = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), S4 = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, E4 = 16;
function Yx(e) {
  return S4[e] || `\\u${`0000${e.charCodeAt(0).toString(E4)}`.slice(-4)}`;
}
ze(Yx, "escape");
function sp(e, t) {
  return av.test(e) && (e = e.replace(av, Yx)), t.stylize(`'${wi(e, t.truncate - 2)}'`, "string");
}
ze(sp, "inspectString");
function up(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
ze(up, "inspectSymbol");
var x4 = /* @__PURE__ */ ze(() => "Promise{…}", "getPromiseValue"), A4 = x4;
function Ea(e, t) {
  const r = Object.getOwnPropertyNames(e), i = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (r.length === 0 && i.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const n = Dn(r.map((a) => [a, e[a]]), t, Mo), o = Dn(i.map((a) => [a, e[a]]), t, Mo);
  t.seen.pop();
  let s = "";
  return n && o && (s = ", "), `{ ${n}${s}${o} }`;
}
ze(Ea, "inspectObject");
var Ic = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function Xx(e, t) {
  let r = "";
  return Ic && Ic in e && (r = e[Ic]), r = r || e.constructor.name, (!r || r === "_class") && (r = "<Anonymous Class>"), t.truncate -= r.length, `${r}${Ea(e, t)}`;
}
ze(Xx, "inspectClass");
function Qx(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Dn(e, t)} ]`);
}
ze(Qx, "inspectArguments");
var j4 = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function eA(e, t) {
  const r = Object.getOwnPropertyNames(e).filter((s) => j4.indexOf(s) === -1), i = e.name;
  t.truncate -= i.length;
  let n = "";
  if (typeof e.message == "string" ? n = wi(e.message, t.truncate) : r.unshift("message"), n = n ? `: ${n}` : "", t.truncate -= n.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const o = Dn(r.map((s) => [s, e[s]]), t, Mo);
  return `${i}${n}${o ? ` { ${o} }` : ""}`;
}
ze(eA, "inspectObject");
function tA([e, t], r) {
  return r.truncate -= 3, t ? `${r.stylize(String(e), "yellow")}=${r.stylize(`"${t}"`, "string")}` : `${r.stylize(String(e), "yellow")}`;
}
ze(tA, "inspectAttribute");
function tu(e, t) {
  return Dn(e, t, rA, `
`);
}
ze(tu, "inspectNodeCollection");
function rA(e, t) {
  switch (e.nodeType) {
    case 1:
      return Ym(e, t);
    case 3:
      return t.inspect(e.data, t);
    default:
      return t.inspect(e, t);
  }
}
ze(rA, "inspectNode");
function Ym(e, t) {
  const r = e.getAttributeNames(), i = e.tagName.toLowerCase(), n = t.stylize(`<${i}`, "special"), o = t.stylize(">", "special"), s = t.stylize(`</${i}>`, "special");
  t.truncate -= i.length * 2 + 5;
  let a = "";
  r.length > 0 && (a += " ", a += Dn(r.map((f) => [f, e.getAttribute(f)]), t, tA, " ")), t.truncate -= a.length;
  const u = t.truncate;
  let c = tu(e.children, t);
  return c && c.length > u && (c = `${Uo}(${e.children.length})`), `${n}${a}${o}${c}${s}`;
}
ze(Ym, "inspectHTML");
var k4 = typeof Symbol == "function" && typeof Symbol.for == "function", Tc = k4 ? Symbol.for("chai/inspect") : "@@chai/inspect", Nc = Symbol.for("nodejs.util.inspect.custom"), sv = /* @__PURE__ */ new WeakMap(), uv = {}, cv = {
  undefined: /* @__PURE__ */ ze((e, t) => t.stylize("undefined", "undefined"), "undefined"),
  null: /* @__PURE__ */ ze((e, t) => t.stylize("null", "null"), "null"),
  boolean: /* @__PURE__ */ ze((e, t) => t.stylize(String(e), "boolean"), "boolean"),
  Boolean: /* @__PURE__ */ ze((e, t) => t.stylize(String(e), "boolean"), "Boolean"),
  number: op,
  Number: op,
  bigint: ap,
  BigInt: ap,
  string: sp,
  String: sp,
  function: ip,
  Function: ip,
  symbol: up,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: up,
  Array: qx,
  Date: Zx,
  Map: Gx,
  Set: Jx,
  RegExp: Kx,
  Promise: A4,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: /* @__PURE__ */ ze((e, t) => t.stylize("WeakSet{…}", "special"), "WeakSet"),
  WeakMap: /* @__PURE__ */ ze((e, t) => t.stylize("WeakMap{…}", "special"), "WeakMap"),
  Arguments: Qx,
  Int8Array: ni,
  Uint8Array: ni,
  Uint8ClampedArray: ni,
  Int16Array: ni,
  Uint16Array: ni,
  Int32Array: ni,
  Uint32Array: ni,
  Float32Array: ni,
  Float64Array: ni,
  Generator: /* @__PURE__ */ ze(() => "", "Generator"),
  DataView: /* @__PURE__ */ ze(() => "", "DataView"),
  ArrayBuffer: /* @__PURE__ */ ze(() => "", "ArrayBuffer"),
  Error: eA,
  HTMLCollection: tu,
  NodeList: tu
}, P4 = /* @__PURE__ */ ze((e, t, r) => Tc in e && typeof e[Tc] == "function" ? e[Tc](t) : Nc in e && typeof e[Nc] == "function" ? e[Nc](t.depth, t) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && sv.has(e.constructor) ? sv.get(e.constructor)(e, t) : uv[r] ? uv[r](e, t) : "", "inspectCustom"), I4 = Object.prototype.toString;
function ru(e, t = {}) {
  const r = Fx(t, ru), { customInspect: i } = r;
  let n = e === null ? "null" : typeof e;
  if (n === "object" && (n = I4.call(e).slice(8, -1)), n in cv)
    return cv[n](e, r);
  if (i && e) {
    const s = P4(e, r, n);
    if (s)
      return typeof s == "string" ? s : ru(s, r);
  }
  const o = e ? Object.getPrototypeOf(e) : !1;
  return o === Object.prototype || o === null ? Ea(e, r) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? Ym(e, r) : "constructor" in e ? e.constructor !== Object ? Xx(e, r) : Ea(e, r) : e === Object(e) ? Ea(e, r) : r.stylize(String(e), n);
}
ze(ru, "inspect");
var hn = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function er(e, t, r, i) {
  let n = {
    colors: i,
    depth: typeof r > "u" ? 2 : r,
    showHidden: t,
    truncate: hn.truncateThreshold ? hn.truncateThreshold : 1 / 0
  };
  return ru(e, n);
}
ze(er, "inspect");
function Qi(e) {
  let t = er(e), r = Object.prototype.toString.call(e);
  if (hn.truncateThreshold && t.length >= hn.truncateThreshold) {
    if (r === "[object Function]")
      return !e.name || e.name === "" ? "[Function]" : "[Function: " + e.name + "]";
    if (r === "[object Array]")
      return "[ Array(" + e.length + ") ]";
    if (r === "[object Object]") {
      let i = Object.keys(e);
      return "{ Object (" + (i.length > 2 ? i.splice(0, 2).join(", ") + ", ..." : i.join(", ")) + ") }";
    } else
      return t;
  } else
    return t;
}
ze(Qi, "objDisplay");
function Xm(e, t) {
  let r = Dt(e, "negate"), i = Dt(e, "object"), n = t[3], o = Lu(e, t), s = r ? t[2] : t[1], a = Dt(e, "message");
  return typeof s == "function" && (s = s()), s = s || "", s = s.replace(/#\{this\}/g, function() {
    return Qi(i);
  }).replace(/#\{act\}/g, function() {
    return Qi(o);
  }).replace(/#\{exp\}/g, function() {
    return Qi(n);
  }), a ? a + ": " + s : s;
}
ze(Xm, "getMessage");
function Kn(e, t, r) {
  let i = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), r = arguments.length === 3 ? r : !0;
  for (let n in i)
    (r || n !== "object" && n !== "ssfi" && n !== "lockSsfi" && n != "message") && (t.__flags[n] = i[n]);
}
ze(Kn, "transferFlags");
function cp(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
ze(cp, "type");
function Qm() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
ze(Qm, "FakeMap");
Qm.prototype = {
  get: /* @__PURE__ */ ze(function(t) {
    return t[this._key];
  }, "get"),
  set: /* @__PURE__ */ ze(function(t, r) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: r,
      configurable: !0
    });
  }, "set")
};
var nA = typeof WeakMap == "function" ? WeakMap : Qm;
function lp(e, t, r) {
  if (!r || oo(e) || oo(t))
    return null;
  var i = r.get(e);
  if (i) {
    var n = i.get(t);
    if (typeof n == "boolean")
      return n;
  }
  return null;
}
ze(lp, "memoizeCompare");
function wa(e, t, r, i) {
  if (!(!r || oo(e) || oo(t))) {
    var n = r.get(e);
    n ? n.set(t, i) : (n = new nA(), n.set(t, i), r.set(e, n));
  }
}
ze(wa, "memoizeSet");
var iA = Ya;
function Ya(e, t, r) {
  if (r && r.comparator)
    return fp(e, t, r);
  var i = ey(e, t);
  return i !== null ? i : fp(e, t, r);
}
ze(Ya, "deepEqual");
function ey(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? !0 : oo(e) || oo(t) ? !1 : null;
}
ze(ey, "simpleEqual");
function fp(e, t, r) {
  r = r || {}, r.memoize = r.memoize === !1 ? !1 : r.memoize || new nA();
  var i = r && r.comparator, n = lp(e, t, r.memoize);
  if (n !== null)
    return n;
  var o = lp(t, e, r.memoize);
  if (o !== null)
    return o;
  if (i) {
    var s = i(e, t);
    if (s === !1 || s === !0)
      return wa(e, t, r.memoize, s), s;
    var a = ey(e, t);
    if (a !== null)
      return a;
  }
  var u = cp(e);
  if (u !== cp(t))
    return wa(e, t, r.memoize, !1), !1;
  wa(e, t, r.memoize, !0);
  var c = oA(e, t, u, r);
  return wa(e, t, r.memoize, c), c;
}
ze(fp, "extensiveDeepEqual");
function oA(e, t, r, i) {
  switch (r) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Ya(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return ty(e, t, ["name", "message", "code"], i);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Ti(e, t, i);
    case "RegExp":
      return aA(e, t);
    case "Generator":
      return sA(e, t, i);
    case "DataView":
      return Ti(new Uint8Array(e.buffer), new Uint8Array(t.buffer), i);
    case "ArrayBuffer":
      return Ti(new Uint8Array(e), new Uint8Array(t), i);
    case "Set":
      return hp(e, t, i);
    case "Map":
      return hp(e, t, i);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return cA(e, t, i);
  }
}
ze(oA, "extensiveDeepEqualByType");
function aA(e, t) {
  return e.toString() === t.toString();
}
ze(aA, "regexpEqual");
function hp(e, t, r) {
  try {
    if (e.size !== t.size)
      return !1;
    if (e.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var i = [], n = [];
  return e.forEach(/* @__PURE__ */ ze(function(s, a) {
    i.push([s, a]);
  }, "gatherEntries")), t.forEach(/* @__PURE__ */ ze(function(s, a) {
    n.push([s, a]);
  }, "gatherEntries")), Ti(i.sort(), n.sort(), r);
}
ze(hp, "entriesEqual");
function Ti(e, t, r) {
  var i = e.length;
  if (i !== t.length)
    return !1;
  if (i === 0)
    return !0;
  for (var n = -1; ++n < i; )
    if (Ya(e[n], t[n], r) === !1)
      return !1;
  return !0;
}
ze(Ti, "iterableEqual");
function sA(e, t, r) {
  return Ti(nu(e), nu(t), r);
}
ze(sA, "generatorEqual");
function uA(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
ze(uA, "hasIteratorFunction");
function pp(e) {
  if (uA(e))
    try {
      return nu(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
ze(pp, "getIteratorEntries");
function nu(e) {
  for (var t = e.next(), r = [t.value]; t.done === !1; )
    t = e.next(), r.push(t.value);
  return r;
}
ze(nu, "getGeneratorEntries");
function dp(e) {
  var t = [];
  for (var r in e)
    t.push(r);
  return t;
}
ze(dp, "getEnumerableKeys");
function mp(e) {
  for (var t = [], r = Object.getOwnPropertySymbols(e), i = 0; i < r.length; i += 1) {
    var n = r[i];
    Object.getOwnPropertyDescriptor(e, n).enumerable && t.push(n);
  }
  return t;
}
ze(mp, "getEnumerableSymbols");
function ty(e, t, r, i) {
  var n = r.length;
  if (n === 0)
    return !0;
  for (var o = 0; o < n; o += 1)
    if (Ya(e[r[o]], t[r[o]], i) === !1)
      return !1;
  return !0;
}
ze(ty, "keysEqual");
function cA(e, t, r) {
  var i = dp(e), n = dp(t), o = mp(e), s = mp(t);
  if (i = i.concat(o), n = n.concat(s), i.length && i.length === n.length)
    return Ti(yp(i).sort(), yp(n).sort()) === !1 ? !1 : ty(e, t, i, r);
  var a = pp(e), u = pp(t);
  return a.length && a.length === u.length ? (a.sort(), u.sort(), Ti(a, u, r)) : i.length === 0 && a.length === 0 && n.length === 0 && u.length === 0;
}
ze(cA, "objectEqual");
function oo(e) {
  return e === null || typeof e != "object";
}
ze(oo, "isPrimitive");
function yp(e) {
  return e.map(/* @__PURE__ */ ze(function(r) {
    return typeof r == "symbol" ? r.toString() : r;
  }, "mapSymbol"));
}
ze(yp, "mapSymbols");
function Bu(e, t) {
  return typeof e > "u" || e === null ? !1 : t in Object(e);
}
ze(Bu, "hasProperty");
function lA(e) {
  return e.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((i) => {
    if (i === "constructor" || i === "__proto__" || i === "prototype")
      return {};
    const o = /^\[(\d+)\]$/.exec(i);
    let s = null;
    return o ? s = { i: parseFloat(o[1]) } : s = { p: i.replace(/\\([.[\]])/g, "$1") }, s;
  });
}
ze(lA, "parsePath");
function gp(e, t, r) {
  let i = e, n = null;
  r = typeof r > "u" ? t.length : r;
  for (let o = 0; o < r; o++) {
    const s = t[o];
    i && (typeof s.p > "u" ? i = i[s.i] : i = i[s.p], o === r - 1 && (n = i));
  }
  return n;
}
ze(gp, "internalGetPathValue");
function ry(e, t) {
  const r = lA(t), i = r[r.length - 1], n = {
    parent: r.length > 1 ? gp(e, r, r.length - 1) : e,
    name: i.p || i.i,
    value: gp(e, r)
  };
  return n.exists = Bu(n.parent, n.name), n;
}
ze(ry, "getPathInfo");
var we = class fA {
  static {
    ze(this, "Assertion");
  }
  /** @type {{}} */
  __flags = {};
  /**
   * Creates object for chaining.
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   * the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   * contain `numKittens` so that the `equal` assertion can reference it when
   * needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   * prepended to the error message that's generated by the assertion when it
   * fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   * contains a function reference that serves as the starting point for
   * removing frames from the stack trace of the error that's created by the
   * assertion when it fails. The goal is to provide a cleaner stack trace to
   * end users by removing Chai's internal functions. Note that it only works
   * in environments that support `Error.captureStackTrace`, and only when
   * `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   * should retain its current value, even as assertions are chained off of
   * this object. This is usually set to `true` when creating a new assertion
   * from within another assertion. It's also temporarily set to `true` before
   * an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {unknown} obj target of the assertion
   * @param {string} [msg] (optional) custom error message
   * @param {Function} [ssfi] (optional) starting point for removing stack frames
   * @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
   */
  constructor(t, r, i, n) {
    return Dt(this, "ssfi", i || fA), Dt(this, "lockSsfi", n), Dt(this, "object", t), Dt(this, "message", r), Dt(this, "eql", hn.deepEqual || iA), Go(this);
  }
  /** @returns {boolean} */
  static get includeStack() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), hn.includeStack;
  }
  /** @param {boolean} value */
  static set includeStack(t) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), hn.includeStack = t;
  }
  /** @returns {boolean} */
  static get showDiff() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), hn.showDiff;
  }
  /** @param {boolean} value */
  static set showDiff(t) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), hn.showDiff = t;
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addProperty(t, r) {
    ny(this.prototype, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static addMethod(t, r) {
    iy(this.prototype, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static addChainableMethod(t, r, i) {
    sy(this.prototype, t, r, i);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteProperty(t, r) {
    oy(this.prototype, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   */
  static overwriteMethod(t, r) {
    ay(this.prototype, t, r);
  }
  /**
   * @param {string} name
   * @param {Function} fn
   * @param {Function} chainingBehavior
   */
  static overwriteChainableMethod(t, r, i) {
    uy(this.prototype, t, r, i);
  }
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {unknown} _expr to be tested
   * @param {string | Function} msg or function that returns message to display if expression fails
   * @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
   * @param {unknown} expected value (remember to check for negation)
   * @param {unknown} _actual (optional) will default to `this.obj`
   * @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @returns {void}
   */
  assert(t, r, i, n, o, s) {
    const a = Jm(this, arguments);
    if (s !== !1 && (s = !0), n === void 0 && o === void 0 && (s = !1), hn.showDiff !== !0 && (s = !1), !a) {
      r = Xm(this, arguments);
      const c = {
        actual: Lu(this, arguments),
        expected: n,
        showDiff: s
      }, f = fy(this, arguments);
      throw f && (c.operator = f), new tr(
        r,
        c,
        // @ts-expect-error Not sure what to do about these types yet
        hn.includeStack ? this.assert : Dt(this, "ssfi")
      );
    }
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @returns {unknown}
   */
  get _obj() {
    return Dt(this, "object");
  }
  /**
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @param {unknown} val
   */
  set _obj(t) {
    Dt(this, "object", t);
  }
};
function Xa() {
  return hn.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
ze(Xa, "isProxyEnabled");
function ny(e, t, r) {
  r = r === void 0 ? function() {
  } : r, Object.defineProperty(e, t, {
    get: /* @__PURE__ */ ze(function i() {
      !Xa() && !Dt(this, "lockSsfi") && Dt(this, "ssfi", i);
      let n = r.call(this);
      if (n !== void 0) return n;
      let o = new we();
      return Kn(this, o), o;
    }, "propertyGetter"),
    configurable: !0
  });
}
ze(ny, "addProperty");
var T4 = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Qa(e, t, r) {
  return T4.configurable && Object.defineProperty(e, "length", {
    get: /* @__PURE__ */ ze(function() {
      throw Error(
        r ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".'
      );
    }, "get")
  }), e;
}
ze(Qa, "addLengthGuard");
function hA(e) {
  let t = Object.getOwnPropertyNames(e);
  function r(n) {
    t.indexOf(n) === -1 && t.push(n);
  }
  ze(r, "addProperty");
  let i = Object.getPrototypeOf(e);
  for (; i !== null; )
    Object.getOwnPropertyNames(i).forEach(r), i = Object.getPrototypeOf(i);
  return t;
}
ze(hA, "getProperties");
var lv = ["__flags", "__methods", "_obj", "assert"];
function Go(e, t) {
  return Xa() ? new Proxy(e, {
    get: /* @__PURE__ */ ze(function r(i, n) {
      if (typeof n == "string" && hn.proxyExcludedKeys.indexOf(n) === -1 && !Reflect.has(i, n)) {
        if (t)
          throw Error(
            "Invalid Chai property: " + t + "." + n + '. See docs for proper usage of "' + t + '".'
          );
        let o = null, s = 4;
        throw hA(i).forEach(function(a) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(a) && lv.indexOf(a) === -1
          ) {
            let u = pA(n, a, s);
            u < s && (o = a, s = u);
          }
        }), Error(
          o !== null ? "Invalid Chai property: " + n + '. Did you mean "' + o + '"?' : "Invalid Chai property: " + n
        );
      }
      return lv.indexOf(n) === -1 && !Dt(i, "lockSsfi") && Dt(i, "ssfi", r), Reflect.get(i, n);
    }, "proxyGetter")
  }) : e;
}
ze(Go, "proxify");
function pA(e, t, r) {
  if (Math.abs(e.length - t.length) >= r)
    return r;
  let i = [];
  for (let n = 0; n <= e.length; n++)
    i[n] = Array(t.length + 1).fill(0), i[n][0] = n;
  for (let n = 0; n < t.length; n++)
    i[0][n] = n;
  for (let n = 1; n <= e.length; n++) {
    let o = e.charCodeAt(n - 1);
    for (let s = 1; s <= t.length; s++) {
      if (Math.abs(n - s) >= r) {
        i[n][s] = r;
        continue;
      }
      i[n][s] = Math.min(
        i[n - 1][s] + 1,
        i[n][s - 1] + 1,
        i[n - 1][s - 1] + (o === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  }
  return i[e.length][t.length];
}
ze(pA, "stringDistanceCapped");
function iy(e, t, r) {
  let i = /* @__PURE__ */ ze(function() {
    Dt(this, "lockSsfi") || Dt(this, "ssfi", i);
    let n = r.apply(this, arguments);
    if (n !== void 0) return n;
    let o = new we();
    return Kn(this, o), o;
  }, "methodWrapper");
  Qa(i, t, !1), e[t] = Go(i, t);
}
ze(iy, "addMethod");
function oy(e, t, r) {
  let i = Object.getOwnPropertyDescriptor(e, t), n = /* @__PURE__ */ ze(function() {
  }, "_super");
  i && typeof i.get == "function" && (n = i.get), Object.defineProperty(e, t, {
    get: /* @__PURE__ */ ze(function o() {
      !Xa() && !Dt(this, "lockSsfi") && Dt(this, "ssfi", o);
      let s = Dt(this, "lockSsfi");
      Dt(this, "lockSsfi", !0);
      let a = r(n).call(this);
      if (Dt(this, "lockSsfi", s), a !== void 0)
        return a;
      let u = new we();
      return Kn(this, u), u;
    }, "overwritingPropertyGetter"),
    configurable: !0
  });
}
ze(oy, "overwriteProperty");
function ay(e, t, r) {
  let i = e[t], n = /* @__PURE__ */ ze(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  i && typeof i == "function" && (n = i);
  let o = /* @__PURE__ */ ze(function() {
    Dt(this, "lockSsfi") || Dt(this, "ssfi", o);
    let s = Dt(this, "lockSsfi");
    Dt(this, "lockSsfi", !0);
    let a = r(n).apply(this, arguments);
    if (Dt(this, "lockSsfi", s), a !== void 0)
      return a;
    let u = new we();
    return Kn(this, u), u;
  }, "overwritingMethodWrapper");
  Qa(o, t, !1), e[t] = Go(o, t);
}
ze(ay, "overwriteMethod");
var N4 = typeof Object.setPrototypeOf == "function", fv = /* @__PURE__ */ ze(function() {
}, "testFn"), C4 = Object.getOwnPropertyNames(fv).filter(function(e) {
  let t = Object.getOwnPropertyDescriptor(fv, e);
  return typeof t != "object" ? !0 : !t.configurable;
}), R4 = Function.prototype.call, D4 = Function.prototype.apply;
function sy(e, t, r, i) {
  typeof i != "function" && (i = /* @__PURE__ */ ze(function() {
  }, "chainingBehavior"));
  let n = {
    method: r,
    chainingBehavior: i
  };
  e.__methods || (e.__methods = {}), e.__methods[t] = n, Object.defineProperty(e, t, {
    get: /* @__PURE__ */ ze(function() {
      n.chainingBehavior.call(this);
      let s = /* @__PURE__ */ ze(function() {
        Dt(this, "lockSsfi") || Dt(this, "ssfi", s);
        let a = n.method.apply(this, arguments);
        if (a !== void 0)
          return a;
        let u = new we();
        return Kn(this, u), u;
      }, "chainableMethodWrapper");
      if (Qa(s, t, !0), N4) {
        let a = Object.create(this);
        a.call = R4, a.apply = D4, Object.setPrototypeOf(s, a);
      } else
        Object.getOwnPropertyNames(e).forEach(function(u) {
          if (C4.indexOf(u) !== -1)
            return;
          let c = Object.getOwnPropertyDescriptor(e, u);
          Object.defineProperty(s, u, c);
        });
      return Kn(this, s), Go(s);
    }, "chainableMethodGetter"),
    configurable: !0
  });
}
ze(sy, "addChainableMethod");
function uy(e, t, r, i) {
  let n = e.__methods[t], o = n.chainingBehavior;
  n.chainingBehavior = /* @__PURE__ */ ze(function() {
    let u = i(o).call(this);
    if (u !== void 0)
      return u;
    let c = new we();
    return Kn(this, c), c;
  }, "overwritingChainableMethodGetter");
  let s = n.method;
  n.method = /* @__PURE__ */ ze(function() {
    let u = r(s).apply(this, arguments);
    if (u !== void 0)
      return u;
    let c = new we();
    return Kn(this, c), c;
  }, "overwritingChainableMethodWrapper");
}
ze(uy, "overwriteChainableMethod");
function iu(e, t) {
  return er(e) < er(t) ? -1 : 1;
}
ze(iu, "compareByInspect");
function cy(e) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.getOwnPropertyDescriptor(e, t).enumerable;
  });
}
ze(cy, "getOwnEnumerablePropertySymbols");
function ly(e) {
  return Object.keys(e).concat(cy(e));
}
ze(ly, "getOwnEnumerableProperties");
var ou = Number.isNaN;
function dA(e) {
  let t = lr(e);
  return ["Array", "Object", "Function"].indexOf(t) !== -1;
}
ze(dA, "isObjectType");
function fy(e, t) {
  let r = Dt(e, "operator"), i = Dt(e, "negate"), n = t[3], o = i ? t[2] : t[1];
  if (r)
    return r;
  if (typeof o == "function" && (o = o()), o = o || "", !o || /\shave\s/.test(o))
    return;
  let s = dA(n);
  return /\snot\s/.test(o) ? s ? "notDeepStrictEqual" : "notStrictEqual" : s ? "deepStrictEqual" : "strictEqual";
}
ze(fy, "getOperator");
function qu(e) {
  return e.name;
}
ze(qu, "getName");
function au(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
ze(au, "isRegExp");
function tn(e) {
  return ["Number", "BigInt"].includes(lr(e));
}
ze(tn, "isNumeric");
var { flag: Ce } = eu;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(e) {
  we.addProperty(e);
});
we.addProperty("not", function() {
  Ce(this, "negate", !0);
});
we.addProperty("deep", function() {
  Ce(this, "deep", !0);
});
we.addProperty("nested", function() {
  Ce(this, "nested", !0);
});
we.addProperty("own", function() {
  Ce(this, "own", !0);
});
we.addProperty("ordered", function() {
  Ce(this, "ordered", !0);
});
we.addProperty("any", function() {
  Ce(this, "any", !0), Ce(this, "all", !1);
});
we.addProperty("all", function() {
  Ce(this, "all", !0), Ce(this, "any", !1);
});
var hv = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function hy(e, t) {
  t && Ce(this, "message", t), e = e.toLowerCase();
  let r = Ce(this, "object"), i = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a ";
  const n = lr(r).toLowerCase();
  hv.function.includes(e) ? this.assert(
    hv[e].includes(n),
    "expected #{this} to be " + i + e,
    "expected #{this} not to be " + i + e
  ) : this.assert(
    e === n,
    "expected #{this} to be " + i + e,
    "expected #{this} not to be " + i + e
  );
}
ze(hy, "an");
we.addChainableMethod("an", hy);
we.addChainableMethod("a", hy);
function mA(e, t) {
  return ou(e) && ou(t) || e === t;
}
ze(mA, "SameValueZero");
function es() {
  Ce(this, "contains", !0);
}
ze(es, "includeChainingBehavior");
function ts(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = lr(r).toLowerCase(), n = Ce(this, "message"), o = Ce(this, "negate"), s = Ce(this, "ssfi"), a = Ce(this, "deep"), u = a ? "deep " : "", c = a ? Ce(this, "eql") : mA;
  n = n ? n + ": " : "";
  let f = !1;
  switch (i) {
    case "string":
      f = r.indexOf(e) !== -1;
      break;
    case "weakset":
      if (a)
        throw new tr(
          n + "unable to use .deep.include with WeakSet",
          void 0,
          s
        );
      f = r.has(e);
      break;
    case "map":
      r.forEach(function(h) {
        f = f || c(h, e);
      });
      break;
    case "set":
      a ? r.forEach(function(h) {
        f = f || c(h, e);
      }) : f = r.has(e);
      break;
    case "array":
      a ? f = r.some(function(h) {
        return c(h, e);
      }) : f = r.indexOf(e) !== -1;
      break;
    default: {
      if (e !== Object(e))
        throw new tr(
          n + "the given combination of arguments (" + i + " and " + lr(e).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + lr(e).toLowerCase(),
          void 0,
          s
        );
      let h = Object.keys(e), y = null, p = 0;
      if (h.forEach(function(l) {
        let d = new we(r);
        if (Kn(this, d, !0), Ce(d, "lockSsfi", !0), !o || h.length === 1) {
          d.property(l, e[l]);
          return;
        }
        try {
          d.property(l, e[l]);
        } catch (v) {
          if (!jn.compatibleConstructor(v, tr))
            throw v;
          y === null && (y = v), p++;
        }
      }, this), o && h.length > 1 && p === h.length)
        throw y;
      return;
    }
  }
  this.assert(
    f,
    "expected #{this} to " + u + "include " + er(e),
    "expected #{this} to not " + u + "include " + er(e)
  );
}
ze(ts, "include");
we.addChainableMethod("include", ts, es);
we.addChainableMethod("contain", ts, es);
we.addChainableMethod("contains", ts, es);
we.addChainableMethod("includes", ts, es);
we.addProperty("ok", function() {
  this.assert(
    Ce(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
we.addProperty("true", function() {
  this.assert(
    Ce(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !Ce(this, "negate")
  );
});
we.addProperty("numeric", function() {
  const e = Ce(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(lr(e)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !Ce(this, "negate")
  );
});
we.addProperty("callable", function() {
  const e = Ce(this, "object"), t = Ce(this, "ssfi"), r = Ce(this, "message"), i = r ? `${r}: ` : "", n = Ce(this, "negate"), o = n ? `${i}expected ${er(e)} not to be a callable function` : `${i}expected ${er(e)} to be a callable function`, s = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(lr(e));
  if (s && n || !s && !n)
    throw new tr(o, void 0, t);
});
we.addProperty("false", function() {
  this.assert(
    Ce(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!Ce(this, "negate")
  );
});
we.addProperty("null", function() {
  this.assert(
    Ce(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
we.addProperty("undefined", function() {
  this.assert(
    Ce(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
we.addProperty("NaN", function() {
  this.assert(
    ou(Ce(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function py() {
  let e = Ce(this, "object");
  this.assert(
    e != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
ze(py, "assertExist");
we.addProperty("exist", py);
we.addProperty("exists", py);
we.addProperty("empty", function() {
  let e = Ce(this, "object"), t = Ce(this, "ssfi"), r = Ce(this, "message"), i;
  switch (r = r ? r + ": " : "", lr(e).toLowerCase()) {
    case "array":
    case "string":
      i = e.length;
      break;
    case "map":
    case "set":
      i = e.size;
      break;
    case "weakmap":
    case "weakset":
      throw new tr(
        r + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function": {
      const n = r + ".empty was passed a function " + qu(e);
      throw new tr(n.trim(), void 0, t);
    }
    default:
      if (e !== Object(e))
        throw new tr(
          r + ".empty was passed non-string primitive " + er(e),
          void 0,
          t
        );
      i = Object.keys(e).length;
  }
  this.assert(
    i === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function dy() {
  let e = Ce(this, "object"), t = lr(e);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
ze(dy, "checkArguments");
we.addProperty("arguments", dy);
we.addProperty("Arguments", dy);
function Zu(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object");
  if (Ce(this, "deep")) {
    let i = Ce(this, "lockSsfi");
    Ce(this, "lockSsfi", !0), this.eql(e), Ce(this, "lockSsfi", i);
  } else
    this.assert(
      e === r,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      e,
      this._obj,
      !0
    );
}
ze(Zu, "assertEqual");
we.addMethod("equal", Zu);
we.addMethod("equals", Zu);
we.addMethod("eq", Zu);
function my(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "eql");
  this.assert(
    r(e, Ce(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    e,
    this._obj,
    !0
  );
}
ze(my, "assertEql");
we.addMethod("eql", my);
we.addMethod("eqls", my);
function Vu(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "doLength"), n = Ce(this, "message"), o = n ? n + ": " : "", s = Ce(this, "ssfi"), a = lr(r).toLowerCase(), u = lr(e).toLowerCase();
  if (i && a !== "map" && a !== "set" && new we(r, n, s, !0).to.have.property("length"), !i && a === "date" && u !== "date")
    throw new tr(
      o + "the argument to above must be a date",
      void 0,
      s
    );
  if (!tn(e) && (i || tn(r)))
    throw new tr(
      o + "the argument to above must be a number",
      void 0,
      s
    );
  if (!i && a !== "date" && !tn(r)) {
    let c = a === "string" ? "'" + r + "'" : r;
    throw new tr(
      o + "expected " + c + " to be a number or a date",
      void 0,
      s
    );
  }
  if (i) {
    let c = "length", f;
    a === "map" || a === "set" ? (c = "size", f = r.size) : f = r.length, this.assert(
      f > e,
      "expected #{this} to have a " + c + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + c + " above #{exp}",
      e,
      f
    );
  } else
    this.assert(
      r > e,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      e
    );
}
ze(Vu, "assertAbove");
we.addMethod("above", Vu);
we.addMethod("gt", Vu);
we.addMethod("greaterThan", Vu);
function Wu(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "doLength"), n = Ce(this, "message"), o = n ? n + ": " : "", s = Ce(this, "ssfi"), a = lr(r).toLowerCase(), u = lr(e).toLowerCase(), c, f = !0;
  if (i && a !== "map" && a !== "set" && new we(r, n, s, !0).to.have.property("length"), !i && a === "date" && u !== "date")
    c = o + "the argument to least must be a date";
  else if (!tn(e) && (i || tn(r)))
    c = o + "the argument to least must be a number";
  else if (!i && a !== "date" && !tn(r)) {
    let h = a === "string" ? "'" + r + "'" : r;
    c = o + "expected " + h + " to be a number or a date";
  } else
    f = !1;
  if (f)
    throw new tr(c, void 0, s);
  if (i) {
    let h = "length", y;
    a === "map" || a === "set" ? (h = "size", y = r.size) : y = r.length, this.assert(
      y >= e,
      "expected #{this} to have a " + h + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + h + " below #{exp}",
      e,
      y
    );
  } else
    this.assert(
      r >= e,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      e
    );
}
ze(Wu, "assertLeast");
we.addMethod("least", Wu);
we.addMethod("gte", Wu);
we.addMethod("greaterThanOrEqual", Wu);
function Gu(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "doLength"), n = Ce(this, "message"), o = n ? n + ": " : "", s = Ce(this, "ssfi"), a = lr(r).toLowerCase(), u = lr(e).toLowerCase(), c, f = !0;
  if (i && a !== "map" && a !== "set" && new we(r, n, s, !0).to.have.property("length"), !i && a === "date" && u !== "date")
    c = o + "the argument to below must be a date";
  else if (!tn(e) && (i || tn(r)))
    c = o + "the argument to below must be a number";
  else if (!i && a !== "date" && !tn(r)) {
    let h = a === "string" ? "'" + r + "'" : r;
    c = o + "expected " + h + " to be a number or a date";
  } else
    f = !1;
  if (f)
    throw new tr(c, void 0, s);
  if (i) {
    let h = "length", y;
    a === "map" || a === "set" ? (h = "size", y = r.size) : y = r.length, this.assert(
      y < e,
      "expected #{this} to have a " + h + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + h + " below #{exp}",
      e,
      y
    );
  } else
    this.assert(
      r < e,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      e
    );
}
ze(Gu, "assertBelow");
we.addMethod("below", Gu);
we.addMethod("lt", Gu);
we.addMethod("lessThan", Gu);
function Ku(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "doLength"), n = Ce(this, "message"), o = n ? n + ": " : "", s = Ce(this, "ssfi"), a = lr(r).toLowerCase(), u = lr(e).toLowerCase(), c, f = !0;
  if (i && a !== "map" && a !== "set" && new we(r, n, s, !0).to.have.property("length"), !i && a === "date" && u !== "date")
    c = o + "the argument to most must be a date";
  else if (!tn(e) && (i || tn(r)))
    c = o + "the argument to most must be a number";
  else if (!i && a !== "date" && !tn(r)) {
    let h = a === "string" ? "'" + r + "'" : r;
    c = o + "expected " + h + " to be a number or a date";
  } else
    f = !1;
  if (f)
    throw new tr(c, void 0, s);
  if (i) {
    let h = "length", y;
    a === "map" || a === "set" ? (h = "size", y = r.size) : y = r.length, this.assert(
      y <= e,
      "expected #{this} to have a " + h + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + h + " above #{exp}",
      e,
      y
    );
  } else
    this.assert(
      r <= e,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      e
    );
}
ze(Ku, "assertMost");
we.addMethod("most", Ku);
we.addMethod("lte", Ku);
we.addMethod("lessThanOrEqual", Ku);
we.addMethod("within", function(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Ce(this, "doLength"), o = Ce(this, "message"), s = o ? o + ": " : "", a = Ce(this, "ssfi"), u = lr(i).toLowerCase(), c = lr(e).toLowerCase(), f = lr(t).toLowerCase(), h, y = !0, p = c === "date" && f === "date" ? e.toISOString() + ".." + t.toISOString() : e + ".." + t;
  if (n && u !== "map" && u !== "set" && new we(i, o, a, !0).to.have.property("length"), !n && u === "date" && (c !== "date" || f !== "date"))
    h = s + "the arguments to within must be dates";
  else if ((!tn(e) || !tn(t)) && (n || tn(i)))
    h = s + "the arguments to within must be numbers";
  else if (!n && u !== "date" && !tn(i)) {
    let l = u === "string" ? "'" + i + "'" : i;
    h = s + "expected " + l + " to be a number or a date";
  } else
    y = !1;
  if (y)
    throw new tr(h, void 0, a);
  if (n) {
    let l = "length", d;
    u === "map" || u === "set" ? (l = "size", d = i.size) : d = i.length, this.assert(
      d >= e && d <= t,
      "expected #{this} to have a " + l + " within " + p,
      "expected #{this} to not have a " + l + " within " + p
    );
  } else
    this.assert(
      i >= e && i <= t,
      "expected #{this} to be within " + p,
      "expected #{this} to not be within " + p
    );
});
function yy(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "ssfi"), n = Ce(this, "message"), o;
  try {
    o = r instanceof e;
  } catch (a) {
    throw a instanceof TypeError ? (n = n ? n + ": " : "", new tr(
      n + "The instanceof assertion needs a constructor but " + lr(e) + " was given.",
      void 0,
      i
    )) : a;
  }
  let s = qu(e);
  s == null && (s = "an unnamed constructor"), this.assert(
    o,
    "expected #{this} to be an instance of " + s,
    "expected #{this} to not be an instance of " + s
  );
}
ze(yy, "assertInstanceOf");
we.addMethod("instanceof", yy);
we.addMethod("instanceOf", yy);
function gy(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "nested"), n = Ce(this, "own"), o = Ce(this, "message"), s = Ce(this, "object"), a = Ce(this, "ssfi"), u = typeof e;
  if (o = o ? o + ": " : "", i) {
    if (u !== "string")
      throw new tr(
        o + "the argument to property must be a string when using nested syntax",
        void 0,
        a
      );
  } else if (u !== "string" && u !== "number" && u !== "symbol")
    throw new tr(
      o + "the argument to property must be a string, number, or symbol",
      void 0,
      a
    );
  if (i && n)
    throw new tr(
      o + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      a
    );
  if (s == null)
    throw new tr(
      o + "Target cannot be null or undefined.",
      void 0,
      a
    );
  let c = Ce(this, "deep"), f = Ce(this, "negate"), h = i ? ry(s, e) : null, y = i ? h.value : s[e], p = c ? Ce(this, "eql") : (v, m) => v === m, l = "";
  c && (l += "deep "), n && (l += "own "), i && (l += "nested "), l += "property ";
  let d;
  n ? d = Object.prototype.hasOwnProperty.call(s, e) : i ? d = h.exists : d = Bu(s, e), (!f || arguments.length === 1) && this.assert(
    d,
    "expected #{this} to have " + l + er(e),
    "expected #{this} to not have " + l + er(e)
  ), arguments.length > 1 && this.assert(
    d && p(t, y),
    "expected #{this} to have " + l + er(e) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + l + er(e) + " of #{act}",
    t,
    y
  ), Ce(this, "object", y);
}
ze(gy, "assertProperty");
we.addMethod("property", gy);
function vy(e, t, r) {
  Ce(this, "own", !0), gy.apply(this, arguments);
}
ze(vy, "assertOwnProperty");
we.addMethod("ownProperty", vy);
we.addMethod("haveOwnProperty", vy);
function by(e, t, r) {
  typeof t == "string" && (r = t, t = null), r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Object.getOwnPropertyDescriptor(Object(i), e), o = Ce(this, "eql");
  n && t ? this.assert(
    o(t, n),
    "expected the own property descriptor for " + er(e) + " on #{this} to match " + er(t) + ", got " + er(n),
    "expected the own property descriptor for " + er(e) + " on #{this} to not match " + er(t),
    t,
    n,
    !0
  ) : this.assert(
    n,
    "expected #{this} to have an own property descriptor for " + er(e),
    "expected #{this} to not have an own property descriptor for " + er(e)
  ), Ce(this, "object", n);
}
ze(by, "assertOwnPropertyDescriptor");
we.addMethod("ownPropertyDescriptor", by);
we.addMethod("haveOwnPropertyDescriptor", by);
function _y() {
  Ce(this, "doLength", !0);
}
ze(_y, "assertLengthChain");
function wy(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = lr(r).toLowerCase(), n = Ce(this, "message"), o = Ce(this, "ssfi"), s = "length", a;
  switch (i) {
    case "map":
    case "set":
      s = "size", a = r.size;
      break;
    default:
      new we(r, n, o, !0).to.have.property("length"), a = r.length;
  }
  this.assert(
    a == e,
    "expected #{this} to have a " + s + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + s + " of #{act}",
    e,
    a
  );
}
ze(wy, "assertLength");
we.addChainableMethod("length", wy, _y);
we.addChainableMethod("lengthOf", wy, _y);
function Oy(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object");
  this.assert(
    e.exec(r),
    "expected #{this} to match " + e,
    "expected #{this} not to match " + e
  );
}
ze(Oy, "assertMatch");
we.addMethod("match", Oy);
we.addMethod("matches", Oy);
we.addMethod("string", function(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "message"), n = Ce(this, "ssfi");
  new we(r, i, n, !0).is.a("string"), this.assert(
    ~r.indexOf(e),
    "expected #{this} to contain " + er(e),
    "expected #{this} to not contain " + er(e)
  );
});
function $y(e) {
  let t = Ce(this, "object"), r = lr(t), i = lr(e), n = Ce(this, "ssfi"), o = Ce(this, "deep"), s, a = "", u, c = !0, f = Ce(this, "message");
  f = f ? f + ": " : "";
  let h = f + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (r === "Map" || r === "Set")
    a = o ? "deeply " : "", u = [], t.forEach(function(m, g) {
      u.push(g);
    }), i !== "Array" && (e = Array.prototype.slice.call(arguments));
  else {
    switch (u = ly(t), i) {
      case "Array":
        if (arguments.length > 1)
          throw new tr(h, void 0, n);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new tr(h, void 0, n);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function(m) {
      return typeof m == "symbol" ? m : String(m);
    });
  }
  if (!e.length)
    throw new tr(f + "keys required", void 0, n);
  let y = e.length, p = Ce(this, "any"), l = Ce(this, "all"), d = e, v = o ? Ce(this, "eql") : (m, g) => m === g;
  if (!p && !l && (l = !0), p && (c = d.some(function(m) {
    return u.some(function(g) {
      return v(m, g);
    });
  })), l && (c = d.every(function(m) {
    return u.some(function(g) {
      return v(m, g);
    });
  }), Ce(this, "contains") || (c = c && e.length == u.length)), y > 1) {
    e = e.map(function(g) {
      return er(g);
    });
    let m = e.pop();
    l && (s = e.join(", ") + ", and " + m), p && (s = e.join(", ") + ", or " + m);
  } else
    s = er(e[0]);
  s = (y > 1 ? "keys " : "key ") + s, s = (Ce(this, "contains") ? "contain " : "have ") + s, this.assert(
    c,
    "expected #{this} to " + a + s,
    "expected #{this} to not " + a + s,
    d.slice(0).sort(iu),
    u.sort(iu),
    !0
  );
}
ze($y, "assertKeys");
we.addMethod("keys", $y);
we.addMethod("key", $y);
function Hu(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Ce(this, "ssfi"), o = Ce(this, "message"), s = Ce(this, "negate") || !1;
  new we(i, o, n, !0).is.a("function"), (au(e) || typeof e == "string") && (t = e, e = null);
  let a, u = !1;
  try {
    i();
  } catch (p) {
    u = !0, a = p;
  }
  let c = e === void 0 && t === void 0, f = !!(e && t), h = !1, y = !1;
  if (c || !c && !s) {
    let p = "an error";
    e instanceof Error ? p = "#{exp}" : e && (p = jn.getConstructorName(e));
    let l = a;
    if (a instanceof Error)
      l = a.toString();
    else if (typeof a == "string")
      l = a;
    else if (a && (typeof a == "object" || typeof a == "function"))
      try {
        l = jn.getConstructorName(a);
      } catch {
      }
    this.assert(
      u,
      "expected #{this} to throw " + p,
      "expected #{this} to not throw an error but #{act} was thrown",
      e && e.toString(),
      l
    );
  }
  if (e && a && (e instanceof Error && jn.compatibleInstance(
    a,
    e
  ) === s && (f && s ? h = !0 : this.assert(
    s,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a && !s ? " but #{act} was thrown" : ""),
    e.toString(),
    a.toString()
  )), jn.compatibleConstructor(
    a,
    e
  ) === s && (f && s ? h = !0 : this.assert(
    s,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && jn.getConstructorName(e),
    a instanceof Error ? a.toString() : a && jn.getConstructorName(a)
  ))), a && t !== void 0 && t !== null) {
    let p = "including";
    au(t) && (p = "matching"), jn.compatibleMessage(
      a,
      t
    ) === s && (f && s ? y = !0 : this.assert(
      s,
      "expected #{this} to throw error " + p + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + p + " #{exp}",
      t,
      jn.getMessage(a)
    ));
  }
  h && y && this.assert(
    s,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && jn.getConstructorName(e),
    a instanceof Error ? a.toString() : a && jn.getConstructorName(a)
  ), Ce(this, "object", a);
}
ze(Hu, "assertThrows");
we.addMethod("throw", Hu);
we.addMethod("throws", Hu);
we.addMethod("Throw", Hu);
function Sy(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "itself"), n = typeof r == "function" && !i ? r.prototype[e] : r[e];
  this.assert(
    typeof n == "function",
    "expected #{this} to respond to " + er(e),
    "expected #{this} to not respond to " + er(e)
  );
}
ze(Sy, "respondTo");
we.addMethod("respondTo", Sy);
we.addMethod("respondsTo", Sy);
we.addProperty("itself", function() {
  Ce(this, "itself", !0);
});
function Ey(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = e(r);
  this.assert(
    i,
    "expected #{this} to satisfy " + Qi(e),
    "expected #{this} to not satisfy" + Qi(e),
    !Ce(this, "negate"),
    i
  );
}
ze(Ey, "satisfy");
we.addMethod("satisfy", Ey);
we.addMethod("satisfies", Ey);
function xy(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Ce(this, "message"), o = Ce(this, "ssfi");
  new we(i, n, o, !0).is.numeric;
  let s = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new tr(
      n ? `${n}: ${s}` : s,
      void 0,
      o
    );
  if (new we(t, n, o, !0).is.numeric, s = "A `expected` value is required for `closeTo`", e == null)
    throw new tr(
      n ? `${n}: ${s}` : s,
      void 0,
      o
    );
  new we(e, n, o, !0).is.numeric;
  const a = /* @__PURE__ */ ze((c) => c < 0n ? -c : c, "abs"), u = /* @__PURE__ */ ze((c) => parseFloat(parseFloat(c).toPrecision(12)), "strip");
  this.assert(
    u(a(i - e)) <= t,
    "expected #{this} to be close to " + e + " +/- " + t,
    "expected #{this} not to be close to " + e + " +/- " + t
  );
}
ze(xy, "closeTo");
we.addMethod("closeTo", xy);
we.addMethod("approximately", xy);
function yA(e, t, r, i, n) {
  let o = Array.from(t), s = Array.from(e);
  if (!i) {
    if (s.length !== o.length) return !1;
    o = o.slice();
  }
  return s.every(function(a, u) {
    if (n) return r ? r(a, o[u]) : a === o[u];
    if (!r) {
      let c = o.indexOf(a);
      return c === -1 ? !1 : (i || o.splice(c, 1), !0);
    }
    return o.some(function(c, f) {
      return r(a, c) ? (i || o.splice(f, 1), !0) : !1;
    });
  });
}
ze(yA, "isSubsetOf");
we.addMethod("members", function(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "message"), n = Ce(this, "ssfi");
  new we(r, i, n, !0).to.be.iterable, new we(e, i, n, !0).to.be.iterable;
  let o = Ce(this, "contains"), s = Ce(this, "ordered"), a, u, c;
  o ? (a = s ? "an ordered superset" : "a superset", u = "expected #{this} to be " + a + " of #{exp}", c = "expected #{this} to not be " + a + " of #{exp}") : (a = s ? "ordered members" : "members", u = "expected #{this} to have the same " + a + " as #{exp}", c = "expected #{this} to not have the same " + a + " as #{exp}");
  let f = Ce(this, "deep") ? Ce(this, "eql") : void 0;
  this.assert(
    yA(e, r, f, o, s),
    u,
    c,
    e,
    r,
    !0
  );
});
we.addProperty("iterable", function(e) {
  e && Ce(this, "message", e);
  let t = Ce(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function gA(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "object"), i = Ce(this, "message"), n = Ce(this, "ssfi"), o = Ce(this, "contains"), s = Ce(this, "deep"), a = Ce(this, "eql");
  new we(e, i, n, !0).to.be.an("array"), o ? this.assert(
    e.some(function(u) {
      return r.indexOf(u) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    e,
    r
  ) : s ? this.assert(
    e.some(function(u) {
      return a(r, u);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    e,
    r
  ) : this.assert(
    e.indexOf(r) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    e,
    r
  );
}
ze(gA, "oneOf");
we.addMethod("oneOf", gA);
function Ay(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Ce(this, "message"), o = Ce(this, "ssfi");
  new we(i, n, o, !0).is.a("function");
  let s;
  t ? (new we(e, n, o, !0).to.have.property(t), s = e[t]) : (new we(e, n, o, !0).is.a("function"), s = e()), i();
  let a = t == null ? e() : e[t], u = t == null ? s : "." + t;
  Ce(this, "deltaMsgObj", u), Ce(this, "initialDeltaValue", s), Ce(this, "finalDeltaValue", a), Ce(this, "deltaBehavior", "change"), Ce(this, "realDelta", a !== s), this.assert(
    s !== a,
    "expected " + u + " to change",
    "expected " + u + " to not change"
  );
}
ze(Ay, "assertChanges");
we.addMethod("change", Ay);
we.addMethod("changes", Ay);
function jy(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Ce(this, "message"), o = Ce(this, "ssfi");
  new we(i, n, o, !0).is.a("function");
  let s;
  t ? (new we(e, n, o, !0).to.have.property(t), s = e[t]) : (new we(e, n, o, !0).is.a("function"), s = e()), new we(s, n, o, !0).is.a("number"), i();
  let a = t == null ? e() : e[t], u = t == null ? s : "." + t;
  Ce(this, "deltaMsgObj", u), Ce(this, "initialDeltaValue", s), Ce(this, "finalDeltaValue", a), Ce(this, "deltaBehavior", "increase"), Ce(this, "realDelta", a - s), this.assert(
    a - s > 0,
    "expected " + u + " to increase",
    "expected " + u + " to not increase"
  );
}
ze(jy, "assertIncreases");
we.addMethod("increase", jy);
we.addMethod("increases", jy);
function ky(e, t, r) {
  r && Ce(this, "message", r);
  let i = Ce(this, "object"), n = Ce(this, "message"), o = Ce(this, "ssfi");
  new we(i, n, o, !0).is.a("function");
  let s;
  t ? (new we(e, n, o, !0).to.have.property(t), s = e[t]) : (new we(e, n, o, !0).is.a("function"), s = e()), new we(s, n, o, !0).is.a("number"), i();
  let a = t == null ? e() : e[t], u = t == null ? s : "." + t;
  Ce(this, "deltaMsgObj", u), Ce(this, "initialDeltaValue", s), Ce(this, "finalDeltaValue", a), Ce(this, "deltaBehavior", "decrease"), Ce(this, "realDelta", s - a), this.assert(
    a - s < 0,
    "expected " + u + " to decrease",
    "expected " + u + " to not decrease"
  );
}
ze(ky, "assertDecreases");
we.addMethod("decrease", ky);
we.addMethod("decreases", ky);
function vA(e, t) {
  t && Ce(this, "message", t);
  let r = Ce(this, "deltaMsgObj"), i = Ce(this, "initialDeltaValue"), n = Ce(this, "finalDeltaValue"), o = Ce(this, "deltaBehavior"), s = Ce(this, "realDelta"), a;
  o === "change" ? a = Math.abs(n - i) === Math.abs(e) : a = s === Math.abs(e), this.assert(
    a,
    "expected " + r + " to " + o + " by " + e,
    "expected " + r + " to not " + o + " by " + e
  );
}
ze(vA, "assertDelta");
we.addMethod("by", vA);
we.addProperty("extensible", function() {
  let e = Ce(this, "object"), t = e === Object(e) && Object.isExtensible(e);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
we.addProperty("sealed", function() {
  let e = Ce(this, "object"), t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
we.addProperty("frozen", function() {
  let e = Ce(this, "object"), t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
we.addProperty("finite", function(e) {
  let t = Ce(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function su(e, t) {
  return e === t ? !0 : typeof t != typeof e ? !1 : typeof e != "object" || e === null ? e === t : t ? Array.isArray(e) ? Array.isArray(t) ? e.every(function(r) {
    return t.some(function(i) {
      return su(r, i);
    });
  }) : !1 : e instanceof Date ? t instanceof Date ? e.getTime() === t.getTime() : !1 : Object.keys(e).every(function(r) {
    let i = e[r], n = t[r];
    return typeof i == "object" && i !== null && n !== null ? su(i, n) : typeof i == "function" ? i(n) : n === i;
  }) : !1;
}
ze(su, "compareSubset");
we.addMethod("containSubset", function(e) {
  const t = Dt(this, "object"), r = hn.showDiff;
  this.assert(
    su(e, t),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    e,
    t,
    r
  );
});
function uu(e, t) {
  return new we(e, t);
}
ze(uu, "expect");
uu.fail = function(e, t, r, i) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "expect.fail()", new tr(
    r,
    {
      actual: e,
      expected: t,
      operator: i
    },
    uu.fail
  );
};
var bA = {};
Hm(bA, {
  Should: () => U4,
  should: () => z4
});
function Py() {
  function e() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new we(this.valueOf(), null, e) : new we(this, null, e);
  }
  ze(e, "shouldGetter");
  function t(i) {
    Object.defineProperty(this, "should", {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  ze(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: e,
    configurable: !0
  });
  let r = {};
  return r.fail = function(i, n, o, s) {
    throw arguments.length < 2 && (o = i, i = void 0), o = o || "should.fail()", new tr(
      o,
      {
        actual: i,
        expected: n,
        operator: s
      },
      r.fail
    );
  }, r.equal = function(i, n, o) {
    new we(i, o).to.equal(n);
  }, r.Throw = function(i, n, o, s) {
    new we(i, s).to.Throw(n, o);
  }, r.exist = function(i, n) {
    new we(i, n).to.exist;
  }, r.not = {}, r.not.equal = function(i, n, o) {
    new we(i, o).to.not.equal(n);
  }, r.not.Throw = function(i, n, o, s) {
    new we(i, s).to.not.Throw(n, o);
  }, r.not.exist = function(i, n) {
    new we(i, n).to.not.exist;
  }, r.throw = r.Throw, r.not.throw = r.not.Throw, r;
}
ze(Py, "loadShould");
var z4 = Py, U4 = Py;
function ve(e, t) {
  new we(null, null, ve, !0).assert(e, t, "[ negation message unavailable ]");
}
ze(ve, "assert");
ve.fail = function(e, t, r, i) {
  throw arguments.length < 2 && (r = e, e = void 0), r = r || "assert.fail()", new tr(
    r,
    {
      actual: e,
      expected: t,
      operator: i
    },
    ve.fail
  );
};
ve.isOk = function(e, t) {
  new we(e, t, ve.isOk, !0).is.ok;
};
ve.isNotOk = function(e, t) {
  new we(e, t, ve.isNotOk, !0).is.not.ok;
};
ve.equal = function(e, t, r) {
  let i = new we(e, r, ve.equal, !0);
  i.assert(
    t == Dt(i, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    e,
    !0
  );
};
ve.notEqual = function(e, t, r) {
  let i = new we(e, r, ve.notEqual, !0);
  i.assert(
    t != Dt(i, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    e,
    !0
  );
};
ve.strictEqual = function(e, t, r) {
  new we(e, r, ve.strictEqual, !0).to.equal(t);
};
ve.notStrictEqual = function(e, t, r) {
  new we(e, r, ve.notStrictEqual, !0).to.not.equal(t);
};
ve.deepEqual = ve.deepStrictEqual = function(e, t, r) {
  new we(e, r, ve.deepEqual, !0).to.eql(t);
};
ve.notDeepEqual = function(e, t, r) {
  new we(e, r, ve.notDeepEqual, !0).to.not.eql(t);
};
ve.isAbove = function(e, t, r) {
  new we(e, r, ve.isAbove, !0).to.be.above(t);
};
ve.isAtLeast = function(e, t, r) {
  new we(e, r, ve.isAtLeast, !0).to.be.least(t);
};
ve.isBelow = function(e, t, r) {
  new we(e, r, ve.isBelow, !0).to.be.below(t);
};
ve.isAtMost = function(e, t, r) {
  new we(e, r, ve.isAtMost, !0).to.be.most(t);
};
ve.isTrue = function(e, t) {
  new we(e, t, ve.isTrue, !0).is.true;
};
ve.isNotTrue = function(e, t) {
  new we(e, t, ve.isNotTrue, !0).to.not.equal(!0);
};
ve.isFalse = function(e, t) {
  new we(e, t, ve.isFalse, !0).is.false;
};
ve.isNotFalse = function(e, t) {
  new we(e, t, ve.isNotFalse, !0).to.not.equal(!1);
};
ve.isNull = function(e, t) {
  new we(e, t, ve.isNull, !0).to.equal(null);
};
ve.isNotNull = function(e, t) {
  new we(e, t, ve.isNotNull, !0).to.not.equal(null);
};
ve.isNaN = function(e, t) {
  new we(e, t, ve.isNaN, !0).to.be.NaN;
};
ve.isNotNaN = function(e, t) {
  new we(e, t, ve.isNotNaN, !0).not.to.be.NaN;
};
ve.exists = function(e, t) {
  new we(e, t, ve.exists, !0).to.exist;
};
ve.notExists = function(e, t) {
  new we(e, t, ve.notExists, !0).to.not.exist;
};
ve.isUndefined = function(e, t) {
  new we(e, t, ve.isUndefined, !0).to.equal(void 0);
};
ve.isDefined = function(e, t) {
  new we(e, t, ve.isDefined, !0).to.not.equal(void 0);
};
ve.isCallable = function(e, t) {
  new we(e, t, ve.isCallable, !0).is.callable;
};
ve.isNotCallable = function(e, t) {
  new we(e, t, ve.isNotCallable, !0).is.not.callable;
};
ve.isObject = function(e, t) {
  new we(e, t, ve.isObject, !0).to.be.a("object");
};
ve.isNotObject = function(e, t) {
  new we(e, t, ve.isNotObject, !0).to.not.be.a("object");
};
ve.isArray = function(e, t) {
  new we(e, t, ve.isArray, !0).to.be.an("array");
};
ve.isNotArray = function(e, t) {
  new we(e, t, ve.isNotArray, !0).to.not.be.an("array");
};
ve.isString = function(e, t) {
  new we(e, t, ve.isString, !0).to.be.a("string");
};
ve.isNotString = function(e, t) {
  new we(e, t, ve.isNotString, !0).to.not.be.a("string");
};
ve.isNumber = function(e, t) {
  new we(e, t, ve.isNumber, !0).to.be.a("number");
};
ve.isNotNumber = function(e, t) {
  new we(e, t, ve.isNotNumber, !0).to.not.be.a("number");
};
ve.isNumeric = function(e, t) {
  new we(e, t, ve.isNumeric, !0).is.numeric;
};
ve.isNotNumeric = function(e, t) {
  new we(e, t, ve.isNotNumeric, !0).is.not.numeric;
};
ve.isFinite = function(e, t) {
  new we(e, t, ve.isFinite, !0).to.be.finite;
};
ve.isBoolean = function(e, t) {
  new we(e, t, ve.isBoolean, !0).to.be.a("boolean");
};
ve.isNotBoolean = function(e, t) {
  new we(e, t, ve.isNotBoolean, !0).to.not.be.a("boolean");
};
ve.typeOf = function(e, t, r) {
  new we(e, r, ve.typeOf, !0).to.be.a(t);
};
ve.notTypeOf = function(e, t, r) {
  new we(e, r, ve.notTypeOf, !0).to.not.be.a(t);
};
ve.instanceOf = function(e, t, r) {
  new we(e, r, ve.instanceOf, !0).to.be.instanceOf(t);
};
ve.notInstanceOf = function(e, t, r) {
  new we(e, r, ve.notInstanceOf, !0).to.not.be.instanceOf(
    t
  );
};
ve.include = function(e, t, r) {
  new we(e, r, ve.include, !0).include(t);
};
ve.notInclude = function(e, t, r) {
  new we(e, r, ve.notInclude, !0).not.include(t);
};
ve.deepInclude = function(e, t, r) {
  new we(e, r, ve.deepInclude, !0).deep.include(t);
};
ve.notDeepInclude = function(e, t, r) {
  new we(e, r, ve.notDeepInclude, !0).not.deep.include(t);
};
ve.nestedInclude = function(e, t, r) {
  new we(e, r, ve.nestedInclude, !0).nested.include(t);
};
ve.notNestedInclude = function(e, t, r) {
  new we(e, r, ve.notNestedInclude, !0).not.nested.include(
    t
  );
};
ve.deepNestedInclude = function(e, t, r) {
  new we(e, r, ve.deepNestedInclude, !0).deep.nested.include(
    t
  );
};
ve.notDeepNestedInclude = function(e, t, r) {
  new we(
    e,
    r,
    ve.notDeepNestedInclude,
    !0
  ).not.deep.nested.include(t);
};
ve.ownInclude = function(e, t, r) {
  new we(e, r, ve.ownInclude, !0).own.include(t);
};
ve.notOwnInclude = function(e, t, r) {
  new we(e, r, ve.notOwnInclude, !0).not.own.include(t);
};
ve.deepOwnInclude = function(e, t, r) {
  new we(e, r, ve.deepOwnInclude, !0).deep.own.include(t);
};
ve.notDeepOwnInclude = function(e, t, r) {
  new we(e, r, ve.notDeepOwnInclude, !0).not.deep.own.include(
    t
  );
};
ve.match = function(e, t, r) {
  new we(e, r, ve.match, !0).to.match(t);
};
ve.notMatch = function(e, t, r) {
  new we(e, r, ve.notMatch, !0).to.not.match(t);
};
ve.property = function(e, t, r) {
  new we(e, r, ve.property, !0).to.have.property(t);
};
ve.notProperty = function(e, t, r) {
  new we(e, r, ve.notProperty, !0).to.not.have.property(t);
};
ve.propertyVal = function(e, t, r, i) {
  new we(e, i, ve.propertyVal, !0).to.have.property(t, r);
};
ve.notPropertyVal = function(e, t, r, i) {
  new we(e, i, ve.notPropertyVal, !0).to.not.have.property(
    t,
    r
  );
};
ve.deepPropertyVal = function(e, t, r, i) {
  new we(e, i, ve.deepPropertyVal, !0).to.have.deep.property(
    t,
    r
  );
};
ve.notDeepPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.notDeepPropertyVal,
    !0
  ).to.not.have.deep.property(t, r);
};
ve.ownProperty = function(e, t, r) {
  new we(e, r, ve.ownProperty, !0).to.have.own.property(t);
};
ve.notOwnProperty = function(e, t, r) {
  new we(e, r, ve.notOwnProperty, !0).to.not.have.own.property(
    t
  );
};
ve.ownPropertyVal = function(e, t, r, i) {
  new we(e, i, ve.ownPropertyVal, !0).to.have.own.property(
    t,
    r
  );
};
ve.notOwnPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.notOwnPropertyVal,
    !0
  ).to.not.have.own.property(t, r);
};
ve.deepOwnPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.deepOwnPropertyVal,
    !0
  ).to.have.deep.own.property(t, r);
};
ve.notDeepOwnPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.notDeepOwnPropertyVal,
    !0
  ).to.not.have.deep.own.property(t, r);
};
ve.nestedProperty = function(e, t, r) {
  new we(e, r, ve.nestedProperty, !0).to.have.nested.property(
    t
  );
};
ve.notNestedProperty = function(e, t, r) {
  new we(
    e,
    r,
    ve.notNestedProperty,
    !0
  ).to.not.have.nested.property(t);
};
ve.nestedPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.nestedPropertyVal,
    !0
  ).to.have.nested.property(t, r);
};
ve.notNestedPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.notNestedPropertyVal,
    !0
  ).to.not.have.nested.property(t, r);
};
ve.deepNestedPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.deepNestedPropertyVal,
    !0
  ).to.have.deep.nested.property(t, r);
};
ve.notDeepNestedPropertyVal = function(e, t, r, i) {
  new we(
    e,
    i,
    ve.notDeepNestedPropertyVal,
    !0
  ).to.not.have.deep.nested.property(t, r);
};
ve.lengthOf = function(e, t, r) {
  new we(e, r, ve.lengthOf, !0).to.have.lengthOf(t);
};
ve.hasAnyKeys = function(e, t, r) {
  new we(e, r, ve.hasAnyKeys, !0).to.have.any.keys(t);
};
ve.hasAllKeys = function(e, t, r) {
  new we(e, r, ve.hasAllKeys, !0).to.have.all.keys(t);
};
ve.containsAllKeys = function(e, t, r) {
  new we(e, r, ve.containsAllKeys, !0).to.contain.all.keys(
    t
  );
};
ve.doesNotHaveAnyKeys = function(e, t, r) {
  new we(e, r, ve.doesNotHaveAnyKeys, !0).to.not.have.any.keys(
    t
  );
};
ve.doesNotHaveAllKeys = function(e, t, r) {
  new we(e, r, ve.doesNotHaveAllKeys, !0).to.not.have.all.keys(
    t
  );
};
ve.hasAnyDeepKeys = function(e, t, r) {
  new we(e, r, ve.hasAnyDeepKeys, !0).to.have.any.deep.keys(
    t
  );
};
ve.hasAllDeepKeys = function(e, t, r) {
  new we(e, r, ve.hasAllDeepKeys, !0).to.have.all.deep.keys(
    t
  );
};
ve.containsAllDeepKeys = function(e, t, r) {
  new we(
    e,
    r,
    ve.containsAllDeepKeys,
    !0
  ).to.contain.all.deep.keys(t);
};
ve.doesNotHaveAnyDeepKeys = function(e, t, r) {
  new we(
    e,
    r,
    ve.doesNotHaveAnyDeepKeys,
    !0
  ).to.not.have.any.deep.keys(t);
};
ve.doesNotHaveAllDeepKeys = function(e, t, r) {
  new we(
    e,
    r,
    ve.doesNotHaveAllDeepKeys,
    !0
  ).to.not.have.all.deep.keys(t);
};
ve.throws = function(e, t, r, i) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null);
  let n = new we(e, i, ve.throws, !0).to.throw(
    t,
    r
  );
  return Dt(n, "object");
};
ve.doesNotThrow = function(e, t, r, i) {
  (typeof t == "string" || t instanceof RegExp) && (r = t, t = null), new we(e, i, ve.doesNotThrow, !0).to.not.throw(
    t,
    r
  );
};
ve.operator = function(e, t, r, i) {
  let n;
  switch (t) {
    case "==":
      n = e == r;
      break;
    case "===":
      n = e === r;
      break;
    case ">":
      n = e > r;
      break;
    case ">=":
      n = e >= r;
      break;
    case "<":
      n = e < r;
      break;
    case "<=":
      n = e <= r;
      break;
    case "!=":
      n = e != r;
      break;
    case "!==":
      n = e !== r;
      break;
    default:
      throw i = i && i + ": ", new tr(
        i + 'Invalid operator "' + t + '"',
        void 0,
        ve.operator
      );
  }
  let o = new we(n, i, ve.operator, !0);
  o.assert(
    Dt(o, "object") === !0,
    "expected " + er(e) + " to be " + t + " " + er(r),
    "expected " + er(e) + " to not be " + t + " " + er(r)
  );
};
ve.closeTo = function(e, t, r, i) {
  new we(e, i, ve.closeTo, !0).to.be.closeTo(t, r);
};
ve.approximately = function(e, t, r, i) {
  new we(e, i, ve.approximately, !0).to.be.approximately(
    t,
    r
  );
};
ve.sameMembers = function(e, t, r) {
  new we(e, r, ve.sameMembers, !0).to.have.same.members(t);
};
ve.notSameMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notSameMembers,
    !0
  ).to.not.have.same.members(t);
};
ve.sameDeepMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.sameDeepMembers,
    !0
  ).to.have.same.deep.members(t);
};
ve.notSameDeepMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notSameDeepMembers,
    !0
  ).to.not.have.same.deep.members(t);
};
ve.sameOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.sameOrderedMembers,
    !0
  ).to.have.same.ordered.members(t);
};
ve.notSameOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notSameOrderedMembers,
    !0
  ).to.not.have.same.ordered.members(t);
};
ve.sameDeepOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.sameDeepOrderedMembers,
    !0
  ).to.have.same.deep.ordered.members(t);
};
ve.notSameDeepOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notSameDeepOrderedMembers,
    !0
  ).to.not.have.same.deep.ordered.members(t);
};
ve.includeMembers = function(e, t, r) {
  new we(e, r, ve.includeMembers, !0).to.include.members(
    t
  );
};
ve.notIncludeMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notIncludeMembers,
    !0
  ).to.not.include.members(t);
};
ve.includeDeepMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.includeDeepMembers,
    !0
  ).to.include.deep.members(t);
};
ve.notIncludeDeepMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notIncludeDeepMembers,
    !0
  ).to.not.include.deep.members(t);
};
ve.includeOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.includeOrderedMembers,
    !0
  ).to.include.ordered.members(t);
};
ve.notIncludeOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notIncludeOrderedMembers,
    !0
  ).to.not.include.ordered.members(t);
};
ve.includeDeepOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.includeDeepOrderedMembers,
    !0
  ).to.include.deep.ordered.members(t);
};
ve.notIncludeDeepOrderedMembers = function(e, t, r) {
  new we(
    e,
    r,
    ve.notIncludeDeepOrderedMembers,
    !0
  ).to.not.include.deep.ordered.members(t);
};
ve.oneOf = function(e, t, r) {
  new we(e, r, ve.oneOf, !0).to.be.oneOf(t);
};
ve.isIterable = function(e, t) {
  if (e == null || !e[Symbol.iterator])
    throw t = t ? `${t} expected ${er(e)} to be an iterable` : `expected ${er(e)} to be an iterable`, new tr(t, void 0, ve.isIterable);
};
ve.changes = function(e, t, r, i) {
  arguments.length === 3 && typeof t == "function" && (i = r, r = null), new we(e, i, ve.changes, !0).to.change(t, r);
};
ve.changesBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  new we(e, n, ve.changesBy, !0).to.change(t, r).by(i);
};
ve.doesNotChange = function(e, t, r, i) {
  return arguments.length === 3 && typeof t == "function" && (i = r, r = null), new we(e, i, ve.doesNotChange, !0).to.not.change(
    t,
    r
  );
};
ve.changesButNotBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  new we(e, n, ve.changesButNotBy, !0).to.change(t, r).but.not.by(i);
};
ve.increases = function(e, t, r, i) {
  return arguments.length === 3 && typeof t == "function" && (i = r, r = null), new we(e, i, ve.increases, !0).to.increase(t, r);
};
ve.increasesBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  new we(e, n, ve.increasesBy, !0).to.increase(t, r).by(i);
};
ve.doesNotIncrease = function(e, t, r, i) {
  return arguments.length === 3 && typeof t == "function" && (i = r, r = null), new we(e, i, ve.doesNotIncrease, !0).to.not.increase(
    t,
    r
  );
};
ve.increasesButNotBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  new we(e, n, ve.increasesButNotBy, !0).to.increase(t, r).but.not.by(i);
};
ve.decreases = function(e, t, r, i) {
  return arguments.length === 3 && typeof t == "function" && (i = r, r = null), new we(e, i, ve.decreases, !0).to.decrease(t, r);
};
ve.decreasesBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  new we(e, n, ve.decreasesBy, !0).to.decrease(t, r).by(i);
};
ve.doesNotDecrease = function(e, t, r, i) {
  return arguments.length === 3 && typeof t == "function" && (i = r, r = null), new we(e, i, ve.doesNotDecrease, !0).to.not.decrease(
    t,
    r
  );
};
ve.doesNotDecreaseBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  return new we(e, n, ve.doesNotDecreaseBy, !0).to.not.decrease(t, r).by(i);
};
ve.decreasesButNotBy = function(e, t, r, i, n) {
  if (arguments.length === 4 && typeof t == "function") {
    let o = i;
    i = r, n = o;
  } else arguments.length === 3 && (i = r, r = null);
  new we(e, n, ve.decreasesButNotBy, !0).to.decrease(t, r).but.not.by(i);
};
ve.ifError = function(e) {
  if (e)
    throw e;
};
ve.isExtensible = function(e, t) {
  new we(e, t, ve.isExtensible, !0).to.be.extensible;
};
ve.isNotExtensible = function(e, t) {
  new we(e, t, ve.isNotExtensible, !0).to.not.be.extensible;
};
ve.isSealed = function(e, t) {
  new we(e, t, ve.isSealed, !0).to.be.sealed;
};
ve.isNotSealed = function(e, t) {
  new we(e, t, ve.isNotSealed, !0).to.not.be.sealed;
};
ve.isFrozen = function(e, t) {
  new we(e, t, ve.isFrozen, !0).to.be.frozen;
};
ve.isNotFrozen = function(e, t) {
  new we(e, t, ve.isNotFrozen, !0).to.not.be.frozen;
};
ve.isEmpty = function(e, t) {
  new we(e, t, ve.isEmpty, !0).to.be.empty;
};
ve.isNotEmpty = function(e, t) {
  new we(e, t, ve.isNotEmpty, !0).to.not.be.empty;
};
ve.containsSubset = function(e, t, r) {
  new we(e, r).to.containSubset(t);
};
ve.doesNotContainSubset = function(e, t, r) {
  new we(e, r).to.not.containSubset(t);
};
var M4 = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (const [e, t] of M4)
  ve[t] = ve[e];
var pv = [];
function _A(e) {
  const t = {
    use: _A,
    AssertionError: tr,
    util: eu,
    config: hn,
    expect: uu,
    assert: ve,
    Assertion: we,
    ...bA
  };
  return ~pv.indexOf(e) || (e(t, eu), pv.push(e)), t;
}
ze(_A, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var Ji = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Bi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _s = { exports: {} }, Cc, dv;
function F4() {
  if (dv) return Cc;
  dv = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, n = i * 7, o = i * 365.25;
  Cc = function(f, h) {
    h = h || {};
    var y = typeof f;
    if (y === "string" && f.length > 0)
      return s(f);
    if (y === "number" && isFinite(f))
      return h.long ? u(f) : a(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function s(f) {
    if (f = String(f), !(f.length > 100)) {
      var h = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (h) {
        var y = parseFloat(h[1]), p = (h[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return y * o;
          case "weeks":
          case "week":
          case "w":
            return y * n;
          case "days":
          case "day":
          case "d":
            return y * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return y * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return y * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return y * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return y;
          default:
            return;
        }
      }
    }
  }
  function a(f) {
    var h = Math.abs(f);
    return h >= i ? Math.round(f / i) + "d" : h >= r ? Math.round(f / r) + "h" : h >= t ? Math.round(f / t) + "m" : h >= e ? Math.round(f / e) + "s" : f + "ms";
  }
  function u(f) {
    var h = Math.abs(f);
    return h >= i ? c(f, h, i, "day") : h >= r ? c(f, h, r, "hour") : h >= t ? c(f, h, t, "minute") : h >= e ? c(f, h, e, "second") : f + " ms";
  }
  function c(f, h, y, p) {
    var l = h >= y * 1.5;
    return Math.round(f / y) + " " + p + (l ? "s" : "");
  }
  return Cc;
}
var Rc, mv;
function L4() {
  if (mv) return Rc;
  mv = 1;
  function e(t) {
    i.debug = i, i.default = i, i.coerce = c, i.disable = a, i.enable = o, i.enabled = u, i.humanize = F4(), i.destroy = f, Object.keys(t).forEach((h) => {
      i[h] = t[h];
    }), i.names = [], i.skips = [], i.formatters = {};
    function r(h) {
      let y = 0;
      for (let p = 0; p < h.length; p++)
        y = (y << 5) - y + h.charCodeAt(p), y |= 0;
      return i.colors[Math.abs(y) % i.colors.length];
    }
    i.selectColor = r;
    function i(h) {
      let y, p = null, l, d;
      function v(...m) {
        if (!v.enabled)
          return;
        const g = v, _ = Number(/* @__PURE__ */ new Date()), b = _ - (y || _);
        g.diff = b, g.prev = y, g.curr = _, y = _, m[0] = i.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
        let w = 0;
        m[0] = m[0].replace(/%([a-zA-Z%])/g, (E, O) => {
          if (E === "%%")
            return "%";
          w++;
          const $ = i.formatters[O];
          if (typeof $ == "function") {
            const k = m[w];
            E = $.call(g, k), m.splice(w, 1), w--;
          }
          return E;
        }), i.formatArgs.call(g, m), (g.log || i.log).apply(g, m);
      }
      return v.namespace = h, v.useColors = i.useColors(), v.color = i.selectColor(h), v.extend = n, v.destroy = i.destroy, Object.defineProperty(v, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (l !== i.namespaces && (l = i.namespaces, d = i.enabled(h)), d),
        set: (m) => {
          p = m;
        }
      }), typeof i.init == "function" && i.init(v), v;
    }
    function n(h, y) {
      const p = i(this.namespace + (typeof y > "u" ? ":" : y) + h);
      return p.log = this.log, p;
    }
    function o(h) {
      i.save(h), i.namespaces = h, i.names = [], i.skips = [];
      const y = (typeof h == "string" ? h : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const p of y)
        p[0] === "-" ? i.skips.push(p.slice(1)) : i.names.push(p);
    }
    function s(h, y) {
      let p = 0, l = 0, d = -1, v = 0;
      for (; p < h.length; )
        if (l < y.length && (y[l] === h[p] || y[l] === "*"))
          y[l] === "*" ? (d = l, v = p, l++) : (p++, l++);
        else if (d !== -1)
          l = d + 1, v++, p = v;
        else
          return !1;
      for (; l < y.length && y[l] === "*"; )
        l++;
      return l === y.length;
    }
    function a() {
      const h = [
        ...i.names,
        ...i.skips.map((y) => "-" + y)
      ].join(",");
      return i.enable(""), h;
    }
    function u(h) {
      for (const y of i.skips)
        if (s(h, y))
          return !1;
      for (const y of i.names)
        if (s(h, y))
          return !0;
      return !1;
    }
    function c(h) {
      return h instanceof Error ? h.stack || h.message : h;
    }
    function f() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return i.enable(i.load()), i;
  }
  return Rc = e, Rc;
}
var yv;
function B4() {
  return yv || (yv = 1, (function(e, t) {
    t.formatArgs = i, t.save = n, t.load = o, t.useColors = r, t.storage = s(), t.destroy = /* @__PURE__ */ (() => {
      let u = !1;
      return () => {
        u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let u;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function i(u) {
      if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      u.splice(1, 0, c, "color: inherit");
      let f = 0, h = 0;
      u[0].replace(/%[a-zA-Z%]/g, (y) => {
        y !== "%%" && (f++, y === "%c" && (h = f));
      }), u.splice(h, 0, c);
    }
    t.log = console.debug || console.log || (() => {
    });
    function n(u) {
      try {
        u ? t.storage.setItem("debug", u) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function o() {
      let u;
      try {
        u = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
      } catch {
      }
      return !u && typeof process < "u" && "env" in process && (u = void 0), u;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = L4()(t);
    const { formatters: a } = e.exports;
    a.j = function(u) {
      try {
        return JSON.stringify(u);
      } catch (c) {
        return "[UnexpectedJSONParseError]: " + c.message;
      }
    };
  })(_s, _s.exports)), _s.exports;
}
var q4 = B4();
const rq = /* @__PURE__ */ Bi(q4);
var wA = typeof global == "object" && global && global.Object === Object && global, Z4 = typeof self == "object" && self && self.Object === Object && self, Ko = wA || Z4 || Function("return this")(), Fo = Ko.Symbol, OA = Object.prototype, V4 = OA.hasOwnProperty, W4 = OA.toString, ua = Fo ? Fo.toStringTag : void 0;
function G4(e) {
  var t = V4.call(e, ua), r = e[ua];
  try {
    e[ua] = void 0;
    var i = !0;
  } catch {
  }
  var n = W4.call(e);
  return i && (t ? e[ua] = r : delete e[ua]), n;
}
var K4 = Object.prototype, H4 = K4.toString;
function J4(e) {
  return H4.call(e);
}
var Y4 = "[object Null]", X4 = "[object Undefined]", gv = Fo ? Fo.toStringTag : void 0;
function rs(e) {
  return e == null ? e === void 0 ? X4 : Y4 : gv && gv in Object(e) ? G4(e) : J4(e);
}
function Ho(e) {
  return e != null && typeof e == "object";
}
var Q4 = "[object Symbol]";
function Iy(e) {
  return typeof e == "symbol" || Ho(e) && rs(e) == Q4;
}
function e3(e, t) {
  for (var r = -1, i = e == null ? 0 : e.length, n = Array(i); ++r < i; )
    n[r] = t(e[r], r, e);
  return n;
}
var Lo = Array.isArray, vv = Fo ? Fo.prototype : void 0, bv = vv ? vv.toString : void 0;
function $A(e) {
  if (typeof e == "string")
    return e;
  if (Lo(e))
    return e3(e, $A) + "";
  if (Iy(e))
    return bv ? bv.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function yo(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function SA(e) {
  return e;
}
var t3 = "[object AsyncFunction]", r3 = "[object Function]", n3 = "[object GeneratorFunction]", i3 = "[object Proxy]";
function Ty(e) {
  if (!yo(e))
    return !1;
  var t = rs(e);
  return t == r3 || t == n3 || t == t3 || t == i3;
}
var Dc = Ko["__core-js_shared__"], _v = (function() {
  var e = /[^.]+$/.exec(Dc && Dc.keys && Dc.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function o3(e) {
  return !!_v && _v in e;
}
var a3 = Function.prototype, s3 = a3.toString;
function u3(e) {
  if (e != null) {
    try {
      return s3.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var c3 = /[\\^$.*+?()[\]{}|]/g, l3 = /^\[object .+?Constructor\]$/, f3 = Function.prototype, h3 = Object.prototype, p3 = f3.toString, d3 = h3.hasOwnProperty, m3 = RegExp(
  "^" + p3.call(d3).replace(c3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function y3(e) {
  if (!yo(e) || o3(e))
    return !1;
  var t = Ty(e) ? m3 : l3;
  return t.test(u3(e));
}
function g3(e, t) {
  return e?.[t];
}
function Ny(e, t) {
  var r = g3(e, t);
  return y3(r) ? r : void 0;
}
var wv = Object.create, v3 = /* @__PURE__ */ (function() {
  function e() {
  }
  return function(t) {
    if (!yo(t))
      return {};
    if (wv)
      return wv(t);
    e.prototype = t;
    var r = new e();
    return e.prototype = void 0, r;
  };
})();
function b3(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
function _3(e, t) {
  var r = -1, i = e.length;
  for (t || (t = Array(i)); ++r < i; )
    t[r] = e[r];
  return t;
}
var w3 = 800, O3 = 16, $3 = Date.now;
function S3(e) {
  var t = 0, r = 0;
  return function() {
    var i = $3(), n = O3 - (i - r);
    if (r = i, n > 0) {
      if (++t >= w3)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function E3(e) {
  return function() {
    return e;
  };
}
var cu = (function() {
  try {
    var e = Ny(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
})(), x3 = cu ? function(e, t) {
  return cu(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: E3(t),
    writable: !0
  });
} : SA, A3 = S3(x3), j3 = 9007199254740991, k3 = /^(?:0|[1-9]\d*)$/;
function EA(e, t) {
  var r = typeof e;
  return t = t ?? j3, !!t && (r == "number" || r != "symbol" && k3.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Cy(e, t, r) {
  t == "__proto__" && cu ? cu(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
function Ju(e, t) {
  return e === t || e !== e && t !== t;
}
var P3 = Object.prototype, I3 = P3.hasOwnProperty;
function T3(e, t, r) {
  var i = e[t];
  (!(I3.call(e, t) && Ju(i, r)) || r === void 0 && !(t in e)) && Cy(e, t, r);
}
function N3(e, t, r, i) {
  var n = !r;
  r || (r = {});
  for (var o = -1, s = t.length; ++o < s; ) {
    var a = t[o], u = void 0;
    u === void 0 && (u = e[a]), n ? Cy(r, a, u) : T3(r, a, u);
  }
  return r;
}
var Ov = Math.max;
function C3(e, t, r) {
  return t = Ov(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var i = arguments, n = -1, o = Ov(i.length - t, 0), s = Array(o); ++n < o; )
      s[n] = i[t + n];
    n = -1;
    for (var a = Array(t + 1); ++n < t; )
      a[n] = i[n];
    return a[t] = r(s), b3(e, this, a);
  };
}
function R3(e, t) {
  return A3(C3(e, t, SA), e + "");
}
var D3 = 9007199254740991;
function xA(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= D3;
}
function Ry(e) {
  return e != null && xA(e.length) && !Ty(e);
}
function z3(e, t, r) {
  if (!yo(r))
    return !1;
  var i = typeof t;
  return (i == "number" ? Ry(r) && EA(t, r.length) : i == "string" && t in r) ? Ju(r[t], e) : !1;
}
function U3(e) {
  return R3(function(t, r) {
    var i = -1, n = r.length, o = n > 1 ? r[n - 1] : void 0, s = n > 2 ? r[2] : void 0;
    for (o = e.length > 3 && typeof o == "function" ? (n--, o) : void 0, s && z3(r[0], r[1], s) && (o = n < 3 ? void 0 : o, n = 1), t = Object(t); ++i < n; ) {
      var a = r[i];
      a && e(t, a, i, o);
    }
    return t;
  });
}
var M3 = Object.prototype;
function AA(e) {
  var t = e && e.constructor, r = typeof t == "function" && t.prototype || M3;
  return e === r;
}
function F3(e, t) {
  for (var r = -1, i = Array(e); ++r < e; )
    i[r] = t(r);
  return i;
}
var L3 = "[object Arguments]";
function $v(e) {
  return Ho(e) && rs(e) == L3;
}
var jA = Object.prototype, B3 = jA.hasOwnProperty, q3 = jA.propertyIsEnumerable, vp = $v(/* @__PURE__ */ (function() {
  return arguments;
})()) ? $v : function(e) {
  return Ho(e) && B3.call(e, "callee") && !q3.call(e, "callee");
};
function Z3() {
  return !1;
}
var kA = typeof exports == "object" && exports && !exports.nodeType && exports, Sv = kA && typeof module == "object" && module && !module.nodeType && module, V3 = Sv && Sv.exports === kA, Ev = V3 ? Ko.Buffer : void 0, W3 = Ev ? Ev.isBuffer : void 0, PA = W3 || Z3, G3 = "[object Arguments]", K3 = "[object Array]", H3 = "[object Boolean]", J3 = "[object Date]", Y3 = "[object Error]", X3 = "[object Function]", Q3 = "[object Map]", eC = "[object Number]", tC = "[object Object]", rC = "[object RegExp]", nC = "[object Set]", iC = "[object String]", oC = "[object WeakMap]", aC = "[object ArrayBuffer]", sC = "[object DataView]", uC = "[object Float32Array]", cC = "[object Float64Array]", lC = "[object Int8Array]", fC = "[object Int16Array]", hC = "[object Int32Array]", pC = "[object Uint8Array]", dC = "[object Uint8ClampedArray]", mC = "[object Uint16Array]", yC = "[object Uint32Array]", gr = {};
gr[uC] = gr[cC] = gr[lC] = gr[fC] = gr[hC] = gr[pC] = gr[dC] = gr[mC] = gr[yC] = !0;
gr[G3] = gr[K3] = gr[aC] = gr[H3] = gr[sC] = gr[J3] = gr[Y3] = gr[X3] = gr[Q3] = gr[eC] = gr[tC] = gr[rC] = gr[nC] = gr[iC] = gr[oC] = !1;
function gC(e) {
  return Ho(e) && xA(e.length) && !!gr[rs(e)];
}
function vC(e) {
  return function(t) {
    return e(t);
  };
}
var IA = typeof exports == "object" && exports && !exports.nodeType && exports, xa = IA && typeof module == "object" && module && !module.nodeType && module, bC = xa && xa.exports === IA, zc = bC && wA.process, xv = (function() {
  try {
    var e = xa && xa.require && xa.require("util").types;
    return e || zc && zc.binding && zc.binding("util");
  } catch {
  }
})(), Av = xv && xv.isTypedArray, TA = Av ? vC(Av) : gC;
function _C(e, t) {
  var r = Lo(e), i = !r && vp(e), n = !r && !i && PA(e), o = !r && !i && !n && TA(e), s = r || i || n || o, a = s ? F3(e.length, String) : [], u = a.length;
  for (var c in e)
    s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    n && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    EA(c, u)) || a.push(c);
  return a;
}
function wC(e, t) {
  return function(r) {
    return e(t(r));
  };
}
function OC(e) {
  var t = [];
  if (e != null)
    for (var r in Object(e))
      t.push(r);
  return t;
}
var $C = Object.prototype, SC = $C.hasOwnProperty;
function EC(e) {
  if (!yo(e))
    return OC(e);
  var t = AA(e), r = [];
  for (var i in e)
    i == "constructor" && (t || !SC.call(e, i)) || r.push(i);
  return r;
}
function NA(e) {
  return Ry(e) ? _C(e) : EC(e);
}
var xC = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, AC = /^\w*$/;
function jC(e, t) {
  if (Lo(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || Iy(e) ? !0 : AC.test(e) || !xC.test(e) || t != null && e in Object(t);
}
var Ca = Ny(Object, "create");
function kC() {
  this.__data__ = Ca ? Ca(null) : {}, this.size = 0;
}
function PC(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var IC = "__lodash_hash_undefined__", TC = Object.prototype, NC = TC.hasOwnProperty;
function CC(e) {
  var t = this.__data__;
  if (Ca) {
    var r = t[e];
    return r === IC ? void 0 : r;
  }
  return NC.call(t, e) ? t[e] : void 0;
}
var RC = Object.prototype, DC = RC.hasOwnProperty;
function zC(e) {
  var t = this.__data__;
  return Ca ? t[e] !== void 0 : DC.call(t, e);
}
var UC = "__lodash_hash_undefined__";
function MC(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = Ca && t === void 0 ? UC : t, this;
}
function ao(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
ao.prototype.clear = kC;
ao.prototype.delete = PC;
ao.prototype.get = CC;
ao.prototype.has = zC;
ao.prototype.set = MC;
function FC() {
  this.__data__ = [], this.size = 0;
}
function Yu(e, t) {
  for (var r = e.length; r--; )
    if (Ju(e[r][0], t))
      return r;
  return -1;
}
var LC = Array.prototype, BC = LC.splice;
function qC(e) {
  var t = this.__data__, r = Yu(t, e);
  if (r < 0)
    return !1;
  var i = t.length - 1;
  return r == i ? t.pop() : BC.call(t, r, 1), --this.size, !0;
}
function ZC(e) {
  var t = this.__data__, r = Yu(t, e);
  return r < 0 ? void 0 : t[r][1];
}
function VC(e) {
  return Yu(this.__data__, e) > -1;
}
function WC(e, t) {
  var r = this.__data__, i = Yu(r, e);
  return i < 0 ? (++this.size, r.push([e, t])) : r[i][1] = t, this;
}
function Oi(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
Oi.prototype.clear = FC;
Oi.prototype.delete = qC;
Oi.prototype.get = ZC;
Oi.prototype.has = VC;
Oi.prototype.set = WC;
var CA = Ny(Ko, "Map");
function GC() {
  this.size = 0, this.__data__ = {
    hash: new ao(),
    map: new (CA || Oi)(),
    string: new ao()
  };
}
function KC(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Xu(e, t) {
  var r = e.__data__;
  return KC(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function HC(e) {
  var t = Xu(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function JC(e) {
  return Xu(this, e).get(e);
}
function YC(e) {
  return Xu(this, e).has(e);
}
function XC(e, t) {
  var r = Xu(this, e), i = r.size;
  return r.set(e, t), this.size += r.size == i ? 0 : 1, this;
}
function qi(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var i = e[t];
    this.set(i[0], i[1]);
  }
}
qi.prototype.clear = GC;
qi.prototype.delete = HC;
qi.prototype.get = JC;
qi.prototype.has = YC;
qi.prototype.set = XC;
var QC = "Expected a function";
function Dy(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(QC);
  var r = function() {
    var i = arguments, n = t ? t.apply(this, i) : i[0], o = r.cache;
    if (o.has(n))
      return o.get(n);
    var s = e.apply(this, i);
    return r.cache = o.set(n, s) || o, s;
  };
  return r.cache = new (Dy.Cache || qi)(), r;
}
Dy.Cache = qi;
var eR = 500;
function tR(e) {
  var t = Dy(e, function(i) {
    return r.size === eR && r.clear(), i;
  }), r = t.cache;
  return t;
}
var rR = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, nR = /\\(\\)?/g, iR = tR(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(rR, function(r, i, n, o) {
    t.push(n ? o.replace(nR, "$1") : i || r);
  }), t;
});
function oR(e) {
  return e == null ? "" : $A(e);
}
function aR(e, t) {
  return Lo(e) ? e : jC(e, t) ? [e] : iR(oR(e));
}
function sR(e) {
  if (typeof e == "string" || Iy(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function uR(e, t) {
  t = aR(t, e);
  for (var r = 0, i = t.length; e != null && r < i; )
    e = e[sR(t[r++])];
  return r && r == i ? e : void 0;
}
function nq(e, t, r) {
  var i = e == null ? void 0 : uR(e, t);
  return i === void 0 ? r : i;
}
var RA = wC(Object.getPrototypeOf, Object), cR = "[object Object]", lR = Function.prototype, fR = Object.prototype, DA = lR.toString, hR = fR.hasOwnProperty, pR = DA.call(Object);
function dR(e) {
  if (!Ho(e) || rs(e) != cR)
    return !1;
  var t = RA(e);
  if (t === null)
    return !0;
  var r = hR.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r instanceof r && DA.call(r) == pR;
}
function mR() {
  this.__data__ = new Oi(), this.size = 0;
}
function yR(e) {
  var t = this.__data__, r = t.delete(e);
  return this.size = t.size, r;
}
function gR(e) {
  return this.__data__.get(e);
}
function vR(e) {
  return this.__data__.has(e);
}
var bR = 200;
function _R(e, t) {
  var r = this.__data__;
  if (r instanceof Oi) {
    var i = r.__data__;
    if (!CA || i.length < bR - 1)
      return i.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new qi(i);
  }
  return r.set(e, t), this.size = r.size, this;
}
function Jo(e) {
  var t = this.__data__ = new Oi(e);
  this.size = t.size;
}
Jo.prototype.clear = mR;
Jo.prototype.delete = yR;
Jo.prototype.get = gR;
Jo.prototype.has = vR;
Jo.prototype.set = _R;
var zA = typeof exports == "object" && exports && !exports.nodeType && exports, jv = zA && typeof module == "object" && module && !module.nodeType && module, wR = jv && jv.exports === zA, kv = wR ? Ko.Buffer : void 0;
kv && kv.allocUnsafe;
function OR(e, t) {
  return e.slice();
}
var Pv = Ko.Uint8Array;
function $R(e) {
  var t = new e.constructor(e.byteLength);
  return new Pv(t).set(new Pv(e)), t;
}
function SR(e, t) {
  var r = $R(e.buffer);
  return new e.constructor(r, e.byteOffset, e.length);
}
function ER(e) {
  return typeof e.constructor == "function" && !AA(e) ? v3(RA(e)) : {};
}
function xR(e) {
  return function(t, r, i) {
    for (var n = -1, o = Object(t), s = i(t), a = s.length; a--; ) {
      var u = s[++n];
      if (r(o[u], u, o) === !1)
        break;
    }
    return t;
  };
}
var AR = xR();
function bp(e, t, r) {
  (r !== void 0 && !Ju(e[t], r) || r === void 0 && !(t in e)) && Cy(e, t, r);
}
function jR(e) {
  return Ho(e) && Ry(e);
}
function _p(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function kR(e) {
  return N3(e, NA(e));
}
function PR(e, t, r, i, n, o, s) {
  var a = _p(e, r), u = _p(t, r), c = s.get(u);
  if (c) {
    bp(e, r, c);
    return;
  }
  var f = o ? o(a, u, r + "", e, t, s) : void 0, h = f === void 0;
  if (h) {
    var y = Lo(u), p = !y && PA(u), l = !y && !p && TA(u);
    f = u, y || p || l ? Lo(a) ? f = a : jR(a) ? f = _3(a) : p ? (h = !1, f = OR(u)) : l ? (h = !1, f = SR(u)) : f = [] : dR(u) || vp(u) ? (f = a, vp(a) ? f = kR(a) : (!yo(a) || Ty(a)) && (f = ER(u))) : h = !1;
  }
  h && (s.set(u, f), n(f, u, i, o, s), s.delete(u)), bp(e, r, f);
}
function UA(e, t, r, i, n) {
  e !== t && AR(t, function(o, s) {
    if (n || (n = new Jo()), yo(o))
      PR(e, t, s, r, UA, i, n);
    else {
      var a = i ? i(_p(e, s), o, s + "", e, t, n) : void 0;
      a === void 0 && (a = o), bp(e, s, a);
    }
  }, NA);
}
var iq = U3(function(e, t, r) {
  UA(e, t, r);
}), ws = { exports: {} }, Uc, Iv;
function IR() {
  if (Iv) return Uc;
  Iv = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, n = i * 7, o = i * 365.25;
  Uc = function(f, h) {
    h = h || {};
    var y = typeof f;
    if (y === "string" && f.length > 0)
      return s(f);
    if (y === "number" && isFinite(f))
      return h.long ? u(f) : a(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(f)
    );
  };
  function s(f) {
    if (f = String(f), !(f.length > 100)) {
      var h = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        f
      );
      if (h) {
        var y = parseFloat(h[1]), p = (h[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return y * o;
          case "weeks":
          case "week":
          case "w":
            return y * n;
          case "days":
          case "day":
          case "d":
            return y * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return y * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return y * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return y * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return y;
          default:
            return;
        }
      }
    }
  }
  function a(f) {
    var h = Math.abs(f);
    return h >= i ? Math.round(f / i) + "d" : h >= r ? Math.round(f / r) + "h" : h >= t ? Math.round(f / t) + "m" : h >= e ? Math.round(f / e) + "s" : f + "ms";
  }
  function u(f) {
    var h = Math.abs(f);
    return h >= i ? c(f, h, i, "day") : h >= r ? c(f, h, r, "hour") : h >= t ? c(f, h, t, "minute") : h >= e ? c(f, h, e, "second") : f + " ms";
  }
  function c(f, h, y, p) {
    var l = h >= y * 1.5;
    return Math.round(f / y) + " " + p + (l ? "s" : "");
  }
  return Uc;
}
var Mc, Tv;
function TR() {
  if (Tv) return Mc;
  Tv = 1;
  function e(t) {
    i.debug = i, i.default = i, i.coerce = c, i.disable = a, i.enable = o, i.enabled = u, i.humanize = IR(), i.destroy = f, Object.keys(t).forEach((h) => {
      i[h] = t[h];
    }), i.names = [], i.skips = [], i.formatters = {};
    function r(h) {
      let y = 0;
      for (let p = 0; p < h.length; p++)
        y = (y << 5) - y + h.charCodeAt(p), y |= 0;
      return i.colors[Math.abs(y) % i.colors.length];
    }
    i.selectColor = r;
    function i(h) {
      let y, p = null, l, d;
      function v(...m) {
        if (!v.enabled)
          return;
        const g = v, _ = Number(/* @__PURE__ */ new Date()), b = _ - (y || _);
        g.diff = b, g.prev = y, g.curr = _, y = _, m[0] = i.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
        let w = 0;
        m[0] = m[0].replace(/%([a-zA-Z%])/g, (E, O) => {
          if (E === "%%")
            return "%";
          w++;
          const $ = i.formatters[O];
          if (typeof $ == "function") {
            const k = m[w];
            E = $.call(g, k), m.splice(w, 1), w--;
          }
          return E;
        }), i.formatArgs.call(g, m), (g.log || i.log).apply(g, m);
      }
      return v.namespace = h, v.useColors = i.useColors(), v.color = i.selectColor(h), v.extend = n, v.destroy = i.destroy, Object.defineProperty(v, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (l !== i.namespaces && (l = i.namespaces, d = i.enabled(h)), d),
        set: (m) => {
          p = m;
        }
      }), typeof i.init == "function" && i.init(v), v;
    }
    function n(h, y) {
      const p = i(this.namespace + (typeof y > "u" ? ":" : y) + h);
      return p.log = this.log, p;
    }
    function o(h) {
      i.save(h), i.namespaces = h, i.names = [], i.skips = [];
      const y = (typeof h == "string" ? h : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const p of y)
        p[0] === "-" ? i.skips.push(p.slice(1)) : i.names.push(p);
    }
    function s(h, y) {
      let p = 0, l = 0, d = -1, v = 0;
      for (; p < h.length; )
        if (l < y.length && (y[l] === h[p] || y[l] === "*"))
          y[l] === "*" ? (d = l, v = p, l++) : (p++, l++);
        else if (d !== -1)
          l = d + 1, v++, p = v;
        else
          return !1;
      for (; l < y.length && y[l] === "*"; )
        l++;
      return l === y.length;
    }
    function a() {
      const h = [
        ...i.names,
        ...i.skips.map((y) => "-" + y)
      ].join(",");
      return i.enable(""), h;
    }
    function u(h) {
      for (const y of i.skips)
        if (s(h, y))
          return !1;
      for (const y of i.names)
        if (s(h, y))
          return !0;
      return !1;
    }
    function c(h) {
      return h instanceof Error ? h.stack || h.message : h;
    }
    function f() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return i.enable(i.load()), i;
  }
  return Mc = e, Mc;
}
var Nv;
function NR() {
  return Nv || (Nv = 1, (function(e, t) {
    t.formatArgs = i, t.save = n, t.load = o, t.useColors = r, t.storage = s(), t.destroy = /* @__PURE__ */ (() => {
      let u = !1;
      return () => {
        u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let u;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function i(u) {
      if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      u.splice(1, 0, c, "color: inherit");
      let f = 0, h = 0;
      u[0].replace(/%[a-zA-Z%]/g, (y) => {
        y !== "%%" && (f++, y === "%c" && (h = f));
      }), u.splice(h, 0, c);
    }
    t.log = console.debug || console.log || (() => {
    });
    function n(u) {
      try {
        u ? t.storage.setItem("debug", u) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function o() {
      let u;
      try {
        u = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
      } catch {
      }
      return !u && typeof process < "u" && "env" in process && (u = void 0), u;
    }
    function s() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = TR()(t);
    const { formatters: a } = e.exports;
    a.j = function(u) {
      try {
        return JSON.stringify(u);
      } catch (c) {
        return "[UnexpectedJSONParseError]: " + c.message;
      }
    };
  })(ws, ws.exports)), ws.exports;
}
var CR = NR();
const oq = /* @__PURE__ */ Bi(CR);
var Rs = { exports: {} };
/*! For license information please see browser.umd.js.LICENSE.txt */
var RR = Rs.exports, Cv;
function DR() {
  return Cv || (Cv = 1, (function(e, t) {
    (function(r, i) {
      e.exports = i();
    })(typeof self < "u" ? self : RR, () => (() => {
      var r = { 118: (o) => {
        o.exports = function(s) {
          return s != s;
        };
      }, 170: (o, s, a) => {
        function u(k) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(j) {
            return typeof j;
          } : function(j) {
            return j && typeof Symbol == "function" && j.constructor === Symbol && j !== Symbol.prototype ? "symbol" : typeof j;
          }, u(k);
        }
        var c = a(3609), f = a(8995), h = a(7768), y = a(7236), p = /* @__PURE__ */ new Set(["$and", "$or"]), l = /* @__PURE__ */ new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]), d = /* @__PURE__ */ new Set(["$multiply", "$divide", "$log", "$mod", "$trunc", "$avg", "$max", "$min", "$stdDevPop", "$stdDevSamp", "$sum"]), v = /* @__PURE__ */ new Set(["$abs", "$exp", "$ceil", "$floor", "$ln", "$log10", "$sqrt", "$sin", "$cos", "$tan", "$asin", "$acos", "$atan", "$atan2", "$asinh", "$acosh", "$atanh", "$sinh", "$cosh", "$tanh", "$degreesToRadians", "$radiansToDegrees"]), m = /* @__PURE__ */ new Set(["$arrayElemAt", "$first", "$last"]), g = /* @__PURE__ */ new Set(["$year", "$month", "$week", "$dayOfMonth", "$dayOfYear", "$hour", "$minute", "$second", "$isoDayOfWeek", "$isoWeekYear", "$isoWeek", "$millisecond"]), _ = /* @__PURE__ */ new Set(["$not"]);
        function b(k, j, P) {
          if (O(k) || k === null) return k;
          k.$cond != null ? Array.isArray(k.$cond) ? k.$cond = k.$cond.map(function(F) {
            return b(F, j, P);
          }) : (k.$cond.if = b(k.$cond.if, j, P), k.$cond.then = b(k.$cond.then, j, P), k.$cond.else = b(k.$cond.else, j, P)) : k.$ifNull != null ? k.$ifNull.map(function(F) {
            return b(F, j, P);
          }) : k.$switch != null && (Array.isArray(k.$switch.branches) && (k.$switch.branches = k.$switch.branches.map(function(F) {
            return b(F, j, P);
          })), "default" in k.$switch && (k.$switch.default = b(k.$switch.default, j, P)));
          for (var R = 0, I = Object.keys(k); R < I.length; R++) {
            var z = I[R];
            p.has(z) ? k[z] = k[z].map(function(F) {
              return b(F, j, P);
            }) : l.has(z) ? k[z] = E(k[z], j, P) : d.has(z) ? k[z] = A(k[z]) : v.has(z) ? k[z] = w(k[z]) : _.has(z) && (k[z] = b(k[z], j, P));
          }
          if (k.$in && (k.$in = (function(F, te, ee) {
            var V = F[1];
            if (!O(V)) return F;
            var T = F[0], D = te.path(V.slice(1));
            if (D !== null) {
              if (!D.$isMongooseArray) throw new Error("Path must be an array for $in");
              return [D.$isMongooseDocumentArray ? D.$embeddedSchemaType.cast(T) : D.caster.cast(T), V];
            }
            if (ee === !1) return F;
            if (ee === "throw") throw new f("$in");
          })(k.$in, j, P)), k.$size && (k.$size = w(k.$size)), k.$round) {
            var W = k.$round;
            if (!Array.isArray(W) || W.length < 1 || W.length > 2) throw new c("Array", W, "$round");
            k.$round = W.map(function(F) {
              return w(F);
            });
          }
          return y(k), k;
        }
        function w(k) {
          if (!$(k)) return k;
          try {
            return h(k);
          } catch {
            throw new c("Number", k);
          }
        }
        function A(k) {
          if (!Array.isArray(k)) {
            if (!$(k)) return k;
            try {
              return h(k);
            } catch {
              throw new c("Number", k);
            }
          }
          return k.map(function(j) {
            if (!$(j)) return j;
            try {
              return h(j);
            } catch {
              throw new c("Number", j);
            }
          });
        }
        function E(k, j, P) {
          if (!Array.isArray(k) || k.length !== 2) throw new Error("Comparison operator must be an array of length 2");
          k[0] = b(k[0], j, P);
          var R = k[0];
          if ($(k[1])) {
            var I = null, z = null, W = null;
            if (O(R)) I = R.slice(1), z = j.path(I);
            else if (u(R) === "object" && R != null) for (var F = 0, te = Object.keys(R); F < te.length; F++) {
              var ee = te[F];
              g.has(ee) && O(R[ee]) ? (I = R[ee].slice(1) + "." + ee, W = h) : m.has(ee) && O(R[ee]) && (I = R[ee].slice(1) + "." + ee, (z = j.path(R[ee].slice(1))) != null && (z.$isMongooseDocumentArray ? z = z.$embeddedSchemaType : z.$isMongooseArray && (z = z.caster)));
            }
            var V = u(k[1]) === "object" && k[1] != null && k[1].$literal != null;
            if (z != null) k[1] = V ? { $literal: z.cast(k[1].$literal) } : z.cast(k[1]);
            else if (W != null) if (V) try {
              k[1] = { $literal: W(k[1].$literal) };
            } catch {
              throw new c(W.name.replace(/^cast/, ""), k[1], I + ".$literal");
            }
            else try {
              k[1] = W(k[1]);
            } catch {
              throw new c(W.name.replace(/^cast/, ""), k[1], I);
            }
            else {
              if (I != null && P === !0) return;
              if (I != null && P === "throw") throw new f(I);
            }
          } else k[1] = b(k[1]);
          return k;
        }
        function O(k) {
          return typeof k == "string" && k[0] === "$";
        }
        function $(k) {
          return !(typeof k == "string" && k[0] === "$" || u(k) === "object" && k !== null && Object.keys(k).find(function(j) {
            return j[0] === "$";
          }) && k.$literal == null);
        }
        o.exports = function(k, j, P) {
          if (typeof k == "boolean") return k;
          if (u(k) !== "object" || k === null) throw new Error("`$expr` must be an object or boolean literal");
          return b(k, j, P);
        };
      }, 209: (o, s, a) => {
        function u(y) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
            return typeof p;
          } : function(p) {
            return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
          }, u(y);
        }
        var c = a(2403), f = a(5825), h = a(6583);
        o.exports = c ? function(y) {
          return c(y);
        } : f ? function(y) {
          if (!y || u(y) !== "object" && typeof y != "function") throw new TypeError("getProto: not an object");
          return f(y);
        } : h ? function(y) {
          return h(y);
        } : null;
      }, 241: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "of", p), o.exports = y;
      }, 354: (o) => {
        function s(p) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, s(p);
        }
        var a = 1e3, u = 60 * a, c = 60 * u, f = 24 * c, h = 7 * f;
        function y(p, l, d, v) {
          var m = l >= 1.5 * d;
          return Math.round(p / d) + " " + v + (m ? "s" : "");
        }
        o.exports = function(p, l) {
          l = l || {};
          var d, v, m = s(p);
          if (m === "string" && p.length > 0) return (function(g) {
            if (!((g = String(g)).length > 100)) {
              var _ = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(g);
              if (_) {
                var b = parseFloat(_[1]);
                switch ((_[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * b;
                  case "weeks":
                  case "week":
                  case "w":
                    return b * h;
                  case "days":
                  case "day":
                  case "d":
                    return b * f;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return b * c;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return b * u;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return b * a;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return b;
                  default:
                    return;
                }
              }
            }
          })(p);
          if (m === "number" && isFinite(p)) return l.long ? (d = p, (v = Math.abs(d)) >= f ? y(d, v, f, "day") : v >= c ? y(d, v, c, "hour") : v >= u ? y(d, v, u, "minute") : v >= a ? y(d, v, a, "second") : d + " ms") : (function(g) {
            var _ = Math.abs(g);
            return _ >= f ? Math.round(g / f) + "d" : _ >= c ? Math.round(g / c) + "h" : _ >= u ? Math.round(g / u) + "m" : _ >= a ? Math.round(g / a) + "s" : g + "ms";
          })(p);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(p));
        };
      }, 433: (o, s, a) => {
        function u(b) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
            return typeof w;
          } : function(w) {
            return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
          }, u(b);
        }
        function c(b, w) {
          var A = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var E = Object.getOwnPropertySymbols(b);
            w && (E = E.filter(function(O) {
              return Object.getOwnPropertyDescriptor(b, O).enumerable;
            })), A.push.apply(A, E);
          }
          return A;
        }
        function f(b) {
          for (var w = 1; w < arguments.length; w++) {
            var A = arguments[w] != null ? arguments[w] : {};
            w % 2 ? c(Object(A), !0).forEach(function(E) {
              h(b, E, A[E]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(A)) : c(Object(A)).forEach(function(E) {
              Object.defineProperty(b, E, Object.getOwnPropertyDescriptor(A, E));
            });
          }
          return b;
        }
        function h(b, w, A) {
          return (w = (function(E) {
            var O = (function($) {
              if (u($) != "object" || !$) return $;
              var k = $[Symbol.toPrimitive];
              if (k !== void 0) {
                var j = k.call($, "string");
                if (u(j) != "object") return j;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String($);
            })(E);
            return u(O) == "symbol" ? O : O + "";
          })(w)) in b ? Object.defineProperty(b, w, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : b[w] = A, b;
        }
        var y = a(3609), p = a(6426), l = a(5413), d = a(4327), v = a(9460);
        function m(b, w) {
          p.call(this, b, w, "Int32");
        }
        m.schemaName = "Int32", m.defaultOptions = {}, m.prototype = Object.create(p.prototype), m.prototype.constructor = m, m._cast = l, m.set = p.set, m.setters = [], m.get = p.get, m._defaultCaster = function(b) {
          if (b != null && (typeof b != "number" || b !== (0 | b) || b < -2147483648 || b > 2147483647)) throw new Error();
          return b;
        }, m.cast = function(b) {
          return arguments.length === 0 || (b === !1 && (b = this._defaultCaster), this._cast = b), this._cast;
        }, m._checkRequired = function(b) {
          return b != null;
        }, m.checkRequired = p.checkRequired, m.prototype.checkRequired = function(b) {
          return this.constructor._checkRequired(b);
        }, m.prototype.cast = function(b) {
          var w;
          w = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : m.cast();
          try {
            return w(b);
          } catch (A) {
            throw new y("Int32", b, this.path, A, this);
          }
        };
        var g = f(f({}, p.prototype.$conditionalHandlers), {}, { $gt: _, $gte: _, $lt: _, $lte: _, $bitsAllClear: v, $bitsAnyClear: v, $bitsAllSet: v, $bitsAnySet: v });
        function _(b, w) {
          return this.castForQuery(null, b, w);
        }
        Object.defineProperty(m.prototype, "$conditionalHandlers", { enumerable: !1, value: g }), m.prototype.castForQuery = function(b, w, A) {
          var E;
          if (b != null) return (E = this.$conditionalHandlers[b]) ? E.call(this, w) : this.applySetters(w, A);
          try {
            return this.applySetters(w, A);
          } catch (O) {
            throw O instanceof y && O.path === this.path && this.$fullPath != null && (O.path = this.$fullPath), O;
          }
        }, m.prototype.toJSONSchema = function(b) {
          var w = this.options.required && typeof this.options.required != "function";
          return d("number", "int", b?.useBsonType, w);
        }, m.prototype.autoEncryptionType = function() {
          return "int";
        }, o.exports = m;
      }, 486: (o) => {
        o.exports = function(s) {
          var a = { _id: { auto: !0 } };
          a._id[s.options.typeKey] = "ObjectId", s.add(a);
        };
      }, 533: (o, s, a) => {
        var u = a(8213), c = a(7352);
        o.exports = function(f, h) {
          if (typeof f != "string" && typeof f != "function") throw new u('Invalid ref at path "' + h + '". Got ' + c.inspect(f, { depth: 0 }));
        };
      }, 542: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          return !!a && (s(a) === "object" || typeof a == "function") && typeof a.then == "function";
        };
      }, 608: (o, s, a) => {
        var u = a(5832).hp;
        o.exports = function(c) {
          return u.isBuffer(c) || Object.prototype.toString.call(c) === "[object Object]";
        };
      }, 622: (o, s, a) => {
        function u(l, d) {
          var v = typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
          if (!v) {
            if (Array.isArray(l) || (v = (function(A, E) {
              if (A) {
                if (typeof A == "string") return c(A, E);
                var O = {}.toString.call(A).slice(8, -1);
                return O === "Object" && A.constructor && (O = A.constructor.name), O === "Map" || O === "Set" ? Array.from(A) : O === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(O) ? c(A, E) : void 0;
              }
            })(l)) || d) {
              v && (l = v);
              var m = 0, g = function() {
              };
              return { s: g, n: function() {
                return m >= l.length ? { done: !0 } : { done: !1, value: l[m++] };
              }, e: function(A) {
                throw A;
              }, f: g };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var _, b = !0, w = !1;
          return { s: function() {
            v = v.call(l);
          }, n: function() {
            var A = v.next();
            return b = A.done, A;
          }, e: function(A) {
            w = !0, _ = A;
          }, f: function() {
            try {
              b || v.return == null || v.return();
            } finally {
              if (w) throw _;
            }
          } };
        }
        function c(l, d) {
          (d == null || d > l.length) && (d = l.length);
          for (var v = 0, m = Array(d); v < d; v++) m[v] = l[v];
          return m;
        }
        var f = a(4009), h = a(8768), y = a(7930).modelSymbol;
        function p(l, d) {
          this.path = d, this.getters = [], this.setters = [], this.options = Object.assign({}, l);
        }
        p.prototype._applyDefaultGetters = function() {
          if (!(this.getters.length > 0 || this.setters.length > 0)) {
            var l = "$" + this.path;
            this.getters.push(function() {
              return this.$locals[l];
            }), this.setters.push(function(d) {
              this.$locals[l] = d;
            });
          }
        }, p.prototype.clone = function() {
          var l = new p(this.options, this.path);
          return l.getters = [].concat(this.getters), l.setters = [].concat(this.setters), l;
        }, p.prototype.get = function(l) {
          return this.getters.push(l), this;
        }, p.prototype.set = function(l) {
          return this.setters.push(l), this;
        }, p.prototype.applyGetters = function(l, d) {
          h.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && d.$$populatedVirtuals && d.$$populatedVirtuals.hasOwnProperty(this.path) && (l = d.$$populatedVirtuals[this.path]);
          var v, m = l, g = u(this.getters);
          try {
            for (g.s(); !(v = g.n()).done; ) m = v.value.call(d, m, this, d);
          } catch (_) {
            g.e(_);
          } finally {
            g.f();
          }
          return m;
        }, p.prototype.applySetters = function(l, d) {
          var v, m = l, g = u(this.setters);
          try {
            for (g.s(); !(v = g.n()).done; ) m = v.value.call(d, m, this, d);
          } catch (_) {
            g.e(_);
          } finally {
            g.f();
          }
          return m;
        }, p.prototype._getModelNamesForPopulate = function(l) {
          if (this.options.refPath) return f(this.options.refPath, l, this.path);
          var d;
          return (d = typeof this.options.ref != "function" || this.options.ref[y] ? this.options.ref : this.options.ref.call(l, l)) == null || Array.isArray(d) ? d : [d];
        }, o.exports = p;
      }, 668: (o, s, a) => {
        var u = Array.prototype.slice, c = a(6312), f = Object.keys, h = f ? function(p) {
          return f(p);
        } : a(6544), y = Object.keys;
        h.shim = function() {
          if (Object.keys) {
            var p = (function() {
              var l = Object.keys(arguments);
              return l && l.length === arguments.length;
            })(1, 2);
            p || (Object.keys = function(l) {
              return c(l) ? y(u.call(l)) : y(l);
            });
          } else Object.keys = h;
          return Object.keys || h;
        }, o.exports = h;
      }, 674: (o, s, a) => {
        var u = a(3414);
        o.exports = function(c) {
          return u(c) || c === 0 ? c : c < 0 ? -1 : 1;
        };
      }, 766: (o, s) => {
        var a = o.exports = {};
        a.DocumentNotFoundError = null, a.general = {}, a.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`", a.general.required = "Path `{PATH}` is required.", a.Number = {}, a.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).", a.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).", a.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", a.Date = {}, a.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).", a.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).", a.String = {}, a.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", a.String.match = "Path `{PATH}` is invalid ({VALUE}).", a.String.minlength = "Path `{PATH}` (`{VALUE}`, length {LENGTH}) is shorter than the minimum allowed length ({MINLENGTH}).", a.String.maxlength = "Path `{PATH}` (`{VALUE}`, length {LENGTH}) is longer than the maximum allowed length ({MAXLENGTH}).";
      }, 783: (o) => {
        o.exports = ReferenceError;
      }, 791: (o, s, a) => {
        function u(h, y) {
          var p = typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
          if (!p) {
            if (Array.isArray(h) || (p = (function(_, b) {
              if (_) {
                if (typeof _ == "string") return c(_, b);
                var w = {}.toString.call(_).slice(8, -1);
                return w === "Object" && _.constructor && (w = _.constructor.name), w === "Map" || w === "Set" ? Array.from(_) : w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w) ? c(_, b) : void 0;
              }
            })(h)) || y) {
              p && (h = p);
              var l = 0, d = function() {
              };
              return { s: d, n: function() {
                return l >= h.length ? { done: !0 } : { done: !1, value: h[l++] };
              }, e: function(_) {
                throw _;
              }, f: d };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var v, m = !0, g = !1;
          return { s: function() {
            p = p.call(h);
          }, n: function() {
            var _ = p.next();
            return m = _.done, _;
          }, e: function(_) {
            g = !0, v = _;
          }, f: function() {
            try {
              m || p.return == null || p.return();
            } finally {
              if (g) throw v;
            }
          } };
        }
        function c(h, y) {
          (y == null || y > h.length) && (y = h.length);
          for (var p = 0, l = Array(y); p < y; p++) l[p] = h[p];
          return l;
        }
        var f = a(3703);
        o.exports = function(h, y, p) {
          var l, d = p != null ? Object.keys(f(h.tree, p, {})) : Object.keys(h.tree), v = new Set(Object.keys(y));
          if (v.size > 1) {
            l = /* @__PURE__ */ new Set();
            var m, g = u(d);
            try {
              for (g.s(); !(m = g.n()).done; ) {
                var _ = m.value;
                v.has(_) && l.add(_);
              }
            } catch (E) {
              g.e(E);
            } finally {
              g.f();
            }
            var b, w = u(v);
            try {
              for (w.s(); !(b = w.n()).done; ) {
                var A = b.value;
                l.has(A) || l.add(A);
              }
            } catch (E) {
              w.e(E);
            } finally {
              w.f();
            }
            l = Array.from(l);
          } else l = Array.from(v);
          return l;
        };
      }, 863: (o, s, a) => {
        var u = a(3305), c = a(5549);
        o.exports = function(f) {
          if (f == null || u(f, "ObjectId")) return f;
          if (f._id) {
            if (u(f._id, "ObjectId")) return f._id;
            if (f._id.toString instanceof Function) return new c(f._id.toString());
          }
          return f.toString instanceof Function ? new c(f.toString()) : new c(f);
        };
      }, 953: (o, s, a) => {
        var u = a(5484);
        o.exports = function() {
          return u() && !!Symbol.toStringTag;
        };
      }, 988: (o) => {
        var s = Object.defineProperty || !1;
        if (s) try {
          s({}, "a", { value: 1 });
        } catch {
          s = !1;
        }
        o.exports = s;
      }, 1007: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "min", p), Object.defineProperty(y.prototype, "max", p), Object.defineProperty(y.prototype, "enum", p), Object.defineProperty(y.prototype, "populate", p), o.exports = y;
      }, 1058: (o, s, a) => {
        var u = a(2696);
        o.exports = function(c, f) {
          if (c == null) return null;
          for (var h = 0, y = Object.keys(c); h < y.length; h++) {
            var p = c[y[h]];
            if (p.schema && p.schema.discriminatorMapping && u(p.schema.discriminatorMapping.value, f)) return p;
          }
          return null;
        };
      }, 1091: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          return a != null && s(a) === "object" && a.$slice == null && a.$elemMatch == null && a.$meta == null && a.$ == null;
        };
      }, 1129: (o, s, a) => {
        function u(d) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(v) {
            return typeof v;
          } : function(v) {
            return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
          }, u(d);
        }
        function c() {
          try {
            var d = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!d;
          })();
        }
        function f(d) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(v) {
            return v.__proto__ || Object.getPrototypeOf(v);
          }, f(d);
        }
        function h(d, v) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, g) {
            return m.__proto__ = g, m;
          }, h(d, v);
        }
        var y = a(8213), p = a(7352), l = (function(d) {
          function v(g, _, b, w) {
            var A;
            (function(O, $) {
              if (!(O instanceof $)) throw new TypeError("Cannot call a class as a function");
            })(this, v);
            var E = y.messages;
            return (A = (function(O, $, k) {
              return $ = f($), (function(j, P) {
                if (P && (u(P) == "object" || typeof P == "function")) return P;
                if (P !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(R) {
                  if (R === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return R;
                })(j);
              })(O, c() ? Reflect.construct($, k || [], f(O).constructor) : $.apply(O, k));
            })(this, v, [E.DocumentNotFoundError != null ? typeof E.DocumentNotFoundError == "function" ? E.DocumentNotFoundError(g, _) : E.DocumentNotFoundError : 'No document found for query "' + p.inspect(g) + '" on model "' + _ + '"'])).result = w, A.numAffected = b, A.filter = g, A.query = g, A;
          }
          return (function(g, _) {
            if (typeof _ != "function" && _ !== null) throw new TypeError("Super expression must either be null or a function");
            g.prototype = Object.create(_ && _.prototype, { constructor: { value: g, writable: !0, configurable: !0 } }), Object.defineProperty(g, "prototype", { writable: !1 }), _ && h(g, _);
          })(v, d), m = v, Object.defineProperty(m, "prototype", { writable: !1 }), m;
          var m;
        })(y);
        Object.defineProperty(l.prototype, "name", { value: "DocumentNotFoundError" }), o.exports = l;
      }, 1199: (o) => {
        o.exports = function(s, a) {
          var u = Object.keys(s), c = Object.keys(a);
          if (u.length !== c.length) return !1;
          for (var f = 0; f < u.length; f++) {
            var h = u[f];
            if (h !== c[f] || s[h] !== a[h]) return !1;
          }
          return !0;
        };
      }, 1226: (o) => {
        o.exports = function(s) {
          return s == null ? null : Object.keys(s)[0];
        };
      }, 1243: (o, s) => {
        s.isMongooseArray = function(a) {
          return Array.isArray(a) && a.isMongooseArray;
        };
      }, 1244: (o, s, a) => {
        var u = a(3609);
        o.exports = function(c, f) {
          if (c == null) return c;
          if (c._id && typeof c._id == "string") return c._id;
          if (c.toString && c.toString !== Object.prototype.toString && !Array.isArray(c)) return c.toString();
          throw new u("string", c, f);
        };
      }, 1260: (o, s) => {
        var a = Object.freeze(["countDocuments", "distinct", "estimatedDocumentCount", "find", "findOne", "findOneAndReplace", "findOneAndUpdate", "replaceOne", "updateMany", "updateOne", "deleteMany", "deleteOne", "findOneAndDelete"]).concat(["validate"]);
        s.Ut = a;
      }, 1313: (o, s, a) => {
        var u = a(486);
        o.exports = function(c, f) {
          return f == null || f._id == null || (c = c.clone(), f._id ? c.paths._id || (u(c), c.options._id = !0) : (c.remove("_id"), c.options._id = !1)), c;
        };
      }, 1344: (o, s, a) => {
        o.exports = a(6353).UUID;
      }, 1347: (o, s) => {
        s.isMongooseDocumentArray = function(a) {
          return Array.isArray(a) && a.isMongooseDocumentArray;
        };
      }, 1350: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m, g) {
            return (function(_, b) {
              if (!(_ instanceof b)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(_, b, w) {
              return b = f(b), (function(A, E) {
                if (E && (u(E) == "object" || typeof E == "function")) return E;
                if (E !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(O) {
                  if (O === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return O;
                })(A);
              })(_, c() ? Reflect.construct(b, w || [], f(_).constructor) : b.apply(_, w));
            })(this, l, ['Parameter "' + m + '" to ' + g + '() must be an object, got "' + v.toString() + '" (type ' + u(v) + ")"]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "ObjectParameterError" }), o.exports = y;
      }, 1417: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v) {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, l, ["For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + v.join(`
  `) + `
Use Model.updateOne() to update these arrays instead.`]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "DivergentArrayError" }), o.exports = y;
      }, 1464: (o, s, a) => {
        var u = a(5807);
        if (u) try {
          u([], "length");
        } catch {
          u = null;
        }
        o.exports = u;
      }, 1469: (o, s, a) => {
        function u($) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
            return typeof k;
          } : function(k) {
            return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
          }, u($);
        }
        function c($, k) {
          var j = Object.keys($);
          if (Object.getOwnPropertySymbols) {
            var P = Object.getOwnPropertySymbols($);
            k && (P = P.filter(function(R) {
              return Object.getOwnPropertyDescriptor($, R).enumerable;
            })), j.push.apply(j, P);
          }
          return j;
        }
        function f($, k, j) {
          return (k = (function(P) {
            var R = (function(I) {
              if (u(I) != "object" || !I) return I;
              var z = I[Symbol.toPrimitive];
              if (z !== void 0) {
                var W = z.call(I, "string");
                if (u(W) != "object") return W;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(I);
            })(P);
            return u(R) == "symbol" ? R : R + "";
          })(k)) in $ ? Object.defineProperty($, k, { value: j, enumerable: !0, configurable: !0, writable: !0 }) : $[k] = j, $;
        }
        function h() {
          var $, k, j = typeof Symbol == "function" ? Symbol : {}, P = j.iterator || "@@iterator", R = j.toStringTag || "@@toStringTag";
          function I(D, L, M, N) {
            var Z = L && L.prototype instanceof W ? L : W, Y = Object.create(Z.prototype);
            return y(Y, "_invoke", (function(ie, le, de) {
              var ae, ne, he, x = 0, U = de || [], B = !1, J = { p: 0, n: 0, v: $, a: X, f: X.bind($, 4), d: function(oe, ye) {
                return ae = oe, ne = 0, he = $, J.n = ye, z;
              } };
              function X(oe, ye) {
                for (ne = oe, he = ye, k = 0; !B && x && !q && k < U.length; k++) {
                  var q, G = U[k], ce = J.p, ue = G[2];
                  oe > 3 ? (q = ue === ye) && (he = G[(ne = G[4]) ? 5 : (ne = 3, 3)], G[4] = G[5] = $) : G[0] <= ce && ((q = oe < 2 && ce < G[1]) ? (ne = 0, J.v = ye, J.n = G[1]) : ce < ue && (q = oe < 3 || G[0] > ye || ye > ue) && (G[4] = oe, G[5] = ye, J.n = ue, ne = 0));
                }
                if (q || oe > 1) return z;
                throw B = !0, ye;
              }
              return function(oe, ye, q) {
                if (x > 1) throw TypeError("Generator is already running");
                for (B && ye === 1 && X(ye, q), ne = ye, he = q; (k = ne < 2 ? $ : he) || !B; ) {
                  ae || (ne ? ne < 3 ? (ne > 1 && (J.n = -1), X(ne, he)) : J.n = he : J.v = he);
                  try {
                    if (x = 2, ae) {
                      if (ne || (oe = "next"), k = ae[oe]) {
                        if (!(k = k.call(ae, he))) throw TypeError("iterator result is not an object");
                        if (!k.done) return k;
                        he = k.value, ne < 2 && (ne = 0);
                      } else ne === 1 && (k = ae.return) && k.call(ae), ne < 2 && (he = TypeError("The iterator does not provide a '" + oe + "' method"), ne = 1);
                      ae = $;
                    } else if ((k = (B = J.n < 0) ? he : ie.call(le, J)) !== z) break;
                  } catch (G) {
                    ae = $, ne = 1, he = G;
                  } finally {
                    x = 1;
                  }
                }
                return { value: k, done: B };
              };
            })(D, M, N), !0), Y;
          }
          var z = {};
          function W() {
          }
          function F() {
          }
          function te() {
          }
          k = Object.getPrototypeOf;
          var ee = [][P] ? k(k([][P]())) : (y(k = {}, P, function() {
            return this;
          }), k), V = te.prototype = W.prototype = Object.create(ee);
          function T(D) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(D, te) : (D.__proto__ = te, y(D, R, "GeneratorFunction")), D.prototype = Object.create(V), D;
          }
          return F.prototype = te, y(V, "constructor", te), y(te, "constructor", F), F.displayName = "GeneratorFunction", y(te, R, "GeneratorFunction"), y(V), y(V, R, "Generator"), y(V, P, function() {
            return this;
          }), y(V, "toString", function() {
            return "[object Generator]";
          }), (h = function() {
            return { w: I, m: T };
          })();
        }
        function y($, k, j, P) {
          var R = Object.defineProperty;
          try {
            R({}, "", {});
          } catch {
            R = 0;
          }
          y = function(I, z, W, F) {
            function te(ee, V) {
              y(I, ee, function(T) {
                return this._invoke(ee, V, T);
              });
            }
            z ? R ? R(I, z, { value: W, enumerable: !F, configurable: !F, writable: !F }) : I[z] = W : (te("next", 0), te("throw", 1), te("return", 2));
          }, y($, k, j, P);
        }
        function p($) {
          return (function(k) {
            if (Array.isArray(k)) return v(k);
          })($) || (function(k) {
            if (typeof Symbol < "u" && k[Symbol.iterator] != null || k["@@iterator"] != null) return Array.from(k);
          })($) || d($) || (function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })();
        }
        function l($, k) {
          var j = typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
          if (!j) {
            if (Array.isArray($) || (j = d($)) || k) {
              j && ($ = j);
              var P = 0, R = function() {
              };
              return { s: R, n: function() {
                return P >= $.length ? { done: !0 } : { done: !1, value: $[P++] };
              }, e: function(F) {
                throw F;
              }, f: R };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var I, z = !0, W = !1;
          return { s: function() {
            j = j.call($);
          }, n: function() {
            var F = j.next();
            return z = F.done, F;
          }, e: function(F) {
            W = !0, I = F;
          }, f: function() {
            try {
              z || j.return == null || j.return();
            } finally {
              if (W) throw I;
            }
          } };
        }
        function d($, k) {
          if ($) {
            if (typeof $ == "string") return v($, k);
            var j = {}.toString.call($).slice(8, -1);
            return j === "Object" && $.constructor && (j = $.constructor.name), j === "Map" || j === "Set" ? Array.from($) : j === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(j) ? v($, k) : void 0;
          }
        }
        function v($, k) {
          (k == null || k > $.length) && (k = $.length);
          for (var j = 0, P = Array(k); j < k; j++) P[j] = $[j];
          return P;
        }
        var m = a(5022), g = a(8442), _ = a(4450), b = a(2068).X, w = a(3703), A = a(8768), E = a(4301), O = { toJSON: !0, toObject: !0, _id: !0, id: !0, virtuals: !0, methods: !0, statics: !0 };
        o.exports = function($, k, j, P, R, I, z) {
          if (!j || !j.instanceOfSchema) throw new Error("You must pass a valid discriminator Schema");
          if (I = I == null || I, $.schema.discriminatorMapping && !$.schema.discriminatorMapping.isRoot) throw new Error('Discriminator "' + k + '" can only be a discriminator of the root model');
          if (R) {
            var W = w($.base, "options.applyPluginsToDiscriminators", !1) || !I;
            $.base._applyPlugins(j, { skipTopLevel: !W });
          } else I || g(j);
          var F = $.schema.options.discriminatorKey, te = $.schema.path(F);
          if (te != null) A.hasUserDefinedProperty(te.options, "select") || (te.options.select = !0), te.options.$skipDiscriminatorCheck = !0;
          else {
            var ee = {};
            ee[F] = { default: void 0, select: !0, $skipDiscriminatorCheck: !0 }, ee[F][$.schema.options.typeKey] = String, $.schema.add(ee), b({ prop: F, prototype: $.prototype, options: $.schema.options });
          }
          if (j.path(F) && j.path(F).options.$skipDiscriminatorCheck !== !0) throw new Error('Discriminator "' + k + '" cannot have field with name "' + F + '"');
          var V = k;
          if ((typeof P == "string" && P.length || P != null) && (V = P), (function(T, D) {
            var L = h().m(ie);
            if (T.encryptionType() != null || D.encryptionType() != null) {
              var M, N = l(ie(Y(T), Y(D)));
              try {
                for (N.s(); !(M = N.n()).done; ) {
                  var Z = M.value;
                  if (T._hasEncryptedField(Z) && D._hasEncryptedField(Z)) throw new Error("encrypted fields cannot be declared on both the base schema and the child schema in a discriminator. path=".concat(Z));
                  if (T._hasEncryptedField(Z) || D._hasEncryptedField(Z)) throw new Error("encrypted fields cannot have the same path as a non-encrypted field for discriminators. path=".concat(Z));
                }
              } catch (le) {
                N.e(le);
              } finally {
                N.f();
              }
            }
            function Y(le) {
              return [].concat(p(Object.keys(le.paths)), p(Object.keys(le.singleNestedPaths)));
            }
            function ie(le, de) {
              var ae, ne, he, x, U;
              return h().w(function(B) {
                for (; ; ) switch (B.p = B.n) {
                  case 0:
                    ae = new Set(le), ne = l(de), B.p = 1, ne.s();
                  case 2:
                    if ((he = ne.n()).done) {
                      B.n = 4;
                      break;
                    }
                    if (x = he.value, !ae.has(x)) {
                      B.n = 3;
                      break;
                    }
                    return B.n = 3, x;
                  case 3:
                    B.n = 2;
                    break;
                  case 4:
                    B.n = 6;
                    break;
                  case 5:
                    B.p = 5, U = B.v, ne.e(U);
                  case 6:
                    return B.p = 6, ne.f(), B.f(6);
                  case 7:
                    return B.a(2);
                }
              }, L, null, [[1, 5, 6, 7]]);
            }
          })($.schema, j), (function(T, D) {
            T._baseSchema = D, D.paths._id && D.paths._id.options && !D.paths._id.options.auto && T.remove("_id");
            for (var L = [], M = 0, N = Object.keys(D.paths); M < N.length; M++) {
              var Z = N[M];
              if (T.nested[Z]) L.push(Z);
              else if (Z.indexOf(".") !== -1) {
                var Y, ie = "", le = l(Z.split(".").slice(0, -1));
                try {
                  for (le.s(); !(Y = le.n()).done; ) {
                    var de = Y.value;
                    ie += (ie.length ? "." : "") + de, (T.paths[ie] instanceof m || T.singleNestedPaths[ie] instanceof m) && L.push(Z);
                  }
                } catch (xe) {
                  le.e(xe);
                } finally {
                  le.f();
                }
              }
            }
            T.obj = (function(xe) {
              for (var be = 1; be < arguments.length; be++) {
                var Ee = arguments[be] != null ? arguments[be] : {};
                be % 2 ? c(Object(Ee), !0).forEach(function(Ue) {
                  f(xe, Ue, Ee[Ue]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(xe, Object.getOwnPropertyDescriptors(Ee)) : c(Object(Ee)).forEach(function(Ue) {
                  Object.defineProperty(xe, Ue, Object.getOwnPropertyDescriptor(Ee, Ue));
                });
              }
              return xe;
            })({}, T.obj), E(T, D), T._gatherChildSchemas();
            for (var ae = 0, ne = L; ae < ne.length; ae++) {
              var he = ne[ae];
              delete T.paths[he];
            }
            T.childSchemas.forEach(function(xe) {
              xe.model.prototype.$__setSchema(xe.schema);
            });
            var x = {};
            x[F] = { default: V, select: !0, set: function(xe) {
              if (xe === V || Array.isArray(V) && A.deepEqual(xe, V)) return V;
              throw new Error(`Can't set discriminator key "` + F + '"');
            }, $skipDiscriminatorCheck: !0 }, x[F][T.options.typeKey] = te ? te.options[T.options.typeKey] : String, T.add(x), T.discriminatorMapping = { key: F, value: V, isRoot: !1 }, D.options.collection && (T.options.collection = D.options.collection);
            var U = T.options.toJSON, B = T.options.toObject, J = T.options._id, X = T.options.id, oe = Object.keys(T.options);
            T.options.discriminatorKey = D.options.discriminatorKey;
            for (var ye = T._userProvidedOptions, q = 0, G = oe; q < G.length; q++) {
              var ce = G[q];
              if (!O[ce] && ce in ye && !A.deepEqual(T.options[ce], D.options[ce])) throw new Error("Can't customize discriminator option " + ce + " (can only modify " + Object.keys(O).join(", ") + ")");
            }
            T.options = _(D.options);
            for (var ue = 0, re = Object.keys(ye); ue < re.length; ue++) {
              var pe = re[ue];
              T.options[pe] = ye[pe];
            }
            U && (T.options.toJSON = U), B && (T.options.toObject = B), J !== void 0 && (T.options._id = J), T.options.id = X, I && (T.s.hooks = $.schema.s.hooks.merge(T.s.hooks)), R && (T.plugins = Array.prototype.slice.call(D.plugins)), T.callQueue = D.callQueue.concat(T.callQueue), delete T._requiredpaths;
          })(j, $.schema), $.discriminators || ($.discriminators = {}), $.schema.discriminatorMapping || ($.schema.discriminatorMapping = { key: F, value: null, isRoot: !0 }), $.schema.discriminators || ($.schema.discriminators = {}), $.schema.discriminators[k] = j, $.discriminators[k] && !j.options.overwriteModels && !z) throw new Error('Discriminator with name "' + k + '" already exists');
          return j;
        };
      }, 1505: (o) => {
        o.exports = function(s, a, u, c, f) {
          var h = a != null && a.updatedAt === !1, y = a != null && a.createdAt === !1, p = u != null ? u() : s.ownerDocument().constructor.base.now();
          if (!y && (s.isNew || s.$isSubdocument) && c && !s.$__getValue(c) && s.$__isSelected(c) && s.$set(c, p, void 0, { overwriteImmutable: !0 }), !h && f && (s.isNew || s.$isModified())) {
            var l = p;
            s.isNew && c != null && (l = s.$__getValue(c)), s.$set(f, l);
          }
        };
      }, 1635: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v) {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, l, ["Can't validate() the same doc multiple times in parallel. Document: " + v._doc._id]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "ParallelValidateError" }), o.exports = y;
      }, 1679: (o) => {
        typeof Object.create == "function" ? o.exports = function(s, a) {
          a && (s.super_ = a, s.prototype = Object.create(a.prototype, { constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 } }));
        } : o.exports = function(s, a) {
          if (a) {
            s.super_ = a;
            var u = function() {
            };
            u.prototype = a.prototype, s.prototype = new u(), s.prototype.constructor = s;
          }
        };
      }, 1697: (o) => {
        o.exports = Math.max;
      }, 1732: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        function c(_, b) {
          var w = Object.keys(_);
          if (Object.getOwnPropertySymbols) {
            var A = Object.getOwnPropertySymbols(_);
            b && (A = A.filter(function(E) {
              return Object.getOwnPropertyDescriptor(_, E).enumerable;
            })), w.push.apply(w, A);
          }
          return w;
        }
        function f(_) {
          for (var b = 1; b < arguments.length; b++) {
            var w = arguments[b] != null ? arguments[b] : {};
            b % 2 ? c(Object(w), !0).forEach(function(A) {
              h(_, A, w[A]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(w)) : c(Object(w)).forEach(function(A) {
              Object.defineProperty(_, A, Object.getOwnPropertyDescriptor(w, A));
            });
          }
          return _;
        }
        function h(_, b, w) {
          return (b = (function(A) {
            var E = (function(O) {
              if (u(O) != "object" || !O) return O;
              var $ = O[Symbol.toPrimitive];
              if ($ !== void 0) {
                var k = $.call(O, "string");
                if (u(k) != "object") return k;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(O);
            })(A);
            return u(E) == "symbol" ? E : E + "";
          })(b)) in _ ? Object.defineProperty(_, b, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : _[b] = w, _;
        }
        var y = a(3609), p = a(6426), l = a(3704), d = a(4327);
        function v(_, b) {
          p.call(this, _, b, "Double");
        }
        function m(_) {
          return this.cast(_);
        }
        v.schemaName = "Double", v.defaultOptions = {}, v.prototype = Object.create(p.prototype), v.prototype.constructor = v, v._cast = l, v.set = p.set, v.setters = [], v.get = p.get, v._defaultCaster = function(_) {
          if (_ != null && _._bsontype !== "Double") throw new Error();
          return _;
        }, v.cast = function(_) {
          return arguments.length === 0 || (_ === !1 && (_ = this._defaultCaster), this._cast = _), this._cast;
        }, v._checkRequired = function(_) {
          return _ != null;
        }, v.checkRequired = p.checkRequired, v.prototype.checkRequired = function(_) {
          return this.constructor._checkRequired(_);
        }, v.prototype.cast = function(_) {
          var b;
          b = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : v.cast();
          try {
            return b(_);
          } catch (w) {
            throw new y("Double", _, this.path, w, this);
          }
        };
        var g = f(f({}, p.prototype.$conditionalHandlers), {}, { $gt: m, $gte: m, $lt: m, $lte: m });
        Object.defineProperty(v.prototype, "$conditionalHandlers", { enumerable: !1, value: g }), v.prototype.toJSONSchema = function(_) {
          var b = this.options.required && typeof this.options.required != "function";
          return d("number", "double", _?.useBsonType, b);
        }, v.prototype.autoEncryptionType = function() {
          return "double";
        }, o.exports = v;
      }, 1793: (o, s, a) => {
        var u = a(7300), c = a(2789);
        o.exports = function f(h) {
          if (h == null) return null;
          var y = Object.keys(h), p = null;
          if (y.length === 1 && y[0] === "_id") p = !h._id;
          else for (var l = 0; l < y.length; ++l) {
            var d, v = y[l];
            if (v !== "_id" && u(h[v]) && (p = c(h[v]) ? (d = f(h[v])) !== null && d !== void 0 ? d : p : !h[v]) != null) break;
          }
          return p;
        };
      }, 1824: (o, s, a) => {
        function u(f) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
            return typeof h;
          } : function(h) {
            return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
          }, u(f);
        }
        var c = a(3703);
        o.exports = function(f, h, y, p, l, d) {
          var v = p, m = v, g = c(l, "timestamps", !0);
          if (!g || v == null) return p;
          var _, b, w, A = g != null && g.createdAt === !1, E = g != null && g.updatedAt === !1;
          if (d) return p && p.$set && (p = p.$set, v.$set = {}, m = v.$set), E || !y || p[y] || (m[y] = f), A || !h || p[h] || (m[h] = f), v;
          if (p = p || {}, Array.isArray(v)) return y == null || v.push({ $set: (_ = {}, b = y, w = f, (b = (function(te) {
            var ee = (function(V) {
              if (u(V) != "object" || !V) return V;
              var T = V[Symbol.toPrimitive];
              if (T !== void 0) {
                var D = T.call(V, "string");
                if (u(D) != "object") return D;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(V);
            })(te);
            return u(ee) == "symbol" ? ee : ee + "";
          })(b)) in _ ? Object.defineProperty(_, b, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : _[b] = w, _) }), v;
          if (v.$set = v.$set || {}, !E && y && (!p.$currentDate || !p.$currentDate[y])) {
            var O = !1;
            if (y.indexOf(".") !== -1) for (var $ = y.split("."), k = 1; k < $.length; ++k) {
              var j = $.slice(-k).join("."), P = $.slice(0, -k).join(".");
              if (p[P] != null) {
                p[P][j] = f, O = !0;
                break;
              }
              if (p.$set && p.$set[P]) {
                p.$set[P][j] = f, O = !0;
                break;
              }
            }
            O || (v.$set[y] = f), v.hasOwnProperty(y) && delete v[y];
          }
          if (!A && h) {
            p[h] && delete p[h], p.$set && p.$set[h] && delete p.$set[h];
            var R = !1;
            if (h.indexOf(".") !== -1) for (var I = h.split("."), z = 1; z < I.length; ++z) {
              var W = I.slice(-z).join("."), F = I.slice(0, -z).join(".");
              if (p[F] != null) {
                p[F][W] = f, R = !0;
                break;
              }
              if (p.$set && p.$set[F]) {
                p.$set[F][W] = f, R = !0;
                break;
              }
            }
            R || (v.$setOnInsert = v.$setOnInsert || {}, v.$setOnInsert[h] = f);
          }
          return Object.keys(v.$set).length === 0 && delete v.$set, v;
        };
      }, 1849: (o, s, a) => {
        function u(f, h) {
          (h == null || h > f.length) && (h = f.length);
          for (var y = 0, p = Array(h); y < h; y++) p[y] = f[y];
          return p;
        }
        var c = a(8768);
        o.exports = function(f, h) {
          if (f._doc._id != null && h != null && h.length !== 0) {
            var y, p = String(f._doc._id), l = (function(A, E) {
              var O = typeof Symbol < "u" && A[Symbol.iterator] || A["@@iterator"];
              if (!O) {
                if (Array.isArray(A) || (O = (function(I, z) {
                  if (I) {
                    if (typeof I == "string") return u(I, z);
                    var W = {}.toString.call(I).slice(8, -1);
                    return W === "Object" && I.constructor && (W = I.constructor.name), W === "Map" || W === "Set" ? Array.from(I) : W === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(W) ? u(I, z) : void 0;
                  }
                })(A)) || E) {
                  O && (A = O);
                  var $ = 0, k = function() {
                  };
                  return { s: k, n: function() {
                    return $ >= A.length ? { done: !0 } : { done: !1, value: A[$++] };
                  }, e: function(I) {
                    throw I;
                  }, f: k };
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              }
              var j, P = !0, R = !1;
              return { s: function() {
                O = O.call(A);
              }, n: function() {
                var I = O.next();
                return P = I.done, I;
              }, e: function(I) {
                R = !0, j = I;
              }, f: function() {
                try {
                  P || O.return == null || O.return();
                } finally {
                  if (R) throw j;
                }
              } };
            })(h);
            try {
              for (l.s(); !(y = l.n()).done; ) {
                var d = y.value;
                if (!d.isVirtual) for (var v = d.path.split("."), m = 0; m < v.length - 1; ++m) {
                  var g = v.slice(0, m + 1).join("."), _ = v.slice(m + 1).join("."), b = f.get(g);
                  if (b != null && c.isMongooseDocumentArray(b)) {
                    for (var w = 0; w < b.length; ++w) b[w] && b[w].populated(_, d._docs[p] == null ? void 0 : d._docs[p][w], d);
                    break;
                  }
                }
              }
            } catch (A) {
              l.e(A);
            } finally {
              l.f();
            }
          }
        };
      }, 1875: (o) => {
        o.exports = function(s) {
          for (var a, u = Object.keys(s.errors || {}), c = u.length, f = [], h = 0; h < c; ++h) a = u[h], s !== s.errors[a] && f.push(a + ": " + s.errors[a].message);
          return f.join(", ");
        };
      }, 1898: (o, s, a) => {
        s.saveSubdocs = a(4432), s.sharding = a(2824), s.trackTransaction = a(5889), s.validateBeforeSave = a(9848);
      }, 1905: (o, s, a) => {
        var u = a(3071), c = a(2724)(/^\s*(?:function)?\*/), f = a(953)(), h = a(209), y = u("Object.prototype.toString"), p = u("Function.prototype.toString"), l = a(8690);
        o.exports = function(d) {
          if (typeof d != "function") return !1;
          if (c(p(d))) return !0;
          if (!f) return y(d) === "[object GeneratorFunction]";
          if (!h) return !1;
          var v = l();
          return v && h(d) === v.prototype;
        };
      }, 2003: (o, s, a) => {
        var u = a(3703), c = a(608), f = a(2423);
        o.exports = function(h) {
          var y = [], p = /* @__PURE__ */ new WeakMap(), l = h.constructor.indexTypes, d = /* @__PURE__ */ new Map();
          return (function v(m, g, _) {
            if (!p.has(m)) {
              p.set(m, !0), g = g || "";
              for (var b = 0, w = Object.keys(m.paths); b < w.length; b++) {
                var A = w[b], E = m.paths[A];
                if (_ == null || !_.paths[A]) {
                  if (E._duplicateKeyErrorMessage != null && (m._duplicateKeyErrorMessagesByPath = m._duplicateKeyErrorMessagesByPath || {}, m._duplicateKeyErrorMessagesByPath[A] = E._duplicateKeyErrorMessage), E.$isMongooseDocumentArray || E.$isSingleNested) {
                    if (u(E, "options.excludeIndexes") !== !0 && u(E, "schemaOptions.excludeIndexes") !== !0 && u(E, "schema.options.excludeIndexes") !== !0 && v(E.schema, g + A + "."), E.schema.discriminators != null) for (var O = E.schema.discriminators, $ = 0, k = Object.keys(O); $ < k.length; $++)
                      v(O[k[$]], g + A + ".", E.schema);
                    if (E.$isMongooseDocumentArray) continue;
                  }
                  var j = E._index || E.caster && E.caster._index;
                  if (j !== !1 && j != null) {
                    var P = {}, R = c(j), I = R ? j : {}, z = typeof j == "string" ? j : !!R && j.type;
                    if (z && l.indexOf(z) !== -1) P[g + A] = z;
                    else if (I.text) P[g + A] = "text", delete I.text;
                    else {
                      var W;
                      W = j === "descending" || j === "desc" || j !== "ascending" && j !== "asc" && Number(j) === -1, P[g + A] = W ? -1 : 1;
                    }
                    delete I.type, "background" in I || (I.background = !0), m.options.autoIndex != null && (I._autoIndex = m.options.autoIndex);
                    var F = I && I.name;
                    typeof F == "string" && d.has(F) ? Object.assign(d.get(F), P) : (y.push([P, I]), d.set(F, P));
                  }
                }
              }
              p.delete(m), g ? (function(te, ee) {
                for (var V = te._indexes, T = V.length, D = 0; D < T; ++D) {
                  for (var L = V[D][0], M = V[D][1], N = Object.keys(L), Z = N.length, Y = {}, ie = 0; ie < Z; ++ie) {
                    var le = N[ie];
                    Y[ee + le] = L[le];
                  }
                  var de = Object.assign({}, M);
                  if (M != null && M.partialFilterExpression != null) {
                    de.partialFilterExpression = {};
                    for (var ae = M.partialFilterExpression, ne = 0, he = Object.keys(ae); ne < he.length; ne++) {
                      var x = he[ne];
                      de.partialFilterExpression[ee + x] = ae[x];
                    }
                  }
                  y.push([Y, de]);
                }
              })(m, g) : (m._indexes.forEach(function(te) {
                var ee = te[1];
                "background" in ee || (ee.background = !0), f(m, ee);
              }), y = y.concat(m._indexes));
            }
          })(h), y;
        };
      }, 2064: (o, s, a) => {
        var u = a(2273), c = a(9122), f = a(4756), h = a(2481), y = a(9247), p = c(h(), Object);
        u(p, { getPolyfill: h, implementation: f, shim: y }), o.exports = p;
      }, 2068: (o, s, a) => {
        var u, c = a(4450), f = a(7930).documentSchemaSymbol, h = a(3303)._, y = a(8768), p = a(7930).getSymbol, l = a(7930).scopeSymbol, d = y.isPOJO;
        s.w = g, s.X = _;
        var v = Object.freeze({ minimize: !0, virtuals: !1, getters: !1, transform: !1 }), m = Object.freeze({ noDottedPath: !0 });
        function g(b, w, A, E) {
          u = u || a(2400);
          for (var O = E.typeKey, $ = 0, k = Object.keys(b); $ < k.length; $++) {
            var j = k[$], P = b[j];
            _({ prop: j, subprops: d(P) && Object.keys(P).length > 0 && (!P[O] || O === "type" && d(P.type) && P.type.type) ? P : null, prototype: w, prefix: A, options: E });
          }
        }
        function _(b) {
          var w = b.prop, A = b.subprops, E = b.prototype, O = b.prefix, $ = b.options;
          u = u || a(2400);
          var k = (O ? O + "." : "") + w, j = (O = O || "") ? Object.freeze({}) : m;
          A ? Object.defineProperty(E, w, { enumerable: !0, configurable: !0, get: function() {
            var P, R, I = this;
            if (this.$__.getters || (this.$__.getters = {}), !this.$__.getters[k]) {
              var z = Object.create(u.prototype, (P = this, R = {}, Object.getOwnPropertyNames(P).forEach(function(W) {
                ["isNew", "$__", "$errors", "errors", "_doc", "$locals", "$op", "__parentArray", "__index", "$isDocumentArrayElement"].indexOf(W) === -1 || (R[W] = Object.getOwnPropertyDescriptor(P, W), R[W].enumerable = !1);
              }), R));
              O || (z.$__[l] = this), z.$__.nestedPath = k, Object.defineProperty(z, "schema", { enumerable: !1, configurable: !0, writable: !1, value: E.schema }), Object.defineProperty(z, "$__schema", { enumerable: !1, configurable: !0, writable: !1, value: E.schema }), Object.defineProperty(z, f, { enumerable: !1, configurable: !0, writable: !1, value: E.schema }), Object.defineProperty(z, "toObject", { enumerable: !1, configurable: !0, writable: !1, value: function() {
                return c(I.get(k, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null }));
              } }), Object.defineProperty(z, "$__get", { enumerable: !1, configurable: !0, writable: !1, value: function() {
                return I.get(k, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null });
              } }), Object.defineProperty(z, "toJSON", { enumerable: !1, configurable: !0, writable: !1, value: function() {
                return I.get(k, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null });
              } }), Object.defineProperty(z, "$__isNested", { enumerable: !1, configurable: !0, writable: !1, value: !0 }), Object.defineProperty(z, "$isEmpty", { enumerable: !1, configurable: !0, writable: !1, value: function() {
                return Object.keys(this.get(k, null, v) || {}).length === 0;
              } }), Object.defineProperty(z, "$__parent", { enumerable: !1, configurable: !0, writable: !1, value: this }), g(A, z, k, $), this.$__.getters[k] = z;
            }
            return this.$__.getters[k];
          }, set: function(P) {
            P != null && P.$__isNested ? P = P.$__get() : P instanceof u && !P.$__isNested && (P = P.$toObject(h)), (this.$__[l] || this).$set(k, P);
          } }) : Object.defineProperty(E, w, { enumerable: !0, configurable: !0, get: function() {
            return this[p].call(this.$__[l] || this, k, null, j);
          }, set: function(P) {
            this.$set.call(this.$__[l] || this, k, P);
          } });
        }
      }, 2069: (o, s, a) => {
        function u(h, y, p) {
          return Object.defineProperty(h, "prototype", { writable: !1 }), h;
        }
        var c = a(5761), f = u(function h(y) {
          (function(p, l) {
            if (!(p instanceof l)) throw new TypeError("Cannot call a class as a function");
          })(this, h), Object.assign(this, y), y != null && y.options != null && (this.options = Object.assign({}, y.options));
        });
        Object.defineProperty(f.prototype, "ref", c), Object.defineProperty(f.prototype, "refPath", c), Object.defineProperty(f.prototype, "localField", c), Object.defineProperty(f.prototype, "foreignField", c), Object.defineProperty(f.prototype, "justOne", c), Object.defineProperty(f.prototype, "count", c), Object.defineProperty(f.prototype, "match", c), Object.defineProperty(f.prototype, "options", c), Object.defineProperty(f.prototype, "skip", c), Object.defineProperty(f.prototype, "limit", c), Object.defineProperty(f.prototype, "perDocumentLimit", c), o.exports = f;
      }, 2073: (o) => {
        o.exports = function s(a) {
          if (!Array.isArray(a)) return { min: 0, max: 0, containsNonArrayItem: !0 };
          if (a.length === 0) return { min: 1, max: 1, containsNonArrayItem: !1 };
          if (a.length === 1 && !Array.isArray(a[0])) return { min: 1, max: 1, containsNonArrayItem: !1 };
          for (var u = s(a[0]), c = 1; c < a.length; ++c) {
            var f = s(a[c]);
            f.min < u.min && (u.min = f.min), f.max > u.max && (u.max = f.max), u.containsNonArrayItem = u.containsNonArrayItem || f.containsNonArrayItem;
          }
          return u.min = u.min + 1, u.max = u.max + 1, u;
        };
      }, 2081: (o, s, a) => {
        function u(W) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
            return typeof F;
          } : function(F) {
            return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
          }, u(W);
        }
        function c(W, F) {
          var te = typeof Symbol < "u" && W[Symbol.iterator] || W["@@iterator"];
          if (!te) {
            if (Array.isArray(W) || (te = (function(M, N) {
              if (M) {
                if (typeof M == "string") return f(M, N);
                var Z = {}.toString.call(M).slice(8, -1);
                return Z === "Object" && M.constructor && (Z = M.constructor.name), Z === "Map" || Z === "Set" ? Array.from(M) : Z === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Z) ? f(M, N) : void 0;
              }
            })(W)) || F) {
              te && (W = te);
              var ee = 0, V = function() {
              };
              return { s: V, n: function() {
                return ee >= W.length ? { done: !0 } : { done: !1, value: W[ee++] };
              }, e: function(M) {
                throw M;
              }, f: V };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var T, D = !0, L = !1;
          return { s: function() {
            te = te.call(W);
          }, n: function() {
            var M = te.next();
            return D = M.done, M;
          }, e: function(M) {
            L = !0, T = M;
          }, f: function() {
            try {
              D || te.return == null || te.return();
            } finally {
              if (L) throw T;
            }
          } };
        }
        function f(W, F) {
          (F == null || F > W.length) && (F = W.length);
          for (var te = 0, ee = Array(F); te < F; te++) ee[te] = W[te];
          return ee;
        }
        function h(W, F) {
          for (var te = 0; te < F.length; te++) {
            var ee = F[te];
            ee.enumerable = ee.enumerable || !1, ee.configurable = !0, "value" in ee && (ee.writable = !0), Object.defineProperty(W, y(ee.key), ee);
          }
        }
        function y(W) {
          var F = (function(te) {
            if (u(te) != "object" || !te) return te;
            var ee = te[Symbol.toPrimitive];
            if (ee !== void 0) {
              var V = ee.call(te, "string");
              if (u(V) != "object") return V;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(te);
          })(W);
          return u(F) == "symbol" ? F : F + "";
        }
        function p(W, F, te, ee) {
          var V = l(g(W.prototype), F, te);
          return 2 & ee && typeof V == "function" ? function(T) {
            return V.apply(te, T);
          } : V;
        }
        function l() {
          return l = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(W, F, te) {
            var ee = (function(T, D) {
              for (; !{}.hasOwnProperty.call(T, D) && (T = g(T)) !== null; ) ;
              return T;
            })(W, F);
            if (ee) {
              var V = Object.getOwnPropertyDescriptor(ee, F);
              return V.get ? V.get.call(arguments.length < 3 ? W : te) : V.value;
            }
          }, l.apply(null, arguments);
        }
        function d(W) {
          var F = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return d = function(te) {
            if (te === null || !(function(V) {
              try {
                return Function.toString.call(V).indexOf("[native code]") !== -1;
              } catch {
                return typeof V == "function";
              }
            })(te)) return te;
            if (typeof te != "function") throw new TypeError("Super expression must either be null or a function");
            if (F !== void 0) {
              if (F.has(te)) return F.get(te);
              F.set(te, ee);
            }
            function ee() {
              return (function(V, T, D) {
                if (v()) return Reflect.construct.apply(null, arguments);
                var L = [null];
                L.push.apply(L, T);
                var M = new (V.bind.apply(V, L))();
                return D && m(M, D.prototype), M;
              })(te, arguments, g(this).constructor);
            }
            return ee.prototype = Object.create(te.prototype, { constructor: { value: ee, enumerable: !1, writable: !0, configurable: !0 } }), m(ee, te);
          }, d(W);
        }
        function v() {
          try {
            var W = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (v = function() {
            return !!W;
          })();
        }
        function m(W, F) {
          return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(te, ee) {
            return te.__proto__ = ee, te;
          }, m(W, F);
        }
        function g(W) {
          return g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(F) {
            return F.__proto__ || Object.getPrototypeOf(F);
          }, g(W);
        }
        var _ = a(5022), b = a(8213), w = a(4450), A = a(8768).deepEqual, E = a(8260), O = a(3216), $ = a(7352), k = a(2793), j = a(3305), P = a(4473), R = a(7930).populateModelSymbol, I = (function(W) {
          function F(V, T, D, L, M) {
            var N, Z;
            return (function(Y, ie) {
              if (!(Y instanceof ie)) throw new TypeError("Cannot call a class as a function");
            })(this, F), E(V) === "Object" && (V = Object.keys(V).reduce(function(Y, ie) {
              return Y.concat([[ie, V[ie]]]);
            }, [])), (Z = (function(Y, ie, le) {
              return ie = g(ie), (function(de, ae) {
                if (ae && (u(ae) == "object" || typeof ae == "function")) return ae;
                if (ae !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(ne) {
                  if (ne === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return ne;
                })(de);
              })(Y, v() ? Reflect.construct(ie, le || [], g(Y).constructor) : ie.apply(Y, le));
            })(this, F, [V])).$__parent = D != null && D.$__ != null ? D : null, (N = Z.$__parent) !== null && N !== void 0 && N.$isSingleNested && Z.$__parent.$basePath ? (Z.$__path = Z.$__parent.$basePath + "." + T, Z.$__pathRelativeToParent = T) : M != null && M.path ? (Z.$__path = M.path, Z.$__pathRelativeToParent = null) : (Z.$__path = T, Z.$__pathRelativeToParent = null), Z.$__schemaType = L ?? new _(T), Z.$__runDeferred(), Z;
          }
          return (function(V, T) {
            if (typeof T != "function" && T !== null) throw new TypeError("Super expression must either be null or a function");
            V.prototype = Object.create(T && T.prototype, { constructor: { value: V, writable: !0, configurable: !0 } }), Object.defineProperty(V, "prototype", { writable: !1 }), T && m(V, T);
          })(F, W), te = F, ee = [{ key: "$init", value: function(V, T) {
            z(V), p(F, "set", this, 3)([V, T]), T != null && T.$isSingleNested && (T.$basePath = this.$__path + "." + V, this.$__pathRelativeToParent != null ? T.$pathRelativeToParent = this.$__pathRelativeToParent + "." + V : T.$pathRelativeToParent = this.$__path + "." + V);
          } }, { key: "$__set", value: function(V, T) {
            p(F, "set", this, 3)([V, T]);
          } }, { key: "get", value: function(V, T) {
            return j(V, "ObjectId") && (V = V.toString()), (T = T || {}).getters === !1 ? p(F, "get", this, 3)([V]) : this.$__schemaType.applyGetters(p(F, "get", this, 3)([V]), this.$__parent);
          } }, { key: "set", value: function(V, T) {
            if (j(V, "ObjectId") && (V = V.toString()), z(V), T = O(T), this.$__schemaType == null) return this.$__deferred = this.$__deferred || [], void this.$__deferred.push({ key: V, value: T });
            var D, L, M = this.$__parent, N = M != null && M.$__ && M.$__.populated ? M.$populated(ie.call(this), !0) || M.$populated(this.$__path, !0) : null, Z = this.get(V);
            if (N != null) {
              if (this.$__schemaType.$isSingleNested) throw new b("Cannot manually populate single nested subdoc underneath Map " + 'at path "'.concat(this.$__path, '". Try using an array instead of a Map.'));
              Array.isArray(T) && this.$__schemaType.$isMongooseArray ? T = T.map(function(le) {
                return le.$__ == null && (le = new N.options[R](le)), le.$__.wasPopulated = { value: le._doc._id }, le;
              }) : T != null && (T.$__ == null && (T = new N.options[R](T)), T.$__.wasPopulated = { value: T._doc._id });
            } else try {
              var Y = null;
              (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested || this.$__schemaType.$isMongooseArray || this.$__schemaType.$isSchemaMap) && (Y = { path: ie.call(this) }, this.$__schemaType.$isSingleNested && (Y.pathRelativeToParent = this.$__pathRelativeToParent != null ? this.$__pathRelativeToParent + "." + V : this.$__path + "." + V)), T = this.$__schemaType.applySetters(T, this.$__parent, !1, this.get(V), Y);
            } catch (le) {
              if (this.$__parent != null && this.$__parent.$__ != null) return void this.$__parent.invalidate(ie.call(this), le);
              throw le;
            }
            function ie() {
              return D || (D = this.$__path + "." + V);
            }
            p(F, "set", this, 3)([V, T]), T != null && T.$isSingleNested && (this.$__pathRelativeToParent != null ? T.$pathRelativeToParent = this.$__pathRelativeToParent + "." + V : T.$pathRelativeToParent = this.$__path + "." + V), M == null || M.$__ == null || A(T, Z) || (L = this.$__pathRelativeToParent != null ? this.$__pathRelativeToParent + "." + V : ie.call(this), M.markModified(L), (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested) && P(M, L));
          } }, { key: "clear", value: function() {
            p(F, "clear", this, 3)([]);
            var V = this.$__parent;
            V?.markModified(this.$__path);
          } }, { key: "delete", value: function(V) {
            return j(V, "ObjectId") && (V = V.toString()), this.set(V, void 0), p(F, "delete", this, 3)([V]);
          } }, { key: "toBSON", value: function() {
            return new Map(this);
          } }, { key: "toObject", value: function(V) {
            if (V && V.flattenMaps) {
              var T, D = {}, L = c(this.keys());
              try {
                for (L.s(); !(T = L.n()).done; ) {
                  var M = T.value;
                  D[M] = w(this.get(M), V);
                }
              } catch (N) {
                L.e(N);
              } finally {
                L.f();
              }
              return D;
            }
            return new Map(this);
          } }, { key: "$toObject", value: function() {
            return this.constructor.prototype.toObject.apply(this, arguments);
          } }, { key: "toJSON", value: function(V) {
            if (typeof (V && V.flattenMaps) != "boolean" || V.flattenMaps) {
              var T, D = {}, L = c(this.keys());
              try {
                for (L.s(); !(T = L.n()).done; ) {
                  var M = T.value;
                  D[M] = w(this.get(M), V);
                }
              } catch (N) {
                L.e(N);
              } finally {
                L.f();
              }
              return D;
            }
            return new Map(this);
          } }, { key: "inspect", value: function() {
            return new Map(this);
          } }, { key: "$__runDeferred", value: function() {
            if (this.$__deferred) {
              var V, T = c(this.$__deferred);
              try {
                for (T.s(); !(V = T.n()).done; ) {
                  var D = V.value;
                  this.set(D.key, D.value);
                }
              } catch (L) {
                T.e(L);
              } finally {
                T.f();
              }
              this.$__deferred = null;
            }
          } }], ee && h(te.prototype, ee), Object.defineProperty(te, "prototype", { writable: !1 }), te;
          var te, ee;
        })(d(Map));
        function z(W) {
          var F = u(W);
          if (F !== "string") throw new TypeError("Mongoose maps only support string keys, got ".concat(F));
          if (W.startsWith("$")) throw new Error('Mongoose maps do not support keys that start with "$", got "'.concat(W, '"'));
          if (W.includes(".")) throw new Error('Mongoose maps do not support keys that contain ".", got "'.concat(W, '"'));
          if (k.has(W)) throw new Error('Mongoose maps do not support reserved key name "'.concat(W, '"'));
        }
        $.inspect.custom && Object.defineProperty(I.prototype, $.inspect.custom, { enumerable: !1, writable: !1, configurable: !1, value: I.prototype.inspect }), Object.defineProperty(I.prototype, "$__set", { enumerable: !1, writable: !0, configurable: !1 }), Object.defineProperty(I.prototype, "$__parent", { enumerable: !1, writable: !0, configurable: !1 }), Object.defineProperty(I.prototype, "$__path", { enumerable: !1, writable: !0, configurable: !1 }), Object.defineProperty(I.prototype, "$__schemaType", { enumerable: !1, writable: !0, configurable: !1 }), Object.defineProperty(I.prototype, "$isMongooseMap", { enumerable: !1, writable: !1, configurable: !1, value: !0 }), Object.defineProperty(I.prototype, "$__deferredCalls", { enumerable: !1, writable: !1, configurable: !1, value: !0 }), o.exports = I;
      }, 2097: (o, s, a) => {
        function u(g) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
            return typeof _;
          } : function(_) {
            return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
          }, u(g);
        }
        function c(g, _) {
          (_ == null || _ > g.length) && (_ = g.length);
          for (var b = 0, w = Array(_); b < _; b++) w[b] = g[b];
          return w;
        }
        function f(g, _, b) {
          return (_ = (function(w) {
            var A = (function(E) {
              if (u(E) != "object" || !E) return E;
              var O = E[Symbol.toPrimitive];
              if (O !== void 0) {
                var $ = O.call(E, "string");
                if (u($) != "object") return $;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(E);
            })(w);
            return u(A) == "symbol" ? A : A + "";
          })(_)) in g ? Object.defineProperty(g, _, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : g[_] = b, g;
        }
        var h = a(9166), y = a(1824), p = a(3703), l = a(3696), d = a(1505), v = a(7160), m = /* @__PURE__ */ new Set(["replaceOne", "findOneAndReplace"]);
        o.exports = function(g, _) {
          var b = g.childSchemas.find(function(R) {
            return !!R.schema.options.timestamps;
          });
          if (_ || b) {
            var w = l(_, "createdAt"), A = l(_, "updatedAt"), E = _ != null && _.hasOwnProperty("currentTime") ? _.currentTime : null, O = {};
            if (g.$timestamps = { createdAt: w, updatedAt: A }, w && !g.paths[w]) {
              var $ = g.base != null ? g.base.get("timestamps.createdAt.immutable") : null, k = $ == null || $;
              O[w] = f(f({}, g.options.typeKey || "type", Date), "immutable", k);
            }
            A && !g.paths[A] && (O[A] = Date), g.add(O), g.pre("save", function(R) {
              var I = p(this, "$__.saveOptions.timestamps");
              if (I === !1) return R();
              d(this, I, E, w, A), R();
            }), g.methods.initializeTimestamps = function() {
              var R = E != null ? E() : this.constructor.base.now();
              if (w && !this.get(w) && this.$set(w, R), A && !this.get(A) && this.$set(A, R), this.$isSubdocument) return this;
              var I, z = (function(F, te) {
                var ee = typeof Symbol < "u" && F[Symbol.iterator] || F["@@iterator"];
                if (!ee) {
                  if (Array.isArray(F) || (ee = (function(N, Z) {
                    if (N) {
                      if (typeof N == "string") return c(N, Z);
                      var Y = {}.toString.call(N).slice(8, -1);
                      return Y === "Object" && N.constructor && (Y = N.constructor.name), Y === "Map" || Y === "Set" ? Array.from(N) : Y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Y) ? c(N, Z) : void 0;
                    }
                  })(F)) || te) {
                    ee && (F = ee);
                    var V = 0, T = function() {
                    };
                    return { s: T, n: function() {
                      return V >= F.length ? { done: !0 } : { done: !1, value: F[V++] };
                    }, e: function(N) {
                      throw N;
                    }, f: T };
                  }
                  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                }
                var D, L = !0, M = !1;
                return { s: function() {
                  ee = ee.call(F);
                }, n: function() {
                  var N = ee.next();
                  return L = N.done, N;
                }, e: function(N) {
                  M = !0, D = N;
                }, f: function() {
                  try {
                    L || ee.return == null || ee.return();
                  } finally {
                    if (M) throw D;
                  }
                } };
              })(this.$getAllSubdocs());
              try {
                for (z.s(); !(I = z.n()).done; ) {
                  var W = I.value;
                  W.initializeTimestamps && W.initializeTimestamps();
                }
              } catch (F) {
                z.e(F);
              } finally {
                z.f();
              }
              return this;
            }, P[v.builtInMiddleware] = !0;
            var j = { query: !0, model: !1 };
            g.pre("findOneAndReplace", j, P), g.pre("findOneAndUpdate", j, P), g.pre("replaceOne", j, P), g.pre("update", j, P), g.pre("updateOne", j, P), g.pre("updateMany", j, P);
          }
          function P(R) {
            var I = E != null ? E() : this.model.base.now();
            m.has(this.op) && this.getUpdate() == null && this.setUpdate({}), y(I, w, A, this.getUpdate(), this._mongooseOptions, m.has(this.op)), h(I, this.getUpdate(), this.model.schema), R();
          }
        };
      }, 2134: (o, s, a) => {
        var u = a(5832).hp;
        function c(j) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(P) {
            return typeof P;
          } : function(P) {
            return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
          }, c(j);
        }
        function f(j, P) {
          var R = Object.keys(j);
          if (Object.getOwnPropertySymbols) {
            var I = Object.getOwnPropertySymbols(j);
            P && (I = I.filter(function(z) {
              return Object.getOwnPropertyDescriptor(j, z).enumerable;
            })), R.push.apply(R, I);
          }
          return R;
        }
        function h(j) {
          for (var P = 1; P < arguments.length; P++) {
            var R = arguments[P] != null ? arguments[P] : {};
            P % 2 ? f(Object(R), !0).forEach(function(I) {
              y(j, I, R[I]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(j, Object.getOwnPropertyDescriptors(R)) : f(Object(R)).forEach(function(I) {
              Object.defineProperty(j, I, Object.getOwnPropertyDescriptor(R, I));
            });
          }
          return j;
        }
        function y(j, P, R) {
          return (P = (function(I) {
            var z = (function(W) {
              if (c(W) != "object" || !W) return W;
              var F = W[Symbol.toPrimitive];
              if (F !== void 0) {
                var te = F.call(W, "string");
                if (c(te) != "object") return te;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(W);
            })(I);
            return c(z) == "symbol" ? z : z + "";
          })(P)) in j ? Object.defineProperty(j, P, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : j[P] = R, j;
        }
        var p = a(6365), l = a(6426), d = l.CastError, v = a(8250), m = a(4327), g = a(8768), _ = a(9460), b = v.UUID_FORMAT, w = p.Binary;
        function A(j) {
          var P;
          return typeof j != "string" && j != null ? (P = j.toString("hex")).substring(0, 8) + "-" + P.substring(8, 12) + "-" + P.substring(12, 16) + "-" + P.substring(16, 20) + "-" + P.substring(20, 32) : j;
        }
        function E(j, P) {
          l.call(this, j, P, "UUID"), this.getters.push(function(R) {
            return R != null && R.$__ != null ? R : u.isBuffer(R) ? A(R) : R instanceof w ? A(R.buffer) : g.isPOJO(R) && R.type === "Buffer" && Array.isArray(R.data) ? A(u.from(R.data)) : R;
          });
        }
        function O(j) {
          return this.cast(j);
        }
        function $(j) {
          var P = this;
          return j.map(function(R) {
            return P.cast(R);
          });
        }
        E.schemaName = "UUID", E.defaultOptions = {}, E.prototype = Object.create(l.prototype), E.prototype.constructor = E, E._cast = v, E.get = l.get, E.set = l.set, E.setters = [], E.cast = function(j) {
          return arguments.length === 0 || (j === !1 && (j = this._defaultCaster), this._cast = j), this._cast;
        }, E._checkRequired = function(j) {
          return j != null;
        }, E.checkRequired = l.checkRequired, E.prototype.checkRequired = function(j) {
          return u.isBuffer(j) && (j = A(j)), j != null && b.test(j);
        }, E.prototype.cast = function(j, P, R, I, z) {
          if (g.isNonBuiltinObject(j) && l._isRef(this, j, P, R)) return this._castRef(j, P, R, z);
          var W;
          W = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : E.cast();
          try {
            return W(j);
          } catch (F) {
            throw new d(E.schemaName, j, this.path, F, this);
          }
        };
        var k = h(h({}, l.prototype.$conditionalHandlers), {}, { $bitsAllClear: _, $bitsAnyClear: _, $bitsAllSet: _, $bitsAnySet: _, $all: $, $gt: O, $gte: O, $in: $, $lt: O, $lte: O, $ne: O, $nin: $ });
        Object.defineProperty(E.prototype, "$conditionalHandlers", { enumerable: !1, value: k }), E.prototype.castForQuery = function(j, P, R) {
          var I;
          if (j != null) {
            if (!(I = this.$conditionalHandlers[j])) throw new Error("Can't use " + j + " with UUID.");
            return I.call(this, P, R);
          }
          try {
            return this.applySetters(P, R);
          } catch (z) {
            throw z instanceof d && z.path === this.path && this.$fullPath != null && (z.path = this.$fullPath), z;
          }
        }, E.prototype.toJSONSchema = function(j) {
          var P = this.options.required && typeof this.options.required != "function";
          return m("string", "binData", j?.useBsonType, P);
        }, E.prototype.autoEncryptionType = function() {
          return "binData";
        }, o.exports = E;
      }, 2151: (o) => {
        o.exports = Math.round;
      }, 2268: (o) => {
        o.exports = TypeError;
      }, 2273: (o, s, a) => {
        function u(m) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, u(m);
        }
        var c = a(668), f = typeof Symbol == "function" && u(Symbol("foo")) === "symbol", h = Object.prototype.toString, y = Array.prototype.concat, p = a(6750), l = a(3191)(), d = function(m, g, _, b) {
          if (g in m) {
            if (b === !0) {
              if (m[g] === _) return;
            } else if (typeof (w = b) != "function" || h.call(w) !== "[object Function]" || !b()) return;
          }
          var w;
          l ? p(m, g, _, !0) : p(m, g, _);
        }, v = function(m, g) {
          var _ = arguments.length > 2 ? arguments[2] : {}, b = c(g);
          f && (b = y.call(b, Object.getOwnPropertySymbols(g)));
          for (var w = 0; w < b.length; w += 1) d(m, b[w], g[b[w]], _[b[w]]);
        };
        v.supportsDescriptors = !!l, o.exports = v;
      }, 2307: (o, s, a) => {
        var u = a(5832).hp;
        function c(O, $) {
          var k = Object.keys(O);
          if (Object.getOwnPropertySymbols) {
            var j = Object.getOwnPropertySymbols(O);
            $ && (j = j.filter(function(P) {
              return Object.getOwnPropertyDescriptor(O, P).enumerable;
            })), k.push.apply(k, j);
          }
          return k;
        }
        function f(O) {
          for (var $ = 1; $ < arguments.length; $++) {
            var k = arguments[$] != null ? arguments[$] : {};
            $ % 2 ? c(Object(k), !0).forEach(function(j) {
              h(O, j, k[j]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(O, Object.getOwnPropertyDescriptors(k)) : c(Object(k)).forEach(function(j) {
              Object.defineProperty(O, j, Object.getOwnPropertyDescriptor(k, j));
            });
          }
          return O;
        }
        function h(O, $, k) {
          return ($ = (function(j) {
            var P = (function(R) {
              if (y(R) != "object" || !R) return R;
              var I = R[Symbol.toPrimitive];
              if (I !== void 0) {
                var z = I.call(R, "string");
                if (y(z) != "object") return z;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(R);
            })(j);
            return y(P) == "symbol" ? P : P + "";
          })($)) in O ? Object.defineProperty(O, $, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : O[$] = k, O;
        }
        function y(O) {
          return y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function($) {
            return typeof $;
          } : function($) {
            return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $;
          }, y(O);
        }
        var p = a(6365), l = a(2945), d = a(6426), v = a(4327), m = a(9460), g = a(8768), _ = p.Binary, b = d.CastError;
        function w(O, $) {
          d.call(this, O, $, "Buffer");
        }
        function A(O, $) {
          return this.castForQuery(null, O, $);
        }
        w.schemaName = "Buffer", w.defaultOptions = {}, w.prototype = Object.create(d.prototype), w.prototype.constructor = w, w.prototype.OptionsConstructor = l, w._checkRequired = function(O) {
          return !(!O || !O.length);
        }, w.set = d.set, w.setters = [], w.get = d.get, w.checkRequired = d.checkRequired, w.prototype.checkRequired = function(O, $) {
          return d._isRef(this, O, $, !0) ? !!O : this.constructor._checkRequired(O);
        }, w.prototype.cast = function(O, $, k, j, P) {
          var R;
          if (d._isRef(this, O, $, k)) {
            if (O && O.isMongooseBuffer) return O;
            if (u.isBuffer(O)) return O && O.isMongooseBuffer || (O = new p(O, [this.path, $]), this.options.subtype != null && (O._subtype = this.options.subtype)), O;
            if (O instanceof _) {
              if (R = new p(O.value(!0), [this.path, $]), typeof O.sub_type != "number") throw new b("Buffer", O, this.path, null, this);
              return R._subtype = O.sub_type, R;
            }
            if (O == null || g.isNonBuiltinObject(O)) return this._castRef(O, $, k, P);
          }
          if (O && O._id && (O = O._id), O && O.isMongooseBuffer) return O;
          if (u.isBuffer(O)) return O && O.isMongooseBuffer || (O = new p(O, [this.path, $]), this.options.subtype != null && (O._subtype = this.options.subtype)), O;
          if (O instanceof _) {
            if (R = new p(O.value(!0), [this.path, $]), typeof O.sub_type != "number") throw new b("Buffer", O, this.path, null, this);
            return R._subtype = O.sub_type, R;
          }
          if (O === null) return O;
          var I = y(O);
          if (I === "string" || I === "number" || Array.isArray(O) || I === "object" && O.type === "Buffer" && Array.isArray(O.data)) return I === "number" && (O = [O]), R = new p(O, [this.path, $]), this.options.subtype != null && (R._subtype = this.options.subtype), R;
          if (g.isPOJO(O) && (O.$binary instanceof _ || typeof O.$binary == "string")) {
            var z = this.cast(u.from(O.$binary, "base64"));
            if (O.$type != null) return z._subtype = O.$type, z;
          }
          throw new b("Buffer", O, this.path, null, this);
        }, w.prototype.subtype = function(O) {
          return this.options.subtype = O, this;
        };
        var E = f(f({}, d.prototype.$conditionalHandlers), {}, { $bitsAllClear: m, $bitsAnyClear: m, $bitsAllSet: m, $bitsAnySet: m, $gt: A, $gte: A, $lt: A, $lte: A });
        Object.defineProperty(w.prototype, "$conditionalHandlers", { enumerable: !1, value: E }), w.prototype.castForQuery = function(O, $, k) {
          var j, P;
          if (O != null) {
            if (!(j = this.$conditionalHandlers[O])) throw new Error("Can't use " + O + " with Buffer.");
            return j.call(this, $);
          }
          try {
            P = this.applySetters($, k);
          } catch (R) {
            throw R instanceof b && R.path === this.path && this.$fullPath != null && (R.path = this.$fullPath), R;
          }
          return P && P.toObject({ transform: !1, virtuals: !1 });
        }, w.prototype.toJSONSchema = function(O) {
          var $ = this.options.required && typeof this.options.required != "function";
          return v("string", "binData", O?.useBsonType, $);
        }, w.prototype.autoEncryptionType = function() {
          return "binData";
        }, o.exports = w;
      }, 2345: (o, s, a) => {
        function u(E, O) {
          var $ = Object.keys(E);
          if (Object.getOwnPropertySymbols) {
            var k = Object.getOwnPropertySymbols(E);
            O && (k = k.filter(function(j) {
              return Object.getOwnPropertyDescriptor(E, j).enumerable;
            })), $.push.apply($, k);
          }
          return $;
        }
        function c(E) {
          for (var O = 1; O < arguments.length; O++) {
            var $ = arguments[O] != null ? arguments[O] : {};
            O % 2 ? u(Object($), !0).forEach(function(k) {
              f(E, k, $[k]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors($)) : u(Object($)).forEach(function(k) {
              Object.defineProperty(E, k, Object.getOwnPropertyDescriptor($, k));
            });
          }
          return E;
        }
        function f(E, O, $) {
          return (O = (function(k) {
            var j = (function(P) {
              if (h(P) != "object" || !P) return P;
              var R = P[Symbol.toPrimitive];
              if (R !== void 0) {
                var I = R.call(P, "string");
                if (h(I) != "object") return I;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(P);
            })(k);
            return h(j) == "symbol" ? j : j + "";
          })(O)) in E ? Object.defineProperty(E, O, { value: $, enumerable: !0, configurable: !0, writable: !0 }) : E[O] = $, E;
        }
        function h(E) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
            return typeof O;
          } : function(O) {
            return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
          }, h(E);
        }
        var y = a(3672), p = a(3731), l = a(6426), d = a(2477), v = a(4327), m = a(8260), g = a(8768), _ = l.CastError;
        function b(E, O) {
          l.call(this, E, O, "Date");
        }
        function w(E) {
          return this.cast(E);
        }
        b.schemaName = "Date", b.defaultOptions = {}, b.prototype = Object.create(l.prototype), b.prototype.constructor = b, b.prototype.OptionsConstructor = p, b._cast = d, b.set = l.set, b.setters = [], b.get = l.get, b.cast = function(E) {
          return arguments.length === 0 || (E === !1 && (E = this._defaultCaster), this._cast = E), this._cast;
        }, b._defaultCaster = function(E) {
          if (E != null && !(E instanceof Date)) throw new Error();
          return E;
        }, b.prototype.expires = function(E) {
          return m(this._index) !== "Object" && (this._index = {}), this._index.expires = E, g.expires(this._index), this;
        }, b._checkRequired = function(E) {
          return E instanceof Date;
        }, b.checkRequired = l.checkRequired, b.prototype.checkRequired = function(E, O) {
          return h(E) === "object" && l._isRef(this, E, O, !0) ? E != null : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : b.checkRequired())(E);
        }, b.prototype.min = function(E, O) {
          if (this.minValidator && (this.validators = this.validators.filter(function(j) {
            return j.validator !== this.minValidator;
          }, this)), E) {
            var $ = O || y.messages.Date.min;
            typeof $ == "string" && ($ = $.replace(/{MIN}/, E === Date.now ? "Date.now()" : E.toString()));
            var k = this;
            this.validators.push({ validator: this.minValidator = function(j) {
              var P = E;
              typeof E == "function" && E !== Date.now && (P = P.call(this));
              var R = P === Date.now ? P() : k.cast(P);
              return j === null || j.valueOf() >= R.valueOf();
            }, message: $, type: "min", min: E });
          }
          return this;
        }, b.prototype.max = function(E, O) {
          if (this.maxValidator && (this.validators = this.validators.filter(function(j) {
            return j.validator !== this.maxValidator;
          }, this)), E) {
            var $ = O || y.messages.Date.max;
            typeof $ == "string" && ($ = $.replace(/{MAX}/, E === Date.now ? "Date.now()" : E.toString()));
            var k = this;
            this.validators.push({ validator: this.maxValidator = function(j) {
              var P = E;
              typeof P == "function" && P !== Date.now && (P = P.call(this));
              var R = P === Date.now ? P() : k.cast(P);
              return j === null || j.valueOf() <= R.valueOf();
            }, message: $, type: "max", max: E });
          }
          return this;
        }, b.prototype.cast = function(E) {
          var O;
          O = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : b.cast();
          try {
            return O(E);
          } catch ($) {
            throw new _("date", E, this.path, $, this);
          }
        };
        var A = c(c({}, l.prototype.$conditionalHandlers), {}, { $gt: w, $gte: w, $lt: w, $lte: w });
        Object.defineProperty(b.prototype, "$conditionalHandlers", { enumerable: !1, value: A }), b.prototype.castForQuery = function(E, O, $) {
          if (E == null) try {
            return this.applySetters(O, $);
          } catch (j) {
            throw j instanceof _ && j.path === this.path && this.$fullPath != null && (j.path = this.$fullPath), j;
          }
          var k = this.$conditionalHandlers[E];
          if (!k) throw new Error("Can't use " + E + " with Date.");
          return k.call(this, O);
        }, b.prototype.toJSONSchema = function(E) {
          var O = this.options.required && typeof this.options.required != "function";
          return v("string", "date", E?.useBsonType, O);
        }, b.prototype.autoEncryptionType = function() {
          return "date";
        }, o.exports = b;
      }, 2354: (o, s, a) => {
        var u = a(6730);
        o.exports = Function.prototype.bind || u;
      }, 2400: (o, s, a) => {
        var u = a(5832).hp;
        function c(K) {
          return (function(se) {
            if (Array.isArray(se)) return _(se);
          })(K) || (function(se) {
            if (typeof Symbol < "u" && se[Symbol.iterator] != null || se["@@iterator"] != null) return Array.from(se);
          })(K) || g(K) || (function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })();
        }
        function f() {
          var K, se, me = typeof Symbol == "function" ? Symbol : {}, ge = me.iterator || "@@iterator", _e = me.toStringTag || "@@toStringTag";
          function $e(De, We, Qe, rt) {
            var ot = We && We.prototype instanceof Ie ? We : Ie, Ot = Object.create(ot.prototype);
            return h(Ot, "_invoke", (function(Lt, _t, St) {
              var zt, Et, Nt, wr = 0, fr = St || [], At = !1, Yt = { p: 0, n: 0, v: K, a: He, f: He.bind(K, 4), d: function(kt, Gt) {
                return zt = kt, Et = 0, Nt = K, Yt.n = Gt, Te;
              } };
              function He(kt, Gt) {
                for (Et = kt, Nt = Gt, se = 0; !At && wr && !Bt && se < fr.length; se++) {
                  var Bt, Kt = fr[se], Kr = Yt.p, Ar = Kt[2];
                  kt > 3 ? (Bt = Ar === Gt) && (Nt = Kt[(Et = Kt[4]) ? 5 : (Et = 3, 3)], Kt[4] = Kt[5] = K) : Kt[0] <= Kr && ((Bt = kt < 2 && Kr < Kt[1]) ? (Et = 0, Yt.v = Gt, Yt.n = Kt[1]) : Kr < Ar && (Bt = kt < 3 || Kt[0] > Gt || Gt > Ar) && (Kt[4] = kt, Kt[5] = Gt, Yt.n = Ar, Et = 0));
                }
                if (Bt || kt > 1) return Te;
                throw At = !0, Gt;
              }
              return function(kt, Gt, Bt) {
                if (wr > 1) throw TypeError("Generator is already running");
                for (At && Gt === 1 && He(Gt, Bt), Et = Gt, Nt = Bt; (se = Et < 2 ? K : Nt) || !At; ) {
                  zt || (Et ? Et < 3 ? (Et > 1 && (Yt.n = -1), He(Et, Nt)) : Yt.n = Nt : Yt.v = Nt);
                  try {
                    if (wr = 2, zt) {
                      if (Et || (kt = "next"), se = zt[kt]) {
                        if (!(se = se.call(zt, Nt))) throw TypeError("iterator result is not an object");
                        if (!se.done) return se;
                        Nt = se.value, Et < 2 && (Et = 0);
                      } else Et === 1 && (se = zt.return) && se.call(zt), Et < 2 && (Nt = TypeError("The iterator does not provide a '" + kt + "' method"), Et = 1);
                      zt = K;
                    } else if ((se = (At = Yt.n < 0) ? Nt : Lt.call(_t, Yt)) !== Te) break;
                  } catch (Kt) {
                    zt = K, Et = 1, Nt = Kt;
                  } finally {
                    wr = 1;
                  }
                }
                return { value: se, done: At };
              };
            })(De, Qe, rt), !0), Ot;
          }
          var Te = {};
          function Ie() {
          }
          function qe() {
          }
          function Fe() {
          }
          se = Object.getPrototypeOf;
          var Ne = [][ge] ? se(se([][ge]())) : (h(se = {}, ge, function() {
            return this;
          }), se), fe = Fe.prototype = Ie.prototype = Object.create(Ne);
          function Pe(De) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(De, Fe) : (De.__proto__ = Fe, h(De, _e, "GeneratorFunction")), De.prototype = Object.create(fe), De;
          }
          return qe.prototype = Fe, h(fe, "constructor", Fe), h(Fe, "constructor", qe), qe.displayName = "GeneratorFunction", h(Fe, _e, "GeneratorFunction"), h(fe), h(fe, _e, "Generator"), h(fe, ge, function() {
            return this;
          }), h(fe, "toString", function() {
            return "[object Generator]";
          }), (f = function() {
            return { w: $e, m: Pe };
          })();
        }
        function h(K, se, me, ge) {
          var _e = Object.defineProperty;
          try {
            _e({}, "", {});
          } catch {
            _e = 0;
          }
          h = function($e, Te, Ie, qe) {
            function Fe(Ne, fe) {
              h($e, Ne, function(Pe) {
                return this._invoke(Ne, fe, Pe);
              });
            }
            Te ? _e ? _e($e, Te, { value: Ie, enumerable: !qe, configurable: !qe, writable: !qe }) : $e[Te] = Ie : (Fe("next", 0), Fe("throw", 1), Fe("return", 2));
          }, h(K, se, me, ge);
        }
        function y(K, se, me, ge, _e, $e, Te) {
          try {
            var Ie = K[$e](Te), qe = Ie.value;
          } catch (Fe) {
            return void me(Fe);
          }
          Ie.done ? se(qe) : Promise.resolve(qe).then(ge, _e);
        }
        function p(K) {
          return function() {
            var se = this, me = arguments;
            return new Promise(function(ge, _e) {
              var $e = K.apply(se, me);
              function Te(qe) {
                y($e, ge, _e, Te, Ie, "next", qe);
              }
              function Ie(qe) {
                y($e, ge, _e, Te, Ie, "throw", qe);
              }
              Te(void 0);
            });
          };
        }
        function l(K, se) {
          var me = Object.keys(K);
          if (Object.getOwnPropertySymbols) {
            var ge = Object.getOwnPropertySymbols(K);
            se && (ge = ge.filter(function(_e) {
              return Object.getOwnPropertyDescriptor(K, _e).enumerable;
            })), me.push.apply(me, ge);
          }
          return me;
        }
        function d(K) {
          for (var se = 1; se < arguments.length; se++) {
            var me = arguments[se] != null ? arguments[se] : {};
            se % 2 ? l(Object(me), !0).forEach(function(ge) {
              v(K, ge, me[ge]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(K, Object.getOwnPropertyDescriptors(me)) : l(Object(me)).forEach(function(ge) {
              Object.defineProperty(K, ge, Object.getOwnPropertyDescriptor(me, ge));
            });
          }
          return K;
        }
        function v(K, se, me) {
          return (se = (function(ge) {
            var _e = (function($e) {
              if (b($e) != "object" || !$e) return $e;
              var Te = $e[Symbol.toPrimitive];
              if (Te !== void 0) {
                var Ie = Te.call($e, "string");
                if (b(Ie) != "object") return Ie;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String($e);
            })(ge);
            return b(_e) == "symbol" ? _e : _e + "";
          })(se)) in K ? Object.defineProperty(K, se, { value: me, enumerable: !0, configurable: !0, writable: !0 }) : K[se] = me, K;
        }
        function m(K, se) {
          var me = typeof Symbol < "u" && K[Symbol.iterator] || K["@@iterator"];
          if (!me) {
            if (Array.isArray(K) || (me = g(K)) || se) {
              me && (K = me);
              var ge = 0, _e = function() {
              };
              return { s: _e, n: function() {
                return ge >= K.length ? { done: !0 } : { done: !1, value: K[ge++] };
              }, e: function(qe) {
                throw qe;
              }, f: _e };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var $e, Te = !0, Ie = !1;
          return { s: function() {
            me = me.call(K);
          }, n: function() {
            var qe = me.next();
            return Te = qe.done, qe;
          }, e: function(qe) {
            Ie = !0, $e = qe;
          }, f: function() {
            try {
              Te || me.return == null || me.return();
            } finally {
              if (Ie) throw $e;
            }
          } };
        }
        function g(K, se) {
          if (K) {
            if (typeof K == "string") return _(K, se);
            var me = {}.toString.call(K).slice(8, -1);
            return me === "Object" && K.constructor && (me = K.constructor.name), me === "Map" || me === "Set" ? Array.from(K) : me === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(me) ? _(K, se) : void 0;
          }
        }
        function _(K, se) {
          (se == null || se > K.length) && (se = K.length);
          for (var me = 0, ge = Array(se); me < se; me++) ge[me] = K[me];
          return ge;
        }
        function b(K) {
          return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(se) {
            return typeof se;
          } : function(se) {
            return se && typeof Symbol == "function" && se.constructor === Symbol && se !== Symbol.prototype ? "symbol" : typeof se;
          }, b(K);
        }
        var w, A, E, O = a(1417), $ = a(3550).EventEmitter, k = a(4224), j = a(6365), P = a(3672), R = a(5022), I = a(6140), z = a(3441), W = a(1350), F = a(1635), te = a(7058), ee = a(8995), V = a(6949), T = a(9538), D = a(6814), L = a(5335), M = a(4473), N = a(4450), Z = a(2068).w, Y = a(2068).X, ie = a(1226), le = a(7430).B, de = a(5152), ae = a(791), ne = a(2692), he = a(3216), x = a(2746), U = a(3305), B = a(7300), J = a(1793), X = a(5188), oe = a(7352).inspect, ye = a(3303)._, q = a(1849), G = a(6451), ce = a(5678), ue = a(6223), re = a(3892), pe = a(8768), xe = a(542), be = pe.deepEqual, Ee = pe.isMongooseObject, Ue = a(7930).arrayAtomicsBackupSymbol, Ae = a(7930).arrayAtomicsSymbol, Me = a(7930).documentArrayParent, et = a(7930).documentIsModified, lt = a(7930).documentModifiedPaths, ft = a(7930).documentSchemaSymbol, Ke = a(7930).getSymbol, Xt = a(7930).modelSymbol, $t = a(7930).populateModelSymbol, Pt = a(7930).scopeSymbol, Tt = a(7160).schemaMixedSymbol, Ft = a(5346), xt = a(7930).sessionNewDocuments, ir = pe.specialProperties;
        function Le(K, se, me, ge) {
          if (b(me) === "object" && me != null && (me = (ge = me).skipId), ge = Object.assign({}, ge), this.$__schema == null) {
            var _e = pe.isObject(se) && !se.instanceOfSchema ? new te(se) : se;
            this.$__setSchema(_e), se = me, me = ge, ge = arguments[4] || {};
          }
          if (this.$__ = new k(), ge.isNew != null && ge.isNew !== !0 && (this.$isNew = ge.isNew), ge.priorDoc != null && (this.$__.priorDoc = ge.priorDoc), me && (this.$__.skipId = me), K != null && b(K) !== "object") throw new W(K, "obj", "Document");
          var $e = !0;
          ge.defaults !== void 0 && (this.$__.defaults = ge.defaults, $e = ge.defaults);
          var Te = this.$__schema;
          typeof se == "boolean" || se === "throw" ? (se !== !0 && (this.$__.strictMode = se), se = void 0) : Te.options.strict !== !0 && (this.$__.strictMode = Te.options.strict);
          var Ie, qe = m(Te.requiredPaths(!0));
          try {
            for (qe.s(); !(Ie = qe.n()).done; ) {
              var Fe = Ie.value;
              this.$__.activePaths.require(Fe);
            }
          } catch (De) {
            qe.e(De);
          } finally {
            qe.f();
          }
          var Ne = null;
          pe.isPOJO(se) && Object.keys(se).length > 0 && (Ne = J(se), this.$__.selected = se, this.$__.exclude = Ne);
          var fe = Ne === !1 && se ? D(se) : null;
          if (this._doc == null && (this.$__buildDoc(K, se, me, Ne, fe, !1), $e && L(this, se, Ne, fe, !0, null, { skipParentChangeTracking: !0 })), K && (this.$__original_set ? this.$__original_set(K, void 0, !0, ge) : this.$set(K, void 0, !0, ge), K instanceof Le && (this.$isNew = K.$isNew)), ge.willInit && $e ? ge.skipDefaults && (this.$__.skipDefaults = ge.skipDefaults) : $e && L(this, se, Ne, fe, !1, ge.skipDefaults), !this.$__.strictMode && K) {
            var Pe = this;
            Object.keys(this._doc).forEach(function(De) {
              De in Te.tree || De in Te.methods || De in Te.virtuals || De.startsWith("$") || Y({ prop: De, subprops: null, prototype: Pe });
            });
          }
          (function(De) {
            var We = De.$__schema && De.$__schema.callQueue;
            if (We.length) {
              var Qe, rt = m(We);
              try {
                for (rt.s(); !(Qe = rt.n()).done; ) {
                  var ot = Qe.value;
                  ot[0] !== "pre" && ot[0] !== "post" && ot[0] !== "on" && De[ot[0]].apply(De, ot[1]);
                }
              } catch (Ot) {
                rt.e(Ot);
              } finally {
                rt.f();
              }
            }
          })(this);
        }
        for (var Pr in Le.prototype.$isMongooseDocumentPrototype = !0, Object.defineProperty(Le.prototype, "isNew", { get: function() {
          return this.$isNew;
        }, set: function(K) {
          this.$isNew = K;
        } }), Object.defineProperty(Le.prototype, "errors", { get: function() {
          return this.$errors;
        }, set: function(K) {
          this.$errors = K;
        } }), Le.prototype.$isNew = !0, pe.each(["on", "once", "emit", "listeners", "removeListener", "setMaxListeners", "removeAllListeners", "addListener"], function(K) {
          Le.prototype[K] = function() {
            if (!this.$__.emitter) {
              if (K === "emit") return;
              this.$__.emitter = new $(), this.$__.emitter.setMaxListeners(0);
            }
            return this.$__.emitter[K].apply(this.$__.emitter, arguments);
          }, Le.prototype["$".concat(K)] = Le.prototype[K];
        }), Le.prototype.constructor = Le, $.prototype) Le[Pr] = $.prototype[Pr];
        function It(K, se, me) {
          if (K != null) for (var ge = Object.keys(me.$__schema.paths), _e = ge.length, $e = se.indexOf(".") === -1 ? [se] : se.split("."), Te = 0; Te < _e; ++Te) {
            var Ie = "", qe = ge[Te];
            if (qe.startsWith(se + ".")) {
              var Fe = me.$__schema.paths[qe], Ne = Fe.splitPath().slice($e.length), fe = Ne.length;
              if (Fe.defaultValue !== void 0) for (var Pe = K, De = 0; De < fe && Pe != null; ++De) {
                var We = Ne[De];
                if (De === fe - 1) {
                  if (Pe[We] !== void 0) break;
                  try {
                    var Qe = Fe.getDefault(me, !1);
                    Qe !== void 0 && (Pe[We] = Qe);
                  } catch (rt) {
                    me.invalidate(se + "." + Ie, rt);
                    break;
                  }
                  break;
                }
                Ie += (Ie.length ? "." : "") + We, Pe[We] = Pe[We] || {}, Pe = Pe[We];
              }
            }
          }
        }
        function je(K, se, me, ge, _e) {
          _e = _e || "", se.$__ != null && (se = se._doc);
          for (var $e, Te, Ie, qe = Object.keys(se), Fe = qe.length, Ne = K.$__.strictMode, fe = K.$__schema, Pe = 0; Pe < Fe; ++Pe) if (Ie = qe[Pe], !ir.has(Ie) && (Te = _e ? _e + Ie : Ie, $e = fe.path(Te), !fe.$isRootDiscriminator || K.$__isSelected(Te))) {
            var De = se[Ie];
            if (!$e && pe.isPOJO(De)) me[Ie] || (me[Ie] = {}, Ne || Ie in fe.tree || Ie in fe.methods || Ie in fe.virtuals ? ge != null && ge.virtuals && Ie in fe.virtuals && (K[Ie] = me[Ie]) : K[Ie] = me[Ie]), je(K, De, me[Ie], ge, Te + ".");
            else if ($e) {
              if (me.hasOwnProperty(Ie) && De !== void 0 && !ge.hydratedPopulatedDocs && delete me[Ie], De === null) me[Ie] = $e._castNullish(null);
              else if (De !== void 0) {
                var We = De.$__ == null ? null : De.$__.wasPopulated;
                if (!$e || We || ge.hydratedPopulatedDocs) if ($e && ge.hydratedPopulatedDocs) {
                  var Qe;
                  me[Ie] = $e.cast(De, K, !0, void 0, { hydratedPopulatedDocs: !0 }), me[Ie] && me[Ie].$__ && me[Ie].$__.wasPopulated ? K.$populated(Te, me[Ie].$__.wasPopulated.value, me[Ie].$__.wasPopulated.options) : Array.isArray(me[Ie]) && me[Ie].length && (Qe = me[Ie][0]) !== null && Qe !== void 0 && (Qe = Qe.$__) !== null && Qe !== void 0 && Qe.wasPopulated && K.$populated(Te, me[Ie].map(function(rt) {
                    var ot;
                    return rt == null || (ot = rt.$__) === null || ot === void 0 || (ot = ot.wasPopulated) === null || ot === void 0 ? void 0 : ot.value;
                  }).filter(function(rt) {
                    return rt != null;
                  }), me[Ie][0].$__.wasPopulated.options);
                } else me[Ie] = De;
                else try {
                  ge && ge.setters ? me[Ie] = $e.applySetters(De, K, !1, null, ge) : me[Ie] = $e.cast(De, K, !0, void 0, ge);
                } catch (rt) {
                  K.invalidate(rt.path, new T({ path: rt.path, message: rt.message, type: "cast", value: rt.value, reason: rt }));
                }
              }
              K.$isModified(Te) || K.$__.activePaths.init(Te);
            } else me[Ie] = De, Ne || _e ? ge != null && ge.virtuals && Ie in fe.virtuals && (K[Ie] = De) : K[Ie] = De;
          }
        }
        function qr(K) {
          if (K == null) return !0;
          if (b(K) !== "object" || Array.isArray(K)) return !1;
          for (var se = 0, me = Object.keys(K); se < me.length; se++) if (!qr(K[me[se]])) return !1;
          return !0;
        }
        function Cn(K, se, me, ge) {
          var _e = {};
          (function(pt) {
            var hr = Object.keys(pt.$__.activePaths.getStatePaths("require")), ar = 0, Qt = hr.length;
            for (ar = 0; ar < Qt; ++ar) {
              var qt = hr[ar], Rt = pt.$__schema.path(qt);
              if (Rt != null && typeof Rt.originalRequiredValue == "function") {
                pt.$__.cachedRequired = pt.$__.cachedRequired || {};
                try {
                  pt.$__.cachedRequired[qt] = Rt.originalRequiredValue.call(pt, pt);
                } catch (Ur) {
                  pt.invalidate(qt, Ur);
                }
              }
            }
          })(K);
          var $e = new Set(Object.keys(K.$__.activePaths.getStatePaths("require")).filter(function(pt) {
            return !(!K.$__isSelected(pt) && !K.$isModified(pt)) && !pt.endsWith(".$*") && (K.$__.cachedRequired == null || !(pt in K.$__.cachedRequired) || K.$__.cachedRequired[pt]);
          }));
          function Te(pt) {
            pt.endsWith(".$*") || $e.add(pt);
          }
          if (Object.keys(K.$__.activePaths.getStatePaths("init")).forEach(Te), Object.keys(K.$__.activePaths.getStatePaths("modify")).forEach(Te), Object.keys(K.$__.activePaths.getStatePaths("default")).forEach(Te), !ge) {
            for (var Ie = [], qe = 0, Fe = Object.keys(K.$__schema.paths); qe < Fe.length; qe++) {
              var Ne = Fe[qe], fe = K.$__schema.path(Ne);
              if (fe.$isSingleNested) {
                var Pe = K.$get(Ne);
                Pe && Ie.push(Pe);
              } else if (fe.$isMongooseDocumentArray) {
                var De = K.$get(Ne);
                if (De && De.length) {
                  var We, Qe = m(De);
                  try {
                    for (Qe.s(); !(We = Qe.n()).done; ) {
                      var rt = We.value;
                      rt && Ie.push(rt);
                    }
                  } catch (pt) {
                    Qe.e(pt);
                  } finally {
                    Qe.f();
                  }
                }
              }
            }
            for (var ot = K.modifiedPaths(), Ot = 0, Lt = Ie; Ot < Lt.length; Ot++) {
              var _t = Lt[Ot];
              if (_t.$basePath) {
                var St, zt = _t.$__pathRelativeToParent(), Et = m(_t.modifiedPaths());
                try {
                  for (Et.s(); !(St = Et.n()).done; ) {
                    var Nt = St.value;
                    $e.delete(zt + "." + Nt);
                  }
                } catch (pt) {
                  Et.e(pt);
                } finally {
                  Et.f();
                }
                var wr = _t.$parent();
                if (wr == null) throw new Error("Cannot validate subdocument that does not have a parent");
                !K.$isModified(zt, null, ot) || wr.$__.activePaths.getStatePaths("modify").hasOwnProperty(zt) || wr.$isDefault(zt) || ($e.add(zt), K.$__.pathsToScopes == null && (K.$__.pathsToScopes = {}), K.$__.pathsToScopes[zt] = _t.$isDocumentArrayElement ? _t.__parentArray : _t.$parent(), _e[zt] = { skipSchemaValidators: !0 }, _t.$isDocumentArrayElement && _t.__index != null && (_e[zt].index = _t.__index));
              }
            }
          }
          var fr, At = m($e);
          try {
            for (At.s(); !(fr = At.n()).done; ) {
              var Yt = fr.value, He = K.$__schema.path(Yt);
              if (He) {
                if (He.$isMongooseDocumentArray) {
                  var kt, Gt = m($e);
                  try {
                    for (Gt.s(); !(kt = Gt.n()).done; ) {
                      var Bt = kt.value;
                      (Bt == null || Bt.startsWith(He.path + ".")) && $e.delete(Bt);
                    }
                  } catch (pt) {
                    Gt.e(pt);
                  } finally {
                    Gt.f();
                  }
                }
                (He.caster || He.validators.length !== 0 || He.$parentSchemaDocArray) && (!He.$isMongooseArray || He.$isMongooseDocumentArray || He.$embeddedSchemaType.$isMongooseArray || He.validators.length !== 0 || He.$embeddedSchemaType.validators.length !== 0) || $e.delete(Yt);
              }
            }
          } catch (pt) {
            At.e(pt);
          } finally {
            At.f();
          }
          Array.isArray(se) ? $e = (function(pt, hr) {
            var ar, Qt = new Set(hr), qt = /* @__PURE__ */ new Map([]), Rt = m(hr);
            try {
              for (Rt.s(); !(ar = Rt.n()).done; ) {
                var Ur = ar.value;
                if (Ur.indexOf(".") !== -1) for (var $r = Ur.split("."), xn = $r[0], an = 1; an < $r.length; ++an) qt.set(xn, Ur), xn = xn + "." + $r[an];
              }
            } catch (Ei) {
              Rt.e(Ei);
            } finally {
              Rt.f();
            }
            var ln, sn = /* @__PURE__ */ new Set(), Mr = m(pt);
            try {
              for (Mr.s(); !(ln = Mr.n()).done; ) {
                var bn = ln.value;
                Qt.has(bn) ? sn.add(bn) : qt.has(bn) && sn.add(qt.get(bn));
              }
            } catch (Ei) {
              Mr.e(Ei);
            } finally {
              Mr.f();
            }
            return sn;
          })($e, se) : Array.isArray(me) && ($e = (function(pt, hr) {
            return hr = new Set(hr), pt = Array.from(pt).filter(function(ar) {
              return !hr.has(ar);
            }), new Set(pt);
          })($e, me)), (function(pt, hr) {
            var ar, Qt = m(hr);
            try {
              for (Qt.s(); !(ar = Qt.n()).done; ) {
                var qt = ar.value, Rt = pt.$__schema.path(qt);
                Rt && Rt.$isMongooseArray && (Array.isArray(Rt) || !Rt.$isMongooseDocumentArray || Rt && Rt.schemaOptions && Rt.schemaOptions.required) && (!Rt.$isMongooseArray || Rt.$isMongooseDocumentArray || Rt.$embeddedSchemaType.$isMongooseArray || Rt.$embeddedSchemaType.validators.length !== 0) && Wr(pt.$__getValue(qt), hr, qt);
              }
            } catch (Ur) {
              Qt.e(Ur);
            } finally {
              Qt.f();
            }
          })(K, $e);
          var Kt, Kr = { skipArrays: !0 }, Ar = m($e);
          try {
            for (Ar.s(); !(Kt = Ar.n()).done; ) {
              var Sn = Kt.value;
              if (K.$__schema.nested[Sn]) {
                var cn = K.$__getValue(Sn);
                Ee(cn) && (cn = cn.toObject({ transform: !1 }));
                var En = le(cn, Sn, Kr, K.$__schema);
                Object.keys(En).filter(function(pt) {
                  return !K.$__schema.singleNestedPaths.hasOwnProperty(pt);
                }).forEach(Te);
              }
            }
          } catch (pt) {
            Ar.e(pt);
          } finally {
            Ar.f();
          }
          var vn, nr = m($e);
          try {
            for (nr.s(); !(vn = nr.n()).done; ) {
              var Ir = vn.value, Or = K.$__schema.path(Ir);
              if (Or && (Or.$parentSchemaDocArray && typeof Or.$parentSchemaDocArray.path == "string" && $e.add(Or.$parentSchemaDocArray.path), Or.$isSchemaMap)) {
                var Tr = K.$__getValue(Ir);
                if (Tr != null) {
                  var rr, yr = m(Tr.keys());
                  try {
                    for (yr.s(); !(rr = yr.n()).done; ) {
                      var Hr = rr.value;
                      $e.add(Ir + "." + Hr);
                    }
                  } catch (pt) {
                    yr.e(pt);
                  } finally {
                    yr.f();
                  }
                }
              }
            }
          } catch (pt) {
            nr.e(pt);
          } finally {
            nr.f();
          }
          return [$e = Array.from($e), _e];
        }
        function Wr(K, se, me) {
          if (K != null) for (var ge = K.length, _e = 0; _e < ge; ++_e) Array.isArray(K[_e]) ? Wr(K[_e], se, me + "." + _e) : se.add(me + "." + _e);
        }
        function or(K, se, me, ge) {
          var _e, $e, Te, Ie = K.$__schema, qe = Ie.virtuals, Fe = Object.keys(qe), Ne = Fe.length, fe = Ne, Pe = K._doc, De = typeof (ge && ge.aliases) != "boolean" || ge.aliases;
          me = me || {};
          var We = null;
          if (Array.isArray(me.virtuals)) We = new Set(me.virtuals);
          else if (me.virtuals && me.virtuals.pathsToSkip) {
            We = new Set(Fe);
            for (var Qe = 0; Qe < me.virtuals.pathsToSkip.length; Qe++) We.has(me.virtuals.pathsToSkip[Qe]) && We.delete(me.virtuals.pathsToSkip[Qe]);
          }
          if (!Pe) return se;
          for (Ne = 0; Ne < fe; ++Ne) if (_e = Fe[Ne], (We == null || We.has(_e)) && (De || !Ie.aliases.hasOwnProperty(_e))) {
            if ($e = _e, me.path != null) {
              if (!_e.startsWith(me.path + ".")) continue;
              $e = _e.substring(me.path.length + 1);
            }
            if ($e.indexOf(".") !== -1 || $e !== _e) {
              var rt = $e.split(".");
              if ((Te = N(K.get(_e), me)) !== void 0) {
                var ot = rt.length;
                Pe = se;
                for (var Ot = 0; Ot < ot - 1; ++Ot) Pe[rt[Ot]] = Pe[rt[Ot]] || {}, Pe = Pe[rt[Ot]];
                Pe[rt[ot - 1]] = Te;
              }
            } else {
              if ((Te = qe[_e].applyGetters(void 0, K)) === void 0) continue;
              Te = N(Te, me), se[$e] = Te;
            }
          }
          return se;
        }
        function Gr(K, se) {
          if (xe(se)) throw new Error("`transform` function must be synchronous, but the transform on path `" + K + "` returned a promise.");
        }
        function ti(K, se, me) {
          var ge = K.$populated(se, !0);
          if (!ge && K.$__.selected) {
            var _e = se.split(".")[0];
            if (K.$__.selected[_e + ".$"]) return _e;
          }
          if (ge && pe.isMongooseArray(me) && (ge.options.match || ge.options.options && pe.object.hasOwnProperty(ge.options.options, "limit") || ge.options.options && ge.options.options.skip || ge.options.select && (ge.options.select._id === 0 || /\s?-_id\s?/.test(ge.options.select)))) {
            var $e = me[Ae];
            if (Object.keys($e).length === 0 || $e.$set || $e.$pop) return se;
          }
        }
        function mr(K, se, me, ge, _e, $e) {
          if ($e || ($e = "$set"), me[$e] || (me[$e] = {}), me[$e][ge.path] = _e, K.$__schema.options.versionKey !== !1 && !(function(Te, Ie) {
            var qe = Te.$__schema.options.skipVersioning;
            return !!qe && qe[Ie = Ie.replace(/\.\d+\./, ".")];
          })(K, ge.path) && 3 & ~K.$__.version && !K.$__schema.options.optimisticConcurrency) {
            switch ($e) {
              case "$set":
              case "$unset":
              case "$pop":
              case "$pull":
              case "$pullAll":
              case "$push":
              case "$addToSet":
              case "$inc":
                break;
              default:
                return;
            }
            $e === "$push" || $e === "$addToSet" || $e === "$pullAll" || $e === "$pull" ? /\.\d+\.|\.\d+$/.test(ge.path) ? K.$__.version = 3 : K.$__.version = 2 : /^\$p/.test($e) || Array.isArray(_e) ? K.$__.version = 3 : /\.\d+\.|\.\d+$/.test(ge.path) && (K.$__.version = 1);
          }
        }
        function on(K, se, me, ge, _e) {
          if (!me.$set || !me.$set[ge.path]) if (typeof _e.$__getAtomics != "function") {
            var $e, Te, Ie = _e[Ae], qe = Object.keys(Ie), Fe = qe.length;
            if (Fe === 0) return pe.isMongooseObject(_e) ? _e = _e.toObject({ depopulate: 1, _isNested: !0 }) : _e.valueOf && (_e = _e.valueOf()), mr(K, 0, me, ge, _e);
            for (; Fe--; ) $e = Ie[Te = qe[Fe]], pe.isMongooseObject($e) ? $e = $e.toObject({ depopulate: !0, transform: !1, _isNested: !0 }) : Array.isArray($e) ? $e = $e.map(Ne) : $e.valueOf && ($e = $e.valueOf()), Te === "$addToSet" && ($e = { $each: $e }), mr(K, 0, me, ge, $e, Te);
          } else _e.$__getAtomics().forEach(function(fe) {
            var Pe = fe[0], De = fe[1];
            mr(K, 0, me, ge, De, Pe);
          });
          function Ne(fe) {
            return pe.isMongooseObject(fe) ? fe.toObject({ depopulate: 1, _isNested: !0 }) : fe;
          }
        }
        Le.prototype.$__schema, Le.prototype.schema, Object.defineProperty(Le.prototype, "$locals", { configurable: !1, enumerable: !1, get: function() {
          return this.$__.locals == null && (this.$__.locals = {}), this.$__.locals;
        }, set: function(K) {
          this.$__.locals = K;
        } }), Le.prototype.isNew, Object.defineProperty(Le.prototype, "$where", { configurable: !1, enumerable: !1, writable: !0 }), Le.prototype.id, Le.prototype.$errors, Object.defineProperty(Le.prototype, "$op", { get: function() {
          return this.$__.op || null;
        }, set: function(K) {
          this.$__.op = K;
        } }), Le.prototype.$__buildDoc = function(K, se, me, ge, _e) {
          for (var $e = {}, Te = Object.keys(this.$__schema.paths).filter(function(Ot) {
            return !Ot.includes("$*");
          }), Ie = Te.length, qe = 0; qe < Ie; ++qe) {
            var Fe = Te[qe];
            if (!(Fe === "_id" && (me || K && "_id" in K)))
              for (var Ne = this.$__schema.paths[Fe].splitPath(), fe = Ne.length, Pe = fe - 1, De = "", We = $e, Qe = !1, rt = 0; rt < fe; ++rt) {
                var ot = Ne[rt];
                if (De.length ? De += "." + ot : De = ot, ge === !0) {
                  if (De in se) break;
                } else if (ge === !1 && se && !Qe) {
                  if (De in se) Qe = !0;
                  else if (!_e[De]) break;
                }
                rt < Pe && (We = We[ot] || (We[ot] = {}));
              }
          }
          this._doc = $e;
        }, Le.prototype.toBSON = function() {
          return this.toObject(ye);
        }, Le.prototype.init = function(K, se, me) {
          return typeof se == "function" && (me = se, se = null), this.$__init(K, se), me && me(null, this), this;
        }, Le.prototype.$init = function() {
          return this.constructor.prototype.init.apply(this, arguments);
        }, Le.prototype.$__init = function(K, se) {
          if (this.$isNew = !1, se = se || {}, K._id != null && se.populated && se.populated.length) {
            var me, ge = String(K._id), _e = m(se.populated);
            try {
              for (_e.s(); !(me = _e.n()).done; ) {
                var $e = me.value;
                if ($e.isVirtual ? this.$populated($e.path, pe.getValue($e.path, K), $e) : this.$populated($e.path, $e._docs[ge], $e), $e._childDocs != null) {
                  var Te, Ie = m($e._childDocs);
                  try {
                    for (Ie.s(); !(Te = Ie.n()).done; ) {
                      var qe = Te.value;
                      qe != null && qe.$__ != null && (qe.$__.parent = this);
                    }
                  } catch (Ne) {
                    Ie.e(Ne);
                  } finally {
                    Ie.f();
                  }
                  $e._childDocs = [];
                }
              }
            } catch (Ne) {
              _e.e(Ne);
            } finally {
              _e.f();
            }
          }
          je(this, K, this._doc, se), q(this, se.populated), this.$emit("init", this), this.constructor.emit("init", this);
          var Fe = this.$__.exclude === !1 && this.$__.selected ? D(this.$__.selected) : null;
          return L(this, this.$__.selected, this.$__.exclude, Fe, !1, this.$__.skipDefaults), this;
        }, Le.prototype.updateOne = function(K, se, me) {
          var ge = this.constructor.updateOne({ _id: this._doc._id }, K, se), _e = this;
          return ge.pre(function($e) {
            _e.constructor._middleware.execPre("updateOne", _e, [_e], $e);
          }), ge.post(function($e) {
            _e.constructor._middleware.execPost("updateOne", _e, [_e], {}, $e);
          }), this.$session() != null && ("session" in ge.options || (ge.options.session = this.$session())), me != null ? ge.exec(me) : ge;
        }, Le.prototype.replaceOne = function() {
          var K = Array.prototype.slice.call(arguments);
          return K.unshift({ _id: this._doc._id }), this.constructor.replaceOne.apply(this.constructor, K);
        }, Le.prototype.$session = function(K) {
          if (arguments.length === 0) return this.$__.session != null && this.$__.session.hasEnded ? (this.$__.session = null, null) : this.$__.session;
          if (K != null && K.hasEnded) throw new P("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
          if (K != null || this.$__.session != null) {
            if (this.$__.session = K, !this.$isSubdocument) {
              var se, me = m(this.$getAllSubdocs());
              try {
                for (me.s(); !(se = me.n()).done; ) se.value.$session(K);
              } catch (ge) {
                me.e(ge);
              } finally {
                me.f();
              }
            }
            return K;
          }
        }, Le.prototype.$timestamps = function(K) {
          return arguments.length === 0 ? this.$__.timestamps != null ? this.$__.timestamps : this.$__schema ? this.$__schema.options.timestamps : void 0 : (K !== this.$timestamps() && (this.$__.timestamps = K), this);
        }, Le.prototype.overwrite = function(K) {
          for (var se = 0, me = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(K)))); se < me.length; se++) {
            var ge = me[se];
            ge !== "_id" && (this.$__schema.options.versionKey && ge === this.$__schema.options.versionKey || this.$__schema.options.discriminatorKey && ge === this.$__schema.options.discriminatorKey || this.$set(ge, K[ge]));
          }
          return this;
        }, Le.prototype.$set = function(K, se, me, ge) {
          var _e = this;
          pe.isPOJO(me) && (ge = me, me = void 0);
          var $e, Te, Ie, qe, Fe = ge && ge.merge, Ne = me && me !== !0, fe = me === !0, Pe = 0, De = ge && "strict" in ge, We = De ? ge.strict : this.$__.strictMode;
          if (Ne && ((this.$__.adhocPaths || (this.$__.adhocPaths = {}))[K] = this.$__schema.interpretAsType(K, me, this.$__schema.options)), K == null) {
            var Qe = [se, K];
            K = Qe[0], se = Qe[1];
          } else if (typeof K != "string") {
            if (K instanceof Le && (K = K.$__isNested ? K.toObject() : K.$__schema === this.$__schema ? or(K, d({}, K._doc)) : K._doc), K == null) {
              var rt = [se, K];
              K = rt[0], se = rt[1];
            }
            qe = se ? se + "." : "";
            var ot = ($e = ae(this.$__schema, K)).length, Ot = ge && ge._skipMinimizeTopLevel || !1;
            if (ot === 0 && Ot) return delete ge._skipMinimizeTopLevel, se && this.$set(se, {}), this;
            ge = Object.assign({}, ge, { _skipMinimizeTopLevel: !1 });
            for (var Lt = 0; Lt < ot; ++Lt) {
              Ie = $e[Lt];
              var _t = qe ? qe + Ie : Ie;
              Te = this.$__schema.pathType(_t);
              var St = K[Ie];
              if (me !== !0 || qe || St == null || Te !== "nested" || this._doc[Ie] == null || delete this._doc[Ie], pe.isNonBuiltinObject(St) && Te === "nested") this.$set(_t, St, fe, ge), It(this.$get(_t), _t, this);
              else if (We) {
                if (fe && St === void 0 && this.$get(_t) !== void 0) continue;
                if (Te === "adhocOrUndefined" && (Te = de(this, _t, { typeOnly: !0 })), Te === "real" || Te === "virtual") this.$set(_t, St, fe, ge);
                else if (Te === "nested" && St instanceof Le) this.$set(_t, St.toObject({ transform: !1 }), fe, ge);
                else {
                  if (We === "throw") throw Te === "nested" ? new z(Ie, St) : new ee(Ie);
                  Te === "nested" && St == null && this.$set(_t, St, fe, ge);
                }
              } else this.$set(_t, St, fe, ge);
            }
            for (var zt = {}, Et = Object.keys(this.$__schema.tree), Nt = 0, wr = Et.length; Nt < wr; ++Nt) (Ie = Et[Nt]) && this._doc.hasOwnProperty(Ie) && (zt[Ie] = void 0);
            return this._doc = Object.assign(zt, this._doc), this;
          }
          var fr = this.$__schema.pathType(K), At = null;
          if (fr === "adhocOrUndefined" && (At = K.indexOf(".") === -1 ? [K] : K.split("."), fr = de(this, At, { typeOnly: !0 })), fr === "adhocOrUndefined" && !De) {
            At == null && (At = K.indexOf(".") === -1 ? [K] : K.split("."));
            var Yt = ne(this.$__schema, At);
            Yt !== void 0 && (We = Yt);
          }
          se = he(se, !0);
          var He, kt = _e.$__.priorDoc != null ? _e.$__.priorDoc.$__getValue(K) : fe ? void 0 : _e.$__getValue(K);
          if (fr === "nested" && se) {
            if (b(se) === "object" && se != null) {
              if (se.$__ != null && (se = se.toObject(ye)), se == null) return this.invalidate(K, new P.CastError("Object", se, K)), this;
              var Gt = this.$isModified(K), Bt = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(K);
              if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(K)) {
                var Kt = this.$__getValue(K);
                this.$__.savedState[K] = Kt;
                for (var Kr = 0, Ar = Object.keys(Kt || {}); Kr < Ar.length; Kr++) {
                  var Sn = Ar[Kr];
                  this.$__.savedState[K + "." + Sn] = Kt[Sn];
                }
              }
              if (Fe) return this.$set(se, K, fe, ge);
              this.$__setValue(K, null), M(this, K);
              var cn = ae(this.$__schema, se, K);
              this.$__setValue(K, {});
              var En, vn = m(cn);
              try {
                for (vn.s(); !(En = vn.n()).done; ) {
                  var nr = En.value;
                  this.$set(K + "." + nr, se[nr], fe, d(d({}, ge), {}, { _skipMarkModified: !0 }));
                }
              } catch (Oe) {
                vn.e(Oe);
              } finally {
                vn.f();
              }
              return kt == null || Gt && !Bt || !pe.deepEqual(Bt ? this.$__.savedState[K] : kt, se) ? this.markModified(K) : this.unmarkModified(K), this;
            }
            return this.invalidate(K, new P.CastError("Object", se, K)), this;
          }
          if (At == null && (At = K.indexOf(".") === -1 ? [K] : K.split(".")), typeof this.$__schema.aliases[At[0]] == "string" && (At[0] = this.$__schema.aliases[At[0]]), fr === "adhocOrUndefined" && We) {
            var Ir;
            for (Pe = 0; Pe < At.length; ++Pe) {
              var Or = At.slice(0, Pe + 1).join(".");
              if (Pe + 1 < At.length && this.$__schema.pathType(Or) === "virtual") return ce.set(K, se, this), this;
              if ((He = this.$__schema.path(Or)) != null) {
                if (He instanceof R) {
                  Ir = !0;
                  break;
                }
                if (He.$isSchemaMap && He.$__schemaType instanceof R && Pe < At.length - 1) {
                  Ir = !0, He = He.$__schemaType;
                  break;
                }
              }
            }
            if (He == null && (He = de(this, K)), !Ir && !He) {
              if (We === "throw") throw new ee(K);
              return this;
            }
          } else {
            if (fr === "virtual") return (He = this.$__schema.virtualpath(K)).applySetters(se, this), this;
            He = this.$__path(K);
          }
          var Tr, rr = this._doc, yr = "";
          for (Pe = 0; Pe < At.length - 1; ++Pe) rr = rr instanceof Map ? rr.get(At[Pe]) : rr[At[Pe]], yr += (yr.length !== 0 ? "." : "") + At[Pe], rr || (this.$set(yr, {}), this.$__isSelected(yr) || this.unmarkModified(yr), rr = this.$__getValue(yr));
          if (At.length <= 1) Tr = K;
          else {
            var Hr = At.length;
            for (Pe = 0; Pe < Hr; ++Pe) {
              var pt = At.slice(0, Pe + 1).join(".");
              if (this.$get(pt, null, { getters: !1 }) === null) {
                Tr = pt;
                break;
              }
            }
            Tr || (Tr = K);
          }
          if (!He) return this.$__set(Tr, K, ge, fe, At, He, se, kt), fr === "nested" && se == null && M(this, K), this;
          if ((He.$isSingleNested || He.$isMongooseArray) && (function(Oe, Ve) {
            if (Oe.$__.validationError) {
              for (var Ze = 0, ke = Object.keys(Oe.$__.validationError.errors); Ze < ke.length; Ze++) {
                var ut = ke[Ze];
                ut.startsWith(Ve + ".") && delete Oe.$__.validationError.errors[ut];
              }
              Object.keys(Oe.$__.validationError.errors).length === 0 && (Oe.$__.validationError = null);
            }
          })(this, K), se != null && Fe && He.$isSingleNested) {
            se instanceof Le && (se = se.toObject({ virtuals: !1, transform: !1 }));
            for (var hr = 0, ar = Object.keys(se); hr < ar.length; hr++) {
              var Qt = ar[hr];
              this.$set(K + "." + Qt, se[Qt], fe, ge);
            }
            return this;
          }
          var qt = !0;
          try {
            var Rt, Ur = (function() {
              if (He.options == null || !(se instanceof Le)) return !1;
              var Oe = se.constructor, Ve = typeof He.options.ref != "function" || He.options.ref[Xt] ? He.options.ref : He.options.ref.call(_e, _e), Ze = Ve?.modelName || Ve;
              if (Ze != null && (Ze === Oe.modelName || Ze === Oe.baseModelName)) return !0;
              var ke = He.options.refPath;
              if (ke == null) return !1;
              var ut = se.get(ke);
              return ut === Oe.modelName || ut === Oe.baseModelName;
            })(), $r = !1;
            if (Ur && se instanceof Le && (!se.$__.wasPopulated || pe.deepEqual(se.$__.wasPopulated.value, se._doc._id))) {
              var xn = He && He.$isSingleNested ? He.cast(se, this) : se._doc._id;
              this.$populated(K, xn, v({}, $t, se.constructor)), se.$__.wasPopulated = { value: xn }, $r = !0;
            }
            var an = this.$__schema.options.typeKey;
            if (He.options && Array.isArray(He.options[an]) && He.options[an].length && He.options[an][0] && He.options[an][0].ref && (function(Oe, Ve) {
              if (!Array.isArray(Oe) || Oe.length === 0) return !1;
              var Ze, ke = m(Oe);
              try {
                for (ke.s(); !(Ze = ke.n()).done; ) {
                  var ut = Ze.value;
                  if (!(ut instanceof Le) || ut.constructor.modelName == null || ut.constructor.modelName != Ve && ut.constructor.baseModelName != Ve) return !1;
                }
              } catch (Xe) {
                ke.e(Xe);
              } finally {
                ke.f();
              }
              return !0;
            })(se, He.options[an][0].ref)) {
              Rt = v({}, $t, se[0].constructor), this.$populated(K, se.map(function(Oe) {
                return Oe._doc._id;
              }), Rt);
              var ln, sn = m(se);
              try {
                for (sn.s(); !(ln = sn.n()).done; ) {
                  var Mr = ln.value;
                  Mr.$__.wasPopulated = { value: Mr._doc._id };
                }
              } catch (Oe) {
                sn.e(Oe);
              } finally {
                sn.f();
              }
              $r = !0;
            }
            if (!Ur || !He.$isSingleNested || !se.$__) {
              var bn = this;
              this.$__schema.singleNestedPaths[K] != null && At.length > 1 && (bn = Ft(this, At, this.schema)), se = ge != null && ge.overwriteImmutable ? He.applySetters(se, bn, !1, kt, { path: K, overwriteImmutable: !0 }) : He.applySetters(se, bn, !1, kt, { path: K });
            }
            if (Array.isArray(se) && !Array.isArray(He) && He.$isMongooseDocumentArray && se.length !== 0 && se[0] != null && se[0].$__ != null && se[0].$__.populated != null) {
              for (var Ei = Object.keys(se[0].$__.populated), ds = function() {
                var Oe = ra[Oo];
                _e.$populated(K + "." + Oe, se.map(function(Ve) {
                  return Ve.$populated(Oe);
                }), se[0].$__.populated[Oe].options);
              }, Oo = 0, ra = Ei; Oo < ra.length; Oo++) ds();
              $r = !0;
            }
            if (!$r && this.$__.populated) {
              if (Array.isArray(se) && this.$__.populated[K]) for (var xi = 0; xi < se.length; ++xi) se[xi] instanceof Le && se.set(xi, se[xi]._doc._id, !0);
              delete this.$__.populated[K];
            }
            se != null && He.$isSingleNested && (function(Oe, Ve, Ze) {
              var ke = Ve.schema;
              if (ke != null) for (var ut = 0, Xe = Object.keys(ke.paths); ut < Xe.length; ut++) {
                var Be = Xe[ut], Ye = ke.paths[Be];
                if (Ye.$immutableSetter != null) {
                  var ht = Ze?.$__getValue(Be);
                  Ye.$immutableSetter.call(Oe, ht);
                }
              }
            })(se, He, kt), this.$markValid(K);
          } catch (Oe) {
            Oe instanceof P.StrictModeError && Oe.isImmutableError ? this.invalidate(K, Oe) : Oe instanceof P.CastError ? (this.invalidate(Oe.path, Oe), Oe.$originalErrorPath && this.invalidate(K, new P.CastError(He.instance, se, K, Oe.$originalErrorPath))) : this.invalidate(K, new P.CastError(He.instance, se, K, Oe)), qt = !1;
          }
          if (qt) {
            var na, C = null, S = null;
            if (!fe) {
              var Q = this.$isSubdocument ? this.ownerDocument() : this;
              C = Q.$__.savedState, S = this.$isSubdocument ? this.$__.fullPath + "." + K : K, Q.$__saveInitialState(S);
            }
            this.$__set(Tr, K, ge, fe, At, He, se, kt);
            var H = !((na = this.$__.session) === null || na === void 0 || !na.transaction), Se = this.$__.session && this.$__.session[xt] && this.$__.session[xt].has(this) && this.$__.session[xt].get(this).modifiedPaths && !this.$__.session[xt].get(this).modifiedPaths.has(S);
            C != null && C.hasOwnProperty(S) && (!H || Se) && pe.deepEqual(se, C[S]) && this.unmarkModified(K);
          }
          return (He.$isSingleNested && (this.isDirectModified(K) || se == null) || He.$isSchemaMap && se == null) && M(this, K), this;
        }, Le.prototype.set = Le.prototype.$set, Le.prototype.$__shouldModify = function(K, se, me, ge, _e, $e, Te, Ie) {
          return !(me && me._skipMarkModified || !this.$isNew && !(se in this.$__.activePaths.getStatePaths("modify")) && (Te !== void 0 || this.$__isSelected(se)) && (Te === void 0 && se in this.$__.activePaths.getStatePaths("default") || this.$populated(se) && Te instanceof Le && be(Te._doc._id, Ie) || be(Te, Ie !== void 0 ? Ie : pe.getValue(se, this)) && (ge || Te == null || !(se in this.$__.activePaths.getStatePaths("default")) || !be(Te, $e.getDefault(this, ge)))));
        }, Le.prototype.$__set = function(K, se, me, ge, _e, $e, Te, Ie) {
          E = E || a(6547);
          var qe = this.$__shouldModify(K, se, me, ge, _e, $e, Te, Ie);
          qe ? (this.$__.primitiveAtomics && this.$__.primitiveAtomics[se] && (delete this.$__.primitiveAtomics[se], Object.keys(this.$__.primitiveAtomics).length === 0 && delete this.$__.primitiveAtomics), this.markModified(K), A || (A = a(7557)), Te && pe.isMongooseArray(Te) && (Te._registerAtomic("$set", Te), pe.isMongooseDocumentArray(Te) && Te.forEach(function(rt) {
            rt && rt.__parentArray && (rt.__parentArray = Te);
          }))) : Array.isArray(Te) && Array.isArray(Ie) && pe.isMongooseArray(Te) && pe.isMongooseArray(Ie) && (Te[Ae] = Ie[Ae], Te[Ue] = Ie[Ue], pe.isMongooseDocumentArray(Te) && Te.forEach(function(rt) {
            rt != null && (rt.$isNew = !1);
          }));
          for (var Fe = this._doc, Ne = 0, fe = _e.length, Pe = ""; Ne < fe; Ne++) {
            var De = Ne + 1 === fe;
            if (Pe += Pe ? "." + _e[Ne] : _e[Ne], !ir.has(_e[Ne])) if (De) Fe instanceof Map ? Fe.set(_e[Ne], Te) : Fe.$isSingleNested ? (_e[Ne] in Fe || (Fe[_e[Ne]] = Te), Fe._doc[_e[Ne]] = Te, qe && Fe.markModified(_e[Ne])) : Fe[_e[Ne]] = Te;
            else {
              var We = Fe instanceof Map, Qe = We ? Fe.get(_e[Ne]) : Fe[_e[Ne]];
              pe.isPOJO(Qe) || Qe && Qe instanceof E || Qe && !Array.isArray(Qe) && Qe.$isSingleNested || Qe && Array.isArray(Qe) || Qe == null && (Qe = {}, We ? Fe.set(_e[Ne], Qe) : Fe[_e[Ne]] = Qe), Fe = Qe;
            }
          }
        }, Le.prototype.$__getValue = function(K) {
          if (typeof K != "string" && !Array.isArray(K)) throw new TypeError('Invalid `path`. Must be either string or array. Got "'.concat(K, '" (type ').concat(b(K), ")"));
          return pe.getValue(K, this._doc);
        }, Le.prototype.$inc = function(K, se) {
          var me = this;
          if (se == null && (se = 1), Array.isArray(K)) return K.forEach(function(qe) {
            return me.$inc(qe, se);
          }), this;
          var ge = this.$__path(K);
          if (ge == null) {
            if (this.$__.strictMode === "throw") throw new ee(K);
            if (this.$__.strictMode === !0) return this;
          } else if (ge.instance !== "Number") return this.invalidate(K, new P.CastError(ge.instance, se, K)), this;
          var _e = this.$__getValue(K) || 0, $e = !1, Te = null, Ie = se;
          try {
            se = ge.cast(se), Ie = (Te = ge.applySetters(_e + se, this)) - _e, $e = !0;
          } catch (qe) {
            this.invalidate(K, new P.CastError("number", se, K, qe));
          }
          return $e && (this.$__.primitiveAtomics = this.$__.primitiveAtomics || {}, this.$__.primitiveAtomics[K] == null ? this.$__.primitiveAtomics[K] = { $inc: Ie } : this.$__.primitiveAtomics[K].$inc += Ie, this.markModified(K), this.$__setValue(K, Te)), this;
        }, Le.prototype.$__setValue = function(K, se) {
          return pe.setValue(K, se, this._doc), this;
        }, Le.prototype.get = function(K, se, me) {
          var ge;
          me == null && (me = {}), se && (ge = this.$__schema.interpretAsType(K, se, this.$__schema.options));
          var _e = me.noDottedPath, $e = _e ? this.$__schema.paths[K] : this.$__path(K);
          if ($e == null && ($e = this.$__schema.virtualpath(K)) != null) return $e.applyGetters(void 0, this);
          if (_e) {
            var Te = this._doc[K];
            return ge && (Te = ge.cast(Te)), $e != null && me.getters !== !1 ? $e.applyGetters(Te, this) : Te;
          }
          if ($e != null && $e.instance === "Mixed") {
            var Ie = this.$__schema.virtualpath(K);
            Ie != null && ($e = Ie);
          }
          var qe = K.indexOf(".") !== -1, Fe = this._doc, Ne = qe ? K.split(".") : [K];
          typeof this.$__schema.aliases[Ne[0]] == "string" && (Ne[0] = this.$__schema.aliases[Ne[0]]);
          for (var fe = 0, Pe = Ne.length; fe < Pe; fe++) Fe && Fe._doc && (Fe = Fe._doc), Fe = Fe == null ? void 0 : Fe instanceof Map ? Fe.get(Ne[fe], { getters: !1 }) : fe === Pe - 1 ? pe.getValue(Ne[fe], Fe) : Fe[Ne[fe]];
          if (ge && (Fe = ge.cast(Fe)), $e != null && me.getters !== !1) Fe = $e.applyGetters(Fe, this);
          else if (this.$__schema.nested[K] && me.virtuals) return or(this, N(Fe) || {}, { path: K });
          return Fe;
        }, Le.prototype[Ke] = Le.prototype.get, Le.prototype.$get = Le.prototype.get, Le.prototype.$__path = function(K) {
          var se = this.$__.adhocPaths;
          return (se && se.hasOwnProperty(K) ? se[K] : null) || this.$__schema.path(K);
        }, Le.prototype.markModified = function(K, se) {
          this.$__saveInitialState(K), this.$__.activePaths.modify(K), se == null || this.$isSubdocument || (this.$__.pathsToScopes = this.$__pathsToScopes || {}, this.$__.pathsToScopes[K] = se);
        }, Le.prototype.$__saveInitialState = function(K) {
          var se = this.$__.savedState, me = K;
          if (se != null) {
            var ge = me.indexOf("."), _e = ge === -1 ? me : me.slice(0, ge);
            se.hasOwnProperty(_e) || (se[_e] = N(this.$__getValue(_e)));
          }
        }, Le.prototype.unmarkModified = function(K) {
          this.$__.activePaths.init(K), this.$__.pathsToScopes != null && delete this.$__.pathsToScopes[K];
        }, Le.prototype.$ignore = function(K) {
          this.$__.activePaths.ignore(K);
        }, Le.prototype.directModifiedPaths = function() {
          return Object.keys(this.$__.activePaths.getStatePaths("modify"));
        }, Le.prototype.$isEmpty = function(K) {
          var se = { minimize: !0, virtuals: !1, getters: !1, transform: !1 };
          if (arguments.length !== 0) {
            var me = this.$get(K);
            return me == null || b(me) === "object" && (pe.isPOJO(me) ? qr(me) : Object.keys(me.toObject(se)).length === 0);
          }
          return Object.keys(this.toObject(se)).length === 0;
        }, Le.prototype.modifiedPaths = function(K) {
          K = K || {};
          var se = Object.keys(this.$__.activePaths.getStatePaths("modify")), me = /* @__PURE__ */ new Set(), ge = 0, _e = 0, $e = se.length;
          for (ge = 0; ge < $e; ++ge) {
            var Te = se[ge], Ie = ue(Te), qe = Ie.length;
            for (_e = 0; _e < qe; ++_e) me.add(Ie[_e]);
            if (K.includeChildren) {
              var Fe = 0, Ne = this.$get(Te);
              if (b(Ne) === "object" && Ne !== null) {
                Ne._doc && (Ne = Ne._doc);
                var fe = Ne.length;
                if (Array.isArray(Ne)) for (Fe = 0; Fe < fe; ++Fe) {
                  var Pe = Te + "." + Fe;
                  if (!me.has(Pe) && (me.add(Pe), Ne[Fe] != null && Ne[Fe].$__)) {
                    var De = Ne[Fe].modifiedPaths(), We = 0, Qe = De.length;
                    for (We = 0; We < Qe; ++We) me.add(Pe + "." + De[We]);
                  }
                }
                else {
                  var rt = Object.keys(Ne), ot = 0, Ot = rt.length;
                  for (ot = 0; ot < Ot; ++ot) me.add(Te + "." + rt[ot]);
                }
              }
            }
          }
          return Array.from(me);
        }, Le.prototype[lt] = Le.prototype.modifiedPaths, Le.prototype.isModified = function(K, se, me) {
          var ge = this;
          if (K) {
            var _e = se && se.ignoreAtomics, $e = this.$__.activePaths.states.modify;
            if ($e == null) return !1;
            typeof K == "string" && (K = K.indexOf(" ") === -1 ? [K] : K.split(" "));
            var Te, Ie = m(K);
            try {
              for (Ie.s(); !(Te = Ie.n()).done; ) if ($e[Te.value] != null) return !0;
            } catch (fe) {
              Ie.e(fe);
            } finally {
              Ie.f();
            }
            var qe = me || this[lt](), Fe = K.some(function(fe) {
              return !!~qe.indexOf(fe);
            }), Ne = Object.keys($e);
            return _e && (Ne = Ne.filter(function(fe) {
              var Pe = ge.$__getValue(fe);
              return Pe == null || Pe[Ae] == null || Pe[Ae].$set !== void 0;
            })), Fe || K.some(function(fe) {
              return Ne.some(function(Pe) {
                return Pe === fe || fe.startsWith(Pe + ".");
              });
            });
          }
          return this.$__.activePaths.some("modify");
        }, Le.prototype.$isModified = Le.prototype.isModified, Le.prototype[et] = Le.prototype.isModified, Le.prototype.$isDefault = function(K) {
          var se = this;
          if (K == null) return this.$__.activePaths.some("default");
          if (typeof K == "string" && K.indexOf(" ") === -1) return this.$__.activePaths.getStatePaths("default").hasOwnProperty(K);
          var me = K;
          return Array.isArray(me) || (me = me.split(" ")), me.some(function(ge) {
            return se.$__.activePaths.getStatePaths("default").hasOwnProperty(ge);
          });
        }, Le.prototype.$isDeleted = function(K) {
          return arguments.length === 0 ? !!this.$__.isDeleted : (this.$__.isDeleted = !!K, this);
        }, Le.prototype.isDirectModified = function(K) {
          var se = this;
          if (K == null) return this.$__.activePaths.some("modify");
          if (typeof K == "string" && K.indexOf(" ") === -1) {
            var me = this.$__.activePaths.getStatePaths("modify").hasOwnProperty(K);
            if (me || K.indexOf(".") === -1) return me;
            for (var ge = K.split("."), _e = 0; _e < ge.length - 1; ++_e) {
              var $e = ge.slice(0, _e + 1).join("."), Te = this.$get($e);
              if (Te != null && Te.$__ != null && Te.isDirectModified(ge.slice(_e + 1).join("."))) return !0;
            }
            return !1;
          }
          var Ie = K;
          return typeof Ie == "string" && (Ie = Ie.split(" ")), Ie.some(function(qe) {
            return se.isDirectModified(qe);
          });
        }, Le.prototype.isInit = function(K) {
          var se = this;
          if (K == null) return this.$__.activePaths.some("init");
          if (typeof K == "string" && K.indexOf(" ") === -1) return this.$__.activePaths.getStatePaths("init").hasOwnProperty(K);
          var me = K;
          return Array.isArray(me) || (me = me.split(" ")), me.some(function(ge) {
            return se.$__.activePaths.getStatePaths("init").hasOwnProperty(ge);
          });
        }, Le.prototype.isSelected = function(K) {
          var se = this;
          if (this.$__.selected == null) return !0;
          if (!K) return !1;
          if (K === "_id") return this.$__.selected._id !== 0;
          if (K.indexOf(" ") !== -1 && (K = K.split(" ")), Array.isArray(K)) return K.some(function(fe) {
            return se.$__isSelected(fe);
          });
          var me = Object.keys(this.$__.selected), ge = null;
          if (me.length === 1 && me[0] === "_id") return this.$__.selected._id === 0;
          for (var _e = 0, $e = me; _e < $e.length; _e++) {
            var Te = $e[_e];
            if (Te !== "_id" && B(this.$__.selected[Te])) {
              ge = !!this.$__.selected[Te];
              break;
            }
          }
          if (ge === null) return !0;
          if (K in this.$__.selected) return ge;
          for (var Ie = K + ".", qe = 0, Fe = me; qe < Fe.length; qe++) {
            var Ne = Fe[qe];
            if (Ne !== "_id") {
              if (Ne.startsWith(Ie)) return ge || Ne !== Ie;
              if (Ie.startsWith(Ne + ".")) return ge;
            }
          }
          return !ge;
        }, Le.prototype.$__isSelected = Le.prototype.isSelected, Le.prototype.isDirectSelected = function(K) {
          var se = this;
          if (this.$__.selected == null) return !0;
          if (K === "_id") return this.$__.selected._id !== 0;
          if (K.indexOf(" ") !== -1 && (K = K.split(" ")), Array.isArray(K)) return K.some(function(Ie) {
            return se.isDirectSelected(Ie);
          });
          var me = Object.keys(this.$__.selected), ge = null;
          if (me.length === 1 && me[0] === "_id") return this.$__.selected._id === 0;
          for (var _e = 0, $e = me; _e < $e.length; _e++) {
            var Te = $e[_e];
            if (Te !== "_id" && B(this.$__.selected[Te])) {
              ge = !!this.$__.selected[Te];
              break;
            }
          }
          return ge === null || (this.$__.selected.hasOwnProperty(K) ? ge : !ge);
        }, Le.prototype.validate = (function() {
          var K = p(f().m(function se(me, ge) {
            var _e, $e, Te = this, Ie = arguments;
            return f().w(function(qe) {
              for (; ; ) switch (qe.n) {
                case 0:
                  if (typeof me != "function" && typeof ge != "function" && typeof Ie[2] != "function") {
                    qe.n = 1;
                    break;
                  }
                  throw new P("Document.prototype.validate() no longer accepts a callback");
                case 1:
                  if (this.$op = "validate", Ie.length === 1 && (b(Ie[0]) !== "object" || Array.isArray(Ie[0]) || (ge = Ie[0], me = null)), ge && typeof ge.pathsToSkip == "string" && (_e = ge.pathsToSkip.indexOf(" ") === -1, ge.pathsToSkip = _e ? [ge.pathsToSkip] : ge.pathsToSkip.split(" ")), $e = ge && ge._skipParallelValidateCheck, this.$isSubdocument == null) {
                    qe.n = 2;
                    break;
                  }
                  qe.n = 4;
                  break;
                case 2:
                  if (!this.$__.validating || $e) {
                    qe.n = 3;
                    break;
                  }
                  throw new F(this);
                case 3:
                  $e || (this.$__.validating = !0);
                case 4:
                  return qe.a(2, new Promise(function(Fe, Ne) {
                    Te.$__validate(me, ge, function(fe) {
                      if (Te.$op = null, Te.$__.validating = null, fe != null) return Ne(fe);
                      Fe();
                    });
                  }));
              }
            }, se, this);
          }));
          return function(se, me) {
            return K.apply(this, arguments);
          };
        })(), Le.prototype.$validate = Le.prototype.validate, Le.prototype.$__validate = function(K, se, me) {
          var ge, _e = this;
          this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !K ? K = c(this.$__.saveOptions.pathsToSave) : typeof K == "function" ? (me = K, se = null, K = null) : typeof se == "function" && (me = se, se = null);
          var $e, Te = se && b(se) === "object" && "validateModifiedOnly" in se, Ie = se && se.pathsToSkip || null;
          $e = Te ? !!se.validateModifiedOnly : this.$__schema.options.validateModifiedOnly;
          var qe = se && se.validateAllPaths;
          if (qe) {
            if (Ie) throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
            if (K) throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
            if (Te && $e) throw new TypeError("Cannot set both `validateAllPaths` and `validateModifiedOnly`");
          }
          var Fe, Ne, fe = this, Pe = function() {
            var He = _e.$__.validationError;
            if (_e.$__.validationError = null, _e.$__.validating = null, $e && He != null) {
              for (var kt = 0, Gt = Object.keys(He.errors); kt < Gt.length; kt++) {
                var Bt = Gt[kt];
                _e.$isModified(Bt) || delete He.errors[Bt];
              }
              Object.keys(He.errors).length === 0 && (He = void 0);
            }
            if (_e.$__.cachedRequired = {}, _e.$emit("validate", fe), _e.constructor.emit("validate", fe), He) {
              for (var Kt in He.errors) !_e[Me] && He.errors[Kt] instanceof P.CastError && _e.invalidate(Kt, He.errors[Kt]);
              return He;
            }
          };
          if (qe) {
            var De, We = m(Fe = new Set(Object.keys(this.$__schema.paths)));
            try {
              for (We.s(); !(De = We.n()).done; ) {
                var Qe = De.value, rt = this.$__schema.path(Qe);
                if (rt && rt.$isMongooseArray) {
                  var ot = this.$__getValue(Qe);
                  ot && Wr(ot, Fe, Qe);
                }
              }
            } catch (He) {
              We.e(He);
            } finally {
              We.f();
            }
            Fe = c(Fe), Ne = {};
          } else {
            var Ot = Cn(this, K, Ie, se && se._nestedValidate);
            Fe = $e ? Ot[0].filter(function(He) {
              return _e.$isModified(He);
            }) : Ot[0], Ne = Ot[1];
          }
          if (typeof K == "string" && (K = K.split(" ")), Fe.length === 0) return x(function() {
            var He = Pe();
            if (He) return fe.$__schema.s.hooks.execPost("validate:error", fe, [fe], { error: He }, function(kt) {
              me(kt);
            });
            me(null, fe);
          });
          var Lt = {}, _t = 0, St = (ge = this.$__.saveOptions) === null || ge === void 0 ? void 0 : ge.pathsToSave;
          if (Array.isArray(St)) {
            St = new Set(St);
            var zt, Et = m(Fe);
            try {
              for (Et.s(); !(zt = Et.n()).done; ) {
                var Nt = zt.value;
                St.has(Nt) && At(Nt);
              }
            } catch (He) {
              Et.e(He);
            } finally {
              Et.f();
            }
          } else {
            var wr, fr = m(Fe);
            try {
              for (fr.s(); !(wr = fr.n()).done; ) At(wr.value);
            } catch (He) {
              fr.e(He);
            } finally {
              fr.f();
            }
          }
          function At(He) {
            He == null || Lt[He] || (Lt[He] = !0, _t++, x(function() {
              var kt = fe.$__schema.path(He);
              if (!kt) return --_t || Yt();
              if (fe.$isValid(He)) {
                if (kt[Tt] != null && He !== kt.path) return --_t || Yt();
                var Gt, Bt = fe.$__getValue(He);
                (Gt = fe.$populated(He)) ? Bt = Gt : Bt != null && Bt.$__ != null && Bt.$__.wasPopulated && (Bt = Bt._doc._id);
                var Kt = fe.$__.pathsToScopes != null && He in fe.$__.pathsToScopes ? fe.$__.pathsToScopes[He] : fe, Kr = d(d({}, Ne[He]), {}, { path: He, validateAllPaths: qe, _nestedValidate: !0 });
                kt.doValidate(Bt, function(Ar) {
                  if (Ar) {
                    if ((kt.$isSingleNested || kt.$isArraySubdocument || kt.$isMongooseDocumentArray) && Ar instanceof V) return --_t || Yt();
                    fe.invalidate(He, Ar, void 0, !0);
                  }
                  --_t || Yt();
                }, Kt, Kr);
              } else --_t || Yt();
            }));
          }
          function Yt() {
            var He = Pe();
            if (He) return fe.$__schema.s.hooks.execPost("validate:error", fe, [fe], { error: He }, function(kt) {
              me(kt);
            });
            me(null, fe);
          }
        }, Le.prototype.validateSync = function(K, se) {
          var me, ge = this, _e = this;
          arguments.length !== 1 || b(arguments[0]) !== "object" || Array.isArray(arguments[0]) || (se = arguments[0], K = null), me = se && b(se) === "object" && "validateModifiedOnly" in se ? !!se.validateModifiedOnly : this.$__schema.options.validateModifiedOnly;
          var $e, Te, Ie = se && se.pathsToSkip, qe = se && se.validateAllPaths;
          if (qe) {
            if (Ie) throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
            if (K) throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
          }
          if (typeof K == "string") {
            var Fe = K.indexOf(" ") === -1;
            K = Fe ? [K] : K.split(" ");
          } else typeof Ie == "string" && Ie.indexOf(" ") !== -1 && (Ie = Ie.split(" "));
          if (qe) {
            var Ne, fe = m($e = new Set(Object.keys(this.$__schema.paths)));
            try {
              for (fe.s(); !(Ne = fe.n()).done; ) {
                var Pe = Ne.value, De = this.$__schema.path(Pe);
                if (De && De.$isMongooseArray) {
                  var We = this.$__getValue(Pe);
                  We && Wr(We, $e, Pe);
                }
              }
            } catch (wr) {
              fe.e(wr);
            } finally {
              fe.f();
            }
            $e = c($e), Te = {};
          } else {
            var Qe = Cn(this, K, Ie);
            $e = me ? Qe[0].filter(function(wr) {
              return ge.$isModified(wr);
            }) : Qe[0], Te = Qe[1];
          }
          for (var rt = {}, ot = 0, Ot = $e.length; ot < Ot; ++ot) {
            var Lt = $e[ot];
            if (!rt[Lt]) {
              rt[Lt] = !0;
              var _t = _e.$__schema.path(Lt);
              if (_t && _e.$isValid(Lt)) {
                var St = _e.$__getValue(Lt), zt = _t.doValidateSync(St, _e, { skipSchemaValidators: Te[Lt], path: Lt, validateModifiedOnly: me, validateAllPaths: qe });
                if (zt) {
                  if ((_t.$isSingleNested || _t.$isArraySubdocument || _t.$isMongooseDocumentArray) && zt instanceof V) continue;
                  _e.invalidate(Lt, zt, void 0, !0);
                }
              }
            }
          }
          var Et = _e.$__.validationError;
          if (_e.$__.validationError = void 0, _e.$emit("validate", _e), _e.constructor.emit("validate", _e), Et) for (var Nt in Et.errors) Et.errors[Nt] instanceof P.CastError && _e.invalidate(Nt, Et.errors[Nt]);
          return Et;
        }, Le.prototype.invalidate = function(K, se, me, ge) {
          if (this.$__.validationError || (this.$__.validationError = new V(this)), !this.$__.validationError.errors[K]) return se && typeof se != "string" || (se = new T({ path: K, message: se, type: ge || "user defined", value: me })), this.$__.validationError === se || this.$__.validationError.addError(K, se), this.$__.validationError;
        }, Le.prototype.$markValid = function(K) {
          this.$__.validationError && this.$__.validationError.errors[K] && (delete this.$__.validationError.errors[K], Object.keys(this.$__.validationError.errors).length === 0 && (this.$__.validationError = null));
        }, Le.prototype.$isValid = function(K) {
          var se = this;
          return this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0 || K != null && (K.indexOf(" ") !== -1 && (K = K.split(" ")), Array.isArray(K) ? K.some(function(me) {
            return se.$__.validationError.errors[me] == null;
          }) : this.$__.validationError.errors[K] == null);
        }, Le.prototype.$__reset = function() {
          var K, se = this.$isSubdocument ? null : this.$getAllSubdocs({ useCache: !0 });
          if (se && se.length > 0) {
            var me, ge = m(se);
            try {
              for (ge.s(); !(me = ge.n()).done; ) me.value.$__reset();
            } catch (_e) {
              ge.e(_e);
            } finally {
              ge.f();
            }
          }
          return this.$__dirty().forEach(function(_e) {
            var $e = _e.value;
            $e && $e[Ae] && ($e[Ue] = $e[Ae], $e[Ae] = {});
          }), this.$__.backup = {}, this.$__.backup.activePaths = { modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")), default: Object.assign({}, this.$__.activePaths.getStatePaths("default")) }, this.$__.backup.validationError = this.$__.validationError, this.$__.backup.errors = this.$errors, this.$__.activePaths.clear("modify"), this.$__.activePaths.clear("default"), this.$__.validationError = void 0, this.$errors = void 0, K = this, this.$__schema.requiredPaths().forEach(function(_e) {
            K.$__.activePaths.require(_e);
          }), this;
        }, Le.prototype.$__undoReset = function() {
          if (this.$__.backup != null && this.$__.backup.activePaths != null) {
            this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify, this.$__.activePaths.states.default = this.$__.backup.activePaths.default, this.$__.validationError = this.$__.backup.validationError, this.$errors = this.$__.backup.errors;
            var K, se = m(this.$__dirty());
            try {
              for (se.s(); !(K = se.n()).done; ) {
                var me = K.value.value;
                me && me[Ae] && me[Ue] && (me[Ae] = me[Ue]);
              }
            } catch ($e) {
              se.e($e);
            } finally {
              se.f();
            }
            if (!this.$isSubdocument) {
              var ge, _e = m(this.$getAllSubdocs());
              try {
                for (_e.s(); !(ge = _e.n()).done; ) ge.value.$__undoReset();
              } catch ($e) {
                _e.e($e);
              } finally {
                _e.f();
              }
            }
          }
        }, Le.prototype.$__dirty = function() {
          var K = this, se = this.$__.activePaths.map("modify", function(_e) {
            return { path: _e, value: K.$__getValue(_e), schema: K.$__path(_e) };
          });
          se = se.concat(this.$__.activePaths.map("default", function(_e) {
            if (_e !== "_id" && K.$__getValue(_e) != null) return { path: _e, value: K.$__getValue(_e), schema: K.$__path(_e) };
          }));
          var me = new Map(se.filter(function(_e) {
            return _e != null;
          }).map(function(_e) {
            return [_e.path, _e.value];
          })), ge = [];
          return se.forEach(function(_e) {
            if (_e) {
              for (var $e = null, Te = ue(_e.path), Ie = 0; Ie < Te.length - 1; Ie++) if (me.has(Te[Ie])) {
                $e = me.get(Te[Ie]);
                break;
              }
              $e == null ? ge.push(_e) : $e != null && $e[Ae] != null && $e.hasAtomics() && ($e[Ae] = {}, $e[Ae].$set = $e);
            }
          }), ge;
        }, Le.prototype.$__setSchema = function(K) {
          Z(K.tree, this, void 0, K.options);
          for (var se = 0, me = Object.keys(K.virtuals); se < me.length; se++) {
            var ge = me[se];
            K.virtuals[ge]._applyDefaultGetters();
          }
          K.path("schema") == null && (this.schema = K), this.$__schema = K, this[ft] = K;
        }, Le.prototype.$__getArrayPathsToValidate = function() {
          return w || (w = a(4878)), this.$__.activePaths.map("init", "modify", function(K) {
            return this.$__getValue(K);
          }.bind(this)).filter(function(K) {
            return K && Array.isArray(K) && pe.isMongooseDocumentArray(K) && K.length;
          }).reduce(function(K, se) {
            return K.concat(se);
          }, []).filter(function(K) {
            return K;
          });
        }, Le.prototype.$getAllSubdocs = function(K) {
          var se;
          if (K != null && K.useCache && (se = this.$__.saveOptions) !== null && se !== void 0 && se.__subdocs) return this.$__.saveOptions.__subdocs;
          w || (w = a(4878)), E = E || a(6547);
          var me = [];
          return (function ge(_e) {
            var $e, Te = [], Ie = m(_e.$__schema.childSchemas);
            try {
              for (Ie.s(); !($e = Ie.n()).done; ) {
                var qe = $e.value.model, Fe = _e.$__getValue(qe.path);
                if (Fe != null) {
                  if (Fe.$__ && Te.push(Fe), Array.isArray(Fe)) {
                    var Ne, fe = m(Fe);
                    try {
                      for (fe.s(); !(Ne = fe.n()).done; ) {
                        var Pe = Ne.value;
                        Pe != null && Pe.$__ && Te.push(Pe);
                      }
                    } catch (Ot) {
                      fe.e(Ot);
                    } finally {
                      fe.f();
                    }
                  }
                  if (Fe instanceof Map) {
                    var De, We = m(Fe.values());
                    try {
                      for (We.s(); !(De = We.n()).done; ) {
                        var Qe = De.value;
                        Qe != null && Qe.$__ && Te.push(Qe);
                      }
                    } catch (Ot) {
                      We.e(Ot);
                    } finally {
                      We.f();
                    }
                  }
                }
              }
            } catch (Ot) {
              Ie.e(Ot);
            } finally {
              Ie.f();
            }
            for (var rt = 0, ot = Te; rt < ot.length; rt++) ge(ot[rt]);
            me.push.apply(me, Te);
          })(this), this.$__.saveOptions && (this.$__.saveOptions.__subdocs = me), me;
        }, Le.prototype.$__handleReject = function(K) {
          this.$listeners("error").length ? this.$emit("error", K) : this.constructor.listeners && this.constructor.listeners("error").length && this.constructor.emit("error", K);
        }, Le.prototype.$toObject = function(K, se) {
          var me, ge, _e, $e, Te, Ie, qe, Fe, Ne, fe, Pe, De, We, Qe, rt, ot = this.$__schema._defaultToObjectOptions(se), Ot = this.$__hasOnlyPrimitiveValues();
          (K = pe.isPOJO(K) ? d({}, K) : {})._calledWithOptions = K._calledWithOptions || d({}, K), rt = K._calledWithOptions.minimize != null ? K.minimize : ((me = this.$__schemaTypeOptions) === null || me === void 0 ? void 0 : me.minimize) != null ? this.$__schemaTypeOptions.minimize : ot != null && ot.minimize != null ? ot.minimize : this.$__schema.options.minimize, K.minimize = rt, Ot || (K._seen = K._seen || /* @__PURE__ */ new Map());
          var Lt = (ge = (_e = ($e = K._calledWithOptions.depopulate) !== null && $e !== void 0 ? $e : ot?.depopulate) !== null && _e !== void 0 ? _e : K.depopulate) !== null && ge !== void 0 && ge;
          if (Lt && K._isNested && this.$__.wasPopulated) return N(this.$__.wasPopulated.value || this._doc._id, K);
          if (Lt && (K.depopulate = !0), ot != null) for (var _t = 0, St = Object.keys(ot); _t < St.length; _t++) {
            var zt = St[_t];
            K[zt] == null && (K[zt] = ot[zt]);
          }
          K._isNested = !0, K.json = se, K.minimize = rt;
          var Et = K._parentOptions;
          K._parentOptions = this.$isSubdocument ? K : null;
          var Nt, wr = (Te = (Ie = (qe = K._calledWithOptions.schemaFieldsOnly) !== null && qe !== void 0 ? qe : K.schemaFieldsOnly) !== null && Ie !== void 0 ? Ie : ot.schemaFieldsOnly) !== null && Te !== void 0 && Te;
          if (Ot && !K.flattenObjectIds) Nt = this.$__toObjectShallow(wr);
          else if (wr) {
            Nt = {};
            for (var fr = 0, At = Object.keys(this.$__schema.paths); fr < At.length; fr++) {
              var Yt = At[fr], He = this.$__getValue(Yt);
              if (He !== void 0) {
                var kt = Yt, Gt = Nt;
                if (Yt.indexOf(".") !== -1) {
                  var Bt = Yt.split(".");
                  kt = Bt[Bt.length - 1];
                  for (var Kt = 0; Kt < Bt.length - 1; ++Kt) {
                    var Kr;
                    Gt[Bt[Kt]] = (Kr = Gt[Bt[Kt]]) !== null && Kr !== void 0 ? Kr : {}, Gt = Gt[Bt[Kt]];
                  }
                }
                Gt[kt] = He !== null ? N(He, K) : null;
              }
            }
          } else Nt = N(this._doc, K) || {};
          var Ar = (Fe = (Ne = (fe = K._calledWithOptions.getters) !== null && fe !== void 0 ? fe : K.getters) !== null && Ne !== void 0 ? Ne : ot.getters) !== null && Fe !== void 0 && Fe;
          Ar && ((function(nr, Ir) {
            var Or, Tr, rr = nr.$__schema, yr = Object.keys(rr.paths), Hr = yr.length, pt = nr._doc;
            if (!pt) return Ir;
            for (; Hr--; ) {
              var hr = (Or = yr[Hr]).split("."), ar = hr.length, Qt = ar - 1, qt = Ir, Rt = void 0;
              if (pt = nr._doc, nr.$__isSelected(Or)) for (var Ur = 0; Ur < ar && (Tr = pt[Rt = hr[Ur]], qt == null || b(qt) === "object"); ++Ur) {
                if (Ur === Qt) {
                  if (qt[Rt] = rr.paths[Or].applyGetters(qt[Rt], nr), Array.isArray(qt[Rt]) && rr.paths[Or].$embeddedSchemaType) for (var $r = 0; $r < qt[Rt].length; ++$r) qt[Rt][$r] = rr.paths[Or].$embeddedSchemaType.applyGetters(qt[Rt][$r], nr);
                } else {
                  if (Tr == null) {
                    Rt in pt && (qt[Rt] = Tr);
                    break;
                  }
                  qt = qt[Rt] || (qt[Rt] = {});
                }
                pt = Tr;
              }
            }
          })(this, Nt), K.minimize && (Nt = G(Nt) || {}));
          var Sn = (Pe = (De = (We = K._calledWithOptions.virtuals) !== null && We !== void 0 ? We : ot.virtuals) !== null && De !== void 0 ? De : Et?.virtuals) !== null && Pe !== void 0 ? Pe : void 0;
          (Sn || Ar && Sn !== !1) && or(this, Nt, K, K), K.versionKey === !1 && this.$__schema.options.versionKey && delete Nt[this.$__schema.options.versionKey];
          var cn = (Qe = K._calledWithOptions.transform) === null || Qe === void 0 || Qe, En = void 0;
          if (cn === !0 ? En = ot.transform : typeof cn == "function" && (En = cn), cn && (function(nr, Ir) {
            var Or = nr.$__schema, Tr = Object.keys(Or.paths || {});
            if (!nr._doc) return Ir;
            for (var rr = 0, yr = Tr; rr < yr.length; rr++) {
              var Hr, pt, hr, ar, Qt, qt = yr[rr], Rt = Or.paths[qt], Ur = (Hr = Rt.options.transform) !== null && Hr !== void 0 ? Hr : (pt = Rt.constructor) === null || pt === void 0 || (pt = pt.defaultOptions) === null || pt === void 0 ? void 0 : pt.transform, $r = (hr = (ar = Rt.$embeddedSchemaType) === null || ar === void 0 || (ar = ar.options) === null || ar === void 0 ? void 0 : ar.transform) !== null && hr !== void 0 ? hr : (Qt = Rt.$embeddedSchemaType) === null || Qt === void 0 || (Qt = Qt.constructor) === null || Qt === void 0 || (Qt = Qt.defaultOptions) === null || Qt === void 0 ? void 0 : Qt.transform;
              if (typeof Ur == "function") {
                var xn = nr.$get(qt);
                if (xn === void 0) continue;
                var an = Ur.call(nr, xn);
                Gr(qt, an), pe.setValue(qt, an, Ir);
              } else if (typeof $r == "function") {
                var ln = nr.$get(qt);
                if (ln === void 0) continue;
                for (var sn = [].concat(ln), Mr = 0; Mr < sn.length; ++Mr) {
                  var bn = $r.call(nr, sn[Mr]);
                  sn[Mr] = bn, Gr(qt, bn);
                }
                Ir[qt] = sn;
              }
            }
          })(this, Nt), K.useProjection && (function(nr, Ir) {
            var Or = nr.$__schema, Tr = Object.keys(Or.paths || {});
            if (!nr._doc) return Ir;
            var rr = nr.$__.selected;
            if (rr === void 0 && (rr = {}, re.applyPaths(rr, Or)), rr == null || Object.keys(rr).length === 0) return Ir;
            for (var yr = 0, Hr = Tr; yr < Hr.length; yr++) {
              var pt = Hr[yr];
              rr[pt] == null || rr[pt] || delete Ir[pt];
            }
          })(this, Nt), typeof En == "function") {
            var vn = En(this, Nt, K);
            vn !== void 0 && (Nt = vn);
          }
          return Nt;
        }, Le.prototype.$__toObjectShallow = function(K) {
          var se = {};
          if (this._doc != null) {
            var me, ge = m(Object.keys(K ? this.$__schema.paths : this._doc));
            try {
              for (ge.s(); !(me = ge.n()).done; ) {
                var _e = me.value, $e = this._doc[_e];
                $e instanceof Date ? se[_e] = new Date($e) : $e !== void 0 && (se[_e] = $e);
              }
            } catch (Te) {
              ge.e(Te);
            } finally {
              ge.f();
            }
          }
          return se;
        }, Le.prototype.toObject = function(K) {
          return this.$toObject(K);
        }, Le.prototype.toJSON = function(K) {
          return this.$toObject(K, !0);
        }, Le.prototype.ownerDocument = function() {
          return this;
        }, Le.prototype.parent = function() {
          return this.$isSubdocument || this.$__.wasPopulated ? this.$__.parent : this;
        }, Le.prototype.$parent = Le.prototype.parent, Le.prototype.inspect = function(K) {
          var se;
          pe.isPOJO(K) && ((se = K).minimize = !1);
          var me = arguments.length > 0 ? this.toObject(se) : this.toObject();
          return me ?? "MongooseDocument { " + me + " }";
        }, oe.custom && (Le.prototype[oe.custom] = Le.prototype.inspect), Le.prototype.toString = function() {
          var K = this.inspect();
          return typeof K == "string" ? K : oe(K);
        }, Le.prototype.equals = function(K) {
          if (!K) return !1;
          var se = this.$__getValue("_id"), me = K.$__ != null ? K.$__getValue("_id") : K;
          return se || me ? se && se.equals ? se.equals(me) : se === me : be(this, K);
        }, Le.prototype.populate = (function() {
          var K = p(f().m(function se() {
            var me, ge, _e, $e, Te, Ie, qe, Fe, Ne, fe, Pe = arguments;
            return f().w(function(De) {
              for (; ; ) switch (De.n) {
                case 0:
                  if (me = {}, typeof (ge = Array.prototype.slice.call(Pe))[ge.length - 1] != "function") {
                    De.n = 1;
                    break;
                  }
                  throw new P("Document.prototype.populate() no longer accepts a callback");
                case 1:
                  if (ge.length !== 0) {
                    _e = pe.populate.apply(null, ge), $e = m(_e);
                    try {
                      for ($e.s(); !(Te = $e.n()).done; ) Ie = Te.value, me[Ie.path] = Ie;
                    } catch (We) {
                      $e.e(We);
                    } finally {
                      $e.f();
                    }
                  }
                  return qe = pe.object.vals(me), Fe = this.constructor, this.$__isNested && (Fe = this.$__[Pt].constructor, Ne = this.$__.nestedPath, qe.forEach(function(We) {
                    We.path = Ne + "." + We.path;
                  })), this.$session() != null && (fe = this.$session(), qe.forEach(function(We) {
                    We.options != null ? "session" in We.options || (We.options.session = fe) : We.options = { session: fe };
                  })), qe.forEach(function(We) {
                    We._localModel = Fe;
                  }), De.a(2, Fe.populate(this, qe));
              }
            }, se, this);
          }));
          return function() {
            return K.apply(this, arguments);
          };
        })(), Le.prototype.$getPopulatedDocs = function() {
          var K = [];
          this.$__.populated != null && (K = K.concat(Object.keys(this.$__.populated)));
          var se, me = [], ge = m(K);
          try {
            for (ge.s(); !(se = ge.n()).done; ) {
              var _e = se.value, $e = this.$get(_e);
              Array.isArray($e) ? me = me.concat($e) : $e instanceof Le && me.push($e);
            }
          } catch (Te) {
            ge.e(Te);
          } finally {
            ge.f();
          }
          return me;
        }, Le.prototype.populated = function(K, se, me) {
          if (se == null || se === !0) {
            if (!this.$__.populated || typeof K != "string") return;
            var ge = K.endsWith(".$*") ? K.replace(/\.\$\*$/, "") : K, _e = this.$__.populated[ge];
            return _e ? se === !0 ? _e : _e.value : void 0;
          }
          this.$__.populated || (this.$__.populated = {}), this.$__.populated[K] = { value: se, options: me };
          for (var $e = K.split("."), Te = 0; Te < $e.length - 1; ++Te) {
            var Ie = $e.slice(0, Te + 1).join("."), qe = this.$get(Ie);
            if (qe != null && qe.$__ != null && this.$populated(Ie)) {
              var Fe = $e.slice(Te + 1).join(".");
              qe.$populated(Fe, se, me);
              break;
            }
          }
          return se;
        }, Le.prototype.$populated = Le.prototype.populated, Le.prototype.$assertPopulated = function(K, se) {
          var me = this;
          if (Array.isArray(K)) return K.forEach(function(ge) {
            return me.$assertPopulated(ge, se);
          }), this;
          if (arguments.length > 1 && this.$set(se), !this.$populated(K)) throw new P('Expected path "'.concat(K, '" to be populated'));
          return this;
        }, Le.prototype.depopulate = function(K) {
          var se;
          typeof K == "string" && (K = K.indexOf(" ") === -1 ? [K] : K.split(" "));
          var me = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [], ge = this.$__ && this.$__.populated || {};
          if (arguments.length === 0) {
            var _e, $e = m(me);
            try {
              for ($e.s(); !(_e = $e.n()).done; ) {
                var Te = _e.value;
                delete this.$$populatedVirtuals[Te], delete this._doc[Te], delete ge[Te];
              }
            } catch (St) {
              $e.e(St);
            } finally {
              $e.f();
            }
            for (var Ie = 0, qe = Object.keys(ge); Ie < qe.length; Ie++) {
              var Fe = qe[Ie];
              if (se = this.$populated(Fe)) if (delete ge[Fe], Array.isArray(se)) {
                var Ne = pe.getValue(Fe, this._doc);
                if (Ne.isMongooseArray) for (var fe = Ne.__array, Pe = 0; Pe < fe.length; ++Pe) {
                  var De = fe[Pe];
                  De != null && (fe[Pe] = De instanceof Le ? De._doc._id : De._id);
                }
                else pe.setValue(Fe, se, this._doc);
              } else pe.setValue(Fe, se, this._doc);
            }
            return this;
          }
          var We, Qe = m(K);
          try {
            for (Qe.s(); !(We = Qe.n()).done; ) {
              var rt = We.value;
              if (se = this.$populated(rt), delete ge[rt], me.indexOf(rt) !== -1) delete this.$$populatedVirtuals[rt], delete this._doc[rt];
              else if (se) if (Array.isArray(se)) {
                var ot = pe.getValue(rt, this._doc);
                if (ot.isMongooseArray) for (var Ot = ot.__array, Lt = 0; Lt < Ot.length; ++Lt) {
                  var _t = Ot[Lt];
                  _t != null && (Ot[Lt] = _t instanceof Le ? _t._doc._id : _t._id);
                }
                else pe.setValue(rt, se, this._doc);
              } else pe.setValue(rt, se, this._doc);
            }
          } catch (St) {
            Qe.e(St);
          } finally {
            Qe.f();
          }
          return this;
        }, Le.prototype.$__fullPath = function(K) {
          return K || "";
        }, Le.prototype.getChanges = function() {
          var K = this.$__delta();
          return K ? K[1] : {};
        }, Le.prototype.$__delta = function() {
          var K = this, se = this.$__dirty(), me = this.$__schema.options.optimisticConcurrency;
          if (me) if (Array.isArray(me)) {
            var ge = new Set(me);
            this.modifiedPaths().find(function(rt) {
              return ge.has(rt);
            }) && (this.$__.version = se.length ? 3 : 1);
          } else this.$__.version = se.length ? 3 : 1;
          if (se.length || this.$__.version === 3) {
            var _e = {}, $e = {}, Te = se.length, Ie = [], qe = 0;
            for (_e._id = this._doc._id, (_e && _e._id && _e._id.$__ || null) != null && (_e._id = _e._id.toObject({ transform: !1, depopulate: !0 })); qe < Te; ++qe) {
              var Fe = se[qe], Ne = Fe.value, fe = ti(this, Fe.path, Ne);
              if (fe) Ie.push(fe);
              else {
                if (!this.$populated(Fe.path, !0) && this.$__.selected) {
                  var Pe = Fe.path.split("."), De = Pe[0];
                  if (this.$__.selected[De] && this.$__.selected[De].$elemMatch) {
                    if (!(Pe.length > 1 && Pe[1] == 0 && _e[De] === void 0)) {
                      Ie.push(Fe.path);
                      continue;
                    }
                    _e[De] = this.$__.selected[De], Pe[1] = "$", Fe.path = Pe.join(".");
                  }
                }
                if (this.$isDefault(Fe.path) && this.$__.selected && (Fe.path.indexOf(".") === -1 && X(this.$__.selected, Fe.path) || ue(Fe.path).find(function(rt) {
                  return X(K.$__.isSelected, rt);
                })))
                  continue;
                if (!Ie.length) if (Ne === void 0) mr(this, 0, $e, Fe, 1, "$unset");
                else if (Ne === null) mr(this, 0, $e, Fe, null);
                else if (pe.isMongooseArray(Ne) && Ne.$path() && Ne[Ae]) on(this, 0, $e, Fe, Ne);
                else if (Ne[j.pathSymbol] && u.isBuffer(Ne)) mr(this, 0, $e, Fe, Ne = Ne.toObject());
                else if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[Fe.path] != null) {
                  var We = this.$__.primitiveAtomics[Fe.path], Qe = ie(We);
                  mr(this, 0, $e, Fe, We[Qe], Qe);
                } else mr(this, 0, $e, Fe, Ne = N(Ne, { depopulate: !0, transform: !1, virtuals: !1, getters: !1, omitUndefined: !0, _isNested: !0 }));
              }
            }
            return Ie.length ? new O(Ie) : (this.$__.version && this.$__version(_e, $e), Object.keys($e).length === 0 ? [_e, null] : [_e, $e]);
          }
        }, Le.prototype.$clone = function() {
          var K = new this.constructor();
          if (K.$isNew = this.$isNew, this._doc && (K._doc = N(this._doc, { retainDocuments: !0 })), this.$__) {
            var se, me = new this.$__.constructor(), ge = m(Object.getOwnPropertyNames(this.$__));
            try {
              for (ge.s(); !(se = ge.n()).done; ) {
                var _e = se.value;
                _e !== "activePaths" && (me[_e] = N(this.$__[_e]));
              }
            } catch ($e) {
              ge.e($e);
            } finally {
              ge.f();
            }
            Object.assign(me.activePaths, N(d({}, this.$__.activePaths))), K.$__ = me;
          }
          return K;
        }, Le.prototype.$createModifiedPathsSnapshot = function() {
          var K = /* @__PURE__ */ new WeakMap();
          if (!this.$isSubdocument) {
            var se, me = m(this.$getAllSubdocs());
            try {
              for (me.s(); !(se = me.n()).done; ) {
                var ge = se.value;
                K.set(ge, ge.$__.activePaths.clone());
              }
            } catch (_e) {
              me.e(_e);
            } finally {
              me.f();
            }
          }
          return new I(K, this.$__.activePaths.clone(), this.$__.version);
        }, Le.prototype.$restoreModifiedPathsSnapshot = function(K) {
          if (this.$__.activePaths = K.activePaths.clone(), this.$__.version = K.version, !this.$isSubdocument) {
            var se, me = m(this.$getAllSubdocs());
            try {
              for (me.s(); !(se = me.n()).done; ) {
                var ge = se.value;
                K.subdocSnapshot.has(ge) && (ge.$__.activePaths = K.subdocSnapshot.get(ge));
              }
            } catch (_e) {
              me.e(_e);
            } finally {
              me.f();
            }
          }
          return this;
        }, Le.prototype.$clearModifiedPaths = function() {
          if (this.$__.activePaths.clear("modify"), this.$__.activePaths.clear("init"), this.$__.version = 0, !this.$isSubdocument) {
            var K, se = m(this.$getAllSubdocs());
            try {
              for (se.s(); !(K = se.n()).done; ) K.value.$clearModifiedPaths();
            } catch (me) {
              se.e(me);
            } finally {
              se.f();
            }
          }
          return this;
        }, Le.prototype.$__hasOnlyPrimitiveValues = function() {
          return !this.$__.populated && !this.$__.wasPopulated && (this._doc == null || Object.values(this._doc).every(function(K) {
            return K == null || b(K) !== "object" || pe.isNativeObject(K) && !Array.isArray(K) || U(K, "ObjectId") || U(K, "Decimal128");
          }));
        }, Le.VERSION_WHERE = 1, Le.VERSION_INC = 2, Le.VERSION_ALL = 3, Le.ValidationError = V, o.exports = Le;
      }, 2401: (o) => {
        o.exports = Math.floor;
      }, 2402: (o, s, a) => {
        function u(M) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(N) {
            return typeof N;
          } : function(N) {
            return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : typeof N;
          }, u(M);
        }
        function c(M) {
          return c = typeof Symbol == "function" && u(Symbol.iterator) === "symbol" ? function(N) {
            return u(N);
          } : function(N) {
            return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : u(N);
          }, c(M);
        }
        var f, h, y = a(3743).codes, p = y.ERR_AMBIGUOUS_ARGUMENT, l = y.ERR_INVALID_ARG_TYPE, d = y.ERR_INVALID_ARG_VALUE, v = y.ERR_INVALID_RETURN_VALUE, m = y.ERR_MISSING_ARGS, g = a(9068), _ = a(7352).inspect, b = a(7352).types, w = b.isPromise, A = b.isRegExp, E = Object.assign ? Object.assign : a(6182).assign, O = Object.is ? Object.is : a(2064);
        function $() {
          var M = a(6193);
          f = M.isDeepEqual, h = M.isDeepStrictEqual;
        }
        var k = !1, j = o.exports = z, P = {};
        function R(M) {
          throw M.message instanceof Error ? M.message : new g(M);
        }
        function I(M, N, Z, Y) {
          if (!Z) {
            var ie = !1;
            if (N === 0) ie = !0, Y = "No value argument passed to `assert.ok()`";
            else if (Y instanceof Error) throw Y;
            var le = new g({ actual: Z, expected: !0, message: Y, operator: "==", stackStartFn: M });
            throw le.generatedMessage = ie, le;
          }
        }
        function z() {
          for (var M = arguments.length, N = new Array(M), Z = 0; Z < M; Z++) N[Z] = arguments[Z];
          I.apply(void 0, [z, N.length].concat(N));
        }
        j.fail = function M(N, Z, Y, ie, le) {
          var de, ae = arguments.length;
          if (ae === 0 ? de = "Failed" : ae === 1 ? (Y = N, N = void 0) : (k === !1 && (k = !0, ({}.emitWarning ? {}.emitWarning : console.warn.bind(console))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")), ae === 2 && (ie = "!=")), Y instanceof Error) throw Y;
          var ne = { actual: N, expected: Z, operator: ie === void 0 ? "fail" : ie, stackStartFn: le || M };
          Y !== void 0 && (ne.message = Y);
          var he = new g(ne);
          throw de && (he.message = de, he.generatedMessage = !0), he;
        }, j.AssertionError = g, j.ok = z, j.equal = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          N != Z && R({ actual: N, expected: Z, message: Y, operator: "==", stackStartFn: M });
        }, j.notEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          N == Z && R({ actual: N, expected: Z, message: Y, operator: "!=", stackStartFn: M });
        }, j.deepEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          f === void 0 && $(), f(N, Z) || R({ actual: N, expected: Z, message: Y, operator: "deepEqual", stackStartFn: M });
        }, j.notDeepEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          f === void 0 && $(), f(N, Z) && R({ actual: N, expected: Z, message: Y, operator: "notDeepEqual", stackStartFn: M });
        }, j.deepStrictEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          f === void 0 && $(), h(N, Z) || R({ actual: N, expected: Z, message: Y, operator: "deepStrictEqual", stackStartFn: M });
        }, j.notDeepStrictEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          f === void 0 && $(), h(N, Z) && R({ actual: N, expected: Z, message: Y, operator: "notDeepStrictEqual", stackStartFn: M });
        }, j.strictEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          O(N, Z) || R({ actual: N, expected: Z, message: Y, operator: "strictEqual", stackStartFn: M });
        }, j.notStrictEqual = function M(N, Z, Y) {
          if (arguments.length < 2) throw new m("actual", "expected");
          O(N, Z) && R({ actual: N, expected: Z, message: Y, operator: "notStrictEqual", stackStartFn: M });
        };
        var W = function M(N, Z, Y) {
          var ie = this;
          (function(le, de) {
            if (!(le instanceof de)) throw new TypeError("Cannot call a class as a function");
          })(this, M), Z.forEach(function(le) {
            le in N && (Y !== void 0 && typeof Y[le] == "string" && A(N[le]) && N[le].test(Y[le]) ? ie[le] = Y[le] : ie[le] = N[le]);
          });
        };
        function F(M, N, Z, Y) {
          if (typeof N != "function") {
            if (A(N)) return N.test(M);
            if (arguments.length === 2) throw new l("expected", ["Function", "RegExp"], N);
            if (c(M) !== "object" || M === null) {
              var ie = new g({ actual: M, expected: N, message: Z, operator: "deepStrictEqual", stackStartFn: Y });
              throw ie.operator = Y.name, ie;
            }
            var le = Object.keys(N);
            if (N instanceof Error) le.push("name", "message");
            else if (le.length === 0) throw new d("error", N, "may not be an empty object");
            return f === void 0 && $(), le.forEach(function(de) {
              typeof M[de] == "string" && A(N[de]) && N[de].test(M[de]) || (function(ae, ne, he, x, U, B) {
                if (!(he in ae) || !h(ae[he], ne[he])) {
                  if (!x) {
                    var J = new W(ae, U), X = new W(ne, U, ae), oe = new g({ actual: J, expected: X, operator: "deepStrictEqual", stackStartFn: B });
                    throw oe.actual = ae, oe.expected = ne, oe.operator = B.name, oe;
                  }
                  R({ actual: ae, expected: ne, message: x, operator: B.name, stackStartFn: B });
                }
              })(M, N, de, Z, le, Y);
            }), !0;
          }
          return N.prototype !== void 0 && M instanceof N || !Error.isPrototypeOf(N) && N.call({}, M) === !0;
        }
        function te(M) {
          if (typeof M != "function") throw new l("fn", "Function", M);
          try {
            M();
          } catch (N) {
            return N;
          }
          return P;
        }
        function ee(M) {
          return w(M) || M !== null && c(M) === "object" && typeof M.then == "function" && typeof M.catch == "function";
        }
        function V(M) {
          return Promise.resolve().then(function() {
            var N;
            if (typeof M == "function") {
              if (!ee(N = M())) throw new v("instance of Promise", "promiseFn", N);
            } else {
              if (!ee(M)) throw new l("promiseFn", ["Function", "Promise"], M);
              N = M;
            }
            return Promise.resolve().then(function() {
              return N;
            }).then(function() {
              return P;
            }).catch(function(Z) {
              return Z;
            });
          });
        }
        function T(M, N, Z, Y) {
          if (typeof Z == "string") {
            if (arguments.length === 4) throw new l("error", ["Object", "Error", "Function", "RegExp"], Z);
            if (c(N) === "object" && N !== null) {
              if (N.message === Z) throw new p("error/message", 'The error message "'.concat(N.message, '" is identical to the message.'));
            } else if (N === Z) throw new p("error/message", 'The error "'.concat(N, '" is identical to the message.'));
            Y = Z, Z = void 0;
          } else if (Z != null && c(Z) !== "object" && typeof Z != "function") throw new l("error", ["Object", "Error", "Function", "RegExp"], Z);
          if (N === P) {
            var ie = "";
            Z && Z.name && (ie += " (".concat(Z.name, ")")), ie += Y ? ": ".concat(Y) : ".";
            var le = M.name === "rejects" ? "rejection" : "exception";
            R({ actual: void 0, expected: Z, operator: M.name, message: "Missing expected ".concat(le).concat(ie), stackStartFn: M });
          }
          if (Z && !F(N, Z, Y, M)) throw N;
        }
        function D(M, N, Z, Y) {
          if (N !== P) {
            if (typeof Z == "string" && (Y = Z, Z = void 0), !Z || F(N, Z)) {
              var ie = Y ? ": ".concat(Y) : ".", le = M.name === "doesNotReject" ? "rejection" : "exception";
              R({ actual: N, expected: Z, operator: M.name, message: "Got unwanted ".concat(le).concat(ie, `
`) + 'Actual message: "'.concat(N && N.message, '"'), stackStartFn: M });
            }
            throw N;
          }
        }
        function L() {
          for (var M = arguments.length, N = new Array(M), Z = 0; Z < M; Z++) N[Z] = arguments[Z];
          I.apply(void 0, [L, N.length].concat(N));
        }
        j.throws = function M(N) {
          for (var Z = arguments.length, Y = new Array(Z > 1 ? Z - 1 : 0), ie = 1; ie < Z; ie++) Y[ie - 1] = arguments[ie];
          T.apply(void 0, [M, te(N)].concat(Y));
        }, j.rejects = function M(N) {
          for (var Z = arguments.length, Y = new Array(Z > 1 ? Z - 1 : 0), ie = 1; ie < Z; ie++) Y[ie - 1] = arguments[ie];
          return V(N).then(function(le) {
            return T.apply(void 0, [M, le].concat(Y));
          });
        }, j.doesNotThrow = function M(N) {
          for (var Z = arguments.length, Y = new Array(Z > 1 ? Z - 1 : 0), ie = 1; ie < Z; ie++) Y[ie - 1] = arguments[ie];
          D.apply(void 0, [M, te(N)].concat(Y));
        }, j.doesNotReject = function M(N) {
          for (var Z = arguments.length, Y = new Array(Z > 1 ? Z - 1 : 0), ie = 1; ie < Z; ie++) Y[ie - 1] = arguments[ie];
          return V(N).then(function(le) {
            return D.apply(void 0, [M, le].concat(Y));
          });
        }, j.ifError = function M(N) {
          if (N != null) {
            var Z = "ifError got unwanted exception: ";
            c(N) === "object" && typeof N.message == "string" ? N.message.length === 0 && N.constructor ? Z += N.constructor.name : Z += N.message : Z += _(N);
            var Y = new g({ actual: N, expected: null, operator: "ifError", message: Z, stackStartFn: M }), ie = N.stack;
            if (typeof ie == "string") {
              var le = ie.split(`
`);
              le.shift();
              for (var de = Y.stack.split(`
`), ae = 0; ae < le.length; ae++) {
                var ne = de.indexOf(le[ae]);
                if (ne !== -1) {
                  de = de.slice(0, ne);
                  break;
                }
              }
              Y.stack = "".concat(de.join(`
`), `
`).concat(le.join(`
`));
            }
            throw Y;
          }
        }, j.strict = E(L, j, { equal: j.strictEqual, deepEqual: j.deepStrictEqual, notEqual: j.notStrictEqual, notDeepEqual: j.notDeepStrictEqual }), j.strict.strict = j.strict;
      }, 2403: (o) => {
        o.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
      }, 2423: (o) => {
        o.exports = function(s, a) {
          var u = s.discriminatorMapping && s.discriminatorMapping.value;
          if (u && !("sparse" in a)) {
            var c = s.options.discriminatorKey;
            a.partialFilterExpression = a.partialFilterExpression || {}, a.partialFilterExpression[c] = u;
          }
          return a;
        };
      }, 2477: (o, s, a) => {
        var u = a(2402);
        o.exports = function(c) {
          return c == null || c === "" ? null : c instanceof Date ? (u.ok(!isNaN(c.valueOf())), c) : (u.ok(typeof c != "boolean"), f = c instanceof Number || typeof c == "number" ? new Date(c) : typeof c == "string" && !isNaN(Number(c)) && (Number(c) >= 275761 || Number(c) < -271820) ? new Date(Number(c)) : typeof c.valueOf == "function" ? new Date(c.valueOf()) : new Date(c), isNaN(f.valueOf()) ? void u.ok(!1) : f);
          var f;
        };
      }, 2481: (o, s, a) => {
        var u = a(4756);
        o.exports = function() {
          return typeof Object.is == "function" ? Object.is : u;
        };
      }, 2486: (o, s) => {
        s.read = function(a, u, c, f, h) {
          var y, p, l = 8 * h - f - 1, d = (1 << l) - 1, v = d >> 1, m = -7, g = c ? h - 1 : 0, _ = c ? -1 : 1, b = a[u + g];
          for (g += _, y = b & (1 << -m) - 1, b >>= -m, m += l; m > 0; y = 256 * y + a[u + g], g += _, m -= 8) ;
          for (p = y & (1 << -m) - 1, y >>= -m, m += f; m > 0; p = 256 * p + a[u + g], g += _, m -= 8) ;
          if (y === 0) y = 1 - v;
          else {
            if (y === d) return p ? NaN : 1 / 0 * (b ? -1 : 1);
            p += Math.pow(2, f), y -= v;
          }
          return (b ? -1 : 1) * p * Math.pow(2, y - f);
        }, s.write = function(a, u, c, f, h, y) {
          var p, l, d, v = 8 * y - h - 1, m = (1 << v) - 1, g = m >> 1, _ = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, b = f ? 0 : y - 1, w = f ? 1 : -1, A = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
          for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (l = isNaN(u) ? 1 : 0, p = m) : (p = Math.floor(Math.log(u) / Math.LN2), u * (d = Math.pow(2, -p)) < 1 && (p--, d *= 2), (u += p + g >= 1 ? _ / d : _ * Math.pow(2, 1 - g)) * d >= 2 && (p++, d /= 2), p + g >= m ? (l = 0, p = m) : p + g >= 1 ? (l = (u * d - 1) * Math.pow(2, h), p += g) : (l = u * Math.pow(2, g - 1) * Math.pow(2, h), p = 0)); h >= 8; a[c + b] = 255 & l, b += w, l /= 256, h -= 8) ;
          for (p = p << h | l, v += h; v > 0; a[c + b] = 255 & p, b += w, p /= 256, v -= 8) ;
          a[c + b - w] |= 128 * A;
        };
      }, 2497: (o, s, a) => {
        var u = a(1243).isMongooseArray;
        o.exports = function(c) {
          return c != null && (u(c) || c.$__ != null || c.isMongooseBuffer || c.$isMongooseMap);
        };
      }, 2555: (o) => {
        o.exports = function(s) {
          if (Array.isArray(s)) {
            if (!s.every(function(a) {
              return typeof a == "number" || typeof a == "string";
            })) throw new Error("$type array values must be strings or numbers");
            return s;
          }
          if (typeof s != "number" && typeof s != "string") throw new Error("$type parameter must be number, string, or array of numbers and strings");
          return s;
        };
      }, 2580: (o, s, a) => {
        var u = a(2400), c = a(3550).EventEmitter, f = a(3672), h = a(7058), y = a(5549), p = f.ValidationError, l = a(4957), d = a(608);
        function v(m, g, _, b, w) {
          if (!(this instanceof v)) return new v(m, g, _, b, w);
          if (d(g) && !g.instanceOfSchema && (g = new h(g)), g = this.schema || g, !this.schema && g.options._id && (m = m || {})._id === void 0 && (m._id = new y()), !g) throw new f.MissingSchemaError();
          for (var A in this.$__setSchema(g), u.call(this, m, _, b, w), l(this, g, { decorateDoc: !0 }), g.methods) this[A] = g.methods[A];
          for (var E in g.statics) this[E] = g.statics[E];
        }
        v.prototype = Object.create(u.prototype), v.prototype.constructor = v, v.events = new c(), v.$emitter = new c(), ["on", "once", "emit", "listeners", "removeListener", "setMaxListeners", "removeAllListeners", "addListener"].forEach(function(m) {
          v[m] = function() {
            return v.$emitter[m].apply(v.$emitter, arguments);
          };
        }), v.ValidationError = p, o.exports = v;
      }, 2653: (o) => {
        o.exports = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
      }, 2692: (o) => {
        o.exports = function(s, a) {
          if (a.length !== 1) {
            for (var u = a[0], c = void 0, f = 0; f < a.length - 1; ++f) {
              var h = s.path(u);
              h && h.schema ? (c = h.schema.options.strict, s = h.schema, u = h.$isMongooseDocumentArray && !isNaN(a[f + 1]) ? "" : a[f + 1]) : u += u.length ? "." + a[f + 1] : a[f + 1];
            }
            return c;
          }
        };
      }, 2696: (o, s, a) => {
        var u = a(3305);
        o.exports = function(c, f) {
          return typeof c == "string" && typeof f == "string" || typeof c == "number" && typeof f == "number" ? c === f : !(!u(c, "ObjectId") || !u(f, "ObjectId")) && c.toString() === f.toString();
        };
      }, 2724: (o, s, a) => {
        var u = a(3071), c = a(9344), f = u("RegExp.prototype.exec"), h = a(2268);
        o.exports = function(y) {
          if (!c(y)) throw new h("`regex` must be a RegExp");
          return function(p) {
            return f(y, p) !== null;
          };
        };
      }, 2746: (o) => {
        var s = typeof {}.nextTick == "function" ? {}.nextTick.bind({ env: {} }) : function(a) {
          return setTimeout(a, 0);
        };
        o.exports = function(a) {
          return s(a);
        };
      }, 2789: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          if (a == null || s(a) !== "object") return !1;
          var u = Object.getPrototypeOf(a);
          return !u || u.constructor.name === "Object";
        };
      }, 2793: (o) => {
        o.exports = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
      }, 2822: (o, s, a) => {
        o.exports = a(6353).Double;
      }, 2824: (o, s, a) => {
        var u = a(7930).objectIdSymbol, c = a(8768);
        function f() {
          var y, p;
          if (this.$__.shardval) {
            p = (y = Object.keys(this.$__.shardval)).length, this.$where = this.$where || {};
            for (var l = 0; l < p; ++l) this.$where[y[l]] = this.$__.shardval[y[l]];
          }
        }
        function h() {
          var y = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
          if (c.isPOJO(y)) for (var p, l = this.$__.shardval = {}, d = Object.keys(y), v = d.length, m = 0; m < v; ++m) (p = this.$__getValue(d[m])) == null ? l[d[m]] = p : c.isMongooseObject(p) ? l[d[m]] = p.toObject({ depopulate: !0, _isNested: !0 }) : p instanceof Date || p[u] ? l[d[m]] = p : typeof p.valueOf == "function" ? l[d[m]] = p.valueOf() : l[d[m]] = p;
        }
        o.exports = function(y) {
          y.post("init", function() {
            return h.call(this), this;
          }), y.pre("save", function(p) {
            f.call(this), p();
          }), y.pre("remove", function(p) {
            f.call(this), p();
          }), y.post("save", function() {
            h.call(this);
          });
        }, o.exports.storeShard = h;
      }, 2900: (o, s, a) => {
        var u = a(8260);
        o.exports = function(c) {
          if (u(c) !== "TopologyDescription") return !1;
          var f = Array.from(c.servers.values());
          return f.length > 0 && f.every(function(h) {
            return h.type === "Unknown";
          });
        };
      }, 2914: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        var c = a(7860), f = ["__proto__", "constructor", "prototype"];
        function h(p, l, d, v, m, g) {
          for (var _, b = 0; b < p.length && b < l.length; ++b) _ = p[b], Array.isArray(_) && Array.isArray(l[b]) ? h(_, l[b], d, v, m, g) : _ && (v ? v(_, d, g(l[b])) : (_[m] && (_ = _[m]), _[d] = g(l[b])));
        }
        function y(p) {
          return p;
        }
        s.get = function(p, l, d, v) {
          var m;
          typeof d == "function" && (d.length < 2 ? (v = d, d = void 0) : (m = d, d = void 0)), v || (v = y);
          var g = typeof p == "string" ? c(p) : p;
          if (!Array.isArray(g)) throw new TypeError("Invalid `path`. Must be either string or array");
          for (var _, b = l, w = 0; w < g.length; ++w) {
            if (_ = g[w], typeof g[w] != "string" && typeof g[w] != "number") throw new TypeError("Each segment of path to `get()` must be a string or number, got " + u(g[w]));
            if (Array.isArray(b) && !/^\d+$/.test(_)) {
              var A = g.slice(w);
              return [].concat(b).map(function(O) {
                return O ? s.get(A, O, d || m, v) : v(void 0);
              });
            }
            if (m) b = m(b, _);
            else {
              var E = d && b[d] ? b[d] : b;
              b = E instanceof Map ? E.get(_) : E[_];
            }
            if (!b) return v(b);
          }
          return v(b);
        }, s.has = function(p, l) {
          var d = typeof p == "string" ? c(p) : p;
          if (!Array.isArray(d)) throw new TypeError("Invalid `path`. Must be either string or array");
          for (var v = d.length, m = l, g = 0; g < v; ++g) {
            if (typeof d[g] != "string" && typeof d[g] != "number") throw new TypeError("Each segment of path to `has()` must be a string or number, got " + u(d[g]));
            if (m == null || u(m) !== "object" || !(d[g] in m)) return !1;
            m = m[d[g]];
          }
          return !0;
        }, s.unset = function(p, l) {
          var d = typeof p == "string" ? c(p) : p;
          if (!Array.isArray(d)) throw new TypeError("Invalid `path`. Must be either string or array");
          for (var v = d.length, m = l, g = 0; g < v; ++g) {
            if (m == null || u(m) !== "object" || !(d[g] in m)) return !1;
            if (typeof d[g] != "string" && typeof d[g] != "number") throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + u(d[g]));
            if (f.indexOf(d[g]) !== -1) return !1;
            if (g === v - 1) return delete m[d[g]], !0;
            m = m instanceof Map ? m.get(d[g]) : m[d[g]];
          }
          return !0;
        }, s.set = function(p, l, d, v, m, g) {
          var _;
          typeof v == "function" && (v.length < 2 ? (m = v, v = void 0) : (_ = v, v = void 0)), m || (m = y);
          var b = typeof p == "string" ? c(p) : p;
          if (!Array.isArray(b)) throw new TypeError("Invalid `path`. Must be either string or array");
          if (d != null) {
            for (var w = 0; w < b.length; ++w) {
              if (typeof b[w] != "string" && typeof b[w] != "number") throw new TypeError("Each segment of path to `set()` must be a string or number, got " + u(b[w]));
              if (f.indexOf(b[w]) !== -1) return;
            }
            for (var A, E = g || /\$/.test(p) && g !== !1, O = d, $ = (w = 0, b.length - 1); w < $; ++w) if ((A = b[w]) != "$") {
              if (Array.isArray(O) && !/^\d+$/.test(A)) {
                var k = b.slice(w);
                if (!E && Array.isArray(l)) for (var j = 0; j < O.length && j < l.length; ++j) s.set(k, l[j], O[j], v || _, m, E);
                else for (j = 0; j < O.length; ++j) s.set(k, l, O[j], v || _, m, E);
                return;
              }
              if (_) O = _(O, A);
              else {
                var P = v && O[v] ? O[v] : O;
                O = P instanceof Map ? P.get(A) : P[A];
              }
              if (!O) return;
            } else if (w == $ - 1) break;
            if (A = b[$], v && O[v] && (O = O[v]), Array.isArray(O) && !/^\d+$/.test(A)) if (!E && Array.isArray(l)) h(O, l, A, _, v, m);
            else for (j = 0; j < O.length; ++j) {
              var R = O[j];
              R && (_ ? _(R, A, m(l)) : (R[v] && (R = R[v]), R[A] = m(l)));
            }
            else _ ? _(O, A, m(l)) : O instanceof Map ? O.set(A, m(l)) : O[A] = m(l);
          }
        }, s.stringToParts = c;
      }, 2945: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "subtype", p), o.exports = y;
      }, 3071: (o, s, a) => {
        var u = a(6400), c = a(8863), f = c([u("%String.prototype.indexOf%")]);
        o.exports = function(h, y) {
          var p = u(h, !!y);
          return typeof p == "function" && f(h, ".prototype.") > -1 ? c([p]) : p;
        };
      }, 3091: (o, s, a) => {
        function u(j) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(P) {
            return typeof P;
          } : function(P) {
            return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
          }, u(j);
        }
        function c(j, P) {
          var R = Object.keys(j);
          if (Object.getOwnPropertySymbols) {
            var I = Object.getOwnPropertySymbols(j);
            P && (I = I.filter(function(z) {
              return Object.getOwnPropertyDescriptor(j, z).enumerable;
            })), R.push.apply(R, I);
          }
          return R;
        }
        function f(j) {
          for (var P = 1; P < arguments.length; P++) {
            var R = arguments[P] != null ? arguments[P] : {};
            P % 2 ? c(Object(R), !0).forEach(function(I) {
              h(j, I, R[I]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(j, Object.getOwnPropertyDescriptors(R)) : c(Object(R)).forEach(function(I) {
              Object.defineProperty(j, I, Object.getOwnPropertyDescriptor(R, I));
            });
          }
          return j;
        }
        function h(j, P, R) {
          return (P = (function(I) {
            var z = (function(W) {
              if (u(W) != "object" || !W) return W;
              var F = W[Symbol.toPrimitive];
              if (F !== void 0) {
                var te = F.call(W, "string");
                if (u(te) != "object") return te;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(W);
            })(I);
            return u(z) == "symbol" ? z : z + "";
          })(P)) in j ? Object.defineProperty(j, P, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : j[P] = R, j;
        }
        var y, p = a(4625), l = a(6426), d = a(863), v = a(4327), m = a(8260), g = a(5549), _ = a(3305), b = a(8768), w = l.CastError;
        function A(j, P) {
          var R = typeof j == "string" && j.length === 24 && /^[a-f0-9]+$/i.test(j), I = P && P.suppressWarning;
          !R && j !== void 0 || I || b.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema."), l.call(this, j, P, "ObjectId");
        }
        function E(j) {
          return this.cast(j);
        }
        A.schemaName = "ObjectId", A.defaultOptions = {}, A.prototype = Object.create(l.prototype), A.prototype.constructor = A, A.prototype.OptionsConstructor = p, A.get = l.get, A.set = l.set, A.setters = [], A.prototype.auto = function(j) {
          return j && (this.default($), this.set(k)), this;
        }, A._checkRequired = function(j) {
          return _(j, "ObjectId");
        }, A._cast = d, A.cast = function(j) {
          return arguments.length === 0 || (j === !1 && (j = this._defaultCaster), this._cast = j), this._cast;
        }, A._defaultCaster = function(j) {
          if (!_(j, "ObjectId")) throw new Error(j + " is not an instance of ObjectId");
          return j;
        }, A.checkRequired = l.checkRequired, A.prototype.checkRequired = function(j, P) {
          return l._isRef(this, j, P, !0) ? !!j : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : A.checkRequired())(j);
        }, A.prototype.cast = function(j, P, R, I, z) {
          if (!_(j, "ObjectId") && l._isRef(this, j, P, R)) {
            if ((m(j) || "").toLowerCase() === "objectid") return new g(j.toHexString());
            if (j == null || b.isNonBuiltinObject(j)) return this._castRef(j, P, R, z);
          }
          var W;
          W = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : A.cast();
          try {
            return W(j);
          } catch (F) {
            throw new w("ObjectId", j, this.path, F, this);
          }
        };
        var O = f(f({}, l.prototype.$conditionalHandlers), {}, { $gt: E, $gte: E, $lt: E, $lte: E });
        function $() {
          return new g();
        }
        function k(j) {
          return y || (y = a(2400)), this instanceof y && j === void 0 ? new g() : j;
        }
        Object.defineProperty(A.prototype, "$conditionalHandlers", { enumerable: !1, value: O }), $.$runBeforeSetters = !0, A.prototype.toJSONSchema = function(j) {
          var P = this.options.required && typeof this.options.required != "function" || this.path === "_id";
          return v("string", "objectId", j?.useBsonType, P);
        }, A.prototype.autoEncryptionType = function() {
          return "objectId";
        }, o.exports = A;
      }, 3123: (o) => {
        o.exports = Function.prototype.call;
      }, 3191: (o, s, a) => {
        var u = a(988), c = function() {
          return !!u;
        };
        c.hasArrayLengthDefineBug = function() {
          if (!u) return null;
          try {
            return u([], "length", { value: 1 }).length !== 1;
          } catch {
            return !0;
          }
        }, o.exports = c;
      }, 3216: (o, s, a) => {
        function u(l, d) {
          var v = Object.keys(l);
          if (Object.getOwnPropertySymbols) {
            var m = Object.getOwnPropertySymbols(l);
            d && (m = m.filter(function(g) {
              return Object.getOwnPropertyDescriptor(l, g).enumerable;
            })), v.push.apply(v, m);
          }
          return v;
        }
        function c(l) {
          for (var d = 1; d < arguments.length; d++) {
            var v = arguments[d] != null ? arguments[d] : {};
            d % 2 ? u(Object(v), !0).forEach(function(m) {
              f(l, m, v[m]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(v)) : u(Object(v)).forEach(function(m) {
              Object.defineProperty(l, m, Object.getOwnPropertyDescriptor(v, m));
            });
          }
          return l;
        }
        function f(l, d, v) {
          return (d = (function(m) {
            var g = (function(_) {
              if (h(_) != "object" || !_) return _;
              var b = _[Symbol.toPrimitive];
              if (b !== void 0) {
                var w = b.call(_, "string");
                if (h(w) != "object") return w;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(_);
            })(m);
            return h(g) == "symbol" ? g : g + "";
          })(d)) in l ? Object.defineProperty(l, d, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : l[d] = v, l;
        }
        function h(l) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, h(l);
        }
        var y = a(8768), p = /* @__PURE__ */ new Set(["__index", "__parentArray", "_doc"]);
        o.exports = function(l, d) {
          if (y.isPOJO(l) && l.$__ != null && l._doc != null) {
            if (d) {
              for (var v = {}, m = 0, g = Object.keys(l); m < g.length; m++) {
                var _ = g[m];
                h(_) !== "symbol" && _[0] !== "$" && (p.has(_) || (v[_] = l[_]));
              }
              return c(c({}, l._doc), v);
            }
            return l._doc;
          }
          return l;
        };
      }, 3279: (o) => {
        o.exports = Function.prototype.apply;
      }, 3303: (o, s) => {
        s._ = { transform: !1, virtuals: !1, getters: !1, _skipDepopulateTopLevel: !0, depopulate: !0, flattenDecimals: !1, useProjection: !1, versionKey: !0, flattenObjectIds: !1 };
      }, 3305: (o) => {
        o.exports = function(s, a) {
          return s != null && s._bsontype === a;
        };
      }, 3318: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        function c(_, b) {
          var w = Object.keys(_);
          if (Object.getOwnPropertySymbols) {
            var A = Object.getOwnPropertySymbols(_);
            b && (A = A.filter(function(E) {
              return Object.getOwnPropertyDescriptor(_, E).enumerable;
            })), w.push.apply(w, A);
          }
          return w;
        }
        function f(_) {
          for (var b = 1; b < arguments.length; b++) {
            var w = arguments[b] != null ? arguments[b] : {};
            b % 2 ? c(Object(w), !0).forEach(function(A) {
              h(_, A, w[A]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(w)) : c(Object(w)).forEach(function(A) {
              Object.defineProperty(_, A, Object.getOwnPropertyDescriptor(w, A));
            });
          }
          return _;
        }
        function h(_, b, w) {
          return (b = (function(A) {
            var E = (function(O) {
              if (u(O) != "object" || !O) return O;
              var $ = O[Symbol.toPrimitive];
              if ($ !== void 0) {
                var k = $.call(O, "string");
                if (u(k) != "object") return k;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(O);
            })(A);
            return u(E) == "symbol" ? E : E + "";
          })(b)) in _ ? Object.defineProperty(_, b, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : _[b] = w, _;
        }
        var y = a(3609), p = a(6426), l = a(4058), d = a(4327);
        function v(_, b) {
          p.call(this, _, b, "BigInt");
        }
        v.schemaName = "BigInt", v.defaultOptions = {}, v.prototype = Object.create(p.prototype), v.prototype.constructor = v, v._cast = l, v.set = p.set, v.setters = [], v.get = p.get, v.cast = function(_) {
          return arguments.length === 0 || (_ === !1 && (_ = this._defaultCaster), this._cast = _), this._cast;
        }, v._checkRequired = function(_) {
          return _ != null;
        }, v.checkRequired = p.checkRequired, v.prototype.checkRequired = function(_) {
          return this.constructor._checkRequired(_);
        }, v.prototype.cast = function(_) {
          var b;
          b = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : v.cast();
          try {
            return b(_);
          } catch (w) {
            throw new y("BigInt", _, this.path, w, this);
          }
        };
        var m = f(f({}, p.prototype.$conditionalHandlers), {}, { $gt: g, $gte: g, $lt: g, $lte: g });
        function g(_, b) {
          return this.castForQuery(null, _, b);
        }
        Object.defineProperty(v.prototype, "$conditionalHandlers", { enumerable: !1, value: m }), v.prototype.castForQuery = function(_, b, w) {
          var A;
          if (_ != null) return (A = this.$conditionalHandlers[_]) ? A.call(this, b) : this.applySetters(b, w);
          try {
            return this.applySetters(b, w);
          } catch (E) {
            throw E instanceof y && E.path === this.path && this.$fullPath != null && (E.path = this.$fullPath), E;
          }
        }, v.prototype._castNullish = function(_) {
          return _ === void 0 || (typeof this.constructor.cast == "function" ? this.constructor.cast() : v.cast()), _;
        }, v.prototype.toJSONSchema = function(_) {
          var b = this.options.required && typeof this.options.required != "function";
          return d("string", "long", _?.useBsonType, b);
        }, v.prototype.autoEncryptionType = function() {
          return "long";
        }, o.exports = v;
      }, 3381: (o) => {
        function s() {
          return this._id != null ? this._id.toString() : null;
        }
        o.exports = function(a) {
          return !a.paths.id && a.paths._id && a.options.id && (a.aliases && a.aliases.id || a.virtual("id").get(s)), a;
        };
      }, 3388: (o) => {
        o.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
      }, 3414: (o) => {
        o.exports = Number.isNaN || function(s) {
          return s != s;
        };
      }, 3426: (o, s, a) => {
        var u = a(2653), c = typeof globalThis > "u" ? a.g : globalThis;
        o.exports = function() {
          for (var f = [], h = 0; h < u.length; h++) typeof c[u[h]] == "function" && (f[f.length] = u[h]);
          return f;
        };
      }, 3441: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m) {
            var g;
            (function(b, w) {
              if (!(b instanceof w)) throw new TypeError("Cannot call a class as a function");
            })(this, l);
            var _ = Array.isArray(m) ? "array" : "primitive value";
            return (g = (function(b, w, A) {
              return w = f(w), (function(E, O) {
                if (O && (u(O) == "object" || typeof O == "function")) return O;
                if (O !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function($) {
                  if ($ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return $;
                })(E);
              })(b, c() ? Reflect.construct(w, A || [], f(b).constructor) : w.apply(b, A));
            })(this, l, ["Tried to set nested object field `" + v + "` to ".concat(_, " `") + m + "`"])).path = v, g;
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "ObjectExpectedError" }), o.exports = y;
      }, 3550: (o) => {
        function s(A) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          }, s(A);
        }
        var a, u = (typeof Reflect > "u" ? "undefined" : s(Reflect)) === "object" ? Reflect : null, c = u && typeof u.apply == "function" ? u.apply : function(A, E, O) {
          return Function.prototype.apply.call(A, E, O);
        };
        a = u && typeof u.ownKeys == "function" ? u.ownKeys : Object.getOwnPropertySymbols ? function(A) {
          return Object.getOwnPropertyNames(A).concat(Object.getOwnPropertySymbols(A));
        } : function(A) {
          return Object.getOwnPropertyNames(A);
        };
        var f = Number.isNaN || function(A) {
          return A != A;
        };
        function h() {
          h.init.call(this);
        }
        o.exports = h, o.exports.once = function(A, E) {
          return new Promise(function(O, $) {
            function k(P) {
              A.removeListener(E, j), $(P);
            }
            function j() {
              typeof A.removeListener == "function" && A.removeListener("error", k), O([].slice.call(arguments));
            }
            w(A, E, j, { once: !0 }), E !== "error" && (function(P, R) {
              typeof P.on == "function" && w(P, "error", R, { once: !0 });
            })(A, k);
          });
        }, h.EventEmitter = h, h.prototype._events = void 0, h.prototype._eventsCount = 0, h.prototype._maxListeners = void 0;
        var y = 10;
        function p(A) {
          if (typeof A != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + s(A));
        }
        function l(A) {
          return A._maxListeners === void 0 ? h.defaultMaxListeners : A._maxListeners;
        }
        function d(A, E, O, $) {
          var k, j, P, R;
          if (p(O), (j = A._events) === void 0 ? (j = A._events = /* @__PURE__ */ Object.create(null), A._eventsCount = 0) : (j.newListener !== void 0 && (A.emit("newListener", E, O.listener ? O.listener : O), j = A._events), P = j[E]), P === void 0) P = j[E] = O, ++A._eventsCount;
          else if (typeof P == "function" ? P = j[E] = $ ? [O, P] : [P, O] : $ ? P.unshift(O) : P.push(O), (k = l(A)) > 0 && P.length > k && !P.warned) {
            P.warned = !0;
            var I = new Error("Possible EventEmitter memory leak detected. " + P.length + " " + String(E) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            I.name = "MaxListenersExceededWarning", I.emitter = A, I.type = E, I.count = P.length, R = I, console && console.warn && console.warn(R);
          }
          return A;
        }
        function v() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function m(A, E, O) {
          var $ = { fired: !1, wrapFn: void 0, target: A, type: E, listener: O }, k = v.bind($);
          return k.listener = O, $.wrapFn = k, k;
        }
        function g(A, E, O) {
          var $ = A._events;
          if ($ === void 0) return [];
          var k = $[E];
          return k === void 0 ? [] : typeof k == "function" ? O ? [k.listener || k] : [k] : O ? (function(j) {
            for (var P = new Array(j.length), R = 0; R < P.length; ++R) P[R] = j[R].listener || j[R];
            return P;
          })(k) : b(k, k.length);
        }
        function _(A) {
          var E = this._events;
          if (E !== void 0) {
            var O = E[A];
            if (typeof O == "function") return 1;
            if (O !== void 0) return O.length;
          }
          return 0;
        }
        function b(A, E) {
          for (var O = new Array(E), $ = 0; $ < E; ++$) O[$] = A[$];
          return O;
        }
        function w(A, E, O, $) {
          if (typeof A.on == "function") $.once ? A.once(E, O) : A.on(E, O);
          else {
            if (typeof A.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + s(A));
            A.addEventListener(E, function k(j) {
              $.once && A.removeEventListener(E, k), O(j);
            });
          }
        }
        Object.defineProperty(h, "defaultMaxListeners", { enumerable: !0, get: function() {
          return y;
        }, set: function(A) {
          if (typeof A != "number" || A < 0 || f(A)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + A + ".");
          y = A;
        } }), h.init = function() {
          this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, h.prototype.setMaxListeners = function(A) {
          if (typeof A != "number" || A < 0 || f(A)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + A + ".");
          return this._maxListeners = A, this;
        }, h.prototype.getMaxListeners = function() {
          return l(this);
        }, h.prototype.emit = function(A) {
          for (var E = [], O = 1; O < arguments.length; O++) E.push(arguments[O]);
          var $ = A === "error", k = this._events;
          if (k !== void 0) $ = $ && k.error === void 0;
          else if (!$) return !1;
          if ($) {
            var j;
            if (E.length > 0 && (j = E[0]), j instanceof Error) throw j;
            var P = new Error("Unhandled error." + (j ? " (" + j.message + ")" : ""));
            throw P.context = j, P;
          }
          var R = k[A];
          if (R === void 0) return !1;
          if (typeof R == "function") c(R, this, E);
          else {
            var I = R.length, z = b(R, I);
            for (O = 0; O < I; ++O) c(z[O], this, E);
          }
          return !0;
        }, h.prototype.addListener = function(A, E) {
          return d(this, A, E, !1);
        }, h.prototype.on = h.prototype.addListener, h.prototype.prependListener = function(A, E) {
          return d(this, A, E, !0);
        }, h.prototype.once = function(A, E) {
          return p(E), this.on(A, m(this, A, E)), this;
        }, h.prototype.prependOnceListener = function(A, E) {
          return p(E), this.prependListener(A, m(this, A, E)), this;
        }, h.prototype.removeListener = function(A, E) {
          var O, $, k, j, P;
          if (p(E), ($ = this._events) === void 0) return this;
          if ((O = $[A]) === void 0) return this;
          if (O === E || O.listener === E) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete $[A], $.removeListener && this.emit("removeListener", A, O.listener || E));
          else if (typeof O != "function") {
            for (k = -1, j = O.length - 1; j >= 0; j--) if (O[j] === E || O[j].listener === E) {
              P = O[j].listener, k = j;
              break;
            }
            if (k < 0) return this;
            k === 0 ? O.shift() : (function(R, I) {
              for (; I + 1 < R.length; I++) R[I] = R[I + 1];
              R.pop();
            })(O, k), O.length === 1 && ($[A] = O[0]), $.removeListener !== void 0 && this.emit("removeListener", A, P || E);
          }
          return this;
        }, h.prototype.off = h.prototype.removeListener, h.prototype.removeAllListeners = function(A) {
          var E, O, $;
          if ((O = this._events) === void 0) return this;
          if (O.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : O[A] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete O[A]), this;
          if (arguments.length === 0) {
            var k, j = Object.keys(O);
            for ($ = 0; $ < j.length; ++$) (k = j[$]) !== "removeListener" && this.removeAllListeners(k);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (typeof (E = O[A]) == "function") this.removeListener(A, E);
          else if (E !== void 0) for ($ = E.length - 1; $ >= 0; $--) this.removeListener(A, E[$]);
          return this;
        }, h.prototype.listeners = function(A) {
          return g(this, A, !0);
        }, h.prototype.rawListeners = function(A) {
          return g(this, A, !1);
        }, h.listenerCount = function(A, E) {
          return typeof A.listenerCount == "function" ? A.listenerCount(E) : _.call(A, E);
        }, h.prototype.listenerCount = _, h.prototype.eventNames = function() {
          return this._eventsCount > 0 ? a(this._events) : [];
        };
      }, 3609: (o, s, a) => {
        function u(E) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
            return typeof O;
          } : function(O) {
            return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
          }, u(E);
        }
        function c(E, O) {
          for (var $ = 0; $ < O.length; $++) {
            var k = O[$];
            k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(E, f(k.key), k);
          }
        }
        function f(E) {
          var O = (function($) {
            if (u($) != "object" || !$) return $;
            var k = $[Symbol.toPrimitive];
            if (k !== void 0) {
              var j = k.call($, "string");
              if (u(j) != "object") return j;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String($);
          })(E);
          return u(O) == "symbol" ? O : O + "";
        }
        function h(E, O, $) {
          return O = l(O), (function(k, j) {
            if (j && (u(j) == "object" || typeof j == "function")) return j;
            if (j !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return y(k);
          })(E, p() ? Reflect.construct(O, $ || [], l(E).constructor) : O.apply(E, $));
        }
        function y(E) {
          if (E === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return E;
        }
        function p() {
          try {
            var E = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (p = function() {
            return !!E;
          })();
        }
        function l(E) {
          return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(O) {
            return O.__proto__ || Object.getPrototypeOf(O);
          }, l(E);
        }
        function d(E, O) {
          return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function($, k) {
            return $.__proto__ = k, $;
          }, d(E, O);
        }
        var v = a(8213), m = a(7352), g = (function(E) {
          function O(j, P, R, I, z) {
            var W;
            if ((function(te, ee) {
              if (!(te instanceof ee)) throw new TypeError("Cannot call a class as a function");
            })(this, O), arguments.length > 0) {
              var F = b(P);
              (W = h(this, O, [A(null, j, P, R, w(z), F, I)])).init(j, P, R, I, z);
            } else W = h(this, O, [A()]);
            return y(W);
          }
          return (function(j, P) {
            if (typeof P != "function" && P !== null) throw new TypeError("Super expression must either be null or a function");
            j.prototype = Object.create(P && P.prototype, { constructor: { value: j, writable: !0, configurable: !0 } }), Object.defineProperty(j, "prototype", { writable: !1 }), P && d(j, P);
          })(O, E), $ = O, (k = [{ key: "toJSON", value: function() {
            return { stringValue: this.stringValue, valueType: this.valueType, kind: this.kind, value: this.value, path: this.path, reason: this.reason, name: this.name, message: this.message };
          } }, { key: "init", value: function(j, P, R, I, z) {
            this.stringValue = _(P), this.messageFormat = w(z), this.kind = j, this.value = P, this.path = R, this.reason = I, this.valueType = b(P);
          } }, { key: "copy", value: function(j) {
            this.messageFormat = j.messageFormat, this.stringValue = j.stringValue, this.kind = j.kind, this.value = j.value, this.path = j.path, this.reason = j.reason, this.message = j.message, this.valueType = j.valueType;
          } }, { key: "setModel", value: function(j) {
            this.message = A(j, this.kind, this.value, this.path, this.messageFormat, this.valueType);
          } }]) && c($.prototype, k), Object.defineProperty($, "prototype", { writable: !1 }), $;
          var $, k;
        })(v);
        function _(E) {
          var O = m.inspect(E);
          return (O = O.replace(/^'|'$/g, '"')).startsWith('"') || (O = '"' + O + '"'), O;
        }
        function b(E) {
          if (E == null) return "" + E;
          var O = u(E);
          return O !== "object" || typeof E.constructor != "function" ? O : E.constructor.name;
        }
        function w(E) {
          var O = E && E._castErrorMessage || null;
          if (typeof O == "string" || typeof O == "function") return O;
        }
        function A(E, O, $, k, j, P, R) {
          if (typeof j == "string") {
            var I = _($), z = j.replace("{KIND}", O).replace("{VALUE}", I).replace("{PATH}", k);
            return E != null && (z = z.replace("{MODEL}", E.modelName)), z;
          }
          if (typeof j == "function") return j($, k, E, O);
          var W = "Cast to " + O + " failed for value " + _($) + (P ? " (type " + P + ")" : "") + ' at path "' + k + '"';
          return E != null && (W += ' for model "' + E.modelName + '"'), R != null && typeof R.constructor == "function" && R.constructor.name !== "AssertionError" && R.constructor.name !== "Error" && (W += ' because of "' + R.constructor.name + '"'), W;
        }
        Object.defineProperty(g.prototype, "name", { value: "CastError" }), o.exports = g;
      }, 3622: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a, u, c) {
          return a == null ? a : (a._doc != null && (a = a._doc), arguments.length >= 3 ? s(a) !== "object" || c === void 0 ? void 0 : (a instanceof Map ? a.set(u, c) : a[u] = c, c) : u === "$*" ? a instanceof Map ? Array.from(a.values()) : Object.keys(a).map(function(f) {
            return a[f];
          }) : a instanceof Map ? a.get(u) : a[u]);
        };
      }, 3644: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v) {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, l, ["Cannot overwrite `" + v + "` model once compiled."]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "OverwriteModelError" }), o.exports = y;
      }, 3660: (o, s, a) => {
        function u(E, O) {
          var $ = Object.keys(E);
          if (Object.getOwnPropertySymbols) {
            var k = Object.getOwnPropertySymbols(E);
            O && (k = k.filter(function(j) {
              return Object.getOwnPropertyDescriptor(E, j).enumerable;
            })), $.push.apply($, k);
          }
          return $;
        }
        function c(E) {
          for (var O = 1; O < arguments.length; O++) {
            var $ = arguments[O] != null ? arguments[O] : {};
            O % 2 ? u(Object($), !0).forEach(function(k) {
              f(E, k, $[k]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors($)) : u(Object($)).forEach(function(k) {
              Object.defineProperty(E, k, Object.getOwnPropertyDescriptor($, k));
            });
          }
          return E;
        }
        function f(E, O, $) {
          return (O = (function(k) {
            var j = (function(P) {
              if (h(P) != "object" || !P) return P;
              var R = P[Symbol.toPrimitive];
              if (R !== void 0) {
                var I = R.call(P, "string");
                if (h(I) != "object") return I;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(P);
            })(k);
            return h(j) == "symbol" ? j : j + "";
          })(O)) in E ? Object.defineProperty(E, O, { value: $, enumerable: !0, configurable: !0, writable: !0 }) : E[O] = $, E;
        }
        function h(E) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
            return typeof O;
          } : function(O) {
            return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
          }, h(E);
        }
        var y = a(3672), p = a(1007), l = a(6426), d = a(7768), v = a(4327), m = a(9460), g = a(8768), _ = l.CastError;
        function b(E, O) {
          l.call(this, E, O, "Number");
        }
        function w(E) {
          return this.cast(E);
        }
        b.get = l.get, b.set = l.set, b.setters = [], b._cast = d, b.cast = function(E) {
          return arguments.length === 0 || (E === !1 && (E = this._defaultCaster), this._cast = E), this._cast;
        }, b._defaultCaster = function(E) {
          if (typeof E != "number") throw new Error();
          return E;
        }, b.schemaName = "Number", b.defaultOptions = {}, b.prototype = Object.create(l.prototype), b.prototype.constructor = b, b.prototype.OptionsConstructor = p, b._checkRequired = function(E) {
          return typeof E == "number" || E instanceof Number;
        }, b.checkRequired = l.checkRequired, b.prototype.checkRequired = function(E, O) {
          return h(E) === "object" && l._isRef(this, E, O, !0) ? E != null : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : b.checkRequired())(E);
        }, b.prototype.min = function(E, O) {
          if (this.minValidator && (this.validators = this.validators.filter(function(k) {
            return k.validator !== this.minValidator;
          }, this)), E != null) {
            var $ = O || y.messages.Number.min;
            $ = $.replace(/{MIN}/, E), this.validators.push({ validator: this.minValidator = function(k) {
              return k == null || k >= E;
            }, message: $, type: "min", min: E });
          }
          return this;
        }, b.prototype.max = function(E, O) {
          if (this.maxValidator && (this.validators = this.validators.filter(function(k) {
            return k.validator !== this.maxValidator;
          }, this)), E != null) {
            var $ = O || y.messages.Number.max;
            $ = $.replace(/{MAX}/, E), this.validators.push({ validator: this.maxValidator = function(k) {
              return k == null || k <= E;
            }, message: $, type: "max", max: E });
          }
          return this;
        }, b.prototype.enum = function(E, O) {
          return this.enumValidator && (this.validators = this.validators.filter(function($) {
            return $.validator !== this.enumValidator;
          }, this)), Array.isArray(E) || (g.isPOJO(E) && E.values != null ? (O = E.message, E = E.values) : typeof E == "number" && (E = Array.prototype.slice.call(arguments), O = null), g.isPOJO(E) && (E = Object.values(E)), O = O || y.messages.Number.enum), O = O ?? y.messages.Number.enum, this.enumValidator = function($) {
            return $ == null || E.indexOf($) !== -1;
          }, this.validators.push({ validator: this.enumValidator, message: O, type: "enum", enumValues: E }), this;
        }, b.prototype.cast = function(E, O, $, k, j) {
          if (typeof E != "number" && l._isRef(this, E, O, $) && (E == null || g.isNonBuiltinObject(E))) return this._castRef(E, O, $, j);
          var P, R = E && E._id !== void 0 ? E._id : E;
          P = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : b.cast();
          try {
            return P(R);
          } catch (I) {
            throw new _("Number", R, this.path, I, this);
          }
        };
        var A = c(c({}, l.prototype.$conditionalHandlers), {}, { $bitsAllClear: m, $bitsAnyClear: m, $bitsAllSet: m, $bitsAnySet: m, $gt: w, $gte: w, $lt: w, $lte: w, $mod: function(E) {
          var O = this;
          return Array.isArray(E) ? E.map(function($) {
            return O.cast($);
          }) : [this.cast(E)];
        } });
        Object.defineProperty(b.prototype, "$conditionalHandlers", { enumerable: !1, value: A }), b.prototype.castForQuery = function(E, O, $) {
          var k;
          if (E != null) {
            if (!(k = this.$conditionalHandlers[E])) throw new _("number", O, this.path, null, this);
            return k.call(this, O, $);
          }
          try {
            O = this.applySetters(O, $);
          } catch (j) {
            throw j instanceof _ && j.path === this.path && this.$fullPath != null && (j.path = this.$fullPath), j;
          }
          return O;
        }, b.prototype.toJSONSchema = function(E) {
          var O = this.options.required && typeof this.options.required != "function" || this.path === "_id";
          return v("number", "number", E?.useBsonType, O);
        }, o.exports = b;
      }, 3672: (o, s, a) => {
        var u = a(8213);
        o.exports = u, u.messages = a(766), u.Messages = u.messages, u.CastError = a(3609), u.DocumentNotFoundError = a(1129), u.ValidationError = a(6949), u.ValidatorError = a(9538), u.VersionError = a(6996), u.ParallelSaveError = a(3940), u.OverwriteModelError = a(3644), u.MissingSchemaError = a(8063), u.MongooseBulkSaveIncompleteError = a(8517), u.MongooseServerSelectionError = a(7219), u.DivergentArrayError = a(1417), u.StrictModeError = a(8995), u.StrictPopulateError = a(6801);
      }, 3696: (o) => {
        o.exports = function(s, a) {
          return s == null ? null : typeof s == "boolean" ? a : typeof s[a] == "boolean" ? s[a] ? a : null : a in s ? s[a] : a;
        };
      }, 3703: (o) => {
        function s(u, c) {
          (c == null || c > u.length) && (c = u.length);
          for (var f = 0, h = Array(c); f < c; f++) h[f] = u[f];
          return h;
        }
        function a(u, c) {
          return u == null ? u : u instanceof Map ? u.get(c) : u[c];
        }
        o.exports = function(u, c, f) {
          var h, y = !1;
          if (typeof c == "string") {
            if (c.indexOf(".") === -1) {
              var p = a(u, c);
              return p ?? f;
            }
            h = c.split(".");
          } else if (y = !0, (h = c).length === 1) {
            var l = a(u, h[0]);
            return l ?? f;
          }
          var d, v = c, m = u, g = (function(b, w) {
            var A = typeof Symbol < "u" && b[Symbol.iterator] || b["@@iterator"];
            if (!A) {
              if (Array.isArray(b) || (A = (function(P, R) {
                if (P) {
                  if (typeof P == "string") return s(P, R);
                  var I = {}.toString.call(P).slice(8, -1);
                  return I === "Object" && P.constructor && (I = P.constructor.name), I === "Map" || I === "Set" ? Array.from(P) : I === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(I) ? s(P, R) : void 0;
                }
              })(b)) || w) {
                A && (b = A);
                var E = 0, O = function() {
                };
                return { s: O, n: function() {
                  return E >= b.length ? { done: !0 } : { done: !1, value: b[E++] };
                }, e: function(P) {
                  throw P;
                }, f: O };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var $, k = !0, j = !1;
            return { s: function() {
              A = A.call(b);
            }, n: function() {
              var P = A.next();
              return k = P.done, P;
            }, e: function(P) {
              j = !0, $ = P;
            }, f: function() {
              try {
                k || A.return == null || A.return();
              } finally {
                if (j) throw $;
              }
            } };
          })(h);
          try {
            for (g.s(); !(d = g.n()).done; ) {
              var _ = d.value;
              if (m == null) return f;
              if (!y && m[v] != null) return m[v];
              m = a(m, _), y || (v = v.substr(_.length + 1));
            }
          } catch (b) {
            g.e(b);
          } finally {
            g.f();
          }
          return m ?? f;
        };
      }, 3704: (o, s, a) => {
        function u(y) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
            return typeof p;
          } : function(p) {
            return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
          }, u(y);
        }
        var c = a(2402), f = a(6353), h = a(3305);
        o.exports = function(y) {
          if (y == null || y === "") return null;
          var p;
          if (h(y, "Long")) p = y.toNumber();
          else if (typeof y == "string") try {
            return f.Double.fromString(y);
          } catch {
            c.ok(!1);
          }
          else if (u(y) === "object") {
            var l, d = (l = y.valueOf()) !== null && l !== void 0 ? l : y.toString();
            if (typeof d == "string") try {
              return f.Double.fromString(y);
            } catch {
              c.ok(!1);
            }
            else p = Number(d);
          } else p = Number(y);
          return new f.Double(p);
        };
      }, 3731: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "min", p), Object.defineProperty(y.prototype, "max", p), Object.defineProperty(y.prototype, "expires", p), o.exports = y;
      }, 3743: (o, s, a) => {
        function u(m) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, u(m);
        }
        function c(m) {
          return c = typeof Symbol == "function" && u(Symbol.iterator) === "symbol" ? function(g) {
            return u(g);
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : u(g);
          }, c(m);
        }
        function f(m) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf : function(g) {
            return g.__proto__ || Object.getPrototypeOf(g);
          }, f(m);
        }
        function h(m, g) {
          return h = Object.setPrototypeOf || function(_, b) {
            return _.__proto__ = b, _;
          }, h(m, g);
        }
        var y, p, l = {};
        function d(m, g, _) {
          _ || (_ = Error);
          var b = (function(w) {
            function A(E, O, $) {
              var k;
              return (function(j, P) {
                if (!(j instanceof P)) throw new TypeError("Cannot call a class as a function");
              })(this, A), k = (function(j, P) {
                return !P || c(P) !== "object" && typeof P != "function" ? (function(R) {
                  if (R === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return R;
                })(j) : P;
              })(this, f(A).call(this, (function(j, P, R) {
                return typeof g == "string" ? g : g(j, P, R);
              })(E, O, $))), k.code = m, k;
            }
            return (function(E, O) {
              if (typeof O != "function" && O !== null) throw new TypeError("Super expression must either be null or a function");
              E.prototype = Object.create(O && O.prototype, { constructor: { value: E, writable: !0, configurable: !0 } }), O && h(E, O);
            })(A, w), A;
          })(_);
          l[m] = b;
        }
        function v(m, g) {
          if (Array.isArray(m)) {
            var _ = m.length;
            return m = m.map(function(b) {
              return String(b);
            }), _ > 2 ? "one of ".concat(g, " ").concat(m.slice(0, _ - 1).join(", "), ", or ") + m[_ - 1] : _ === 2 ? "one of ".concat(g, " ").concat(m[0], " or ").concat(m[1]) : "of ".concat(g, " ").concat(m[0]);
          }
          return "of ".concat(g, " ").concat(String(m));
        }
        d("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), d("ERR_INVALID_ARG_TYPE", function(m, g, _) {
          var b, w, A, E, O;
          if (y === void 0 && (y = a(2402)), y(typeof m == "string", "'name' must be a string"), typeof g == "string" && (w = "not ", g.substr(0, 4) === w) ? (b = "must not be", g = g.replace(/^not /, "")) : b = "must be", (function(k, j, P) {
            return (P === void 0 || P > k.length) && (P = k.length), k.substring(P - 9, P) === j;
          })(m, " argument")) A = "The ".concat(m, " ").concat(b, " ").concat(v(g, "type"));
          else {
            var $ = (typeof O != "number" && (O = 0), O + 1 > (E = m).length || E.indexOf(".", O) === -1 ? "argument" : "property");
            A = 'The "'.concat(m, '" ').concat($, " ").concat(b, " ").concat(v(g, "type"));
          }
          return A + ". Received type ".concat(c(_));
        }, TypeError), d("ERR_INVALID_ARG_VALUE", function(m, g) {
          var _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
          p === void 0 && (p = a(7352));
          var b = p.inspect(g);
          return b.length > 128 && (b = "".concat(b.slice(0, 128), "...")), "The argument '".concat(m, "' ").concat(_, ". Received ").concat(b);
        }, TypeError), d("ERR_INVALID_RETURN_VALUE", function(m, g, _) {
          var b;
          return b = _ && _.constructor && _.constructor.name ? "instance of ".concat(_.constructor.name) : "type ".concat(c(_)), "Expected ".concat(m, ' to be returned from the "').concat(g, '"') + " function but got ".concat(b, ".");
        }, TypeError), d("ERR_MISSING_ARGS", function() {
          for (var m = arguments.length, g = new Array(m), _ = 0; _ < m; _++) g[_] = arguments[_];
          y === void 0 && (y = a(2402)), y(g.length > 0, "At least one arg needs to be specified");
          var b = "The ", w = g.length;
          switch (g = g.map(function(A) {
            return '"'.concat(A, '"');
          }), w) {
            case 1:
              b += "".concat(g[0], " argument");
              break;
            case 2:
              b += "".concat(g[0], " and ").concat(g[1], " arguments");
              break;
            default:
              b += g.slice(0, w - 1).join(", "), b += ", and ".concat(g[w - 1], " arguments");
          }
          return "".concat(b, " must be specified");
        }, TypeError), o.exports.codes = l;
      }, 3777: (o, s, a) => {
        var u = a(9809), c = Object.prototype.toString, f = Object.prototype.hasOwnProperty;
        o.exports = function(h, y, p) {
          if (!u(y)) throw new TypeError("iterator must be a function");
          var l, d;
          arguments.length >= 3 && (l = p), d = h, c.call(d) === "[object Array]" ? (function(v, m, g) {
            for (var _ = 0, b = v.length; _ < b; _++) f.call(v, _) && (g == null ? m(v[_], _, v) : m.call(g, v[_], _, v));
          })(h, y, l) : typeof h == "string" ? (function(v, m, g) {
            for (var _ = 0, b = v.length; _ < b; _++) g == null ? m(v.charAt(_), _, v) : m.call(g, v.charAt(_), _, v);
          })(h, y, l) : (function(v, m, g) {
            for (var _ in v) f.call(v, _) && (g == null ? m(v[_], _, v) : m.call(g, v[_], _, v));
          })(h, y, l);
        };
      }, 3892: (o, s, a) => {
        function u(w) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A) {
            return typeof A;
          } : function(A) {
            return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
          }, u(w);
        }
        function c(w, A) {
          var E = typeof Symbol < "u" && w[Symbol.iterator] || w["@@iterator"];
          if (!E) {
            if (Array.isArray(w) || (E = (function(R, I) {
              if (R) {
                if (typeof R == "string") return f(R, I);
                var z = {}.toString.call(R).slice(8, -1);
                return z === "Object" && R.constructor && (z = R.constructor.name), z === "Map" || z === "Set" ? Array.from(R) : z === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(z) ? f(R, I) : void 0;
              }
            })(w)) || A) {
              E && (w = E);
              var O = 0, $ = function() {
              };
              return { s: $, n: function() {
                return O >= w.length ? { done: !0 } : { done: !1, value: w[O++] };
              }, e: function(R) {
                throw R;
              }, f: $ };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var k, j = !0, P = !1;
          return { s: function() {
            E = E.call(w);
          }, n: function() {
            var R = E.next();
            return j = R.done, R;
          }, e: function(R) {
            P = !0, k = R;
          }, f: function() {
            try {
              j || E.return == null || E.return();
            } finally {
              if (P) throw k;
            }
          } };
        }
        function f(w, A) {
          (A == null || A > w.length) && (A = w.length);
          for (var E = 0, O = Array(A); E < A; E++) O[E] = w[E];
          return O;
        }
        function h(w, A) {
          var E = Object.keys(w);
          if (Object.getOwnPropertySymbols) {
            var O = Object.getOwnPropertySymbols(w);
            A && (O = O.filter(function($) {
              return Object.getOwnPropertyDescriptor(w, $).enumerable;
            })), E.push.apply(E, O);
          }
          return E;
        }
        function y(w) {
          for (var A = 1; A < arguments.length; A++) {
            var E = arguments[A] != null ? arguments[A] : {};
            A % 2 ? h(Object(E), !0).forEach(function(O) {
              p(w, O, E[O]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : h(Object(E)).forEach(function(O) {
              Object.defineProperty(w, O, Object.getOwnPropertyDescriptor(E, O));
            });
          }
          return w;
        }
        function p(w, A, E) {
          return (A = (function(O) {
            var $ = (function(k) {
              if (u(k) != "object" || !k) return k;
              var j = k[Symbol.toPrimitive];
              if (j !== void 0) {
                var P = j.call(k, "string");
                if (u(P) != "object") return P;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(k);
            })(O);
            return u($) == "symbol" ? $ : $ + "";
          })(A)) in w ? Object.defineProperty(w, A, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : w[A] = E, w;
        }
        var l = a(6948), d = a(3916), v = a(3703), m = a(1058), g = a(7300), _ = a(4450), b = a(6665);
        s.preparePopulationOptionsMQ = function(w, A) {
          var E, O = w._mongooseOptions.populate, $ = Object.keys(O).reduce(function(R, I) {
            return R.concat([O[I]]);
          }, []);
          A.lean != null && $.filter(function(R) {
            return (R && R.options && R.options.lean) == null;
          }).forEach((E = A.lean, function(R) {
            R.options || (R.options = {}), E != null && Array.isArray(E.virtuals) && ((E = Object.assign({}, E)).virtuals = E.virtuals.filter(function(I) {
              return typeof I == "string" && I.startsWith(R.path + ".");
            }).map(function(I) {
              return I.slice(R.path.length + 1);
            })), R.options.lean = E;
          }));
          var k = w && w.options && w.options.session || null;
          k != null && $.forEach(function(R) {
            R.options != null ? "session" in R.options || (R.options.session = k) : R.options = { session: k };
          });
          for (var j = w._fieldsForExec(), P = 0; P < $.length; ++P) $[P] instanceof l ? $[P] = new l(y(y({}, $[P]), {}, { _queryProjection: j, _localModel: w.model })) : ($[P]._queryProjection = j, $[P]._localModel = w.model);
          return $;
        }, s.createModel = function(w, A, E, O, $) {
          w.hooks.execPreSync("createModel", A);
          var k = w.schema ? w.schema.discriminatorMapping : null, j = k && k.isRoot ? k.key : null, P = A[j];
          if (j && P && w.discriminators) {
            var R = w.discriminators[P] || m(w.discriminators, P);
            if (R) {
              var I = _(O);
              return s.applyPaths(I, R.schema), new R(void 0, I, !0);
            }
          }
          var z = { skipId: !0, isNew: !1, willInit: !0 };
          return $ != null && "defaults" in $ && (z.defaults = $.defaults), new w(void 0, E, z);
        }, s.createModelAndInit = function(w, A, E, O, $, k, j) {
          var P = k ? { populated: k } : void 0, R = s.createModel(w, A, E, O, $);
          try {
            R.$init(A, P, j);
          } catch (I) {
            j(I, R);
          }
        }, s.applyPaths = function(w, A, E) {
          var O, $, k = /* @__PURE__ */ new Set();
          if (w) {
            $ = Object.keys(w);
            for (var j = [], P = 0; P < $.length; ++P) {
              var R = $[P];
              $[P][0] === "-" && (delete w[R], R === "-_id" ? w._id = 0 : j.push(R.slice(1)));
            }
            $ = Object.keys(w);
            for (var I = 0; I < $.length; ++I) if ($[I][0] !== "+") {
              var z = w[$[I]];
              if (g(z) && !($[I] === "_id" && $.length > 1) && (!($[I] === A.options.discriminatorKey && $.length > 1 && z != null) || z)) {
                O = !z;
                break;
              }
            }
            for (var W = 0, F = j; W < F.length; W++) {
              var te = F[W], ee = A.path(te);
              ee && ee.selected && O === !1 ? ee && ee.selected && O === !1 && k.add(te) : (w[te] = 0, O = !0);
            }
          }
          var V = [], T = [], D = [];
          switch ((function B(J, X) {
            if (X || (X = ""), D.indexOf(J) !== -1) return [];
            D.push(J);
            var oe = [];
            return J.eachPath(function(ye, q) {
              if (X && (ye = X + "." + ye), q.$isSchemaMap || ye.endsWith(".$*")) {
                var G = w && "+" + ye in w;
                q.options && q.options.select === !1 && !G && T.push(ye);
              } else {
                var ce = U(ye, q);
                if (ce != null || Array.isArray(q) || !q.$isMongooseArray || q.$isMongooseDocumentArray || (ce = U(ye, q.caster)), ce != null && oe.push(ce), q.schema) {
                  var ue = B(q.schema, ye);
                  O === !1 && d(w, ye, q.schema, V, ue);
                }
              }
            }), D.pop(), oe;
          })(A), O) {
            case !0:
              var L, M = c(T);
              try {
                for (M.s(); !(L = M.n()).done; ) {
                  var N = L.value;
                  w[N] = 0;
                }
              } catch (B) {
                M.e(B);
              } finally {
                M.f();
              }
              break;
            case !1:
              A && A.paths._id && A.paths._id.options && A.paths._id.options.select === !1 && (w._id = 0);
              var Z, Y = c(V);
              try {
                for (Y.s(); !(Z = Y.n()).done; ) {
                  var ie = Z.value;
                  k.has(ie) || b(w, ie) || (w[ie] = w[ie] || 1);
                }
              } catch (B) {
                Y.e(B);
              } finally {
                Y.f();
              }
              break;
            case void 0:
              if (w == null) break;
              for (var le = 0, de = Object.keys(w || {}); le < de.length; le++) {
                var ae = de[le];
                ae.startsWith("+") && delete w[ae];
              }
              var ne, he = c(T);
              try {
                for (he.s(); !(ne = he.n()).done; ) {
                  var x = ne.value;
                  w[x] == null && (w[x] = 0);
                }
              } catch (B) {
                he.e(B);
              } finally {
                he.f();
              }
          }
          function U(B, J) {
            if (w != null && typeof J.selected == "boolean") if (J.selected === !1 && w[B]) E && (w[B] = 0);
            else if (O || !J.selected || B !== A.options.discriminatorKey || w[B] == null || w[B]) {
              if (O !== !1 || !J.selected || w[B] == null || w[B]) {
                var X = "+" + B;
                if (w && X in w) return delete w[X], void (O === !1 && $.length > 1 && !~$.indexOf(B) && !E ? w[B] = 1 : O == null && E && J.selected === !1 && (w[B] = 0));
                for (var oe = B.split("."), ye = "", q = 0; q < oe.length; ++q) if (ye += ye.length ? "." + oe[q] : oe[q], T.indexOf(ye) !== -1) return;
                if (!O && J && J.options && J.options.$skipDiscriminatorCheck) for (var G = "", ce = 0; ce < oe.length; ++ce) {
                  G += (G.length === 0 ? "" : ".") + oe[ce];
                  var ue = v(w, G, !1) || v(w, G + ".$", !1);
                  if (ue && u(ue) !== "object") return;
                }
                return (J.selected ? V : T).push(B), B;
              }
              delete w[B];
            } else delete w[B];
          }
        };
      }, 3900: (o, s, a) => {
        var u = a(6400), c = a(6750), f = a(3191)(), h = a(1464), y = a(2268), p = u("%Math.floor%");
        o.exports = function(l, d) {
          if (typeof l != "function") throw new y("`fn` is not a function");
          if (typeof d != "number" || d < 0 || d > 4294967295 || p(d) !== d) throw new y("`length` must be a positive 32-bit integer");
          var v = arguments.length > 2 && !!arguments[2], m = !0, g = !0;
          if ("length" in l && h) {
            var _ = h(l, "length");
            _ && !_.configurable && (m = !1), _ && !_.writable && (g = !1);
          }
          return (m || g || !v) && (f ? c(l, "length", d, !0, !0) : c(l, "length", d)), l;
        };
      }, 3916: (o) => {
        o.exports = function(s, a, u, c, f) {
          var h = Object.keys(s).reduce(function(p, l) {
            return p || l.startsWith(a + ".");
          }, !1), y = a + "." + u.options.discriminatorKey;
          h || f.length !== 1 || f[0] !== y || c.splice(c.indexOf(y), 1);
        };
      }, 3940: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v) {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, l, ["Can't save() the same doc multiple times in parallel. Document: " + v._doc._id]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "ParallelSaveError" }), o.exports = y;
      }, 4009: (o, s, a) => {
        var u = a(8213), c = a(5188), f = a(3622), h = a(5678), y = a(7352), p = a(8768), l = /(\.\d+$|\.\d+\.)/g;
        o.exports = function(d, v, m, g, _) {
          if (d == null) return [];
          if (typeof d == "string" && _ != null && c(_, d)) throw new u("refPath `" + d + "` must not be excluded in projection, got " + y.inspect(_));
          if (l.test(m)) {
            var b = m.split(l);
            if (b[b.length - 1] === "") throw new Error("Can't populate individual element in an array");
            for (var w = "", A = d, E = 0; E < b.length; E += 2) {
              var O = b[E];
              if (!A.startsWith(O + ".")) {
                if (E === b.length - 1) {
                  w += A, A = "";
                  break;
                }
                throw new Error("Could not normalize ref path, chunk " + O + " not in populated path");
              }
              w += A.substring(0, O.length) + b[E + 1], A = A.substring(O.length + 1);
            }
            var $ = h.get(w, v, f), k = Array.isArray($) ? $ : [$];
            return p.array.flatten(k);
          }
          var j = h.get(d, v, f);
          return g != null && g.virtuals.hasOwnProperty(d) ? [g.virtuals[d].applyGetters(void 0, v)] : Array.isArray(j) ? j : [j];
        };
      }, 4026: (o, s) => {
        s.Collection = function() {
          throw new Error("Cannot create a collection from browser library");
        }, s.Connection = function() {
          throw new Error("Cannot create a connection from browser library");
        }, s.BulkWriteResult = function() {
        };
      }, 4058: (o, s, a) => {
        var u = a(6353).Long, c = 9223372036854775807n, f = -9223372036854775808n, h = "Mongoose only supports BigInts between ".concat(f, " and ").concat(c, " because MongoDB does not support arbitrary precision integers");
        o.exports = function(y) {
          if (y == null) return y;
          if (y === "") return null;
          if (typeof y == "bigint") {
            if (y > c || y < f) throw new Error(h);
            return y;
          }
          if (y instanceof u) return y.toBigInt();
          if (typeof y == "string" || typeof y == "number") {
            if ((y = BigInt(y)) > c || y < f) throw new Error(h);
            return y;
          }
          throw new Error('Cannot convert value to BigInt: "'.concat(y, '"'));
        };
      }, 4070: (o, s, a) => {
        function u(f, h) {
          (h == null || h > f.length) && (h = f.length);
          for (var y = 0, p = Array(h); y < h; y++) p[y] = f[y];
          return p;
        }
        var c = a(8260);
        o.exports = function(f) {
          if (c(f) !== "TopologyDescription" || f.servers.size === 0) return !1;
          var h, y = (function(l, d) {
            var v = typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
            if (!v) {
              if (Array.isArray(l) || (v = (function(A, E) {
                if (A) {
                  if (typeof A == "string") return u(A, E);
                  var O = {}.toString.call(A).slice(8, -1);
                  return O === "Object" && A.constructor && (O = A.constructor.name), O === "Map" || O === "Set" ? Array.from(A) : O === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(O) ? u(A, E) : void 0;
                }
              })(l)) || d) {
                v && (l = v);
                var m = 0, g = function() {
                };
                return { s: g, n: function() {
                  return m >= l.length ? { done: !0 } : { done: !1, value: l[m++] };
                }, e: function(A) {
                  throw A;
                }, f: g };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var _, b = !0, w = !1;
            return { s: function() {
              v = v.call(l);
            }, n: function() {
              var A = v.next();
              return b = A.done, A;
            }, e: function(A) {
              w = !0, _ = A;
            }, f: function() {
              try {
                b || v.return == null || v.return();
              } finally {
                if (w) throw _;
              }
            } };
          })(f.servers.values());
          try {
            for (y.s(); !(h = y.n()).done; ) {
              var p = h.value;
              if (p.host.endsWith(".mongodb.net") === !1 || p.port !== 27017) return !1;
            }
          } catch (l) {
            y.e(l);
          } finally {
            y.f();
          }
          return !0;
        };
      }, 4183: (o, s, a) => {
        var u = a(118);
        o.exports = function() {
          return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : u;
        };
      }, 4224: (o, s, a) => {
        var u = a(6511).ctor("require", "modify", "init", "default", "ignore");
        function c() {
          this.activePaths = new u();
        }
        o.exports = c, c.prototype.strictMode = !0, c.prototype.fullPath = void 0, c.prototype.selected = void 0, c.prototype.shardval = void 0, c.prototype.saveError = void 0, c.prototype.validationError = void 0, c.prototype.adhocPaths = void 0, c.prototype.removing = void 0, c.prototype.inserting = void 0, c.prototype.saving = void 0, c.prototype.version = void 0, c.prototype._id = void 0, c.prototype.ownerDocument = void 0, c.prototype.populate = void 0, c.prototype.populated = void 0, c.prototype.primitiveAtomics = void 0, c.prototype.wasPopulated = !1, c.prototype.scope = void 0, c.prototype.session = null, c.prototype.pathsToScopes = null, c.prototype.cachedRequired = null;
      }, 4301: (o, s, a) => {
        var u = a(9539), c = a(2793), f = a(3305), h = a(5549), y = a(608);
        o.exports = function p(l, d, v, m) {
          var g, _ = Object.keys(d), b = 0, w = _.length;
          if (v = v || "", !(m = m || /* @__PURE__ */ new WeakSet()).has(d)) {
            for (m.add(d); b < w; ) if (g = _[b++], (v || g !== "discriminators" && g !== "base" && g !== "_applyDiscriminators" && g !== "_userProvidedOptions" && g !== "options" && g !== "tree") && !(v === "tree" && d != null && d.instanceOfSchema || c.has(g))) {
              if (l[g] == null) l[g] = d[g];
              else if (y(d[g])) {
                if (y(l[g]) || (l[g] = {}), d[g] != null) {
                  if (d[g].$isSingleNested && l[g].$isMongooseDocumentArray || d[g].$isMongooseDocumentArray && l[g].$isSingleNested || d[g].$isMongooseDocumentArrayElement && l[g].$isMongooseDocumentArrayElement) continue;
                  if (d[g].instanceOfSchema) {
                    l[g].instanceOfSchema ? u(l[g], d[g].clone(), !0) : l[g] = d[g].clone();
                    continue;
                  }
                  if (f(d[g], "ObjectId")) {
                    l[g] = new h(d[g]);
                    continue;
                  }
                }
                p(l[g], d[g], v ? v + "." + g : g, m);
              }
            }
            d != null && d.instanceOfSchema && (l.tree = Object.assign({}, d.tree, l.tree));
          }
        };
      }, 4327: (o) => {
        o.exports = function(s, a, u, c) {
          return u ? c ? { bsonType: a } : { bsonType: [a, "null"] } : c ? { type: s } : { type: [s, "null"] };
        };
      }, 4432: (o, s, a) => {
        function u(m) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, u(m);
        }
        function c(m) {
          if (m != null) {
            var g = m[typeof Symbol == "function" && Symbol.iterator || "@@iterator"], _ = 0;
            if (g) return g.call(m);
            if (typeof m.next == "function") return m;
            if (!isNaN(m.length)) return { next: function() {
              return m && _ >= m.length && (m = void 0), { value: m && m[_++], done: !m };
            } };
          }
          throw new TypeError(u(m) + " is not iterable");
        }
        function f() {
          var m, g, _ = typeof Symbol == "function" ? Symbol : {}, b = _.iterator || "@@iterator", w = _.toStringTag || "@@toStringTag";
          function A(I, z, W, F) {
            var te = z && z.prototype instanceof O ? z : O, ee = Object.create(te.prototype);
            return h(ee, "_invoke", (function(V, T, D) {
              var L, M, N, Z = 0, Y = D || [], ie = !1, le = { p: 0, n: 0, v: m, a: de, f: de.bind(m, 4), d: function(ae, ne) {
                return L = ae, M = 0, N = m, le.n = ne, E;
              } };
              function de(ae, ne) {
                for (M = ae, N = ne, g = 0; !ie && Z && !he && g < Y.length; g++) {
                  var he, x = Y[g], U = le.p, B = x[2];
                  ae > 3 ? (he = B === ne) && (N = x[(M = x[4]) ? 5 : (M = 3, 3)], x[4] = x[5] = m) : x[0] <= U && ((he = ae < 2 && U < x[1]) ? (M = 0, le.v = ne, le.n = x[1]) : U < B && (he = ae < 3 || x[0] > ne || ne > B) && (x[4] = ae, x[5] = ne, le.n = B, M = 0));
                }
                if (he || ae > 1) return E;
                throw ie = !0, ne;
              }
              return function(ae, ne, he) {
                if (Z > 1) throw TypeError("Generator is already running");
                for (ie && ne === 1 && de(ne, he), M = ne, N = he; (g = M < 2 ? m : N) || !ie; ) {
                  L || (M ? M < 3 ? (M > 1 && (le.n = -1), de(M, N)) : le.n = N : le.v = N);
                  try {
                    if (Z = 2, L) {
                      if (M || (ae = "next"), g = L[ae]) {
                        if (!(g = g.call(L, N))) throw TypeError("iterator result is not an object");
                        if (!g.done) return g;
                        N = g.value, M < 2 && (M = 0);
                      } else M === 1 && (g = L.return) && g.call(L), M < 2 && (N = TypeError("The iterator does not provide a '" + ae + "' method"), M = 1);
                      L = m;
                    } else if ((g = (ie = le.n < 0) ? N : V.call(T, le)) !== E) break;
                  } catch (x) {
                    L = m, M = 1, N = x;
                  } finally {
                    Z = 1;
                  }
                }
                return { value: g, done: ie };
              };
            })(I, W, F), !0), ee;
          }
          var E = {};
          function O() {
          }
          function $() {
          }
          function k() {
          }
          g = Object.getPrototypeOf;
          var j = [][b] ? g(g([][b]())) : (h(g = {}, b, function() {
            return this;
          }), g), P = k.prototype = O.prototype = Object.create(j);
          function R(I) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(I, k) : (I.__proto__ = k, h(I, w, "GeneratorFunction")), I.prototype = Object.create(P), I;
          }
          return $.prototype = k, h(P, "constructor", k), h(k, "constructor", $), $.displayName = "GeneratorFunction", h(k, w, "GeneratorFunction"), h(P), h(P, w, "Generator"), h(P, b, function() {
            return this;
          }), h(P, "toString", function() {
            return "[object Generator]";
          }), (f = function() {
            return { w: A, m: R };
          })();
        }
        function h(m, g, _, b) {
          var w = Object.defineProperty;
          try {
            w({}, "", {});
          } catch {
            w = 0;
          }
          h = function(A, E, O, $) {
            function k(j, P) {
              h(A, j, function(R) {
                return this._invoke(j, P, R);
              });
            }
            E ? w ? w(A, E, { value: O, enumerable: !$, configurable: !$, writable: !$ }) : A[E] = O : (k("next", 0), k("throw", 1), k("return", 2));
          }, h(m, g, _, b);
        }
        function y(m, g) {
          var _ = typeof Symbol < "u" && m[Symbol.iterator] || m["@@iterator"];
          if (!_) {
            if (Array.isArray(m) || (_ = (function($, k) {
              if ($) {
                if (typeof $ == "string") return p($, k);
                var j = {}.toString.call($).slice(8, -1);
                return j === "Object" && $.constructor && (j = $.constructor.name), j === "Map" || j === "Set" ? Array.from($) : j === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(j) ? p($, k) : void 0;
              }
            })(m)) || g) {
              _ && (m = _);
              var b = 0, w = function() {
              };
              return { s: w, n: function() {
                return b >= m.length ? { done: !0 } : { done: !1, value: m[b++] };
              }, e: function($) {
                throw $;
              }, f: w };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var A, E = !0, O = !1;
          return { s: function() {
            _ = _.call(m);
          }, n: function() {
            var $ = _.next();
            return E = $.done, $;
          }, e: function($) {
            O = !0, A = $;
          }, f: function() {
            try {
              E || _.return == null || _.return();
            } finally {
              if (O) throw A;
            }
          } };
        }
        function p(m, g) {
          (g == null || g > m.length) && (g = m.length);
          for (var _ = 0, b = Array(g); _ < g; _++) b[_] = m[_];
          return b;
        }
        function l(m, g, _, b, w, A, E) {
          try {
            var O = m[A](E), $ = O.value;
          } catch (k) {
            return void _(k);
          }
          O.done ? g($) : Promise.resolve($).then(b, w);
        }
        function d(m) {
          return function() {
            var g = this, _ = arguments;
            return new Promise(function(b, w) {
              var A = m.apply(g, _);
              function E($) {
                l(A, b, w, E, O, "next", $);
              }
              function O($) {
                l(A, b, w, E, O, "throw", $);
              }
              E(void 0);
            });
          };
        }
        var v = a(5782);
        o.exports = function(m) {
          var g = !0;
          m.s.hooks.pre("save", !1, function(_) {
            if (this.$isSubdocument) _();
            else {
              var b = this, w = this.$getAllSubdocs({ useCache: !0 });
              w.length ? v(w, function(A, E) {
                A.$__schema.s.hooks.execPre("save", A, function(O) {
                  E(O);
                });
              }, function(A) {
                if (b.$__.saveOptions && (b.$__.saveOptions.__subdocs = null), A) return b.$__schema.s.hooks.execPost("save:error", b, [b], { error: A }, function(E) {
                  _(E);
                });
                _();
              }) : _();
            }
          }, null, g), m.s.hooks.post("save", (function() {
            var _ = d(f().m(function b() {
              var w, A, E, O, $, k;
              return f().w(function(j) {
                for (; ; ) switch (j.p = j.n) {
                  case 0:
                    if ((w = this.$__.removedSubdocs) && w.length) {
                      j.n = 1;
                      break;
                    }
                    return j.a(2);
                  case 1:
                    A = [], E = y(w), j.p = 2, $ = f().m(function P() {
                      var R;
                      return f().w(function(I) {
                        for (; ; ) switch (I.n) {
                          case 0:
                            R = O.value, A.push(new Promise(function(z, W) {
                              R.$__schema.s.hooks.execPost("deleteOne", R, [R], function(F) {
                                if (F) return W(F);
                                z();
                              });
                            }));
                          case 1:
                            return I.a(2);
                        }
                      }, P);
                    }), E.s();
                  case 3:
                    if ((O = E.n()).done) {
                      j.n = 5;
                      break;
                    }
                    return j.d(c($()), 4);
                  case 4:
                    j.n = 3;
                    break;
                  case 5:
                    j.n = 7;
                    break;
                  case 6:
                    j.p = 6, k = j.v, E.e(k);
                  case 7:
                    return j.p = 7, E.f(), j.f(7);
                  case 8:
                    return this.$__.removedSubdocs = null, j.n = 9, Promise.all(A);
                  case 9:
                    return j.a(2);
                }
              }, b, this, [[2, 6, 7, 8]]);
            }));
            return function() {
              return _.apply(this, arguments);
            };
          })()), m.s.hooks.post("save", (function() {
            var _ = d(f().m(function b() {
              var w, A, E, O, $, k, j, P, R = this;
              return f().w(function(I) {
                for (; ; ) switch (I.p = I.n) {
                  case 0:
                    if (!this.$isSubdocument) {
                      I.n = 1;
                      break;
                    }
                    return I.a(2);
                  case 1:
                    if (w = this, (A = this.$getAllSubdocs({ useCache: !0 })).length) {
                      I.n = 2;
                      break;
                    }
                    return I.a(2);
                  case 2:
                    E = [], O = y(A), I.p = 3, k = f().m(function z() {
                      var W;
                      return f().w(function(F) {
                        for (; ; ) switch (F.n) {
                          case 0:
                            W = $.value, E.push(new Promise(function(te, ee) {
                              W.$__schema.s.hooks.execPost("save", W, [W], function(V) {
                                if (V) return ee(V);
                                te();
                              });
                            }));
                          case 1:
                            return F.a(2);
                        }
                      }, z);
                    }), O.s();
                  case 4:
                    if (($ = O.n()).done) {
                      I.n = 6;
                      break;
                    }
                    return I.d(c(k()), 5);
                  case 5:
                    I.n = 4;
                    break;
                  case 6:
                    I.n = 8;
                    break;
                  case 7:
                    I.p = 7, j = I.v, O.e(j);
                  case 8:
                    return I.p = 8, O.f(), I.f(8);
                  case 9:
                    return I.p = 9, I.n = 10, Promise.all(E);
                  case 10:
                    I.n = 12;
                    break;
                  case 11:
                    return I.p = 11, P = I.v, I.n = 12, new Promise(function(z, W) {
                      R.$__schema.s.hooks.execPost("save:error", w, [w], { error: P }, function(F) {
                        if (F) return W(F);
                        z();
                      });
                    });
                  case 12:
                    return I.a(2);
                }
              }, b, this, [[9, 11], [3, 7, 8, 9]]);
            }));
            return function() {
              return _.apply(this, arguments);
            };
          })(), null, g);
        };
      }, 4450: (o, s, a) => {
        function u(E) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
            return typeof O;
          } : function(O) {
            return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
          }, u(E);
        }
        var c = a(9639), f = a(5549), h = a(2793), y = a(2497), p = a(9696), l = a(3305), d = a(1243).isMongooseArray, v = a(608), m = a(2789), g = a(7930), _ = a(7291).trustedSymbol, b = a(6353);
        function w(E, O, $) {
          if (E == null) return E;
          if (l(E, "Double")) return new b.Double(E.value);
          if (typeof E == "number" || typeof E == "string" || typeof E == "boolean" || typeof E == "bigint") return E;
          if (Array.isArray(E)) return (function(I, z) {
            var W = 0, F = I.length, te = null;
            for (te = z != null && z.retainDocuments ? I.isMongooseDocumentArray ? new (I.$schemaType()).schema.base.Types.DocumentArray([], I.$path(), I.$parent(), I.$schemaType()) : I.isMongooseArray ? new (I.$parent()).schema.base.Types.Array([], I.$path(), I.$parent(), I.$schemaType()) : new Array(F) : new Array(F), I = d(I) ? I.__array : I, W = 0; W < F; ++W) te[W] = w(I[W], z, !0);
            return te;
          })(E, O);
          if (y(E)) {
            if (O && O.retainDocuments && E.$__ != null) {
              var k = E.$clone();
              return E.__index != null && (k.__index = E.__index), E.__parentArray != null && (k.__parentArray = E.__parentArray), k.$__parent = E.$__parent, k;
            }
            return m(E) && E.$__ != null && E._doc != null ? E._doc : O && O.json && typeof E.toJSON == "function" ? E.toJSON(O) : E.toObject(O);
          }
          var j, P, R = E.constructor;
          if (R) switch (p(R)) {
            case "Object":
              return A(E, O, $);
            case "Date":
              return new R(+E);
            case "RegExp":
              return j = E, (P = new RegExp(j.source, j.flags)).lastIndex !== j.lastIndex && (P.lastIndex = j.lastIndex), P;
          }
          return l(E, "ObjectId") ? O && O.flattenObjectIds ? E.toJSON() : new f(E.id) : l(E, "Decimal128") ? O && O.flattenDecimals ? E.toJSON() : c.fromString(E.toString()) : !R && v(E) ? A(E, O, $) : u(E) === "object" && E[g.schemaTypeSymbol] ? E.clone() : O && O.bson && typeof E.toBSON == "function" ? E : typeof E.valueOf == "function" ? E.valueOf() : A(E, O, $);
        }
        function A(E, O, $) {
          var k, j = O && O.minimize, P = O && O.omitUndefined, R = O && O._seen, I = {};
          if (R && R.has(E)) return R.get(E);
          R && R.set(E, I), _ in E && O?.copyTrustedSymbol !== !1 && (I[_] = E[_]);
          for (var z = Object.keys(E), W = z.length, F = 0; F < W; ++F) {
            var te = z[F];
            if (!h.has(te)) {
              var ee = w(E[te], O, !1);
              j !== !1 && !P || ee !== void 0 ? j === !0 && ee === void 0 || (k || (k = !0), I[te] = ee) : delete I[te];
            }
          }
          return j && !$ ? k && I : I;
        }
        o.exports = w;
      }, 4473: (o) => {
        function s(a, u) {
          var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
          if (c.has(a)) throw new Error("Infinite subdocument loop: subdoc with _id " + a._id + " is a parent of itself");
          var f = a.$parent(), h = a.$__pathRelativeToParent(void 0, !1) + "." + u;
          f.$__.activePaths.clearPath(h), f.$isSubdocument && s(f, h, c);
        }
        o.exports = function(a, u, c) {
          var f = (c = c || {}).skipDocArrays, h = 0;
          if (!a) return h;
          for (var y = 0, p = Object.keys(a.$__.activePaths.getStatePaths("modify")); y < p.length; y++) {
            var l = p[y];
            if (f) {
              var d = a.$__schema.path(l);
              if (d && d.$isMongooseDocumentArray) continue;
            }
            l.startsWith(u + ".") && (a.$__.activePaths.clearPath(l), ++h, a.$isSubdocument && s(a, l));
          }
          return h;
        };
      }, 4561: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "excludeIndexes", p), Object.defineProperty(y.prototype, "_id", p), o.exports = y;
      }, 4592: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "enum", p), Object.defineProperty(y.prototype, "of", p), Object.defineProperty(y.prototype, "castNonArrays", p), o.exports = y;
      }, 4625: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "auto", p), Object.defineProperty(y.prototype, "populate", p), o.exports = y;
      }, 4756: (o) => {
        var s = function(a) {
          return a != a;
        };
        o.exports = function(a, u) {
          return a === 0 && u === 0 ? 1 / a == 1 / u : a === u || !(!s(a) || !s(u));
        };
      }, 4829: (o, s, a) => {
        o.exports = a(8533);
      }, 4859: (o, s, a) => {
        var u = a(5832).hp;
        function c($, k) {
          var j = typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
          if (!j) {
            if (Array.isArray($) || (j = (function(F, te) {
              if (F) {
                if (typeof F == "string") return f(F, te);
                var ee = {}.toString.call(F).slice(8, -1);
                return ee === "Object" && F.constructor && (ee = F.constructor.name), ee === "Map" || ee === "Set" ? Array.from(F) : ee === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ee) ? f(F, te) : void 0;
              }
            })($)) || k) {
              j && ($ = j);
              var P = 0, R = function() {
              };
              return { s: R, n: function() {
                return P >= $.length ? { done: !0 } : { done: !1, value: $[P++] };
              }, e: function(F) {
                throw F;
              }, f: R };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var I, z = !0, W = !1;
          return { s: function() {
            j = j.call($);
          }, n: function() {
            var F = j.next();
            return z = F.done, F;
          }, e: function(F) {
            W = !0, I = F;
          }, f: function() {
            try {
              z || j.return == null || j.return();
            } finally {
              if (W) throw I;
            }
          } };
        }
        function f($, k) {
          (k == null || k > $.length) && (k = $.length);
          for (var j = 0, P = Array(k); j < k; j++) P[j] = $[j];
          return P;
        }
        var h = a(8920), y = a(2400), p = a(863), l = a(1058), d = a(3303)._, v = a(8768), m = a(3305), g = a(7930).arrayParentSymbol, _ = a(7930).arrayPathSymbol, b = a(7930).arraySchemaSymbol, w = a(7930).documentArrayParent, A = Array.prototype.toString, E = { toBSON: function() {
          return this.toObject(d);
        }, toString: function() {
          return A.call(this.__array.map(function($) {
            return $ != null && $.$__ != null ? $.toString() : $;
          }));
        }, getArrayParent: function() {
          return this[g];
        }, $schemaType: function() {
          return this[b];
        }, _cast: function($, k, j) {
          if (this[b] == null) return $;
          var P = this[b].casterConstructor;
          if ((P.$isMongooseDocumentArray ? v.isMongooseDocumentArray($) : $ instanceof P) || $ && $.constructor && $.constructor.baseCasterConstructor === P) return $[w] && $.__parentArray || ($[w] = this[g], $.__parentArray = this), $.$setIndex(k), $;
          if ($ == null) return null;
          if ((u.isBuffer($) || m($, "ObjectId") || !v.isObject($)) && ($ = { _id: $ }), $ && P.discriminators && P.schema && P.schema.options && P.schema.options.discriminatorKey) if (typeof $[P.schema.options.discriminatorKey] == "string" && P.discriminators[$[P.schema.options.discriminatorKey]]) P = P.discriminators[$[P.schema.options.discriminatorKey]];
          else {
            var R = l(P.discriminators, $[P.schema.options.discriminatorKey]);
            R && (P = R);
          }
          if (P.$isMongooseDocumentArray) return P.cast($, this, void 0, void 0, k);
          var I = new P($, this, j, void 0, k);
          return I.isNew = !0, I;
        }, id: function($) {
          var k, j, P;
          try {
            k = p($).toString();
          } catch {
            k = null;
          }
          var R, I = c(this);
          try {
            for (I.s(); !(R = I.n()).done; ) {
              var z = R.value;
              if (z && (P = z.get("_id")) != null) {
                if (P instanceof y) {
                  if (j || (j = String($)), j == P._id) return z;
                } else if (m($, "ObjectId") || m(P, "ObjectId")) {
                  if (k == P) return z;
                } else if ($ == P || v.deepEqual($, P)) return z;
              }
            }
          } catch (W) {
            I.e(W);
          } finally {
            I.f();
          }
          return null;
        }, toObject: function($) {
          return [].concat(this.map(function(k) {
            return k == null ? null : typeof k.toObject != "function" ? k : k.toObject($);
          }));
        }, $toObject: function() {
          return this.constructor.prototype.toObject.apply(this, arguments);
        }, push: function() {
          var $ = h.push.apply(this, arguments);
          return O(this), $;
        }, pull: function() {
          var $ = h.pull.apply(this, arguments);
          return O(this), $;
        }, shift: function() {
          var $ = h.shift.apply(this, arguments);
          return O(this), $;
        }, splice: function() {
          var $ = h.splice.apply(this, arguments);
          return O(this), $;
        }, inspect: function() {
          return this.toObject();
        }, create: function($) {
          var k = this[b].casterConstructor;
          if ($ && k.discriminators && k.schema && k.schema.options && k.schema.options.discriminatorKey) if (typeof $[k.schema.options.discriminatorKey] == "string" && k.discriminators[$[k.schema.options.discriminatorKey]]) k = k.discriminators[$[k.schema.options.discriminatorKey]];
          else {
            var j = l(k.discriminators, $[k.schema.options.discriminatorKey]);
            j && (k = j);
          }
          return new k($, this);
        }, notify: function($) {
          var k = this;
          return function j(P, R) {
            for (var I = (R = R || k).length; I--; ) R[I] != null && ($ === "save" && (P = k[I]), v.isMongooseArray(R[I]) ? j(P, R[I]) : R[I] && R[I].emit($, P));
          };
        }, set: function($, k, j) {
          var P = this.__array;
          if (j) return P[$] = k, this;
          var R = E._cast.call(this, k, $);
          return E._markModified.call(this, $), P[$] = R, this;
        }, _markModified: function($, k) {
          var j, P = this[g];
          if (P) {
            if (j = this[_], arguments.length && (j = k != null ? j + "." + $.__index + "." + k : j + "." + $), j != null && j.endsWith(".$")) return this;
            P.markModified(j, arguments.length !== 0 ? $ : P);
          }
          return this;
        } };
        function O($) {
          var k = $[g];
          if (k && k.$__.populated != null) {
            var j, P = c(Object.keys(k.$__.populated).filter(function(I) {
              return I.startsWith($[_] + ".");
            }));
            try {
              var R = function() {
                var I = j.value, z = I.slice(($[_] + ".").length);
                if (!Array.isArray(k.$__.populated[I].value)) return 1;
                k.$__.populated[I].value = $.map(function(W) {
                  return W.$populated(z);
                });
              };
              for (P.s(); !(j = P.n()).done; ) R();
            } catch (I) {
              P.e(I);
            } finally {
              P.f();
            }
          }
        }
        o.exports = E;
      }, 4878: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        function c(_, b, w) {
          return (b = (function(A) {
            var E = (function(O) {
              if (u(O) != "object" || !O) return O;
              var $ = O[Symbol.toPrimitive];
              if ($ !== void 0) {
                var k = $.call(O, "string");
                if (u(k) != "object") return k;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(O);
            })(A);
            return u(E) == "symbol" ? E : E + "";
          })(b)) in _ ? Object.defineProperty(_, b, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : _[b] = w, _;
        }
        var f = a(8920), h = a(4859), y = a(7930).arrayAtomicsSymbol, p = a(7930).arrayAtomicsBackupSymbol, l = a(7930).arrayParentSymbol, d = a(7930).arrayPathSymbol, v = a(7930).arraySchemaSymbol, m = Array.prototype.push, g = /^\d+$/;
        o.exports = function(_, b, w, A) {
          var E = [], O = c(c(c(c(c({}, y, {}), p, void 0), d, b), v, void 0), l, void 0);
          if (Array.isArray(_) && (_[d] === b && _[l] === w && (O[y] = Object.assign({}, _[y])), _.forEach(function(k) {
            m.call(E, k);
          })), O[d] = b, O.__array = E, w && w.$__) for (O[l] = w, O[v] = w.$__schema.path(b); O[v] != null && O[v].$isMongooseArray && !O[v].$isMongooseDocumentArray; ) O[v] = O[v].casterConstructor;
          var $ = new Proxy(E, { get: function(k, j) {
            return j === "isMongooseArray" || j === "isMongooseArrayProxy" || j === "isMongooseDocumentArray" || j === "isMongooseDocumentArrayProxy" || (O.hasOwnProperty(j) ? O[j] : h.hasOwnProperty(j) ? h[j] : A && A.virtuals && A.virtuals.hasOwnProperty(j) ? A.virtuals[j].applyGetters(void 0, k) : f.hasOwnProperty(j) ? f[j] : E[j]);
          }, set: function(k, j, P) {
            return typeof j == "string" && g.test(j) ? h.set.call($, j, P, !1) : O.hasOwnProperty(j) ? O[j] = P : A && A.virtuals && A.virtuals.hasOwnProperty(j) ? A.virtuals[j].applySetters(P, k) : E[j] = P, !0;
          } });
          return $;
        };
      }, 4957: (o, s, a) => {
        function u(v) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
            return typeof m;
          } : function(m) {
            return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
          }, u(v);
        }
        function c(v, m) {
          var g = Object.keys(v);
          if (Object.getOwnPropertySymbols) {
            var _ = Object.getOwnPropertySymbols(v);
            m && (_ = _.filter(function(b) {
              return Object.getOwnPropertyDescriptor(v, b).enumerable;
            })), g.push.apply(g, _);
          }
          return g;
        }
        function f(v) {
          for (var m = 1; m < arguments.length; m++) {
            var g = arguments[m] != null ? arguments[m] : {};
            m % 2 ? c(Object(g), !0).forEach(function(_) {
              h(v, _, g[_]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(g)) : c(Object(g)).forEach(function(_) {
              Object.defineProperty(v, _, Object.getOwnPropertyDescriptor(g, _));
            });
          }
          return v;
        }
        function h(v, m, g) {
          return (m = (function(_) {
            var b = (function(w) {
              if (u(w) != "object" || !w) return w;
              var A = w[Symbol.toPrimitive];
              if (A !== void 0) {
                var E = A.call(w, "string");
                if (u(E) != "object") return E;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(w);
            })(_);
            return u(b) == "symbol" ? b : b + "";
          })(m)) in v ? Object.defineProperty(v, m, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : v[m] = g, v;
        }
        var y = a(7160), p = a(5268);
        o.exports = d, d.middlewareFunctions = ["deleteOne", "save", "validate", "remove", "updateOne", "init"];
        var l = new Set(d.middlewareFunctions.flatMap(function(v) {
          return [v, "$__".concat(v)];
        }));
        function d(v, m, g) {
          var _ = { useErrorHandlers: !0, numCallbackParams: 1, nullResultByDefault: !0, contextParameter: !0 }, b = (g = g || {}).decorateDoc ? v : v.prototype;
          v.$appliedHooks = !0;
          for (var w = 0, A = Object.keys(m.paths); w < A.length; w++) {
            var E = A[w], O = m.paths[E], $ = null;
            if (O.$isSingleNested) $ = O.caster;
            else {
              if (!O.$isMongooseDocumentArray) continue;
              $ = O.Constructor;
            }
            if (!$.$appliedHooks && (d($, O.schema, f(f({}, g), {}, { isChildSchema: !0 })), $.discriminators != null)) for (var k = 0, j = Object.keys($.discriminators); k < j.length; k++) {
              var P = j[k];
              d($.discriminators[P], $.discriminators[P].schema, g);
            }
          }
          var R = m.s.hooks.filter(function(M) {
            return M.name === "updateOne" || M.name === "deleteOne" ? !!M.document : M.name === "remove" || M.name === "init" ? M.document == null || !!M.document : M.query == null && M.document == null || M.document !== !1;
          }).filter(function(M) {
            return !m.methods[M.name] || !M.fn[y.builtInMiddleware];
          });
          v._middleware = R, b.$__originalValidate = b.$__originalValidate || b.$__validate;
          for (var I = 0, z = g && g.isChildSchema ? ["save", "validate", "deleteOne"] : ["save", "validate"]; I < z.length; I++) {
            var W = z[I], F = W === "validate" ? "$__originalValidate" : "$__".concat(W), te = R.createWrapper(W, b[F], null, _);
            b["$__".concat(W)] = te;
          }
          b.$__init = R.createWrapperSync("init", b.$__init, null, _);
          for (var ee = Object.keys(m.methods), V = Object.assign({}, _, { checkForPromise: !0 }), T = function() {
            var M = L[D];
            if (l.has(M) || !R.hasHooks(M)) return 0;
            var N = b[M];
            b[M] = function() {
              var Z = this, Y = Array.prototype.slice.call(arguments), ie = Y.slice(-1).pop(), le = typeof ie == "function" ? Y.slice(0, Y.length - 1) : Y;
              return p(ie, function(de) {
                return Z["$__".concat(M)].apply(Z, le.concat([de]));
              }, v.events);
            }, b["$__".concat(M)] = R.createWrapper(M, N, null, V);
          }, D = 0, L = ee; D < L.length; D++) T();
        }
      }, 5022: (o, s, a) => {
        var u = a(6426), c = a(7160), f = a(608), h = a(8768);
        function y(p, l) {
          if (l && l.default) {
            var d = l.default;
            Array.isArray(d) && d.length === 0 ? l.default = Array : !l.shared && f(d) && Object.keys(d).length === 0 && (l.default = function() {
              return {};
            });
          }
          u.call(this, p, l, "Mixed"), this[c.schemaMixedSymbol] = !0;
        }
        y.schemaName = "Mixed", y.defaultOptions = {}, y.prototype = Object.create(u.prototype), y.prototype.constructor = y, y.get = u.get, y.set = u.set, y.setters = [], y.prototype.cast = function(p) {
          return p instanceof Error ? h.errorToPOJO(p) : p;
        }, y.prototype.castForQuery = function(p, l) {
          return l;
        }, y.prototype.toJSONSchema = function(p) {
          return {};
        }, o.exports = y;
      }, 5098: (o, s, a) => {
        function u(F) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(te) {
            return typeof te;
          } : function(te) {
            return te && typeof Symbol == "function" && te.constructor === Symbol && te !== Symbol.prototype ? "symbol" : typeof te;
          }, u(F);
        }
        function c(F, te) {
          var ee = Object.keys(F);
          if (Object.getOwnPropertySymbols) {
            var V = Object.getOwnPropertySymbols(F);
            te && (V = V.filter(function(T) {
              return Object.getOwnPropertyDescriptor(F, T).enumerable;
            })), ee.push.apply(ee, V);
          }
          return ee;
        }
        function f(F) {
          for (var te = 1; te < arguments.length; te++) {
            var ee = arguments[te] != null ? arguments[te] : {};
            te % 2 ? c(Object(ee), !0).forEach(function(V) {
              h(F, V, ee[V]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(F, Object.getOwnPropertyDescriptors(ee)) : c(Object(ee)).forEach(function(V) {
              Object.defineProperty(F, V, Object.getOwnPropertyDescriptor(ee, V));
            });
          }
          return F;
        }
        function h(F, te, ee) {
          return (te = (function(V) {
            var T = (function(D) {
              if (u(D) != "object" || !D) return D;
              var L = D[Symbol.toPrimitive];
              if (L !== void 0) {
                var M = L.call(D, "string");
                if (u(M) != "object") return M;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(D);
            })(V);
            return u(T) == "symbol" ? T : T + "";
          })(te)) in F ? Object.defineProperty(F, te, { value: ee, enumerable: !0, configurable: !0, writable: !0 }) : F[te] = ee, F;
        }
        var y, p = a(3609), l = a(3550).EventEmitter, d = a(3441), v = a(7494), m = a(6426), g = a(5335), _ = a(8499), b = a(5558).G, w = a(4327), A = a(1469), E = a(9604), O = a(7910), $ = a(1313), k = a(3303)._, j = a(1793), P = a(8768), R = a(5537);
        function I(F, te, ee) {
          if (F.options.timeseries) throw new R(te, "timeseries");
          var V = I.defaultOptions && I.defaultOptions._id;
          V != null && ((ee = ee || {})._id = V), F = $(F, ee), this.caster = z(F, null, ee), this.caster.path = te, this.caster.prototype.$basePath = te, this.schema = F, this.$isSingleNested = !0, this.base = F.base, m.call(this, te, ee, "Embedded");
        }
        function z(F, te, ee) {
          y || (y = a(9380));
          var V = function(N, Z, Y) {
            this.$__parent = Y, y.apply(this, arguments), Y != null && this.$session(Y.$session());
          };
          F._preCompile();
          var T = te != null ? te.prototype : y.prototype;
          for (var D in (V.prototype = Object.create(T)).$__setSchema(F), V.prototype.constructor = V, V.prototype.$__schemaTypeOptions = ee, V.$__required = ee?.required, V.base = F.base, V.schema = F, V.$isSingleNested = !0, V.events = new l(), V.prototype.toBSON = function() {
            return this.toObject(k);
          }, F.methods) V.prototype[D] = F.methods[D];
          for (var L in F.statics) V[L] = F.statics[L];
          for (var M in l.prototype) V[M] = l.prototype[M];
          return V;
        }
        o.exports = I, I.prototype = Object.create(m.prototype), I.prototype.constructor = I, I.prototype.OptionsConstructor = v;
        var W = f({}, m.prototype.$conditionalHandlers);
        W.$geoWithin = function(F, te) {
          return { $geometry: this.castForQuery(null, F.$geometry, te) };
        }, W.$near = W.$nearSphere = E.cast$near, W.$within = W.$geoWithin = E.cast$within, W.$geoIntersects = E.cast$geoIntersects, W.$minDistance = b, W.$maxDistance = b, W.$exists = _, Object.defineProperty(I.prototype, "$conditionalHandlers", { enumerable: !1, value: W }), I.prototype.cast = function(F, te, ee, V, T) {
          if (F && F.$isSingleNested && F.parent === te) return F;
          if (F != null && (u(F) !== "object" || Array.isArray(F))) throw new d(this.path, F);
          var D, L = this.schema.path(this.schema.options.discriminatorKey), M = L == null ? null : L.getDefault(te), N = O(this.caster, F, M), Z = te && te.$__ && te.$__.selected, Y = this.path, ie = Z == null ? null : Object.keys(Z).reduce(function(de, ae) {
            return ae.startsWith(Y + ".") && ((de = de || {})[ae.substring(Y.length + 1)] = Z[ae]), de;
          }, null);
          if (!ee) return T = Object.assign({}, T, { priorDoc: V }), Object.keys(F).length === 0 ? new N({}, ie, te, void 0, T) : new N(F, ie, te, void 0, T);
          delete (D = new N(void 0, ie, te, !1, { defaults: !1 })).$__.defaults, T.path != null && delete (T = f({}, T)).path, D.$init(F, T);
          var le = j(ie);
          return g(D, ie, le), D;
        }, I.prototype.castForQuery = function(F, te, ee, V) {
          var T;
          if (F != null) {
            if (!(T = this.$conditionalHandlers[F])) throw new Error("Can't use " + F);
            return T.call(this, te);
          }
          if (te == null) return te;
          var D = O(this.caster, te);
          if (te instanceof D) return te;
          this.options.runSetters && (te = this._applySetters(te, ee));
          var L = V != null && V.strict != null ? V.strict : void 0;
          try {
            te = new D(te, L);
          } catch (M) {
            throw M instanceof p ? M : new p("Embedded", te, this.path, M, this);
          }
          return te;
        }, I.prototype.doValidate = function(F, te, ee, V) {
          var T = O(this.caster, F);
          if (!F || F instanceof T || (F = new T(F, null, ee != null && ee.$__ != null ? ee : null)), V && V.skipSchemaValidators) return F ? F.validate().then(function() {
            return te(null);
          }, function(D) {
            return te(D);
          }) : te(null);
          m.prototype.doValidate.call(this, F, function(D) {
            return D ? te(D) : F ? void F.validate().then(function() {
              return te(null);
            }, function(L) {
              return te(L);
            }) : te(null);
          }, ee, V);
        }, I.prototype.doValidateSync = function(F, te, ee) {
          if (!ee || !ee.skipSchemaValidators) {
            var V = m.prototype.doValidateSync.call(this, F, te);
            if (V) return V;
          }
          if (F) return F.validateSync();
        }, I.prototype.discriminator = function(F, te, ee) {
          ee = ee || {};
          var V = P.isPOJO(ee) ? ee.value : ee, T = typeof ee.clone != "boolean" || ee.clone;
          return te.instanceOfSchema && T && (te = te.clone()), te = A(this.caster, F, te, V, null, null, ee.overwriteExisting), this.caster.discriminators[F] = z(te, this.caster), this.caster.discriminators[F];
        }, I.defaultOptions = {}, I.set = m.set, I.setters = [], I.get = m.get, I.prototype.toJSON = function() {
          return { path: this.path, options: this.options };
        }, I.prototype.clone = function() {
          var F = new this.constructor(this.schema, this.path, f(f({}, this.options), {}, { _skipApplyDiscriminators: !0 }));
          return F.validators = this.validators.slice(), this.requiredValidator !== void 0 && (F.requiredValidator = this.requiredValidator), F.caster.discriminators = Object.assign({}, this.caster.discriminators), F._appliedDiscriminators = this._appliedDiscriminators, F;
        }, I.prototype.toJSONSchema = function(F) {
          var te = this.options.required && typeof this.options.required != "function";
          return f(f({}, this.schema.toJSONSchema(F)), w("object", "object", F?.useBsonType, te));
        };
      }, 5110: (o) => {
        var s = /* @__PURE__ */ new Set(["$ref", "$id", "$db"]);
        o.exports = function(a) {
          return a[0] === "$" && !s.has(a);
        };
      }, 5152: (o, s, a) => {
        var u = a(3703), c = a(7425);
        o.exports = function f(h, y, p) {
          for (var l = (p = p || {}).typeOnly, d = Array.isArray(y) ? y : y.indexOf(".") === -1 ? [y] : y.split("."), v = null, m = "adhocOrUndefined", g = c(h.schema, h.get(h.schema.options.discriminatorKey)) || h.schema, _ = 0; _ < d.length; ++_) {
            var b = d.slice(0, _ + 1).join(".");
            if ((v = g.path(b)) != null) {
              if (v.instance === "Mixed") return l ? "real" : v;
              if (m = g.pathType(b), (v.$isSingleNested || v.$isMongooseDocumentArrayElement) && v.schema.discriminators != null) {
                var w = v.schema.discriminators, A = h.get(b + "." + u(v, "schema.options.discriminatorKey"));
                if (A == null || w[A] == null) continue;
                var E = d.slice(_ + 1).join(".");
                return f(h.get(b), E, p);
              }
            } else m = "adhocOrUndefined";
          }
          return l ? m : v;
        };
      }, 5188: (o, s, a) => {
        var u = a(7300);
        o.exports = function(c, f) {
          if (c == null) return !1;
          if (f === "_id") return c._id === 0;
          for (var h = null, y = 0, p = Object.keys(c); y < p.length; y++) {
            var l = p[y];
            if (u(c[l])) {
              h = c[f] === 1 ? "inclusive" : "exclusive";
              break;
            }
          }
          return h === "inclusive" ? c[f] !== 1 : h === "exclusive" && c[f] === 0;
        };
      }, 5268: (o, s, a) => {
        var u = a(2746), c = Symbol("mongoose#emitted");
        o.exports = function(f, h, y, p) {
          if (typeof f == "function") try {
            return h(function(l) {
              if (l == null) f.apply(this, arguments);
              else {
                y != null && y.listeners != null && y.listeners("error").length > 0 && !l[c] && (l[c] = !0, y.emit("error", l));
                try {
                  f(l);
                } catch (d) {
                  return u(function() {
                    throw d;
                  });
                }
              }
            });
          } catch (l) {
            return y != null && y.listeners != null && y.listeners("error").length > 0 && !l[c] && (l[c] = !0, y.emit("error", l)), f(l);
          }
          return new (p = p || a.g.Promise)(function(l, d) {
            h(function(v, m) {
              return v != null ? (y != null && y.listeners != null && y.listeners("error").length > 0 && !v[c] && (v[c] = !0, y.emit("error", v)), d(v)) : arguments.length > 2 ? l(Array.prototype.slice.call(arguments, 1)) : void l(m);
            });
          });
        };
      }, 5289: (o) => {
        o.exports = function(s) {
          switch (s) {
            case "p":
              s = "primary";
              break;
            case "pp":
              s = "primaryPreferred";
              break;
            case "s":
              s = "secondary";
              break;
            case "sp":
              s = "secondaryPreferred";
              break;
            case "n":
              s = "nearest";
          }
          return s;
        };
      }, 5335: (o, s, a) => {
        var u = a(1091);
        function c(f, h, y) {
          f.$__.activePaths.default(h), !y && f.$isSubdocument && f.$isSingleNested && f.$parent() != null && f.$parent().$__.activePaths.default(f.$__pathRelativeToParent(h));
        }
        o.exports = function(f, h, y, p, l, d, v) {
          for (var m = Object.keys(f.$__schema.paths), g = m.length, _ = v && v.skipParentChangeTracking, b = 0; b < g; ++b) {
            var w = void 0, A = "", E = m[b];
            if (E !== "_id" || !f.$__.skipId) {
              var O = f.$__schema.paths[E], $ = O.splitPath(), k = $.length;
              if ($[k - 1] !== "$*") for (var j = !1, P = f._doc, R = 0; R < k && P != null; ++R) {
                var I = $[R];
                if (A += (A.length ? "." : "") + I, y === !0) {
                  if (A in h) break;
                } else if (y === !1 && h && !j) {
                  var z = O.$isSingleNested || O.$isMongooseDocumentArray;
                  if (A in h && !u(h[A]) || R === k - 1 && z && p != null && p[A]) j = !0;
                  else if (p != null && !p[A]) break;
                }
                if (R === k - 1) {
                  if (P[I] !== void 0) break;
                  if (l != null) {
                    if (typeof O.defaultValue == "function") {
                      if (!O.defaultValue.$runBeforeSetters && l || O.defaultValue.$runBeforeSetters && !l) break;
                    } else if (!l) continue;
                  }
                  if (d && d[A]) break;
                  if (h && y !== null) {
                    if (y === !0) {
                      if (E in h) continue;
                      try {
                        w = O.getDefault(f, !1);
                      } catch (W) {
                        f.invalidate(E, W);
                        break;
                      }
                      w !== void 0 && (P[I] = w, c(f, E, _));
                    } else if (j) {
                      try {
                        w = O.getDefault(f, !1);
                      } catch (W) {
                        f.invalidate(E, W);
                        break;
                      }
                      w !== void 0 && (P[I] = w, c(f, E, _));
                    }
                  } else {
                    try {
                      w = O.getDefault(f, !1);
                    } catch (W) {
                      f.invalidate(E, W);
                      break;
                    }
                    w !== void 0 && (P[I] = w, c(f, E, _));
                  }
                } else P = P[I];
              }
            }
          }
        };
      }, 5346: (o) => {
        o.exports = function(s, a, u) {
          for (var c = a[0], f = u, h = s, y = 0; y < a.length - 1; ++y) {
            var p = f.path(c);
            if (p && p.schema) {
              var l = h.get(c);
              if (f = p.schema, c = a[y + 1], Array.isArray(l) && !isNaN(c) && (l = l[c], c = ""), l == null) break;
              h = l;
            } else c += c.length ? "." + a[y + 1] : a[y + 1];
          }
          return h;
        };
      }, 5413: (o, s, a) => {
        var u = a(3305), c = a(2402);
        o.exports = function(f) {
          if (f == null) return f;
          if (f === "") return null;
          var h = u(f, "Long") ? f.toNumber() : Number(f);
          if (h === (0 | h) && h >= -2147483648 && h <= 2147483647) return h;
          c.ok(!1);
        };
      }, 5477: (o, s, a) => {
        var u = a(2354), c = a(3279), f = a(3123), h = a(3388);
        o.exports = h || u.call(f, c);
      }, 5484: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function() {
          if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
          if (s(Symbol.iterator) === "symbol") return !0;
          var a = {}, u = Symbol("test"), c = Object(u);
          if (typeof u == "string" || Object.prototype.toString.call(u) !== "[object Symbol]" || Object.prototype.toString.call(c) !== "[object Symbol]") return !1;
          for (var f in a[u] = 42, a) return !1;
          if (typeof Object.keys == "function" && Object.keys(a).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(a).length !== 0) return !1;
          var h = Object.getOwnPropertySymbols(a);
          if (h.length !== 1 || h[0] !== u || !Object.prototype.propertyIsEnumerable.call(a, u)) return !1;
          if (typeof Object.getOwnPropertyDescriptor == "function") {
            var y = Object.getOwnPropertyDescriptor(a, u);
            if (y.value !== 42 || y.enumerable !== !0) return !1;
          }
          return !0;
        };
      }, 5497: (o, s, a) => {
        var u = a(8260);
        o.exports = function(c) {
          if (u(c) !== "TopologyDescription") return !1;
          var f = Array.from(c.servers.values());
          return f.length > 0 && f.every(function(h) {
            return h.error && h.error.message.indexOf("Client network socket disconnected before secure TLS connection was established") !== -1;
          });
        };
      }, 5510: (o, s, a) => {
        function u(h) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y) {
            return typeof y;
          } : function(y) {
            return y && typeof Symbol == "function" && y.constructor === Symbol && y !== Symbol.prototype ? "symbol" : typeof y;
          }, u(h);
        }
        var c = typeof Symbol < "u" && Symbol, f = a(5484);
        o.exports = function() {
          return typeof c == "function" && typeof Symbol == "function" && u(c("foo")) === "symbol" && u(Symbol("bar")) === "symbol" && f();
        };
      }, 5537: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m) {
            return (function(g, _) {
              if (!(g instanceof _)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(g, _, b) {
              return _ = f(_), (function(w, A) {
                if (A && (u(A) == "object" || typeof A == "function")) return A;
                if (A !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(E) {
                  if (E === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return E;
                })(w);
              })(g, c() ? Reflect.construct(_, b || [], f(g).constructor) : _.apply(g, b));
            })(this, l, ['Cannot create use schema for property "'.concat(v, '" because the schema has the ').concat(m, " option enabled.")]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "InvalidSchemaOptionError" }), o.exports = y;
      }, 5549: (o, s, a) => {
        var u = a(6353).ObjectId, c = a(7930).objectIdSymbol;
        Object.defineProperty(u.prototype, "_id", { enumerable: !1, configurable: !0, get: function() {
          return this;
        } }), u.prototype.hasOwnProperty("valueOf") || (u.prototype.valueOf = function() {
          return this.toString();
        }), u.prototype[c] = !0, o.exports = u;
      }, 5558: (o, s, a) => {
        var u = a(3660);
        function c(f) {
          return u.cast()(f);
        }
        s.G = c, s.p = function f(h, y) {
          h.forEach(function(p, l) {
            Array.isArray(p) ? f(p, y) : h[l] = c.call(y, p);
          });
        };
      }, 5678: (o, s, a) => {
        o.exports = a(2914);
      }, 5761: (o) => {
        o.exports = Object.freeze({ enumerable: !0, configurable: !0, writable: !0, value: void 0 });
      }, 5782: (o) => {
        function s(a, u) {
          (u == null || u > a.length) && (u = a.length);
          for (var c = 0, f = Array(u); c < u; c++) f[c] = a[c];
          return f;
        }
        o.exports = function(a, u, c) {
          if (a.length === 0) return c();
          var f, h = a.length, y = null, p = (function(l, d) {
            var v = typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
            if (!v) {
              if (Array.isArray(l) || (v = (function(A, E) {
                if (A) {
                  if (typeof A == "string") return s(A, E);
                  var O = {}.toString.call(A).slice(8, -1);
                  return O === "Object" && A.constructor && (O = A.constructor.name), O === "Map" || O === "Set" ? Array.from(A) : O === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(O) ? s(A, E) : void 0;
                }
              })(l)) || d) {
                v && (l = v);
                var m = 0, g = function() {
                };
                return { s: g, n: function() {
                  return m >= l.length ? { done: !0 } : { done: !1, value: l[m++] };
                }, e: function(A) {
                  throw A;
                }, f: g };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var _, b = !0, w = !1;
            return { s: function() {
              v = v.call(l);
            }, n: function() {
              var A = v.next();
              return b = A.done, A;
            }, e: function(A) {
              w = !0, _ = A;
            }, f: function() {
              try {
                b || v.return == null || v.return();
              } finally {
                if (w) throw _;
              }
            } };
          })(a);
          try {
            for (p.s(); !(f = p.n()).done; ) u(f.value, function(l) {
              if (y == null) return l != null ? c(y = l) : --h <= 0 ? c() : void 0;
            });
          } catch (l) {
            p.e(l);
          } finally {
            p.f();
          }
        };
      }, 5804: (o, s, a) => {
        var u = a(2354), c = a(3279), f = a(5477);
        o.exports = function() {
          return f(u, c, arguments);
        };
      }, 5807: (o) => {
        o.exports = Object.getOwnPropertyDescriptor;
      }, 5825: (o, s, a) => {
        var u = a(8093);
        o.exports = u.getPrototypeOf || null;
      }, 5832: (o, s, a) => {
        function u(x) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(U) {
            return typeof U;
          } : function(U) {
            return U && typeof Symbol == "function" && U.constructor === Symbol && U !== Symbol.prototype ? "symbol" : typeof U;
          }, u(x);
        }
        var c = a(6775), f = a(2486), h = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        s.hp = l, s.IS = 50;
        var y = 2147483647;
        function p(x) {
          if (x > y) throw new RangeError('The value "' + x + '" is invalid for option "size"');
          var U = new Uint8Array(x);
          return Object.setPrototypeOf(U, l.prototype), U;
        }
        function l(x, U, B) {
          if (typeof x == "number") {
            if (typeof U == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return m(x);
          }
          return d(x, U, B);
        }
        function d(x, U, B) {
          if (typeof x == "string") return (function(oe, ye) {
            if (typeof ye == "string" && ye !== "" || (ye = "utf8"), !l.isEncoding(ye)) throw new TypeError("Unknown encoding: " + ye);
            var q = 0 | w(oe, ye), G = p(q), ce = G.write(oe, ye);
            return ce !== q && (G = G.slice(0, ce)), G;
          })(x, U);
          if (ArrayBuffer.isView(x)) return (function(oe) {
            if (ae(oe, Uint8Array)) {
              var ye = new Uint8Array(oe);
              return _(ye.buffer, ye.byteOffset, ye.byteLength);
            }
            return g(oe);
          })(x);
          if (x == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + u(x));
          if (ae(x, ArrayBuffer) || x && ae(x.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ae(x, SharedArrayBuffer) || x && ae(x.buffer, SharedArrayBuffer))) return _(x, U, B);
          if (typeof x == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
          var J = x.valueOf && x.valueOf();
          if (J != null && J !== x) return l.from(J, U, B);
          var X = (function(oe) {
            if (l.isBuffer(oe)) {
              var ye = 0 | b(oe.length), q = p(ye);
              return q.length === 0 || oe.copy(q, 0, 0, ye), q;
            }
            return oe.length !== void 0 ? typeof oe.length != "number" || ne(oe.length) ? p(0) : g(oe) : oe.type === "Buffer" && Array.isArray(oe.data) ? g(oe.data) : void 0;
          })(x);
          if (X) return X;
          if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x[Symbol.toPrimitive] == "function") return l.from(x[Symbol.toPrimitive]("string"), U, B);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + u(x));
        }
        function v(x) {
          if (typeof x != "number") throw new TypeError('"size" argument must be of type number');
          if (x < 0) throw new RangeError('The value "' + x + '" is invalid for option "size"');
        }
        function m(x) {
          return v(x), p(x < 0 ? 0 : 0 | b(x));
        }
        function g(x) {
          for (var U = x.length < 0 ? 0 : 0 | b(x.length), B = p(U), J = 0; J < U; J += 1) B[J] = 255 & x[J];
          return B;
        }
        function _(x, U, B) {
          if (U < 0 || x.byteLength < U) throw new RangeError('"offset" is outside of buffer bounds');
          if (x.byteLength < U + (B || 0)) throw new RangeError('"length" is outside of buffer bounds');
          var J;
          return J = U === void 0 && B === void 0 ? new Uint8Array(x) : B === void 0 ? new Uint8Array(x, U) : new Uint8Array(x, U, B), Object.setPrototypeOf(J, l.prototype), J;
        }
        function b(x) {
          if (x >= y) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + y.toString(16) + " bytes");
          return 0 | x;
        }
        function w(x, U) {
          if (l.isBuffer(x)) return x.length;
          if (ArrayBuffer.isView(x) || ae(x, ArrayBuffer)) return x.byteLength;
          if (typeof x != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + u(x));
          var B = x.length, J = arguments.length > 2 && arguments[2] === !0;
          if (!J && B === 0) return 0;
          for (var X = !1; ; ) switch (U) {
            case "ascii":
            case "latin1":
            case "binary":
              return B;
            case "utf8":
            case "utf-8":
              return ie(x).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * B;
            case "hex":
              return B >>> 1;
            case "base64":
              return le(x).length;
            default:
              if (X) return J ? -1 : ie(x).length;
              U = ("" + U).toLowerCase(), X = !0;
          }
        }
        function A(x, U, B) {
          var J = !1;
          if ((U === void 0 || U < 0) && (U = 0), U > this.length || ((B === void 0 || B > this.length) && (B = this.length), B <= 0) || (B >>>= 0) <= (U >>>= 0)) return "";
          for (x || (x = "utf8"); ; ) switch (x) {
            case "hex":
              return V(this, U, B);
            case "utf8":
            case "utf-8":
              return W(this, U, B);
            case "ascii":
              return te(this, U, B);
            case "latin1":
            case "binary":
              return ee(this, U, B);
            case "base64":
              return z(this, U, B);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return T(this, U, B);
            default:
              if (J) throw new TypeError("Unknown encoding: " + x);
              x = (x + "").toLowerCase(), J = !0;
          }
        }
        function E(x, U, B) {
          var J = x[U];
          x[U] = x[B], x[B] = J;
        }
        function O(x, U, B, J, X) {
          if (x.length === 0) return -1;
          if (typeof B == "string" ? (J = B, B = 0) : B > 2147483647 ? B = 2147483647 : B < -2147483648 && (B = -2147483648), ne(B = +B) && (B = X ? 0 : x.length - 1), B < 0 && (B = x.length + B), B >= x.length) {
            if (X) return -1;
            B = x.length - 1;
          } else if (B < 0) {
            if (!X) return -1;
            B = 0;
          }
          if (typeof U == "string" && (U = l.from(U, J)), l.isBuffer(U)) return U.length === 0 ? -1 : $(x, U, B, J, X);
          if (typeof U == "number") return U &= 255, typeof Uint8Array.prototype.indexOf == "function" ? X ? Uint8Array.prototype.indexOf.call(x, U, B) : Uint8Array.prototype.lastIndexOf.call(x, U, B) : $(x, [U], B, J, X);
          throw new TypeError("val must be string, number or Buffer");
        }
        function $(x, U, B, J, X) {
          var oe, ye = 1, q = x.length, G = U.length;
          if (J !== void 0 && ((J = String(J).toLowerCase()) === "ucs2" || J === "ucs-2" || J === "utf16le" || J === "utf-16le")) {
            if (x.length < 2 || U.length < 2) return -1;
            ye = 2, q /= 2, G /= 2, B /= 2;
          }
          function ce(xe, be) {
            return ye === 1 ? xe[be] : xe.readUInt16BE(be * ye);
          }
          if (X) {
            var ue = -1;
            for (oe = B; oe < q; oe++) if (ce(x, oe) === ce(U, ue === -1 ? 0 : oe - ue)) {
              if (ue === -1 && (ue = oe), oe - ue + 1 === G) return ue * ye;
            } else ue !== -1 && (oe -= oe - ue), ue = -1;
          } else for (B + G > q && (B = q - G), oe = B; oe >= 0; oe--) {
            for (var re = !0, pe = 0; pe < G; pe++) if (ce(x, oe + pe) !== ce(U, pe)) {
              re = !1;
              break;
            }
            if (re) return oe;
          }
          return -1;
        }
        function k(x, U, B, J) {
          B = Number(B) || 0;
          var X = x.length - B;
          J ? (J = Number(J)) > X && (J = X) : J = X;
          var oe = U.length;
          J > oe / 2 && (J = oe / 2);
          for (var ye = 0; ye < J; ++ye) {
            var q = parseInt(U.substr(2 * ye, 2), 16);
            if (ne(q)) return ye;
            x[B + ye] = q;
          }
          return ye;
        }
        function j(x, U, B, J) {
          return de(ie(U, x.length - B), x, B, J);
        }
        function P(x, U, B, J) {
          return de((function(X) {
            for (var oe = [], ye = 0; ye < X.length; ++ye) oe.push(255 & X.charCodeAt(ye));
            return oe;
          })(U), x, B, J);
        }
        function R(x, U, B, J) {
          return de(le(U), x, B, J);
        }
        function I(x, U, B, J) {
          return de((function(X, oe) {
            for (var ye, q, G, ce = [], ue = 0; ue < X.length && !((oe -= 2) < 0); ++ue) q = (ye = X.charCodeAt(ue)) >> 8, G = ye % 256, ce.push(G), ce.push(q);
            return ce;
          })(U, x.length - B), x, B, J);
        }
        function z(x, U, B) {
          return U === 0 && B === x.length ? c.fromByteArray(x) : c.fromByteArray(x.slice(U, B));
        }
        function W(x, U, B) {
          B = Math.min(x.length, B);
          for (var J = [], X = U; X < B; ) {
            var oe, ye, q, G, ce = x[X], ue = null, re = ce > 239 ? 4 : ce > 223 ? 3 : ce > 191 ? 2 : 1;
            if (X + re <= B) switch (re) {
              case 1:
                ce < 128 && (ue = ce);
                break;
              case 2:
                (192 & (oe = x[X + 1])) == 128 && (G = (31 & ce) << 6 | 63 & oe) > 127 && (ue = G);
                break;
              case 3:
                oe = x[X + 1], ye = x[X + 2], (192 & oe) == 128 && (192 & ye) == 128 && (G = (15 & ce) << 12 | (63 & oe) << 6 | 63 & ye) > 2047 && (G < 55296 || G > 57343) && (ue = G);
                break;
              case 4:
                oe = x[X + 1], ye = x[X + 2], q = x[X + 3], (192 & oe) == 128 && (192 & ye) == 128 && (192 & q) == 128 && (G = (15 & ce) << 18 | (63 & oe) << 12 | (63 & ye) << 6 | 63 & q) > 65535 && G < 1114112 && (ue = G);
            }
            ue === null ? (ue = 65533, re = 1) : ue > 65535 && (ue -= 65536, J.push(ue >>> 10 & 1023 | 55296), ue = 56320 | 1023 & ue), J.push(ue), X += re;
          }
          return (function(pe) {
            var xe = pe.length;
            if (xe <= F) return String.fromCharCode.apply(String, pe);
            for (var be = "", Ee = 0; Ee < xe; ) be += String.fromCharCode.apply(String, pe.slice(Ee, Ee += F));
            return be;
          })(J);
        }
        l.TYPED_ARRAY_SUPPORT = (function() {
          try {
            var x = new Uint8Array(1), U = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(U, Uint8Array.prototype), Object.setPrototypeOf(x, U), x.foo() === 42;
          } catch {
            return !1;
          }
        })(), l.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(l.prototype, "parent", { enumerable: !0, get: function() {
          if (l.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(l.prototype, "offset", { enumerable: !0, get: function() {
          if (l.isBuffer(this)) return this.byteOffset;
        } }), l.poolSize = 8192, l.from = function(x, U, B) {
          return d(x, U, B);
        }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(x, U, B) {
          return (function(J, X, oe) {
            return v(J), J <= 0 ? p(J) : X !== void 0 ? typeof oe == "string" ? p(J).fill(X, oe) : p(J).fill(X) : p(J);
          })(x, U, B);
        }, l.allocUnsafe = function(x) {
          return m(x);
        }, l.allocUnsafeSlow = function(x) {
          return m(x);
        }, l.isBuffer = function(x) {
          return x != null && x._isBuffer === !0 && x !== l.prototype;
        }, l.compare = function(x, U) {
          if (ae(x, Uint8Array) && (x = l.from(x, x.offset, x.byteLength)), ae(U, Uint8Array) && (U = l.from(U, U.offset, U.byteLength)), !l.isBuffer(x) || !l.isBuffer(U)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (x === U) return 0;
          for (var B = x.length, J = U.length, X = 0, oe = Math.min(B, J); X < oe; ++X) if (x[X] !== U[X]) {
            B = x[X], J = U[X];
            break;
          }
          return B < J ? -1 : J < B ? 1 : 0;
        }, l.isEncoding = function(x) {
          switch (String(x).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, l.concat = function(x, U) {
          if (!Array.isArray(x)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (x.length === 0) return l.alloc(0);
          var B;
          if (U === void 0) for (U = 0, B = 0; B < x.length; ++B) U += x[B].length;
          var J = l.allocUnsafe(U), X = 0;
          for (B = 0; B < x.length; ++B) {
            var oe = x[B];
            if (ae(oe, Uint8Array)) X + oe.length > J.length ? l.from(oe).copy(J, X) : Uint8Array.prototype.set.call(J, oe, X);
            else {
              if (!l.isBuffer(oe)) throw new TypeError('"list" argument must be an Array of Buffers');
              oe.copy(J, X);
            }
            X += oe.length;
          }
          return J;
        }, l.byteLength = w, l.prototype._isBuffer = !0, l.prototype.swap16 = function() {
          var x = this.length;
          if (x % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var U = 0; U < x; U += 2) E(this, U, U + 1);
          return this;
        }, l.prototype.swap32 = function() {
          var x = this.length;
          if (x % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var U = 0; U < x; U += 4) E(this, U, U + 3), E(this, U + 1, U + 2);
          return this;
        }, l.prototype.swap64 = function() {
          var x = this.length;
          if (x % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var U = 0; U < x; U += 8) E(this, U, U + 7), E(this, U + 1, U + 6), E(this, U + 2, U + 5), E(this, U + 3, U + 4);
          return this;
        }, l.prototype.toString = function() {
          var x = this.length;
          return x === 0 ? "" : arguments.length === 0 ? W(this, 0, x) : A.apply(this, arguments);
        }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(x) {
          if (!l.isBuffer(x)) throw new TypeError("Argument must be a Buffer");
          return this === x || l.compare(this, x) === 0;
        }, l.prototype.inspect = function() {
          var x = "", U = s.IS;
          return x = this.toString("hex", 0, U).replace(/(.{2})/g, "$1 ").trim(), this.length > U && (x += " ... "), "<Buffer " + x + ">";
        }, h && (l.prototype[h] = l.prototype.inspect), l.prototype.compare = function(x, U, B, J, X) {
          if (ae(x, Uint8Array) && (x = l.from(x, x.offset, x.byteLength)), !l.isBuffer(x)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + u(x));
          if (U === void 0 && (U = 0), B === void 0 && (B = x ? x.length : 0), J === void 0 && (J = 0), X === void 0 && (X = this.length), U < 0 || B > x.length || J < 0 || X > this.length) throw new RangeError("out of range index");
          if (J >= X && U >= B) return 0;
          if (J >= X) return -1;
          if (U >= B) return 1;
          if (this === x) return 0;
          for (var oe = (X >>>= 0) - (J >>>= 0), ye = (B >>>= 0) - (U >>>= 0), q = Math.min(oe, ye), G = this.slice(J, X), ce = x.slice(U, B), ue = 0; ue < q; ++ue) if (G[ue] !== ce[ue]) {
            oe = G[ue], ye = ce[ue];
            break;
          }
          return oe < ye ? -1 : ye < oe ? 1 : 0;
        }, l.prototype.includes = function(x, U, B) {
          return this.indexOf(x, U, B) !== -1;
        }, l.prototype.indexOf = function(x, U, B) {
          return O(this, x, U, B, !0);
        }, l.prototype.lastIndexOf = function(x, U, B) {
          return O(this, x, U, B, !1);
        }, l.prototype.write = function(x, U, B, J) {
          if (U === void 0) J = "utf8", B = this.length, U = 0;
          else if (B === void 0 && typeof U == "string") J = U, B = this.length, U = 0;
          else {
            if (!isFinite(U)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            U >>>= 0, isFinite(B) ? (B >>>= 0, J === void 0 && (J = "utf8")) : (J = B, B = void 0);
          }
          var X = this.length - U;
          if ((B === void 0 || B > X) && (B = X), x.length > 0 && (B < 0 || U < 0) || U > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          J || (J = "utf8");
          for (var oe = !1; ; ) switch (J) {
            case "hex":
              return k(this, x, U, B);
            case "utf8":
            case "utf-8":
              return j(this, x, U, B);
            case "ascii":
            case "latin1":
            case "binary":
              return P(this, x, U, B);
            case "base64":
              return R(this, x, U, B);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return I(this, x, U, B);
            default:
              if (oe) throw new TypeError("Unknown encoding: " + J);
              J = ("" + J).toLowerCase(), oe = !0;
          }
        }, l.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        var F = 4096;
        function te(x, U, B) {
          var J = "";
          B = Math.min(x.length, B);
          for (var X = U; X < B; ++X) J += String.fromCharCode(127 & x[X]);
          return J;
        }
        function ee(x, U, B) {
          var J = "";
          B = Math.min(x.length, B);
          for (var X = U; X < B; ++X) J += String.fromCharCode(x[X]);
          return J;
        }
        function V(x, U, B) {
          var J = x.length;
          (!U || U < 0) && (U = 0), (!B || B < 0 || B > J) && (B = J);
          for (var X = "", oe = U; oe < B; ++oe) X += he[x[oe]];
          return X;
        }
        function T(x, U, B) {
          for (var J = x.slice(U, B), X = "", oe = 0; oe < J.length - 1; oe += 2) X += String.fromCharCode(J[oe] + 256 * J[oe + 1]);
          return X;
        }
        function D(x, U, B) {
          if (x % 1 != 0 || x < 0) throw new RangeError("offset is not uint");
          if (x + U > B) throw new RangeError("Trying to access beyond buffer length");
        }
        function L(x, U, B, J, X, oe) {
          if (!l.isBuffer(x)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (U > X || U < oe) throw new RangeError('"value" argument is out of bounds');
          if (B + J > x.length) throw new RangeError("Index out of range");
        }
        function M(x, U, B, J, X, oe) {
          if (B + J > x.length) throw new RangeError("Index out of range");
          if (B < 0) throw new RangeError("Index out of range");
        }
        function N(x, U, B, J, X) {
          return U = +U, B >>>= 0, X || M(x, 0, B, 4), f.write(x, U, B, J, 23, 4), B + 4;
        }
        function Z(x, U, B, J, X) {
          return U = +U, B >>>= 0, X || M(x, 0, B, 8), f.write(x, U, B, J, 52, 8), B + 8;
        }
        l.prototype.slice = function(x, U) {
          var B = this.length;
          (x = ~~x) < 0 ? (x += B) < 0 && (x = 0) : x > B && (x = B), (U = U === void 0 ? B : ~~U) < 0 ? (U += B) < 0 && (U = 0) : U > B && (U = B), U < x && (U = x);
          var J = this.subarray(x, U);
          return Object.setPrototypeOf(J, l.prototype), J;
        }, l.prototype.readUintLE = l.prototype.readUIntLE = function(x, U, B) {
          x >>>= 0, U >>>= 0, B || D(x, U, this.length);
          for (var J = this[x], X = 1, oe = 0; ++oe < U && (X *= 256); ) J += this[x + oe] * X;
          return J;
        }, l.prototype.readUintBE = l.prototype.readUIntBE = function(x, U, B) {
          x >>>= 0, U >>>= 0, B || D(x, U, this.length);
          for (var J = this[x + --U], X = 1; U > 0 && (X *= 256); ) J += this[x + --U] * X;
          return J;
        }, l.prototype.readUint8 = l.prototype.readUInt8 = function(x, U) {
          return x >>>= 0, U || D(x, 1, this.length), this[x];
        }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(x, U) {
          return x >>>= 0, U || D(x, 2, this.length), this[x] | this[x + 1] << 8;
        }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(x, U) {
          return x >>>= 0, U || D(x, 2, this.length), this[x] << 8 | this[x + 1];
        }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(x, U) {
          return x >>>= 0, U || D(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + 16777216 * this[x + 3];
        }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(x, U) {
          return x >>>= 0, U || D(x, 4, this.length), 16777216 * this[x] + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
        }, l.prototype.readIntLE = function(x, U, B) {
          x >>>= 0, U >>>= 0, B || D(x, U, this.length);
          for (var J = this[x], X = 1, oe = 0; ++oe < U && (X *= 256); ) J += this[x + oe] * X;
          return J >= (X *= 128) && (J -= Math.pow(2, 8 * U)), J;
        }, l.prototype.readIntBE = function(x, U, B) {
          x >>>= 0, U >>>= 0, B || D(x, U, this.length);
          for (var J = U, X = 1, oe = this[x + --J]; J > 0 && (X *= 256); ) oe += this[x + --J] * X;
          return oe >= (X *= 128) && (oe -= Math.pow(2, 8 * U)), oe;
        }, l.prototype.readInt8 = function(x, U) {
          return x >>>= 0, U || D(x, 1, this.length), 128 & this[x] ? -1 * (255 - this[x] + 1) : this[x];
        }, l.prototype.readInt16LE = function(x, U) {
          x >>>= 0, U || D(x, 2, this.length);
          var B = this[x] | this[x + 1] << 8;
          return 32768 & B ? 4294901760 | B : B;
        }, l.prototype.readInt16BE = function(x, U) {
          x >>>= 0, U || D(x, 2, this.length);
          var B = this[x + 1] | this[x] << 8;
          return 32768 & B ? 4294901760 | B : B;
        }, l.prototype.readInt32LE = function(x, U) {
          return x >>>= 0, U || D(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
        }, l.prototype.readInt32BE = function(x, U) {
          return x >>>= 0, U || D(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
        }, l.prototype.readFloatLE = function(x, U) {
          return x >>>= 0, U || D(x, 4, this.length), f.read(this, x, !0, 23, 4);
        }, l.prototype.readFloatBE = function(x, U) {
          return x >>>= 0, U || D(x, 4, this.length), f.read(this, x, !1, 23, 4);
        }, l.prototype.readDoubleLE = function(x, U) {
          return x >>>= 0, U || D(x, 8, this.length), f.read(this, x, !0, 52, 8);
        }, l.prototype.readDoubleBE = function(x, U) {
          return x >>>= 0, U || D(x, 8, this.length), f.read(this, x, !1, 52, 8);
        }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(x, U, B, J) {
          x = +x, U >>>= 0, B >>>= 0, J || L(this, x, U, B, Math.pow(2, 8 * B) - 1, 0);
          var X = 1, oe = 0;
          for (this[U] = 255 & x; ++oe < B && (X *= 256); ) this[U + oe] = x / X & 255;
          return U + B;
        }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(x, U, B, J) {
          x = +x, U >>>= 0, B >>>= 0, J || L(this, x, U, B, Math.pow(2, 8 * B) - 1, 0);
          var X = B - 1, oe = 1;
          for (this[U + X] = 255 & x; --X >= 0 && (oe *= 256); ) this[U + X] = x / oe & 255;
          return U + B;
        }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 1, 255, 0), this[U] = 255 & x, U + 1;
        }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 2, 65535, 0), this[U] = 255 & x, this[U + 1] = x >>> 8, U + 2;
        }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 2, 65535, 0), this[U] = x >>> 8, this[U + 1] = 255 & x, U + 2;
        }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 4, 4294967295, 0), this[U + 3] = x >>> 24, this[U + 2] = x >>> 16, this[U + 1] = x >>> 8, this[U] = 255 & x, U + 4;
        }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 4, 4294967295, 0), this[U] = x >>> 24, this[U + 1] = x >>> 16, this[U + 2] = x >>> 8, this[U + 3] = 255 & x, U + 4;
        }, l.prototype.writeIntLE = function(x, U, B, J) {
          if (x = +x, U >>>= 0, !J) {
            var X = Math.pow(2, 8 * B - 1);
            L(this, x, U, B, X - 1, -X);
          }
          var oe = 0, ye = 1, q = 0;
          for (this[U] = 255 & x; ++oe < B && (ye *= 256); ) x < 0 && q === 0 && this[U + oe - 1] !== 0 && (q = 1), this[U + oe] = (x / ye | 0) - q & 255;
          return U + B;
        }, l.prototype.writeIntBE = function(x, U, B, J) {
          if (x = +x, U >>>= 0, !J) {
            var X = Math.pow(2, 8 * B - 1);
            L(this, x, U, B, X - 1, -X);
          }
          var oe = B - 1, ye = 1, q = 0;
          for (this[U + oe] = 255 & x; --oe >= 0 && (ye *= 256); ) x < 0 && q === 0 && this[U + oe + 1] !== 0 && (q = 1), this[U + oe] = (x / ye | 0) - q & 255;
          return U + B;
        }, l.prototype.writeInt8 = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[U] = 255 & x, U + 1;
        }, l.prototype.writeInt16LE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 2, 32767, -32768), this[U] = 255 & x, this[U + 1] = x >>> 8, U + 2;
        }, l.prototype.writeInt16BE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 2, 32767, -32768), this[U] = x >>> 8, this[U + 1] = 255 & x, U + 2;
        }, l.prototype.writeInt32LE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 4, 2147483647, -2147483648), this[U] = 255 & x, this[U + 1] = x >>> 8, this[U + 2] = x >>> 16, this[U + 3] = x >>> 24, U + 4;
        }, l.prototype.writeInt32BE = function(x, U, B) {
          return x = +x, U >>>= 0, B || L(this, x, U, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[U] = x >>> 24, this[U + 1] = x >>> 16, this[U + 2] = x >>> 8, this[U + 3] = 255 & x, U + 4;
        }, l.prototype.writeFloatLE = function(x, U, B) {
          return N(this, x, U, !0, B);
        }, l.prototype.writeFloatBE = function(x, U, B) {
          return N(this, x, U, !1, B);
        }, l.prototype.writeDoubleLE = function(x, U, B) {
          return Z(this, x, U, !0, B);
        }, l.prototype.writeDoubleBE = function(x, U, B) {
          return Z(this, x, U, !1, B);
        }, l.prototype.copy = function(x, U, B, J) {
          if (!l.isBuffer(x)) throw new TypeError("argument should be a Buffer");
          if (B || (B = 0), J || J === 0 || (J = this.length), U >= x.length && (U = x.length), U || (U = 0), J > 0 && J < B && (J = B), J === B || x.length === 0 || this.length === 0) return 0;
          if (U < 0) throw new RangeError("targetStart out of bounds");
          if (B < 0 || B >= this.length) throw new RangeError("Index out of range");
          if (J < 0) throw new RangeError("sourceEnd out of bounds");
          J > this.length && (J = this.length), x.length - U < J - B && (J = x.length - U + B);
          var X = J - B;
          return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(U, B, J) : Uint8Array.prototype.set.call(x, this.subarray(B, J), U), X;
        }, l.prototype.fill = function(x, U, B, J) {
          if (typeof x == "string") {
            if (typeof U == "string" ? (J = U, U = 0, B = this.length) : typeof B == "string" && (J = B, B = this.length), J !== void 0 && typeof J != "string") throw new TypeError("encoding must be a string");
            if (typeof J == "string" && !l.isEncoding(J)) throw new TypeError("Unknown encoding: " + J);
            if (x.length === 1) {
              var X = x.charCodeAt(0);
              (J === "utf8" && X < 128 || J === "latin1") && (x = X);
            }
          } else typeof x == "number" ? x &= 255 : typeof x == "boolean" && (x = Number(x));
          if (U < 0 || this.length < U || this.length < B) throw new RangeError("Out of range index");
          if (B <= U) return this;
          var oe;
          if (U >>>= 0, B = B === void 0 ? this.length : B >>> 0, x || (x = 0), typeof x == "number") for (oe = U; oe < B; ++oe) this[oe] = x;
          else {
            var ye = l.isBuffer(x) ? x : l.from(x, J), q = ye.length;
            if (q === 0) throw new TypeError('The value "' + x + '" is invalid for argument "value"');
            for (oe = 0; oe < B - U; ++oe) this[oe + U] = ye[oe % q];
          }
          return this;
        };
        var Y = /[^+/0-9A-Za-z-_]/g;
        function ie(x, U) {
          var B;
          U = U || 1 / 0;
          for (var J = x.length, X = null, oe = [], ye = 0; ye < J; ++ye) {
            if ((B = x.charCodeAt(ye)) > 55295 && B < 57344) {
              if (!X) {
                if (B > 56319) {
                  (U -= 3) > -1 && oe.push(239, 191, 189);
                  continue;
                }
                if (ye + 1 === J) {
                  (U -= 3) > -1 && oe.push(239, 191, 189);
                  continue;
                }
                X = B;
                continue;
              }
              if (B < 56320) {
                (U -= 3) > -1 && oe.push(239, 191, 189), X = B;
                continue;
              }
              B = 65536 + (X - 55296 << 10 | B - 56320);
            } else X && (U -= 3) > -1 && oe.push(239, 191, 189);
            if (X = null, B < 128) {
              if ((U -= 1) < 0) break;
              oe.push(B);
            } else if (B < 2048) {
              if ((U -= 2) < 0) break;
              oe.push(B >> 6 | 192, 63 & B | 128);
            } else if (B < 65536) {
              if ((U -= 3) < 0) break;
              oe.push(B >> 12 | 224, B >> 6 & 63 | 128, 63 & B | 128);
            } else {
              if (!(B < 1114112)) throw new Error("Invalid code point");
              if ((U -= 4) < 0) break;
              oe.push(B >> 18 | 240, B >> 12 & 63 | 128, B >> 6 & 63 | 128, 63 & B | 128);
            }
          }
          return oe;
        }
        function le(x) {
          return c.toByteArray((function(U) {
            if ((U = (U = U.split("=")[0]).trim().replace(Y, "")).length < 2) return "";
            for (; U.length % 4 != 0; ) U += "=";
            return U;
          })(x));
        }
        function de(x, U, B, J) {
          for (var X = 0; X < J && !(X + B >= U.length || X >= x.length); ++X) U[X + B] = x[X];
          return X;
        }
        function ae(x, U) {
          return x instanceof U || x != null && x.constructor != null && x.constructor.name != null && x.constructor.name === U.name;
        }
        function ne(x) {
          return x != x;
        }
        var he = (function() {
          for (var x = "0123456789abcdef", U = new Array(256), B = 0; B < 16; ++B) for (var J = 16 * B, X = 0; X < 16; ++X) U[J + X] = x[B] + x[X];
          return U;
        })();
      }, 5889: (o, s, a) => {
        function u(d, v) {
          var m = typeof Symbol < "u" && d[Symbol.iterator] || d["@@iterator"];
          if (!m) {
            if (Array.isArray(d) || (m = c(d)) || v) {
              m && (d = m);
              var g = 0, _ = function() {
              };
              return { s: _, n: function() {
                return g >= d.length ? { done: !0 } : { done: !1, value: d[g++] };
              }, e: function(E) {
                throw E;
              }, f: _ };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var b, w = !0, A = !1;
          return { s: function() {
            m = m.call(d);
          }, n: function() {
            var E = m.next();
            return w = E.done, E;
          }, e: function(E) {
            A = !0, b = E;
          }, f: function() {
            try {
              w || m.return == null || m.return();
            } finally {
              if (A) throw b;
            }
          } };
        }
        function c(d, v) {
          if (d) {
            if (typeof d == "string") return f(d, v);
            var m = {}.toString.call(d).slice(8, -1);
            return m === "Object" && d.constructor && (m = d.constructor.name), m === "Map" || m === "Set" ? Array.from(d) : m === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(m) ? f(d, v) : void 0;
          }
        }
        function f(d, v) {
          (v == null || v > d.length) && (v = d.length);
          for (var m = 0, g = Array(v); m < v; m++) g[m] = d[m];
          return g;
        }
        var h = a(7930).arrayAtomicsSymbol, y = a(7930).sessionNewDocuments, p = a(8768);
        function l(d, v) {
          return d = d || {}, v.$pullAll != null && (d.$pullAll = (d.$pullAll || []).concat(v.$pullAll)), v.$push != null && (d.$push = d.$push || {}, d.$push.$each = (d.$push.$each || []).concat(v.$push.$each)), v.$addToSet != null && (d.$addToSet = (d.$addToSet || []).concat(v.$addToSet)), v.$set != null && (d.$set = Array.isArray(v.$set) ? (function(g) {
            if (Array.isArray(g)) return f(g);
          })(m = v.$set) || (function(g) {
            if (typeof Symbol < "u" && g[Symbol.iterator] != null || g["@@iterator"] != null) return Array.from(g);
          })(m) || c(m) || (function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })() : Object.assign({}, v.$set)), d;
          var m;
        }
        o.exports = function(d) {
          d.pre("save", function() {
            var v = this.$session();
            if (v != null && v.transaction != null && v[y] != null && !v[y].has(this)) {
              var m = {};
              this.isNew && (m.isNew = !0), this.$__schema.options.versionKey && (m.versionKey = this.get(this.$__schema.options.versionKey)), m.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify"))), m.atomics = (function(g, _) {
                var b = /* @__PURE__ */ new Map();
                _ = _ || /* @__PURE__ */ new Map();
                var w, A = u(Object.keys(g.$__.activePaths.init).concat(Object.keys(g.$__.activePaths.modify)));
                try {
                  for (A.s(); !(w = A.n()).done; ) {
                    var E = w.value, O = g.$__getValue(E);
                    if (O != null && Array.isArray(O) && p.isMongooseDocumentArray(O) && O.length && O[h] != null && Object.keys(O[h]).length !== 0) {
                      var $ = _.get(E) || {};
                      b.set(E, l($, O[h]));
                    }
                  }
                } catch (W) {
                  A.e(W);
                } finally {
                  A.f();
                }
                var k, j = u(g.$__dirty());
                try {
                  for (j.s(); !(k = j.n()).done; ) {
                    var P = k.value, R = P.path, I = P.value;
                    if (I != null && I[h] != null && Object.keys(I[h]).length !== 0) {
                      var z = _.get(R) || {};
                      b.set(R, l(z, I[h]));
                    }
                  }
                } catch (W) {
                  j.e(W);
                } finally {
                  j.f();
                }
                return b;
              })(this), v[y].set(this, m);
            }
          });
        };
      }, 5899: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        var c = a(953)(), f = a(3071)("Object.prototype.toString"), h = function(l) {
          return !(c && l && u(l) === "object" && Symbol.toStringTag in l) && f(l) === "[object Arguments]";
        }, y = function(l) {
          return !!h(l) || l !== null && u(l) === "object" && "length" in l && typeof l.length == "number" && l.length >= 0 && f(l) !== "[object Array]" && "callee" in l && f(l.callee) === "[object Function]";
        }, p = (function() {
          return h(arguments);
        })();
        h.isLegacyArguments = y, o.exports = p ? h : y;
      }, 5994: (o, s, a) => {
        var u = Function.prototype.call, c = Object.prototype.hasOwnProperty, f = a(2354);
        o.exports = f.call(u, c);
      }, 6062: (o, s, a) => {
        var u = a(9122), c = a(2273), f = a(118), h = a(4183), y = a(7878), p = u(h(), Number);
        c(p, { getPolyfill: h, implementation: f, shim: y }), o.exports = p;
      }, 6140: (o) => {
        function s(a, u, c) {
          return Object.defineProperty(a, "prototype", { writable: !1 }), a;
        }
        o.exports = s(function a(u, c, f) {
          (function(h, y) {
            if (!(h instanceof y)) throw new TypeError("Cannot call a class as a function");
          })(this, a), this.subdocSnapshot = u, this.activePaths = c, this.version = f;
        });
      }, 6155: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          for (var u = Object.keys(a), c = !0, f = 0, h = u.length; f < h; ++f) if (s(a[u[f]]) === "object" && a[u[f]] !== null) {
            c = !1;
            break;
          }
          return c;
        };
      }, 6182: (o) => {
        function s(a, u) {
          if (a == null) throw new TypeError("Cannot convert first argument to object");
          for (var c = Object(a), f = 1; f < arguments.length; f++) {
            var h = arguments[f];
            if (h != null) for (var y = Object.keys(Object(h)), p = 0, l = y.length; p < l; p++) {
              var d = y[p], v = Object.getOwnPropertyDescriptor(h, d);
              v !== void 0 && v.enumerable && (c[d] = h[d]);
            }
          }
          return c;
        }
        o.exports = { assign: s, polyfill: function() {
          Object.assign || Object.defineProperty(Object, "assign", { enumerable: !1, configurable: !0, writable: !0, value: s });
        } };
      }, 6193: (o, s, a) => {
        function u(ne) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(he) {
            return typeof he;
          } : function(he) {
            return he && typeof Symbol == "function" && he.constructor === Symbol && he !== Symbol.prototype ? "symbol" : typeof he;
          }, u(ne);
        }
        function c(ne, he) {
          return (function(x) {
            if (Array.isArray(x)) return x;
          })(ne) || (function(x, U) {
            var B = [], J = !0, X = !1, oe = void 0;
            try {
              for (var ye, q = x[Symbol.iterator](); !(J = (ye = q.next()).done) && (B.push(ye.value), !U || B.length !== U); J = !0) ;
            } catch (G) {
              X = !0, oe = G;
            } finally {
              try {
                J || q.return == null || q.return();
              } finally {
                if (X) throw oe;
              }
            }
            return B;
          })(ne, he) || (function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          })();
        }
        function f(ne) {
          return f = typeof Symbol == "function" && u(Symbol.iterator) === "symbol" ? function(he) {
            return u(he);
          } : function(he) {
            return he && typeof Symbol == "function" && he.constructor === Symbol && he !== Symbol.prototype ? "symbol" : u(he);
          }, f(ne);
        }
        var h = /a/g.flags !== void 0, y = function(ne) {
          var he = [];
          return ne.forEach(function(x) {
            return he.push(x);
          }), he;
        }, p = function(ne) {
          var he = [];
          return ne.forEach(function(x, U) {
            return he.push([U, x]);
          }), he;
        }, l = Object.is ? Object.is : a(2064), d = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
          return [];
        }, v = Number.isNaN ? Number.isNaN : a(6062);
        function m(ne) {
          return ne.call.bind(ne);
        }
        var g = m(Object.prototype.hasOwnProperty), _ = m(Object.prototype.propertyIsEnumerable), b = m(Object.prototype.toString), w = a(7352).types, A = w.isAnyArrayBuffer, E = w.isArrayBufferView, O = w.isDate, $ = w.isMap, k = w.isRegExp, j = w.isSet, P = w.isNativeError, R = w.isBoxedPrimitive, I = w.isNumberObject, z = w.isStringObject, W = w.isBooleanObject, F = w.isBigIntObject, te = w.isSymbolObject, ee = w.isFloat32Array, V = w.isFloat64Array;
        function T(ne) {
          if (ne.length === 0 || ne.length > 10) return !0;
          for (var he = 0; he < ne.length; he++) {
            var x = ne.charCodeAt(he);
            if (x < 48 || x > 57) return !0;
          }
          return ne.length === 10 && ne >= Math.pow(2, 32);
        }
        function D(ne) {
          return Object.keys(ne).filter(T).concat(d(ne).filter(Object.prototype.propertyIsEnumerable.bind(ne)));
        }
        function L(ne, he) {
          if (ne === he) return 0;
          for (var x = ne.length, U = he.length, B = 0, J = Math.min(x, U); B < J; ++B) if (ne[B] !== he[B]) {
            x = ne[B], U = he[B];
            break;
          }
          return x < U ? -1 : U < x ? 1 : 0;
        }
        function M(ne, he, x, U) {
          if (ne === he) return ne !== 0 || !x || l(ne, he);
          if (x) {
            if (f(ne) !== "object") return typeof ne == "number" && v(ne) && v(he);
            if (f(he) !== "object" || ne === null || he === null || Object.getPrototypeOf(ne) !== Object.getPrototypeOf(he)) return !1;
          } else {
            if (ne === null || f(ne) !== "object") return (he === null || f(he) !== "object") && ne == he;
            if (he === null || f(he) !== "object") return !1;
          }
          var B, J, X, oe, ye = b(ne);
          if (ye !== b(he)) return !1;
          if (Array.isArray(ne)) {
            if (ne.length !== he.length) return !1;
            var q = D(ne), G = D(he);
            return q.length === G.length && Z(ne, he, x, U, 1, q);
          }
          if (ye === "[object Object]" && (!$(ne) && $(he) || !j(ne) && j(he))) return !1;
          if (O(ne)) {
            if (!O(he) || Date.prototype.getTime.call(ne) !== Date.prototype.getTime.call(he)) return !1;
          } else if (k(ne)) {
            if (!k(he) || (X = ne, oe = he, !(h ? X.source === oe.source && X.flags === oe.flags : RegExp.prototype.toString.call(X) === RegExp.prototype.toString.call(oe)))) return !1;
          } else if (P(ne) || ne instanceof Error) {
            if (ne.message !== he.message || ne.name !== he.name) return !1;
          } else {
            if (E(ne)) {
              if (x || !ee(ne) && !V(ne)) {
                if (!(function(re, pe) {
                  return re.byteLength === pe.byteLength && L(new Uint8Array(re.buffer, re.byteOffset, re.byteLength), new Uint8Array(pe.buffer, pe.byteOffset, pe.byteLength)) === 0;
                })(ne, he)) return !1;
              } else if (!(function(re, pe) {
                if (re.byteLength !== pe.byteLength) return !1;
                for (var xe = 0; xe < re.byteLength; xe++) if (re[xe] !== pe[xe]) return !1;
                return !0;
              })(ne, he)) return !1;
              var ce = D(ne), ue = D(he);
              return ce.length === ue.length && Z(ne, he, x, U, 0, ce);
            }
            if (j(ne)) return !(!j(he) || ne.size !== he.size) && Z(ne, he, x, U, 2);
            if ($(ne)) return !(!$(he) || ne.size !== he.size) && Z(ne, he, x, U, 3);
            if (A(ne)) {
              if (J = he, (B = ne).byteLength !== J.byteLength || L(new Uint8Array(B), new Uint8Array(J)) !== 0) return !1;
            } else if (R(ne) && !(function(re, pe) {
              return I(re) ? I(pe) && l(Number.prototype.valueOf.call(re), Number.prototype.valueOf.call(pe)) : z(re) ? z(pe) && String.prototype.valueOf.call(re) === String.prototype.valueOf.call(pe) : W(re) ? W(pe) && Boolean.prototype.valueOf.call(re) === Boolean.prototype.valueOf.call(pe) : F(re) ? F(pe) && BigInt.prototype.valueOf.call(re) === BigInt.prototype.valueOf.call(pe) : te(pe) && Symbol.prototype.valueOf.call(re) === Symbol.prototype.valueOf.call(pe);
            })(ne, he)) return !1;
          }
          return Z(ne, he, x, U, 0);
        }
        function N(ne, he) {
          return he.filter(function(x) {
            return _(ne, x);
          });
        }
        function Z(ne, he, x, U, B, J) {
          if (arguments.length === 5) {
            J = Object.keys(ne);
            var X = Object.keys(he);
            if (J.length !== X.length) return !1;
          }
          for (var oe = 0; oe < J.length; oe++) if (!g(he, J[oe])) return !1;
          if (x && arguments.length === 5) {
            var ye = d(ne);
            if (ye.length !== 0) {
              var q = 0;
              for (oe = 0; oe < ye.length; oe++) {
                var G = ye[oe];
                if (_(ne, G)) {
                  if (!_(he, G)) return !1;
                  J.push(G), q++;
                } else if (_(he, G)) return !1;
              }
              var ce = d(he);
              if (ye.length !== ce.length && N(he, ce).length !== q) return !1;
            } else {
              var ue = d(he);
              if (ue.length !== 0 && N(he, ue).length !== 0) return !1;
            }
          }
          if (J.length === 0 && (B === 0 || B === 1 && ne.length === 0 || ne.size === 0)) return !0;
          if (U === void 0) U = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
          else {
            var re = U.val1.get(ne);
            if (re !== void 0) {
              var pe = U.val2.get(he);
              if (pe !== void 0) return re === pe;
            }
            U.position++;
          }
          U.val1.set(ne, U.position), U.val2.set(he, U.position);
          var xe = (function(be, Ee, Ue, Ae, Me, et) {
            var lt = 0;
            if (et === 2) {
              if (!(function($t, Pt, Tt, Ft) {
                for (var xt = null, ir = y($t), Le = 0; Le < ir.length; Le++) {
                  var Pr = ir[Le];
                  if (f(Pr) === "object" && Pr !== null) xt === null && (xt = /* @__PURE__ */ new Set()), xt.add(Pr);
                  else if (!Pt.has(Pr)) {
                    if (Tt || !le($t, Pt, Pr)) return !1;
                    xt === null && (xt = /* @__PURE__ */ new Set()), xt.add(Pr);
                  }
                }
                if (xt !== null) {
                  for (var It = y(Pt), je = 0; je < It.length; je++) {
                    var qr = It[je];
                    if (f(qr) === "object" && qr !== null) {
                      if (!Y(xt, qr, Tt, Ft)) return !1;
                    } else if (!Tt && !$t.has(qr) && !Y(xt, qr, Tt, Ft)) return !1;
                  }
                  return xt.size === 0;
                }
                return !0;
              })(be, Ee, Ue, Me)) return !1;
            } else if (et === 3) {
              if (!(function($t, Pt, Tt, Ft) {
                for (var xt = null, ir = p($t), Le = 0; Le < ir.length; Le++) {
                  var Pr = c(ir[Le], 2), It = Pr[0], je = Pr[1];
                  if (f(It) === "object" && It !== null) xt === null && (xt = /* @__PURE__ */ new Set()), xt.add(It);
                  else {
                    var qr = Pt.get(It);
                    if (qr === void 0 && !Pt.has(It) || !M(je, qr, Tt, Ft)) {
                      if (Tt || !de($t, Pt, It, je, Ft)) return !1;
                      xt === null && (xt = /* @__PURE__ */ new Set()), xt.add(It);
                    }
                  }
                }
                if (xt !== null) {
                  for (var Cn = p(Pt), Wr = 0; Wr < Cn.length; Wr++) {
                    var or = c(Cn[Wr], 2), Gr = (It = or[0], or[1]);
                    if (f(It) === "object" && It !== null) {
                      if (!ae(xt, $t, It, Gr, Tt, Ft)) return !1;
                    } else if (!(Tt || $t.has(It) && M($t.get(It), Gr, !1, Ft) || ae(xt, $t, It, Gr, !1, Ft))) return !1;
                  }
                  return xt.size === 0;
                }
                return !0;
              })(be, Ee, Ue, Me)) return !1;
            } else if (et === 1) for (; lt < be.length; lt++) {
              if (!g(be, lt)) {
                if (g(Ee, lt)) return !1;
                for (var ft = Object.keys(be); lt < ft.length; lt++) {
                  var Ke = ft[lt];
                  if (!g(Ee, Ke) || !M(be[Ke], Ee[Ke], Ue, Me)) return !1;
                }
                return ft.length === Object.keys(Ee).length;
              }
              if (!g(Ee, lt) || !M(be[lt], Ee[lt], Ue, Me)) return !1;
            }
            for (lt = 0; lt < Ae.length; lt++) {
              var Xt = Ae[lt];
              if (!M(be[Xt], Ee[Xt], Ue, Me)) return !1;
            }
            return !0;
          })(ne, he, x, J, U, B);
          return U.val1.delete(ne), U.val2.delete(he), xe;
        }
        function Y(ne, he, x, U) {
          for (var B = y(ne), J = 0; J < B.length; J++) {
            var X = B[J];
            if (M(he, X, x, U)) return ne.delete(X), !0;
          }
          return !1;
        }
        function ie(ne) {
          switch (f(ne)) {
            case "undefined":
              return null;
            case "object":
              return;
            case "symbol":
              return !1;
            case "string":
              ne = +ne;
            case "number":
              if (v(ne)) return !1;
          }
          return !0;
        }
        function le(ne, he, x) {
          var U = ie(x);
          return U ?? (he.has(U) && !ne.has(U));
        }
        function de(ne, he, x, U, B) {
          var J = ie(x);
          if (J != null) return J;
          var X = he.get(J);
          return !(X === void 0 && !he.has(J) || !M(U, X, !1, B)) && !ne.has(J) && M(U, X, !1, B);
        }
        function ae(ne, he, x, U, B, J) {
          for (var X = y(ne), oe = 0; oe < X.length; oe++) {
            var ye = X[oe];
            if (M(x, ye, B, J) && M(U, he.get(ye), B, J)) return ne.delete(ye), !0;
          }
          return !1;
        }
        o.exports = { isDeepEqual: function(ne, he) {
          return M(ne, he, !1);
        }, isDeepStrictEqual: function(ne, he) {
          return M(ne, he, !0);
        } };
      }, 6223: (o) => {
        var s = /\./g;
        o.exports = function(a) {
          if (a.indexOf(".") === -1) return [a];
          for (var u = a.split(s), c = u.length, f = new Array(c), h = "", y = 0; y < c; ++y) h += h.length !== 0 ? "." + u[y] : u[y], f[y] = h;
          return f;
        };
      }, 6312: (o) => {
        function s(u) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(c) {
            return typeof c;
          } : function(c) {
            return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
          }, s(u);
        }
        var a = Object.prototype.toString;
        o.exports = function(u) {
          var c = a.call(u), f = c === "[object Arguments]";
          return f || (f = c !== "[object Array]" && u !== null && s(u) === "object" && typeof u.length == "number" && u.length >= 0 && a.call(u.callee) === "[object Function]"), f;
        };
      }, 6353: (o, s, a) => {
        a.r(s), a.d(s, { BSON: () => na, BSONError: () => ne, BSONOffsetError: () => U, BSONRegExp: () => We, BSONRuntimeError: () => x, BSONSymbol: () => Qe, BSONType: () => ae, BSONValue: () => pe, BSONVersionError: () => he, Binary: () => Ae, Code: () => Ke, DBRef: () => $t, Decimal128: () => _e, Double: () => $e, EJSON: () => $r, Int32: () => Te, Long: () => je, MaxKey: () => Ie, MinKey: () => qe, ObjectId: () => fe, Timestamp: () => ot, UUID: () => ft, calculateObjectSize: () => ra, deserialize: () => Oo, deserializeStream: () => xi, onDemand: () => ln, serialize: () => Ei, serializeWithBufferAndIndex: () => ds, setInternalBufferSize: () => bn });
        var u = a(5832).hp;
        const c = (() => {
          const C = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
          return (S) => C.call(S);
        })();
        function f(C) {
          return c(C) === "Uint8Array";
        }
        function h(C) {
          return typeof C == "object" && C != null && Symbol.toStringTag in C && (C[Symbol.toStringTag] === "ArrayBuffer" || C[Symbol.toStringTag] === "SharedArrayBuffer");
        }
        function y(C) {
          return C instanceof RegExp || Object.prototype.toString.call(C) === "[object RegExp]";
        }
        function p(C) {
          return typeof C == "object" && C != null && Symbol.toStringTag in C && C[Symbol.toStringTag] === "Map";
        }
        function l(C) {
          return C instanceof Date || Object.prototype.toString.call(C) === "[object Date]";
        }
        function d(C, S) {
          return JSON.stringify(C, (Q, H) => typeof H == "bigint" ? { $numberLong: `${H}` } : p(H) ? Object.fromEntries(H) : H);
        }
        const v = 6, m = Symbol.for("@@mdb.bson.version"), g = 2147483647, _ = -2147483648, b = Math.pow(2, 63) - 1, w = -Math.pow(2, 63), A = Math.pow(2, 53), E = -Math.pow(2, 53), O = 1, $ = 2, k = 3, j = 4, P = 5, R = 6, I = 7, z = 8, W = 9, F = 10, te = 11, ee = 12, V = 13, T = 14, D = 15, L = 16, M = 17, N = 18, Z = 19, Y = 255, ie = 127, le = 0, de = 4, ae = Object.freeze({ double: 1, string: 2, object: 3, array: 4, binData: 5, undefined: 6, objectId: 7, bool: 8, date: 9, null: 10, regex: 11, dbPointer: 12, javascript: 13, symbol: 14, javascriptWithScope: 15, int: 16, timestamp: 17, long: 18, decimal: 19, minKey: -1, maxKey: 127 });
        class ne extends Error {
          get bsonError() {
            return !0;
          }
          get name() {
            return "BSONError";
          }
          constructor(S, Q) {
            super(S, Q);
          }
          static isBSONError(S) {
            return S != null && typeof S == "object" && "bsonError" in S && S.bsonError === !0 && "name" in S && "message" in S && "stack" in S;
          }
        }
        class he extends ne {
          get name() {
            return "BSONVersionError";
          }
          constructor() {
            super(`Unsupported BSON version, bson types must be from bson ${v}.x.x`);
          }
        }
        class x extends ne {
          get name() {
            return "BSONRuntimeError";
          }
          constructor(S) {
            super(S);
          }
        }
        class U extends ne {
          get name() {
            return "BSONOffsetError";
          }
          constructor(S, Q, H) {
            super(`${S}. offset: ${Q}`, H), this.offset = Q;
          }
        }
        let B, J;
        function X(C, S, Q, H) {
          if (H) {
            B ??= new TextDecoder("utf8", { fatal: !0 });
            try {
              return B.decode(C.subarray(S, Q));
            } catch (Se) {
              throw new ne("Invalid UTF-8 string in BSON document", { cause: Se });
            }
          }
          return J ??= new TextDecoder("utf8", { fatal: !1 }), J.decode(C.subarray(S, Q));
        }
        function oe(C, S, Q) {
          if (C.length === 0) return "";
          const H = Q - S;
          if (H === 0) return "";
          if (H > 20) return null;
          if (H === 1 && C[S] < 128) return String.fromCharCode(C[S]);
          if (H === 2 && C[S] < 128 && C[S + 1] < 128) return String.fromCharCode(C[S]) + String.fromCharCode(C[S + 1]);
          if (H === 3 && C[S] < 128 && C[S + 1] < 128 && C[S + 2] < 128) return String.fromCharCode(C[S]) + String.fromCharCode(C[S + 1]) + String.fromCharCode(C[S + 2]);
          const Se = [];
          for (let Oe = S; Oe < Q; Oe++) {
            const Ve = C[Oe];
            if (Ve > 127) return null;
            Se.push(Ve);
          }
          return String.fromCharCode(...Se);
        }
        const ye = { toLocalBufferType(C) {
          if (u.isBuffer(C)) return C;
          if (ArrayBuffer.isView(C)) return u.from(C.buffer, C.byteOffset, C.byteLength);
          const S = C?.[Symbol.toStringTag] ?? Object.prototype.toString.call(C);
          if (S === "ArrayBuffer" || S === "SharedArrayBuffer" || S === "[object ArrayBuffer]" || S === "[object SharedArrayBuffer]") return u.from(C);
          throw new ne("Cannot create Buffer from the passed potentialBuffer.");
        }, allocate: (C) => u.alloc(C), allocateUnsafe: (C) => u.allocUnsafe(C), equals: (C, S) => ye.toLocalBufferType(C).equals(S), fromNumberArray: (C) => u.from(C), fromBase64: (C) => u.from(C, "base64"), toBase64: (C) => ye.toLocalBufferType(C).toString("base64"), fromISO88591: (C) => u.from(C, "binary"), toISO88591: (C) => ye.toLocalBufferType(C).toString("binary"), fromHex: (C) => u.from(C, "hex"), toHex: (C) => ye.toLocalBufferType(C).toString("hex"), toUTF8(C, S, Q, H) {
          const Se = Q - S <= 20 ? oe(C, S, Q) : null;
          if (Se != null) return Se;
          const Oe = ye.toLocalBufferType(C).toString("utf8", S, Q);
          if (H) {
            for (let Ve = 0; Ve < Oe.length; Ve++) if (Oe.charCodeAt(Ve) === 65533) {
              X(C, S, Q, !0);
              break;
            }
          }
          return Oe;
        }, utf8ByteLength: (C) => u.byteLength(C, "utf8"), encodeUTF8Into(C, S, Q) {
          const H = (function(Se, Oe, Ve) {
            if (Oe.length === 0) return 0;
            if (Oe.length > 25 || Se.length - Ve < Oe.length) return null;
            for (let Ze = 0, ke = Ve; Ze < Oe.length; Ze++, ke++) {
              const ut = Oe.charCodeAt(Ze);
              if (ut > 127) return null;
              Se[ke] = ut;
            }
            return Oe.length;
          })(C, S, Q);
          return H ?? ye.toLocalBufferType(C).write(S, Q, void 0, "utf8");
        }, randomBytes: function(C) {
          return ye.fromNumberArray(Array.from({ length: C }, () => Math.floor(256 * Math.random())));
        }, swap32: (C) => ye.toLocalBufferType(C).swap32() };
        function q(C) {
          if (C < 0) throw new RangeError(`The argument 'byteLength' is invalid. Received ${C}`);
          return ue.fromNumberArray(Array.from({ length: C }, () => Math.floor(256 * Math.random())));
        }
        const G = (() => {
          const { crypto: C } = globalThis;
          if (C != null && typeof C.getRandomValues == "function") return (S) => C.getRandomValues(ue.allocate(S));
          if ((function() {
            const { navigator: S } = globalThis;
            return typeof S == "object" && S.product === "ReactNative";
          })()) {
            const { console: S } = globalThis;
            S?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
          }
          return q;
        })(), ce = /(\d|[a-f])/i, ue = { toLocalBufferType(C) {
          const S = C?.[Symbol.toStringTag] ?? Object.prototype.toString.call(C);
          if (S === "Uint8Array") return C;
          if (ArrayBuffer.isView(C)) return new Uint8Array(C.buffer.slice(C.byteOffset, C.byteOffset + C.byteLength));
          if (S === "ArrayBuffer" || S === "SharedArrayBuffer" || S === "[object ArrayBuffer]" || S === "[object SharedArrayBuffer]") return new Uint8Array(C);
          throw new ne("Cannot make a Uint8Array from passed potentialBuffer.");
        }, allocate(C) {
          if (typeof C != "number") throw new TypeError(`The "size" argument must be of type number. Received ${String(C)}`);
          return new Uint8Array(C);
        }, allocateUnsafe: (C) => ue.allocate(C), equals(C, S) {
          if (C.byteLength !== S.byteLength) return !1;
          for (let Q = 0; Q < C.byteLength; Q++) if (C[Q] !== S[Q]) return !1;
          return !0;
        }, fromNumberArray: (C) => Uint8Array.from(C), fromBase64: (C) => Uint8Array.from(atob(C), (S) => S.charCodeAt(0)), toBase64: (C) => btoa(ue.toISO88591(C)), fromISO88591: (C) => Uint8Array.from(C, (S) => 255 & S.charCodeAt(0)), toISO88591: (C) => Array.from(Uint16Array.from(C), (S) => String.fromCharCode(S)).join(""), fromHex(C) {
          const S = C.length % 2 == 0 ? C : C.slice(0, C.length - 1), Q = [];
          for (let H = 0; H < S.length; H += 2) {
            const Se = S[H], Oe = S[H + 1];
            if (!ce.test(Se) || !ce.test(Oe)) break;
            const Ve = Number.parseInt(`${Se}${Oe}`, 16);
            Q.push(Ve);
          }
          return Uint8Array.from(Q);
        }, toHex: (C) => Array.from(C, (S) => S.toString(16).padStart(2, "0")).join(""), toUTF8(C, S, Q, H) {
          const Se = Q - S <= 20 ? oe(C, S, Q) : null;
          return Se ?? X(C, S, Q, H);
        }, utf8ByteLength: (C) => new TextEncoder().encode(C).byteLength, encodeUTF8Into(C, S, Q) {
          const H = new TextEncoder().encode(S);
          return C.set(H, Q), H.byteLength;
        }, randomBytes: G, swap32(C) {
          if (C.length % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let S = 0; S < C.length; S += 4) {
            const Q = C[S], H = C[S + 1], Se = C[S + 2], Oe = C[S + 3];
            C[S] = Oe, C[S + 1] = Se, C[S + 2] = H, C[S + 3] = Q;
          }
          return C;
        } }, re = typeof u == "function" && u.prototype?._isBuffer !== !0 ? ye : ue;
        class pe {
          get [m]() {
            return v;
          }
          [Symbol.for("nodejs.util.inspect.custom")](S, Q, H) {
            return this.inspect(S, Q, H);
          }
        }
        const xe = new Float64Array(1), be = new Uint8Array(xe.buffer, 0, 8);
        xe[0] = -1;
        const Ee = be[7] === 0, Ue = { isBigEndian: Ee, getNonnegativeInt32LE(C, S) {
          if (C[S + 3] > 127) throw new RangeError(`Size cannot be negative at offset: ${S}`);
          return C[S] | C[S + 1] << 8 | C[S + 2] << 16 | C[S + 3] << 24;
        }, getInt32LE: (C, S) => C[S] | C[S + 1] << 8 | C[S + 2] << 16 | C[S + 3] << 24, getUint32LE: (C, S) => C[S] + 256 * C[S + 1] + 65536 * C[S + 2] + 16777216 * C[S + 3], getUint32BE: (C, S) => C[S + 3] + 256 * C[S + 2] + 65536 * C[S + 1] + 16777216 * C[S], getBigInt64LE(C, S) {
          const Q = BigInt(C[S + 4] + 256 * C[S + 5] + 65536 * C[S + 6] + (C[S + 7] << 24)), H = BigInt(C[S] + 256 * C[S + 1] + 65536 * C[S + 2] + 16777216 * C[S + 3]);
          return (Q << BigInt(32)) + H;
        }, getFloat64LE: Ee ? (C, S) => (be[7] = C[S], be[6] = C[S + 1], be[5] = C[S + 2], be[4] = C[S + 3], be[3] = C[S + 4], be[2] = C[S + 5], be[1] = C[S + 6], be[0] = C[S + 7], xe[0]) : (C, S) => (be[0] = C[S], be[1] = C[S + 1], be[2] = C[S + 2], be[3] = C[S + 3], be[4] = C[S + 4], be[5] = C[S + 5], be[6] = C[S + 6], be[7] = C[S + 7], xe[0]), setInt32BE: (C, S, Q) => (C[S + 3] = Q, Q >>>= 8, C[S + 2] = Q, Q >>>= 8, C[S + 1] = Q, Q >>>= 8, C[S] = Q, 4), setInt32LE: (C, S, Q) => (C[S] = Q, Q >>>= 8, C[S + 1] = Q, Q >>>= 8, C[S + 2] = Q, Q >>>= 8, C[S + 3] = Q, 4), setBigInt64LE(C, S, Q) {
          const H = BigInt(4294967295);
          let Se = Number(Q & H);
          C[S] = Se, Se >>= 8, C[S + 1] = Se, Se >>= 8, C[S + 2] = Se, Se >>= 8, C[S + 3] = Se;
          let Oe = Number(Q >> BigInt(32) & H);
          return C[S + 4] = Oe, Oe >>= 8, C[S + 5] = Oe, Oe >>= 8, C[S + 6] = Oe, Oe >>= 8, C[S + 7] = Oe, 8;
        }, setFloat64LE: Ee ? (C, S, Q) => (xe[0] = Q, C[S] = be[7], C[S + 1] = be[6], C[S + 2] = be[5], C[S + 3] = be[4], C[S + 4] = be[3], C[S + 5] = be[2], C[S + 6] = be[1], C[S + 7] = be[0], 8) : (C, S, Q) => (xe[0] = Q, C[S] = be[0], C[S + 1] = be[1], C[S + 2] = be[2], C[S + 3] = be[3], C[S + 4] = be[4], C[S + 5] = be[5], C[S + 6] = be[6], C[S + 7] = be[7], 8) };
        class Ae extends pe {
          get _bsontype() {
            return "Binary";
          }
          constructor(S, Q) {
            if (super(), S != null && typeof S == "string" && !ArrayBuffer.isView(S) && !h(S) && !Array.isArray(S)) throw new ne("Binary can only be constructed from Uint8Array or number[]");
            this.sub_type = Q ?? Ae.BSON_BINARY_SUBTYPE_DEFAULT, S == null ? (this.buffer = re.allocate(Ae.BUFFER_SIZE), this.position = 0) : (this.buffer = Array.isArray(S) ? re.fromNumberArray(S) : re.toLocalBufferType(S), this.position = this.buffer.byteLength);
          }
          put(S) {
            if (typeof S == "string" && S.length !== 1) throw new ne("only accepts single character String");
            if (typeof S != "number" && S.length !== 1) throw new ne("only accepts single character Uint8Array or Array");
            let Q;
            if (Q = typeof S == "string" ? S.charCodeAt(0) : typeof S == "number" ? S : S[0], Q < 0 || Q > 255) throw new ne("only accepts number in a valid unsigned byte range 0-255");
            if (this.buffer.byteLength > this.position) this.buffer[this.position++] = Q;
            else {
              const H = re.allocate(Ae.BUFFER_SIZE + this.buffer.length);
              H.set(this.buffer, 0), this.buffer = H, this.buffer[this.position++] = Q;
            }
          }
          write(S, Q) {
            if (Q = typeof Q == "number" ? Q : this.position, this.buffer.byteLength < Q + S.length) {
              const H = re.allocate(this.buffer.byteLength + S.length);
              H.set(this.buffer, 0), this.buffer = H;
            }
            if (ArrayBuffer.isView(S)) this.buffer.set(re.toLocalBufferType(S), Q), this.position = Q + S.byteLength > this.position ? Q + S.length : this.position;
            else if (typeof S == "string") throw new ne("input cannot be string");
          }
          read(S, Q) {
            const H = S + (Q = Q && Q > 0 ? Q : this.position);
            return this.buffer.subarray(S, H > this.position ? this.position : H);
          }
          value() {
            return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
          }
          length() {
            return this.position;
          }
          toJSON() {
            return re.toBase64(this.buffer.subarray(0, this.position));
          }
          toString(S) {
            return S === "hex" ? re.toHex(this.buffer.subarray(0, this.position)) : S === "base64" ? re.toBase64(this.buffer.subarray(0, this.position)) : re.toUTF8(this.buffer, 0, this.position, !1);
          }
          toExtendedJSON(S) {
            S = S || {}, this.sub_type === Ae.SUBTYPE_VECTOR && Me(this);
            const Q = re.toBase64(this.buffer), H = Number(this.sub_type).toString(16);
            return S.legacy ? { $binary: Q, $type: H.length === 1 ? "0" + H : H } : { $binary: { base64: Q, subType: H.length === 1 ? "0" + H : H } };
          }
          toUUID() {
            if (this.sub_type === Ae.SUBTYPE_UUID) return new ft(this.buffer.subarray(0, this.position));
            throw new ne(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Ae.SUBTYPE_UUID}" is currently supported.`);
          }
          static createFromHexString(S, Q) {
            return new Ae(re.fromHex(S), Q);
          }
          static createFromBase64(S, Q) {
            return new Ae(re.fromBase64(S), Q);
          }
          static fromExtendedJSON(S, Q) {
            let H, Se;
            if (Q = Q || {}, "$binary" in S ? Q.legacy && typeof S.$binary == "string" && "$type" in S ? (Se = S.$type ? parseInt(S.$type, 16) : 0, H = re.fromBase64(S.$binary)) : typeof S.$binary != "string" && (Se = S.$binary.subType ? parseInt(S.$binary.subType, 16) : 0, H = re.fromBase64(S.$binary.base64)) : "$uuid" in S && (Se = 4, H = ft.bytesFromString(S.$uuid)), !H) throw new ne(`Unexpected Binary Extended JSON format ${JSON.stringify(S)}`);
            return Se === de ? new ft(H) : new Ae(H, Se);
          }
          inspect(S, Q, H) {
            return H ??= d, `Binary.createFromBase64(${H(re.toBase64(this.buffer.subarray(0, this.position)), Q)}, ${H(this.sub_type, Q)})`;
          }
          toInt8Array() {
            if (this.sub_type !== Ae.SUBTYPE_VECTOR) throw new ne("Binary sub_type is not Vector");
            if (this.buffer[0] !== Ae.VECTOR_TYPE.Int8) throw new ne("Binary datatype field is not Int8");
            return Me(this), new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
          }
          toFloat32Array() {
            if (this.sub_type !== Ae.SUBTYPE_VECTOR) throw new ne("Binary sub_type is not Vector");
            if (this.buffer[0] !== Ae.VECTOR_TYPE.Float32) throw new ne("Binary datatype field is not Float32");
            Me(this);
            const S = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
            return Ue.isBigEndian && re.swap32(S), new Float32Array(S.buffer);
          }
          toPackedBits() {
            if (this.sub_type !== Ae.SUBTYPE_VECTOR) throw new ne("Binary sub_type is not Vector");
            if (this.buffer[0] !== Ae.VECTOR_TYPE.PackedBit) throw new ne("Binary datatype field is not packed bit");
            return Me(this), new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
          }
          toBits() {
            if (this.sub_type !== Ae.SUBTYPE_VECTOR) throw new ne("Binary sub_type is not Vector");
            if (this.buffer[0] !== Ae.VECTOR_TYPE.PackedBit) throw new ne("Binary datatype field is not packed bit");
            Me(this);
            const S = 8 * (this.length() - 2) - this.buffer[1], Q = new Int8Array(S);
            for (let H = 0; H < Q.length; H++) {
              const Se = H / 8 | 0, Oe = this.buffer[Se + 2] >> 7 - H % 8 & 1;
              Q[H] = Oe;
            }
            return Q;
          }
          static fromInt8Array(S) {
            const Q = re.allocate(S.byteLength + 2);
            Q[0] = Ae.VECTOR_TYPE.Int8, Q[1] = 0;
            const H = new Uint8Array(S.buffer, S.byteOffset, S.byteLength);
            Q.set(H, 2);
            const Se = new this(Q, this.SUBTYPE_VECTOR);
            return Me(Se), Se;
          }
          static fromFloat32Array(S) {
            const Q = re.allocate(S.byteLength + 2);
            Q[0] = Ae.VECTOR_TYPE.Float32, Q[1] = 0;
            const H = new Uint8Array(S.buffer, S.byteOffset, S.byteLength);
            Q.set(H, 2), Ue.isBigEndian && re.swap32(new Uint8Array(Q.buffer, 2));
            const Se = new this(Q, this.SUBTYPE_VECTOR);
            return Me(Se), Se;
          }
          static fromPackedBits(S, Q = 0) {
            const H = re.allocate(S.byteLength + 2);
            H[0] = Ae.VECTOR_TYPE.PackedBit, H[1] = Q, H.set(S, 2);
            const Se = new this(H, this.SUBTYPE_VECTOR);
            return Me(Se), Se;
          }
          static fromBits(S) {
            const Q = S.length + 7 >>> 3, H = new Uint8Array(Q + 2);
            H[0] = Ae.VECTOR_TYPE.PackedBit;
            const Se = S.length % 8;
            H[1] = Se === 0 ? 0 : 8 - Se;
            for (let Oe = 0; Oe < S.length; Oe++) {
              const Ve = Oe >>> 3, Ze = S[Oe];
              if (Ze !== 0 && Ze !== 1) throw new ne(`Invalid bit value at ${Oe}: must be 0 or 1, found ${S[Oe]}`);
              if (Ze === 0) continue;
              const ke = 7 - Oe % 8;
              H[Ve + 2] |= Ze << ke;
            }
            return new this(H, Ae.SUBTYPE_VECTOR);
          }
        }
        function Me(C) {
          if (C.sub_type !== Ae.SUBTYPE_VECTOR) return;
          const S = C.position, Q = C.buffer[0], H = C.buffer[1];
          if ((Q === Ae.VECTOR_TYPE.Float32 || Q === Ae.VECTOR_TYPE.Int8) && H !== 0) throw new ne("Invalid Vector: padding must be zero for int8 and float32 vectors");
          if (Q === Ae.VECTOR_TYPE.Float32 && S !== 0 && S - 2 != 0 && (S - 2) % 4 != 0) throw new ne("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");
          if (Q === Ae.VECTOR_TYPE.PackedBit && H !== 0 && S === 2) throw new ne("Invalid Vector: padding must be zero for packed bit vectors that are empty");
          if (Q === Ae.VECTOR_TYPE.PackedBit && H > 7) throw new ne(`Invalid Vector: padding must be a value between 0 and 7. found: ${H}`);
        }
        Ae.BSON_BINARY_SUBTYPE_DEFAULT = 0, Ae.BUFFER_SIZE = 256, Ae.SUBTYPE_DEFAULT = 0, Ae.SUBTYPE_FUNCTION = 1, Ae.SUBTYPE_BYTE_ARRAY = 2, Ae.SUBTYPE_UUID_OLD = 3, Ae.SUBTYPE_UUID = 4, Ae.SUBTYPE_MD5 = 5, Ae.SUBTYPE_ENCRYPTED = 6, Ae.SUBTYPE_COLUMN = 7, Ae.SUBTYPE_SENSITIVE = 8, Ae.SUBTYPE_VECTOR = 9, Ae.SUBTYPE_USER_DEFINED = 128, Ae.VECTOR_TYPE = Object.freeze({ Int8: 3, Float32: 39, PackedBit: 16 });
        const et = /^[0-9A-F]{32}$/i, lt = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
        class ft extends Ae {
          constructor(S) {
            let Q;
            if (S == null) Q = ft.generate();
            else if (S instanceof ft) Q = re.toLocalBufferType(new Uint8Array(S.buffer));
            else if (ArrayBuffer.isView(S) && S.byteLength === 16) Q = re.toLocalBufferType(S);
            else {
              if (typeof S != "string") throw new ne("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
              Q = ft.bytesFromString(S);
            }
            super(Q, de);
          }
          get id() {
            return this.buffer;
          }
          set id(S) {
            this.buffer = S;
          }
          toHexString(S = !0) {
            return S ? [re.toHex(this.buffer.subarray(0, 4)), re.toHex(this.buffer.subarray(4, 6)), re.toHex(this.buffer.subarray(6, 8)), re.toHex(this.buffer.subarray(8, 10)), re.toHex(this.buffer.subarray(10, 16))].join("-") : re.toHex(this.buffer);
          }
          toString(S) {
            return S === "hex" ? re.toHex(this.id) : S === "base64" ? re.toBase64(this.id) : this.toHexString();
          }
          toJSON() {
            return this.toHexString();
          }
          equals(S) {
            if (!S) return !1;
            if (S instanceof ft) return re.equals(S.id, this.id);
            try {
              return re.equals(new ft(S).id, this.id);
            } catch {
              return !1;
            }
          }
          toBinary() {
            return new Ae(this.id, Ae.SUBTYPE_UUID);
          }
          static generate() {
            const S = re.randomBytes(16);
            return S[6] = 15 & S[6] | 64, S[8] = 63 & S[8] | 128, S;
          }
          static isValid(S) {
            return !!S && (typeof S == "string" ? ft.isValidUUIDString(S) : f(S) ? S.byteLength === 16 : S._bsontype === "Binary" && S.sub_type === this.SUBTYPE_UUID && S.buffer.byteLength === 16);
          }
          static createFromHexString(S) {
            const Q = ft.bytesFromString(S);
            return new ft(Q);
          }
          static createFromBase64(S) {
            return new ft(re.fromBase64(S));
          }
          static bytesFromString(S) {
            if (!ft.isValidUUIDString(S)) throw new ne("UUID string representation must be 32 hex digits or canonical hyphenated representation");
            return re.fromHex(S.replace(/-/g, ""));
          }
          static isValidUUIDString(S) {
            return et.test(S) || lt.test(S);
          }
          inspect(S, Q, H) {
            return H ??= d, `new UUID(${H(this.toHexString(), Q)})`;
          }
        }
        class Ke extends pe {
          get _bsontype() {
            return "Code";
          }
          constructor(S, Q) {
            super(), this.code = S.toString(), this.scope = Q ?? null;
          }
          toJSON() {
            return this.scope != null ? { code: this.code, scope: this.scope } : { code: this.code };
          }
          toExtendedJSON() {
            return this.scope ? { $code: this.code, $scope: this.scope } : { $code: this.code };
          }
          static fromExtendedJSON(S) {
            return new Ke(S.$code, S.$scope);
          }
          inspect(S, Q, H) {
            H ??= d;
            let Se = H(this.code, Q);
            const Oe = Se.includes(`
`);
            return this.scope != null && (Se += `,${Oe ? `
` : " "}${H(this.scope, Q)}`), `new Code(${Oe ? `
` : ""}${Se}${Oe && this.scope === null ? `
` : ""})`;
          }
        }
        function Xt(C) {
          return C != null && typeof C == "object" && "$id" in C && C.$id != null && "$ref" in C && typeof C.$ref == "string" && (!("$db" in C) || "$db" in C && typeof C.$db == "string");
        }
        class $t extends pe {
          get _bsontype() {
            return "DBRef";
          }
          constructor(S, Q, H, Se) {
            super();
            const Oe = S.split(".");
            Oe.length === 2 && (H = Oe.shift(), S = Oe.shift()), this.collection = S, this.oid = Q, this.db = H, this.fields = Se || {};
          }
          get namespace() {
            return this.collection;
          }
          set namespace(S) {
            this.collection = S;
          }
          toJSON() {
            const S = Object.assign({ $ref: this.collection, $id: this.oid }, this.fields);
            return this.db != null && (S.$db = this.db), S;
          }
          toExtendedJSON(S) {
            S = S || {};
            let Q = { $ref: this.collection, $id: this.oid };
            return S.legacy || (this.db && (Q.$db = this.db), Q = Object.assign(Q, this.fields)), Q;
          }
          static fromExtendedJSON(S) {
            const Q = Object.assign({}, S);
            return delete Q.$ref, delete Q.$id, delete Q.$db, new $t(S.$ref, S.$id, S.$db, Q);
          }
          inspect(S, Q, H) {
            H ??= d;
            const Se = [H(this.namespace, Q), H(this.oid, Q), ...this.db ? [H(this.db, Q)] : [], ...Object.keys(this.fields).length > 0 ? [H(this.fields, Q)] : []];
            return Se[1] = H === d ? `new ObjectId(${Se[1]})` : Se[1], `new DBRef(${Se.join(", ")})`;
          }
        }
        function Pt(C) {
          if (C === "") return C;
          let S = 0;
          const Q = C[S] === "-", H = C[S] === "+";
          (H || Q) && (S += 1);
          let Se = !1;
          for (; S < C.length && C[S] === "0"; ++S) Se = !0;
          return Se ? `${Q ? "-" : ""}${C.length === S ? "0" : C.slice(S)}` : H ? C.slice(1) : C;
        }
        let Tt;
        try {
          Tt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
        } catch {
        }
        const Ft = 4294967296, xt = 18446744073709552e3, ir = xt / 2, Le = {}, Pr = {}, It = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
        class je extends pe {
          get _bsontype() {
            return "Long";
          }
          get __isLong__() {
            return !0;
          }
          constructor(S = 0, Q, H) {
            super();
            const Se = typeof Q == "boolean" ? Q : !!H, Oe = typeof Q == "number" ? Q : 0, Ve = typeof S == "string" ? je.fromString(S, Se) : typeof S == "bigint" ? je.fromBigInt(S, Se) : { low: 0 | S, high: 0 | Oe, unsigned: Se };
            this.low = Ve.low, this.high = Ve.high, this.unsigned = Ve.unsigned;
          }
          static fromBits(S, Q, H) {
            return new je(S, Q, H);
          }
          static fromInt(S, Q) {
            let H, Se, Oe;
            return Q ? (Oe = 0 <= (S >>>= 0) && S < 256) && (Se = Pr[S], Se) ? Se : (H = je.fromBits(S, (0 | S) < 0 ? -1 : 0, !0), Oe && (Pr[S] = H), H) : (Oe = -128 <= (S |= 0) && S < 128) && (Se = Le[S], Se) ? Se : (H = je.fromBits(S, S < 0 ? -1 : 0, !1), Oe && (Le[S] = H), H);
          }
          static fromNumber(S, Q) {
            if (isNaN(S)) return Q ? je.UZERO : je.ZERO;
            if (Q) {
              if (S < 0) return je.UZERO;
              if (S >= xt) return je.MAX_UNSIGNED_VALUE;
            } else {
              if (S <= -9223372036854776e3) return je.MIN_VALUE;
              if (S + 1 >= ir) return je.MAX_VALUE;
            }
            return S < 0 ? je.fromNumber(-S, Q).neg() : je.fromBits(S % Ft | 0, S / Ft | 0, Q);
          }
          static fromBigInt(S, Q) {
            const H = BigInt(4294967295), Se = BigInt(32);
            return new je(Number(S & H), Number(S >> Se & H), Q);
          }
          static _fromString(S, Q, H) {
            if (S.length === 0) throw new ne("empty string");
            if (H < 2 || 36 < H) throw new ne("radix");
            let Se;
            if ((Se = S.indexOf("-")) > 0) throw new ne("interior hyphen");
            if (Se === 0) return je._fromString(S.substring(1), Q, H).neg();
            const Oe = je.fromNumber(Math.pow(H, 8));
            let Ve = je.ZERO;
            for (let Ze = 0; Ze < S.length; Ze += 8) {
              const ke = Math.min(8, S.length - Ze), ut = parseInt(S.substring(Ze, Ze + ke), H);
              if (ke < 8) {
                const Xe = je.fromNumber(Math.pow(H, ke));
                Ve = Ve.mul(Xe).add(je.fromNumber(ut));
              } else Ve = Ve.mul(Oe), Ve = Ve.add(je.fromNumber(ut));
            }
            return Ve.unsigned = Q, Ve;
          }
          static fromStringStrict(S, Q, H) {
            let Se = !1;
            if (typeof Q == "number" ? (H = Q, Q = !1) : Se = !!Q, H ??= 10, S.trim() !== S) throw new ne(`Input: '${S}' contains leading and/or trailing whitespace`);
            if (!(function(Ze, ke) {
              const ut = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, ke = ke ?? 10);
              return !new RegExp(`[^-+${ut}]`, "i").test(Ze) && Ze;
            })(S, H)) throw new ne(`Input: '${S}' contains invalid characters for radix: ${H}`);
            const Oe = Pt(S), Ve = je._fromString(Oe, Se, H);
            if (Ve.toString(H).toLowerCase() !== Oe.toLowerCase()) throw new ne(`Input: ${S} is not representable as ${Ve.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${H != null ? `with radix: ${H}` : ""}`);
            return Ve;
          }
          static fromString(S, Q, H) {
            let Se = !1;
            return typeof Q == "number" ? (H = Q, Q = !1) : Se = !!Q, H ??= 10, S === "NaN" && H < 24 || (S === "Infinity" || S === "+Infinity" || S === "-Infinity") && H < 35 ? je.ZERO : je._fromString(S, Se, H);
          }
          static fromBytes(S, Q, H) {
            return H ? je.fromBytesLE(S, Q) : je.fromBytesBE(S, Q);
          }
          static fromBytesLE(S, Q) {
            return new je(S[0] | S[1] << 8 | S[2] << 16 | S[3] << 24, S[4] | S[5] << 8 | S[6] << 16 | S[7] << 24, Q);
          }
          static fromBytesBE(S, Q) {
            return new je(S[4] << 24 | S[5] << 16 | S[6] << 8 | S[7], S[0] << 24 | S[1] << 16 | S[2] << 8 | S[3], Q);
          }
          static isLong(S) {
            return S != null && typeof S == "object" && "__isLong__" in S && S.__isLong__ === !0;
          }
          static fromValue(S, Q) {
            return typeof S == "number" ? je.fromNumber(S, Q) : typeof S == "string" ? je.fromString(S, Q) : je.fromBits(S.low, S.high, typeof Q == "boolean" ? Q : S.unsigned);
          }
          add(S) {
            je.isLong(S) || (S = je.fromValue(S));
            const Q = this.high >>> 16, H = 65535 & this.high, Se = this.low >>> 16, Oe = 65535 & this.low, Ve = S.high >>> 16, Ze = 65535 & S.high, ke = S.low >>> 16;
            let ut = 0, Xe = 0, Be = 0, Ye = 0;
            return Ye += Oe + (65535 & S.low), Be += Ye >>> 16, Ye &= 65535, Be += Se + ke, Xe += Be >>> 16, Be &= 65535, Xe += H + Ze, ut += Xe >>> 16, Xe &= 65535, ut += Q + Ve, ut &= 65535, je.fromBits(Be << 16 | Ye, ut << 16 | Xe, this.unsigned);
          }
          and(S) {
            return je.isLong(S) || (S = je.fromValue(S)), je.fromBits(this.low & S.low, this.high & S.high, this.unsigned);
          }
          compare(S) {
            if (je.isLong(S) || (S = je.fromValue(S)), this.eq(S)) return 0;
            const Q = this.isNegative(), H = S.isNegative();
            return Q && !H ? -1 : !Q && H ? 1 : this.unsigned ? S.high >>> 0 > this.high >>> 0 || S.high === this.high && S.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(S).isNegative() ? -1 : 1;
          }
          comp(S) {
            return this.compare(S);
          }
          divide(S) {
            if (je.isLong(S) || (S = je.fromValue(S)), S.isZero()) throw new ne("division by zero");
            if (Tt) {
              if (!this.unsigned && this.high === -2147483648 && S.low === -1 && S.high === -1) return this;
              const Oe = (this.unsigned ? Tt.div_u : Tt.div_s)(this.low, this.high, S.low, S.high);
              return je.fromBits(Oe, Tt.get_high(), this.unsigned);
            }
            if (this.isZero()) return this.unsigned ? je.UZERO : je.ZERO;
            let Q, H, Se;
            if (this.unsigned) {
              if (S.unsigned || (S = S.toUnsigned()), S.gt(this)) return je.UZERO;
              if (S.gt(this.shru(1))) return je.UONE;
              Se = je.UZERO;
            } else {
              if (this.eq(je.MIN_VALUE)) return S.eq(je.ONE) || S.eq(je.NEG_ONE) ? je.MIN_VALUE : S.eq(je.MIN_VALUE) ? je.ONE : (Q = this.shr(1).div(S).shl(1), Q.eq(je.ZERO) ? S.isNegative() ? je.ONE : je.NEG_ONE : (H = this.sub(S.mul(Q)), Se = Q.add(H.div(S)), Se));
              if (S.eq(je.MIN_VALUE)) return this.unsigned ? je.UZERO : je.ZERO;
              if (this.isNegative()) return S.isNegative() ? this.neg().div(S.neg()) : this.neg().div(S).neg();
              if (S.isNegative()) return this.div(S.neg()).neg();
              Se = je.ZERO;
            }
            for (H = this; H.gte(S); ) {
              Q = Math.max(1, Math.floor(H.toNumber() / S.toNumber()));
              const Oe = Math.ceil(Math.log(Q) / Math.LN2), Ve = Oe <= 48 ? 1 : Math.pow(2, Oe - 48);
              let Ze = je.fromNumber(Q), ke = Ze.mul(S);
              for (; ke.isNegative() || ke.gt(H); ) Q -= Ve, Ze = je.fromNumber(Q, this.unsigned), ke = Ze.mul(S);
              Ze.isZero() && (Ze = je.ONE), Se = Se.add(Ze), H = H.sub(ke);
            }
            return Se;
          }
          div(S) {
            return this.divide(S);
          }
          equals(S) {
            return je.isLong(S) || (S = je.fromValue(S)), (this.unsigned === S.unsigned || this.high >>> 31 != 1 || S.high >>> 31 != 1) && this.high === S.high && this.low === S.low;
          }
          eq(S) {
            return this.equals(S);
          }
          getHighBits() {
            return this.high;
          }
          getHighBitsUnsigned() {
            return this.high >>> 0;
          }
          getLowBits() {
            return this.low;
          }
          getLowBitsUnsigned() {
            return this.low >>> 0;
          }
          getNumBitsAbs() {
            if (this.isNegative()) return this.eq(je.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
            const S = this.high !== 0 ? this.high : this.low;
            let Q;
            for (Q = 31; Q > 0 && !(S & 1 << Q); Q--) ;
            return this.high !== 0 ? Q + 33 : Q + 1;
          }
          greaterThan(S) {
            return this.comp(S) > 0;
          }
          gt(S) {
            return this.greaterThan(S);
          }
          greaterThanOrEqual(S) {
            return this.comp(S) >= 0;
          }
          gte(S) {
            return this.greaterThanOrEqual(S);
          }
          ge(S) {
            return this.greaterThanOrEqual(S);
          }
          isEven() {
            return !(1 & this.low);
          }
          isNegative() {
            return !this.unsigned && this.high < 0;
          }
          isOdd() {
            return !(1 & ~this.low);
          }
          isPositive() {
            return this.unsigned || this.high >= 0;
          }
          isZero() {
            return this.high === 0 && this.low === 0;
          }
          lessThan(S) {
            return this.comp(S) < 0;
          }
          lt(S) {
            return this.lessThan(S);
          }
          lessThanOrEqual(S) {
            return this.comp(S) <= 0;
          }
          lte(S) {
            return this.lessThanOrEqual(S);
          }
          modulo(S) {
            if (je.isLong(S) || (S = je.fromValue(S)), Tt) {
              const Q = (this.unsigned ? Tt.rem_u : Tt.rem_s)(this.low, this.high, S.low, S.high);
              return je.fromBits(Q, Tt.get_high(), this.unsigned);
            }
            return this.sub(this.div(S).mul(S));
          }
          mod(S) {
            return this.modulo(S);
          }
          rem(S) {
            return this.modulo(S);
          }
          multiply(S) {
            if (this.isZero()) return je.ZERO;
            if (je.isLong(S) || (S = je.fromValue(S)), Tt) {
              const mt = Tt.mul(this.low, this.high, S.low, S.high);
              return je.fromBits(mt, Tt.get_high(), this.unsigned);
            }
            if (S.isZero()) return je.ZERO;
            if (this.eq(je.MIN_VALUE)) return S.isOdd() ? je.MIN_VALUE : je.ZERO;
            if (S.eq(je.MIN_VALUE)) return this.isOdd() ? je.MIN_VALUE : je.ZERO;
            if (this.isNegative()) return S.isNegative() ? this.neg().mul(S.neg()) : this.neg().mul(S).neg();
            if (S.isNegative()) return this.mul(S.neg()).neg();
            if (this.lt(je.TWO_PWR_24) && S.lt(je.TWO_PWR_24)) return je.fromNumber(this.toNumber() * S.toNumber(), this.unsigned);
            const Q = this.high >>> 16, H = 65535 & this.high, Se = this.low >>> 16, Oe = 65535 & this.low, Ve = S.high >>> 16, Ze = 65535 & S.high, ke = S.low >>> 16, ut = 65535 & S.low;
            let Xe = 0, Be = 0, Ye = 0, ht = 0;
            return ht += Oe * ut, Ye += ht >>> 16, ht &= 65535, Ye += Se * ut, Be += Ye >>> 16, Ye &= 65535, Ye += Oe * ke, Be += Ye >>> 16, Ye &= 65535, Be += H * ut, Xe += Be >>> 16, Be &= 65535, Be += Se * ke, Xe += Be >>> 16, Be &= 65535, Be += Oe * Ze, Xe += Be >>> 16, Be &= 65535, Xe += Q * ut + H * ke + Se * Ze + Oe * Ve, Xe &= 65535, je.fromBits(Ye << 16 | ht, Xe << 16 | Be, this.unsigned);
          }
          mul(S) {
            return this.multiply(S);
          }
          negate() {
            return !this.unsigned && this.eq(je.MIN_VALUE) ? je.MIN_VALUE : this.not().add(je.ONE);
          }
          neg() {
            return this.negate();
          }
          not() {
            return je.fromBits(~this.low, ~this.high, this.unsigned);
          }
          notEquals(S) {
            return !this.equals(S);
          }
          neq(S) {
            return this.notEquals(S);
          }
          ne(S) {
            return this.notEquals(S);
          }
          or(S) {
            return je.isLong(S) || (S = je.fromValue(S)), je.fromBits(this.low | S.low, this.high | S.high, this.unsigned);
          }
          shiftLeft(S) {
            return je.isLong(S) && (S = S.toInt()), (S &= 63) == 0 ? this : S < 32 ? je.fromBits(this.low << S, this.high << S | this.low >>> 32 - S, this.unsigned) : je.fromBits(0, this.low << S - 32, this.unsigned);
          }
          shl(S) {
            return this.shiftLeft(S);
          }
          shiftRight(S) {
            return je.isLong(S) && (S = S.toInt()), (S &= 63) == 0 ? this : S < 32 ? je.fromBits(this.low >>> S | this.high << 32 - S, this.high >> S, this.unsigned) : je.fromBits(this.high >> S - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }
          shr(S) {
            return this.shiftRight(S);
          }
          shiftRightUnsigned(S) {
            if (je.isLong(S) && (S = S.toInt()), (S &= 63) == 0) return this;
            {
              const Q = this.high;
              if (S < 32) {
                const H = this.low;
                return je.fromBits(H >>> S | Q << 32 - S, Q >>> S, this.unsigned);
              }
              return S === 32 ? je.fromBits(Q, 0, this.unsigned) : je.fromBits(Q >>> S - 32, 0, this.unsigned);
            }
          }
          shr_u(S) {
            return this.shiftRightUnsigned(S);
          }
          shru(S) {
            return this.shiftRightUnsigned(S);
          }
          subtract(S) {
            return je.isLong(S) || (S = je.fromValue(S)), this.add(S.neg());
          }
          sub(S) {
            return this.subtract(S);
          }
          toInt() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }
          toNumber() {
            return this.unsigned ? (this.high >>> 0) * Ft + (this.low >>> 0) : this.high * Ft + (this.low >>> 0);
          }
          toBigInt() {
            return BigInt(this.toString());
          }
          toBytes(S) {
            return S ? this.toBytesLE() : this.toBytesBE();
          }
          toBytesLE() {
            const S = this.high, Q = this.low;
            return [255 & Q, Q >>> 8 & 255, Q >>> 16 & 255, Q >>> 24, 255 & S, S >>> 8 & 255, S >>> 16 & 255, S >>> 24];
          }
          toBytesBE() {
            const S = this.high, Q = this.low;
            return [S >>> 24, S >>> 16 & 255, S >>> 8 & 255, 255 & S, Q >>> 24, Q >>> 16 & 255, Q >>> 8 & 255, 255 & Q];
          }
          toSigned() {
            return this.unsigned ? je.fromBits(this.low, this.high, !1) : this;
          }
          toString(S) {
            if ((S = S || 10) < 2 || 36 < S) throw new ne("radix");
            if (this.isZero()) return "0";
            if (this.isNegative()) {
              if (this.eq(je.MIN_VALUE)) {
                const Oe = je.fromNumber(S), Ve = this.div(Oe), Ze = Ve.mul(Oe).sub(this);
                return Ve.toString(S) + Ze.toInt().toString(S);
              }
              return "-" + this.neg().toString(S);
            }
            const Q = je.fromNumber(Math.pow(S, 6), this.unsigned);
            let H = this, Se = "";
            for (; ; ) {
              const Oe = H.div(Q);
              let Ve = (H.sub(Oe.mul(Q)).toInt() >>> 0).toString(S);
              if (H = Oe, H.isZero()) return Ve + Se;
              for (; Ve.length < 6; ) Ve = "0" + Ve;
              Se = "" + Ve + Se;
            }
          }
          toUnsigned() {
            return this.unsigned ? this : je.fromBits(this.low, this.high, !0);
          }
          xor(S) {
            return je.isLong(S) || (S = je.fromValue(S)), je.fromBits(this.low ^ S.low, this.high ^ S.high, this.unsigned);
          }
          eqz() {
            return this.isZero();
          }
          le(S) {
            return this.lessThanOrEqual(S);
          }
          toExtendedJSON(S) {
            return S && S.relaxed ? this.toNumber() : { $numberLong: this.toString() };
          }
          static fromExtendedJSON(S, Q) {
            const { useBigInt64: H = !1, relaxed: Se = !0 } = { ...Q };
            if (S.$numberLong.length > 20) throw new ne("$numberLong string is too long");
            if (!It.test(S.$numberLong)) throw new ne(`$numberLong string "${S.$numberLong}" is in an invalid format`);
            if (H) {
              const Ve = BigInt(S.$numberLong);
              return BigInt.asIntN(64, Ve);
            }
            const Oe = je.fromString(S.$numberLong);
            return Se ? Oe.toNumber() : Oe;
          }
          inspect(S, Q, H) {
            return H ??= d, `new Long(${H(this.toString(), Q)}${this.unsigned ? `, ${H(this.unsigned, Q)}` : ""})`;
          }
        }
        je.TWO_PWR_24 = je.fromInt(16777216), je.MAX_UNSIGNED_VALUE = je.fromBits(-1, -1, !0), je.ZERO = je.fromInt(0), je.UZERO = je.fromInt(0, !0), je.ONE = je.fromInt(1), je.UONE = je.fromInt(1, !0), je.NEG_ONE = je.fromInt(-1), je.MAX_VALUE = je.fromBits(-1, 2147483647, !1), je.MIN_VALUE = je.fromBits(0, -2147483648, !1);
        const qr = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/, Cn = /^(\+|-)?(Infinity|inf)$/i, Wr = /^(\+|-)?NaN$/i, or = 6111, Gr = -6176, ti = re.fromNumberArray([124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), mr = re.fromNumberArray([248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), on = re.fromNumberArray([120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), K = /^([-+])?(\d+)?$/;
        function se(C) {
          return !isNaN(parseInt(C, 10));
        }
        function me(C) {
          const S = je.fromNumber(1e9);
          let Q = je.fromNumber(0);
          if (!(C.parts[0] || C.parts[1] || C.parts[2] || C.parts[3])) return { quotient: C, rem: Q };
          for (let H = 0; H <= 3; H++) Q = Q.shiftLeft(32), Q = Q.add(new je(C.parts[H], 0)), C.parts[H] = Q.div(S).low, Q = Q.modulo(S);
          return { quotient: C, rem: Q };
        }
        function ge(C, S) {
          throw new ne(`"${C}" is not a valid Decimal128 string - ${S}`);
        }
        class _e extends pe {
          get _bsontype() {
            return "Decimal128";
          }
          constructor(S) {
            if (super(), typeof S == "string") this.bytes = _e.fromString(S).bytes;
            else {
              if (!(S instanceof Uint8Array || f(S))) throw new ne("Decimal128 must take a Buffer or string");
              if (S.byteLength !== 16) throw new ne("Decimal128 must take a Buffer of 16 bytes");
              this.bytes = S;
            }
          }
          static fromString(S) {
            return _e._fromString(S, { allowRounding: !1 });
          }
          static fromStringWithRounding(S) {
            return _e._fromString(S, { allowRounding: !0 });
          }
          static _fromString(S, Q) {
            let H = !1, Se = !1, Oe = !1, Ve = !1, Ze = 0, ke = 0, ut = 0, Xe = 0, Be = 0;
            const Ye = [0];
            let ht = 0, mt = 0, Zt = 0, sr = 0, ur = new je(0, 0), Nr = new je(0, 0), cr = 0, st = 0;
            if (S.length >= 7e3) throw new ne(S + " not a valid Decimal128 string");
            const wt = S.match(qr), ri = S.match(Cn), Ht = S.match(Wr);
            if (!wt && !ri && !Ht || S.length === 0) throw new ne(S + " not a valid Decimal128 string");
            if (wt) {
              const gt = wt[2], Jr = wt[4], Fr = wt[5], Lr = wt[6];
              Jr && Lr === void 0 && ge(S, "missing exponent power"), Jr && gt === void 0 && ge(S, "missing exponent base"), Jr === void 0 && (Fr || Lr) && ge(S, "missing e before exponent");
            }
            if (S[st] !== "+" && S[st] !== "-" || (Se = !0, H = S[st++] === "-"), !se(S[st]) && S[st] !== ".") {
              if (S[st] === "i" || S[st] === "I") return new _e(H ? mr : on);
              if (S[st] === "N") return new _e(ti);
            }
            for (; se(S[st]) || S[st] === "."; ) S[st] !== "." ? (ht < 34 && (S[st] !== "0" || Ve) && (Ve || (Be = ke), Ve = !0, Ye[mt++] = parseInt(S[st], 10), ht += 1), Ve && (ut += 1), Oe && (Xe += 1), ke += 1, st += 1) : (Oe && ge(S, "contains multiple periods"), Oe = !0, st += 1);
            if (Oe && !ke) throw new ne(S + " not a valid Decimal128 string");
            if (S[st] === "e" || S[st] === "E") {
              const gt = S.substr(++st).match(K);
              if (!gt || !gt[2]) return new _e(ti);
              sr = parseInt(gt[0], 10), st += gt[0].length;
            }
            if (S[st]) return new _e(ti);
            if (ht) {
              if (Zt = ht - 1, Ze = ut, Ze !== 1) for (; S[Be + Ze - 1 + Number(Se) + Number(Oe)] === "0"; ) Ze -= 1;
            } else Ye[0] = 0, ut = 1, ht = 1, Ze = 0;
            for (sr <= Xe && Xe > sr + 16384 ? sr = Gr : sr -= Xe; sr > or; ) {
              if (Zt += 1, Zt >= 34) {
                if (Ze === 0) {
                  sr = or;
                  break;
                }
                ge(S, "overflow");
              }
              sr -= 1;
            }
            if (Q.allowRounding) {
              for (; sr < Gr || ht < ut; ) {
                if (Zt === 0 && Ze < ht) {
                  sr = Gr, Ze = 0;
                  break;
                }
                if (ht < ut ? ut -= 1 : Zt -= 1, sr < or) sr += 1;
                else {
                  if (Ye.join("").match(/^0+$/)) {
                    sr = or;
                    break;
                  }
                  ge(S, "overflow");
                }
              }
              if (Zt + 1 < Ze) {
                let gt = ke;
                Oe && (Be += 1, gt += 1), Se && (Be += 1, gt += 1);
                const Jr = parseInt(S[Be + Zt + 1], 10);
                let Fr = 0;
                if (Jr >= 5 && (Fr = 1, Jr === 5)) {
                  Fr = Ye[Zt] % 2 == 1 ? 1 : 0;
                  for (let Lr = Be + Zt + 2; Lr < gt; Lr++) if (parseInt(S[Lr], 10)) {
                    Fr = 1;
                    break;
                  }
                }
                if (Fr) {
                  let Lr = Zt;
                  for (; Lr >= 0 && ++Ye[Lr] > 9; Lr--) if (Ye[Lr] = 0, Lr === 0) {
                    if (!(sr < or)) return new _e(H ? mr : on);
                    sr += 1, Ye[Lr] = 1;
                  }
                }
              }
            } else {
              for (; sr < Gr || ht < ut; ) {
                if (Zt === 0) {
                  if (Ze === 0) {
                    sr = Gr;
                    break;
                  }
                  ge(S, "exponent underflow");
                }
                ht < ut ? (S[ut - 1 + Number(Se) + Number(Oe)] !== "0" && Ze !== 0 && ge(S, "inexact rounding"), ut -= 1) : (Ye[Zt] !== 0 && ge(S, "inexact rounding"), Zt -= 1), sr < or ? sr += 1 : ge(S, "overflow");
              }
              Zt + 1 < Ze && (Oe && (Be += 1), Se && (Be += 1), parseInt(S[Be + Zt + 1], 10) !== 0 && ge(S, "inexact rounding"));
            }
            if (ur = je.fromNumber(0), Nr = je.fromNumber(0), Ze === 0) ur = je.fromNumber(0), Nr = je.fromNumber(0);
            else if (Zt < 17) {
              let gt = 0;
              for (Nr = je.fromNumber(Ye[gt++]), ur = new je(0, 0); gt <= Zt; gt++) Nr = Nr.multiply(je.fromNumber(10)), Nr = Nr.add(je.fromNumber(Ye[gt]));
            } else {
              let gt = 0;
              for (ur = je.fromNumber(Ye[gt++]); gt <= Zt - 17; gt++) ur = ur.multiply(je.fromNumber(10)), ur = ur.add(je.fromNumber(Ye[gt]));
              for (Nr = je.fromNumber(Ye[gt++]); gt <= Zt; gt++) Nr = Nr.multiply(je.fromNumber(10)), Nr = Nr.add(je.fromNumber(Ye[gt]));
            }
            const Xr = (function(gt, Jr) {
              if (!gt && !Jr) return { high: je.fromNumber(0), low: je.fromNumber(0) };
              const Fr = gt.shiftRightUnsigned(32), Lr = new je(gt.getLowBits(), 0), Ng = Jr.shiftRightUnsigned(32), Cg = new je(Jr.getLowBits(), 0);
              let ia = Fr.multiply(Ng), oa = Fr.multiply(Cg);
              const lk = Lr.multiply(Ng);
              let ms = Lr.multiply(Cg);
              return ia = ia.add(oa.shiftRightUnsigned(32)), oa = new je(oa.getLowBits(), 0).add(lk).add(ms.shiftRightUnsigned(32)), ia = ia.add(oa.shiftRightUnsigned(32)), ms = oa.shiftLeft(32).add(new je(ms.getLowBits(), 0)), { high: ia, low: ms };
            })(ur, je.fromString("100000000000000000"));
            Xr.low = Xr.low.add(Nr), (function(gt, Jr) {
              const Fr = gt.high >>> 0, Lr = Jr.high >>> 0;
              return Fr < Lr || Fr === Lr && gt.low >>> 0 < Jr.low >>> 0;
            })(Xr.low, Nr) && (Xr.high = Xr.high.add(je.fromNumber(1))), cr = sr + 6176;
            const at = { low: je.fromNumber(0), high: je.fromNumber(0) };
            Xr.high.shiftRightUnsigned(49).and(je.fromNumber(1)).equals(je.fromNumber(1)) ? (at.high = at.high.or(je.fromNumber(3).shiftLeft(61)), at.high = at.high.or(je.fromNumber(cr).and(je.fromNumber(16383).shiftLeft(47))), at.high = at.high.or(Xr.high.and(je.fromNumber(140737488355327)))) : (at.high = at.high.or(je.fromNumber(16383 & cr).shiftLeft(49)), at.high = at.high.or(Xr.high.and(je.fromNumber(562949953421311)))), at.low = Xr.low, H && (at.high = at.high.or(je.fromString("9223372036854775808")));
            const dt = re.allocateUnsafe(16);
            return st = 0, dt[st++] = 255 & at.low.low, dt[st++] = at.low.low >> 8 & 255, dt[st++] = at.low.low >> 16 & 255, dt[st++] = at.low.low >> 24 & 255, dt[st++] = 255 & at.low.high, dt[st++] = at.low.high >> 8 & 255, dt[st++] = at.low.high >> 16 & 255, dt[st++] = at.low.high >> 24 & 255, dt[st++] = 255 & at.high.low, dt[st++] = at.high.low >> 8 & 255, dt[st++] = at.high.low >> 16 & 255, dt[st++] = at.high.low >> 24 & 255, dt[st++] = 255 & at.high.high, dt[st++] = at.high.high >> 8 & 255, dt[st++] = at.high.high >> 16 & 255, dt[st++] = at.high.high >> 24 & 255, new _e(dt);
          }
          toString() {
            let S, Q = 0;
            const H = new Array(36);
            for (let cr = 0; cr < H.length; cr++) H[cr] = 0;
            let Se, Oe, Ve, Ze = 0, ke = !1, ut = { parts: [0, 0, 0, 0] };
            const Xe = [];
            Ze = 0;
            const Be = this.bytes, Ye = Be[Ze++] | Be[Ze++] << 8 | Be[Ze++] << 16 | Be[Ze++] << 24, ht = Be[Ze++] | Be[Ze++] << 8 | Be[Ze++] << 16 | Be[Ze++] << 24, mt = Be[Ze++] | Be[Ze++] << 8 | Be[Ze++] << 16 | Be[Ze++] << 24, Zt = Be[Ze++] | Be[Ze++] << 8 | Be[Ze++] << 16 | Be[Ze++] << 24;
            Ze = 0, (new je(Ye, ht), new je(mt, Zt)).lessThan(je.ZERO) && Xe.push("-");
            const sr = Zt >> 26 & 31;
            if (sr >> 3 == 3) {
              if (sr === 30) return Xe.join("") + "Infinity";
              if (sr === 31) return "NaN";
              S = Zt >> 15 & 16383, Se = 8 + (Zt >> 14 & 1);
            } else Se = Zt >> 14 & 7, S = Zt >> 17 & 16383;
            const ur = S - 6176;
            if (ut.parts[0] = (16383 & Zt) + ((15 & Se) << 14), ut.parts[1] = mt, ut.parts[2] = ht, ut.parts[3] = Ye, ut.parts[0] === 0 && ut.parts[1] === 0 && ut.parts[2] === 0 && ut.parts[3] === 0) ke = !0;
            else for (Ve = 3; Ve >= 0; Ve--) {
              let cr = 0;
              const st = me(ut);
              if (ut = st.quotient, cr = st.rem.low, cr) for (Oe = 8; Oe >= 0; Oe--) H[9 * Ve + Oe] = cr % 10, cr = Math.floor(cr / 10);
            }
            if (ke) Q = 1, H[Ze] = 0;
            else for (Q = 36; !H[Ze]; ) Q -= 1, Ze += 1;
            const Nr = Q - 1 + ur;
            if (Nr >= 34 || Nr <= -7 || ur > 0) {
              if (Q > 34) return Xe.push("0"), ur > 0 ? Xe.push(`E+${ur}`) : ur < 0 && Xe.push(`E${ur}`), Xe.join("");
              Xe.push(`${H[Ze++]}`), Q -= 1, Q && Xe.push(".");
              for (let cr = 0; cr < Q; cr++) Xe.push(`${H[Ze++]}`);
              Xe.push("E"), Nr > 0 ? Xe.push(`+${Nr}`) : Xe.push(`${Nr}`);
            } else if (ur >= 0) for (let cr = 0; cr < Q; cr++) Xe.push(`${H[Ze++]}`);
            else {
              let cr = Q + ur;
              if (cr > 0) for (let st = 0; st < cr; st++) Xe.push(`${H[Ze++]}`);
              else Xe.push("0");
              for (Xe.push("."); cr++ < 0; ) Xe.push("0");
              for (let st = 0; st < Q - Math.max(cr - 1, 0); st++) Xe.push(`${H[Ze++]}`);
            }
            return Xe.join("");
          }
          toJSON() {
            return { $numberDecimal: this.toString() };
          }
          toExtendedJSON() {
            return { $numberDecimal: this.toString() };
          }
          static fromExtendedJSON(S) {
            return _e.fromString(S.$numberDecimal);
          }
          inspect(S, Q, H) {
            return H ??= d, `new Decimal128(${H(this.toString(), Q)})`;
          }
        }
        class $e extends pe {
          get _bsontype() {
            return "Double";
          }
          constructor(S) {
            super(), S instanceof Number && (S = S.valueOf()), this.value = +S;
          }
          static fromString(S) {
            const Q = Number(S);
            if (S === "NaN") return new $e(NaN);
            if (S === "Infinity") return new $e(1 / 0);
            if (S === "-Infinity") return new $e(-1 / 0);
            if (!Number.isFinite(Q)) throw new ne(`Input: ${S} is not representable as a Double`);
            if (S.trim() !== S) throw new ne(`Input: '${S}' contains whitespace`);
            if (S === "") throw new ne("Input is an empty string");
            if (/[^-0-9.+eE]/.test(S)) throw new ne(`Input: '${S}' is not in decimal or exponential notation`);
            return new $e(Q);
          }
          valueOf() {
            return this.value;
          }
          toJSON() {
            return this.value;
          }
          toString(S) {
            return this.value.toString(S);
          }
          toExtendedJSON(S) {
            return S && (S.legacy || S.relaxed && isFinite(this.value)) ? this.value : Object.is(Math.sign(this.value), -0) ? { $numberDouble: "-0.0" } : { $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString() };
          }
          static fromExtendedJSON(S, Q) {
            const H = parseFloat(S.$numberDouble);
            return Q && Q.relaxed ? H : new $e(H);
          }
          inspect(S, Q, H) {
            return H ??= d, `new Double(${H(this.value, Q)})`;
          }
        }
        class Te extends pe {
          get _bsontype() {
            return "Int32";
          }
          constructor(S) {
            super(), S instanceof Number && (S = S.valueOf()), this.value = 0 | +S;
          }
          static fromString(S) {
            const Q = Pt(S), H = Number(S);
            if (g < H) throw new ne(`Input: '${S}' is larger than the maximum value for Int32`);
            if (_ > H) throw new ne(`Input: '${S}' is smaller than the minimum value for Int32`);
            if (!Number.isSafeInteger(H)) throw new ne(`Input: '${S}' is not a safe integer`);
            if (H.toString() !== Q) throw new ne(`Input: '${S}' is not a valid Int32 string`);
            return new Te(H);
          }
          valueOf() {
            return this.value;
          }
          toString(S) {
            return this.value.toString(S);
          }
          toJSON() {
            return this.value;
          }
          toExtendedJSON(S) {
            return S && (S.relaxed || S.legacy) ? this.value : { $numberInt: this.value.toString() };
          }
          static fromExtendedJSON(S, Q) {
            return Q && Q.relaxed ? parseInt(S.$numberInt, 10) : new Te(S.$numberInt);
          }
          inspect(S, Q, H) {
            return H ??= d, `new Int32(${H(this.value, Q)})`;
          }
        }
        class Ie extends pe {
          get _bsontype() {
            return "MaxKey";
          }
          toExtendedJSON() {
            return { $maxKey: 1 };
          }
          static fromExtendedJSON() {
            return new Ie();
          }
          inspect() {
            return "new MaxKey()";
          }
        }
        class qe extends pe {
          get _bsontype() {
            return "MinKey";
          }
          toExtendedJSON() {
            return { $minKey: 1 };
          }
          static fromExtendedJSON() {
            return new qe();
          }
          inspect() {
            return "new MinKey()";
          }
        }
        let Fe = null;
        const Ne = /* @__PURE__ */ new WeakMap();
        class fe extends pe {
          get _bsontype() {
            return "ObjectId";
          }
          constructor(S) {
            let Q;
            if (super(), typeof S == "object" && S && "id" in S) {
              if (typeof S.id != "string" && !ArrayBuffer.isView(S.id)) throw new ne("Argument passed in must have an id that is of type string or Buffer");
              Q = "toHexString" in S && typeof S.toHexString == "function" ? re.fromHex(S.toHexString()) : S.id;
            } else Q = S;
            if (Q == null || typeof Q == "number") this.buffer = fe.generate(typeof Q == "number" ? Q : void 0);
            else if (ArrayBuffer.isView(Q) && Q.byteLength === 12) this.buffer = re.toLocalBufferType(Q);
            else {
              if (typeof Q != "string") throw new ne("Argument passed in does not match the accepted types");
              if (!fe.validateHexString(Q)) throw new ne("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
              this.buffer = re.fromHex(Q), fe.cacheHexString && Ne.set(this, Q);
            }
          }
          get id() {
            return this.buffer;
          }
          set id(S) {
            this.buffer = S, fe.cacheHexString && Ne.set(this, re.toHex(S));
          }
          static validateHexString(S) {
            if (S?.length !== 24) return !1;
            for (let Q = 0; Q < 24; Q++) {
              const H = S.charCodeAt(Q);
              if (!(H >= 48 && H <= 57 || H >= 97 && H <= 102 || H >= 65 && H <= 70)) return !1;
            }
            return !0;
          }
          toHexString() {
            if (fe.cacheHexString) {
              const Q = Ne.get(this);
              if (Q) return Q;
            }
            const S = re.toHex(this.id);
            return fe.cacheHexString && Ne.set(this, S), S;
          }
          static getInc() {
            return fe.index = (fe.index + 1) % 16777215;
          }
          static generate(S) {
            typeof S != "number" && (S = Math.floor(Date.now() / 1e3));
            const Q = fe.getInc(), H = re.allocateUnsafe(12);
            return Ue.setInt32BE(H, 0, S), Fe === null && (Fe = re.randomBytes(5)), H[4] = Fe[0], H[5] = Fe[1], H[6] = Fe[2], H[7] = Fe[3], H[8] = Fe[4], H[11] = 255 & Q, H[10] = Q >> 8 & 255, H[9] = Q >> 16 & 255, H;
          }
          toString(S) {
            return S === "base64" ? re.toBase64(this.id) : this.toHexString();
          }
          toJSON() {
            return this.toHexString();
          }
          static is(S) {
            return S != null && typeof S == "object" && "_bsontype" in S && S._bsontype === "ObjectId";
          }
          equals(S) {
            if (S == null) return !1;
            if (fe.is(S)) return this.buffer[11] === S.buffer[11] && re.equals(this.buffer, S.buffer);
            if (typeof S == "string") return S.toLowerCase() === this.toHexString();
            if (typeof S == "object" && typeof S.toHexString == "function") {
              const Q = S.toHexString(), H = this.toHexString();
              return typeof Q == "string" && Q.toLowerCase() === H;
            }
            return !1;
          }
          getTimestamp() {
            const S = /* @__PURE__ */ new Date(), Q = Ue.getUint32BE(this.buffer, 0);
            return S.setTime(1e3 * Math.floor(Q)), S;
          }
          static createPk() {
            return new fe();
          }
          serializeInto(S, Q) {
            return S[Q] = this.buffer[0], S[Q + 1] = this.buffer[1], S[Q + 2] = this.buffer[2], S[Q + 3] = this.buffer[3], S[Q + 4] = this.buffer[4], S[Q + 5] = this.buffer[5], S[Q + 6] = this.buffer[6], S[Q + 7] = this.buffer[7], S[Q + 8] = this.buffer[8], S[Q + 9] = this.buffer[9], S[Q + 10] = this.buffer[10], S[Q + 11] = this.buffer[11], 12;
          }
          static createFromTime(S) {
            const Q = re.allocate(12);
            for (let H = 11; H >= 4; H--) Q[H] = 0;
            return Ue.setInt32BE(Q, 0, S), new fe(Q);
          }
          static createFromHexString(S) {
            if (S?.length !== 24) throw new ne("hex string must be 24 characters");
            return new fe(re.fromHex(S));
          }
          static createFromBase64(S) {
            if (S?.length !== 16) throw new ne("base64 string must be 16 characters");
            return new fe(re.fromBase64(S));
          }
          static isValid(S) {
            if (S == null) return !1;
            if (typeof S == "string") return fe.validateHexString(S);
            try {
              return new fe(S), !0;
            } catch {
              return !1;
            }
          }
          toExtendedJSON() {
            return this.toHexString ? { $oid: this.toHexString() } : { $oid: this.toString("hex") };
          }
          static fromExtendedJSON(S) {
            return new fe(S.$oid);
          }
          isCached() {
            return fe.cacheHexString && Ne.has(this);
          }
          inspect(S, Q, H) {
            return H ??= d, `new ObjectId(${H(this.toHexString(), Q)})`;
          }
        }
        function Pe(C, S, Q) {
          let H = 5;
          if (Array.isArray(C)) for (let Se = 0; Se < C.length; Se++) H += De(Se.toString(), C[Se], S, !0, Q);
          else {
            typeof C?.toBSON == "function" && (C = C.toBSON());
            for (const Se of Object.keys(C)) H += De(Se, C[Se], S, !1, Q);
          }
          return H;
        }
        function De(C, S, Q = !1, H = !1, Se = !1) {
          switch (typeof S?.toBSON == "function" && (S = S.toBSON()), typeof S) {
            case "string":
              return 1 + re.utf8ByteLength(C) + 1 + 4 + re.utf8ByteLength(S) + 1;
            case "number":
              return Math.floor(S) === S && S >= E && S <= A && S >= _ && S <= g ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + 5 : (C != null ? re.utf8ByteLength(C) + 1 : 0) + 9;
            case "undefined":
              return H || !Se ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 : 0;
            case "boolean":
              return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 2;
            case "object":
              if (S != null && typeof S._bsontype == "string" && S[m] !== v) throw new he();
              if (S == null || S._bsontype === "MinKey" || S._bsontype === "MaxKey") return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1;
              if (S._bsontype === "ObjectId") return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 13;
              if (S instanceof Date || l(S)) return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 9;
              if (ArrayBuffer.isView(S) || S instanceof ArrayBuffer || h(S)) return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 6 + S.byteLength;
              if (S._bsontype === "Long" || S._bsontype === "Double" || S._bsontype === "Timestamp") return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 9;
              if (S._bsontype === "Decimal128") return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 17;
              if (S._bsontype === "Code") return S.scope != null && Object.keys(S.scope).length > 0 ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 + 4 + 4 + re.utf8ByteLength(S.code.toString()) + 1 + Pe(S.scope, Q, Se) : (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 + 4 + re.utf8ByteLength(S.code.toString()) + 1;
              if (S._bsontype === "Binary") {
                const Oe = S;
                return Oe.sub_type === Ae.SUBTYPE_BYTE_ARRAY ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + (Oe.position + 1 + 4 + 1 + 4) : (C != null ? re.utf8ByteLength(C) + 1 : 0) + (Oe.position + 1 + 4 + 1);
              }
              if (S._bsontype === "Symbol") return (C != null ? re.utf8ByteLength(C) + 1 : 0) + re.utf8ByteLength(S.value) + 4 + 1 + 1;
              if (S._bsontype === "DBRef") {
                const Oe = Object.assign({ $ref: S.collection, $id: S.oid }, S.fields);
                return S.db != null && (Oe.$db = S.db), (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 + Pe(Oe, Q, Se);
              }
              return S instanceof RegExp || y(S) ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 + re.utf8ByteLength(S.source) + 1 + (S.global ? 1 : 0) + (S.ignoreCase ? 1 : 0) + (S.multiline ? 1 : 0) + 1 : S._bsontype === "BSONRegExp" ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 + re.utf8ByteLength(S.pattern) + 1 + re.utf8ByteLength(S.options) + 1 : (C != null ? re.utf8ByteLength(C) + 1 : 0) + Pe(S, Q, Se) + 1;
            case "function":
              return Q ? (C != null ? re.utf8ByteLength(C) + 1 : 0) + 1 + 4 + re.utf8ByteLength(S.toString()) + 1 : 0;
            case "bigint":
              return (C != null ? re.utf8ByteLength(C) + 1 : 0) + 9;
            case "symbol":
              return 0;
            default:
              throw new ne("Unrecognized JS type: " + typeof S);
          }
        }
        fe.index = Math.floor(16777215 * Math.random());
        class We extends pe {
          get _bsontype() {
            return "BSONRegExp";
          }
          constructor(S, Q) {
            if (super(), this.pattern = S, this.options = (Q ?? "").split("").sort().join(""), this.pattern.indexOf("\0") !== -1) throw new ne(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
            if (this.options.indexOf("\0") !== -1) throw new ne(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
            for (let H = 0; H < this.options.length; H++) if (this.options[H] !== "i" && this.options[H] !== "m" && this.options[H] !== "x" && this.options[H] !== "l" && this.options[H] !== "s" && this.options[H] !== "u") throw new ne(`The regular expression option [${this.options[H]}] is not supported`);
          }
          static parseOptions(S) {
            return S ? S.split("").sort().join("") : "";
          }
          toExtendedJSON(S) {
            return (S = S || {}).legacy ? { $regex: this.pattern, $options: this.options } : { $regularExpression: { pattern: this.pattern, options: this.options } };
          }
          static fromExtendedJSON(S) {
            if ("$regex" in S) {
              if (typeof S.$regex == "string") return new We(S.$regex, We.parseOptions(S.$options));
              if (S.$regex._bsontype === "BSONRegExp") return S;
            }
            if ("$regularExpression" in S) return new We(S.$regularExpression.pattern, We.parseOptions(S.$regularExpression.options));
            throw new ne(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(S)}`);
          }
          inspect(S, Q, H) {
            const Se = (function(Oe) {
              if (Oe != null && typeof Oe == "object" && "stylize" in Oe && typeof Oe.stylize == "function") return Oe.stylize;
            })(Q) ?? ((Oe) => Oe);
            return H ??= d, `new BSONRegExp(${Se(H(this.pattern), "regexp")}, ${Se(H(this.options), "regexp")})`;
          }
        }
        class Qe extends pe {
          get _bsontype() {
            return "BSONSymbol";
          }
          constructor(S) {
            super(), this.value = S;
          }
          valueOf() {
            return this.value;
          }
          toString() {
            return this.value;
          }
          toJSON() {
            return this.value;
          }
          toExtendedJSON() {
            return { $symbol: this.value };
          }
          static fromExtendedJSON(S) {
            return new Qe(S.$symbol);
          }
          inspect(S, Q, H) {
            return H ??= d, `new BSONSymbol(${H(this.value, Q)})`;
          }
        }
        const rt = je;
        class ot extends rt {
          get _bsontype() {
            return "Timestamp";
          }
          get i() {
            return this.low >>> 0;
          }
          get t() {
            return this.high >>> 0;
          }
          constructor(S) {
            if (S == null) super(0, 0, !0);
            else if (typeof S == "bigint") super(S, !0);
            else if (je.isLong(S)) super(S.low, S.high, !0);
            else {
              if (typeof S != "object" || !("t" in S) || !("i" in S)) throw new ne("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
              {
                if (typeof S.t != "number" && (typeof S.t != "object" || S.t._bsontype !== "Int32")) throw new ne("Timestamp constructed from { t, i } must provide t as a number");
                if (typeof S.i != "number" && (typeof S.i != "object" || S.i._bsontype !== "Int32")) throw new ne("Timestamp constructed from { t, i } must provide i as a number");
                const Q = Number(S.t), H = Number(S.i);
                if (Q < 0 || Number.isNaN(Q)) throw new ne("Timestamp constructed from { t, i } must provide a positive t");
                if (H < 0 || Number.isNaN(H)) throw new ne("Timestamp constructed from { t, i } must provide a positive i");
                if (Q > 4294967295) throw new ne("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
                if (H > 4294967295) throw new ne("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
                super(H, Q, !0);
              }
            }
          }
          toJSON() {
            return { $timestamp: this.toString() };
          }
          static fromInt(S) {
            return new ot(je.fromInt(S, !0));
          }
          static fromNumber(S) {
            return new ot(je.fromNumber(S, !0));
          }
          static fromBits(S, Q) {
            return new ot({ i: S, t: Q });
          }
          static fromString(S, Q) {
            return new ot(je.fromString(S, !0, Q));
          }
          toExtendedJSON() {
            return { $timestamp: { t: this.t, i: this.i } };
          }
          static fromExtendedJSON(S) {
            const Q = je.isLong(S.$timestamp.i) ? S.$timestamp.i.getLowBitsUnsigned() : S.$timestamp.i, H = je.isLong(S.$timestamp.t) ? S.$timestamp.t.getLowBitsUnsigned() : S.$timestamp.t;
            return new ot({ t: H, i: Q });
          }
          inspect(S, Q, H) {
            return H ??= d, `new Timestamp({ t: ${H(this.t, Q)}, i: ${H(this.i, Q)} })`;
          }
        }
        ot.MAX_VALUE = je.MAX_UNSIGNED_VALUE;
        const Ot = je.fromNumber(A), Lt = je.fromNumber(E);
        function _t(C, S, Q) {
          const H = (S = S ?? {}) && S.index ? S.index : 0, Se = Ue.getInt32LE(C, H);
          if (Se < 5) throw new ne(`bson size must be >= 5, is ${Se}`);
          if (S.allowObjectSmallerThanBufferSize && C.length < Se) throw new ne(`buffer length ${C.length} must be >= bson size ${Se}`);
          if (!S.allowObjectSmallerThanBufferSize && C.length !== Se) throw new ne(`buffer length ${C.length} must === bson size ${Se}`);
          if (Se + H > C.byteLength) throw new ne(`(bson size ${Se} + options.index ${H} must be <= buffer length ${C.byteLength})`);
          if (C[H + Se - 1] !== 0) throw new ne("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
          return zt(C, H, S, Q);
        }
        const St = /^\$ref$|^\$id$|^\$db$/;
        function zt(C, S, Q, H = !1) {
          const Se = Q.fieldsAsRaw == null ? null : Q.fieldsAsRaw, Oe = Q.raw != null && Q.raw, Ve = typeof Q.bsonRegExp == "boolean" && Q.bsonRegExp, Ze = Q.promoteBuffers ?? !1, ke = Q.promoteLongs ?? !0, ut = Q.promoteValues ?? !0, Xe = Q.useBigInt64 ?? !1;
          if (Xe && !ut) throw new ne("Must either request bigint or Long for int64 deserialization");
          if (Xe && !ke) throw new ne("Must either request bigint or Long for int64 deserialization");
          let Be, Ye, ht = !0;
          const mt = (Q.validation == null ? { utf8: !0 } : Q.validation).utf8;
          if (typeof mt == "boolean") Be = mt;
          else {
            ht = !1;
            const st = Object.keys(mt).map(function(wt) {
              return mt[wt];
            });
            if (st.length === 0) throw new ne("UTF-8 validation setting cannot be empty");
            if (typeof st[0] != "boolean") throw new ne("Invalid UTF-8 validation option, must specify boolean values");
            if (Be = st[0], !st.every((wt) => wt === Be)) throw new ne("Invalid UTF-8 validation option - keys must be all true or all false");
          }
          if (!ht) {
            Ye = /* @__PURE__ */ new Set();
            for (const st of Object.keys(mt)) Ye.add(st);
          }
          const Zt = S;
          if (C.length < 5) throw new ne("corrupt bson message < 5 bytes long");
          const sr = Ue.getInt32LE(C, S);
          if (S += 4, sr < 5 || sr > C.length) throw new ne("corrupt bson message");
          const ur = H ? [] : {};
          let Nr = 0, cr = !H && null;
          for (; ; ) {
            const st = C[S++];
            if (st === 0) break;
            let wt = S;
            for (; C[wt] !== 0 && wt < C.length; ) wt++;
            if (wt >= C.byteLength) throw new ne("Bad BSON Document: illegal CString");
            const ri = H ? Nr++ : re.toUTF8(C, S, wt, !1);
            let Ht, Xr = !0;
            if (Xr = ht || Ye?.has(ri) ? Be : !Be, cr !== !1 && ri[0] === "$" && (cr = St.test(ri)), S = wt + 1, st === $) {
              const at = Ue.getInt32LE(C, S);
              if (S += 4, at <= 0 || at > C.length - S || C[S + at - 1] !== 0) throw new ne("bad string length in bson");
              Ht = re.toUTF8(C, S, S + at - 1, Xr), S += at;
            } else if (st === I) {
              const at = re.allocateUnsafe(12);
              for (let dt = 0; dt < 12; dt++) at[dt] = C[S + dt];
              Ht = new fe(at), S += 12;
            } else if (st === L && ut === !1) Ht = new Te(Ue.getInt32LE(C, S)), S += 4;
            else if (st === L) Ht = Ue.getInt32LE(C, S), S += 4;
            else if (st === O) Ht = Ue.getFloat64LE(C, S), S += 8, ut === !1 && (Ht = new $e(Ht));
            else if (st === W) {
              const at = Ue.getInt32LE(C, S), dt = Ue.getInt32LE(C, S + 4);
              S += 8, Ht = new Date(new je(at, dt).toNumber());
            } else if (st === z) {
              if (C[S] !== 0 && C[S] !== 1) throw new ne("illegal boolean type value");
              Ht = C[S++] === 1;
            } else if (st === k) {
              const at = S, dt = Ue.getInt32LE(C, S);
              if (dt <= 0 || dt > C.length - S) throw new ne("bad embedded document length in bson");
              if (Oe) Ht = C.subarray(S, S + dt);
              else {
                let gt = Q;
                ht || (gt = { ...Q, validation: { utf8: Xr } }), Ht = zt(C, at, gt, !1);
              }
              S += dt;
            } else if (st === j) {
              const at = S, dt = Ue.getInt32LE(C, S);
              let gt = Q;
              const Jr = S + dt;
              if (Se && Se[ri] && (gt = { ...Q, raw: !0 }), ht || (gt = { ...gt, validation: { utf8: Xr } }), Ht = zt(C, at, gt, !0), C[(S += dt) - 1] !== 0) throw new ne("invalid array terminator byte");
              if (S !== Jr) throw new ne("corrupted array bson");
            } else if (st === R) Ht = void 0;
            else if (st === F) Ht = null;
            else if (st === N) if (Xe) Ht = Ue.getBigInt64LE(C, S), S += 8;
            else {
              const at = Ue.getInt32LE(C, S), dt = Ue.getInt32LE(C, S + 4);
              S += 8;
              const gt = new je(at, dt);
              Ht = ke && ut === !0 && gt.lessThanOrEqual(Ot) && gt.greaterThanOrEqual(Lt) ? gt.toNumber() : gt;
            }
            else if (st === Z) {
              const at = re.allocateUnsafe(16);
              for (let dt = 0; dt < 16; dt++) at[dt] = C[S + dt];
              S += 16, Ht = new _e(at);
            } else if (st === P) {
              let at = Ue.getInt32LE(C, S);
              S += 4;
              const dt = at, gt = C[S++];
              if (at < 0) throw new ne("Negative binary type element size found");
              if (at > C.byteLength) throw new ne("Binary type size larger than document size");
              if (gt === Ae.SUBTYPE_BYTE_ARRAY) {
                if (at = Ue.getInt32LE(C, S), S += 4, at < 0) throw new ne("Negative binary type element size found for subtype 0x02");
                if (at > dt - 4) throw new ne("Binary type with subtype 0x02 contains too long binary size");
                if (at < dt - 4) throw new ne("Binary type with subtype 0x02 contains too short binary size");
              }
              Ze && ut ? Ht = re.toLocalBufferType(C.subarray(S, S + at)) : (Ht = new Ae(C.subarray(S, S + at), gt), gt === de && ft.isValid(Ht) && (Ht = Ht.toUUID())), S += at;
            } else if (st === te && Ve === !1) {
              for (wt = S; C[wt] !== 0 && wt < C.length; ) wt++;
              if (wt >= C.length) throw new ne("Bad BSON Document: illegal CString");
              const at = re.toUTF8(C, S, wt, !1);
              for (wt = S = wt + 1; C[wt] !== 0 && wt < C.length; ) wt++;
              if (wt >= C.length) throw new ne("Bad BSON Document: illegal CString");
              const dt = re.toUTF8(C, S, wt, !1);
              S = wt + 1;
              const gt = new Array(dt.length);
              for (wt = 0; wt < dt.length; wt++) switch (dt[wt]) {
                case "m":
                  gt[wt] = "m";
                  break;
                case "s":
                  gt[wt] = "g";
                  break;
                case "i":
                  gt[wt] = "i";
              }
              Ht = new RegExp(at, gt.join(""));
            } else if (st === te && Ve === !0) {
              for (wt = S; C[wt] !== 0 && wt < C.length; ) wt++;
              if (wt >= C.length) throw new ne("Bad BSON Document: illegal CString");
              const at = re.toUTF8(C, S, wt, !1);
              for (wt = S = wt + 1; C[wt] !== 0 && wt < C.length; ) wt++;
              if (wt >= C.length) throw new ne("Bad BSON Document: illegal CString");
              const dt = re.toUTF8(C, S, wt, !1);
              S = wt + 1, Ht = new We(at, dt);
            } else if (st === T) {
              const at = Ue.getInt32LE(C, S);
              if (S += 4, at <= 0 || at > C.length - S || C[S + at - 1] !== 0) throw new ne("bad string length in bson");
              const dt = re.toUTF8(C, S, S + at - 1, Xr);
              Ht = ut ? dt : new Qe(dt), S += at;
            } else if (st === M) Ht = new ot({ i: Ue.getUint32LE(C, S), t: Ue.getUint32LE(C, S + 4) }), S += 8;
            else if (st === Y) Ht = new qe();
            else if (st === ie) Ht = new Ie();
            else if (st === V) {
              const at = Ue.getInt32LE(C, S);
              if (S += 4, at <= 0 || at > C.length - S || C[S + at - 1] !== 0) throw new ne("bad string length in bson");
              const dt = re.toUTF8(C, S, S + at - 1, Xr);
              Ht = new Ke(dt), S += at;
            } else if (st === D) {
              const at = Ue.getInt32LE(C, S);
              if (S += 4, at < 13) throw new ne("code_w_scope total size shorter minimum expected length");
              const dt = Ue.getInt32LE(C, S);
              if (S += 4, dt <= 0 || dt > C.length - S || C[S + dt - 1] !== 0) throw new ne("bad string length in bson");
              const gt = re.toUTF8(C, S, S + dt - 1, Xr), Jr = S += dt, Fr = Ue.getInt32LE(C, S), Lr = zt(C, Jr, Q, !1);
              if (S += Fr, at < 8 + Fr + dt) throw new ne("code_w_scope total size is too short, truncating scope");
              if (at > 8 + Fr + dt) throw new ne("code_w_scope total size is too long, clips outer document");
              Ht = new Ke(gt, Lr);
            } else {
              if (st !== ee) throw new ne(`Detected unknown BSON type ${st.toString(16)} for fieldname "${ri}"`);
              {
                const at = Ue.getInt32LE(C, S);
                if (S += 4, at <= 0 || at > C.length - S || C[S + at - 1] !== 0) throw new ne("bad string length in bson");
                const dt = re.toUTF8(C, S, S + at - 1, Xr);
                S += at;
                const gt = re.allocateUnsafe(12);
                for (let Fr = 0; Fr < 12; Fr++) gt[Fr] = C[S + Fr];
                const Jr = new fe(gt);
                S += 12, Ht = new $t(dt, Jr);
              }
            }
            ri === "__proto__" ? Object.defineProperty(ur, ri, { value: Ht, writable: !0, enumerable: !0, configurable: !0 }) : ur[ri] = Ht;
          }
          if (sr !== S - Zt)
            throw H ? new ne("corrupt array bson") : new ne("corrupt object bson");
          if (!cr) return ur;
          if (Xt(ur)) {
            const st = Object.assign({}, ur);
            return delete st.$ref, delete st.$id, delete st.$db, new $t(ur.$ref, ur.$id, ur.$db, st);
          }
          return ur;
        }
        const Et = /\x00/, Nt = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
        function wr(C, S, Q, H) {
          C[H++] = $, C[(H = H + re.encodeUTF8Into(C, S, H) + 1) - 1] = 0;
          const Se = re.encodeUTF8Into(C, Q, H + 4);
          return Ue.setInt32LE(C, H, Se + 1), H = H + 4 + Se, C[H++] = 0, H;
        }
        function fr(C, S, Q, H) {
          const Se = !Object.is(Q, -0) && Number.isSafeInteger(Q) && Q <= g && Q >= _ ? L : O;
          return C[H++] = Se, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H + (Se === L ? Ue.setInt32LE(C, H, Q) : Ue.setFloat64LE(C, H, Q));
        }
        function At(C, S, Q, H) {
          return C[H++] = N, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H + Ue.setBigInt64LE(C, H, Q);
        }
        function Yt(C, S, Q, H) {
          return C[H++] = F, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H;
        }
        function He(C, S, Q, H) {
          return C[H++] = z, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, C[H++] = Q ? 1 : 0, H;
        }
        function kt(C, S, Q, H) {
          C[H++] = W, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const Se = je.fromNumber(Q.getTime()), Oe = Se.getLowBits(), Ve = Se.getHighBits();
          return (H += Ue.setInt32LE(C, H, Oe)) + Ue.setInt32LE(C, H, Ve);
        }
        function Gt(C, S, Q, H) {
          if (C[H++] = te, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, Q.source && Q.source.match(Et) != null) throw new ne("value " + Q.source + " must not contain null bytes");
          return H += re.encodeUTF8Into(C, Q.source, H), C[H++] = 0, Q.ignoreCase && (C[H++] = 105), Q.global && (C[H++] = 115), Q.multiline && (C[H++] = 109), C[H++] = 0, H;
        }
        function Bt(C, S, Q, H) {
          if (C[H++] = te, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, Q.pattern.match(Et) != null) throw new ne("pattern " + Q.pattern + " must not contain null bytes");
          H += re.encodeUTF8Into(C, Q.pattern, H), C[H++] = 0;
          const Se = Q.options.split("").sort().join("");
          return H += re.encodeUTF8Into(C, Se, H), C[H++] = 0, H;
        }
        function Kt(C, S, Q, H) {
          return Q === null ? C[H++] = F : Q._bsontype === "MinKey" ? C[H++] = Y : C[H++] = ie, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H;
        }
        function Kr(C, S, Q, H) {
          return C[H++] = I, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H + Q.serializeInto(C, H);
        }
        function Ar(C, S, Q, H) {
          C[H++] = P, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const Se = Q.length;
          if (H += Ue.setInt32LE(C, H, Se), C[H++] = le, Se <= 16) for (let Oe = 0; Oe < Se; Oe++) C[H + Oe] = Q[Oe];
          else C.set(Q, H);
          return H + Se;
        }
        function Sn(C, S, Q, H, Se, Oe, Ve, Ze, ke) {
          if (ke.has(Q)) throw new ne("Cannot convert circular structure to BSON");
          ke.add(Q), C[H++] = Array.isArray(Q) ? j : k, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const ut = Hr(C, Q, Se, H, Oe + 1, Ve, Ze, ke);
          return ke.delete(Q), ut;
        }
        function cn(C, S, Q, H) {
          C[H++] = Z, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          for (let Se = 0; Se < 16; Se++) C[H + Se] = Q.bytes[Se];
          return H + 16;
        }
        function En(C, S, Q, H) {
          C[H++] = Q._bsontype === "Long" ? N : M, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const Se = Q.getLowBits(), Oe = Q.getHighBits();
          return (H += Ue.setInt32LE(C, H, Se)) + Ue.setInt32LE(C, H, Oe);
        }
        function vn(C, S, Q, H) {
          return Q = Q.valueOf(), C[H++] = L, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H + Ue.setInt32LE(C, H, Q);
        }
        function nr(C, S, Q, H) {
          return C[H++] = O, H += re.encodeUTF8Into(C, S, H), C[H++] = 0, H + Ue.setFloat64LE(C, H, Q.value);
        }
        function Ir(C, S, Q, H) {
          C[H++] = V, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const Se = Q.toString(), Oe = re.encodeUTF8Into(C, Se, H + 4) + 1;
          return Ue.setInt32LE(C, H, Oe), H = H + 4 + Oe - 1, C[H++] = 0, H;
        }
        function Or(C, S, Q, H, Se = !1, Oe = 0, Ve = !1, Ze = !0, ke) {
          if (Q.scope && typeof Q.scope == "object") {
            C[H++] = D, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
            let ut = H;
            const Xe = Q.code;
            H += 4;
            const Be = re.encodeUTF8Into(C, Xe, H + 4) + 1;
            Ue.setInt32LE(C, H, Be), C[H + 4 + Be - 1] = 0, H = H + Be + 4;
            const Ye = Hr(C, Q.scope, Se, H, Oe + 1, Ve, Ze, ke);
            H = Ye - 1;
            const ht = Ye - ut;
            ut += Ue.setInt32LE(C, ut, ht), C[H++] = 0;
          } else {
            C[H++] = V, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
            const ut = Q.code.toString(), Xe = re.encodeUTF8Into(C, ut, H + 4) + 1;
            Ue.setInt32LE(C, H, Xe), H = H + 4 + Xe - 1, C[H++] = 0;
          }
          return H;
        }
        function Tr(C, S, Q, H) {
          C[H++] = P, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const Se = Q.buffer;
          let Oe = Q.position;
          if (Q.sub_type === Ae.SUBTYPE_BYTE_ARRAY && (Oe += 4), H += Ue.setInt32LE(C, H, Oe), C[H++] = Q.sub_type, Q.sub_type === Ae.SUBTYPE_BYTE_ARRAY && (Oe -= 4, H += Ue.setInt32LE(C, H, Oe)), Q.sub_type === Ae.SUBTYPE_VECTOR && Me(Q), Oe <= 16) for (let Ve = 0; Ve < Oe; Ve++) C[H + Ve] = Se[Ve];
          else C.set(Se, H);
          return H + Q.position;
        }
        function rr(C, S, Q, H) {
          C[H++] = T, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          const Se = re.encodeUTF8Into(C, Q.value, H + 4) + 1;
          return Ue.setInt32LE(C, H, Se), H = H + 4 + Se - 1, C[H++] = 0, H;
        }
        function yr(C, S, Q, H, Se, Oe, Ve) {
          C[H++] = k, H += re.encodeUTF8Into(C, S, H), C[H++] = 0;
          let Ze = H, ke = { $ref: Q.collection || Q.namespace, $id: Q.oid };
          Q.db != null && (ke.$db = Q.db), ke = Object.assign(ke, Q.fields);
          const ut = Hr(C, ke, !1, H, Se + 1, Oe, !0, Ve), Xe = ut - Ze;
          return Ze += Ue.setInt32LE(C, H, Xe), ut;
        }
        function Hr(C, S, Q, H, Se, Oe, Ve, Ze) {
          if (Ze == null) {
            if (S == null) return C[0] = 5, C[1] = 0, C[2] = 0, C[3] = 0, C[4] = 0, 5;
            if (Array.isArray(S)) throw new ne("serialize does not support an array as the root input");
            if (typeof S != "object") throw new ne("serialize does not support non-object as the root input");
            if ("_bsontype" in S && typeof S._bsontype == "string") throw new ne("BSON types cannot be serialized as a document");
            if (l(S) || y(S) || f(S) || h(S)) throw new ne("date, regexp, typedarray, and arraybuffer cannot be BSON documents");
            Ze = /* @__PURE__ */ new Set();
          }
          Ze.add(S);
          let ke = H + 4;
          if (Array.isArray(S)) for (let Xe = 0; Xe < S.length; Xe++) {
            const Be = `${Xe}`;
            let Ye = S[Xe];
            typeof Ye?.toBSON == "function" && (Ye = Ye.toBSON());
            const ht = typeof Ye;
            if (Ye === void 0) ke = Yt(C, Be, 0, ke);
            else if (Ye === null) ke = Yt(C, Be, 0, ke);
            else if (ht === "string") ke = wr(C, Be, Ye, ke);
            else if (ht === "number") ke = fr(C, Be, Ye, ke);
            else if (ht === "bigint") ke = At(C, Be, Ye, ke);
            else if (ht === "boolean") ke = He(C, Be, Ye, ke);
            else if (ht === "object" && Ye._bsontype == null) ke = Ye instanceof Date || l(Ye) ? kt(C, Be, Ye, ke) : Ye instanceof Uint8Array || f(Ye) ? Ar(C, Be, Ye, ke) : Ye instanceof RegExp || y(Ye) ? Gt(C, Be, Ye, ke) : Sn(C, Be, Ye, ke, Q, Se, Oe, Ve, Ze);
            else if (ht === "object") {
              if (Ye[m] !== v) throw new he();
              if (Ye._bsontype === "ObjectId") ke = Kr(C, Be, Ye, ke);
              else if (Ye._bsontype === "Decimal128") ke = cn(C, Be, Ye, ke);
              else if (Ye._bsontype === "Long" || Ye._bsontype === "Timestamp") ke = En(C, Be, Ye, ke);
              else if (Ye._bsontype === "Double") ke = nr(C, Be, Ye, ke);
              else if (Ye._bsontype === "Code") ke = Or(C, Be, Ye, ke, Q, Se, Oe, Ve, Ze);
              else if (Ye._bsontype === "Binary") ke = Tr(C, Be, Ye, ke);
              else if (Ye._bsontype === "BSONSymbol") ke = rr(C, Be, Ye, ke);
              else if (Ye._bsontype === "DBRef") ke = yr(C, Be, Ye, ke, Se, Oe, Ze);
              else if (Ye._bsontype === "BSONRegExp") ke = Bt(C, Be, Ye, ke);
              else if (Ye._bsontype === "Int32") ke = vn(C, Be, Ye, ke);
              else if (Ye._bsontype === "MinKey" || Ye._bsontype === "MaxKey") ke = Kt(C, Be, Ye, ke);
              else if (Ye._bsontype !== void 0) throw new ne(`Unrecognized or invalid _bsontype: ${String(Ye._bsontype)}`);
            } else ht === "function" && Oe && (ke = Ir(C, Be, Ye, ke));
          }
          else if (S instanceof Map || p(S)) {
            const Xe = S.entries();
            let Be = !1;
            for (; !Be; ) {
              const Ye = Xe.next();
              if (Be = !!Ye.done, Be) continue;
              const ht = Ye.value ? Ye.value[0] : void 0;
              let mt = Ye.value ? Ye.value[1] : void 0;
              typeof mt?.toBSON == "function" && (mt = mt.toBSON());
              const Zt = typeof mt;
              if (typeof ht == "string" && !Nt.has(ht)) {
                if (ht.match(Et) != null) throw new ne("key " + ht + " must not contain null bytes");
                if (Q) {
                  if (ht[0] === "$") throw new ne("key " + ht + " must not start with '$'");
                  if (ht.includes(".")) throw new ne("key " + ht + " must not contain '.'");
                }
              }
              if (mt === void 0) Ve === !1 && (ke = Yt(C, ht, 0, ke));
              else if (mt === null) ke = Yt(C, ht, 0, ke);
              else if (Zt === "string") ke = wr(C, ht, mt, ke);
              else if (Zt === "number") ke = fr(C, ht, mt, ke);
              else if (Zt === "bigint") ke = At(C, ht, mt, ke);
              else if (Zt === "boolean") ke = He(C, ht, mt, ke);
              else if (Zt === "object" && mt._bsontype == null) ke = mt instanceof Date || l(mt) ? kt(C, ht, mt, ke) : mt instanceof Uint8Array || f(mt) ? Ar(C, ht, mt, ke) : mt instanceof RegExp || y(mt) ? Gt(C, ht, mt, ke) : Sn(C, ht, mt, ke, Q, Se, Oe, Ve, Ze);
              else if (Zt === "object") {
                if (mt[m] !== v) throw new he();
                if (mt._bsontype === "ObjectId") ke = Kr(C, ht, mt, ke);
                else if (mt._bsontype === "Decimal128") ke = cn(C, ht, mt, ke);
                else if (mt._bsontype === "Long" || mt._bsontype === "Timestamp") ke = En(C, ht, mt, ke);
                else if (mt._bsontype === "Double") ke = nr(C, ht, mt, ke);
                else if (mt._bsontype === "Code") ke = Or(C, ht, mt, ke, Q, Se, Oe, Ve, Ze);
                else if (mt._bsontype === "Binary") ke = Tr(C, ht, mt, ke);
                else if (mt._bsontype === "BSONSymbol") ke = rr(C, ht, mt, ke);
                else if (mt._bsontype === "DBRef") ke = yr(C, ht, mt, ke, Se, Oe, Ze);
                else if (mt._bsontype === "BSONRegExp") ke = Bt(C, ht, mt, ke);
                else if (mt._bsontype === "Int32") ke = vn(C, ht, mt, ke);
                else if (mt._bsontype === "MinKey" || mt._bsontype === "MaxKey") ke = Kt(C, ht, mt, ke);
                else if (mt._bsontype !== void 0) throw new ne(`Unrecognized or invalid _bsontype: ${String(mt._bsontype)}`);
              } else Zt === "function" && Oe && (ke = Ir(C, ht, mt, ke));
            }
          } else {
            if (typeof S?.toBSON == "function" && (S = S.toBSON()) != null && typeof S != "object") throw new ne("toBSON function did not return an object");
            for (const Xe of Object.keys(S)) {
              let Be = S[Xe];
              typeof Be?.toBSON == "function" && (Be = Be.toBSON());
              const Ye = typeof Be;
              if (typeof Xe == "string" && !Nt.has(Xe)) {
                if (Xe.match(Et) != null) throw new ne("key " + Xe + " must not contain null bytes");
                if (Q) {
                  if (Xe[0] === "$") throw new ne("key " + Xe + " must not start with '$'");
                  if (Xe.includes(".")) throw new ne("key " + Xe + " must not contain '.'");
                }
              }
              if (Be === void 0) Ve === !1 && (ke = Yt(C, Xe, 0, ke));
              else if (Be === null) ke = Yt(C, Xe, 0, ke);
              else if (Ye === "string") ke = wr(C, Xe, Be, ke);
              else if (Ye === "number") ke = fr(C, Xe, Be, ke);
              else if (Ye === "bigint") ke = At(C, Xe, Be, ke);
              else if (Ye === "boolean") ke = He(C, Xe, Be, ke);
              else if (Ye === "object" && Be._bsontype == null) ke = Be instanceof Date || l(Be) ? kt(C, Xe, Be, ke) : Be instanceof Uint8Array || f(Be) ? Ar(C, Xe, Be, ke) : Be instanceof RegExp || y(Be) ? Gt(C, Xe, Be, ke) : Sn(C, Xe, Be, ke, Q, Se, Oe, Ve, Ze);
              else if (Ye === "object") {
                if (Be[m] !== v) throw new he();
                if (Be._bsontype === "ObjectId") ke = Kr(C, Xe, Be, ke);
                else if (Be._bsontype === "Decimal128") ke = cn(C, Xe, Be, ke);
                else if (Be._bsontype === "Long" || Be._bsontype === "Timestamp") ke = En(C, Xe, Be, ke);
                else if (Be._bsontype === "Double") ke = nr(C, Xe, Be, ke);
                else if (Be._bsontype === "Code") ke = Or(C, Xe, Be, ke, Q, Se, Oe, Ve, Ze);
                else if (Be._bsontype === "Binary") ke = Tr(C, Xe, Be, ke);
                else if (Be._bsontype === "BSONSymbol") ke = rr(C, Xe, Be, ke);
                else if (Be._bsontype === "DBRef") ke = yr(C, Xe, Be, ke, Se, Oe, Ze);
                else if (Be._bsontype === "BSONRegExp") ke = Bt(C, Xe, Be, ke);
                else if (Be._bsontype === "Int32") ke = vn(C, Xe, Be, ke);
                else if (Be._bsontype === "MinKey" || Be._bsontype === "MaxKey") ke = Kt(C, Xe, Be, ke);
                else if (Be._bsontype !== void 0) throw new ne(`Unrecognized or invalid _bsontype: ${String(Be._bsontype)}`);
              } else Ye === "function" && Oe && (ke = Ir(C, Xe, Be, ke));
            }
          }
          Ze.delete(S), C[ke++] = 0;
          const ut = ke - H;
          return H += Ue.setInt32LE(C, H, ut), ke;
        }
        const pt = { $oid: fe, $binary: Ae, $uuid: Ae, $symbol: Qe, $numberInt: Te, $numberDecimal: _e, $numberDouble: $e, $numberLong: je, $minKey: qe, $maxKey: Ie, $regex: We, $regularExpression: We, $timestamp: ot };
        function hr(C, S = {}) {
          if (typeof C == "number") {
            const H = C <= g && C >= _, Se = C <= b && C >= w;
            if (S.relaxed || S.legacy) return C;
            if (Number.isInteger(C) && !Object.is(C, -0)) {
              if (H) return new Te(C);
              if (Se) return S.useBigInt64 ? BigInt(C) : je.fromNumber(C);
            }
            return new $e(C);
          }
          if (C == null || typeof C != "object") return C;
          if (C.$undefined) return null;
          const Q = Object.keys(C).filter((H) => H.startsWith("$") && C[H] != null);
          for (let H = 0; H < Q.length; H++) {
            const Se = pt[Q[H]];
            if (Se) return Se.fromExtendedJSON(C, S);
          }
          if (C.$date != null) {
            const H = C.$date, Se = /* @__PURE__ */ new Date();
            if (S.legacy) if (typeof H == "number") Se.setTime(H);
            else if (typeof H == "string") Se.setTime(Date.parse(H));
            else {
              if (typeof H != "bigint") throw new x("Unrecognized type for EJSON date: " + typeof H);
              Se.setTime(Number(H));
            }
            else if (typeof H == "string") Se.setTime(Date.parse(H));
            else if (je.isLong(H)) Se.setTime(H.toNumber());
            else if (typeof H == "number" && S.relaxed) Se.setTime(H);
            else {
              if (typeof H != "bigint") throw new x("Unrecognized type for EJSON date: " + typeof H);
              Se.setTime(Number(H));
            }
            return Se;
          }
          if (C.$code != null) {
            const H = Object.assign({}, C);
            return C.$scope && (H.$scope = hr(C.$scope)), Ke.fromExtendedJSON(C);
          }
          if (Xt(C) || C.$dbPointer) {
            const H = C.$ref ? C : C.$dbPointer;
            if (H instanceof $t) return H;
            const Se = Object.keys(H).filter((Ve) => Ve.startsWith("$"));
            let Oe = !0;
            if (Se.forEach((Ve) => {
              ["$ref", "$id", "$db"].indexOf(Ve) === -1 && (Oe = !1);
            }), Oe) return $t.fromExtendedJSON(H);
          }
          return C;
        }
        function ar(C) {
          const S = C.toISOString();
          return C.getUTCMilliseconds() !== 0 ? S : S.slice(0, -5) + "Z";
        }
        function Qt(C, S) {
          if (C instanceof Map || p(C)) {
            const Q = /* @__PURE__ */ Object.create(null);
            for (const [H, Se] of C) {
              if (typeof H != "string") throw new ne("Can only serialize maps with string keys");
              Q[H] = Se;
            }
            return Qt(Q, S);
          }
          if ((typeof C == "object" || typeof C == "function") && C !== null) {
            const Q = S.seenObjects.findIndex((H) => H.obj === C);
            if (Q !== -1) {
              const H = S.seenObjects.map((Xe) => Xe.propertyName), Se = H.slice(0, Q).map((Xe) => `${Xe} -> `).join(""), Oe = H[Q], Ve = " -> " + H.slice(Q + 1, H.length - 1).map((Xe) => `${Xe} -> `).join(""), Ze = H[H.length - 1], ke = " ".repeat(Se.length + Oe.length / 2), ut = "-".repeat(Ve.length + (Oe.length + Ze.length) / 2 - 1);
              throw new ne(`Converting circular structure to EJSON:
    ${Se}${Oe}${Ve}${Ze}
    ${ke}\\${ut}/`);
            }
            S.seenObjects[S.seenObjects.length - 1].obj = C;
          }
          if (Array.isArray(C)) return (function(Q, H) {
            return Q.map((Se, Oe) => {
              H.seenObjects.push({ propertyName: `index ${Oe}`, obj: null });
              try {
                return Qt(Se, H);
              } finally {
                H.seenObjects.pop();
              }
            });
          })(C, S);
          if (C === void 0) return null;
          if (C instanceof Date || l(C)) {
            const Q = C.getTime(), H = Q > -1 && Q < 2534023188e5;
            return S.legacy ? S.relaxed && H ? { $date: C.getTime() } : { $date: ar(C) } : S.relaxed && H ? { $date: ar(C) } : { $date: { $numberLong: C.getTime().toString() } };
          }
          if (!(typeof C != "number" || S.relaxed && isFinite(C))) {
            if (Number.isInteger(C) && !Object.is(C, -0)) {
              if (C >= _ && C <= g) return { $numberInt: C.toString() };
              if (C >= w && C <= b) return { $numberLong: C.toString() };
            }
            return { $numberDouble: Object.is(C, -0) ? "-0.0" : C.toString() };
          }
          if (typeof C == "bigint") return S.relaxed ? Number(BigInt.asIntN(64, C)) : { $numberLong: BigInt.asIntN(64, C).toString() };
          if (C instanceof RegExp || y(C)) {
            let Q = C.flags;
            if (Q === void 0) {
              const H = C.toString().match(/[gimuy]*$/);
              H && (Q = H[0]);
            }
            return new We(C.source, Q).toExtendedJSON(S);
          }
          return C != null && typeof C == "object" ? (function(Q, H) {
            if (Q == null || typeof Q != "object") throw new ne("not an object instance");
            const Se = Q._bsontype;
            if (Se === void 0) {
              const Oe = {};
              for (const Ve of Object.keys(Q)) {
                H.seenObjects.push({ propertyName: Ve, obj: null });
                try {
                  const Ze = Qt(Q[Ve], H);
                  Ve === "__proto__" ? Object.defineProperty(Oe, Ve, { value: Ze, writable: !0, enumerable: !0, configurable: !0 }) : Oe[Ve] = Ze;
                } finally {
                  H.seenObjects.pop();
                }
              }
              return Oe;
            }
            if (Q != null && typeof Q == "object" && typeof Q._bsontype == "string" && Q[m] !== v) throw new he();
            if ((function(Oe) {
              return Oe != null && typeof Oe == "object" && "_bsontype" in Oe && typeof Oe._bsontype == "string";
            })(Q)) {
              let Oe = Q;
              if (typeof Oe.toExtendedJSON != "function") {
                const Ve = qt[Q._bsontype];
                if (!Ve) throw new ne("Unrecognized or invalid _bsontype: " + Q._bsontype);
                Oe = Ve(Oe);
              }
              return Se === "Code" && Oe.scope ? Oe = new Ke(Oe.code, Qt(Oe.scope, H)) : Se === "DBRef" && Oe.oid && (Oe = new $t(Qt(Oe.collection, H), Qt(Oe.oid, H), Qt(Oe.db, H), Qt(Oe.fields, H))), Oe.toExtendedJSON(H);
            }
            throw new ne("_bsontype must be a string, but was: " + typeof Se);
          })(C, S) : C;
        }
        const qt = { Binary: (C) => new Ae(C.value(), C.sub_type), Code: (C) => new Ke(C.code, C.scope), DBRef: (C) => new $t(C.collection || C.namespace, C.oid, C.db, C.fields), Decimal128: (C) => new _e(C.bytes), Double: (C) => new $e(C.value), Int32: (C) => new Te(C.value), Long: (C) => je.fromBits(C.low != null ? C.low : C.low_, C.low != null ? C.high : C.high_, C.low != null ? C.unsigned : C.unsigned_), MaxKey: () => new Ie(), MinKey: () => new qe(), ObjectId: (C) => new fe(C), BSONRegExp: (C) => new We(C.pattern, C.options), BSONSymbol: (C) => new Qe(C.value), Timestamp: (C) => ot.fromBits(C.low, C.high) };
        function Rt(C, S) {
          const Q = { useBigInt64: S?.useBigInt64 ?? !1, relaxed: S?.relaxed ?? !0, legacy: S?.legacy ?? !1 };
          return JSON.parse(C, (H, Se) => {
            if (H.indexOf("\0") !== -1) throw new ne(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(H)}`);
            return hr(Se, Q);
          });
        }
        function Ur(C, S, Q, H) {
          Q != null && typeof Q == "object" && (H = Q, Q = 0), S == null || typeof S != "object" || Array.isArray(S) || (H = S, S = void 0, Q = 0);
          const Se = Qt(C, Object.assign({ relaxed: !0, legacy: !1 }, H, { seenObjects: [{ propertyName: "(root)", obj: null }] }));
          return JSON.stringify(Se, S, Q);
        }
        const $r = /* @__PURE__ */ Object.create(null);
        $r.parse = Rt, $r.stringify = Ur, $r.serialize = function(C, S) {
          return S = S || {}, JSON.parse(Ur(C, S));
        }, $r.deserialize = function(C, S) {
          return S = S || {}, Rt(JSON.stringify(C), S);
        }, Object.freeze($r);
        function xn(C, S) {
          try {
            return Ue.getNonnegativeInt32LE(C, S);
          } catch (Q) {
            throw new U("BSON size cannot be negative", S, { cause: Q });
          }
        }
        function an(C, S) {
          let Q = S;
          for (; C[Q] !== 0; Q++) ;
          if (Q === C.length - 1) throw new U("Null terminator not found", S);
          return Q;
        }
        const ln = /* @__PURE__ */ Object.create(null);
        ln.parseToElements = function(C, S = 0) {
          if (S ??= 0, C.length < 5) throw new U(`Input must be at least 5 bytes, got ${C.length} bytes`, S);
          const Q = xn(C, S);
          if (Q > C.length - S) throw new U(`Parsed documentSize (${Q} bytes) does not match input length (${C.length} bytes)`, S);
          if (C[S + Q - 1] !== 0) throw new U("BSON documents must end in 0x00", S + Q);
          const H = [];
          let Se = S + 4;
          for (; Se <= Q + S; ) {
            const Oe = C[Se];
            if (Se += 1, Oe === 0) {
              if (Se - S !== Q) throw new U("Invalid 0x00 type byte", Se);
              break;
            }
            const Ve = Se, Ze = an(C, Se) - Ve;
            let ke;
            if (Se += Ze + 1, Oe === 1 || Oe === 18 || Oe === 9 || Oe === 17) ke = 8;
            else if (Oe === 16) ke = 4;
            else if (Oe === 7) ke = 12;
            else if (Oe === 19) ke = 16;
            else if (Oe === 8) ke = 1;
            else if (Oe === 10 || Oe === 6 || Oe === 127 || Oe === 255) ke = 0;
            else if (Oe === 11) ke = an(C, an(C, Se) + 1) + 1 - Se;
            else if (Oe === 3 || Oe === 4 || Oe === 15) ke = xn(C, Se);
            else {
              if (Oe !== 2 && Oe !== 5 && Oe !== 12 && Oe !== 13 && Oe !== 14) throw new U(`Invalid 0x${Oe.toString(16).padStart(2, "0")} type byte`, Se);
              ke = xn(C, Se) + 4, Oe === 5 && (ke += 1), Oe === 12 && (ke += 12);
            }
            if (ke > Q) throw new U("value reports length larger than document", Se);
            H.push([Oe, Ve, Ze, Se, ke]), Se += ke;
          }
          return H;
        }, ln.ByteUtils = re, ln.NumberUtils = Ue, Object.freeze(ln);
        const sn = 17825792;
        let Mr = re.allocate(sn);
        function bn(C) {
          Mr.length < C && (Mr = re.allocate(C));
        }
        function Ei(C, S = {}) {
          const Q = typeof S.checkKeys == "boolean" && S.checkKeys, H = typeof S.serializeFunctions == "boolean" && S.serializeFunctions, Se = typeof S.ignoreUndefined != "boolean" || S.ignoreUndefined, Oe = typeof S.minInternalBufferSize == "number" ? S.minInternalBufferSize : sn;
          Mr.length < Oe && (Mr = re.allocate(Oe));
          const Ve = Hr(Mr, C, Q, 0, 0, H, Se, null), Ze = re.allocateUnsafe(Ve);
          return Ze.set(Mr.subarray(0, Ve), 0), Ze;
        }
        function ds(C, S, Q = {}) {
          const H = typeof Q.checkKeys == "boolean" && Q.checkKeys, Se = typeof Q.serializeFunctions == "boolean" && Q.serializeFunctions, Oe = typeof Q.ignoreUndefined != "boolean" || Q.ignoreUndefined, Ve = typeof Q.index == "number" ? Q.index : 0, Ze = Hr(Mr, C, H, 0, 0, Se, Oe, null);
          return S.set(Mr.subarray(0, Ze), Ve), Ve + Ze - 1;
        }
        function Oo(C, S = {}) {
          return _t(re.toLocalBufferType(C), S);
        }
        function ra(C, S = {}) {
          return Pe(C, typeof (S = S || {}).serializeFunctions == "boolean" && S.serializeFunctions, typeof S.ignoreUndefined != "boolean" || S.ignoreUndefined);
        }
        function xi(C, S, Q, H, Se, Oe) {
          const Ve = Object.assign({ allowObjectSmallerThanBufferSize: !0, index: 0 }, Oe), Ze = re.toLocalBufferType(C);
          let ke = S;
          for (let ut = 0; ut < Q; ut++) {
            const Xe = Ue.getInt32LE(Ze, ke);
            Ve.index = ke, H[Se + ut] = _t(Ze, Ve), ke += Xe;
          }
          return ke;
        }
        var na = Object.freeze({ __proto__: null, BSONError: ne, BSONOffsetError: U, BSONRegExp: We, BSONRuntimeError: x, BSONSymbol: Qe, BSONType: ae, BSONValue: pe, BSONVersionError: he, Binary: Ae, Code: Ke, DBRef: $t, Decimal128: _e, Double: $e, EJSON: $r, Int32: Te, Long: je, MaxKey: Ie, MinKey: qe, ObjectId: fe, Timestamp: ot, UUID: ft, calculateObjectSize: ra, deserialize: Oo, deserializeStream: xi, onDemand: ln, serialize: Ei, serializeWithBufferAndIndex: ds, setInternalBufferSize: bn });
      }, 6365: (o, s, a) => {
        var u = a(5832).hp, c = a(6353).Binary, f = a(6353).UUID, h = a(8768);
        function y(d, v, m) {
          var g, _, b, w, A = d;
          return d == null && (A = 0), Array.isArray(v) ? (_ = v[0], b = v[1]) : g = v, w = typeof A == "number" || A instanceof Number ? u.alloc(A) : u.from(A, g, m), h.decorate(w, y.mixin), w.isMongooseBuffer = !0, w[y.pathSymbol] = _, w[l] = b, w._subtype = 0, w;
        }
        var p = Symbol.for("mongoose#Buffer#_path"), l = Symbol.for("mongoose#Buffer#_parent");
        y.pathSymbol = p, y.mixin = { _subtype: void 0, _markModified: function() {
          var d = this[l];
          return d && d.markModified(this[y.pathSymbol]), this;
        }, write: function() {
          var d = u.prototype.write.apply(this, arguments);
          return d > 0 && this._markModified(), d;
        }, copy: function(d) {
          var v = u.prototype.copy.apply(this, arguments);
          return d && d.isMongooseBuffer && d._markModified(), v;
        } }, h.each(["writeUInt8", "writeUInt16", "writeUInt32", "writeInt8", "writeInt16", "writeInt32", "writeFloat", "writeDouble", "fill", "utf8Write", "binaryWrite", "asciiWrite", "set", "writeUInt16LE", "writeUInt16BE", "writeUInt32LE", "writeUInt32BE", "writeInt16LE", "writeInt16BE", "writeInt32LE", "writeInt32BE", "writeFloatLE", "writeFloatBE", "writeDoubleLE", "writeDoubleBE"], function(d) {
          u.prototype[d] && (y.mixin[d] = function() {
            var v = u.prototype[d].apply(this, arguments);
            return this._markModified(), v;
          });
        }), y.mixin.toObject = function(d) {
          var v = typeof d == "number" ? d : this._subtype || 0;
          return new c(u.from(this), v);
        }, y.mixin.$toObject = y.mixin.toObject, y.mixin.toBSON = function() {
          return new c(this, this._subtype || 0);
        }, y.mixin.toUUID = function() {
          if (this._subtype !== 4) throw new Error("Cannot convert a Buffer with subtype " + this._subtype + " to a UUID");
          return new f(this);
        }, y.mixin.equals = function(d) {
          if (!u.isBuffer(d) || this.length !== d.length) return !1;
          for (var v = 0; v < this.length; ++v) if (this[v] !== d[v]) return !1;
          return !0;
        }, y.mixin.subtype = function(d) {
          if (typeof d != "number") throw new TypeError("Invalid subtype. Expected a number");
          this._subtype !== d && this._markModified(), this._subtype = d;
        }, y.Binary = c, o.exports = y;
      }, 6400: (o, s, a) => {
        function u(J) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
            return typeof X;
          } : function(X) {
            return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X;
          }, u(J);
        }
        var c, f = a(8093), h = a(9870), y = a(9206), p = a(9939), l = a(783), d = a(9907), v = a(2268), m = a(8188), g = a(9471), _ = a(2401), b = a(1697), w = a(8435), A = a(8633), E = a(2151), O = a(674), $ = Function, k = function(J) {
          try {
            return $('"use strict"; return (' + J + ").constructor;")();
          } catch {
          }
        }, j = a(1464), P = a(988), R = function() {
          throw new v();
        }, I = j ? (function() {
          try {
            return R;
          } catch {
            try {
              return j(arguments, "callee").get;
            } catch {
              return R;
            }
          }
        })() : R, z = a(5510)(), W = a(209), F = a(5825), te = a(2403), ee = a(3279), V = a(3123), T = {}, D = typeof Uint8Array < "u" && W ? W(Uint8Array) : c, L = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? c : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? c : ArrayBuffer, "%ArrayIteratorPrototype%": z && W ? W([][Symbol.iterator]()) : c, "%AsyncFromSyncIteratorPrototype%": c, "%AsyncFunction%": T, "%AsyncGenerator%": T, "%AsyncGeneratorFunction%": T, "%AsyncIteratorPrototype%": T, "%Atomics%": typeof Atomics > "u" ? c : Atomics, "%BigInt%": typeof BigInt > "u" ? c : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? c : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? c : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? c : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": h, "%eval%": eval, "%EvalError%": y, "%Float16Array%": typeof Float16Array > "u" ? c : Float16Array, "%Float32Array%": typeof Float32Array > "u" ? c : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? c : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? c : FinalizationRegistry, "%Function%": $, "%GeneratorFunction%": T, "%Int8Array%": typeof Int8Array > "u" ? c : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? c : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? c : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": z && W ? W(W([][Symbol.iterator]())) : c, "%JSON%": (typeof JSON > "u" ? "undefined" : u(JSON)) === "object" ? JSON : c, "%Map%": typeof Map > "u" ? c : Map, "%MapIteratorPrototype%": typeof Map < "u" && z && W ? W((/* @__PURE__ */ new Map())[Symbol.iterator]()) : c, "%Math%": Math, "%Number%": Number, "%Object%": f, "%Object.getOwnPropertyDescriptor%": j, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? c : Promise, "%Proxy%": typeof Proxy > "u" ? c : Proxy, "%RangeError%": p, "%ReferenceError%": l, "%Reflect%": typeof Reflect > "u" ? c : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? c : Set, "%SetIteratorPrototype%": typeof Set < "u" && z && W ? W((/* @__PURE__ */ new Set())[Symbol.iterator]()) : c, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? c : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": z && W ? W(""[Symbol.iterator]()) : c, "%Symbol%": z ? Symbol : c, "%SyntaxError%": d, "%ThrowTypeError%": I, "%TypedArray%": D, "%TypeError%": v, "%Uint8Array%": typeof Uint8Array > "u" ? c : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? c : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? c : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? c : Uint32Array, "%URIError%": m, "%WeakMap%": typeof WeakMap > "u" ? c : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? c : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? c : WeakSet, "%Function.prototype.call%": V, "%Function.prototype.apply%": ee, "%Object.defineProperty%": P, "%Object.getPrototypeOf%": F, "%Math.abs%": g, "%Math.floor%": _, "%Math.max%": b, "%Math.min%": w, "%Math.pow%": A, "%Math.round%": E, "%Math.sign%": O, "%Reflect.getPrototypeOf%": te };
        if (W) try {
          null.error;
        } catch (J) {
          var M = W(W(J));
          L["%Error.prototype%"] = M;
        }
        var N = function J(X) {
          var oe;
          if (X === "%AsyncFunction%") oe = k("async function () {}");
          else if (X === "%GeneratorFunction%") oe = k("function* () {}");
          else if (X === "%AsyncGeneratorFunction%") oe = k("async function* () {}");
          else if (X === "%AsyncGenerator%") {
            var ye = J("%AsyncGeneratorFunction%");
            ye && (oe = ye.prototype);
          } else if (X === "%AsyncIteratorPrototype%") {
            var q = J("%AsyncGenerator%");
            q && W && (oe = W(q.prototype));
          }
          return L[X] = oe, oe;
        }, Z = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, Y = a(2354), ie = a(5994), le = Y.call(V, Array.prototype.concat), de = Y.call(ee, Array.prototype.splice), ae = Y.call(V, String.prototype.replace), ne = Y.call(V, String.prototype.slice), he = Y.call(V, RegExp.prototype.exec), x = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, U = /\\(\\)?/g, B = function(J, X) {
          var oe, ye = J;
          if (ie(Z, ye) && (ye = "%" + (oe = Z[ye])[0] + "%"), ie(L, ye)) {
            var q = L[ye];
            if (q === T && (q = N(ye)), q === void 0 && !X) throw new v("intrinsic " + J + " exists, but is not available. Please file an issue!");
            return { alias: oe, name: ye, value: q };
          }
          throw new d("intrinsic " + J + " does not exist!");
        };
        o.exports = function(J, X) {
          if (typeof J != "string" || J.length === 0) throw new v("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && typeof X != "boolean") throw new v('"allowMissing" argument must be a boolean');
          if (he(/^%?[^%]*%?$/, J) === null) throw new d("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          var oe = (function(Me) {
            var et = ne(Me, 0, 1), lt = ne(Me, -1);
            if (et === "%" && lt !== "%") throw new d("invalid intrinsic syntax, expected closing `%`");
            if (lt === "%" && et !== "%") throw new d("invalid intrinsic syntax, expected opening `%`");
            var ft = [];
            return ae(Me, x, function(Ke, Xt, $t, Pt) {
              ft[ft.length] = $t ? ae(Pt, U, "$1") : Xt || Ke;
            }), ft;
          })(J), ye = oe.length > 0 ? oe[0] : "", q = B("%" + ye + "%", X), G = q.name, ce = q.value, ue = !1, re = q.alias;
          re && (ye = re[0], de(oe, le([0, 1], re)));
          for (var pe = 1, xe = !0; pe < oe.length; pe += 1) {
            var be = oe[pe], Ee = ne(be, 0, 1), Ue = ne(be, -1);
            if ((Ee === '"' || Ee === "'" || Ee === "`" || Ue === '"' || Ue === "'" || Ue === "`") && Ee !== Ue) throw new d("property names with quotes must have matching quotes");
            if (be !== "constructor" && xe || (ue = !0), ie(L, G = "%" + (ye += "." + be) + "%")) ce = L[G];
            else if (ce != null) {
              if (!(be in ce)) {
                if (!X) throw new v("base intrinsic for " + J + " exists, but the property is not available.");
                return;
              }
              if (j && pe + 1 >= oe.length) {
                var Ae = j(ce, be);
                ce = (xe = !!Ae) && "get" in Ae && !("originalValue" in Ae.get) ? Ae.get : ce[be];
              } else xe = ie(ce, be), ce = ce[be];
              xe && !ue && (L[G] = ce);
            }
          }
          return ce;
        };
      }, 6413: (o, s, a) => {
        function u(m) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, u(m);
        }
        function c(m, g) {
          var _ = Object.keys(m);
          if (Object.getOwnPropertySymbols) {
            var b = Object.getOwnPropertySymbols(m);
            g && (b = b.filter(function(w) {
              return Object.getOwnPropertyDescriptor(m, w).enumerable;
            })), _.push.apply(_, b);
          }
          return _;
        }
        function f(m, g, _) {
          return (g = (function(b) {
            var w = (function(A) {
              if (u(A) != "object" || !A) return A;
              var E = A[Symbol.toPrimitive];
              if (E !== void 0) {
                var O = E.call(A, "string");
                if (u(O) != "object") return O;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(A);
            })(b);
            return u(w) == "symbol" ? w : w + "";
          })(g)) in m ? Object.defineProperty(m, g, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : m[g] = _, m;
        }
        var h = a(3609), y = a(6426), p = a(8953), l = a(4327);
        function d(m, g) {
          y.call(this, m, g, "Boolean");
        }
        d.schemaName = "Boolean", d.defaultOptions = {}, d.prototype = Object.create(y.prototype), d.prototype.constructor = d, d._cast = p, d.set = y.set, d.setters = [], d.get = y.get, d.cast = function(m) {
          return arguments.length === 0 || (m === !1 && (m = this._defaultCaster), this._cast = m), this._cast;
        }, d._defaultCaster = function(m) {
          if (m != null && typeof m != "boolean") throw new Error();
          return m;
        }, d._checkRequired = function(m) {
          return m === !0 || m === !1;
        }, d.checkRequired = y.checkRequired, d.prototype.checkRequired = function(m) {
          return this.constructor._checkRequired(m);
        }, Object.defineProperty(d, "convertToTrue", { get: function() {
          return p.convertToTrue;
        }, set: function(m) {
          p.convertToTrue = m;
        } }), Object.defineProperty(d, "convertToFalse", { get: function() {
          return p.convertToFalse;
        }, set: function(m) {
          p.convertToFalse = m;
        } }), d.prototype.cast = function(m) {
          var g;
          g = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : d.cast();
          try {
            return g(m);
          } catch (_) {
            throw new h("Boolean", m, this.path, _, this);
          }
        };
        var v = (function(m) {
          for (var g = 1; g < arguments.length; g++) {
            var _ = arguments[g] != null ? arguments[g] : {};
            g % 2 ? c(Object(_), !0).forEach(function(b) {
              f(m, b, _[b]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(_)) : c(Object(_)).forEach(function(b) {
              Object.defineProperty(m, b, Object.getOwnPropertyDescriptor(_, b));
            });
          }
          return m;
        })({}, y.prototype.$conditionalHandlers);
        Object.defineProperty(d.prototype, "$conditionalHandlers", { enumerable: !1, value: v }), d.prototype.castForQuery = function(m, g, _) {
          var b;
          if (m != null) return (b = this.$conditionalHandlers[m]) ? b.call(this, g) : this.applySetters(g, _);
          try {
            return this.applySetters(g, _);
          } catch (w) {
            throw w instanceof h && w.path === this.path && this.$fullPath != null && (w.path = this.$fullPath), w;
          }
        }, d.prototype._castNullish = function(m) {
          if (m === void 0) return m;
          var g = typeof this.constructor.cast == "function" ? this.constructor.cast() : d.cast();
          return g == null ? m : !(g.convertToFalse instanceof Set && g.convertToFalse.has(m)) && (!!(g.convertToTrue instanceof Set && g.convertToTrue.has(m)) || m);
        }, d.prototype.toJSONSchema = function(m) {
          var g = this.options.required && typeof this.options.required != "function";
          return l("boolean", "bool", m?.useBsonType, g);
        }, d.prototype.autoEncryptionType = function() {
          return "bool";
        }, o.exports = d;
      }, 6426: (o, s, a) => {
        var u = a(5832).hp;
        function c(z) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(W) {
            return typeof W;
          } : function(W) {
            return W && typeof Symbol == "function" && W.constructor === Symbol && W !== Symbol.prototype ? "symbol" : typeof W;
          }, c(z);
        }
        var f = a(3672), h = a(8879), y = a(8499), p = a(2555), l = a(4450), d = a(8133), v = a(9183), m = a(6155), g = a(2746), _ = a(7930).schemaTypeSymbol, b = a(8768), w = a(7930).validatorErrorSymbol, A = a(7930).documentIsModified, E = a(7930).populateModelSymbol, O = f.CastError, $ = f.ValidatorError, k = { _skipMarkModified: !0 };
        function j(z, W, F) {
          this[_] = !0, this.path = z, this.instance = F, this.schemaName = this.constructor.schemaName, this.validators = [], this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [], this.setters = this.constructor.hasOwnProperty("setters") ? this.constructor.setters.slice() : [], this.splitPath(), W = W || {};
          for (var te = this.constructor.defaultOptions || {}, ee = 0, V = Object.keys(te); ee < V.length; ee++) {
            var T = V[ee];
            T === "validate" ? this.validate(te.validate) : te.hasOwnProperty(T) && !Object.prototype.hasOwnProperty.call(W, T) && (W[T] = te[T]);
          }
          W.select == null && delete W.select;
          var D = this.OptionsConstructor || h;
          this.options = new D(W), this._index = null, b.hasUserDefinedProperty(this.options, "immutable") && (this.$immutable = this.options.immutable, d(this));
          for (var L = 0, M = Object.keys(this.options); L < M.length; L++) {
            var N = M[L];
            if (N !== "cast") {
              if (b.hasUserDefinedProperty(this.options, N) && typeof this[N] == "function") {
                if (N === "index" && this._index) {
                  if (W.index === !1) {
                    var Z = this._index;
                    if (c(Z) === "object" && Z != null) {
                      if (Z.unique) throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                      if (Z.sparse) throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                    }
                    this._index = !1;
                  }
                  continue;
                }
                var Y = W[N];
                if (N === "default") {
                  this.default(Y);
                  continue;
                }
                var ie = Array.isArray(Y) ? Y : [Y];
                this[N].apply(this, ie);
              }
            } else Array.isArray(this.options[N]) ? this.castFunction.apply(this, this.options[N]) : this.castFunction(this.options[N]);
          }
          Object.defineProperty(this, "$$context", { enumerable: !1, configurable: !1, writable: !0, value: null });
        }
        function P(z, W) {
          if (z !== void 0 && !z) {
            var F = new (W.ErrorConstructor || $)(W);
            return F[w] = !0, F;
          }
        }
        function R(z, W) {
          return this.castForQuery(null, z, W);
        }
        function I(z, W) {
          var F = this;
          return Array.isArray(z) ? z.map(function(te) {
            return Array.isArray(te) && te.length === 0 ? te : F.castForQuery(null, te, W);
          }) : [this.castForQuery(null, z, W)];
        }
        j.prototype.OptionsConstructor = h, j.prototype.path, j.prototype.validators, j.prototype.isRequired, j.prototype.splitPath = function() {
          return this._presplitPath != null ? this._presplitPath : this.path != null ? (this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split("."), this._presplitPath) : void 0;
        }, j.cast = function(z) {
          return arguments.length === 0 || (z === !1 && (z = function(W) {
            return W;
          }), this._cast = z), this._cast;
        }, j.prototype.castFunction = function(z, W) {
          return arguments.length === 0 ? this._castFunction : (z === !1 && (z = this.constructor._defaultCaster || function(F) {
            return F;
          }), typeof z == "string" ? (this._castErrorMessage = z, this._castFunction) : (z != null && (this._castFunction = z), W != null && (this._castErrorMessage = W), this._castFunction));
        }, j.prototype.cast = function() {
          throw new Error("Base SchemaType class does not implement a `cast()` function");
        }, j.set = function(z, W) {
          this.hasOwnProperty("defaultOptions") || (this.defaultOptions = Object.assign({}, this.defaultOptions)), this.defaultOptions[z] = W;
        }, j.get = function(z) {
          this.getters = this.hasOwnProperty("getters") ? this.getters : [], this.getters.push(z);
        }, j.prototype.default = function(z) {
          if (arguments.length === 1) {
            if (z === void 0) return void (this.defaultValue = void 0);
            if (z != null && z.instanceOfSchema) throw new f("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
            return this.defaultValue = z, this.defaultValue;
          }
          return arguments.length > 1 && (this.defaultValue = Array.prototype.slice.call(arguments)), this.defaultValue;
        }, j.prototype.index = function(z) {
          return this._index = z, b.expires(this._index), this;
        }, j.prototype.unique = function(z, W) {
          if (this._index === !1) {
            if (!z) return;
            throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
          }
          return this.options.hasOwnProperty("index") || z !== !1 ? (this._index == null || this._index === !0 ? this._index = {} : typeof this._index == "string" && (this._index = { type: this._index }), this._index.unique = !!z, typeof W == "string" && (this._duplicateKeyErrorMessage = W), this) : this;
        }, j.prototype.text = function(z) {
          if (this._index === !1) {
            if (!z) return this;
            throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
          }
          return this.options.hasOwnProperty("index") || z !== !1 ? (this._index === null || this._index === void 0 || typeof this._index == "boolean" ? this._index = {} : typeof this._index == "string" && (this._index = { type: this._index }), this._index.text = z, this) : this;
        }, j.prototype.sparse = function(z) {
          if (this._index === !1) {
            if (!z) return this;
            throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
          }
          return this.options.hasOwnProperty("index") || z !== !1 ? (this._index == null || typeof this._index == "boolean" ? this._index = {} : typeof this._index == "string" && (this._index = { type: this._index }), this._index.sparse = z, this) : this;
        }, j.prototype.immutable = function(z) {
          return this.$immutable = z, d(this), this;
        }, j.prototype.transform = function(z) {
          return this.options.transform = z, this;
        }, j.prototype.set = function(z) {
          if (typeof z != "function") throw new TypeError("A setter must be a function.");
          return this.setters.push(z), this;
        }, j.prototype.get = function(z) {
          if (typeof z != "function") throw new TypeError("A getter must be a function.");
          return this.getters.push(z), this;
        }, j.prototype.validateAll = function(z) {
          for (var W = 0; W < z.length; W++) this.validate(z[W]);
          return this;
        }, j.prototype.validate = function(z, W, F) {
          var te, ee, V, T;
          if (typeof z == "function" || z && b.getFunctionName(z.constructor) === "RegExp") return typeof W == "function" ? (te = { validator: z, message: W }).type = F || "user defined" : W instanceof Object && !F ? ((te = m(W) ? Object.assign({}, W) : l(W)).message || (te.message = te.msg), te.validator = z, te.type = te.type || "user defined") : (W == null && (W = f.messages.general.default), F || (F = "user defined"), te = { message: W, type: F, validator: z }), this.validators.push(te), this;
          for (ee = 0, V = arguments.length; ee < V; ee++) {
            if (T = arguments[ee], !b.isPOJO(T)) {
              var D = "Invalid validator. Received (" + c(T) + ") " + T + ". See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()";
              throw new Error(D);
            }
            this.validate(T.validator, T);
          }
          return this;
        }, j.prototype.required = function(z, W) {
          var F = {};
          if (arguments.length > 0 && z == null) return this.validators = this.validators.filter(function(V) {
            return V.validator !== this.requiredValidator;
          }, this), this.isRequired = !1, delete this.originalRequiredValue, this;
          if (c(z) === "object" && (W = (F = z).message || W, z = z.isRequired), z === !1) return this.validators = this.validators.filter(function(V) {
            return V.validator !== this.requiredValidator;
          }, this), this.isRequired = !1, delete this.originalRequiredValue, this;
          var te = this;
          this.isRequired = !0, this.requiredValidator = function(V) {
            var T = this && this.$__ && this.$__.cachedRequired;
            if (T != null && !this.$__isSelected(te.path) && !this[A](te.path)) return !0;
            if (T != null && te.path in T) {
              var D = !T[te.path] || te.checkRequired(V, this);
              return delete T[te.path], D;
            }
            return typeof z == "function" && !z.apply(this) || te.checkRequired(V, this);
          }, this.originalRequiredValue = z, typeof z == "string" && (W = z, z = void 0);
          var ee = W || f.messages.general.required;
          return this.validators.unshift(Object.assign({}, F, { validator: this.requiredValidator, message: ee, type: "required" })), this;
        }, j.prototype.ref = function(z) {
          return this.options.ref = z, this;
        }, j.prototype.getDefault = function(z, W, F) {
          var te;
          if (this.defaultValue == null) return this.defaultValue;
          if ((te = typeof this.defaultValue == "function" ? this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid" ? this.defaultValue.call(z) : this.defaultValue.call(z, z) : this.defaultValue) != null) {
            if (c(te) !== "object" || this.options && this.options.shared || (te = l(te)), F && F.skipCast) return this._applySetters(te, z);
            var ee = this.applySetters(te, z, W, void 0, k);
            return ee && !Array.isArray(ee) && ee.$isSingleNested && (ee.$__parent = z), ee;
          }
          return te;
        }, j.prototype._applySetters = function(z, W, F, te, ee) {
          var V = z;
          if (F) return V;
          for (var T = this.setters, D = T.length - 1; D >= 0; D--) V = T[D].call(W, V, te, this, ee);
          return V;
        }, j.prototype._castNullish = function(z) {
          return z;
        }, j.prototype.applySetters = function(z, W, F, te, ee) {
          var V = this._applySetters(z, W, F, te, ee);
          return V == null ? this._castNullish(V) : V = this.cast(V, W, F, te, ee);
        }, j.prototype.applyGetters = function(z, W) {
          var F = z, te = this.getters, ee = te.length;
          if (ee === 0) return F;
          for (var V = 0; V < ee; ++V) F = te[V].call(W, F, this);
          return F;
        }, j.prototype.select = function(z) {
          return this.selected = !!z, this;
        }, j.prototype.doValidate = function(z, W, F, te) {
          var ee = this, V = !1, T = this.path;
          if (typeof W != "function") throw new TypeError("Must pass callback function to doValidate(), got ".concat(c(W)));
          var D = this.validators.filter(function(ie) {
            return c(ie) === "object" && ie !== null;
          }), L = D.length;
          if (!L) return W(null);
          for (var M = function() {
            if (V) return 0;
            var ie, le = D[N], de = le.validator, ae = m(le) ? Object.assign({}, le) : l(le);
            if (ae.path = te && te.path ? te.path : T, ae.fullPath = ee.$fullPath, ae.value = z, typeof z == "string" && (ae.length = z.length, ae.value.length > 30 && (ae.value = ae.value.slice(0, 30) + "...")), de instanceof RegExp) return Y(de.test(z), ae, F), 1;
            if (typeof de != "function") return 1;
            if (z === void 0 && de !== ee.requiredValidator) return Y(!0, ae, F), 1;
            try {
              ie = ae.propsParameter ? de.call(F, z, ae) : de.call(F, z);
            } catch (ne) {
              ie = !1, ae.reason = ne, ne.message && (ae.message = ne.message);
            }
            ie != null && typeof ie.then == "function" ? ie.then(function(ne) {
              Y(ne, ae, F);
            }, function(ne) {
              ae.reason = ne, ae.message = ne.message, Y(ie = !1, ae, F);
            }) : Y(ie, ae, F);
          }, N = 0, Z = D.length; N < Z && M() !== 0; ++N) ;
          function Y(ie, le, de) {
            if (!V) if (ie === void 0 || ie) --L <= 0 && g(function() {
              W(null);
            });
            else {
              var ae = le.ErrorConstructor || $;
              (V = new ae(le, de))[w] = !0, g(function() {
                W(V);
              });
            }
          }
        }, j.prototype.doValidateSync = function(z, W, F) {
          var te = this.path;
          if (!this.validators.length) return null;
          var ee = this.validators;
          if (z === void 0) {
            if (this.validators.length === 0 || this.validators[0].type !== "required") return null;
            ee = [this.validators[0]];
          }
          var V = null, T = 0, D = ee.length;
          for (T = 0; T < D; ++T) {
            var L = ee[T];
            if (L !== null && c(L) === "object") {
              var M = L.validator, N = m(L) ? Object.assign({}, L) : l(L);
              N.path = F && F.path ? F.path : te, N.fullPath = this.$fullPath, N.value = z, typeof z == "string" && (N.length = z.length, N.value.length > 30 && (N.value = N.value.slice(0, 30) + "..."));
              var Z = !1;
              if (!v(M)) {
                if (M instanceof RegExp) V = P(M.test(z), N);
                else if (typeof M == "function") {
                  try {
                    Z = N.propsParameter ? M.call(W, z, N) : M.call(W, z);
                  } catch (Y) {
                    Z = !1, N.reason = Y;
                  }
                  if ((Z == null || typeof Z.then != "function") && (V = P(Z, N))) break;
                }
              }
            }
          }
          return V;
        }, j._isRef = function(z, W, F, te) {
          var ee = te && z.options && (z.options.ref || z.options.refPath);
          if (!ee && F && F.$__ != null) {
            var V = F.$__fullPath(z.path, !0), T = F.ownerDocument();
            ee = V != null && T.$populated(V) || F.$populated(z.path);
          }
          return !!ee && (W == null || !(u.isBuffer(W) || W._bsontype === "Binary" || !b.isObject(W)) || te);
        }, j.prototype._castRef = function(z, W, F, te) {
          if (z == null) return z;
          if (z.$__ != null) return z.$__.wasPopulated = z.$__.wasPopulated || { value: z._doc._id }, z;
          if (u.isBuffer(z) || !b.isObject(z)) {
            if (F) return z;
            throw new O(this.instance, z, this.path, null, this);
          }
          var ee, V, T, D = W.$__fullPath(this.path, !0), L = W.ownerDocument().$populated(D, !0), M = z;
          if (!(W.$__.populated && W.$__.populated[D] && W.$__.populated[D].options && W.$__.populated[D].options.options && W.$__.populated[D].options.options.lean)) {
            var N = L ? L.options[E] : W.constructor.db.model(this.options.ref);
            (M = N.hydrate(z, null, te)).$__.wasPopulated = { value: M._doc._id, options: (ee = {}, V = E, T = N, (V = (function(Z) {
              var Y = (function(ie) {
                if (c(ie) != "object" || !ie) return ie;
                var le = ie[Symbol.toPrimitive];
                if (le !== void 0) {
                  var de = le.call(ie, "string");
                  if (c(de) != "object") return de;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(ie);
              })(Z);
              return c(Y) == "symbol" ? Y : Y + "";
            })(V)) in ee ? Object.defineProperty(ee, V, { value: T, enumerable: !0, configurable: !0, writable: !0 }) : ee[V] = T, ee) };
          }
          return M;
        }, j.prototype.$conditionalHandlers = { $all: function(z, W) {
          var F = this;
          return Array.isArray(z) ? z.map(function(te) {
            return F.castForQuery(null, te, W);
          }) : [this.castForQuery(null, z, W)];
        }, $eq: R, $in: I, $ne: R, $nin: I, $exists: y, $type: p }, j.prototype.castForQuery = function(z, W, F) {
          var te;
          if (z != null) {
            if (!(te = this.$conditionalHandlers[z])) throw new Error("Can't use " + z);
            return te.call(this, W, F);
          }
          try {
            return this.applySetters(W, F);
          } catch (ee) {
            throw ee instanceof O && ee.path === this.path && this.$fullPath != null && (ee.path = this.$fullPath), ee;
          }
        }, j.checkRequired = function(z) {
          return arguments.length !== 0 && (this._checkRequired = z), this._checkRequired;
        }, j.prototype.checkRequired = function(z) {
          return z != null;
        }, j.prototype.clone = function() {
          var z = Object.assign({}, this.options), W = new this.constructor(this.path, z, this.instance);
          return W.validators = this.validators.slice(), this.requiredValidator !== void 0 && (W.requiredValidator = this.requiredValidator), this.defaultValue !== void 0 && (W.defaultValue = this.defaultValue), this.$immutable !== void 0 && this.options.immutable === void 0 && (W.$immutable = this.$immutable, d(W)), this._index !== void 0 && (W._index = this._index), this.selected !== void 0 && (W.selected = this.selected), this.isRequired !== void 0 && (W.isRequired = this.isRequired), this.originalRequiredValue !== void 0 && (W.originalRequiredValue = this.originalRequiredValue), W.getters = this.getters.slice(), W.setters = this.setters.slice(), W;
        }, j.prototype.getEmbeddedSchemaType = function() {
          return this.$embeddedSchemaType;
        }, j.prototype._duplicateKeyErrorMessage = null, j.prototype.toJSONSchema = function(z) {
          throw new Error("Converting unsupported SchemaType to JSON Schema: ".concat(this.instance, ' at path "').concat(this.path, '"'));
        }, j.prototype.autoEncryptionType = function() {
          return null;
        }, o.exports = s = j, s.CastError = O, s.ValidatorError = $;
      }, 6451: (o, s, a) => {
        var u = a(8768).isPOJO;
        o.exports = function c(f) {
          for (var h, y, p, l = Object.keys(f), d = l.length; d--; ) p = f[y = l[d]], u(p) && (f[y] = c(p)), f[y] !== void 0 ? h = !0 : delete f[y];
          return h ? f : void 0;
        };
      }, 6511: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c(l, d) {
          (d == null || d > l.length) && (d = l.length);
          for (var v = 0, m = Array(d); v < d; v++) m[v] = l[v];
          return m;
        }
        function f(l, d) {
          var v = Object.keys(l);
          if (Object.getOwnPropertySymbols) {
            var m = Object.getOwnPropertySymbols(l);
            d && (m = m.filter(function(g) {
              return Object.getOwnPropertyDescriptor(l, g).enumerable;
            })), v.push.apply(v, m);
          }
          return v;
        }
        function h(l) {
          for (var d = 1; d < arguments.length; d++) {
            var v = arguments[d] != null ? arguments[d] : {};
            d % 2 ? f(Object(v), !0).forEach(function(m) {
              y(l, m, v[m]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(v)) : f(Object(v)).forEach(function(m) {
              Object.defineProperty(l, m, Object.getOwnPropertyDescriptor(v, m));
            });
          }
          return l;
        }
        function y(l, d, v) {
          return (d = (function(m) {
            var g = (function(_) {
              if (u(_) != "object" || !_) return _;
              var b = _[Symbol.toPrimitive];
              if (b !== void 0) {
                var w = b.call(_, "string");
                if (u(w) != "object") return w;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(_);
            })(m);
            return u(g) == "symbol" ? g : g + "";
          })(d)) in l ? Object.defineProperty(l, d, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : l[d] = v, l;
        }
        a(8768);
        var p = o.exports = function() {
        };
        p.ctor = function() {
          var l = Array.prototype.slice.call(arguments), d = function() {
            p.apply(this, arguments), this.paths = {}, this.states = {};
          };
          return (d.prototype = new p()).constructor = d, d.prototype.stateNames = l, l.forEach(function(v) {
            d.prototype[v] = function(m) {
              this._changeState(m, v);
            };
          }), d;
        }, p.prototype._changeState = function(l, d) {
          var v = this.paths[l];
          if (v !== d) {
            var m = this.states[v];
            m && delete m[l], this.paths[l] = d, this.states[d] = this.states[d] || {}, this.states[d][l] = !0;
          }
        }, p.prototype.clear = function(l) {
          if (this.states[l] != null) for (var d, v = Object.keys(this.states[l]), m = v.length; m--; ) d = v[m], delete this.states[l][d], delete this.paths[d];
        }, p.prototype.clearPath = function(l) {
          var d = this.paths[l];
          d && (delete this.paths[l], delete this.states[d][l]);
        }, p.prototype.getStatePaths = function(l) {
          return this.states[l] != null ? this.states[l] : {};
        }, p.prototype.some = function() {
          var l = this, d = arguments.length ? arguments : this.stateNames;
          return Array.prototype.some.call(d, function(v) {
            return l.states[v] != null && Object.keys(l.states[v]).length;
          });
        }, p.prototype._iter = function(l) {
          return function() {
            var d = Array.prototype.slice.call(arguments), v = d.pop();
            d.length || (d = this.stateNames);
            var m = this;
            return d.reduce(function(g, _) {
              return m.states[_] == null ? g : g.concat(Object.keys(m.states[_]));
            }, [])[l](function(g, _, b) {
              return v(g, _, b);
            });
          };
        }, p.prototype.forEach = function() {
          return this.forEach = this._iter("forEach"), this.forEach.apply(this, arguments);
        }, p.prototype.map = function() {
          return this.map = this._iter("map"), this.map.apply(this, arguments);
        }, p.prototype.clone = function() {
          var l = new this.constructor();
          l.paths = h({}, this.paths);
          var d, v = (function(g, _) {
            var b = typeof Symbol < "u" && g[Symbol.iterator] || g["@@iterator"];
            if (!b) {
              if (Array.isArray(g) || (b = (function(k, j) {
                if (k) {
                  if (typeof k == "string") return c(k, j);
                  var P = {}.toString.call(k).slice(8, -1);
                  return P === "Object" && k.constructor && (P = k.constructor.name), P === "Map" || P === "Set" ? Array.from(k) : P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P) ? c(k, j) : void 0;
                }
              })(g)) || _) {
                b && (g = b);
                var w = 0, A = function() {
                };
                return { s: A, n: function() {
                  return w >= g.length ? { done: !0 } : { done: !1, value: g[w++] };
                }, e: function(k) {
                  throw k;
                }, f: A };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var E, O = !0, $ = !1;
            return { s: function() {
              b = b.call(g);
            }, n: function() {
              var k = b.next();
              return O = k.done, k;
            }, e: function(k) {
              $ = !0, E = k;
            }, f: function() {
              try {
                O || b.return == null || b.return();
              } finally {
                if ($) throw E;
              }
            } };
          })(this.stateNames);
          try {
            for (v.s(); !(d = v.n()).done; ) {
              var m = d.value;
              m in this.states && (l.states[m] = this.states[m] == null ? this.states[m] : h({}, this.states[m]));
            }
          } catch (g) {
            v.e(g);
          } finally {
            v.f();
          }
          return l;
        };
      }, 6544: (o, s, a) => {
        function u(b) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
            return typeof w;
          } : function(w) {
            return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
          }, u(b);
        }
        var c;
        if (!Object.keys) {
          var f = Object.prototype.hasOwnProperty, h = Object.prototype.toString, y = a(6312), p = Object.prototype.propertyIsEnumerable, l = !p.call({ toString: null }, "toString"), d = p.call(function() {
          }, "prototype"), v = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], m = function(b) {
            var w = b.constructor;
            return w && w.prototype === b;
          }, g = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, _ = (function() {
            if (typeof window > "u") return !1;
            for (var b in window) try {
              if (!g["$" + b] && f.call(window, b) && window[b] !== null && u(window[b]) === "object") try {
                m(window[b]);
              } catch {
                return !0;
              }
            } catch {
              return !0;
            }
            return !1;
          })();
          c = function(b) {
            var w = b !== null && u(b) === "object", A = h.call(b) === "[object Function]", E = y(b), O = w && h.call(b) === "[object String]", $ = [];
            if (!w && !A && !E) throw new TypeError("Object.keys called on a non-object");
            var k = d && A;
            if (O && b.length > 0 && !f.call(b, 0)) for (var j = 0; j < b.length; ++j) $.push(String(j));
            if (E && b.length > 0) for (var P = 0; P < b.length; ++P) $.push(String(P));
            else for (var R in b) k && R === "prototype" || !f.call(b, R) || $.push(String(R));
            if (l) for (var I = (function(W) {
              if (typeof window > "u" || !_) return m(W);
              try {
                return m(W);
              } catch {
                return !1;
              }
            })(b), z = 0; z < v.length; ++z) I && v[z] === "constructor" || !f.call(b, v[z]) || $.push(v[z]);
            return $;
          };
        }
        o.exports = c;
      }, 6547: (o, s, a) => {
        function u(m, g) {
          var _ = Object.keys(m);
          if (Object.getOwnPropertySymbols) {
            var b = Object.getOwnPropertySymbols(m);
            g && (b = b.filter(function(w) {
              return Object.getOwnPropertyDescriptor(m, w).enumerable;
            })), _.push.apply(_, b);
          }
          return _;
        }
        function c(m, g, _) {
          return (g = (function(b) {
            var w = (function(A) {
              if (f(A) != "object" || !A) return A;
              var E = A[Symbol.toPrimitive];
              if (E !== void 0) {
                var O = E.call(A, "string");
                if (f(O) != "object") return O;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(A);
            })(b);
            return f(w) == "symbol" ? w : w + "";
          })(g)) in m ? Object.defineProperty(m, g, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : m[g] = _, m;
        }
        function f(m) {
          return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, f(m);
        }
        var h = a(3550).EventEmitter, y = a(9380), p = a(8768), l = a(7930).documentArrayParent;
        function d(m, g, _, b, w) {
          var A;
          p.isMongooseDocumentArray(g) ? (this.__parentArray = g, this[l] = g.$parent()) : (this.__parentArray = void 0, this[l] = void 0), this.$setIndex(w), this.$__parent = this[l], f(_) === "object" && _ != null ? (A = (function(E) {
            for (var O = 1; O < arguments.length; O++) {
              var $ = arguments[O] != null ? arguments[O] : {};
              O % 2 ? u(Object($), !0).forEach(function(k) {
                c(E, k, $[k]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(E, Object.getOwnPropertyDescriptors($)) : u(Object($)).forEach(function(k) {
                Object.defineProperty(E, k, Object.getOwnPropertyDescriptor($, k));
              });
            }
            return E;
          })({ isNew: !0 }, _), _ = void 0) : A = { isNew: !0 }, y.call(this, m, b, this[l], _, A);
        }
        for (var v in d.prototype = Object.create(y.prototype), d.prototype.constructor = d, Object.defineProperty(d.prototype, "$isSingleNested", { configurable: !1, writable: !1, value: !1 }), Object.defineProperty(d.prototype, "$isDocumentArrayElement", { configurable: !1, writable: !1, value: !0 }), h.prototype) d[v] = h.prototype[v];
        d.prototype.$setIndex = function(m) {
          if (this.__index = m, this.$__ != null && this.$__.validationError != null) for (var g = 0, _ = Object.keys(this.$__.validationError.errors); g < _.length; g++) {
            var b = _[g];
            this.invalidate(b, this.$__.validationError.errors[b]);
          }
        }, d.prototype.populate = function() {
          throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
        }, d.prototype.$__removeFromParent = function() {
          var m = this._doc._id;
          if (!m) throw new Error("For your own good, Mongoose does not know how to remove an ArraySubdocument that has no _id");
          this.__parentArray.pull({ _id: m });
        }, d.prototype.$__fullPath = function(m, g) {
          return this.__index == null ? null : (this.$__.fullPath || this.ownerDocument(), g ? m ? this.$__.fullPath + "." + m : this.$__.fullPath : m ? this.$__.fullPath + "." + this.__index + "." + m : this.$__.fullPath + "." + this.__index);
        }, d.prototype.$__pathRelativeToParent = function(m, g) {
          return this.__index != null && this.__parentArray && this.__parentArray.$path ? g ? m == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + m : m == null ? this.__parentArray.$path() + "." + this.__index : this.__parentArray.$path() + "." + this.__index + "." + m : null;
        }, d.prototype.$parent = function() {
          return this[l];
        }, d.prototype.parentArray = function() {
          return this.__parentArray;
        }, o.exports = d;
      }, 6583: (o, s, a) => {
        function u(d) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(v) {
            return typeof v;
          } : function(v) {
            return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
          }, u(d);
        }
        var c, f = a(8863), h = a(1464);
        try {
          c = [].__proto__ === Array.prototype;
        } catch (d) {
          if (!d || u(d) !== "object" || !("code" in d) || d.code !== "ERR_PROTO_ACCESS") throw d;
        }
        var y = !!c && h && h(Object.prototype, "__proto__"), p = Object, l = p.getPrototypeOf;
        o.exports = y && typeof y.get == "function" ? f([y.get]) : typeof l == "function" && function(d) {
          return l(d == null ? d : p(d));
        };
      }, 6665: (o) => {
        o.exports = function(s, a) {
          for (var u, c, f, h = a.split("."), y = "", p = 0; p < h.length; ++p) if (s[y += y.length ? "." : "" + h[p]]) {
            for (f = (c = Object.keys(s)).length, u = 0; u < f; ++u) c[p].indexOf(y + ".") !== 0 || c[p].indexOf(a);
            return !0;
          }
          return !1;
        };
      }, 6730: (o) => {
        var s = Object.prototype.toString, a = Math.max, u = function(c, f) {
          for (var h = [], y = 0; y < c.length; y += 1) h[y] = c[y];
          for (var p = 0; p < f.length; p += 1) h[p + c.length] = f[p];
          return h;
        };
        o.exports = function(c) {
          var f = this;
          if (typeof f != "function" || s.apply(f) !== "[object Function]") throw new TypeError("Function.prototype.bind called on incompatible " + f);
          for (var h, y = (function(m) {
            for (var g = [], _ = 1, b = 0; _ < m.length; _ += 1, b += 1) g[b] = m[_];
            return g;
          })(arguments), p = a(0, f.length - y.length), l = [], d = 0; d < p; d++) l[d] = "$" + d;
          if (h = Function("binder", "return function (" + (function(m) {
            for (var g = "", _ = 0; _ < m.length; _ += 1) g += m[_], _ + 1 < m.length && (g += ",");
            return g;
          })(l) + "){ return binder.apply(this,arguments); }")(function() {
            if (this instanceof h) {
              var m = f.apply(this, u(y, arguments));
              return Object(m) === m ? m : this;
            }
            return f.apply(c, u(y, arguments));
          }), f.prototype) {
            var v = function() {
            };
            v.prototype = f.prototype, h.prototype = new v(), v.prototype = null;
          }
          return h;
        };
      }, 6750: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        var c = a(988), f = a(9907), h = a(2268), y = a(1464);
        o.exports = function(p, l, d) {
          if (!p || u(p) !== "object" && typeof p != "function") throw new h("`obj` must be an object or a function`");
          if (typeof l != "string" && u(l) !== "symbol") throw new h("`property` must be a string or a symbol`");
          if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new h("`nonEnumerable`, if provided, must be a boolean or null");
          if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new h("`nonWritable`, if provided, must be a boolean or null");
          if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new h("`nonConfigurable`, if provided, must be a boolean or null");
          if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new h("`loose`, if provided, must be a boolean");
          var v = arguments.length > 3 ? arguments[3] : null, m = arguments.length > 4 ? arguments[4] : null, g = arguments.length > 5 ? arguments[5] : null, _ = arguments.length > 6 && arguments[6], b = !!y && y(p, l);
          if (c) c(p, l, { configurable: g === null && b ? b.configurable : !g, enumerable: v === null && b ? b.enumerable : !v, value: d, writable: m === null && b ? b.writable : !m });
          else {
            if (!_ && (v || m || g)) throw new f("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
            p[l] = d;
          }
        };
      }, 6775: (o, s) => {
        s.byteLength = function(d) {
          var v = y(d), m = v[0], g = v[1];
          return 3 * (m + g) / 4 - g;
        }, s.toByteArray = function(d) {
          var v, m, g = y(d), _ = g[0], b = g[1], w = new c((function(O, $, k) {
            return 3 * ($ + k) / 4 - k;
          })(0, _, b)), A = 0, E = b > 0 ? _ - 4 : _;
          for (m = 0; m < E; m += 4) v = u[d.charCodeAt(m)] << 18 | u[d.charCodeAt(m + 1)] << 12 | u[d.charCodeAt(m + 2)] << 6 | u[d.charCodeAt(m + 3)], w[A++] = v >> 16 & 255, w[A++] = v >> 8 & 255, w[A++] = 255 & v;
          return b === 2 && (v = u[d.charCodeAt(m)] << 2 | u[d.charCodeAt(m + 1)] >> 4, w[A++] = 255 & v), b === 1 && (v = u[d.charCodeAt(m)] << 10 | u[d.charCodeAt(m + 1)] << 4 | u[d.charCodeAt(m + 2)] >> 2, w[A++] = v >> 8 & 255, w[A++] = 255 & v), w;
        }, s.fromByteArray = function(d) {
          for (var v, m = d.length, g = m % 3, _ = [], b = 16383, w = 0, A = m - g; w < A; w += b) _.push(l(d, w, w + b > A ? A : w + b));
          return g === 1 ? (v = d[m - 1], _.push(a[v >> 2] + a[v << 4 & 63] + "==")) : g === 2 && (v = (d[m - 2] << 8) + d[m - 1], _.push(a[v >> 10] + a[v >> 4 & 63] + a[v << 2 & 63] + "=")), _.join("");
        };
        for (var a = [], u = [], c = typeof Uint8Array < "u" ? Uint8Array : Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = 0; h < 64; ++h) a[h] = f[h], u[f.charCodeAt(h)] = h;
        function y(d) {
          var v = d.length;
          if (v % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var m = d.indexOf("=");
          return m === -1 && (m = v), [m, m === v ? 0 : 4 - m % 4];
        }
        function p(d) {
          return a[d >> 18 & 63] + a[d >> 12 & 63] + a[d >> 6 & 63] + a[63 & d];
        }
        function l(d, v, m) {
          for (var g, _ = [], b = v; b < m; b += 3) g = (d[b] << 16 & 16711680) + (d[b + 1] << 8 & 65280) + (255 & d[b + 2]), _.push(p(g));
          return _.join("");
        }
        u[45] = 62, u[95] = 63;
      }, 6801: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m) {
            var g;
            return (function(_, b) {
              if (!(_ instanceof b)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (g = (function(_, b, w) {
              return b = f(b), (function(A, E) {
                if (E && (u(E) == "object" || typeof E == "function")) return E;
                if (E !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(O) {
                  if (O === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return O;
                })(A);
              })(_, c() ? Reflect.construct(b, w || [], f(_).constructor) : b.apply(_, w));
            })(this, l, [m = m || "Cannot populate path `" + v + "` because it is not in your schema. Set the `strictPopulate` option to false to override."])).path = v, g;
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "StrictPopulateError" }), o.exports = y;
      }, 6814: (o) => {
        o.exports = function(s) {
          for (var a = {}, u = 0, c = Object.keys(s); u < c.length; u++) {
            var f = c[u];
            if (f.indexOf(".") !== -1) for (var h = f.split("."), y = h[0], p = 0; p < h.length; ++p) a[y] = 1, p + 1 < h.length && (y = y + "." + h[p + 1]);
            else a[f] = 1;
          }
          return a;
        };
      }, 6867: (o, s, a) => {
        function u(O) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function($) {
            return typeof $;
          } : function($) {
            return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $;
          }, u(O);
        }
        function c(O, $) {
          var k = Object.keys(O);
          if (Object.getOwnPropertySymbols) {
            var j = Object.getOwnPropertySymbols(O);
            $ && (j = j.filter(function(P) {
              return Object.getOwnPropertyDescriptor(O, P).enumerable;
            })), k.push.apply(k, j);
          }
          return k;
        }
        function f(O) {
          for (var $ = 1; $ < arguments.length; $++) {
            var k = arguments[$] != null ? arguments[$] : {};
            $ % 2 ? c(Object(k), !0).forEach(function(j) {
              h(O, j, k[j]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(O, Object.getOwnPropertyDescriptors(k)) : c(Object(k)).forEach(function(j) {
              Object.defineProperty(O, j, Object.getOwnPropertyDescriptor(k, j));
            });
          }
          return O;
        }
        function h(O, $, k) {
          return ($ = l($)) in O ? Object.defineProperty(O, $, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : O[$] = k, O;
        }
        function y(O, $) {
          ($ == null || $ > O.length) && ($ = O.length);
          for (var k = 0, j = Array($); k < $; k++) j[k] = O[k];
          return j;
        }
        function p(O, $) {
          for (var k = 0; k < $.length; k++) {
            var j = $[k];
            j.enumerable = j.enumerable || !1, j.configurable = !0, "value" in j && (j.writable = !0), Object.defineProperty(O, l(j.key), j);
          }
        }
        function l(O) {
          var $ = (function(k) {
            if (u(k) != "object" || !k) return k;
            var j = k[Symbol.toPrimitive];
            if (j !== void 0) {
              var P = j.call(k, "string");
              if (u(P) != "object") return P;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(k);
          })(O);
          return u($) == "symbol" ? $ : $ + "";
        }
        function d() {
          try {
            var O = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (d = function() {
            return !!O;
          })();
        }
        function v() {
          return v = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(O, $, k) {
            var j = (function(R, I) {
              for (; !{}.hasOwnProperty.call(R, I) && (R = m(R)) !== null; ) ;
              return R;
            })(O, $);
            if (j) {
              var P = Object.getOwnPropertyDescriptor(j, $);
              return P.get ? P.get.call(arguments.length < 3 ? O : k) : P.value;
            }
          }, v.apply(null, arguments);
        }
        function m(O) {
          return m = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function($) {
            return $.__proto__ || Object.getPrototypeOf($);
          }, m(O);
        }
        function g(O, $) {
          return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(k, j) {
            return k.__proto__ = j, k;
          }, g(O, $);
        }
        var _ = a(2081), b = a(241), w = a(6426), A = a(4327), E = (function(O) {
          function $(P, R) {
            var I;
            return (function(z, W) {
              if (!(z instanceof W)) throw new TypeError("Cannot call a class as a function");
            })(this, $), (I = (function(z, W, F) {
              return W = m(W), (function(te, ee) {
                if (ee && (u(ee) == "object" || typeof ee == "function")) return ee;
                if (ee !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(V) {
                  if (V === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return V;
                })(te);
              })(z, d() ? Reflect.construct(W, F || [], m(z).constructor) : W.apply(z, F));
            })(this, $, [P, R, "Map"])).$isSchemaMap = !0, I;
          }
          return (function(P, R) {
            if (typeof R != "function" && R !== null) throw new TypeError("Super expression must either be null or a function");
            P.prototype = Object.create(R && R.prototype, { constructor: { value: P, writable: !0, configurable: !0 } }), Object.defineProperty(P, "prototype", { writable: !1 }), R && g(P, R);
          })($, O), k = $, j = [{ key: "set", value: function(P, R) {
            return w.set(P, R);
          } }, { key: "cast", value: function(P, R, I, z, W) {
            if (P instanceof _) return P;
            var F = this.path;
            if (I) {
              var te = new _({}, F, R, this.$__schemaType, W), ee = te.$__pathRelativeToParent != null ? te.$__pathRelativeToParent : te.$__path;
              if (P instanceof a.g.Map) {
                var V, T = (function(ie, le) {
                  var de = typeof Symbol < "u" && ie[Symbol.iterator] || ie["@@iterator"];
                  if (!de) {
                    if (Array.isArray(ie) || (de = (function(B, J) {
                      if (B) {
                        if (typeof B == "string") return y(B, J);
                        var X = {}.toString.call(B).slice(8, -1);
                        return X === "Object" && B.constructor && (X = B.constructor.name), X === "Map" || X === "Set" ? Array.from(B) : X === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(X) ? y(B, J) : void 0;
                      }
                    })(ie)) || le) {
                      de && (ie = de);
                      var ae = 0, ne = function() {
                      };
                      return { s: ne, n: function() {
                        return ae >= ie.length ? { done: !0 } : { done: !1, value: ie[ae++] };
                      }, e: function(B) {
                        throw B;
                      }, f: ne };
                    }
                    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                  }
                  var he, x = !0, U = !1;
                  return { s: function() {
                    de = de.call(ie);
                  }, n: function() {
                    var B = de.next();
                    return x = B.done, B;
                  }, e: function(B) {
                    U = !0, he = B;
                  }, f: function() {
                    try {
                      x || de.return == null || de.return();
                    } finally {
                      if (U) throw he;
                    }
                  } };
                })(P.keys());
                try {
                  for (T.s(); !(V = T.n()).done; ) {
                    var D = V.value, L = P.get(D);
                    L = L == null ? te.$__schemaType._castNullish(L) : te.$__schemaType.cast(L, R, !0, null, f(f({}, W), {}, { path: ee + "." + D })), te.$init(D, L);
                  }
                } catch (ie) {
                  T.e(ie);
                } finally {
                  T.f();
                }
              } else for (var M = 0, N = Object.keys(P); M < N.length; M++) {
                var Z = N[M], Y = P[Z];
                Y = Y == null ? te.$__schemaType._castNullish(Y) : te.$__schemaType.cast(Y, R, !0, null, f(f({}, W), {}, { path: ee + "." + Z })), te.$init(Z, Y);
              }
              return te;
            }
            return new _(P, F, R, this.$__schemaType, W);
          } }, { key: "clone", value: function() {
            var P, R, I, z = (P = $, R = this, typeof (I = v(m(P.prototype), "clone", R)) == "function" ? function(W) {
              return I.apply(R, W);
            } : I)([]);
            return this.$__schemaType != null && (z.$__schemaType = this.$__schemaType.clone()), z;
          } }, { key: "getEmbeddedSchemaType", value: function() {
            return this.$__schemaType;
          } }, { key: "toJSONSchema", value: function(P) {
            var R = P?.useBsonType, I = this.getEmbeddedSchemaType(), z = this.options.required && typeof this.options.required != "function", W = A("object", "object", R, z);
            return W.additionalProperties = I.toJSONSchema(P), W;
          } }, { key: "autoEncryptionType", value: function() {
            return "object";
          } }], j && p(k.prototype, j), Object.defineProperty(k, "prototype", { writable: !1 }), k;
          var k, j;
        })(w);
        E.schemaName = "Map", E.prototype.OptionsConstructor = b, E.defaultOptions = {}, o.exports = E;
      }, 6948: (o, s, a) => {
        function u(y) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
            return typeof p;
          } : function(p) {
            return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
          }, u(y);
        }
        function c(y, p, l) {
          return Object.defineProperty(y, "prototype", { writable: !1 }), y;
        }
        var f = a(4450), h = c(function y(p) {
          if ((function(l, d) {
            if (!(l instanceof d)) throw new TypeError("Cannot call a class as a function");
          })(this, y), this._docs = {}, this._childDocs = [], p != null && (p = f(p), Object.assign(this, p), u(p.subPopulate) === "object" && (this.populate = p.subPopulate), p.perDocumentLimit != null && p.limit != null)) throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + p.path + "`.");
        });
        o.exports = h;
      }, 6949: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        function c(_, b) {
          for (var w = 0; w < b.length; w++) {
            var A = b[w];
            A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(_, f(A.key), A);
          }
        }
        function f(_) {
          var b = (function(w) {
            if (u(w) != "object" || !w) return w;
            var A = w[Symbol.toPrimitive];
            if (A !== void 0) {
              var E = A.call(w, "string");
              if (u(E) != "object") return E;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(w);
          })(_);
          return u(b) == "symbol" ? b : b + "";
        }
        function h() {
          try {
            var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (h = function() {
            return !!_;
          })();
        }
        function y(_) {
          return y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, y(_);
        }
        function p(_, b) {
          return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w, A) {
            return w.__proto__ = A, w;
          }, p(_, b);
        }
        var l = a(8213), d = a(8260), v = a(7352), m = a(1875), g = (function(_) {
          function b(E) {
            var O, $;
            return (function(k, j) {
              if (!(k instanceof j)) throw new TypeError("Cannot call a class as a function");
            })(this, b), (O = (function(k, j, P) {
              return j = y(j), (function(R, I) {
                if (I && (u(I) == "object" || typeof I == "function")) return I;
                if (I !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(z) {
                  if (z === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return z;
                })(R);
              })(k, h() ? Reflect.construct(j, P || [], y(k).constructor) : j.apply(k, P));
            })(this, b, [$ = d(E) === "model" ? E.constructor.modelName + " validation failed" : "Validation failed"])).errors = {}, O._message = $, E && (E.$errors = O.errors), O;
          }
          return (function(E, O) {
            if (typeof O != "function" && O !== null) throw new TypeError("Super expression must either be null or a function");
            E.prototype = Object.create(O && O.prototype, { constructor: { value: E, writable: !0, configurable: !0 } }), Object.defineProperty(E, "prototype", { writable: !1 }), O && p(E, O);
          })(b, _), w = b, (A = [{ key: "toString", value: function() {
            return this.name + ": " + m(this);
          } }, { key: "inspect", value: function() {
            return Object.assign(new Error(this.message), this);
          } }, { key: "addError", value: function(E, O) {
            if (O instanceof b) for (var $ = O.errors, k = 0, j = Object.keys($); k < j.length; k++) {
              var P = j[k];
              this.addError("".concat(E, ".").concat(P), $[P]);
            }
            else this.errors[E] = O, this.message = this._message + ": " + m(this);
          } }]) && c(w.prototype, A), Object.defineProperty(w, "prototype", { writable: !1 }), w;
          var w, A;
        })(l);
        v.inspect.custom && (g.prototype[v.inspect.custom] = g.prototype.inspect), Object.defineProperty(g.prototype, "toJSON", { enumerable: !1, writable: !1, configurable: !0, value: function() {
          return Object.assign({}, this, { name: this.name, message: this.message });
        } }), Object.defineProperty(g.prototype, "name", { value: "ValidationError" }), o.exports = g;
      }, 6974: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "of", p), o.exports = y;
      }, 6996: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m, g) {
            var _;
            (function(w, A) {
              if (!(w instanceof A)) throw new TypeError("Cannot call a class as a function");
            })(this, l);
            var b = g.join(", ");
            return (_ = (function(w, A, E) {
              return A = f(A), (function(O, $) {
                if ($ && (u($) == "object" || typeof $ == "function")) return $;
                if ($ !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(k) {
                  if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return k;
                })(O);
              })(w, c() ? Reflect.construct(A, E || [], f(w).constructor) : A.apply(w, E));
            })(this, l, ['No matching document found for id "' + v._doc._id + '" version ' + m + ' modifiedPaths "' + b + '"'])).version = m, _.modifiedPaths = g, _;
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "VersionError" }), o.exports = y;
      }, 7045: (o, s, a) => {
        function u(b) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
            return typeof w;
          } : function(w) {
            return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
          }, u(b);
        }
        function c(b, w) {
          var A = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var E = Object.getOwnPropertySymbols(b);
            w && (E = E.filter(function(O) {
              return Object.getOwnPropertyDescriptor(b, O).enumerable;
            })), A.push.apply(A, E);
          }
          return A;
        }
        function f(b) {
          for (var w = 1; w < arguments.length; w++) {
            var A = arguments[w] != null ? arguments[w] : {};
            w % 2 ? c(Object(A), !0).forEach(function(E) {
              h(b, E, A[E]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(A)) : c(Object(A)).forEach(function(E) {
              Object.defineProperty(b, E, Object.getOwnPropertyDescriptor(A, E));
            });
          }
          return b;
        }
        function h(b, w, A) {
          return (w = (function(E) {
            var O = (function($) {
              if (u($) != "object" || !$) return $;
              var k = $[Symbol.toPrimitive];
              if (k !== void 0) {
                var j = k.call($, "string");
                if (u(j) != "object") return j;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String($);
            })(E);
            return u(O) == "symbol" ? O : O + "";
          })(w)) in b ? Object.defineProperty(b, w, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : b[w] = A, b;
        }
        var y = a(6426), p = y.CastError, l = a(9553), d = a(4327), v = a(3305);
        function m(b, w) {
          y.call(this, b, w, "Decimal128");
        }
        function g(b) {
          return this.cast(b);
        }
        m.schemaName = "Decimal128", m.defaultOptions = {}, m.prototype = Object.create(y.prototype), m.prototype.constructor = m, m._cast = l, m.set = y.set, m.setters = [], m.get = y.get, m.cast = function(b) {
          return arguments.length === 0 || (b === !1 && (b = this._defaultCaster), this._cast = b), this._cast;
        }, m._defaultCaster = function(b) {
          if (b != null && !v(b, "Decimal128")) throw new Error();
          return b;
        }, m._checkRequired = function(b) {
          return v(b, "Decimal128");
        }, m.checkRequired = y.checkRequired, m.prototype.checkRequired = function(b, w) {
          return y._isRef(this, b, w, !0) ? !!b : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : m.checkRequired())(b);
        }, m.prototype.cast = function(b, w, A, E, O) {
          if (y._isRef(this, b, w, A)) return v(b, "Decimal128") ? b : this._castRef(b, w, A, O);
          var $;
          $ = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : m.cast();
          try {
            return $(b);
          } catch (k) {
            throw new p("Decimal128", b, this.path, k, this);
          }
        };
        var _ = f(f({}, y.prototype.$conditionalHandlers), {}, { $gt: g, $gte: g, $lt: g, $lte: g });
        Object.defineProperty(m.prototype, "$conditionalHandlers", { enumerable: !1, value: _ }), m.prototype.toJSONSchema = function(b) {
          var w = this.options.required && typeof this.options.required != "function";
          return d("string", "decimal", b?.useBsonType, w);
        }, m.prototype.autoEncryptionType = function() {
          return "decimal";
        }, o.exports = m;
      }, 7058: (o, s, a) => {
        var u = a(5832).hp;
        function c(q) {
          return (function(G) {
            if (Array.isArray(G)) return m(G);
          })(q) || (function(G) {
            if (typeof Symbol < "u" && G[Symbol.iterator] != null || G["@@iterator"] != null) return Array.from(G);
          })(q) || v(q) || (function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })();
        }
        function f(q, G) {
          var ce = Object.keys(q);
          if (Object.getOwnPropertySymbols) {
            var ue = Object.getOwnPropertySymbols(q);
            G && (ue = ue.filter(function(re) {
              return Object.getOwnPropertyDescriptor(q, re).enumerable;
            })), ce.push.apply(ce, ue);
          }
          return ce;
        }
        function h(q) {
          for (var G = 1; G < arguments.length; G++) {
            var ce = arguments[G] != null ? arguments[G] : {};
            G % 2 ? f(Object(ce), !0).forEach(function(ue) {
              y(q, ue, ce[ue]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(q, Object.getOwnPropertyDescriptors(ce)) : f(Object(ce)).forEach(function(ue) {
              Object.defineProperty(q, ue, Object.getOwnPropertyDescriptor(ce, ue));
            });
          }
          return q;
        }
        function y(q, G, ce) {
          return (G = (function(ue) {
            var re = (function(pe) {
              if (p(pe) != "object" || !pe) return pe;
              var xe = pe[Symbol.toPrimitive];
              if (xe !== void 0) {
                var be = xe.call(pe, "string");
                if (p(be) != "object") return be;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(pe);
            })(ue);
            return p(re) == "symbol" ? re : re + "";
          })(G)) in q ? Object.defineProperty(q, G, { value: ce, enumerable: !0, configurable: !0, writable: !0 }) : q[G] = ce, q;
        }
        function p(q) {
          return p = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(G) {
            return typeof G;
          } : function(G) {
            return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G;
          }, p(q);
        }
        function l(q, G) {
          return (function(ce) {
            if (Array.isArray(ce)) return ce;
          })(q) || (function(ce, ue) {
            var re = ce == null ? null : typeof Symbol < "u" && ce[Symbol.iterator] || ce["@@iterator"];
            if (re != null) {
              var pe, xe, be, Ee, Ue = [], Ae = !0, Me = !1;
              try {
                if (be = (re = re.call(ce)).next, ue === 0) {
                  if (Object(re) !== re) return;
                  Ae = !1;
                } else for (; !(Ae = (pe = be.call(re)).done) && (Ue.push(pe.value), Ue.length !== ue); Ae = !0) ;
              } catch (et) {
                Me = !0, xe = et;
              } finally {
                try {
                  if (!Ae && re.return != null && (Ee = re.return(), Object(Ee) !== Ee)) return;
                } finally {
                  if (Me) throw xe;
                }
              }
              return Ue;
            }
          })(q, G) || v(q, G) || (function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })();
        }
        function d(q, G) {
          var ce = typeof Symbol < "u" && q[Symbol.iterator] || q["@@iterator"];
          if (!ce) {
            if (Array.isArray(q) || (ce = v(q)) || G) {
              ce && (q = ce);
              var ue = 0, re = function() {
              };
              return { s: re, n: function() {
                return ue >= q.length ? { done: !0 } : { done: !1, value: q[ue++] };
              }, e: function(Ee) {
                throw Ee;
              }, f: re };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var pe, xe = !0, be = !1;
          return { s: function() {
            ce = ce.call(q);
          }, n: function() {
            var Ee = ce.next();
            return xe = Ee.done, Ee;
          }, e: function(Ee) {
            be = !0, pe = Ee;
          }, f: function() {
            try {
              xe || ce.return == null || ce.return();
            } finally {
              if (be) throw pe;
            }
          } };
        }
        function v(q, G) {
          if (q) {
            if (typeof q == "string") return m(q, G);
            var ce = {}.toString.call(q).slice(8, -1);
            return ce === "Object" && q.constructor && (ce = q.constructor.name), ce === "Map" || ce === "Set" ? Array.from(q) : ce === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ce) ? m(q, G) : void 0;
          }
        }
        function m(q, G) {
          (G == null || G > q.length) && (G = q.length);
          for (var ce = 0, ue = Array(G); ce < G; ce++) ue[ce] = q[ce];
          return ue;
        }
        var g, _ = a(3550).EventEmitter, b = a(8297), w = a(8213), A = a(6426), E = a(8879), O = a(2069), $ = a(622), k = a(486), j = a(4450), P = a(3703), R = a(8260), I = a(2003), z = a(5289), W = a(3381), F = a(1199), te = a(9539), ee = a(5678), V = a(7834), T = a(2097), D = a(8768), L = a(533), M = /\.\d+(\.|$)/, N = a(1260).Ut, Z = a(4957).middlewareFunctions, Y = N.concat(Z).reduce(function(q, G) {
          return q.add(G);
        }, /* @__PURE__ */ new Set()), ie = D.isPOJO, le = 0, de = /^\d+$/;
        function ae(q, G) {
          if (!(this instanceof ae)) return new ae(q, G);
          if (this.obj = q, this.paths = {}, this.aliases = {}, this.subpaths = {}, this.virtuals = {}, this.singleNestedPaths = {}, this.nested = {}, this.inherits = {}, this.callQueue = [], this._indexes = [], this._searchIndexes = [], this.methods = G && G.methods || {}, this.methodOptions = {}, this.statics = G && G.statics || {}, this.tree = {}, this.query = G && G.query || {}, this.childSchemas = [], this.plugins = [], this.$id = ++le, this.mapPaths = [], this.encryptedFields = {}, this.s = { hooks: new b() }, this.options = this.defaultOptions(G), Array.isArray(q)) {
            var ce, ue = d(q);
            try {
              for (ue.s(); !(ce = ue.n()).done; ) {
                var re = ce.value;
                this.add(re);
              }
            } catch (et) {
              ue.e(et);
            } finally {
              ue.f();
            }
          } else q && this.add(q);
          if (G && G.virtuals) for (var pe = G.virtuals, xe = 0, be = Object.keys(pe); xe < be.length; xe++) {
            var Ee = be[xe], Ue = pe[Ee].options ? pe[Ee].options : void 0, Ae = this.virtual(Ee, Ue);
            pe[Ee].get && Ae.get(pe[Ee].get), pe[Ee].set && Ae.set(pe[Ee].set);
          }
          var Me = q && q._id && D.isObject(q._id);
          !this.paths._id && this.options._id && !Me && k(this), this.setupTimestamp(this.options.timestamps);
        }
        function ne(q, G) {
          for (var ce = 0, ue = Object.keys(G); ce < ue.length; ce++) {
            var re = ue[ce], pe = null;
            if (G[re] != null) pe = G[re];
            else {
              var xe = P(q.paths[re], "options");
              if (xe == null) continue;
              pe = xe.alias;
            }
            if (pe) {
              var be = q.paths[re].path;
              if (Array.isArray(pe)) {
                var Ee, Ue = d(pe);
                try {
                  for (Ue.s(); !(Ee = Ue.n()).done; ) {
                    var Ae = Ee.value;
                    if (typeof Ae != "string") throw new Error("Invalid value for alias option on " + be + ", got " + Ae);
                    q.aliases[Ae] = be, q.virtual(Ae).get(/* @__PURE__ */ (function(Me) {
                      return function() {
                        return typeof this.get == "function" ? this.get(Me) : this[Me];
                      };
                    })(be)).set(/* @__PURE__ */ (function(Me) {
                      return function(et) {
                        return this.$set(Me, et);
                      };
                    })(be));
                  }
                } catch (Me) {
                  Ue.e(Me);
                } finally {
                  Ue.f();
                }
              } else {
                if (typeof pe != "string") throw new Error("Invalid value for alias option on " + be + ", got " + pe);
                q.aliases[pe] = be, q.virtual(pe).get(/* @__PURE__ */ (function(Me) {
                  return function() {
                    return typeof this.get == "function" ? this.get(Me) : this[Me];
                  };
                })(be)).set(/* @__PURE__ */ (function(Me) {
                  return function(et) {
                    return this.$set(Me, et);
                  };
                })(be));
              }
            }
          }
        }
        ae.prototype = Object.create(_.prototype), ae.prototype.constructor = ae, ae.prototype.instanceOfSchema = !0, Object.defineProperty(ae.prototype, "$schemaType", { configurable: !1, enumerable: !1, writable: !0 }), Object.defineProperty(ae.prototype, "childSchemas", { configurable: !1, enumerable: !0, writable: !0 }), Object.defineProperty(ae.prototype, "virtuals", { configurable: !1, enumerable: !0, writable: !0 }), ae.prototype.obj, ae.prototype.paths, ae.prototype.tree, ae.prototype.clone = function() {
          var q = this, G = this._clone();
          return G.on("init", function(ce) {
            return q.emit("init", ce);
          }), G;
        }, ae.prototype._clone = function(q) {
          var G = new (q = q || (this.base == null ? ae : this.base.Schema))({}, this._userProvidedOptions);
          G.base = this.base, G.obj = this.obj, G.options = j(this.options), G.callQueue = this.callQueue.map(function(Pt) {
            return Pt;
          }), G.methods = j(this.methods), G.methodOptions = j(this.methodOptions), G.statics = j(this.statics), G.query = j(this.query), G.plugins = Array.prototype.slice.call(this.plugins), G._indexes = j(this._indexes), G._searchIndexes = j(this._searchIndexes), G.s.hooks = this.s.hooks.clone(), G.tree = j(this.tree), G.paths = Object.fromEntries(Object.entries(this.paths).map(function(Pt) {
            var Tt = l(Pt, 2);
            return [Tt[0], Tt[1].clone()];
          })), G.nested = j(this.nested), G.subpaths = j(this.subpaths);
          for (var ce = 0, ue = Object.values(G.paths); ce < ue.length; ce++) {
            var re = ue[ce];
            if (re.$isSingleNested) {
              for (var pe = re.path, xe = 0, be = Object.keys(re.schema.paths); xe < be.length; xe++) {
                var Ee = be[xe];
                G.singleNestedPaths[pe + "." + Ee] = re.schema.paths[Ee];
              }
              for (var Ue = 0, Ae = Object.keys(re.schema.singleNestedPaths); Ue < Ae.length; Ue++) {
                var Me = Ae[Ue];
                G.singleNestedPaths[pe + "." + Me] = re.schema.singleNestedPaths[Me];
              }
              for (var et = 0, lt = Object.keys(re.schema.subpaths); et < lt.length; et++) {
                var ft = lt[et];
                G.singleNestedPaths[pe + "." + ft] = re.schema.subpaths[ft];
              }
              for (var Ke = 0, Xt = Object.keys(re.schema.nested); Ke < Xt.length; Ke++) {
                var $t = Xt[Ke];
                G.singleNestedPaths[pe + "." + $t] = "nested";
              }
            }
          }
          return G._gatherChildSchemas(), G.virtuals = j(this.virtuals), G.$globalPluginsApplied = this.$globalPluginsApplied, G.$isRootDiscriminator = this.$isRootDiscriminator, G.$implicitlyCreated = this.$implicitlyCreated, G.$id = ++le, G.$originalSchemaId = this.$id, G.mapPaths = [].concat(this.mapPaths), this.discriminatorMapping != null && (G.discriminatorMapping = Object.assign({}, this.discriminatorMapping)), this.discriminators != null && (G.discriminators = Object.assign({}, this.discriminators)), this._applyDiscriminators != null && (G._applyDiscriminators = new Map(this._applyDiscriminators)), G.aliases = Object.assign({}, this.aliases), G.encryptedFields = j(this.encryptedFields), G;
        }, ae.prototype.pick = function(q, G) {
          var ce = new ae({}, G || this.options);
          if (!Array.isArray(q)) throw new w('Schema#pick() only accepts an array argument, got "' + p(q) + '"');
          var ue, re = d(q);
          try {
            for (re.s(); !(ue = re.n()).done; ) {
              var pe = ue.value;
              if (this._hasEncryptedField(pe)) {
                var xe = this.encryptedFields[pe], be = this.path(pe);
                ce.add(y({}, pe, y({ encrypt: xe }, this.options.typeKey, be)));
              } else if (this.nested[pe]) ce.add(y({}, pe, P(this.tree, pe)));
              else {
                var Ee = this.path(pe);
                if (Ee == null) throw new w("Path `" + pe + "` is not in the schema");
                ce.add(y({}, pe, Ee));
              }
            }
          } catch (Ue) {
            re.e(Ue);
          } finally {
            re.f();
          }
          return this._hasEncryptedFields() || (ce.options.encryptionType = null), ce;
        }, ae.prototype.omit = function(q, G) {
          var ce = new ae(this, G || this.options);
          if (!Array.isArray(q)) throw new w('Schema#omit() only accepts an array argument, got "' + p(q) + '"');
          for (var ue in ce.remove(q), ce.singleNestedPaths) q.includes(ue) && delete ce.singleNestedPaths[ue];
          return ce;
        }, ae.prototype.defaultOptions = function(q) {
          this._userProvidedOptions = q == null ? {} : j(q);
          var G = this.base && this.base.options || {};
          if ((q = h({ strict: !("strict" in G) || G.strict, strictQuery: "strictQuery" in G && G.strictQuery, bufferCommands: !0, capped: !1, versionKey: "__v", optimisticConcurrency: !1, minimize: !0, autoIndex: null, discriminatorKey: "__t", shardKey: null, read: null, validateBeforeSave: !0, validateModifiedOnly: !1, _id: !0, id: !("id" in G) || G.id, typeKey: "type" }, q)).versionKey && typeof q.versionKey != "string") throw new w("`versionKey` must be falsy or string, got `" + p(q.versionKey) + "`");
          if (typeof q.read == "string" ? q.read = z(q.read) : Array.isArray(q.read) && typeof q.read[0] == "string" && (q.read = { mode: z(q.read[0]), tags: q.read[1] }), q.optimisticConcurrency && !q.versionKey) throw new w("Must set `versionKey` if using `optimisticConcurrency`");
          return q;
        }, ae.prototype.discriminator = function(q, G, ce) {
          return this._applyDiscriminators = this._applyDiscriminators || /* @__PURE__ */ new Map(), this._applyDiscriminators.set(q, { schema: G, options: ce }), this;
        }, ae.prototype._defaultToObjectOptions = function(q) {
          var G = q ? "toJSON" : "toObject";
          if (this._defaultToObjectOptionsMap && this._defaultToObjectOptionsMap[G]) return this._defaultToObjectOptionsMap[G];
          var ce = this.base && this.base.options && this.base.options[G] || {}, ue = this.options[G] || {}, re = Object.assign({}, ce, ue);
          return this._defaultToObjectOptionsMap = this._defaultToObjectOptionsMap || {}, this._defaultToObjectOptionsMap[G] = re, re;
        }, ae.prototype.encryptionType = function(q) {
          if (arguments.length === 0) return this.options.encryptionType;
          if (typeof q != "string" && q !== null) throw new Error("invalid `encryptionType`: ${encryptionType}");
          this.options.encryptionType = q;
        }, ae.prototype.add = function(q, G) {
          if (q instanceof ae || q != null && q.instanceOfSchema) return te(this, q), this;
          if (q._id === !1 && G == null && (this.options._id = !1), (G = G || "") === "__proto__." || G === "constructor." || G === "prototype.") return this;
          for (var ce = Object.keys(q), ue = this.options.typeKey, re = 0, pe = ce; re < pe.length; re++) {
            var xe = pe[re];
            if (!D.specialProperties.has(xe)) {
              var be = G + xe, Ee = q[xe];
              if (Ee == null) throw new TypeError("Invalid value for schema path `" + be + '`, got value "' + Ee + '"');
              if (xe !== "_id" || Ee !== !1) {
                var Ue = !1;
                if (typeof Ee == "string" && (Ue = (this.base != null ? this.base.Schema.Types : ae.Types)[Ee.charAt(0).toUpperCase() + Ee.substring(1)] != null), xe !== "_id" && (p(Ee) !== "object" && typeof Ee != "function" && !Ue || Ee == null)) throw new TypeError("Invalid schema configuration: `".concat(Ee, "` is not ") + "a valid type at path `".concat(xe, "`. See ") + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
                if (Ee instanceof $ || (Ee.constructor && Ee.constructor.name || null) === "VirtualType") this.virtual(Ee);
                else {
                  if (Array.isArray(Ee) && Ee.length === 1 && Ee[0] == null) throw new TypeError("Invalid value for schema Array path `" + be + '`, got value "' + Ee[0] + '"');
                  if (ie(Ee) || Ee instanceof E) if (Object.keys(Ee).length < 1) G && (this.nested[G.substring(0, G.length - 1)] = !0), this.path(be, Ee);
                  else if (!Ee[ue] || ue === "type" && ie(Ee.type) && Ee.type.type) this.nested[be] = !0, this.add(Ee, be + ".");
                  else {
                    var Ae = Ee[ue];
                    if (ie(Ae) && Object.keys(Ae).length > 0) {
                      G && (this.nested[G.substring(0, G.length - 1)] = !0);
                      var Me = {};
                      this._userProvidedOptions.typeKey && (Me.typeKey = this._userProvidedOptions.typeKey), this._userProvidedOptions.strict != null && (Me.strict = this._userProvidedOptions.strict), this._userProvidedOptions.toObject != null && (Me.toObject = D.omit(this._userProvidedOptions.toObject, ["transform"])), this._userProvidedOptions.toJSON != null && (Me.toJSON = D.omit(this._userProvidedOptions.toJSON, ["transform"]));
                      var et = new ae(Ae, Me);
                      et.$implicitlyCreated = !0;
                      var lt = Object.assign({}, Ee, y({}, ue, et));
                      this.path(G + xe, lt);
                    } else if (G && (this.nested[G.substring(0, G.length - 1)] = !0), this.path(G + xe, Ee), Ee != null && !Ee.instanceOfSchema && D.isPOJO(Ee.discriminators)) {
                      var ft = this.path(G + xe);
                      for (var Ke in Ee.discriminators) ft.discriminator(Ke, Ee.discriminators[Ke]);
                    }
                  }
                  else if (G && (this.nested[G.substring(0, G.length - 1)] = !0), this.path(G + xe, Ee), Ee[0] != null && !Ee[0].instanceOfSchema && D.isPOJO(Ee[0].discriminators)) {
                    var Xt = this.path(G + xe);
                    for (var $t in Ee[0].discriminators) Xt.discriminator($t, Ee[0].discriminators[$t]);
                  }
                  if (Ee.instanceOfSchema && Ee.encryptionType() != null) {
                    if (this.encryptionType() != Ee.encryptionType()) throw new Error("encryptionType of a nested schema must match the encryption type of the parent schema.");
                    for (var Pt = 0, Tt = Object.entries(Ee.encryptedFields); Pt < Tt.length; Pt++) {
                      var Ft = l(Tt[Pt], 2), xt = Ft[0], ir = Ft[1], Le = be + "." + xt;
                      this._addEncryptedField(Le, ir);
                    }
                  } else if (p(Ee) === "object" && "encrypt" in Ee) {
                    var Pr = Ee.encrypt;
                    if (this.encryptionType() == null) throw new Error("encryptionType must be provided");
                    this._addEncryptedField(be, Pr);
                  } else this._removeEncryptedField(be);
                }
              }
            }
          }
          var It = Object.fromEntries(Object.entries(q).map(function(je) {
            var qr = l(je, 1)[0];
            return [G + qr, null];
          }));
          return ne(this, It), this;
        }, ae.prototype._addEncryptedField = function(q, G) {
          if (this.path(q).autoEncryptionType() == null) throw new Error("Invalid BSON type for FLE field: '".concat(q, "'"));
          this.encryptedFields[q] = j(G);
        }, ae.prototype._removeEncryptedField = function(q) {
          delete this.encryptedFields[q];
        }, ae.prototype._hasEncryptedFields = function() {
          return Object.keys(this.encryptedFields).length > 0;
        }, ae.prototype._hasEncryptedField = function(q) {
          return q in this.encryptedFields;
        }, ae.prototype._buildEncryptedFields = function() {
          var q = this;
          return { fields: Object.entries(this.encryptedFields).map(function(G) {
            var ce = l(G, 2), ue = ce[0], re = ce[1];
            return h({ path: ue, bsonType: q.path(ue).autoEncryptionType() }, re);
          }) };
        }, ae.prototype._buildSchemaMap = function() {
          var q = this;
          return { bsonType: "object", properties: Object.entries(this.encryptedFields).reduce(function(G, ce) {
            var ue = l(ce, 2), re = ue[0], pe = ue[1], xe = q.path(re).autoEncryptionType();
            return (function(be, Ee, Ue) {
              for (var Ae = 0, Me = be[Ae]; Ae < be.length - 1; Me = be[++Ae]) Ee[Me] = Ee[Me] == null ? { bsonType: "object", properties: {} } : Ee[Me], Ee = Ee[Me].properties;
              Ee[Me] = Ue;
            })(re.split("."), G, { encrypt: h(h({}, pe), {}, { bsonType: xe }) }), G;
          }, {}) };
        }, ae.prototype.alias = function(q, G) {
          return ne(this, y({}, q, G)), this;
        }, ae.prototype.removeIndex = function(q) {
          if (arguments.length > 1) throw new Error("removeIndex() takes only 1 argument");
          if (p(q) !== "object" && typeof q != "string") throw new Error("removeIndex() may only take either an object or a string as an argument");
          if (p(q) === "object") for (var G = this._indexes.length - 1; G >= 0; --G) F(this._indexes[G][0], q) && this._indexes.splice(G, 1);
          else for (var ce = this._indexes.length - 1; ce >= 0; --ce) this._indexes[ce][1] != null && this._indexes[ce][1].name === q && this._indexes.splice(ce, 1);
          return this;
        }, ae.prototype.clearIndexes = function() {
          return this._indexes.length = 0, this;
        }, ae.prototype.searchIndex = function(q) {
          return this._searchIndexes.push(q), this;
        }, ae.reserved = /* @__PURE__ */ Object.create(null), ae.prototype.reserved = ae.reserved;
        var he = ae.reserved;
        function x(q) {
          return /\.\d+/.test(q) ? q.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$") : q;
        }
        function U(q, G) {
          if (q.mapPaths.length === 0) return null;
          var ce, ue = d(q.mapPaths);
          try {
            for (ue.s(); !(ce = ue.n()).done; ) {
              var re = ce.value, pe = re.path.replace(/\.\$\*/g, "");
              if (G === pe || G.startsWith(pe + ".") && G.slice(pe.length + 1).indexOf(".") === -1) return re;
              if (re.schema && G.startsWith(pe + ".")) {
                var xe = G.slice(pe.length + 1);
                return xe = xe.slice(xe.indexOf(".") + 1), re.schema.paths[xe];
              }
              if (re.$isSchemaMap && G.startsWith(pe + ".")) {
                var be = G.slice(pe.length + 1);
                be = be.slice(be.indexOf(".") + 1);
                var Ee = re.$__schemaType._presplitPath;
                if (be.indexOf(".") === -1 && Ee[Ee.length - 1] === "$*") return re.$__schemaType;
                if (be.indexOf(".") !== -1 && re.$__schemaType.schema && Ee[Ee.length - 1] === "$*") return re.$__schemaType.schema.path(be.slice(be.indexOf(".") + 1));
              }
            }
          } catch (Ue) {
            ue.e(Ue);
          } finally {
            ue.f();
          }
          return null;
        }
        function B(q, G, ce) {
          var ue = G.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
          if (ue.length < 2) return q.paths.hasOwnProperty(ue[0]) ? q.paths[ue[0]] : "adhocOrUndefined";
          var re = q.path(ue[0]), pe = !1;
          if (!re) return "adhocOrUndefined";
          for (var xe = ue.length - 1, be = 1; be < ue.length; ++be) {
            pe = !1;
            var Ee = ue[be];
            if (be === xe && re && !/\D/.test(Ee)) {
              re = re.$isMongooseDocumentArray ? re.$embeddedSchemaType : re instanceof g.Array ? re.caster : void 0;
              break;
            }
            if (/\D/.test(Ee)) {
              if (!re || !re.schema) {
                re = void 0;
                break;
              }
              pe = re.schema.pathType(Ee) === "nested", re = re.schema.path(Ee);
            } else re instanceof g.Array && be !== xe && (re = re.caster);
          }
          return q.subpaths[ce] = re, re ? "real" : pe ? "nested" : "adhocOrUndefined";
        }
        function J(q, G) {
          var ce, ue = d(q.childSchemas);
          try {
            for (ue.s(); !(ce = ue.n()).done; ) {
              var re = ce.value.schema;
              re.$implicitlyCreated && (Object.assign(re.options, G), J(re, G));
            }
          } catch (pe) {
            ue.e(pe);
          } finally {
            ue.f();
          }
        }
        he.prototype = he.emit = he.listeners = he.removeListener = he.collection = he.errors = he.get = he.init = he.isModified = he.isNew = he.populated = he.remove = he.save = he.toObject = he.validate = 1, he.collection = 1, ae.prototype.path = function(q, G) {
          if (G === void 0) {
            if (this.paths[q] != null) return this.paths[q];
            var ce = x(q), ue = (function(fe, Pe, De) {
              if (fe.paths.hasOwnProperty(Pe)) return fe.paths[Pe];
              if (fe.subpaths.hasOwnProperty(De)) {
                var We = fe.subpaths[De];
                return We === "nested" ? void 0 : We;
              }
              if (fe.singleNestedPaths.hasOwnProperty(De) && p(fe.singleNestedPaths[De]) === "object") {
                var Qe = fe.singleNestedPaths[De];
                return Qe === "nested" ? void 0 : Qe;
              }
              return null;
            })(this, q, ce);
            if (ue != null) return ue;
            var re = U(this, q);
            return re ?? ((ue = this.hasMixedParent(ce)) != null ? ue : M.test(q) ? (function(fe, Pe, De) {
              return B(fe, Pe, De), fe.subpaths[De];
            })(this, q, ce) : void 0);
          }
          var pe = q.split(".")[0];
          if (he[pe] && !this.options.suppressReservedKeysWarning) {
            var xe = "`".concat(pe, "` is a reserved schema pathname and may break some functionality. ") + "You are allowed to use it, but use at your own risk. To disable this warning pass `suppressReservedKeysWarning` as a schema option.";
            D.warn(xe);
          }
          p(G) === "object" && D.hasUserDefinedProperty(G, "ref") && L(G.ref, q);
          var be, Ee = q.split(/\./), Ue = Ee.pop(), Ae = this.tree, Me = "", et = d(Ee);
          try {
            for (et.s(); !(be = et.n()).done; ) {
              var lt = be.value;
              if (D.specialProperties.has(lt)) throw new Error("Cannot set special property `" + lt + "` on a schema");
              if (Me = Me += (Me.length > 0 ? "." : "") + lt, Ae[lt] || (this.nested[Me] = !0, Ae[lt] = {}), p(Ae[lt]) !== "object") {
                var ft = "Cannot set nested path `" + q + "`. Parent path `" + Me + "` already set to type " + Ae[lt].name + ".";
                throw new Error(ft);
              }
              Ae = Ae[lt];
            }
          } catch (fe) {
            et.e(fe);
          } finally {
            et.f();
          }
          Ae[Ue] = j(G), this.paths[q] = this.interpretAsType(q, G, this.options);
          var Ke = this.paths[q];
          if (this.childSchemas = this.childSchemas.filter(function(fe) {
            return fe.path !== q;
          }), Ke.$isSchemaMap) {
            var Xt = q + ".$*";
            this.paths[Xt] = Ke.$__schemaType, this.mapPaths.push(this.paths[Xt]), Ke.$__schemaType.$isSingleNested && this.childSchemas.push({ schema: Ke.$__schemaType.schema, model: Ke.$__schemaType.caster, path: q });
          }
          if (Ke.$isSingleNested) {
            for (var $t = 0, Pt = Object.keys(Ke.schema.paths); $t < Pt.length; $t++) {
              var Tt = Pt[$t];
              this.singleNestedPaths[q + "." + Tt] = Ke.schema.paths[Tt];
            }
            for (var Ft = 0, xt = Object.keys(Ke.schema.singleNestedPaths); Ft < xt.length; Ft++) {
              var ir = xt[Ft];
              this.singleNestedPaths[q + "." + ir] = Ke.schema.singleNestedPaths[ir];
            }
            for (var Le = 0, Pr = Object.keys(Ke.schema.subpaths); Le < Pr.length; Le++) {
              var It = Pr[Le];
              this.singleNestedPaths[q + "." + It] = Ke.schema.subpaths[It];
            }
            for (var je = 0, qr = Object.keys(Ke.schema.nested); je < qr.length; je++) {
              var Cn = qr[je];
              this.singleNestedPaths[q + "." + Cn] = "nested";
            }
            Object.defineProperty(Ke.schema, "base", { configurable: !0, enumerable: !1, writable: !1, value: this.base }), Ke.caster.base = this.base, this.childSchemas.push({ schema: Ke.schema, model: Ke.caster, path: q });
          } else Ke.$isMongooseDocumentArray && (Object.defineProperty(Ke.schema, "base", { configurable: !0, enumerable: !1, writable: !1, value: this.base }), Ke.casterConstructor.base = this.base, this.childSchemas.push({ schema: Ke.schema, model: Ke.casterConstructor, path: q }));
          if (Ke.$isMongooseArray && Ke.caster instanceof A) {
            for (var Wr = q, or = Ke; or.$isMongooseArray; ) Wr += ".$", or.$isMongooseDocumentArray ? (or.$embeddedSchemaType._arrayPath = Wr, or.$embeddedSchemaType._arrayParentPath = q, or = or.$embeddedSchemaType) : (or.caster._arrayPath = Wr, or.caster._arrayParentPath = q, or = or.caster), this.subpaths[Wr] = or;
            for (var Gr = 0, ti = []; Gr < ti.length; Gr++) {
              var mr = ti[Gr];
              this.subpaths[mr.path] = mr;
            }
          }
          if (Ke.$isMongooseDocumentArray) {
            for (var on = 0, K = Object.keys(Ke.schema.paths); on < K.length; on++) {
              var se = K[on], me = Ke.schema.paths[se];
              this.subpaths[q + "." + se] = me, p(me) === "object" && me != null && me.$parentSchemaDocArray == null && (me.$parentSchemaDocArray = Ke);
            }
            for (var ge = 0, _e = Object.keys(Ke.schema.subpaths); ge < _e.length; ge++) {
              var $e = _e[ge], Te = Ke.schema.subpaths[$e];
              this.subpaths[q + "." + $e] = Te, p(Te) === "object" && Te != null && Te.$parentSchemaDocArray == null && (Te.$parentSchemaDocArray = Ke);
            }
            for (var Ie = 0, qe = Object.keys(Ke.schema.singleNestedPaths); Ie < qe.length; Ie++) {
              var Fe = qe[Ie], Ne = Ke.schema.singleNestedPaths[Fe];
              this.subpaths[q + "." + Fe] = Ne, p(Ne) === "object" && Ne != null && Ne.$parentSchemaDocArray == null && (Ne.$parentSchemaDocArray = Ke);
            }
          }
          return this;
        }, ae.prototype._gatherChildSchemas = function() {
          for (var q = [], G = 0, ce = Object.keys(this.paths); G < ce.length; G++) {
            var ue = ce[G];
            if (typeof ue == "string") {
              var re = this.paths[ue];
              re.$isMongooseDocumentArray || re.$isSingleNested ? q.push({ schema: re.schema, model: re.caster, path: ue }) : re.$isSchemaMap && re.$__schemaType.$isSingleNested && q.push({ schema: re.$__schemaType.schema, model: re.$__schemaType.caster, path: ue });
            }
          }
          return this.childSchemas = q, q;
        }, Object.defineProperty(ae.prototype, "base", { configurable: !0, enumerable: !1, writable: !0, value: null }), ae.prototype.interpretAsType = function(q, G, ce) {
          if (G instanceof A) {
            if (G.path === q) return G;
            var ue = G.clone();
            return ue.path = q, ue;
          }
          var re = this.base != null ? this.base.Schema.Types : ae.Types, pe = this.base != null ? this.base.Types : a(9600);
          if (!(D.isPOJO(G) || G instanceof E) && D.getFunctionName(G.constructor) !== "Object") {
            var xe = G;
            (G = {})[ce.typeKey] = xe;
          }
          var be, Ee = G[ce.typeKey] && (G[ce.typeKey] instanceof Function || ce.typeKey !== "type" || !G.type.type) ? G[ce.typeKey] : {};
          if (Ee instanceof A) {
            if (Ee.path === q) return Ee;
            var Ue = Ee.clone();
            return Ue.path = q, Ue;
          }
          if (D.isPOJO(Ee) || Ee === "mixed") return new re.Mixed(q, G);
          if (Array.isArray(Ee) || Ee === Array || Ee === "array" || Ee === re.Array) {
            var Ae = Ee === Array || Ee === "array" ? G.cast || G.of : Ee[0];
            if (Ae && Ae.instanceOfSchema) {
              if (!(Ae instanceof ae)) {
                if (!this.options._isMerging) throw new TypeError("Schema for array path `" + q + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + "".concat(q, ": new Schema(...)"));
                Ae = new ae(Ae);
              }
              return new re.DocumentArray(q, Ae, G);
            }
            if (Ae && Ae[ce.typeKey] && Ae[ce.typeKey].instanceOfSchema) {
              if (!(Ae[ce.typeKey] instanceof ae)) {
                if (!this.options._isMerging) throw new TypeError("Schema for array path `" + q + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + "".concat(q, ": new Schema(...)"));
                Ae[ce.typeKey] = new ae(Ae[ce.typeKey]);
              }
              return new re.DocumentArray(q, Ae[ce.typeKey], G, Ae);
            }
            if (Ae !== void 0 && (Array.isArray(Ae) || Ae.type === Array || Ae.type == "Array")) return Ae && Ae.type == "Array" && (Ae.type = Array), new re.Array(q, this.interpretAsType(q, Ae, ce), G);
            var Me = Ae == null || !Ae[ce.typeKey] || ce.typeKey === "type" && Ae.type.type ? Ae : Ae[ce.typeKey];
            if (typeof Ae == "string") Ae = re[Ae.charAt(0).toUpperCase() + Ae.substring(1)];
            else if (D.isPOJO(Me)) {
              if (Object.keys(Me).length) {
                var et = { minimize: ce.minimize };
                ce.typeKey && (et.typeKey = ce.typeKey), ce.hasOwnProperty("strict") && (et.strict = ce.strict), ce.hasOwnProperty("strictQuery") && (et.strictQuery = ce.strictQuery), ce.hasOwnProperty("toObject") && (et.toObject = D.omit(ce.toObject, ["transform"])), ce.hasOwnProperty("toJSON") && (et.toJSON = D.omit(ce.toJSON, ["transform"])), this._userProvidedOptions.hasOwnProperty("_id") ? et._id = this._userProvidedOptions._id : ae.Types.DocumentArray.defaultOptions._id != null && (et._id = ae.Types.DocumentArray.defaultOptions._id);
                var lt = new ae(Me, et);
                return lt.$implicitlyCreated = !0, new re.DocumentArray(q, lt, G);
              }
              return new re.Array(q, re.Mixed, G);
            }
            if (Ae) {
              if (Ee = !Ae[ce.typeKey] || ce.typeKey === "type" && Ae.type.type ? Ae : Ae[ce.typeKey], Array.isArray(Ee)) return new re.Array(q, this.interpretAsType(q, Ee, ce), G);
              if ((be = typeof Ee == "string" ? Ee : Ee.schemaName || D.getFunctionName(Ee)) === "ClockDate" && (be = "Date"), be === void 0) throw new TypeError("Invalid schema configuration: " + "Could not determine the embedded type for array `".concat(q, "`. ") + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
              if (!re.hasOwnProperty(be)) throw new TypeError("Invalid schema configuration: " + "`".concat(be, "` is not a valid type within the array `").concat(q, "`.") + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
            }
            return new re.Array(q, Ae || re.Mixed, G, ce);
          }
          if (Ee && Ee.instanceOfSchema) return new re.Subdocument(Ee, q, G);
          if ((be = u.isBuffer(Ee) ? "Buffer" : typeof Ee == "function" || p(Ee) === "object" ? Ee.schemaName || D.getFunctionName(Ee) : Ee === pe.ObjectId ? "ObjectId" : Ee === pe.Decimal128 ? "Decimal128" : Ee == null ? "" + Ee : Ee.toString()) && (be = be.charAt(0).toUpperCase() + be.substring(1)), be === "ObjectID" && (be = "ObjectId"), be === "ClockDate" && (be = "Date"), be === void 0) throw new TypeError("Invalid schema configuration: `".concat(q, "` schematype definition is ") + "invalid. See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
          if (re[be] == null) throw new TypeError("Invalid schema configuration: `".concat(be, "` is not ") + "a valid type at path `".concat(q, "`. See ") + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
          be === "Union" && (G.parentSchema = this);
          var ft = new re[be](q, G, ce);
          return ft.$isSchemaMap && (function(Ke, Xt, $t, Pt, Tt) {
            var Ft = $t + ".$*", xt = { type: {} };
            D.hasUserDefinedProperty(Pt, "of") && ((xt = D.isPOJO(Pt.of) && Object.keys(Pt.of).length > 0 && !D.hasUserDefinedProperty(Pt.of, Ke.options.typeKey) ? y({}, Ke.options.typeKey, new ae(Pt.of)) : D.isPOJO(Pt.of) ? Object.assign({}, Pt.of) : y({}, Ke.options.typeKey, Pt.of))[Ke.options.typeKey] && xt[Ke.options.typeKey].instanceOfSchema && xt[Ke.options.typeKey].eachPath(function(ir, Le) {
              if (Le.options.select === !0 || Le.options.select === !1) throw new w('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + $t + "." + ir + '"');
            }), D.hasUserDefinedProperty(Pt, "ref") && (xt.ref = Pt.ref)), Xt.$__schemaType = Ke.interpretAsType(Ft, xt, Tt);
          })(this, ft, q, G, ce), ft;
        }, ae.prototype.eachPath = function(q) {
          for (var G = Object.keys(this.paths), ce = G.length, ue = 0; ue < ce; ++ue) q(G[ue], this.paths[G[ue]]);
          return this;
        }, ae.prototype.requiredPaths = function(q) {
          if (this._requiredpaths && !q) return this._requiredpaths;
          for (var G = Object.keys(this.paths), ce = G.length, ue = []; ce--; ) {
            var re = G[ce];
            this.paths[re].isRequired && ue.push(re);
          }
          return this._requiredpaths = ue, this._requiredpaths;
        }, ae.prototype.indexedPaths = function() {
          return this._indexedpaths || (this._indexedpaths = this.indexes()), this._indexedpaths;
        }, ae.prototype.pathType = function(q) {
          if (this.paths.hasOwnProperty(q)) return "real";
          if (this.virtuals.hasOwnProperty(q)) return "virtual";
          if (this.nested.hasOwnProperty(q)) return "nested";
          var G = x(q);
          if (this.subpaths.hasOwnProperty(G) || this.subpaths.hasOwnProperty(q)) return "real";
          var ce = this.singleNestedPaths.hasOwnProperty(G) || this.singleNestedPaths.hasOwnProperty(q);
          return ce ? ce === "nested" ? "nested" : "real" : U(this, q) != null ? "real" : /\.\d+\.|\.\d+$/.test(q) ? B(this, q, G) : "adhocOrUndefined";
        }, ae.prototype.hasMixedParent = function(q) {
          var G = q.split(/\./g);
          q = "";
          for (var ce = 0; ce < G.length; ++ce) if (q = ce > 0 ? q + "." + G[ce] : G[ce], this.paths.hasOwnProperty(q) && this.paths[q] instanceof g.Mixed) return this.paths[q];
          return null;
        }, ae.prototype.setupTimestamp = function(q) {
          return T(this, q);
        }, ae.prototype.queue = function(q, G) {
          return this.callQueue.push([q, G]), this;
        }, ae.prototype.pre = function(q) {
          if (q instanceof RegExp) {
            var G, ce = Array.prototype.slice.call(arguments, 1), ue = d(Y);
            try {
              for (ue.s(); !(G = ue.n()).done; ) {
                var re = G.value;
                q.test(re) && this.pre.apply(this, [re].concat(ce));
              }
            } catch (Ue) {
              ue.e(Ue);
            } finally {
              ue.f();
            }
            return this;
          }
          if (Array.isArray(q)) {
            var pe, xe = Array.prototype.slice.call(arguments, 1), be = d(q);
            try {
              for (be.s(); !(pe = be.n()).done; ) {
                var Ee = pe.value;
                this.pre.apply(this, [Ee].concat(xe));
              }
            } catch (Ue) {
              be.e(Ue);
            } finally {
              be.f();
            }
            return this;
          }
          return this.s.hooks.pre.apply(this.s.hooks, arguments), this;
        }, ae.prototype.post = function(q) {
          if (q instanceof RegExp) {
            var G, ce = Array.prototype.slice.call(arguments, 1), ue = d(Y);
            try {
              for (ue.s(); !(G = ue.n()).done; ) {
                var re = G.value;
                q.test(re) && this.post.apply(this, [re].concat(ce));
              }
            } catch (Ue) {
              ue.e(Ue);
            } finally {
              ue.f();
            }
            return this;
          }
          if (Array.isArray(q)) {
            var pe, xe = Array.prototype.slice.call(arguments, 1), be = d(q);
            try {
              for (be.s(); !(pe = be.n()).done; ) {
                var Ee = pe.value;
                this.post.apply(this, [Ee].concat(xe));
              }
            } catch (Ue) {
              be.e(Ue);
            } finally {
              be.f();
            }
            return this;
          }
          return this.s.hooks.post.apply(this.s.hooks, arguments), this;
        }, ae.prototype.plugin = function(q, G) {
          if (typeof q != "function") throw new Error('First param to `schema.plugin()` must be a function, got "' + p(q) + '"');
          if (G && G.deduplicate) {
            var ce, ue = d(this.plugins);
            try {
              for (ue.s(); !(ce = ue.n()).done; ) if (ce.value.fn === q) return this;
            } catch (re) {
              ue.e(re);
            } finally {
              ue.f();
            }
          }
          return this.plugins.push({ fn: q, opts: G }), q(this, G), this;
        }, ae.prototype.method = function(q, G, ce) {
          if (typeof q != "string") for (var ue in q) this.methods[ue] = q[ue], this.methodOptions[ue] = j(ce);
          else this.methods[q] = G, this.methodOptions[q] = j(ce);
          return this;
        }, ae.prototype.static = function(q, G) {
          if (typeof q != "string") for (var ce in q) this.statics[ce] = q[ce];
          else this.statics[q] = G;
          return this;
        }, ae.prototype.index = function(q, G) {
          for (var ce in q || (q = {}), G || (G = {}), G.expires && D.expires(G), q) this.aliases[ce] && (q = D.renameObjKey(q, ce, this.aliases[ce]));
          for (var ue = 0, re = Object.keys(q); ue < re.length; ue++) {
            var pe = re[ue];
            q[pe] === "ascending" || q[pe] === "asc" ? q[pe] = 1 : q[pe] !== "descending" && q[pe] !== "desc" || (q[pe] = -1);
          }
          var xe, be = d(this.indexes());
          try {
            for (be.s(); !(xe = be.n()).done; ) {
              var Ee = xe.value;
              G.name == null && Ee[1].name == null && F(Ee[0], q) && D.warn("Duplicate schema index on ".concat(JSON.stringify(q), ' found. This is often due to declaring an index using both "index: true" and "schema.index()". Please remove the duplicate index definition.'));
            }
          } catch (Ue) {
            be.e(Ue);
          } finally {
            be.f();
          }
          return this._indexes.push([q, G]), this;
        }, ae.prototype.set = function(q, G, ce) {
          if (arguments.length === 1) return this.options[q];
          switch (q) {
            case "read":
              typeof G == "string" ? this.options[q] = { mode: z(G), tags: ce } : Array.isArray(G) && typeof G[0] == "string" ? this.options[q] = { mode: z(G[0]), tags: G[1] } : this.options[q] = G, this._userProvidedOptions[q] = this.options[q];
              break;
            case "timestamps":
              this.setupTimestamp(G), this.options[q] = G, this._userProvidedOptions[q] = this.options[q];
              break;
            case "_id":
              this.options[q] = G, this._userProvidedOptions[q] = this.options[q], G && !this.paths._id ? k(this) : !G && this.paths._id != null && this.paths._id.auto && this.remove("_id");
              break;
            default:
              this.options[q] = G, this._userProvidedOptions[q] = this.options[q];
          }
          return q === "strict" && J(this, { strict: G }), q === "strictQuery" && J(this, { strictQuery: G }), q === "toObject" && (delete (G = h({}, G)).transform, J(this, { toObject: G })), q === "toJSON" && (delete (G = h({}, G)).transform, J(this, { toJSON: G })), this;
        }, ae.prototype.get = function(q) {
          return this.options[q];
        };
        var X = "2d 2dsphere hashed text".split(" ");
        function oe(q, G) {
          var ce, ue = G.split("."), re = ue.pop(), pe = q.tree, xe = d(ue);
          try {
            for (xe.s(); !(ce = xe.n()).done; ) pe = pe[ce.value];
          } catch (be) {
            xe.e(be);
          } finally {
            xe.f();
          }
          delete pe[re];
        }
        function ye(q) {
          return q.startsWith("$[") && q.endsWith("]");
        }
        Object.defineProperty(ae, "indexTypes", { get: function() {
          return X;
        }, set: function() {
          throw new Error("Cannot overwrite Schema.indexTypes");
        } }), ae.prototype.indexes = function() {
          return I(this);
        }, ae.prototype.virtual = function(q, G) {
          if (q instanceof $ || R(q) === "VirtualType") return this.virtual(q.path, q.options);
          if (G = new O(G), D.hasUserDefinedProperty(G, ["ref", "refPath"])) {
            if (G.localField == null) throw new Error("Reference virtuals require `localField` option");
            if (G.foreignField == null) throw new Error("Reference virtuals require `foreignField` option");
            var ce = this.virtual(q);
            ce.options = G, this.pre("init", function(Me, et) {
              if (ee.has(q, Me)) {
                var lt = ee.get(q, Me);
                if (this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), G.justOne || G.count ? this.$$populatedVirtuals[q] = Array.isArray(lt) ? lt[0] : lt : this.$$populatedVirtuals[q] = Array.isArray(lt) ? lt : lt == null ? [] : [lt], et != null && et.hydratedPopulatedDocs && !G.count) {
                  var ft = ce._getModelNamesForPopulate(this), Ke = this.$$populatedVirtuals[q];
                  if (Array.isArray(Ke) || Ke.$__ || ft?.length !== 1) {
                    if (Array.isArray(Ke) && ft?.length === 1) {
                      for (var Xt = this.db.model(ft[0]), $t = 0; $t < Ke.length; ++$t) Ke[$t].$__ || (Ke[$t] = Xt.hydrate(Ke[$t], null, { hydratedPopulatedDocs: !0 }));
                      var Pt = G.foreignField;
                      this.$populated(q, Ke.map(function(Ft) {
                        return Ft == null ? Ft : Ft.get(typeof Pt == "function" ? Pt.call(Ft, Ft) : Pt);
                      }), { populateModelSymbol: Xt });
                    }
                  } else {
                    var Tt = this.db.model(ft[0]);
                    this.$$populatedVirtuals[q] = Tt.hydrate(Ke);
                  }
                }
                ee.unset(q, Me);
              }
            }), ce.set(function(Me) {
              return this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), V(this.$$populatedVirtuals, q, Me, G);
            }), typeof G.get == "function" && ce.get(G.get);
            for (var ue = q.split("."), re = ue[0], pe = 0; pe < ue.length - 1; ++pe) if (this.paths[re] != null) {
              if (this.paths[re].$isMongooseDocumentArray || this.paths[re].$isSingleNested) {
                var xe = ue.slice(pe + 1).join(".");
                this.paths[re].schema.virtual(xe, G);
                break;
              }
              if (this.paths[re].$isSchemaMap) {
                var be = ue.slice(pe + 2).join(".");
                this.paths[re].$__schemaType.schema.virtual(be, G);
                break;
              }
              re += "." + ue[pe + 1];
            }
            return ce;
          }
          var Ee = this.virtuals, Ue = q.split(".");
          if (this.pathType(q) === "real") throw new Error('Virtual path "' + q + '" conflicts with a real path in the schema');
          if (Ee[q] = Ue.reduce(function(Me, et, lt) {
            return Me[et] || (Me[et] = lt === Ue.length - 1 ? new $(G, q) : {}), Me[et];
          }, this.tree), G && G.applyToArray && Ue.length > 1) {
            var Ae = this.path(Ue.slice(0, -1).join("."));
            if (Ae && Ae.$isMongooseArray) return Ae.virtual(Ue[Ue.length - 1], G);
            throw new w('Path "'.concat(Ae, '" is not an array'));
          }
          return Ee[q];
        }, ae.prototype.virtualpath = function(q) {
          return this.virtuals.hasOwnProperty(q) ? this.virtuals[q] : null;
        }, ae.prototype.remove = function(q) {
          return typeof q == "string" && (q = [q]), Array.isArray(q) && q.forEach(function(G) {
            if (this.path(G) != null || this.nested[G]) {
              if (this.nested[G]) {
                var ce, ue = d(Object.keys(this.paths).concat(Object.keys(this.nested)));
                try {
                  for (ue.s(); !(ce = ue.n()).done; ) {
                    var re = ce.value;
                    re.startsWith(G + ".") && (delete this.paths[re], delete this.nested[re], oe(this, re));
                  }
                } catch (pe) {
                  ue.e(pe);
                } finally {
                  ue.f();
                }
                return delete this.nested[G], void oe(this, G);
              }
              delete this.paths[G], oe(this, G), this._removeEncryptedField(G);
            }
          }, this), this;
        }, ae.prototype.removeVirtual = function(q) {
          if (typeof q == "string" && (q = [q]), Array.isArray(q)) {
            var G, ce = d(q);
            try {
              for (ce.s(); !(G = ce.n()).done; ) {
                var ue = G.value;
                if (this.virtuals[ue] == null) throw new w('Attempting to remove virtual "'.concat(ue, '" that does not exist.'));
              }
            } catch (be) {
              ce.e(be);
            } finally {
              ce.f();
            }
            var re, pe = d(q);
            try {
              for (pe.s(); !(re = pe.n()).done; ) {
                var xe = re.value;
                delete this.paths[xe], delete this.virtuals[xe], xe.indexOf(".") !== -1 ? ee.unset(xe, this.tree) : delete this.tree[xe];
              }
            } catch (be) {
              pe.e(be);
            } finally {
              pe.f();
            }
          }
          return this;
        }, ae.prototype.loadClass = function(q, G) {
          return q === Object.prototype || q === Function.prototype || q.prototype.hasOwnProperty("$isMongooseModelPrototype") || q.prototype.hasOwnProperty("$isMongooseDocumentPrototype") || (this.loadClass(Object.getPrototypeOf(q), G), G || Object.getOwnPropertyNames(q).forEach(function(ce) {
            if (!ce.match(/^(length|name|prototype|constructor|__proto__)$/)) {
              var ue = Object.getOwnPropertyDescriptor(q, ce);
              ue.hasOwnProperty("value") && this.static(ce, ue.value);
            }
          }, this), Object.getOwnPropertyNames(q.prototype).forEach(function(ce) {
            if (!ce.match(/^(constructor)$/)) {
              var ue = Object.getOwnPropertyDescriptor(q.prototype, ce);
              G || typeof ue.value == "function" && this.method(ce, ue.value), typeof ue.get == "function" && (this.virtuals[ce] && (this.virtuals[ce].getters = []), this.virtual(ce).get(ue.get)), typeof ue.set == "function" && (this.virtuals[ce] && (this.virtuals[ce].setters = []), this.virtual(ce).set(ue.set));
            }
          }, this)), this;
        }, ae.prototype._getSchema = function(q) {
          var G = this.path(q), ce = [];
          if (G) return G.$fullPath = q, G;
          for (var ue = q.split("."), re = 0; re < ue.length; ++re) (ue[re] === "$" || ye(ue[re])) && (ue[re] = "0"), de.test(ue[re]) && (ue[re] = "$");
          return (function pe(xe, be) {
            for (var Ee, Ue, Ae = xe.length + 1; Ae--; ) if (Ue = xe.slice(0, Ae).join("."), Ee = be.path(Ue)) {
              if (ce.push(Ue), Ee.caster) {
                if (Ee.caster instanceof g.Mixed) return Ee.caster.$fullPath = ce.join("."), Ee.caster;
                if (Ae !== xe.length) {
                  if (Ae + 1 === xe.length && Ee.$embeddedSchemaType && (xe[Ae] === "$" || ye(xe[Ae]))) return Ee.$embeddedSchemaType;
                  if (Ee.schema) {
                    var Me = void 0;
                    return xe[Ae] === "$" || ye(xe[Ae]) ? Ae + 1 === xe.length ? Ee.$embeddedSchemaType : ((Me = pe(xe.slice(Ae + 1), Ee.schema)) && (Me.$parentSchemaDocArray = Me.$parentSchemaDocArray || (Ee.schema.$isSingleNested ? null : Ee)), Me) : ((Me = pe(xe.slice(Ae), Ee.schema)) && (Me.$parentSchemaDocArray = Me.$parentSchemaDocArray || (Ee.schema.$isSingleNested ? null : Ee)), Me);
                  }
                }
              } else if (Ee.$isSchemaMap) {
                if (Ae >= xe.length) return Ee;
                if (Ae + 1 >= xe.length || Ee.$__schemaType instanceof g.Mixed) return Ee.$__schemaType;
                if (Ee.$__schemaType.schema != null) return pe(xe.slice(Ae + 1), Ee.$__schemaType.schema);
              }
              return Ee.$fullPath = ce.join("."), Ee;
            }
          })(ue, this);
        }, ae.prototype._getPathType = function(q) {
          return this.path(q) ? "real" : (function G(ce, ue) {
            for (var re, pe, xe = ce.length + 1; xe--; ) {
              if (pe = ce.slice(0, xe).join("."), re = ue.path(pe)) return re.caster ? re.caster instanceof g.Mixed ? { schema: re, pathType: "mixed" } : xe !== ce.length && re.schema ? ce[xe] === "$" || ye(ce[xe]) ? xe === ce.length - 1 ? { schema: re, pathType: "nested" } : G(ce.slice(xe + 1), re.schema) : G(ce.slice(xe), re.schema) : { schema: re, pathType: re.$isSingleNested ? "nested" : "array" } : { schema: re, pathType: "real" };
              if (xe === ce.length && ue.nested[pe]) return { schema: ue, pathType: "nested" };
            }
            return { schema: re || ue, pathType: "undefined" };
          })(q.split("."), this);
        }, ae.prototype._transformDuplicateKeyError = function(q) {
          if (!this._duplicateKeyErrorMessagesByPath || q.code !== 11e3 && q.code !== 11001) return q;
          if (q.keyPattern != null) {
            var G = q.keyPattern, ce = Object.keys(G);
            if (ce.length !== 1) return q;
            var ue = ce[0];
            return this._duplicateKeyErrorMessagesByPath.hasOwnProperty(ue) ? new w(this._duplicateKeyErrorMessagesByPath[ue], { cause: q }) : q;
          }
          return q;
        }, ae.prototype._preCompile = function() {
          this.plugin(W, { deduplicate: !0 });
        }, ae.prototype.toJSONSchema = function(q) {
          for (var G, ce = (G = q?.useBsonType) !== null && G !== void 0 && G, ue = ce ? { required: [], properties: {} } : { type: "object", required: [], properties: {} }, re = 0, pe = Object.keys(this.paths); re < pe.length; re++) {
            var xe = pe[re], be = this.paths[xe];
            if (be._presplitPath.indexOf("$*") === -1) {
              var Ee = ue;
              if (be._presplitPath.length > 1) for (var Ue = 0; Ue < be._presplitPath.length - 1; ++Ue) {
                var Ae = be._presplitPath[Ue];
                Ee.properties[Ae] == null && (Ee.properties[Ae] = ce ? { bsonType: ["object", "null"], properties: {} } : { type: ["object", "null"], properties: {} }), Ee = Ee.properties[Ae];
              }
              var Me = be._presplitPath[be._presplitPath.length - 1], et = !1;
              xe === "_id" ? (Ee.required || (Ee.required = []), Ee.required.push("_id"), et = !0) : be.options.required && typeof be.options.required != "function" && (Ee.required || (Ee.required = []), Ee.required.push(Me), et = !0), Ee.properties[Me] = be.toJSONSchema(q), be.options.enum && (Ee.properties[Me].enum = et ? be.options.enum : [].concat(c(be.options.enum), [null]));
            }
          }
          return ue.required.length === 0 && delete ue.required, ue;
        }, o.exports = s = ae, ae.Types = g = a(7953), s.ObjectId = g.ObjectId;
      }, 7160: (o, s) => {
        s.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed"), s.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
      }, 7219: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        function c(_, b) {
          for (var w = 0; w < b.length; w++) {
            var A = b[w];
            A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(_, f(A.key), A);
          }
        }
        function f(_) {
          var b = (function(w) {
            if (u(w) != "object" || !w) return w;
            var A = w[Symbol.toPrimitive];
            if (A !== void 0) {
              var E = A.call(w, "string");
              if (u(E) != "object") return E;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(w);
          })(_);
          return u(b) == "symbol" ? b : b + "";
        }
        function h() {
          try {
            var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (h = function() {
            return !!_;
          })();
        }
        function y(_) {
          return y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, y(_);
        }
        function p(_, b) {
          return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w, A) {
            return w.__proto__ = A, w;
          }, p(_, b);
        }
        var l = a(8213), d = a(2900), v = a(4070), m = a(5497), g = (function(_) {
          function b() {
            return (function(E, O) {
              if (!(E instanceof O)) throw new TypeError("Cannot call a class as a function");
            })(this, b), (function(E, O, $) {
              return O = y(O), (function(k, j) {
                if (j && (u(j) == "object" || typeof j == "function")) return j;
                if (j !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(P) {
                  if (P === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return P;
                })(k);
              })(E, h() ? Reflect.construct(O, $ || [], y(E).constructor) : O.apply(E, $));
            })(this, b, arguments);
          }
          return (function(E, O) {
            if (typeof O != "function" && O !== null) throw new TypeError("Super expression must either be null or a function");
            E.prototype = Object.create(O && O.prototype, { constructor: { value: E, writable: !0, configurable: !0 } }), Object.defineProperty(E, "prototype", { writable: !1 }), O && p(E, O);
          })(b, _), w = b, (A = [{ key: "assimilateError", value: function(E) {
            var O = E.reason, $ = v(O) && d(O) && E.message.indexOf("bad auth") === -1 && E.message.indexOf("Authentication failed") === -1;
            for (var k in $ ? this.message = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/" : m(O) ? this.message = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html" : this.message = E.message, E) k !== "name" && (this[k] = E[k]);
            return this.cause = O, this;
          } }]) && c(w.prototype, A), Object.defineProperty(w, "prototype", { writable: !1 }), w;
          var w, A;
        })(l);
        Object.defineProperty(g.prototype, "name", { value: "MongooseServerSelectionError" }), o.exports = g;
      }, 7236: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          if (a == null || s(a) !== "object") return a;
          if (Array.isArray(a)) for (var u = a.length - 1; u >= 0; --u) a[u] === void 0 && a.splice(u, 1);
          for (var c = 0, f = Object.keys(a); c < f.length; c++) {
            var h = f[c];
            a[h] === void 0 && delete a[h];
          }
          return a;
        };
      }, 7291: (o, s) => {
        function a(c) {
          return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
            return typeof f;
          } : function(f) {
            return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
          }, a(c);
        }
        var u = Symbol("mongoose#trustedSymbol");
        s.trustedSymbol = u, s.trusted = function(c) {
          return c == null || a(c) !== "object" || (c[u] = !0), c;
        };
      }, 7300: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          return a == null || s(a) !== "object" || !("$meta" in a) && !("$slice" in a);
        };
      }, 7352: (o, s, a) => {
        function u(T) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
            return typeof D;
          } : function(D) {
            return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
          }, u(T);
        }
        var c = Object.getOwnPropertyDescriptors || function(T) {
          for (var D = Object.keys(T), L = {}, M = 0; M < D.length; M++) L[D[M]] = Object.getOwnPropertyDescriptor(T, D[M]);
          return L;
        }, f = /%[sdj%]/g;
        s.format = function(T) {
          if (!O(T)) {
            for (var D = [], L = 0; L < arguments.length; L++) D.push(l(arguments[L]));
            return D.join(" ");
          }
          L = 1;
          for (var M = arguments, N = M.length, Z = String(T).replace(f, function(ie) {
            if (ie === "%%") return "%";
            if (L >= N) return ie;
            switch (ie) {
              case "%s":
                return String(M[L++]);
              case "%d":
                return Number(M[L++]);
              case "%j":
                try {
                  return JSON.stringify(M[L++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return ie;
            }
          }), Y = M[L]; L < N; Y = M[++L]) A(Y) || !j(Y) ? Z += " " + Y : Z += " " + l(Y);
          return Z;
        }, s.deprecate = function(T, D) {
          if ({}.noDeprecation === !0) return T;
          var L = !1;
          return function() {
            if (!L) {
              if ({}.throwDeprecation) throw new Error(D);
              ({}).traceDeprecation ? console.trace(D) : console.error(D), L = !0;
            }
            return T.apply(this, arguments);
          };
        };
        var h = {}, y = /^$/;
        if ({}.NODE_DEBUG) {
          var p = {}.NODE_DEBUG;
          p = p.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), y = new RegExp("^" + p + "$", "i");
        }
        function l(T, D) {
          var L = { seen: [], stylize: v };
          return arguments.length >= 3 && (L.depth = arguments[2]), arguments.length >= 4 && (L.colors = arguments[3]), w(D) ? L.showHidden = D : D && s._extend(L, D), $(L.showHidden) && (L.showHidden = !1), $(L.depth) && (L.depth = 2), $(L.colors) && (L.colors = !1), $(L.customInspect) && (L.customInspect = !0), L.colors && (L.stylize = d), m(L, T, L.depth);
        }
        function d(T, D) {
          var L = l.styles[D];
          return L ? "\x1B[" + l.colors[L][0] + "m" + T + "\x1B[" + l.colors[L][1] + "m" : T;
        }
        function v(T, D) {
          return T;
        }
        function m(T, D, L) {
          if (T.customInspect && D && I(D.inspect) && D.inspect !== s.inspect && (!D.constructor || D.constructor.prototype !== D)) {
            var M = D.inspect(L, T);
            return O(M) || (M = m(T, M, L)), M;
          }
          var N = (function(he, x) {
            if ($(x)) return he.stylize("undefined", "undefined");
            if (O(x)) {
              var U = "'" + JSON.stringify(x).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return he.stylize(U, "string");
            }
            return E(x) ? he.stylize("" + x, "number") : w(x) ? he.stylize("" + x, "boolean") : A(x) ? he.stylize("null", "null") : void 0;
          })(T, D);
          if (N) return N;
          var Z = Object.keys(D), Y = (function(he) {
            var x = {};
            return he.forEach(function(U, B) {
              x[U] = !0;
            }), x;
          })(Z);
          if (T.showHidden && (Z = Object.getOwnPropertyNames(D)), R(D) && (Z.indexOf("message") >= 0 || Z.indexOf("description") >= 0)) return g(D);
          if (Z.length === 0) {
            if (I(D)) {
              var ie = D.name ? ": " + D.name : "";
              return T.stylize("[Function" + ie + "]", "special");
            }
            if (k(D)) return T.stylize(RegExp.prototype.toString.call(D), "regexp");
            if (P(D)) return T.stylize(Date.prototype.toString.call(D), "date");
            if (R(D)) return g(D);
          }
          var le, de = "", ae = !1, ne = ["{", "}"];
          return b(D) && (ae = !0, ne = ["[", "]"]), I(D) && (de = " [Function" + (D.name ? ": " + D.name : "") + "]"), k(D) && (de = " " + RegExp.prototype.toString.call(D)), P(D) && (de = " " + Date.prototype.toUTCString.call(D)), R(D) && (de = " " + g(D)), Z.length !== 0 || ae && D.length != 0 ? L < 0 ? k(D) ? T.stylize(RegExp.prototype.toString.call(D), "regexp") : T.stylize("[Object]", "special") : (T.seen.push(D), le = ae ? (function(he, x, U, B, J) {
            for (var X = [], oe = 0, ye = x.length; oe < ye; ++oe) te(x, String(oe)) ? X.push(_(he, x, U, B, String(oe), !0)) : X.push("");
            return J.forEach(function(q) {
              q.match(/^\d+$/) || X.push(_(he, x, U, B, q, !0));
            }), X;
          })(T, D, L, Y, Z) : Z.map(function(he) {
            return _(T, D, L, Y, he, ae);
          }), T.seen.pop(), (function(he, x, U) {
            return he.reduce(function(B, J) {
              return J.indexOf(`
`), B + J.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60 ? U[0] + (x === "" ? "" : x + `
 `) + " " + he.join(`,
  `) + " " + U[1] : U[0] + x + " " + he.join(", ") + " " + U[1];
          })(le, de, ne)) : ne[0] + de + ne[1];
        }
        function g(T) {
          return "[" + Error.prototype.toString.call(T) + "]";
        }
        function _(T, D, L, M, N, Z) {
          var Y, ie, le;
          if ((le = Object.getOwnPropertyDescriptor(D, N) || { value: D[N] }).get ? ie = le.set ? T.stylize("[Getter/Setter]", "special") : T.stylize("[Getter]", "special") : le.set && (ie = T.stylize("[Setter]", "special")), te(M, N) || (Y = "[" + N + "]"), ie || (T.seen.indexOf(le.value) < 0 ? (ie = A(L) ? m(T, le.value, null) : m(T, le.value, L - 1)).indexOf(`
`) > -1 && (ie = Z ? ie.split(`
`).map(function(de) {
            return "  " + de;
          }).join(`
`).slice(2) : `
` + ie.split(`
`).map(function(de) {
            return "   " + de;
          }).join(`
`)) : ie = T.stylize("[Circular]", "special")), $(Y)) {
            if (Z && N.match(/^\d+$/)) return ie;
            (Y = JSON.stringify("" + N)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Y = Y.slice(1, -1), Y = T.stylize(Y, "name")) : (Y = Y.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Y = T.stylize(Y, "string"));
          }
          return Y + ": " + ie;
        }
        function b(T) {
          return Array.isArray(T);
        }
        function w(T) {
          return typeof T == "boolean";
        }
        function A(T) {
          return T === null;
        }
        function E(T) {
          return typeof T == "number";
        }
        function O(T) {
          return typeof T == "string";
        }
        function $(T) {
          return T === void 0;
        }
        function k(T) {
          return j(T) && z(T) === "[object RegExp]";
        }
        function j(T) {
          return u(T) === "object" && T !== null;
        }
        function P(T) {
          return j(T) && z(T) === "[object Date]";
        }
        function R(T) {
          return j(T) && (z(T) === "[object Error]" || T instanceof Error);
        }
        function I(T) {
          return typeof T == "function";
        }
        function z(T) {
          return Object.prototype.toString.call(T);
        }
        function W(T) {
          return T < 10 ? "0" + T.toString(10) : T.toString(10);
        }
        s.debuglog = function(T) {
          if (T = T.toUpperCase(), !h[T]) if (y.test(T)) {
            var D = {}.pid;
            h[T] = function() {
              var L = s.format.apply(s, arguments);
              console.error("%s %d: %s", T, D, L);
            };
          } else h[T] = function() {
          };
          return h[T];
        }, s.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, s.types = a(7595), s.isArray = b, s.isBoolean = w, s.isNull = A, s.isNullOrUndefined = function(T) {
          return T == null;
        }, s.isNumber = E, s.isString = O, s.isSymbol = function(T) {
          return u(T) === "symbol";
        }, s.isUndefined = $, s.isRegExp = k, s.types.isRegExp = k, s.isObject = j, s.isDate = P, s.types.isDate = P, s.isError = R, s.types.isNativeError = R, s.isFunction = I, s.isPrimitive = function(T) {
          return T === null || typeof T == "boolean" || typeof T == "number" || typeof T == "string" || u(T) === "symbol" || T === void 0;
        }, s.isBuffer = a(7944);
        var F = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function te(T, D) {
          return Object.prototype.hasOwnProperty.call(T, D);
        }
        s.log = function() {
          var T, D;
          console.log("%s - %s", (D = [W((T = /* @__PURE__ */ new Date()).getHours()), W(T.getMinutes()), W(T.getSeconds())].join(":"), [T.getDate(), F[T.getMonth()], D].join(" ")), s.format.apply(s, arguments));
        }, s.inherits = a(1679), s._extend = function(T, D) {
          if (!D || !j(D)) return T;
          for (var L = Object.keys(D), M = L.length; M--; ) T[L[M]] = D[L[M]];
          return T;
        };
        var ee = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        function V(T, D) {
          if (!T) {
            var L = new Error("Promise was rejected with a falsy value");
            L.reason = T, T = L;
          }
          return D(T);
        }
        s.promisify = function(T) {
          if (typeof T != "function") throw new TypeError('The "original" argument must be of type Function');
          if (ee && T[ee]) {
            var D;
            if (typeof (D = T[ee]) != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(D, ee, { value: D, enumerable: !1, writable: !1, configurable: !0 }), D;
          }
          function D() {
            for (var L, M, N = new Promise(function(ie, le) {
              L = ie, M = le;
            }), Z = [], Y = 0; Y < arguments.length; Y++) Z.push(arguments[Y]);
            Z.push(function(ie, le) {
              ie ? M(ie) : L(le);
            });
            try {
              T.apply(this, Z);
            } catch (ie) {
              M(ie);
            }
            return N;
          }
          return Object.setPrototypeOf(D, Object.getPrototypeOf(T)), ee && Object.defineProperty(D, ee, { value: D, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(D, c(T));
        }, s.promisify.custom = ee, s.callbackify = function(T) {
          if (typeof T != "function") throw new TypeError('The "original" argument must be of type Function');
          function D() {
            for (var L = [], M = 0; M < arguments.length; M++) L.push(arguments[M]);
            var N = L.pop();
            if (typeof N != "function") throw new TypeError("The last argument must be of type Function");
            var Z = this, Y = function() {
              return N.apply(Z, arguments);
            };
            T.apply(this, L).then(function(ie) {
              ({ env: {} }).nextTick(Y.bind(null, null, ie));
            }, function(ie) {
              ({ env: {} }).nextTick(V.bind(null, ie, Y));
            });
          }
          return Object.setPrototypeOf(D, Object.getPrototypeOf(T)), Object.defineProperties(D, c(T)), D;
        };
      }, 7425: (o, s, a) => {
        var u = a(2696);
        o.exports = function(c, f) {
          if (c == null || c.discriminators == null) return null;
          for (var h = 0, y = Object.keys(c.discriminators); h < y.length; h++) {
            var p = y[h], l = c.discriminators[p];
            if (l.discriminatorMapping != null && u(l.discriminatorMapping.value, f)) return l;
          }
          return null;
        };
      }, 7430: (o, s, a) => {
        var u = a(5832).hp;
        function c(l) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, c(l);
        }
        var f = a(6353).Binary, h = a(3305), y = a(2497);
        a(3672), a(7352);
        function p(l) {
          return l && c(l) === "object" && !(l instanceof Date) && !h(l, "ObjectId") && (!Array.isArray(l) || l.length !== 0) && !(l instanceof u) && !h(l, "Decimal128") && !(l instanceof f);
        }
        s.B = function l(d, v, m, g) {
          var _, b = (_ = d && y(d) && !u.isBuffer(d) ? Object.keys(d.toObject({ transform: !1, virtuals: !1 }) || {}) : Object.keys(d || {})).length, w = {};
          v = v ? v + "." : "";
          for (var A = 0; A < b; ++A) {
            var E = _[A], O = d[E];
            w[v + E] = O;
            var $ = g && g.path && g.path(v + E), k = g && g.nested && g.nested[v + E];
            if (!$ || $.instance !== "Mixed") {
              if (p(O)) {
                if (m && m.skipArrays && Array.isArray(O)) continue;
                var j = l(O, v + E, m, g);
                for (var P in j) w[P] = j[P];
                Array.isArray(O) && (w[v + E] = O);
              }
              if (k) for (var R = 0, I = Object.keys(g.paths); R < I.length; R++) {
                var z = I[R];
                z.startsWith(v + E + ".") && !w.hasOwnProperty(z) && (w[z] = void 0);
              }
            }
          }
          return w;
        };
      }, 7494: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "_id", p), Object.defineProperty(y.prototype, "minimize", p), o.exports = y;
      }, 7557: (o, s, a) => {
        function u(g) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
            return typeof _;
          } : function(_) {
            return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
          }, u(g);
        }
        function c(g, _, b) {
          return (_ = (function(w) {
            var A = (function(E) {
              if (u(E) != "object" || !E) return E;
              var O = E[Symbol.toPrimitive];
              if (O !== void 0) {
                var $ = O.call(E, "string");
                if (u($) != "object") return $;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(E);
            })(w);
            return u(A) == "symbol" ? A : A + "";
          })(_)) in g ? Object.defineProperty(g, _, { value: b, enumerable: !0, configurable: !0, writable: !0 }) : g[_] = b, g;
        }
        var f = a(8920), h = a(7930).arrayAtomicsSymbol, y = a(7930).arrayAtomicsBackupSymbol, p = a(7930).arrayParentSymbol, l = a(7930).arrayPathSymbol, d = a(7930).arraySchemaSymbol, v = Array.prototype.push, m = /^\d+$/;
        o.exports = function(g, _, b, w) {
          var A;
          if (Array.isArray(g)) {
            var E = g.length;
            if (E === 0) A = new Array();
            else if (E === 1) (A = new Array(1))[0] = g[0];
            else if (E < 1e4) A = new Array(), v.apply(A, g);
            else {
              A = new Array();
              for (var O = 0; O < E; ++O) v.call(A, g[O]);
            }
          } else A = [];
          var $ = c(c(c(c(c(c(c(c({}, h, {}), y, void 0), l, _), d, w), p, void 0), "isMongooseArray", !0), "isMongooseArrayProxy", !0), "__array", A);
          g && g[h] != null && ($[h] = g[h]), b != null && b.$__ && ($[p] = b, $[d] = w || b.schema.path(_));
          var k = new Proxy(A, { get: function(j, P) {
            return $.hasOwnProperty(P) ? $[P] : f.hasOwnProperty(P) ? f[P] : w && w.virtuals && w.virtuals.hasOwnProperty(P) ? w.virtuals[P].applyGetters(void 0, j) : typeof P == "string" && m.test(P) && w?.$embeddedSchemaType != null ? w.$embeddedSchemaType.applyGetters(A[P], b) : A[P];
          }, set: function(j, P, R) {
            return typeof P == "string" && m.test(P) ? f.set.call(k, P, R, !1) : $.hasOwnProperty(P) ? $[P] = R : w && w.virtuals && w.virtuals.hasOwnProperty(P) ? w.virtuals[P].applySetters(R, j) : A[P] = R, !0;
          } });
          return k;
        };
      }, 7591: (o) => {
        var s = null;
        o.exports.get = function() {
          return s;
        }, o.exports.set = function(a) {
          s = a;
        };
      }, 7595: (o, s, a) => {
        function u(L) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(M) {
            return typeof M;
          } : function(M) {
            return M && typeof Symbol == "function" && M.constructor === Symbol && M !== Symbol.prototype ? "symbol" : typeof M;
          }, u(L);
        }
        var c = a(5899), f = a(1905), h = a(9834), y = a(7911);
        function p(L) {
          return L.call.bind(L);
        }
        var l = typeof BigInt < "u", d = typeof Symbol < "u", v = p(Object.prototype.toString), m = p(Number.prototype.valueOf), g = p(String.prototype.valueOf), _ = p(Boolean.prototype.valueOf);
        if (l) var b = p(BigInt.prototype.valueOf);
        if (d) var w = p(Symbol.prototype.valueOf);
        function A(L, M) {
          if (u(L) !== "object") return !1;
          try {
            return M(L), !0;
          } catch {
            return !1;
          }
        }
        function E(L) {
          return v(L) === "[object Map]";
        }
        function O(L) {
          return v(L) === "[object Set]";
        }
        function $(L) {
          return v(L) === "[object WeakMap]";
        }
        function k(L) {
          return v(L) === "[object WeakSet]";
        }
        function j(L) {
          return v(L) === "[object ArrayBuffer]";
        }
        function P(L) {
          return typeof ArrayBuffer < "u" && (j.working ? j(L) : L instanceof ArrayBuffer);
        }
        function R(L) {
          return v(L) === "[object DataView]";
        }
        function I(L) {
          return typeof DataView < "u" && (R.working ? R(L) : L instanceof DataView);
        }
        s.isArgumentsObject = c, s.isGeneratorFunction = f, s.isTypedArray = y, s.isPromise = function(L) {
          return typeof Promise < "u" && L instanceof Promise || L !== null && u(L) === "object" && typeof L.then == "function" && typeof L.catch == "function";
        }, s.isArrayBufferView = function(L) {
          return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(L) : y(L) || I(L);
        }, s.isUint8Array = function(L) {
          return h(L) === "Uint8Array";
        }, s.isUint8ClampedArray = function(L) {
          return h(L) === "Uint8ClampedArray";
        }, s.isUint16Array = function(L) {
          return h(L) === "Uint16Array";
        }, s.isUint32Array = function(L) {
          return h(L) === "Uint32Array";
        }, s.isInt8Array = function(L) {
          return h(L) === "Int8Array";
        }, s.isInt16Array = function(L) {
          return h(L) === "Int16Array";
        }, s.isInt32Array = function(L) {
          return h(L) === "Int32Array";
        }, s.isFloat32Array = function(L) {
          return h(L) === "Float32Array";
        }, s.isFloat64Array = function(L) {
          return h(L) === "Float64Array";
        }, s.isBigInt64Array = function(L) {
          return h(L) === "BigInt64Array";
        }, s.isBigUint64Array = function(L) {
          return h(L) === "BigUint64Array";
        }, E.working = typeof Map < "u" && E(/* @__PURE__ */ new Map()), s.isMap = function(L) {
          return typeof Map < "u" && (E.working ? E(L) : L instanceof Map);
        }, O.working = typeof Set < "u" && O(/* @__PURE__ */ new Set()), s.isSet = function(L) {
          return typeof Set < "u" && (O.working ? O(L) : L instanceof Set);
        }, $.working = typeof WeakMap < "u" && $(/* @__PURE__ */ new WeakMap()), s.isWeakMap = function(L) {
          return typeof WeakMap < "u" && ($.working ? $(L) : L instanceof WeakMap);
        }, k.working = typeof WeakSet < "u" && k(/* @__PURE__ */ new WeakSet()), s.isWeakSet = function(L) {
          return k(L);
        }, j.working = typeof ArrayBuffer < "u" && j(new ArrayBuffer()), s.isArrayBuffer = P, R.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && R(new DataView(new ArrayBuffer(1), 0, 1)), s.isDataView = I;
        var z = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function W(L) {
          return v(L) === "[object SharedArrayBuffer]";
        }
        function F(L) {
          return z !== void 0 && (W.working === void 0 && (W.working = W(new z())), W.working ? W(L) : L instanceof z);
        }
        function te(L) {
          return A(L, m);
        }
        function ee(L) {
          return A(L, g);
        }
        function V(L) {
          return A(L, _);
        }
        function T(L) {
          return l && A(L, b);
        }
        function D(L) {
          return d && A(L, w);
        }
        s.isSharedArrayBuffer = F, s.isAsyncFunction = function(L) {
          return v(L) === "[object AsyncFunction]";
        }, s.isMapIterator = function(L) {
          return v(L) === "[object Map Iterator]";
        }, s.isSetIterator = function(L) {
          return v(L) === "[object Set Iterator]";
        }, s.isGeneratorObject = function(L) {
          return v(L) === "[object Generator]";
        }, s.isWebAssemblyCompiledModule = function(L) {
          return v(L) === "[object WebAssembly.Module]";
        }, s.isNumberObject = te, s.isStringObject = ee, s.isBooleanObject = V, s.isBigIntObject = T, s.isSymbolObject = D, s.isBoxedPrimitive = function(L) {
          return te(L) || ee(L) || V(L) || T(L) || D(L);
        }, s.isAnyArrayBuffer = function(L) {
          return typeof Uint8Array < "u" && (P(L) || F(L));
        }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(L) {
          Object.defineProperty(s, L, { enumerable: !1, value: function() {
            throw new Error(L + " is not supported in userland");
          } });
        });
      }, 7760: (o, s, a) => {
        function u(M, N) {
          var Z = Object.keys(M);
          if (Object.getOwnPropertySymbols) {
            var Y = Object.getOwnPropertySymbols(M);
            N && (Y = Y.filter(function(ie) {
              return Object.getOwnPropertyDescriptor(M, ie).enumerable;
            })), Z.push.apply(Z, Y);
          }
          return Z;
        }
        function c(M) {
          for (var N = 1; N < arguments.length; N++) {
            var Z = arguments[N] != null ? arguments[N] : {};
            N % 2 ? u(Object(Z), !0).forEach(function(Y) {
              f(M, Y, Z[Y]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(M, Object.getOwnPropertyDescriptors(Z)) : u(Object(Z)).forEach(function(Y) {
              Object.defineProperty(M, Y, Object.getOwnPropertyDescriptor(Z, Y));
            });
          }
          return M;
        }
        function f(M, N, Z) {
          return (N = (function(Y) {
            var ie = (function(le) {
              if (y(le) != "object" || !le) return le;
              var de = le[Symbol.toPrimitive];
              if (de !== void 0) {
                var ae = de.call(le, "string");
                if (y(ae) != "object") return ae;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(le);
            })(Y);
            return y(ie) == "symbol" ? ie : ie + "";
          })(N)) in M ? Object.defineProperty(M, N, { value: Z, enumerable: !0, configurable: !0, writable: !0 }) : M[N] = Z, M;
        }
        function h(M, N) {
          (N == null || N > M.length) && (N = M.length);
          for (var Z = 0, Y = Array(N); Z < N; Z++) Y[Z] = M[Z];
          return Y;
        }
        function y(M) {
          return y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(N) {
            return typeof N;
          } : function(N) {
            return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : typeof N;
          }, y(M);
        }
        var p, l, d = a(8499), v = a(2555), m = a(8213), g = a(4592), _ = a(6426), b = _.CastError, w = a(5022), A = a(2069), E = a(622), O = a(2073), $ = a(7982), k = a(4450), j = a(8260), P = a(5110), R = a(7352), I = a(8768), z = a(5558).G, W = a(4327), F = a(9604), te = a(1058), ee = Symbol("mongoose#isNestedArray"), V = Object.freeze({});
        function T(M, N, Z, Y) {
          l || (l = a(9600).Embedded);
          var ie, le, de = "type";
          if (Y && Y.typeKey && (de = Y.typeKey), this.schemaOptions = Y, N) {
            var ae = {};
            I.isPOJO(N) && (N[de] ? (delete (ae = k(N))[de], N = N[de]) : N = w), Z != null && Z.ref != null && ae.ref == null && (ae.ref = Z.ref), N === Object && (N = w);
            var ne = typeof N == "string" ? N : I.getFunctionName(N), he = a(7953), x = he.hasOwnProperty(ne) ? he[ne] : N;
            if (this.casterConstructor = x, this.casterConstructor instanceof T && (this.casterConstructor[ee] = !0), typeof x != "function" || x.$isArraySubdocument || x.$isSchemaMap) this.caster = x, this.caster instanceof l || (this.caster.path = M);
            else {
              var U = this.caster instanceof l ? null : M;
              this.caster = new x(U, ae);
            }
            this.$embeddedSchemaType = this.caster;
          }
          if (this.$isMongooseArray = !0, _.call(this, M, Z, "Array"), this.defaultValue != null && (ie = this.defaultValue, le = typeof ie == "function"), !("defaultValue" in this) || this.defaultValue != null) {
            var B = function() {
              return le ? ie.call(this) : ie != null ? [].concat(ie) : [];
            };
            B.$runBeforeSetters = !le, this.default(B);
          }
        }
        T.schemaName = "Array", T.options = { castNonArrays: !0 }, T.defaultOptions = {}, T.set = _.set, T.setters = [], T.get = _.get, T.prototype = Object.create(_.prototype), T.prototype.constructor = T, T.prototype.OptionsConstructor = g, T._checkRequired = _.prototype.checkRequired, T.checkRequired = _.checkRequired, T.prototype.virtuals = null, T.prototype.checkRequired = function(M, N) {
          return y(M) === "object" && _._isRef(this, M, N, !0) ? !!M : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : T.checkRequired())(M);
        }, T.prototype.enum = function() {
          for (var M = this; ; ) {
            var N = M && M.caster && M.caster.instance;
            if (N !== "Array") {
              if (N !== "String" && N !== "Number") throw new Error("`enum` can only be set on an array of strings or numbers , not " + N);
              break;
            }
            M = M.caster;
          }
          var Z = arguments;
          return !Array.isArray(arguments) && I.isObject(arguments) && (Z = I.object.vals(Z)), M.caster.enum.apply(M.caster, Z), this;
        }, T.prototype.applyGetters = function(M, N) {
          return N != null && N.$__ != null && N.$populated(this.path) ? M : _.prototype.applyGetters.call(this, M, N);
        }, T.prototype._applySetters = function(M, N, Z, Y) {
          if (this.casterConstructor.$isMongooseArray && T.options.castNonArrays && !this[ee]) {
            for (var ie = 0, le = this; le != null && le.$isMongooseArray && !le.$isMongooseDocumentArray; ) ++ie, le = le.casterConstructor;
            if (M != null && M.length !== 0) {
              var de = O(M);
              if (de.min === de.max && de.max < ie && de.containsNonArrayItem) for (var ae = de.max; ae < ie; ++ae) M = [M];
            }
          }
          return _.prototype._applySetters.call(this, M, N, Z, Y);
        }, T.prototype.cast = function(M, N, Z, Y, ie) {
          var le, de;
          if (p || (p = a(9600).Array), Array.isArray(M)) {
            if (!M.length && N) {
              var ae = N.schema.indexedPaths(), ne = this.path;
              for (le = 0, de = ae.length; le < de; ++le) {
                var he = ae[le][0][ne];
                if (he === "2dsphere" || he === "2d") return;
              }
              var x = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
              if (x != null) {
                for (le = 0, de = ae.length; le < de; ++le) if (ae[le][0][x] === "2dsphere") return;
              }
            }
            ie = ie || V;
            var U = I.isMongooseArray(M) ? M.__array : M, B = ie.path || this.path;
            if (ie.arrayPathIndex != null && (B += "." + ie.arrayPathIndex), U = (M = p(U, B, N, this)).__array, Z && N != null && N.$__ != null && N.$populated(this.path)) return M;
            var J = this.caster, X = J.$isMongooseArray;
            if (J && this.casterConstructor !== w) try {
              var oe = U.length;
              for (le = 0; le < oe; le++) {
                var ye = {};
                X && (ie.arrayPath != null || J._arrayParentPath != null) && (ye.arrayPathIndex = le), ie.hydratedPopulatedDocs && (ye.hydratedPopulatedDocs = ie.hydratedPopulatedDocs), U[le] = J.applySetters(U[le], N, Z, void 0, ye);
              }
            } catch (G) {
              throw new b("[" + G.kind + "]", R.inspect(M), this.path + "." + le, G, this);
            }
            return M;
          }
          var q = this.options.castNonArrays != null ? this.options.castNonArrays : T.options.castNonArrays;
          if (Z || q) return N && Z && N.markModified(this.path), this.cast([M], N, Z);
          throw new b("Array", R.inspect(M), this.path, null, this);
        }, T.prototype._castForPopulate = function(M, N) {
          if (p || (p = a(9600).Array), Array.isArray(M)) {
            var Z, Y = M.__array ? M.__array : M, ie = Y.length, le = this.caster;
            if (le && this.casterConstructor !== w) try {
              for (Z = 0; Z < ie; Z++) {
                var de = {};
                le.$isMongooseArray && le._arrayParentPath != null && (de.arrayPathIndex = Z), Y[Z] = le.cast(Y[Z], N, !1, void 0, de);
              }
            } catch (ae) {
              throw new b("[" + ae.kind + "]", R.inspect(M), this.path + "." + Z, ae, this);
            }
            return M;
          }
          throw new b("Array", R.inspect(M), this.path, null, this);
        }, T.prototype.$toObject = T.prototype.toObject, T.prototype.discriminator = function() {
          for (var M, N = this; N.$isMongooseArray && !N.$isMongooseDocumentArray; ) if ((N = N.casterConstructor) == null || typeof N == "function") throw new m("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
          return (M = N).discriminator.apply(M, arguments);
        }, T.prototype.clone = function() {
          var M = Object.assign({}, this.options), N = new this.constructor(this.path, this.caster, M, this.schemaOptions);
          return N.validators = this.validators.slice(), this.requiredValidator !== void 0 && (N.requiredValidator = this.requiredValidator), N;
        }, T.prototype._castForQuery = function(M, N) {
          var Z = this, Y = this.casterConstructor;
          if (M && Y.discriminators && Y.schema && Y.schema.options && Y.schema.options.discriminatorKey) if (typeof M[Y.schema.options.discriminatorKey] == "string" && Y.discriminators[M[Y.schema.options.discriminatorKey]]) Y = Y.discriminators[M[Y.schema.options.discriminatorKey]];
          else {
            var ie = te(Y.discriminators, M[Y.schema.options.discriminatorKey]);
            ie && (Y = ie);
          }
          var le = this.casterConstructor.prototype, de = le && le.castForQuery, ae = le && le.cast, ne = Y.castForQuery, he = this.caster;
          return Array.isArray(M) ? (this.setters.reverse().forEach(function(x) {
            M = x.call(Z, M, Z);
          }), M = M.map(function(x) {
            return I.isObject(x) && x.$elemMatch ? x : de ? x = de.call(he, null, x, N) : ae ? x = ae.call(he, x) : ne ? x = ne.call(he, null, x, N) : x != null ? x = new Y(x) : x;
          })) : de ? M = de.call(he, null, M, N) : ae ? M = ae.call(he, M) : ne ? M = ne.call(he, null, M, N) : M != null && (M = new Y(M)), M;
        }, T.prototype.castForQuery = function(M, N, Z) {
          var Y;
          if (M != null) {
            if (!(Y = this.$conditionalHandlers[M])) throw new Error("Can't use " + M + " with Array.");
            return Y.call(this, N, Z);
          }
          return this._castForQuery(N, Z);
        }, T.prototype.virtual = function(M, N) {
          if (M instanceof E || j(M) === "VirtualType") return this.virtual(M.path, M.options);
          if (N = new A(N), I.hasUserDefinedProperty(N, ["ref", "refPath"])) throw new m("Cannot set populate virtual as a property of an array");
          var Z = new E(N, M);
          return this.virtuals === null && (this.virtuals = {}), this.virtuals[M] = Z, Z;
        };
        var D = T.prototype.$conditionalHandlers = {};
        function L(M) {
          return function(N, Z) {
            if (!Array.isArray(N)) throw new TypeError("conditional " + M + " requires an array");
            var Y, ie = [], le = (function(ne, he) {
              var x = typeof Symbol < "u" && ne[Symbol.iterator] || ne["@@iterator"];
              if (!x) {
                if (Array.isArray(ne) || (x = (function(ye, q) {
                  if (ye) {
                    if (typeof ye == "string") return h(ye, q);
                    var G = {}.toString.call(ye).slice(8, -1);
                    return G === "Object" && ye.constructor && (G = ye.constructor.name), G === "Map" || G === "Set" ? Array.from(ye) : G === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(G) ? h(ye, q) : void 0;
                  }
                })(ne)) || he) {
                  x && (ne = x);
                  var U = 0, B = function() {
                  };
                  return { s: B, n: function() {
                    return U >= ne.length ? { done: !0 } : { done: !1, value: ne[U++] };
                  }, e: function(ye) {
                    throw ye;
                  }, f: B };
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              }
              var J, X = !0, oe = !1;
              return { s: function() {
                x = x.call(ne);
              }, n: function() {
                var ye = x.next();
                return X = ye.done, ye;
              }, e: function(ye) {
                oe = !0, J = ye;
              }, f: function() {
                try {
                  X || x.return == null || x.return();
                } finally {
                  if (oe) throw J;
                }
              } };
            })(N);
            try {
              for (le.s(); !(Y = le.n()).done; ) {
                var de, ae = Y.value;
                ie.push($((de = this.casterConstructor.schema) !== null && de !== void 0 ? de : Z.schema, ae, null, this && this.$$context));
              }
            } catch (ne) {
              le.e(ne);
            } finally {
              le.f();
            }
            return ie;
          };
        }
        D.$all = function(M, N) {
          var Z = this;
          return Array.isArray(M) || (M = [M]), M = M.map(function(Y) {
            if (!I.isObject(Y)) return Y;
            if (Y.$elemMatch != null) return { $elemMatch: $(Z.casterConstructor.schema, Y.$elemMatch, null, Z && Z.$$context) };
            var ie = {};
            return ie[Z.path] = Y, $(Z.casterConstructor.schema, ie, null, Z && Z.$$context)[Z.path];
          }, this), this.castForQuery(null, M, N);
        }, D.$options = String, D.$elemMatch = function(M, N) {
          for (var Z = Object.keys(M), Y = Z.length, ie = 0; ie < Y; ++ie) {
            var le = Z[ie], de = M[le];
            P(le) && de != null && (M[le] = this.castForQuery(le, de, N));
          }
          return M;
        }, D.$geoIntersects = F.cast$geoIntersects, D.$or = L("$or"), D.$and = L("$and"), D.$nor = L("$nor"), D.$near = D.$nearSphere = F.cast$near, D.$within = D.$geoWithin = F.cast$within, D.$size = D.$minDistance = D.$maxDistance = z, D.$exists = d, D.$type = v, D.$eq = D.$gt = D.$gte = D.$lt = D.$lte = D.$not = D.$regex = D.$ne = T.prototype._castForQuery, D.$nin = _.prototype.$conditionalHandlers.$nin, D.$in = _.prototype.$conditionalHandlers.$in, T.prototype.toJSONSchema = function(M) {
          var N = this.getEmbeddedSchemaType(), Z = this.options.required && typeof this.options.required != "function";
          return c(c({}, W("array", "array", M?.useBsonType, Z)), {}, { items: N.toJSONSchema(M) });
        }, T.prototype.autoEncryptionType = function() {
          return "array";
        }, o.exports = T;
      }, 7768: (o, s, a) => {
        var u = a(2402);
        o.exports = function(c) {
          return c == null ? c : c === "" ? null : (typeof c != "string" && typeof c != "boolean" || (c = Number(c)), u.ok(!isNaN(c)), c instanceof Number ? c.valueOf() : typeof c == "number" ? c : Array.isArray(c) || typeof c.valueOf != "function" ? c.toString && !Array.isArray(c) && c.toString() == Number(c) ? Number(c) : void u.ok(!1) : Number(c.valueOf()));
        };
      }, 7834: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a, u, c, f) {
          return f.justOne || f.count ? (a[u] = Array.isArray(c) ? c[0] : c, s(a[u]) !== "object" && (a[u] = f.count ? c : null)) : (a[u] = Array.isArray(c) ? c : c == null ? [] : [c], a[u] = a[u].filter(function(h) {
            return h && s(h) === "object";
          })), a[u];
        };
      }, 7860: (o) => {
        o.exports = function(s) {
          for (var a = [], u = "", c = "DEFAULT", f = 0; f < s.length; ++f) c !== "IN_SQUARE_BRACKETS" || /\d/.test(s[f]) || s[f] === "]" || (c = "DEFAULT", u = a[a.length - 1] + "[" + u, a.splice(a.length - 1, 1)), s[f] === "[" ? (c !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS" && (a.push(u), u = ""), c = "IN_SQUARE_BRACKETS") : s[f] === "]" ? c === "IN_SQUARE_BRACKETS" ? (c = "IMMEDIATELY_AFTER_SQUARE_BRACKETS", a.push(u), u = "") : (c = "DEFAULT", u += s[f]) : s[f] === "." ? (c !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS" && (a.push(u), u = ""), c = "DEFAULT") : u += s[f];
          return c !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS" && a.push(u), a;
        };
      }, 7878: (o, s, a) => {
        var u = a(2273), c = a(4183);
        o.exports = function() {
          var f = c();
          return u(Number, { isNaN: f }, { isNaN: function() {
            return Number.isNaN !== f;
          } }), f;
        };
      }, 7910: (o, s, a) => {
        var u = a(1058);
        o.exports = function(c, f, h) {
          var y = c.schema.options.discriminatorKey, p = f != null && f[y];
          if (p == null && (p = h), c.discriminators && p != null) if (c.discriminators[p]) c = c.discriminators[p];
          else {
            var l = u(c.discriminators, p);
            l && (c = l);
          }
          return c;
        };
      }, 7911: (o, s, a) => {
        var u = a(9834);
        o.exports = function(c) {
          return !!u(c);
        };
      }, 7930: (o, s) => {
        s.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup"), s.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics"), s.arrayParentSymbol = Symbol("mongoose#Array#_parent"), s.arrayPathSymbol = Symbol("mongoose#Array#_path"), s.arraySchemaSymbol = Symbol("mongoose#Array#_schema"), s.documentArrayParent = Symbol("mongoose#documentArrayParent"), s.documentIsSelected = Symbol("mongoose#Document#isSelected"), s.documentIsModified = Symbol("mongoose#Document#isModified"), s.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths"), s.documentSchemaSymbol = Symbol("mongoose#Document#schema"), s.getSymbol = Symbol("mongoose#Document#get"), s.modelSymbol = Symbol("mongoose#Model"), s.objectIdSymbol = Symbol("mongoose#ObjectId"), s.populateModelSymbol = Symbol("mongoose#PopulateOptions#Model"), s.schemaTypeSymbol = Symbol("mongoose#schemaType"), s.sessionNewDocuments = Symbol("mongoose#ClientSession#newDocuments"), s.scopeSymbol = Symbol("mongoose#Document#scope"), s.validatorErrorSymbol = Symbol("mongoose#validatorError");
      }, 7944: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          return a && s(a) === "object" && typeof a.copy == "function" && typeof a.fill == "function" && typeof a.readUInt8 == "function";
        };
      }, 7953: (o, s, a) => {
        s.Array = a(7760), s.BigInt = a(3318), s.Boolean = a(6413), s.Buffer = a(2307), s.Date = a(2345), s.Decimal128 = s.Decimal = a(7045), s.DocumentArray = a(9123), s.Double = a(1732), s.Int32 = a(433), s.Map = a(6867), s.Mixed = a(5022), s.Number = a(3660), s.ObjectId = a(3091), s.String = a(8728), s.Subdocument = a(5098), s.UUID = a(2134), s.Union = a(8866), s.Oid = s.ObjectId, s.Object = s.Mixed, s.Bool = s.Boolean, s.ObjectID = s.ObjectId;
      }, 7982: (o, s, a) => {
        function u(j, P) {
          var R = typeof Symbol < "u" && j[Symbol.iterator] || j["@@iterator"];
          if (!R) {
            if (Array.isArray(j) || (R = (function(ee, V) {
              if (ee) {
                if (typeof ee == "string") return c(ee, V);
                var T = {}.toString.call(ee).slice(8, -1);
                return T === "Object" && ee.constructor && (T = ee.constructor.name), T === "Map" || T === "Set" ? Array.from(ee) : T === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(T) ? c(ee, V) : void 0;
              }
            })(j)) || P) {
              R && (j = R);
              var I = 0, z = function() {
              };
              return { s: z, n: function() {
                return I >= j.length ? { done: !0 } : { done: !1, value: j[I++] };
              }, e: function(ee) {
                throw ee;
              }, f: z };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var W, F = !0, te = !1;
          return { s: function() {
            R = R.call(j);
          }, n: function() {
            var ee = R.next();
            return F = ee.done, ee;
          }, e: function(ee) {
            te = !0, W = ee;
          }, f: function() {
            try {
              F || R.return == null || R.return();
            } finally {
              if (te) throw W;
            }
          } };
        }
        function c(j, P) {
          (P == null || P > j.length) && (P = j.length);
          for (var R = 0, I = Array(P); R < P; R++) I[R] = j[R];
          return I;
        }
        function f(j) {
          return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(P) {
            return typeof P;
          } : function(P) {
            return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
          }, f(j);
        }
        var h = a(3609), y = a(8995), p = a(7953), l = a(170), d = a(1244), v = a(9064), m = a(3703), g = a(7425), _ = a(5110), b = a(7352), w = a(608), A = a(2497), E = a(8768), O = ["Polygon", "MultiPolygon"];
        function $(j, P, R) {
          if (Array.isArray(j)) j.forEach(function(te, ee) {
            if (Array.isArray(te) || w(te)) return $(te, P, R);
            j[ee] = P.castForQuery(null, te, R);
          });
          else for (var I = Object.keys(j), z = I.length; z--; ) {
            var W = I[z], F = j[W];
            Array.isArray(F) || w(F) ? ($(F, P, R), j[W] = F) : j[W] = P.castForQuery({ val: F, context: R });
          }
        }
        function k(j, P, R, I) {
          if ("strictQuery" in j) return j.strictQuery;
          if ("strictQuery" in P) return P.strictQuery;
          var z = I && I.mongooseCollection && I.mongooseCollection.conn && I.mongooseCollection.conn.base && I.mongooseCollection.conn.base.options;
          return z && "strictQuery" in z ? z.strictQuery : R.strictQuery;
        }
        o.exports = function j(P, R, I, z) {
          if (Array.isArray(R)) throw new Error("Query filter must be an object, got an array ", b.inspect(R));
          if (R == null) return R;
          P != null && P.discriminators != null && R[P.options.discriminatorKey] != null && (P = g(P, R[P.options.discriminatorKey]) || P);
          var W, F, te, ee, V, T, D = Object.keys(R), L = D.length;
          for (I = I || {}; L--; ) if (T = R[ee = D[L]], ee === "$or" || ee === "$nor" || ee === "$and") {
            if (!Array.isArray(T)) throw new h("Array", T, ee);
            for (var M = T.length - 1; M >= 0; M--) {
              if (T[M] == null || f(T[M]) !== "object") throw new h("Object", T[M], ee + "." + M);
              var N = Object.keys(T[M]).length, Z = T[M][P.options.discriminatorKey];
              if (Z == null) T[M] = j(P, T[M], I, z);
              else {
                var Y = g(z.schema, Z);
                T[M] = j(Y || P, T[M], I, z);
              }
              Object.keys(T[M]).length === 0 && N !== 0 && T.splice(M, 1);
            }
            T.length === 0 && delete R[ee];
          } else {
            if (ee === "$where") {
              if ((V = f(T)) !== "string" && V !== "function") throw new Error("Must have a string or function for $where");
              V === "function" && (R[ee] = T.toString());
              continue;
            }
            if (ee === "$expr") {
              T = l(T, P);
              continue;
            }
            if (ee === "$elemMatch") T = j(P, T, I, z);
            else if (ee === "$text") T = v(T, ee);
            else if (ee !== "$comment" || P.paths.hasOwnProperty("$comment")) {
              if (!P) continue;
              if (!(F = P.path(ee))) for (var ie = ee.split("."), le = ie.length; le--; ) {
                var de = ie.slice(0, le).join("."), ae = ie.slice(le).join("."), ne = P.path(de), he = ne && ne.schema && ne.schema.options && ne.schema.options.discriminatorKey;
                if (ne != null && (ne.schema && ne.schema.discriminators) != null && he != null && ae !== he) {
                  var x = m(R, de + "." + he), U = ne.schema.discriminators;
                  typeof x == "string" && U[x] != null ? F = U[x].path(ae) : x != null && Object.keys(x).length === 1 && Array.isArray(x.$in) && x.$in.length === 1 && typeof x.$in[0] == "string" && U[x.$in[0]] != null && (F = U[x.$in[0]].path(ae));
                }
              }
              if (F) {
                if (T == null) continue;
                if (E.isPOJO(T)) if (Object.keys(T).some(_)) for (var B = Object.keys(T), J = void 0, X = B.length; X--; ) if (te = T[J = B[X]], J === "$elemMatch") te && F != null && F.schema != null ? j(F.schema, te, I, z) : te && F != null && F.$isMongooseArray && (E.isPOJO(te) && te.$not != null ? j(P, te, I, z) : T[J] = F.castForQuery(J, te, z));
                else if (J === "$not") {
                  if (te && F) {
                    if ((W = Object.keys(te)).length && _(W[0])) for (var oe in te) te[oe] = F.castForQuery(oe, te[oe], z);
                    else T[J] = F.castForQuery(J, te, z);
                    continue;
                  }
                } else T[J] = F.castForQuery(J, te, z);
                else R[ee] = F.castForQuery(null, T, z);
                else if (Array.isArray(T) && ["Buffer", "Array"].indexOf(F.instance) === -1 && !I.sanitizeFilter) {
                  var ye, q = [], G = u(T);
                  try {
                    for (G.s(); !(ye = G.n()).done; ) {
                      var ce = ye.value;
                      q.push(F.castForQuery(null, ce, z));
                    }
                  } catch (Xt) {
                    G.e(Xt);
                  } finally {
                    G.f();
                  }
                  R[ee] = { $in: q };
                } else R[ee] = F.castForQuery(null, T, z);
              } else {
                for (var ue = ee.split("."), re = ue.length, pe = void 0, xe = void 0, be = void 0; re-- && (pe = ue.slice(0, re).join("."), !(F = P.path(pe))); ) ;
                if (F) {
                  if (F.caster && F.caster.schema) {
                    (be = {})[xe = ue.slice(re).join(".")] = T;
                    var Ee = j(F.caster.schema, be, I, z)[xe];
                    Ee === void 0 ? delete R[ee] : R[ee] = Ee;
                  } else R[ee] = T;
                  continue;
                }
                if (w(T)) {
                  var Ue = "";
                  if (T.$near ? Ue = "$near" : T.$nearSphere ? Ue = "$nearSphere" : T.$within ? Ue = "$within" : T.$geoIntersects ? Ue = "$geoIntersects" : T.$geoWithin && (Ue = "$geoWithin"), Ue) {
                    var Ae = new p.Number("__QueryCasting__"), Me = T[Ue];
                    if (T.$maxDistance != null && (T.$maxDistance = Ae.castForQuery(null, T.$maxDistance, z)), T.$minDistance != null && (T.$minDistance = Ae.castForQuery(null, T.$minDistance, z)), Ue === "$within") {
                      var et = Me.$center || Me.$centerSphere || Me.$box || Me.$polygon;
                      if (!et) throw new Error("Bad $within parameter: " + JSON.stringify(T));
                      Me = et;
                    } else if (Ue === "$near" && typeof Me.type == "string" && Array.isArray(Me.coordinates)) Me = Me.coordinates;
                    else if ((Ue === "$near" || Ue === "$nearSphere" || Ue === "$geoIntersects") && Me.$geometry && typeof Me.$geometry.type == "string" && Array.isArray(Me.$geometry.coordinates)) Me.$maxDistance != null && (Me.$maxDistance = Ae.castForQuery(null, Me.$maxDistance, z)), Me.$minDistance != null && (Me.$minDistance = Ae.castForQuery(null, Me.$minDistance, z)), A(Me.$geometry) && (Me.$geometry = Me.$geometry.toObject({ transform: !1, virtuals: !1 })), Me = Me.$geometry.coordinates;
                    else if (Ue === "$geoWithin") if (Me.$geometry) {
                      A(Me.$geometry) && (Me.$geometry = Me.$geometry.toObject({ virtuals: !1 }));
                      var lt = Me.$geometry.type;
                      if (O.indexOf(lt) === -1) throw new Error('Invalid geoJSON type for $geoWithin "' + lt + '", must be "Polygon" or "MultiPolygon"');
                      Me = Me.$geometry.coordinates;
                    } else Me = Me.$box || Me.$polygon || Me.$center || Me.$centerSphere, A(Me) && (Me = Me.toObject({ virtuals: !1 }));
                    $(Me, Ae, z);
                    continue;
                  }
                }
                if (P.nested[ee]) continue;
                var ft = "strict" in I ? I.strict : P.options.strict, Ke = k(I, P._userProvidedOptions, P.options, z);
                if (I.upsert && ft)
                  throw ft === "throw" ? new y(ee) : new y(ee, 'Path "' + ee + '" is not in schema, strict mode is `true`, and upsert is `true`.');
                if (Ke === "throw") throw new y(ee, 'Path "' + ee + `" is not in schema and strictQuery is 'throw'.`);
                Ke && delete R[ee];
              }
            } else T = d(T, ee), R[ee] = T;
          }
          return R;
        };
      }, 8063: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v) {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, l, [`Schema hasn't been registered for model "` + v + `".
Use mongoose.model(name, schema)`]);
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "MissingSchemaError" }), o.exports = y;
      }, 8093: (o) => {
        o.exports = Object;
      }, 8133: (o, s, a) => {
        var u = a(8995);
        o.exports = function(c) {
          var f, h;
          c.$immutable ? (c.$immutableSetter = (f = c.path, h = c.options.immutable, function(y, p, l, d) {
            if (this == null || this.$__ == null || this.isNew || d && d.overwriteImmutable || !(typeof h == "function" ? h.call(this, this) : h)) return y;
            var v = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(f) : this.$__getValue(f);
            if (this.$__.strictMode === "throw" && y !== v) throw new u(f, "Path `" + f + "` is immutable and strict mode is set to throw.", !0);
            return v;
          }), c.set(c.$immutableSetter)) : c.$immutableSetter && (c.setters = c.setters.filter(function(y) {
            return y !== c.$immutableSetter;
          }), delete c.$immutableSetter);
        };
      }, 8188: (o) => {
        o.exports = URIError;
      }, 8213: (o) => {
        function s(y) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
            return typeof p;
          } : function(p) {
            return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
          }, s(y);
        }
        function a(y) {
          var p = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return a = function(l) {
            if (l === null || !(function(v) {
              try {
                return Function.toString.call(v).indexOf("[native code]") !== -1;
              } catch {
                return typeof v == "function";
              }
            })(l)) return l;
            if (typeof l != "function") throw new TypeError("Super expression must either be null or a function");
            if (p !== void 0) {
              if (p.has(l)) return p.get(l);
              p.set(l, d);
            }
            function d() {
              return (function(v, m, g) {
                if (u()) return Reflect.construct.apply(null, arguments);
                var _ = [null];
                _.push.apply(_, m);
                var b = new (v.bind.apply(v, _))();
                return g && c(b, g.prototype), b;
              })(l, arguments, f(this).constructor);
            }
            return d.prototype = Object.create(l.prototype, { constructor: { value: d, enumerable: !1, writable: !0, configurable: !0 } }), c(d, l);
          }, a(y);
        }
        function u() {
          try {
            var y = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (u = function() {
            return !!y;
          })();
        }
        function c(y, p) {
          return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, d) {
            return l.__proto__ = d, l;
          }, c(y, p);
        }
        function f(y) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(p) {
            return p.__proto__ || Object.getPrototypeOf(p);
          }, f(y);
        }
        var h = (function(y) {
          function p() {
            return (function(d, v) {
              if (!(d instanceof v)) throw new TypeError("Cannot call a class as a function");
            })(this, p), (function(d, v, m) {
              return v = f(v), (function(g, _) {
                if (_ && (s(_) == "object" || typeof _ == "function")) return _;
                if (_ !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(b) {
                  if (b === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return b;
                })(g);
              })(d, u() ? Reflect.construct(v, m || [], f(d).constructor) : v.apply(d, m));
            })(this, p, arguments);
          }
          return (function(d, v) {
            if (typeof v != "function" && v !== null) throw new TypeError("Super expression must either be null or a function");
            d.prototype = Object.create(v && v.prototype, { constructor: { value: d, writable: !0, configurable: !0 } }), Object.defineProperty(d, "prototype", { writable: !1 }), v && c(d, v);
          })(p, y), l = p, Object.defineProperty(l, "prototype", { writable: !1 }), l;
          var l;
        })(a(Error));
        Object.defineProperty(h.prototype, "name", { value: "MongooseError" }), o.exports = h;
      }, 8235: (o, s, a) => {
        var u = a(8213), c = a(6426), f = a(5098), h = a(7910);
        function y(p, l) {
          if (this.$parentSchemaType = l && l.$parentSchemaType, !this.$parentSchemaType) throw new u("Cannot create DocumentArrayElement schematype without a parent");
          delete l.$parentSchemaType, c.call(this, p, l, "DocumentArrayElement"), this.$isMongooseDocumentArrayElement = !0;
        }
        y.schemaName = "DocumentArrayElement", y.defaultOptions = {}, y.prototype = Object.create(c.prototype), y.prototype.constructor = y, y.prototype.cast = function() {
          var p;
          return (p = this.$parentSchemaType).cast.apply(p, arguments)[0];
        }, y.prototype.doValidate = function(p, l, d, v) {
          var m = h(this.caster, p);
          return !p || p instanceof m || (p = new m(p, d, null, null, v && v.index != null ? v.index : null)), f.prototype.doValidate.call(this, p, l, d, v);
        }, y.prototype.clone = function() {
          this.options.$parentSchemaType = this.$parentSchemaType;
          var p = c.prototype.clone.apply(this, arguments);
          return delete this.options.$parentSchemaType, p.caster = this.caster, p.schema = this.schema, p;
        }, o.exports = y;
      }, 8250: (o, s, a) => {
        var u = a(5832).hp, c = a(6365), f = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i, h = c.Binary;
        function y(p) {
          typeof p != "string" && (p = "");
          var l, d = (l = p.replace(/[{}-]/g, "")) != null && u.from(l, "hex"), v = new c(d);
          return v._subtype = 4, v;
        }
        o.exports = function(p) {
          if (p == null) return p;
          function l(d) {
            var v = new c(d);
            return v._subtype = 4, v;
          }
          if (typeof p == "string") {
            if (f.test(p)) return y(p);
            throw new Error('"'.concat(p, '" is not a valid UUID string'));
          }
          if (u.isBuffer(p)) return l(p);
          if (p instanceof h) return l(p.value(!0));
          if (p.toString && p.toString !== Object.prototype.toString && f.test(p.toString())) return y(p.toString());
          throw new Error('"'.concat(p, '" cannot be casted to a UUID'));
        }, o.exports.UUID_FORMAT = f;
      }, 8260: (o) => {
        o.exports = function(s) {
          if (s != null && typeof s.constructor == "function") return s.constructor.name;
        };
      }, 8285: (o, s, a) => {
        var u = a(2400), c = a(2580), f = !1;
        o.exports = function() {
          return f ? c : u;
        }, o.exports.setBrowser = function(h) {
          f = h;
        };
      }, 8297: (o) => {
        function s(_, b) {
          var w = typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
          if (!w) {
            if (Array.isArray(_) || (w = u(_)) || b) {
              w && (_ = w);
              var A = 0, E = function() {
              };
              return { s: E, n: function() {
                return A >= _.length ? { done: !0 } : { done: !1, value: _[A++] };
              }, e: function(j) {
                throw j;
              }, f: E };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var O, $ = !0, k = !1;
          return { s: function() {
            w = w.call(_);
          }, n: function() {
            var j = w.next();
            return $ = j.done, j;
          }, e: function(j) {
            k = !0, O = j;
          }, f: function() {
            try {
              $ || w.return == null || w.return();
            } finally {
              if (k) throw O;
            }
          } };
        }
        function a(_) {
          return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, a(_);
        }
        function u(_, b) {
          if (_) {
            if (typeof _ == "string") return c(_, b);
            var w = {}.toString.call(_).slice(8, -1);
            return w === "Object" && _.constructor && (w = _.constructor.name), w === "Map" || w === "Set" ? Array.from(_) : w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w) ? c(_, b) : void 0;
          }
        }
        function c(_, b) {
          (b == null || b > _.length) && (b = _.length);
          for (var w = 0, A = Array(b); w < b; w++) A[w] = _[w];
          return A;
        }
        function f(_, b, w) {
          if (h()) return Reflect.construct.apply(null, arguments);
          var A = [null];
          A.push.apply(A, b);
          var E = new (_.bind.apply(_, A))();
          return E;
        }
        function h() {
          try {
            var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (h = function() {
            return !!_;
          })();
        }
        function y() {
          this._pres = /* @__PURE__ */ new Map(), this._posts = /* @__PURE__ */ new Map();
        }
        function p(_, b, w, A, E, O, $) {
          return O.useErrorHandlers ? _.execPost(w, A, E, { error: b }, function(k) {
            return typeof $ == "function" && $(k);
          }) : typeof $ == "function" && $(b);
        }
        function l(_, b, w, A) {
          var E;
          try {
            E = _.apply(b, w);
          } catch (O) {
            return A(O);
          }
          d(E) && E.then(function() {
            return A();
          }, function(O) {
            return A(O);
          });
        }
        function d(_) {
          return a(_) === "object" && _ !== null && typeof _.then == "function";
        }
        function v(_) {
          var b = !1, w = this;
          return function() {
            var A = arguments;
            if (!b) return b = !0, m(function() {
              return _.apply(w, A);
            });
          };
        }
        y.skipWrappedFunction = function() {
          if (!(this instanceof y.skipWrappedFunction)) return f(y.skipWrappedFunction, Array.prototype.slice.call(arguments));
          this.args = Array.prototype.slice.call(arguments);
        }, y.overwriteResult = function() {
          if (!(this instanceof y.overwriteResult)) return f(y.overwriteResult, Array.prototype.slice.call(arguments));
          this.args = Array.prototype.slice.call(arguments);
        }, y.prototype.execPre = function(_, b, w, A) {
          arguments.length === 3 && (A = w, w = []);
          var E = this._pres.get(_) || [], O = E.length, $ = E.numAsync || 0, k = 0, j = $, P = !1, R = w, I = null;
          if (!O) return m(function() {
            A(null);
          });
          function z() {
            if (!(k >= O)) {
              var F = E[k];
              if (F.isAsync) {
                var te = [v(W), v(function(L) {
                  if (L) {
                    if (P) return;
                    if (!(L instanceof y.skipWrappedFunction)) return P = !0, A(L);
                    I = L;
                  }
                  if (--j === 0 && k >= O) return A(I);
                })];
                l(F.fn, b, te, te[0]);
              } else if (F.fn.length > 0) {
                for (var ee = [v(W)], V = arguments.length >= 2 ? arguments : [null].concat(R), T = 1; T < V.length; ++T) T === V.length - 1 && typeof V[T] == "function" || ee.push(V[T]);
                l(F.fn, b, ee, ee[0]);
              } else {
                var D = null;
                try {
                  D = F.fn.call(b);
                } catch (L) {
                  if (L != null) return A(L);
                }
                if (d(D)) D.then(function() {
                  return W();
                }, function(L) {
                  return W(L);
                });
                else {
                  if (++k >= O) return j > 0 ? void 0 : m(function() {
                    A(I);
                  });
                  z();
                }
              }
            }
          }
          function W(F) {
            if (F) {
              if (P) return;
              if (!(F instanceof y.skipWrappedFunction)) return P = !0, A(F);
              I = F;
            }
            if (++k >= O) return j > 0 ? void 0 : A(I);
            z.apply(b, arguments);
          }
          z.apply(null, [null].concat(w));
        }, y.prototype.execPreSync = function(_, b, w) {
          for (var A = this._pres.get(_) || [], E = A.length, O = 0; O < E; ++O) A[O].fn.apply(b, w || []);
        }, y.prototype.execPost = function(_, b, w, A, E) {
          arguments.length < 5 && (E = A, A = null);
          var O = this._posts.get(_) || [], $ = O.length, k = 0, j = null;
          if (A && A.error && (j = A.error), !$) return m(function() {
            E.apply(null, [j].concat(w));
          });
          (function P() {
            for (var R = O[k].fn, I = 0, z = w.length, W = [], F = 0; F < z; ++F) I += w[F] && w[F]._kareemIgnore ? 0 : 1, w[F] && w[F]._kareemIgnore || W.push(w[F]);
            if (j) if (g(O[k], I)) {
              var te = v(function(D) {
                if (D) {
                  if (D instanceof y.overwriteResult) return w = D.args, ++k >= $ ? E.call(null, j) : P();
                  j = D;
                }
                if (++k >= $) return E.call(null, j);
                P();
              });
              l(R, b, [j].concat(W).concat([te]), te);
            } else {
              if (++k >= $) return E.call(null, j);
              P();
            }
            else {
              var ee = v(function(D) {
                return D ? D instanceof y.overwriteResult ? (w = D.args, ++k >= $ ? E.apply(null, [null].concat(w)) : P()) : (j = D, P()) : ++k >= $ ? E.apply(null, [null].concat(w)) : void P();
              });
              if (g(O[k], I)) return ++k >= $ ? E.apply(null, [null].concat(w)) : P();
              if (R.length === I + 1) l(R, b, W.concat([ee]), ee);
              else {
                var V, T;
                try {
                  T = R.apply(b, W);
                } catch (D) {
                  V = D, j = D;
                }
                if (d(T)) return T.then(function(D) {
                  ee(D instanceof y.overwriteResult ? D : null);
                }, function(D) {
                  return ee(D);
                });
                if (T instanceof y.overwriteResult && (w = T.args), ++k >= $) return E.apply(null, [V].concat(w));
                P();
              }
            }
          })();
        }, y.prototype.execPostSync = function(_, b, w) {
          for (var A = this._posts.get(_) || [], E = A.length, O = 0; O < E; ++O) {
            var $ = A[O].fn.apply(b, w || []);
            $ instanceof y.overwriteResult && (w = $.args);
          }
          return w;
        }, y.prototype.createWrapperSync = function(_, b) {
          var w = this;
          return function() {
            w.execPreSync(_, this, arguments);
            var A = b.apply(this, arguments);
            return w.execPostSync(_, this, [A])[0];
          };
        }, y.prototype.wrap = function(_, b, w, A, E) {
          var O = A.length > 0 ? A[A.length - 1] : null, $ = Array.from(A);
          typeof O == "function" && $.pop();
          var k = this, j = (E = E || {}).checkForPromise;
          this.execPre(_, w, A, function(P) {
            if (P && !(P instanceof y.skipWrappedFunction)) {
              for (var R = E.numCallbackParams || 0, I = E.contextParameter ? [w] : [], z = I.length; z < R; ++z) I.push(null);
              return p(k, P, _, w, I, E, O);
            }
            var W, F, te = b.length;
            if (P instanceof y.skipWrappedFunction) return W = P.args[0], ee.apply(void 0, [null].concat((function(V) {
              if (Array.isArray(V)) return c(V);
            })(F = P.args) || (function(V) {
              if (typeof Symbol < "u" && V[Symbol.iterator] != null || V["@@iterator"] != null) return Array.from(V);
            })(F) || u(F) || (function() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            })()));
            try {
              W = b.apply(w, $.concat(ee));
            } catch (V) {
              return ee(V);
            }
            if (j) {
              if (d(W)) return W.then(function(V) {
                return ee(null, V);
              }, function(V) {
                return ee(V);
              });
              if (te < $.length + 1) return ee(null, W);
            }
            function ee() {
              var V = Array.from(arguments);
              if (V.shift(), E.nullResultByDefault && V.length === 0 && V.push(null), arguments[0]) return p(k, arguments[0], _, w, V, E, O);
              k.execPost(_, w, V, function() {
                O !== null && (arguments[0] ? O(arguments[0]) : O.apply(w, arguments));
              });
            }
          });
        }, y.prototype.filter = function(_) {
          for (var b = this, w = this.clone(), A = Array.from(w._pres.keys()), E = function() {
            var I = $[O], z = b._pres.get(I).map(function(W) {
              return Object.assign({}, W, { name: I });
            }).filter(_);
            if (z.length === 0) return w._pres.delete(I), 1;
            z.numAsync = z.filter(function(W) {
              return W.isAsync;
            }).length, w._pres.set(I, z);
          }, O = 0, $ = A; O < $.length; O++) E();
          for (var k = Array.from(w._posts.keys()), j = function() {
            var I = R[P], z = b._posts.get(I).map(function(W) {
              return Object.assign({}, W, { name: I });
            }).filter(_);
            if (z.length === 0) return w._posts.delete(I), 1;
            w._posts.set(I, z);
          }, P = 0, R = k; P < R.length; P++) j();
          return w;
        }, y.prototype.hasHooks = function(_) {
          return this._pres.has(_) || this._posts.has(_);
        }, y.prototype.createWrapper = function(_, b, w, A) {
          var E = this;
          return this.hasHooks(_) ? function() {
            var O = w || this;
            E.wrap(_, b, O, Array.from(arguments), A);
          } : function() {
            var O = arguments, $ = this;
            m(function() {
              return b.apply($, O);
            });
          };
        }, y.prototype.pre = function(_, b, w, A, E) {
          var O = {};
          a(b) === "object" && b !== null ? b = (O = b).isAsync : typeof arguments[1] != "boolean" && (w = b, b = !1);
          var $ = this._pres.get(_) || [];
          if (this._pres.set(_, $), b && ($.numAsync = $.numAsync || 0, ++$.numAsync), typeof w != "function") throw new Error('pre() requires a function, got "' + a(w) + '"');
          return E ? $.unshift(Object.assign({}, O, { fn: w, isAsync: b })) : $.push(Object.assign({}, O, { fn: w, isAsync: b })), this;
        }, y.prototype.post = function(_, b, w, A) {
          var E = this._posts.get(_) || [];
          if (typeof b == "function" && (A = !!w, w = b, b = {}), typeof w != "function") throw new Error('post() requires a function, got "' + a(w) + '"');
          return A ? E.unshift(Object.assign({}, b, { fn: w })) : E.push(Object.assign({}, b, { fn: w })), this._posts.set(_, E), this;
        }, y.prototype.clone = function() {
          var _, b = new y(), w = s(this._pres.keys());
          try {
            for (w.s(); !(_ = w.n()).done; ) {
              var A = _.value, E = this._pres.get(A).slice();
              E.numAsync = this._pres.get(A).numAsync, b._pres.set(A, E);
            }
          } catch (j) {
            w.e(j);
          } finally {
            w.f();
          }
          var O, $ = s(this._posts.keys());
          try {
            for ($.s(); !(O = $.n()).done; ) {
              var k = O.value;
              b._posts.set(k, this._posts.get(k).slice());
            }
          } catch (j) {
            $.e(j);
          } finally {
            $.f();
          }
          return b;
        }, y.prototype.merge = function(_, b) {
          var w, A = (b = arguments.length === 1 || b) ? this.clone() : this, E = s(_._pres.keys());
          try {
            var O = function() {
              var P = w.value, R = A._pres.get(P) || [], I = _._pres.get(P).filter(function(W) {
                return R.map(function(F) {
                  return F.fn;
                }).indexOf(W.fn) === -1;
              }), z = R.concat(I);
              z.numAsync = R.numAsync || 0, z.numAsync += I.filter(function(W) {
                return W.isAsync;
              }).length, A._pres.set(P, z);
            };
            for (E.s(); !(w = E.n()).done; ) O();
          } catch (P) {
            E.e(P);
          } finally {
            E.f();
          }
          var $, k = s(_._posts.keys());
          try {
            var j = function() {
              var P = $.value, R = A._posts.get(P) || [], I = _._posts.get(P).filter(function(z) {
                return R.indexOf(z) === -1;
              });
              A._posts.set(P, R.concat(I));
            };
            for (k.s(); !($ = k.n()).done; ) j();
          } catch (P) {
            k.e(P);
          } finally {
            k.f();
          }
          return A;
        };
        var m = a({ env: {} }) === "object" && {} !== null && {}.nextTick || function(_) {
          setTimeout(_, 0);
        };
        function g(_, b) {
          return !!_.errorHandler || _.fn.length === b + 2;
        }
        o.exports = y;
      }, 8435: (o) => {
        o.exports = Math.min;
      }, 8442: (o, s, a) => {
        var u = a(1898);
        o.exports = function(c) {
          for (var f = 0, h = Object.values(u); f < h.length; f++) (0, h[f])(c, { deduplicate: !0 });
          c.plugins = Object.values(u).map(function(y) {
            return { fn: y, opts: { deduplicate: !0 } };
          }).concat(c.plugins);
        };
      }, 8499: (o, s, a) => {
        var u = a(8953);
        o.exports = function(c) {
          var f = this != null ? this.path : null;
          return u(c, f);
        };
      }, 8517: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m, g) {
            var _, b, w;
            (function(k, j) {
              if (!(k instanceof j)) throw new TypeError("Cannot call a class as a function");
            })(this, l);
            var A = (_ = g?.matchedCount) !== null && _ !== void 0 ? _ : 0, E = (b = g?.insertedCount) !== null && b !== void 0 ? b : 0, O = m.map(function(k) {
              return k._id;
            }).join(", ");
            O.length > 100 && (O = O.slice(0, 100) + "...");
            var $ = m.length - A - E;
            return (w = (function(k, j, P) {
              return j = f(j), (function(R, I) {
                if (I && (u(I) == "object" || typeof I == "function")) return I;
                if (I !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(z) {
                  if (z === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return z;
                })(R);
              })(k, c() ? Reflect.construct(j, P || [], f(k).constructor) : j.apply(k, P));
            })(this, l, ["".concat(v, ".bulkSave() was not able to update ").concat($, " of the given documents due to incorrect version or optimistic concurrency, document ids: ").concat(O)])).modelName = v, w.documents = m, w.bulkWriteResult = g, w.numDocumentsNotUpdated = $, w;
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "MongooseBulkSaveIncompleteError" }), o.exports = y;
      }, 8533: (o, s, a) => {
        var u = a(5832).hp;
        function c(l) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, c(l);
        }
        function f() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (f = function() {
            return !!l;
          })();
        }
        function h(l) {
          return h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, h(l);
        }
        function y(l, d) {
          return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, y(l, d);
        }
        a(7591).set(a(4026));
        var p = a(8285);
        p.setBrowser(!0), s.Error = a(3672), s.Schema = a(7058), s.Types = a(9600), s.VirtualType = a(622), s.SchemaType = a(6426), s.SchemaTypeOptions = a(8879), s.utils = a(8768), s.Document = p(), s.model = function(l, d) {
          var v = (function(m) {
            function g(b, w) {
              return (function(A, E) {
                if (!(A instanceof E)) throw new TypeError("Cannot call a class as a function");
              })(this, g), (function(A, E, O) {
                return E = h(E), (function($, k) {
                  if (k && (c(k) == "object" || typeof k == "function")) return k;
                  if (k !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                  return (function(j) {
                    if (j === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return j;
                  })($);
                })(A, f() ? Reflect.construct(E, O || [], h(A).constructor) : E.apply(A, O));
              })(this, g, [b, d, w]);
            }
            return (function(b, w) {
              if (typeof w != "function" && w !== null) throw new TypeError("Super expression must either be null or a function");
              b.prototype = Object.create(w && w.prototype, { constructor: { value: b, writable: !0, configurable: !0 } }), Object.defineProperty(b, "prototype", { writable: !1 }), w && y(b, w);
            })(g, m), _ = g, Object.defineProperty(_, "prototype", { writable: !1 }), _;
            var _;
          })(s.Document);
          return v.modelName = l, v;
        }, typeof window < "u" && (window.mongoose = o.exports, window.Buffer = u);
      }, 8633: (o) => {
        o.exports = Math.pow;
      }, 8690: (o) => {
        function s() {
          var c, f, h = typeof Symbol == "function" ? Symbol : {}, y = h.iterator || "@@iterator", p = h.toStringTag || "@@toStringTag";
          function l(A, E, O, $) {
            var k = E && E.prototype instanceof v ? E : v, j = Object.create(k.prototype);
            return a(j, "_invoke", (function(P, R, I) {
              var z, W, F, te = 0, ee = I || [], V = !1, T = { p: 0, n: 0, v: c, a: D, f: D.bind(c, 4), d: function(L, M) {
                return z = L, W = 0, F = c, T.n = M, d;
              } };
              function D(L, M) {
                for (W = L, F = M, f = 0; !V && te && !N && f < ee.length; f++) {
                  var N, Z = ee[f], Y = T.p, ie = Z[2];
                  L > 3 ? (N = ie === M) && (F = Z[(W = Z[4]) ? 5 : (W = 3, 3)], Z[4] = Z[5] = c) : Z[0] <= Y && ((N = L < 2 && Y < Z[1]) ? (W = 0, T.v = M, T.n = Z[1]) : Y < ie && (N = L < 3 || Z[0] > M || M > ie) && (Z[4] = L, Z[5] = M, T.n = ie, W = 0));
                }
                if (N || L > 1) return d;
                throw V = !0, M;
              }
              return function(L, M, N) {
                if (te > 1) throw TypeError("Generator is already running");
                for (V && M === 1 && D(M, N), W = M, F = N; (f = W < 2 ? c : F) || !V; ) {
                  z || (W ? W < 3 ? (W > 1 && (T.n = -1), D(W, F)) : T.n = F : T.v = F);
                  try {
                    if (te = 2, z) {
                      if (W || (L = "next"), f = z[L]) {
                        if (!(f = f.call(z, F))) throw TypeError("iterator result is not an object");
                        if (!f.done) return f;
                        F = f.value, W < 2 && (W = 0);
                      } else W === 1 && (f = z.return) && f.call(z), W < 2 && (F = TypeError("The iterator does not provide a '" + L + "' method"), W = 1);
                      z = c;
                    } else if ((f = (V = T.n < 0) ? F : P.call(R, T)) !== d) break;
                  } catch (Z) {
                    z = c, W = 1, F = Z;
                  } finally {
                    te = 1;
                  }
                }
                return { value: f, done: V };
              };
            })(A, O, $), !0), j;
          }
          var d = {};
          function v() {
          }
          function m() {
          }
          function g() {
          }
          f = Object.getPrototypeOf;
          var _ = [][y] ? f(f([][y]())) : (a(f = {}, y, function() {
            return this;
          }), f), b = g.prototype = v.prototype = Object.create(_);
          function w(A) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(A, g) : (A.__proto__ = g, a(A, p, "GeneratorFunction")), A.prototype = Object.create(b), A;
          }
          return m.prototype = g, a(b, "constructor", g), a(g, "constructor", m), m.displayName = "GeneratorFunction", a(g, p, "GeneratorFunction"), a(b), a(b, p, "Generator"), a(b, y, function() {
            return this;
          }), a(b, "toString", function() {
            return "[object Generator]";
          }), (s = function() {
            return { w: l, m: w };
          })();
        }
        function a(c, f, h, y) {
          var p = Object.defineProperty;
          try {
            p({}, "", {});
          } catch {
            p = 0;
          }
          a = function(l, d, v, m) {
            function g(_, b) {
              a(l, _, function(w) {
                return this._invoke(_, b, w);
              });
            }
            d ? p ? p(l, d, { value: v, enumerable: !m, configurable: !m, writable: !m }) : l[d] = v : (g("next", 0), g("throw", 1), g("return", 2));
          }, a(c, f, h, y);
        }
        var u = s().m(function c() {
          return s().w(function(f) {
            for (; ; ) if (f.n === 0) return f.a(2);
          }, c);
        }).constructor;
        o.exports = function() {
          return u;
        };
      }, 8728: (o, s, a) => {
        function u($, k) {
          var j = Object.keys($);
          if (Object.getOwnPropertySymbols) {
            var P = Object.getOwnPropertySymbols($);
            k && (P = P.filter(function(R) {
              return Object.getOwnPropertyDescriptor($, R).enumerable;
            })), j.push.apply(j, P);
          }
          return j;
        }
        function c($) {
          for (var k = 1; k < arguments.length; k++) {
            var j = arguments[k] != null ? arguments[k] : {};
            k % 2 ? u(Object(j), !0).forEach(function(P) {
              f($, P, j[P]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(j)) : u(Object(j)).forEach(function(P) {
              Object.defineProperty($, P, Object.getOwnPropertyDescriptor(j, P));
            });
          }
          return $;
        }
        function f($, k, j) {
          return (k = (function(P) {
            var R = (function(I) {
              if (h(I) != "object" || !I) return I;
              var z = I[Symbol.toPrimitive];
              if (z !== void 0) {
                var W = z.call(I, "string");
                if (h(W) != "object") return W;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(I);
            })(P);
            return h(R) == "symbol" ? R : R + "";
          })(k)) in $ ? Object.defineProperty($, k, { value: j, enumerable: !0, configurable: !0, writable: !0 }) : $[k] = j, $;
        }
        function h($) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
            return typeof k;
          } : function(k) {
            return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
          }, h($);
        }
        function y($, k) {
          (k == null || k > $.length) && (k = $.length);
          for (var j = 0, P = Array(k); j < k; j++) P[j] = $[j];
          return P;
        }
        var p = a(6426), l = a(3672), d = a(9528), v = a(1244), m = a(4327), g = a(8768), _ = a(3305), b = p.CastError;
        function w($, k) {
          this.enumValues = [], this.regExp = null, p.call(this, $, k, "String");
        }
        function A($, k) {
          return this.castForQuery(null, $, k);
        }
        function E($) {
          return $ == null ? this._castNullish($) : this.cast($, this);
        }
        w.schemaName = "String", w.defaultOptions = {}, w.prototype = Object.create(p.prototype), w.prototype.constructor = w, Object.defineProperty(w.prototype, "OptionsConstructor", { configurable: !1, enumerable: !1, writable: !1, value: d }), w._cast = v, w.cast = function($) {
          return arguments.length === 0 || ($ === !1 && ($ = this._defaultCaster), this._cast = $), this._cast;
        }, w._defaultCaster = function($) {
          if ($ != null && typeof $ != "string") throw new Error();
          return $;
        }, w.get = p.get, w.set = p.set, w.setters = [], w._checkRequired = function($) {
          return ($ instanceof String || typeof $ == "string") && $.length;
        }, w.checkRequired = p.checkRequired, w.prototype.enum = function() {
          if (this.enumValidator && (this.validators = this.validators.filter(function(z) {
            return z.validator !== this.enumValidator;
          }, this), this.enumValidator = !1), arguments[0] === void 0 || arguments[0] === !1) return this;
          var $, k;
          g.isObject(arguments[0]) ? Array.isArray(arguments[0].values) ? ($ = arguments[0].values, k = arguments[0].message) : ($ = g.object.vals(arguments[0]), k = l.messages.String.enum) : ($ = arguments, k = l.messages.String.enum);
          var j, P = (function(z, W) {
            var F = typeof Symbol < "u" && z[Symbol.iterator] || z["@@iterator"];
            if (!F) {
              if (Array.isArray(z) || (F = (function(L, M) {
                if (L) {
                  if (typeof L == "string") return y(L, M);
                  var N = {}.toString.call(L).slice(8, -1);
                  return N === "Object" && L.constructor && (N = L.constructor.name), N === "Map" || N === "Set" ? Array.from(L) : N === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(N) ? y(L, M) : void 0;
                }
              })(z)) || W) {
                F && (z = F);
                var te = 0, ee = function() {
                };
                return { s: ee, n: function() {
                  return te >= z.length ? { done: !0 } : { done: !1, value: z[te++] };
                }, e: function(L) {
                  throw L;
                }, f: ee };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var V, T = !0, D = !1;
            return { s: function() {
              F = F.call(z);
            }, n: function() {
              var L = F.next();
              return T = L.done, L;
            }, e: function(L) {
              D = !0, V = L;
            }, f: function() {
              try {
                T || F.return == null || F.return();
              } finally {
                if (D) throw V;
              }
            } };
          })($);
          try {
            for (P.s(); !(j = P.n()).done; ) {
              var R = j.value;
              R !== void 0 && this.enumValues.push(this.cast(R));
            }
          } catch (z) {
            P.e(z);
          } finally {
            P.f();
          }
          var I = this.enumValues;
          return this.enumValidator = function(z) {
            return z == null || ~I.indexOf(z);
          }, this.validators.push({ validator: this.enumValidator, message: k, type: "enum", enumValues: I }), this;
        }, w.prototype.lowercase = function($) {
          var k = this;
          return arguments.length > 0 && !$ ? this : this.set(function(j) {
            return typeof j != "string" && (j = k.cast(j)), j && j.toLowerCase();
          });
        }, w.prototype.uppercase = function($) {
          var k = this;
          return arguments.length > 0 && !$ ? this : this.set(function(j) {
            return typeof j != "string" && (j = k.cast(j)), j && j.toUpperCase();
          });
        }, w.prototype.trim = function($) {
          var k = this;
          return arguments.length > 0 && !$ ? this : this.set(function(j) {
            return typeof j != "string" && (j = k.cast(j)), j && j.trim();
          });
        }, w.prototype.minlength = function($, k) {
          if (this.minlengthValidator && (this.validators = this.validators.filter(function(P) {
            return P.validator !== this.minlengthValidator;
          }, this)), $ != null) {
            var j = k || l.messages.String.minlength;
            j = j.replace(/{MINLENGTH}/, $), this.validators.push({ validator: this.minlengthValidator = function(P) {
              return P === null || P.length >= $;
            }, message: j, type: "minlength", minlength: $ });
          }
          return this;
        }, w.prototype.minLength = w.prototype.minlength, w.prototype.maxlength = function($, k) {
          if (this.maxlengthValidator && (this.validators = this.validators.filter(function(P) {
            return P.validator !== this.maxlengthValidator;
          }, this)), $ != null) {
            var j = k || l.messages.String.maxlength;
            j = j.replace(/{MAXLENGTH}/, $), this.validators.push({ validator: this.maxlengthValidator = function(P) {
              return P === null || P.length <= $;
            }, message: j, type: "maxlength", maxlength: $ });
          }
          return this;
        }, w.prototype.maxLength = w.prototype.maxlength, w.prototype.match = function($, k) {
          var j = k || l.messages.String.match;
          return this.validators.push({ validator: function(P) {
            return !!$ && ($.lastIndex = 0, P == null || P === "" || $.test(P));
          }, message: j, type: "regexp", regexp: $ }), this;
        }, w.prototype.checkRequired = function($, k) {
          return h($) === "object" && p._isRef(this, $, k, !0) ? $ != null : (typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : w.checkRequired())($);
        }, w.prototype.cast = function($, k, j, P, R) {
          if (typeof $ != "string" && p._isRef(this, $, k, j)) return this._castRef($, k, j, R);
          var I;
          I = typeof this._castFunction == "function" ? this._castFunction : typeof this.constructor.cast == "function" ? this.constructor.cast() : w.cast();
          try {
            return I($);
          } catch {
            throw new b("string", $, this.path, null, this);
          }
        };
        var O = c(c({}, p.prototype.$conditionalHandlers), {}, { $all: function($, k) {
          var j = this;
          return Array.isArray($) ? $.map(function(P) {
            return j.castForQuery(null, P, k);
          }) : [this.castForQuery(null, $, k)];
        }, $gt: A, $gte: A, $lt: A, $lte: A, $options: E, $regex: function($) {
          return Object.prototype.toString.call($) === "[object RegExp]" ? $ : E.call(this, $);
        }, $not: A });
        Object.defineProperty(w.prototype, "$conditionalHandlers", { enumerable: !1, value: O }), w.prototype.castForQuery = function($, k, j) {
          var P;
          if ($ != null) {
            if (!(P = this.$conditionalHandlers[$])) throw new Error("Can't use " + $ + " with String.");
            return P.call(this, k, j);
          }
          if (Object.prototype.toString.call(k) === "[object RegExp]" || _(k, "BSONRegExp")) return k;
          try {
            return this.applySetters(k, j);
          } catch (R) {
            throw R instanceof b && R.path === this.path && this.$fullPath != null && (R.path = this.$fullPath), R;
          }
        }, w.prototype.toJSONSchema = function($) {
          var k = this.options.required && typeof this.options.required != "function";
          return m("string", "string", $?.useBsonType, k);
        }, w.prototype.autoEncryptionType = function() {
          return "string";
        }, o.exports = w;
      }, 8759: (o) => {
        o.exports = function(s) {
          return s.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
        };
      }, 8768: (o, s, a) => {
        var u = a(5832).hp;
        function c(N, Z) {
          var Y = Object.keys(N);
          if (Object.getOwnPropertySymbols) {
            var ie = Object.getOwnPropertySymbols(N);
            Z && (ie = ie.filter(function(le) {
              return Object.getOwnPropertyDescriptor(N, le).enumerable;
            })), Y.push.apply(Y, ie);
          }
          return Y;
        }
        function f(N, Z, Y) {
          return (Z = (function(ie) {
            var le = (function(de) {
              if (l(de) != "object" || !de) return de;
              var ae = de[Symbol.toPrimitive];
              if (ae !== void 0) {
                var ne = ae.call(de, "string");
                if (l(ne) != "object") return ne;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(de);
            })(ie);
            return l(le) == "symbol" ? le : le + "";
          })(Z)) in N ? Object.defineProperty(N, Z, { value: Y, enumerable: !0, configurable: !0, writable: !0 }) : N[Z] = Y, N;
        }
        function h(N, Z) {
          var Y = typeof Symbol < "u" && N[Symbol.iterator] || N["@@iterator"];
          if (!Y) {
            if (Array.isArray(N) || (Y = y(N)) || Z) {
              Y && (N = Y);
              var ie = 0, le = function() {
              };
              return { s: le, n: function() {
                return ie >= N.length ? { done: !0 } : { done: !1, value: N[ie++] };
              }, e: function(he) {
                throw he;
              }, f: le };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var de, ae = !0, ne = !1;
          return { s: function() {
            Y = Y.call(N);
          }, n: function() {
            var he = Y.next();
            return ae = he.done, he;
          }, e: function(he) {
            ne = !0, de = he;
          }, f: function() {
            try {
              ae || Y.return == null || Y.return();
            } finally {
              if (ne) throw de;
            }
          } };
        }
        function y(N, Z) {
          if (N) {
            if (typeof N == "string") return p(N, Z);
            var Y = {}.toString.call(N).slice(8, -1);
            return Y === "Object" && N.constructor && (Y = N.constructor.name), Y === "Map" || Y === "Set" ? Array.from(N) : Y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Y) ? p(N, Z) : void 0;
          }
        }
        function p(N, Z) {
          (Z == null || Z > N.length) && (Z = N.length);
          for (var Y = 0, ie = Array(Z); Y < Z; Y++) ie[Y] = N[Y];
          return ie;
        }
        function l(N) {
          return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Z) {
            return typeof Z;
          } : function(Z) {
            return Z && typeof Symbol == "function" && Z.constructor === Symbol && Z !== Symbol.prototype ? "symbol" : typeof Z;
          }, l(N);
        }
        var d, v = a(6353).UUID, m = a(354), g = a(5678), _ = a(5549), b = a(6948), w = a(4450), A = a(2746), E = a(608), O = a(1243), $ = a(1347), k = a(3305), j = a(2789), P = a(9696), R = a(2497), I = a(5268), z = a(9539), W = a(2793), F = a(7291).trustedSymbol;
        s.specialProperties = W, s.isMongooseArray = O.isMongooseArray, s.isMongooseDocumentArray = $.isMongooseDocumentArray, s.registerMongooseArray = O.registerMongooseArray, s.registerMongooseDocumentArray = $.registerMongooseDocumentArray;
        var te = /\s/, ee = /\s+/;
        s.toCollectionName = function(N, Z) {
          if (N === "system.profile" || N === "system.indexes") return N;
          if (typeof Z == "function") {
            if (typeof N != "string") throw new TypeError("Collection name must be a string");
            if (N.length === 0) throw new TypeError("Collection name cannot be empty");
            return Z(N);
          }
          return N;
        }, s.deepEqual = function N(Z, Y) {
          if (Z === Y) return !0;
          if (l(Z) !== "object" || l(Y) !== "object") return Z === Y;
          if (Z instanceof Date && Y instanceof Date) return Z.getTime() === Y.getTime();
          if (k(Z, "ObjectId") && k(Y, "ObjectId") || k(Z, "Decimal128") && k(Y, "Decimal128")) return Z.toString() === Y.toString();
          if (Z instanceof RegExp && Y instanceof RegExp) return Z.source === Y.source && Z.ignoreCase === Y.ignoreCase && Z.multiline === Y.multiline && Z.global === Y.global && Z.dotAll === Y.dotAll && Z.unicode === Y.unicode && Z.sticky === Y.sticky && Z.hasIndices === Y.hasIndices;
          if (Z == null || Y == null || Z.prototype !== Y.prototype) return !1;
          if (Z instanceof Map || Y instanceof Map) return Z instanceof Map && Y instanceof Map && N(Array.from(Z.keys()), Array.from(Y.keys())) && N(Array.from(Z.values()), Array.from(Y.values()));
          if (Z instanceof Number && Y instanceof Number) return Z.valueOf() === Y.valueOf();
          if (u.isBuffer(Z)) return s.buffer.areEqual(Z, Y);
          if (Array.isArray(Z) || Array.isArray(Y)) {
            if (!Array.isArray(Z) || !Array.isArray(Y)) return !1;
            var ie = Z.length;
            if (ie !== Y.length) return !1;
            for (var le = 0; le < ie; ++le) if (!N(Z[le], Y[le])) return !1;
            return !0;
          }
          Z.$__ != null ? Z = Z._doc : R(Z) && (Z = Z.toObject()), Y.$__ != null ? Y = Y._doc : R(Y) && (Y = Y.toObject());
          var de = Object.keys(Z), ae = Object.keys(Y), ne = de.length;
          if (ne !== ae.length) return !1;
          for (var he = ne - 1; he >= 0; he--) if (de[he] !== ae[he]) return !1;
          for (var x = 0, U = de; x < U.length; x++) {
            var B = U[x];
            if (!N(Z[B], Y[B])) return !1;
          }
          return !0;
        }, s.last = function(N) {
          if (N.length > 0) return N[N.length - 1];
        }, s.promiseOrCallback = I, s.cloneArrays = function(N) {
          return Array.isArray(N) ? N.map(function(Z) {
            return s.cloneArrays(Z);
          }) : N;
        }, s.omit = function(N, Z) {
          if (Z == null) return Object.assign({}, N);
          Array.isArray(Z) || (Z = [Z]);
          var Y, ie = Object.assign({}, N), le = h(Z);
          try {
            for (le.s(); !(Y = le.n()).done; ) delete ie[Y.value];
          } catch (de) {
            le.e(de);
          } finally {
            le.f();
          }
          return ie;
        }, s.clonePOJOsAndArrays = function(N) {
          if (N == null || N.$__ != null) return N;
          if (j(N)) {
            N = (function(ae) {
              for (var ne = 1; ne < arguments.length; ne++) {
                var he = arguments[ne] != null ? arguments[ne] : {};
                ne % 2 ? c(Object(he), !0).forEach(function(x) {
                  f(ae, x, he[x]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ae, Object.getOwnPropertyDescriptors(he)) : c(Object(he)).forEach(function(x) {
                  Object.defineProperty(ae, x, Object.getOwnPropertyDescriptor(he, x));
                });
              }
              return ae;
            })({}, N);
            for (var Z = 0, Y = Object.keys(N); Z < Y.length; Z++) {
              var ie = Y[Z];
              N[ie] = s.clonePOJOsAndArrays(N[ie]);
            }
            return N;
          }
          if (Array.isArray(N)) {
            N = (function(ae) {
              if (Array.isArray(ae)) return p(ae);
            })(de = N) || (function(ae) {
              if (typeof Symbol < "u" && ae[Symbol.iterator] != null || ae["@@iterator"] != null) return Array.from(ae);
            })(de) || y(de) || (function() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            })();
            for (var le = 0; le < N.length; ++le) N[le] = s.clonePOJOsAndArrays(N[le]);
            return N;
          }
          var de;
          return N;
        }, s.merge = function N(Z, Y, ie, le) {
          ie = ie || {};
          var de, ae = Object.keys(Y), ne = 0, he = ae.length;
          Y[F] && (Z[F] = Y[F]), le = le || "";
          for (var x = ie.omitNested || {}; ne < he; ) if (de = ae[ne++], !(ie.omit && ie.omit[de] || x[le] || W.has(de))) if (Z[de] == null) Z[de] = s.clonePOJOsAndArrays(Y[de]);
          else if (s.isObject(Y[de])) {
            if (s.isObject(Z[de]) || (Z[de] = {}), Y[de] != null) {
              if (ie.isDiscriminatorSchemaMerge && Y[de].$isSingleNested && Z[de].$isMongooseDocumentArray || Y[de].$isMongooseDocumentArray && Z[de].$isSingleNested) continue;
              if (Y[de].instanceOfSchema) {
                Z[de].instanceOfSchema ? z(Z[de], Y[de].clone(), ie.isDiscriminatorSchemaMerge) : Z[de] = Y[de].clone();
                continue;
              }
              if (k(Y[de], "ObjectId")) {
                Z[de] = new _(Y[de]);
                continue;
              }
            }
            N(Z[de], Y[de], ie, le ? le + "." + de : de);
          } else ie.overwrite && (Z[de] = Y[de]);
          return Z;
        }, s.toObject = function N(Z) {
          var Y;
          if (d || (d = a(2400)), Z == null) return Z;
          if (Z instanceof d) return Z.toObject();
          if (Array.isArray(Z)) {
            Y = [];
            var ie, le = h(Z);
            try {
              for (le.s(); !(ie = le.n()).done; ) {
                var de = ie.value;
                Y.push(N(de));
              }
            } catch (x) {
              le.e(x);
            } finally {
              le.f();
            }
            return Y;
          }
          if (s.isPOJO(Z)) {
            Y = {}, Z[F] && (Y[F] = Z[F]);
            for (var ae = 0, ne = Object.keys(Z); ae < ne.length; ae++) {
              var he = ne[ae];
              W.has(he) || (Y[he] = N(Z[he]));
            }
            return Y;
          }
          return Z;
        }, s.isObject = E, s.isPOJO = a(2789), s.isNonBuiltinObject = function(N) {
          return !(l(N) !== "object" || s.isNativeObject(N) || s.isMongooseType(N) || N instanceof v || N == null);
        }, s.isNativeObject = function(N) {
          return Array.isArray(N) || N instanceof Date || N instanceof Boolean || N instanceof Number || N instanceof String;
        }, s.isEmptyObject = function(N) {
          return N != null && l(N) === "object" && Object.keys(N).length === 0;
        }, s.hasKey = function(N, Z) {
          for (var Y = 0, ie = Object.keys(N); Y < ie.length; Y++) {
            var le = ie[Y];
            if (le === Z || s.isPOJO(N[le]) && s.hasKey(N[le], Z)) return !0;
          }
          return !1;
        }, s.tick = function(N) {
          if (typeof N == "function") return function() {
            try {
              N.apply(this, arguments);
            } catch (Z) {
              A(function() {
                throw Z;
              });
            }
          };
        }, s.isMongooseType = function(N) {
          return k(N, "ObjectId") || k(N, "Decimal128") || N instanceof u;
        }, s.isMongooseObject = R, s.expires = function(N) {
          N && N.constructor.name === "Object" && "expires" in N && (N.expireAfterSeconds = typeof N.expires != "string" ? N.expires : Math.round(m(N.expires) / 1e3), delete N.expires);
        }, s.populate = function(N, Z, Y, ie, le, de, ae, ne) {
          var he, x = null;
          if (arguments.length === 1) {
            if (N instanceof b) return N._docs = {}, N._childDocs = [], [N];
            if (Array.isArray(N)) {
              var U = (he = [], N.forEach(function(B) {
                te.test(B.path) ? B.path.split(ee).forEach(function(J) {
                  var X = Object.assign({}, B);
                  X.path = J, he.push(X);
                }) : he.push(B);
              }), he);
              return U.map(function(B) {
                return s.populate(B)[0];
              });
            }
            x = s.isObject(N) ? Object.assign({}, N) : { path: N };
          } else x = l(Y) === "object" ? { path: N, select: Z, match: Y, options: ie } : { path: N, select: Z, model: Y, match: ie, options: le, populate: de, justOne: ae, count: ne };
          if (!(typeof x.path == "string" || Array.isArray(x.path) && x.path.every(function(B) {
            return typeof B == "string";
          }))) throw new TypeError("utils.populate: invalid path. Expected string or array of strings. Got typeof `" + l(N) + "`");
          return (function(B) {
            if (Array.isArray(B.populate)) {
              var J = [];
              B.populate.forEach(function(ce) {
                if (te.test(ce.path)) {
                  var ue = Object.assign({}, ce);
                  ue.path.split(ee).forEach(function(re) {
                    ue.path = re, J.push(s.populate(ue)[0]);
                  });
                } else J.push(s.populate(ce)[0]);
              }), B.populate = s.populate(J);
            } else B.populate != null && l(B.populate) === "object" && (B.populate = s.populate(B.populate));
            var X = [], oe = te.test(B.path) ? B.path.split(ee) : Array.isArray(B.path) ? B.path : [B.path];
            B.options != null && (B.options = w(B.options));
            var ye, q = h(oe);
            try {
              for (q.s(); !(ye = q.n()).done; ) {
                var G = ye.value;
                X.push(new b(Object.assign({}, B, { path: G })));
              }
            } catch (ce) {
              q.e(ce);
            } finally {
              q.f();
            }
            return X;
          })(x);
        }, s.getValue = function(N, Z, Y) {
          return g.get(N, Z, T, Y);
        };
        var V = Object.freeze({ getters: !1 });
        function T(N, Z) {
          if (Z === "$*" && N instanceof Map) return N;
          var Y = N?._doc || N;
          return Y != null && Y.isMongooseArrayProxy && (Y = Y.__array), Y instanceof Map ? Y.get(Z, V) : Y[Z];
        }
        s.setValue = function(N, Z, Y, ie, le) {
          g.set(N, Z, Y, "_doc", ie, le);
        }, s.object = {}, s.object.vals = function(N) {
          for (var Z = Object.keys(N), Y = Z.length, ie = []; Y--; ) ie.push(N[Z[Y]]);
          return ie;
        };
        var D = Object.prototype.hasOwnProperty;
        s.object.hasOwnProperty = function(N, Z) {
          return D.call(N, Z);
        }, s.isNullOrUndefined = function(N) {
          return N == null;
        }, s.array = {}, s.array.flatten = function N(Z, Y, ie) {
          return ie || (ie = []), Z.forEach(function(le) {
            Array.isArray(le) ? N(le, Y, ie) : Y && !Y(le) || ie.push(le);
          }), ie;
        };
        var L = Object.prototype.hasOwnProperty;
        s.hasUserDefinedProperty = function(N, Z) {
          if (N == null) return !1;
          if (Array.isArray(Z)) {
            var Y, ie = h(Z);
            try {
              for (ie.s(); !(Y = ie.n()).done; ) {
                var le = Y.value;
                if (s.hasUserDefinedProperty(N, le)) return !0;
              }
            } catch (ae) {
              ie.e(ae);
            } finally {
              ie.f();
            }
            return !1;
          }
          if (L.call(N, Z)) return !0;
          if (l(N) === "object" && Z in N) {
            var de = N[Z];
            return de !== Object.prototype[Z] && de !== Array.prototype[Z];
          }
          return !1;
        };
        var M = Math.pow(2, 32) - 1;
        s.isArrayIndex = function(N) {
          return typeof N == "number" ? N >= 0 && N <= M : typeof N == "string" && !!/^\d+$/.test(N) && (N = +N) >= 0 && N <= M;
        }, s.array.unique = function(N) {
          var Z, Y = /* @__PURE__ */ new Set(), ie = /* @__PURE__ */ new Set(), le = [], de = h(N);
          try {
            for (de.s(); !(Z = de.n()).done; ) {
              var ae = Z.value;
              if (typeof ae == "number" || typeof ae == "string" || ae == null) {
                if (Y.has(ae)) continue;
                le.push(ae), Y.add(ae);
              } else if (k(ae, "ObjectId")) {
                if (ie.has(ae.toString())) continue;
                le.push(ae), ie.add(ae.toString());
              } else le.push(ae);
            }
          } catch (ne) {
            de.e(ne);
          } finally {
            de.f();
          }
          return le;
        }, s.buffer = {}, s.buffer.areEqual = function(N, Z) {
          if (!u.isBuffer(N) || !u.isBuffer(Z) || N.length !== Z.length) return !1;
          for (var Y = 0, ie = N.length; Y < ie; ++Y) if (N[Y] !== Z[Y]) return !1;
          return !0;
        }, s.getFunctionName = P, s.decorate = function(N, Z) {
          for (var Y in Z) W.has(Y) || (N[Y] = Z[Y]);
        }, s.mergeClone = function(N, Z) {
          R(Z) && (Z = Z.toObject({ transform: !1, virtuals: !1, depopulate: !0, getters: !1, flattenDecimals: !1 }));
          for (var Y, ie = Object.keys(Z), le = ie.length, de = 0; de < le; ) if (Y = ie[de++], !W.has(Y)) if (N[Y] === void 0) N[Y] = w(Z[Y], { transform: !1, virtuals: !1, depopulate: !0, getters: !1, flattenDecimals: !1 });
          else {
            var ae = Z[Y];
            if (ae == null || !ae.valueOf || ae instanceof Date || (ae = ae.valueOf()), s.isObject(ae)) {
              var ne = ae;
              R(ae) && !ae.isMongooseBuffer && (ne = ne.toObject({ transform: !1, virtuals: !1, depopulate: !0, getters: !1, flattenDecimals: !1 })), ae.isMongooseBuffer && (ne = u.from(ne)), s.mergeClone(N[Y], ne);
            } else N[Y] = w(ae, { flattenDecimals: !1 });
          }
        }, s.each = function(N, Z) {
          var Y, ie = h(N);
          try {
            for (ie.s(); !(Y = ie.n()).done; ) Z(Y.value);
          } catch (le) {
            ie.e(le);
          } finally {
            ie.f();
          }
        }, s.renameObjKey = function(N, Z, Y) {
          return Object.keys(N).reduce(function(ie, le) {
            return le === Z ? ie[Y] = N[Z] : ie[le] = N[le], ie;
          }, {});
        }, s.getOption = function(N) {
          var Z, Y = h(Array.prototype.slice.call(arguments, 1));
          try {
            for (Y.s(); !(Z = Y.n()).done; ) {
              var ie = Z.value;
              if (ie != null && ie[N] != null) return ie[N];
            }
          } catch (le) {
            Y.e(le);
          } finally {
            Y.f();
          }
          return null;
        }, s.noop = function() {
        }, s.errorToPOJO = function(N) {
          if (!(N instanceof Error)) throw new Error("`error` must be `instanceof Error`.");
          var Z, Y = {}, ie = h(Object.getOwnPropertyNames(N));
          try {
            for (ie.s(); !(Z = ie.n()).done; ) {
              var le = Z.value;
              Y[le] = N[le];
            }
          } catch (de) {
            ie.e(de);
          } finally {
            ie.f();
          }
          return Y;
        }, s.warn = function(N) {
          return { env: {} }.emitWarning(N, { code: "MONGOOSE" });
        }, s.injectTimestampsOption = function(N, Z) {
          Z != null && (N.timestamps = Z);
        };
      }, 8863: (o, s, a) => {
        var u = a(2354), c = a(2268), f = a(3123), h = a(5477);
        o.exports = function(y) {
          if (y.length < 1 || typeof y[0] != "function") throw new c("a function is required");
          return h(u, f, y);
        };
      }, 8866: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        function c(_, b) {
          for (var w = 0; w < b.length; w++) {
            var A = b[w];
            A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(_, f(A.key), A);
          }
        }
        function f(_) {
          var b = (function(w) {
            if (u(w) != "object" || !w) return w;
            var A = w[Symbol.toPrimitive];
            if (A !== void 0) {
              var E = A.call(w, "string");
              if (u(E) != "object") return E;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(w);
          })(_);
          return u(b) == "symbol" ? b : b + "";
        }
        function h() {
          try {
            var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (h = function() {
            return !!_;
          })();
        }
        function y() {
          return y = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(_, b, w) {
            var A = (function(O, $) {
              for (; !{}.hasOwnProperty.call(O, $) && (O = p(O)) !== null; ) ;
              return O;
            })(_, b);
            if (A) {
              var E = Object.getOwnPropertyDescriptor(A, b);
              return E.get ? E.get.call(arguments.length < 3 ? _ : w) : E.value;
            }
          }, y.apply(null, arguments);
        }
        function p(_) {
          return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, p(_);
        }
        function l(_, b) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w, A) {
            return w.__proto__ = A, w;
          }, l(_, b);
        }
        var d = a(6974), v = a(6426), m = Symbol("firstValue"), g = (function(_) {
          function b(E, O) {
            var $, k = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if ((function(j, P) {
              if (!(j instanceof P)) throw new TypeError("Cannot call a class as a function");
            })(this, b), $ = (function(j, P, R) {
              return P = p(P), (function(I, z) {
                if (z && (u(z) == "object" || typeof z == "function")) return z;
                if (z !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(W) {
                  if (W === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return W;
                })(I);
              })(j, h() ? Reflect.construct(P, R || [], p(j).constructor) : P.apply(j, R));
            })(this, b, [E, O, "Union"]), !O || !Array.isArray(O.of) || O.of.length === 0) throw new Error("Union schema type requires an array of types");
            return $.schemaTypes = O.of.map(function(j) {
              return O.parentSchema.interpretAsType(E, j, k);
            }), $;
          }
          return (function(E, O) {
            if (typeof O != "function" && O !== null) throw new TypeError("Super expression must either be null or a function");
            E.prototype = Object.create(O && O.prototype, { constructor: { value: E, writable: !0, configurable: !0 } }), Object.defineProperty(E, "prototype", { writable: !1 }), O && l(E, O);
          })(b, _), w = b, A = [{ key: "cast", value: function(E, O, $, k, j) {
            for (var P, R = m, I = 0; I < this.schemaTypes.length; ++I) try {
              var z = this.schemaTypes[I].cast(E, O, $, k, j);
              if (z === E) return z;
              R === m && (R = z);
            } catch (W) {
              P = W;
            }
            if (R !== m) return R;
            throw P;
          } }, { key: "applySetters", value: function(E, O, $, k, j) {
            for (var P, R = m, I = 0; I < this.schemaTypes.length; ++I) try {
              var z = this.schemaTypes[I]._applySetters(E, O, $, k, j);
              if ((z = z == null ? this.schemaTypes[I]._castNullish(z) : this.schemaTypes[I].cast(z, O, $, k, j)) === E) return z;
              R === m && (R = z);
            } catch (W) {
              P = W;
            }
            if (R !== m) return R;
            throw P;
          } }, { key: "clone", value: function() {
            var E, O, $, k = (E = b, O = this, typeof ($ = y(p(E.prototype), "clone", O)) == "function" ? function(j) {
              return $.apply(O, j);
            } : $)([]);
            return k.schemaTypes = this.schemaTypes.map(function(j) {
              return j.clone();
            }), k;
          } }], A && c(w.prototype, A), Object.defineProperty(w, "prototype", { writable: !1 }), w;
          var w, A;
        })(v);
        g.schemaName = "Union", g.defaultOptions = {}, g.prototype.OptionsConstructor = d, o.exports = g;
      }, 8879: (o, s, a) => {
        function u(y, p, l) {
          return Object.defineProperty(y, "prototype", { writable: !1 }), y;
        }
        var c = a(4450), f = u(function y(p) {
          if ((function(l, d) {
            if (!(l instanceof d)) throw new TypeError("Cannot call a class as a function");
          })(this, y), p == null) return this;
          Object.assign(this, c(p));
        }), h = a(5761);
        Object.defineProperty(f.prototype, "type", h), Object.defineProperty(f.prototype, "validate", h), Object.defineProperty(f.prototype, "cast", h), Object.defineProperty(f.prototype, "required", h), Object.defineProperty(f.prototype, "default", h), Object.defineProperty(f.prototype, "ref", h), Object.defineProperty(f.prototype, "refPath", h), Object.defineProperty(f.prototype, "select", h), Object.defineProperty(f.prototype, "index", h), Object.defineProperty(f.prototype, "unique", h), Object.defineProperty(f.prototype, "immutable", h), Object.defineProperty(f.prototype, "sparse", h), Object.defineProperty(f.prototype, "text", h), Object.defineProperty(f.prototype, "transform", h), o.exports = f;
      }, 8920: (o, s, a) => {
        var u = a(5832).hp;
        function c(V) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(T) {
            return typeof T;
          } : function(T) {
            return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
          }, c(V);
        }
        function f(V, T) {
          var D = typeof Symbol < "u" && V[Symbol.iterator] || V["@@iterator"];
          if (!D) {
            if (Array.isArray(V) || (D = h(V)) || T) {
              D && (V = D);
              var L = 0, M = function() {
              };
              return { s: M, n: function() {
                return L >= V.length ? { done: !0 } : { done: !1, value: V[L++] };
              }, e: function(ie) {
                throw ie;
              }, f: M };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var N, Z = !0, Y = !1;
          return { s: function() {
            D = D.call(V);
          }, n: function() {
            var ie = D.next();
            return Z = ie.done, ie;
          }, e: function(ie) {
            Y = !0, N = ie;
          }, f: function() {
            try {
              Z || D.return == null || D.return();
            } finally {
              if (Y) throw N;
            }
          } };
        }
        function h(V, T) {
          if (V) {
            if (typeof V == "string") return y(V, T);
            var D = {}.toString.call(V).slice(8, -1);
            return D === "Object" && V.constructor && (D = V.constructor.name), D === "Map" || D === "Set" ? Array.from(V) : D === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D) ? y(V, T) : void 0;
          }
        }
        function y(V, T) {
          (T == null || T > V.length) && (T = V.length);
          for (var D = 0, L = Array(T); D < T; D++) L[D] = V[D];
          return L;
        }
        var p = a(2400), l = a(6547), d = a(8213), v = a(4473), m = a(4450), g = a(3303)._, _ = a(5678), b = a(8768), w = a(3305), A = a(7930).arrayAtomicsSymbol, E = a(7930).arrayParentSymbol, O = a(7930).arrayPathSymbol, $ = a(7930).arraySchemaSymbol, k = a(7930).populateModelSymbol, j = Symbol("mongoose#Array#sliced"), P = Array.prototype.push, R = { $__getAtomics: function() {
          var V = [], T = Object.keys(this[A] || {}), D = T.length, L = Object.assign({}, g, { _isNested: !0 });
          if (D === 0) return V[0] = ["$set", this.toObject(L)], V;
          for (; D--; ) {
            var M = T[D], N = this[A][M];
            b.isMongooseObject(N) ? N = N.toObject(L) : Array.isArray(N) ? N = this.toObject.call(N, L) : N != null && Array.isArray(N.$each) ? N.$each = this.toObject.call(N.$each, L) : N != null && typeof N.valueOf == "function" && (N = N.valueOf()), M === "$addToSet" && (N = { $each: N }), V.push([M, N]);
          }
          return V;
        }, $atomics: function() {
          return this[A];
        }, $parent: function() {
          return this[E];
        }, $path: function() {
          return this[O];
        }, $schemaType: function() {
          return this[$];
        }, $shift: function() {
          this._registerAtomic("$pop", -1), this._markModified();
          var V = this.__array;
          if (!V._shifted) return V._shifted = !0, [].shift.call(V);
        }, $pop: function() {
          if (this._registerAtomic("$pop", 1), this._markModified(), !this._popped) return this._popped = !0, [].pop.call(this);
        }, $schema: function() {
          return this[$];
        }, _cast: function(V) {
          var T, D = !1, L = this[E];
          if (L && (D = L.$populated(this[O], !0)), D && V != null) {
            if ((T = D.options[k]) == null) throw new d("No populated model found for path `" + this[O] + "`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.");
            return (u.isBuffer(V) || w(V, "ObjectId") || !b.isObject(V)) && (V = { _id: V }), V.schema && V.schema.discriminatorMapping && V.schema.discriminatorMapping.key !== void 0 || (V = new T(V)), this[$].caster.applySetters(V, L, !0);
          }
          return this[$].caster.applySetters(V, L, !1);
        }, _mapCast: function(V, T) {
          return this._cast(V, this.length + T);
        }, _markModified: function(V) {
          var T, D = this[E];
          if (D) {
            if (T = this[O], arguments.length && (T = T + "." + V), T != null && T.endsWith(".$")) return this;
            D.markModified(T, arguments.length !== 0 ? V : D);
          }
          return this;
        }, _registerAtomic: function(V, T) {
          if (!this[j]) {
            if (V === "$set") return this[A] = { $set: T }, v(this[E], this[O]), this._markModified(), this;
            var D, L = this[A];
            if (V === "$pop" && !("$pop" in L)) {
              var M = this;
              this[E].once("save", function() {
                M._popped = M._shifted = null;
              });
            }
            if (L.$set || Object.keys(L).length && !(V in L)) return this[A] = { $set: this }, this;
            if (V === "$pullAll" || V === "$addToSet") L[V] || (L[V] = []), L[V] = L[V].concat(T);
            else if (V === "$pullDocs") {
              var N = L.$pull || (L.$pull = {});
              T[0] instanceof l ? (D = N.$or || (N.$or = []), Array.prototype.push.apply(D, T.map(function(ae) {
                return ae.toObject({ transform: function(ne, he) {
                  return ae == null || ae.$__ == null || Object.keys(ae.$__.activePaths.getStatePaths("default")).forEach(function(x) {
                    _.unset(x, he), I(he, x);
                  }), he;
                }, virtuals: !1 });
              }))) : (D = N._id || (N._id = { $in: [] })).$in = D.$in.concat(T);
            } else if (V === "$push") if (L.$push = L.$push || { $each: [] }, T != null && b.hasUserDefinedProperty(T, "$each")) L.$push = T;
            else if (T.length === 1) L.$push.$each.push(T[0]);
            else if (T.length < 1e4) {
              var Z;
              (Z = L.$push.$each).push.apply(Z, (function(ae) {
                if (Array.isArray(ae)) return y(ae);
              })(de = T) || (function(ae) {
                if (typeof Symbol < "u" && ae[Symbol.iterator] != null || ae["@@iterator"] != null) return Array.from(ae);
              })(de) || h(de) || (function() {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              })());
            } else {
              var Y, ie = f(T);
              try {
                for (ie.s(); !(Y = ie.n()).done; ) {
                  var le = Y.value;
                  L.$push.$each.push(le);
                }
              } catch (ae) {
                ie.e(ae);
              } finally {
                ie.f();
              }
            }
            else L[V] = T;
            return this;
          }
          var de;
        }, addToSet: function() {
          z(this, arguments), W(this, arguments);
          var V = [].map.call(arguments, this._mapCast, this), T = [], D = "";
          V[0] instanceof l ? D = "doc" : V[0] instanceof Date ? D = "date" : w(V[0], "ObjectId") && (D = "ObjectId");
          var L = b.isMongooseArray(V) ? V.__array : V, M = b.isMongooseArray(this) ? this.__array : this;
          return L.forEach(function(N) {
            var Z, Y = +N;
            switch (D) {
              case "doc":
                Z = this.some(function(ie) {
                  return ie.equals(N);
                });
                break;
              case "date":
                Z = this.some(function(ie) {
                  return +ie === Y;
                });
                break;
              case "ObjectId":
                Z = this.find(function(ie) {
                  return ie.toString() === N.toString();
                });
                break;
              default:
                Z = ~this.indexOf(N);
            }
            Z || (this._markModified(), M.push(N), this._registerAtomic("$addToSet", N), [].push.call(T, N));
          }, this), T;
        }, hasAtomics: function() {
          return b.isPOJO(this[A]) ? Object.keys(this[A]).length : 0;
        }, includes: function(V, T) {
          return this.indexOf(V, T) !== -1;
        }, indexOf: function(V, T) {
          w(V, "ObjectId") && (V = V.toString()), T = T ?? 0;
          for (var D = this.length, L = T; L < D; ++L) if (V == this[L]) return L;
          return -1;
        }, inspect: function() {
          return JSON.stringify(this);
        }, nonAtomicPush: function() {
          var V = [].map.call(arguments, this._mapCast, this);
          this._markModified();
          var T = [].push.apply(this, V);
          return this._registerAtomic("$set", this), T;
        }, pop: function() {
          this._markModified();
          var V = [].pop.call(this);
          return this._registerAtomic("$set", this), V;
        }, pull: function() {
          var V = this, T = [].map.call(arguments, function(N, Z) {
            return V._cast(N, Z, { defaults: !1 });
          }, this), D = this;
          b.isMongooseArray(D) && (D = D.__array);
          var L, M = D.length;
          for (this._markModified(); M--; ) (L = D[M]) instanceof p ? T.some(function(N) {
            return L.equals(N);
          }) && D.splice(M, 1) : ~this.indexOf.call(T, L) && D.splice(M, 1);
          return T[0] instanceof l ? this._registerAtomic("$pullDocs", T.map(function(N) {
            var Z = N.$__getValue("_id");
            return Z === void 0 || N.$isDefault("_id") ? N : Z;
          })) : this._registerAtomic("$pullAll", T), v(this[E], this[O]) > 0 && this._registerAtomic("$set", this), this;
        }, push: function() {
          var V, T = arguments, D = T, L = T[0] != null && b.hasUserDefinedProperty(T[0], "$each"), M = b.isMongooseArray(this) ? this.__array : this;
          if (L && (D = T[0], T = T[0].$each), this[$] == null) return P.apply(this, T);
          z(this, T), W(this, T), T = [].map.call(T, this._mapCast, this);
          var N = this[A];
          return this._markModified(), L ? (D.$each = T, (N.$push && N.$push.$each && N.$push.$each.length || 0) !== 0 && N.$push.$position != D.$position ? (D.$position != null ? ([].splice.apply(M, [D.$position, 0].concat(T)), V = M.length) : V = [].push.apply(M, T), this._registerAtomic("$set", this)) : D.$position != null ? ([].splice.apply(M, [D.$position, 0].concat(T)), V = this.length) : V = [].push.apply(M, T)) : (D = T, V = P.apply(M, T)), this._registerAtomic("$push", D), V;
        }, remove: function() {
          return this.pull.apply(this, arguments);
        }, set: function(V, T, D) {
          var L = this.__array;
          if (D) return L[V] = T, this;
          var M = R._cast.call(this, T, V);
          return R._markModified.call(this, V), L[V] = M, this;
        }, shift: function() {
          var V = b.isMongooseArray(this) ? this.__array : this;
          this._markModified();
          var T = [].shift.call(V);
          return this._registerAtomic("$set", this), T;
        }, sort: function() {
          var V = b.isMongooseArray(this) ? this.__array : this, T = [].sort.apply(V, arguments);
          return this._registerAtomic("$set", this), T;
        }, splice: function() {
          var V, T = b.isMongooseArray(this) ? this.__array : this;
          if (this._markModified(), z(this, Array.prototype.slice.call(arguments, 2)), arguments.length) {
            var D;
            if (this[$] == null) D = arguments;
            else {
              D = [];
              for (var L = 0; L < arguments.length; ++L) D[L] = L < 2 ? arguments[L] : this._cast(arguments[L], arguments[0] + (L - 2));
            }
            V = [].splice.apply(T, D), this._registerAtomic("$set", this);
          }
          return V;
        }, toBSON: function() {
          return this.toObject(g);
        }, toObject: function(V) {
          var T = b.isMongooseArray(this) ? this.__array : this;
          return V && V.depopulate ? ((V = m(V))._isNested = !0, [].concat(T).map(function(D) {
            return D instanceof p ? D.toObject(V) : D;
          })) : [].concat(T);
        }, $toObject: function() {
          return this.constructor.prototype.toObject.apply(this, arguments);
        }, unshift: function() {
          var V;
          z(this, arguments), V = this[$] == null ? arguments : [].map.call(arguments, this._cast, this);
          var T = b.isMongooseArray(this) ? this.__array : this;
          return this._markModified(), [].unshift.apply(T, V), this._registerAtomic("$set", this), this.length;
        } };
        function I(V, T, D) {
          if (typeof T == "string") {
            if (T.indexOf(".") === -1) return;
            T = _.stringToParts(T);
          }
          (D = D || 0) >= T.length || V != null && c(V) === "object" && (I(V[T[0]], T, D + 1), V[T[0]] != null && c(V[T[0]]) === "object" && Object.keys(V[T[0]]).length === 0 && delete V[T[0]]);
        }
        function z(V, T) {
          var D, L, M, N = V == null ? null : V[$] && V[$].caster && V[$].caster.options && V[$].caster.options.ref || null;
          V.length === 0 && T.length !== 0 && (function(Z, Y) {
            if (!Y) return !1;
            var ie, le = f(Z);
            try {
              for (le.s(); !(ie = le.n()).done; ) {
                var de = ie.value;
                if (de == null) return !1;
                var ae = de.constructor;
                if (!(de instanceof p) || ae.modelName !== Y && ae.baseModelName !== Y) return !1;
              }
            } catch (ne) {
              le.e(ne);
            } finally {
              le.f();
            }
            return !0;
          })(T, N) && V[E].$populated(V[O], [], (D = {}, L = k, M = T[0].constructor, (L = (function(Z) {
            var Y = (function(ie) {
              if (c(ie) != "object" || !ie) return ie;
              var le = ie[Symbol.toPrimitive];
              if (le !== void 0) {
                var de = le.call(ie, "string");
                if (c(de) != "object") return de;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(ie);
            })(Z);
            return c(Y) == "symbol" ? Y : Y + "";
          })(L)) in D ? Object.defineProperty(D, L, { value: M, enumerable: !0, configurable: !0, writable: !0 }) : D[L] = M, D));
        }
        function W(V, T) {
          var D = V == null ? null : V[$] && V[$].caster && V[$].caster.options && V[$].caster.options.ref || null, L = V[E], M = V[O];
          if (D && L.populated(M)) {
            var N, Z = f(T);
            try {
              for (Z.s(); !(N = Z.n()).done; ) {
                var Y = N.value;
                if (Y != null && (c(Y) !== "object" || Y instanceof String || Y instanceof Number || Y instanceof u || b.isMongooseType(Y))) {
                  L.depopulate(M);
                  break;
                }
              }
            } catch (ie) {
              Z.e(ie);
            } finally {
              Z.f();
            }
          }
        }
        for (var F = function() {
          var V = ee[te];
          if (Array.prototype[V] == null) return 1;
          R[V] = function() {
            var T = b.isMongooseArray(this) ? this.__array : this, D = [].concat(T);
            return D[V].apply(D, arguments);
          };
        }, te = 0, ee = ["filter", "flat", "flatMap", "map", "slice"]; te < ee.length; te++) F();
        o.exports = R;
      }, 8953: (o, s, a) => {
        var u = a(3609);
        o.exports = function(c, f) {
          if (o.exports.convertToTrue.has(c)) return !0;
          if (o.exports.convertToFalse.has(c)) return !1;
          if (c == null) return c;
          throw new u("boolean", c, f);
        }, o.exports.convertToTrue = /* @__PURE__ */ new Set([!0, "true", 1, "1", "yes"]), o.exports.convertToFalse = /* @__PURE__ */ new Set([!1, "false", 0, "0", "no"]);
      }, 8995: (o, s, a) => {
        function u(p) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, u(p);
        }
        function c() {
          try {
            var p = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!p;
          })();
        }
        function f(p) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
            return l.__proto__ || Object.getPrototypeOf(l);
          }, f(p);
        }
        function h(p, l) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, v) {
            return d.__proto__ = v, d;
          }, h(p, l);
        }
        var y = (function(p) {
          function l(v, m, g) {
            var _;
            return (function(b, w) {
              if (!(b instanceof w)) throw new TypeError("Cannot call a class as a function");
            })(this, l), (_ = (function(b, w, A) {
              return w = f(w), (function(E, O) {
                if (O && (u(O) == "object" || typeof O == "function")) return O;
                if (O !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function($) {
                  if ($ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return $;
                })(E);
              })(b, c() ? Reflect.construct(w, A || [], f(b).constructor) : w.apply(b, A));
            })(this, l, [m = m || "Field `" + v + "` is not in schema and strict mode is set to throw."])).isImmutableError = !!g, _.path = v, _;
          }
          return (function(v, m) {
            if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
            v.prototype = Object.create(m && m.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), m && h(v, m);
          })(l, p), d = l, Object.defineProperty(d, "prototype", { writable: !1 }), d;
          var d;
        })(a(8213));
        Object.defineProperty(y.prototype, "name", { value: "StrictModeError" }), o.exports = y;
      }, 9064: (o, s, a) => {
        function u(y) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
            return typeof p;
          } : function(p) {
            return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
          }, u(y);
        }
        var c = a(3609), f = a(8953), h = a(1244);
        o.exports = function(y, p) {
          if (y == null || u(y) !== "object") throw new c("$text", y, p);
          return y.$search != null && (y.$search = h(y.$search, p + ".$search")), y.$language != null && (y.$language = h(y.$language, p + ".$language")), y.$caseSensitive != null && (y.$caseSensitive = f(y.$caseSensitive, p + ".$castSensitive")), y.$diacriticSensitive != null && (y.$diacriticSensitive = f(y.$diacriticSensitive, p + ".$diacriticSensitive")), y;
        };
      }, 9068: (o, s, a) => {
        function u(R) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(I) {
            return typeof I;
          } : function(I) {
            return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
          }, u(R);
        }
        function c(R, I, z) {
          return I in R ? Object.defineProperty(R, I, { value: z, enumerable: !0, configurable: !0, writable: !0 }) : R[I] = z, R;
        }
        function f(R, I) {
          for (var z = 0; z < I.length; z++) {
            var W = I[z];
            W.enumerable = W.enumerable || !1, W.configurable = !0, "value" in W && (W.writable = !0), Object.defineProperty(R, W.key, W);
          }
        }
        function h(R, I) {
          return !I || m(I) !== "object" && typeof I != "function" ? y(R) : I;
        }
        function y(R) {
          if (R === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return R;
        }
        function p(R) {
          var I = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return p = function(z) {
            if (z === null || (W = z, Function.toString.call(W).indexOf("[native code]") === -1)) return z;
            var W;
            if (typeof z != "function") throw new TypeError("Super expression must either be null or a function");
            if (I !== void 0) {
              if (I.has(z)) return I.get(z);
              I.set(z, F);
            }
            function F() {
              return l(z, arguments, v(this).constructor);
            }
            return F.prototype = Object.create(z.prototype, { constructor: { value: F, enumerable: !1, writable: !0, configurable: !0 } }), d(F, z);
          }, p(R);
        }
        function l(R, I, z) {
          return l = (function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
            if (typeof Proxy == "function") return !0;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), !0;
            } catch {
              return !1;
            }
          })() ? Reflect.construct : function(W, F, te) {
            var ee = [null];
            ee.push.apply(ee, F);
            var V = new (Function.bind.apply(W, ee))();
            return te && d(V, te.prototype), V;
          }, l.apply(null, arguments);
        }
        function d(R, I) {
          return d = Object.setPrototypeOf || function(z, W) {
            return z.__proto__ = W, z;
          }, d(R, I);
        }
        function v(R) {
          return v = Object.setPrototypeOf ? Object.getPrototypeOf : function(I) {
            return I.__proto__ || Object.getPrototypeOf(I);
          }, v(R);
        }
        function m(R) {
          return m = typeof Symbol == "function" && u(Symbol.iterator) === "symbol" ? function(I) {
            return u(I);
          } : function(I) {
            return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : u(I);
          }, m(R);
        }
        var g = a(7352).inspect, _ = a(3743).codes.ERR_INVALID_ARG_TYPE;
        function b(R, I, z) {
          return (z === void 0 || z > R.length) && (z = R.length), R.substring(z - I.length, z) === I;
        }
        var w = "", A = "", E = "", O = "", $ = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
        function k(R) {
          var I = Object.keys(R), z = Object.create(Object.getPrototypeOf(R));
          return I.forEach(function(W) {
            z[W] = R[W];
          }), Object.defineProperty(z, "message", { value: R.message }), z;
        }
        function j(R) {
          return g(R, { compact: !1, customInspect: !1, depth: 1e3, maxArrayLength: 1 / 0, showHidden: !1, breakLength: 1 / 0, showProxy: !1, sorted: !0, getters: !0 });
        }
        var P = (function(R) {
          function I(F) {
            var te;
            if ((function(de, ae) {
              if (!(de instanceof ae)) throw new TypeError("Cannot call a class as a function");
            })(this, I), m(F) !== "object" || F === null) throw new _("options", "Object", F);
            var ee = F.message, V = F.operator, T = F.stackStartFn, D = F.actual, L = F.expected, M = Error.stackTraceLimit;
            if (Error.stackTraceLimit = 0, ee != null) te = h(this, v(I).call(this, String(ee)));
            else if ({}.stderr && {}.stderr.isTTY && ({}.stderr && {}.stderr.getColorDepth && {}.stderr.getColorDepth() !== 1 ? (w = "\x1B[34m", A = "\x1B[32m", O = "\x1B[39m", E = "\x1B[31m") : (w = "", A = "", O = "", E = "")), m(D) === "object" && D !== null && m(L) === "object" && L !== null && "stack" in D && D instanceof Error && "stack" in L && L instanceof Error && (D = k(D), L = k(L)), V === "deepStrictEqual" || V === "strictEqual") te = h(this, v(I).call(this, (function(de, ae, ne) {
              var he = "", x = "", U = 0, B = "", J = !1, X = j(de), oe = X.split(`
`), ye = j(ae).split(`
`), q = 0, G = "";
              if (ne === "strictEqual" && m(de) === "object" && m(ae) === "object" && de !== null && ae !== null && (ne = "strictEqualObject"), oe.length === 1 && ye.length === 1 && oe[0] !== ye[0]) {
                var ce = oe[0].length + ye[0].length;
                if (ce <= 10) {
                  if (!(m(de) === "object" && de !== null || m(ae) === "object" && ae !== null || de === 0 && ae === 0)) return "".concat($[ne], `

`) + "".concat(oe[0], " !== ").concat(ye[0], `
`);
                } else if (ne !== "strictEqualObject" && ce < ({}.stderr && {}.stderr.isTTY ? {}.stderr.columns : 80)) {
                  for (; oe[0][q] === ye[0][q]; ) q++;
                  q > 2 && (G = `
  `.concat((function(ft, Ke) {
                    if (Ke = Math.floor(Ke), ft.length == 0 || Ke == 0) return "";
                    var Xt = ft.length * Ke;
                    for (Ke = Math.floor(Math.log(Ke) / Math.log(2)); Ke; ) ft += ft, Ke--;
                    return ft + ft.substring(0, Xt - ft.length);
                  })(" ", q), "^"), q = 0);
                }
              }
              for (var ue = oe[oe.length - 1], re = ye[ye.length - 1]; ue === re && (q++ < 2 ? B = `
  `.concat(ue).concat(B) : he = ue, oe.pop(), ye.pop(), oe.length !== 0 && ye.length !== 0); ) ue = oe[oe.length - 1], re = ye[ye.length - 1];
              var pe = Math.max(oe.length, ye.length);
              if (pe === 0) {
                var xe = X.split(`
`);
                if (xe.length > 30) for (xe[26] = "".concat(w, "...").concat(O); xe.length > 27; ) xe.pop();
                return "".concat($.notIdentical, `

`).concat(xe.join(`
`), `
`);
              }
              q > 3 && (B = `
`.concat(w, "...").concat(O).concat(B), J = !0), he !== "" && (B = `
  `.concat(he).concat(B), he = "");
              var be = 0, Ee = $[ne] + `
`.concat(A, "+ actual").concat(O, " ").concat(E, "- expected").concat(O), Ue = " ".concat(w, "...").concat(O, " Lines skipped");
              for (q = 0; q < pe; q++) {
                var Ae = q - U;
                if (oe.length < q + 1) Ae > 1 && q > 2 && (Ae > 4 ? (x += `
`.concat(w, "...").concat(O), J = !0) : Ae > 3 && (x += `
  `.concat(ye[q - 2]), be++), x += `
  `.concat(ye[q - 1]), be++), U = q, he += `
`.concat(E, "-").concat(O, " ").concat(ye[q]), be++;
                else if (ye.length < q + 1) Ae > 1 && q > 2 && (Ae > 4 ? (x += `
`.concat(w, "...").concat(O), J = !0) : Ae > 3 && (x += `
  `.concat(oe[q - 2]), be++), x += `
  `.concat(oe[q - 1]), be++), U = q, x += `
`.concat(A, "+").concat(O, " ").concat(oe[q]), be++;
                else {
                  var Me = ye[q], et = oe[q], lt = et !== Me && (!b(et, ",") || et.slice(0, -1) !== Me);
                  lt && b(Me, ",") && Me.slice(0, -1) === et && (lt = !1, et += ","), lt ? (Ae > 1 && q > 2 && (Ae > 4 ? (x += `
`.concat(w, "...").concat(O), J = !0) : Ae > 3 && (x += `
  `.concat(oe[q - 2]), be++), x += `
  `.concat(oe[q - 1]), be++), U = q, x += `
`.concat(A, "+").concat(O, " ").concat(et), he += `
`.concat(E, "-").concat(O, " ").concat(Me), be += 2) : (x += he, he = "", Ae !== 1 && q !== 0 || (x += `
  `.concat(et), be++));
                }
                if (be > 20 && q < pe - 2) return "".concat(Ee).concat(Ue, `
`).concat(x, `
`).concat(w, "...").concat(O).concat(he, `
`) + "".concat(w, "...").concat(O);
              }
              return "".concat(Ee).concat(J ? Ue : "", `
`).concat(x).concat(he).concat(B).concat(G);
            })(D, L, V)));
            else if (V === "notDeepStrictEqual" || V === "notStrictEqual") {
              var N = $[V], Z = j(D).split(`
`);
              if (V === "notStrictEqual" && m(D) === "object" && D !== null && (N = $.notStrictEqualObject), Z.length > 30) for (Z[26] = "".concat(w, "...").concat(O); Z.length > 27; ) Z.pop();
              te = Z.length === 1 ? h(this, v(I).call(this, "".concat(N, " ").concat(Z[0]))) : h(this, v(I).call(this, "".concat(N, `

`).concat(Z.join(`
`), `
`)));
            } else {
              var Y = j(D), ie = "", le = $[V];
              V === "notDeepEqual" || V === "notEqual" ? (Y = "".concat($[V], `

`).concat(Y)).length > 1024 && (Y = "".concat(Y.slice(0, 1021), "...")) : (ie = "".concat(j(L)), Y.length > 512 && (Y = "".concat(Y.slice(0, 509), "...")), ie.length > 512 && (ie = "".concat(ie.slice(0, 509), "...")), V === "deepEqual" || V === "equal" ? Y = "".concat(le, `

`).concat(Y, `

should equal

`) : ie = " ".concat(V, " ").concat(ie)), te = h(this, v(I).call(this, "".concat(Y).concat(ie)));
            }
            return Error.stackTraceLimit = M, te.generatedMessage = !ee, Object.defineProperty(y(te), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: !1, writable: !0, configurable: !0 }), te.code = "ERR_ASSERTION", te.actual = D, te.expected = L, te.operator = V, Error.captureStackTrace && Error.captureStackTrace(y(te), T), te.stack, te.name = "AssertionError", h(te);
          }
          var z, W;
          return (function(F, te) {
            if (typeof te != "function" && te !== null) throw new TypeError("Super expression must either be null or a function");
            F.prototype = Object.create(te && te.prototype, { constructor: { value: F, writable: !0, configurable: !0 } }), te && d(F, te);
          })(I, R), z = I, W = [{ key: "toString", value: function() {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
          } }, { key: g.custom, value: function(F, te) {
            return g(this, (function(ee) {
              for (var V = 1; V < arguments.length; V++) {
                var T = arguments[V] != null ? arguments[V] : {}, D = Object.keys(T);
                typeof Object.getOwnPropertySymbols == "function" && (D = D.concat(Object.getOwnPropertySymbols(T).filter(function(L) {
                  return Object.getOwnPropertyDescriptor(T, L).enumerable;
                }))), D.forEach(function(L) {
                  c(ee, L, T[L]);
                });
              }
              return ee;
            })({}, te, { customInspect: !1, depth: 0 }));
          } }], W && f(z.prototype, W), I;
        })(p(Error));
        o.exports = P;
      }, 9122: (o, s, a) => {
        var u = a(3900), c = a(988), f = a(8863), h = a(5804);
        o.exports = function(y) {
          var p = f(arguments), l = y.length - (arguments.length - 1);
          return u(p, 1 + (l > 0 ? l : 0), !0);
        }, c ? c(o.exports, "apply", { value: h }) : o.exports.apply = h;
      }, 9123: (o, s, a) => {
        function u(T) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
            return typeof D;
          } : function(D) {
            return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
          }, u(T);
        }
        function c(T, D) {
          var L = Object.keys(T);
          if (Object.getOwnPropertySymbols) {
            var M = Object.getOwnPropertySymbols(T);
            D && (M = M.filter(function(N) {
              return Object.getOwnPropertyDescriptor(T, N).enumerable;
            })), L.push.apply(L, M);
          }
          return L;
        }
        function f(T) {
          for (var D = 1; D < arguments.length; D++) {
            var L = arguments[D] != null ? arguments[D] : {};
            D % 2 ? c(Object(L), !0).forEach(function(M) {
              h(T, M, L[M]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(L)) : c(Object(L)).forEach(function(M) {
              Object.defineProperty(T, M, Object.getOwnPropertyDescriptor(L, M));
            });
          }
          return T;
        }
        function h(T, D, L) {
          return (D = (function(M) {
            var N = (function(Z) {
              if (u(Z) != "object" || !Z) return Z;
              var Y = Z[Symbol.toPrimitive];
              if (Y !== void 0) {
                var ie = Y.call(Z, "string");
                if (u(ie) != "object") return ie;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(Z);
            })(M);
            return u(N) == "symbol" ? N : N + "";
          })(D)) in T ? Object.defineProperty(T, D, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : T[D] = L, T;
        }
        var y, p, l = a(3609), d = a(8235), v = a(3550).EventEmitter, m = a(7760), g = a(4561), _ = a(6426), b = a(7982), w = a(4327), A = a(1469), E = a(1313), O = a(3216), $ = a(5110), k = a(8768), j = a(7910), P = a(5537), R = a(7930).arrayAtomicsSymbol, I = a(7930).arrayPathSymbol, z = a(7930).documentArrayParent;
        function W(T, D, L, M) {
          if (D.options && D.options.timeseries) throw new P(T, "timeseries");
          var N = W.defaultOptions && W.defaultOptions._id;
          N != null && ((M = M || {})._id = N), M != null && M._id != null ? D = E(D, M) : L != null && L._id != null && (D = E(D, L));
          var Z = F(D, L);
          Z.prototype.$basePath = T, m.call(this, T, Z, L), this.schema = D, this.schemaOptions = M || {}, this.$isMongooseDocumentArray = !0, this.Constructor = Z, Z.base = D.base;
          var Y = this.defaultValue;
          "defaultValue" in this && Y == null || this.default(function() {
            var ie = Y.call(this);
            return ie == null || Array.isArray(ie) || (ie = [ie]), ie;
          }), this.$embeddedSchemaType = new d(T + ".$", f(f({}, M || {}), {}, { $parentSchemaType: this })), this.$embeddedSchemaType.caster = this.Constructor, this.$embeddedSchemaType.schema = this.schema;
        }
        function F(T, D, L) {
          function M() {
            p.apply(this, arguments), this.__parentArray != null && this.__parentArray.getArrayParent() != null && this.$session(this.__parentArray.getArrayParent().$session());
          }
          p || (p = a(6547)), T._preCompile();
          var N = L != null ? L.prototype : p.prototype;
          for (var Z in M.prototype = Object.create(N), M.prototype.$__setSchema(T), M.schema = T, M.prototype.constructor = M, M.$isArraySubdocument = !0, M.events = new v(), M.base = T.base, T.methods) M.prototype[Z] = T.methods[Z];
          for (var Y in T.statics) M[Y] = T.statics[Y];
          for (var ie in v.prototype) M[ie] = v.prototype[ie];
          return M.options = D, M;
        }
        W.schemaName = "DocumentArray", W.options = { castNonArrays: !0 }, W.prototype = Object.create(m.prototype), W.prototype.constructor = W, W.prototype.OptionsConstructor = g, Object.defineProperty(W.prototype, "$conditionalHandlers", { enumerable: !1, value: f({}, m.prototype.$conditionalHandlers) }), W.prototype.discriminator = function(T, D, L) {
          var M;
          typeof T == "function" && (T = k.getFunctionName(T)), L = L || {};
          var N = k.isPOJO(L) ? L.value : L, Z = typeof L.clone != "boolean" || L.clone;
          D.instanceOfSchema && Z && (D = D.clone());
          var Y = F(D = A(this.casterConstructor, T, D, N, null, null, (M = L) === null || M === void 0 ? void 0 : M.overwriteExisting), null, this.casterConstructor);
          Y.baseCasterConstructor = this.casterConstructor;
          try {
            Object.defineProperty(Y, "name", { value: T });
          } catch {
          }
          return this.casterConstructor.discriminators[T] = Y, this.casterConstructor.discriminators[T];
        }, W.prototype.doValidate = function(T, D, L, M) {
          y || (y = a(4878));
          var N = this;
          try {
            _.prototype.doValidate.call(this, T, function(Z) {
              if (Z) return D(Z);
              var Y, ie = T && T.length;
              if (!ie || M && M.updateValidator) return D();
              function le(x) {
                x != null && (Y = x), --ie || D(Y);
              }
              k.isMongooseDocumentArray(T) || (T = new y(T, N.path, L));
              for (var de = 0, ae = ie; de < ae; ++de) {
                var ne = T[de];
                if (ne != null) {
                  if (!(ne instanceof p)) {
                    var he = j(N.casterConstructor, T[de]);
                    ne = T[de] = new he(ne, T, void 0, void 0, de);
                  }
                  M == null || !M.validateModifiedOnly || ne.$isModified() ? ne.$__validate(null, M, le) : --ie || D(Y);
                } else --ie || D(Y);
              }
            }, L);
          } catch (Z) {
            return D(Z);
          }
        }, W.prototype.doValidateSync = function(T, D, L) {
          var M = _.prototype.doValidateSync.call(this, T, D);
          if (M != null) return M;
          var N = T && T.length, Z = null;
          if (N) {
            for (var Y = 0, ie = N; Y < ie; ++Y) {
              var le = T[Y];
              if (le) {
                if (!(le instanceof p)) {
                  var de = j(this.casterConstructor, T[Y]);
                  le = T[Y] = new de(le, T, void 0, void 0, Y);
                }
                if (L == null || !L.validateModifiedOnly || le.$isModified()) {
                  var ae = le.validateSync(L);
                  ae && Z == null && (Z = ae);
                }
              }
            }
            return Z;
          }
        }, W.prototype.getDefault = function(T, D, L) {
          var M = typeof this.defaultValue == "function" ? this.defaultValue.call(T) : this.defaultValue;
          if (M == null || L && L.skipCast) return M;
          y || (y = a(4878)), Array.isArray(M) || (M = [M]), M = new y(M, this.path, T);
          for (var N = 0; N < M.length; ++N) {
            var Z = new (j(this.casterConstructor, M[N]))({}, M, void 0, void 0, N);
            Z.$init(M[N]), Z.isNew = !0, Object.assign(Z.$__.activePaths.default, Z.$__.activePaths.init), Z.$__.activePaths.init = {}, M[N] = Z;
          }
          return M;
        };
        var te = Object.freeze({ transform: !1, virtuals: !1 }), ee = Object.freeze({ skipId: !1, willInit: !0 });
        function V(T, D, L) {
          if (L && D) {
            for (var M, N, Z, Y = T.path + ".", ie = Object.keys(D), le = ie.length, de = {}; le--; ) if ((N = ie[le]).startsWith(Y)) {
              if ((Z = N.substring(Y.length)) === "$") continue;
              Z.startsWith("$.") && (Z = Z.substring(2)), M || (M = !0), de[Z] = D[N];
            }
            return M && de || void 0;
          }
        }
        W.prototype.cast = function(T, D, L, M, N) {
          if (y || (y = a(4878)), T != null && T[I] != null && T === M) return T;
          var Z, Y, ie = (N = N || {}).path || this.path;
          if (!Array.isArray(T)) {
            if (!L && !W.options.castNonArrays) throw new l("DocumentArray", T, this.path, null, this);
            return D && L && D.markModified(ie), this.cast([T], D, L, M, N);
          }
          N.skipDocumentArrayCast && !k.isMongooseDocumentArray(T) || (T = new y(T, ie, D, this)), M != null && (T[R] = M[R] || {}), N.arrayPathIndex != null && (T[I] = ie + "." + N.arrayPathIndex);
          for (var le = k.isMongooseDocumentArray(T) ? T.__array : T, de = le.length, ae = 0; ae < de; ++ae) if (le[ae]) {
            var ne = j(this.casterConstructor, le[ae]), he = O(le[ae], !0);
            if (le[ae] !== he && (le[ae] = he), le[ae] instanceof p) {
              if (le[ae][z] !== D) if (L) {
                var x = new ne(null, T, ee, Z, ae);
                le[ae] = x.$init(le[ae]);
              } else {
                var U = new ne(le[ae], T, void 0, void 0, ae);
                le[ae] = U;
              }
              le[ae].__index == null && le[ae].$setIndex(ae);
            } else if (le[ae] != null) if (L) D ? Z || (Z = V(this, D.$__.selected, L)) : Z = !0, Y = new ne(null, T, ee, Z, ae), le[ae] = Y.$init(le[ae], N);
            else if (M && typeof M.id == "function" && (Y = M.id(le[ae]._id)), M && Y && k.deepEqual(Y.toObject(te), le[ae])) Y.set(le[ae]), le[ae] = Y;
            else try {
              Y = new ne(le[ae], T, void 0, void 0, ae), le[ae] = Y;
            } catch (B) {
              throw new l("embedded", le[ae], T[I], B, this);
            }
          }
          return T;
        }, W.prototype.clone = function() {
          var T = Object.assign({}, this.options), D = new this.constructor(this.path, this.schema, T, this.schemaOptions);
          return D.validators = this.validators.slice(), this.requiredValidator !== void 0 && (D.requiredValidator = this.requiredValidator), D.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators), D._appliedDiscriminators = this._appliedDiscriminators, D;
        }, W.prototype.applyGetters = function(T, D) {
          return _.prototype.applyGetters.call(this, T, D);
        }, W.defaultOptions = {}, W.set = _.set, W.setters = [], W.get = _.get, W.prototype.$conditionalHandlers.$elemMatch = function(T, D) {
          for (var L, M = Object.keys(T), N = M.length, Z = 0; Z < N; ++Z) {
            var Y = M[Z], ie = T[Y];
            $(Y) && ie != null && (T[Y] = this.castForQuery(Y, ie, D));
          }
          var le = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey, de = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
          if (le != null && T[le] != null && de[T[le]] != null) return b(de[T[le]], T, null, this && this.$$context);
          var ae = (L = this.casterConstructor.schema) !== null && L !== void 0 ? L : D.schema;
          return b(ae, T, null, this && this.$$context);
        }, W.prototype.toJSONSchema = function(T) {
          var D = w("object", "object", T?.useBsonType, !1), L = this.options.required && typeof this.options.required != "function";
          return f(f({}, w("array", "array", T?.useBsonType, L)), {}, { items: f(f({}, D), this.schema.toJSONSchema(T)) });
        }, o.exports = W;
      }, 9166: (o, s, a) => {
        function u(l, d) {
          var v = typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
          if (!v) {
            if (Array.isArray(l) || (v = (function(A, E) {
              if (A) {
                if (typeof A == "string") return c(A, E);
                var O = {}.toString.call(A).slice(8, -1);
                return O === "Object" && A.constructor && (O = A.constructor.name), O === "Map" || O === "Set" ? Array.from(A) : O === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(O) ? c(A, E) : void 0;
              }
            })(l)) || d) {
              v && (l = v);
              var m = 0, g = function() {
              };
              return { s: g, n: function() {
                return m >= l.length ? { done: !0 } : { done: !1, value: l[m++] };
              }, e: function(A) {
                throw A;
              }, f: g };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var _, b = !0, w = !1;
          return { s: function() {
            v = v.call(l);
          }, n: function() {
            var A = v.next();
            return b = A.done, A;
          }, e: function(A) {
            w = !0, _ = A;
          }, f: function() {
            try {
              b || v.return == null || v.return();
            } finally {
              if (w) throw _;
            }
          } };
        }
        function c(l, d) {
          (d == null || d > l.length) && (d = l.length);
          for (var v = 0, m = Array(d); v < d; v++) m[v] = l[v];
          return m;
        }
        var f = a(8759), h = a(3696);
        function y(l, d, v) {
          if (d != null) {
            var m = Object.keys(d).some(function(R) {
              return R[0] === "$";
            });
            if (m) {
              if (d.$push && P(d.$push), d.$addToSet && P(d.$addToSet), d.$set != null) for (var g = 0, _ = Object.keys(d.$set); g < _.length; g++) {
                var b = _[g];
                p(v, b, d.$set, l);
              }
              if (d.$setOnInsert != null) for (var w = 0, A = Object.keys(d.$setOnInsert); w < A.length; w++) {
                var E = A[w];
                p(v, E, d.$setOnInsert, l);
              }
            }
            var O, $ = Object.keys(d).filter(function(R) {
              return R[0] !== "$";
            }), k = u($);
            try {
              for (k.s(); !(O = k.n()).done; ) {
                var j = O.value;
                p(v, j, d, l);
              }
            } catch (R) {
              k.e(R);
            } finally {
              k.f();
            }
          }
          function P(R) {
            for (var I = function() {
              var F = W[z], te = v.path(F.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
              if (R[F] && te && te.$isMongooseDocumentArray && te.schema.options.timestamps) {
                var ee = te.schema.options.timestamps, V = h(ee, "createdAt"), T = h(ee, "updatedAt");
                R[F].$each ? R[F].$each.forEach(function(D) {
                  T != null && (D[T] = l), V != null && (D[V] = l), y(l, D, te.schema);
                }) : (T != null && (R[F][T] = l), V != null && (R[F][V] = l), y(l, R[F], te.schema));
              }
            }, z = 0, W = Object.keys(R); z < W.length; z++) I();
          }
        }
        function p(l, d, v, m) {
          var g = f(d), _ = l.path(g);
          if (_) {
            for (var b = [], w = g.split("."), A = w.length - 1; A > 0; --A) {
              var E = l.path(w.slice(0, A).join("."));
              E != null && (E.$isMongooseDocumentArray || E.$isSingleNested) && b.push({ parentPath: d.split(".").slice(0, A).join("."), parentSchemaType: E });
            }
            if (Array.isArray(v[d]) && _.$isMongooseDocumentArray) (function(V, T, D) {
              var L = T.schema.options.timestamps, M = V.length;
              if (L) for (var N = h(L, "createdAt"), Z = h(L, "updatedAt"), Y = 0; Y < M; ++Y) Z != null && (V[Y][Z] = D), N != null && (V[Y][N] = D), y(D, V[Y], T.schema);
              else for (var ie = 0; ie < M; ++ie) y(D, V[ie], T.schema);
            })(v[d], _, m);
            else if (v[d] && _.$isSingleNested) (function(V, T, D) {
              var L = T.schema.options.timestamps;
              if (L) {
                var M = h(L, "createdAt"), N = h(L, "updatedAt");
                N != null && (V[N] = D), M != null && (V[M] = D), y(D, V, T.schema);
              } else y(D, V, T.schema);
            })(v[d], _, m);
            else if (b.length > 0) {
              var O, $ = u(b);
              try {
                for ($.s(); !(O = $.n()).done; ) {
                  var k = O.value, j = k.parentPath, P = k.parentSchemaType, R = P.schema.options.timestamps, I = h(R, "updatedAt");
                  if (R && I != null) {
                    if (P.$isSingleNested) v[j + "." + I] = m;
                    else if (P.$isMongooseDocumentArray) {
                      var z = d.substring(j.length + 1);
                      if (/^\d+$/.test(z)) {
                        v[j + "." + z][I] = m;
                        continue;
                      }
                      var W = z.indexOf(".");
                      v[j + "." + (z = W !== -1 ? z.substring(0, W) : z) + "." + I] = m;
                    }
                  }
                }
              } catch (V) {
                $.e(V);
              } finally {
                $.f();
              }
            } else if (_.schema != null && _.schema != l && v[d]) {
              var F = _.schema.options.timestamps, te = h(F, "createdAt"), ee = h(F, "updatedAt");
              if (!F) return;
              ee != null && (v[d][ee] = m), te != null && (v[d][te] = m);
            }
          }
        }
        o.exports = y;
      }, 9183: (o) => {
        o.exports = function(s) {
          return typeof s == "function" && s.constructor && s.constructor.name === "AsyncFunction";
        };
      }, 9206: (o) => {
        o.exports = EvalError;
      }, 9247: (o, s, a) => {
        var u = a(2481), c = a(2273);
        o.exports = function() {
          var f = u();
          return c(Object, { is: f }, { is: function() {
            return Object.is !== f;
          } }), f;
        };
      }, 9344: (o, s, a) => {
        function u(_) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, u(_);
        }
        var c, f = a(3071), h = a(953)(), y = a(5994), p = a(1464);
        if (h) {
          var l = f("RegExp.prototype.exec"), d = {}, v = function() {
            throw d;
          }, m = { toString: v, valueOf: v };
          u(Symbol.toPrimitive) === "symbol" && (m[Symbol.toPrimitive] = v), c = function(_) {
            if (!_ || u(_) !== "object") return !1;
            var b = p(_, "lastIndex");
            if (!b || !y(b, "value")) return !1;
            try {
              l(_, m);
            } catch (w) {
              return w === d;
            }
          };
        } else {
          var g = f("Object.prototype.toString");
          c = function(_) {
            return !(!_ || u(_) !== "object" && typeof _ != "function") && g(_) === "[object RegExp]";
          };
        }
        o.exports = c;
      }, 9380: (o, s, a) => {
        function u() {
          var g, _, b = typeof Symbol == "function" ? Symbol : {}, w = b.iterator || "@@iterator", A = b.toStringTag || "@@toStringTag";
          function E(z, W, F, te) {
            var ee = W && W.prototype instanceof $ ? W : $, V = Object.create(ee.prototype);
            return c(V, "_invoke", (function(T, D, L) {
              var M, N, Z, Y = 0, ie = L || [], le = !1, de = { p: 0, n: 0, v: g, a: ae, f: ae.bind(g, 4), d: function(ne, he) {
                return M = ne, N = 0, Z = g, de.n = he, O;
              } };
              function ae(ne, he) {
                for (N = ne, Z = he, _ = 0; !le && Y && !x && _ < ie.length; _++) {
                  var x, U = ie[_], B = de.p, J = U[2];
                  ne > 3 ? (x = J === he) && (Z = U[(N = U[4]) ? 5 : (N = 3, 3)], U[4] = U[5] = g) : U[0] <= B && ((x = ne < 2 && B < U[1]) ? (N = 0, de.v = he, de.n = U[1]) : B < J && (x = ne < 3 || U[0] > he || he > J) && (U[4] = ne, U[5] = he, de.n = J, N = 0));
                }
                if (x || ne > 1) return O;
                throw le = !0, he;
              }
              return function(ne, he, x) {
                if (Y > 1) throw TypeError("Generator is already running");
                for (le && he === 1 && ae(he, x), N = he, Z = x; (_ = N < 2 ? g : Z) || !le; ) {
                  M || (N ? N < 3 ? (N > 1 && (de.n = -1), ae(N, Z)) : de.n = Z : de.v = Z);
                  try {
                    if (Y = 2, M) {
                      if (N || (ne = "next"), _ = M[ne]) {
                        if (!(_ = _.call(M, Z))) throw TypeError("iterator result is not an object");
                        if (!_.done) return _;
                        Z = _.value, N < 2 && (N = 0);
                      } else N === 1 && (_ = M.return) && _.call(M), N < 2 && (Z = TypeError("The iterator does not provide a '" + ne + "' method"), N = 1);
                      M = g;
                    } else if ((_ = (le = de.n < 0) ? Z : T.call(D, de)) !== O) break;
                  } catch (U) {
                    M = g, N = 1, Z = U;
                  } finally {
                    Y = 1;
                  }
                }
                return { value: _, done: le };
              };
            })(z, F, te), !0), V;
          }
          var O = {};
          function $() {
          }
          function k() {
          }
          function j() {
          }
          _ = Object.getPrototypeOf;
          var P = [][w] ? _(_([][w]())) : (c(_ = {}, w, function() {
            return this;
          }), _), R = j.prototype = $.prototype = Object.create(P);
          function I(z) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(z, j) : (z.__proto__ = j, c(z, A, "GeneratorFunction")), z.prototype = Object.create(R), z;
          }
          return k.prototype = j, c(R, "constructor", j), c(j, "constructor", k), k.displayName = "GeneratorFunction", c(j, A, "GeneratorFunction"), c(R), c(R, A, "Generator"), c(R, w, function() {
            return this;
          }), c(R, "toString", function() {
            return "[object Generator]";
          }), (u = function() {
            return { w: E, m: I };
          })();
        }
        function c(g, _, b, w) {
          var A = Object.defineProperty;
          try {
            A({}, "", {});
          } catch {
            A = 0;
          }
          c = function(E, O, $, k) {
            function j(P, R) {
              c(E, P, function(I) {
                return this._invoke(P, R, I);
              });
            }
            O ? A ? A(E, O, { value: $, enumerable: !k, configurable: !k, writable: !k }) : E[O] = $ : (j("next", 0), j("throw", 1), j("return", 2));
          }, c(g, _, b, w);
        }
        function f(g, _, b, w, A, E, O) {
          try {
            var $ = g[E](O), k = $.value;
          } catch (j) {
            return void b(j);
          }
          $.done ? _(k) : Promise.resolve(k).then(w, A);
        }
        function h(g) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
            return typeof _;
          } : function(_) {
            return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
          }, h(g);
        }
        var y = a(2400), p = a(2746), l = a(3303)._, d = a(7352), v = a(8768);
        function m(g, _, b, w, A) {
          if (h(w) === "object" && w != null && A == null && (A = w, w = void 0), b != null) {
            var E = { isNew: b.isNew };
            "defaults" in b.$__ && (E.defaults = b.$__.defaults), A = Object.assign(E, A);
          }
          A != null && A.path != null && (this.$basePath = A.path), A != null && A.pathRelativeToParent != null && (this.$pathRelativeToParent = A.pathRelativeToParent);
          var O = A;
          A != null && A.path != null && delete (O = Object.assign({}, A)).path, y.call(this, g, _, w, O), delete this.$__.priorDoc;
        }
        o.exports = m, m.prototype = Object.create(y.prototype), Object.defineProperty(m.prototype, "$isSubdocument", { configurable: !1, writable: !1, value: !0 }), Object.defineProperty(m.prototype, "$isSingleNested", { configurable: !1, writable: !1, value: !0 }), m.prototype.toBSON = function() {
          return this.toObject(l);
        }, m.prototype.save = (function() {
          var g, _ = (g = u().m(function b(w) {
            var A = this;
            return u().w(function(E) {
              for (; ; ) if (E.n === 0) return (w = w || {}).suppressWarning || v.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app."), E.a(2, new Promise(function(O, $) {
                A.$__save(function(k) {
                  if (k != null) return $(k);
                  O(A);
                });
              }));
            }, b);
          }), function() {
            var b = this, w = arguments;
            return new Promise(function(A, E) {
              var O = g.apply(b, w);
              function $(j) {
                f(O, A, E, $, k, "next", j);
              }
              function k(j) {
                f(O, A, E, $, k, "throw", j);
              }
              $(void 0);
            });
          });
          return function(b) {
            return _.apply(this, arguments);
          };
        })(), m.prototype.$__fullPath = function(g) {
          return this.$__.fullPath || this.ownerDocument(), g ? this.$__.fullPath + "." + g : this.$__.fullPath;
        }, m.prototype.$__pathRelativeToParent = function(g) {
          return this.$pathRelativeToParent != null ? g == null ? this.$pathRelativeToParent : this.$pathRelativeToParent + "." + g : g == null ? this.$basePath : this.$basePath ? [this.$basePath, g].join(".") : g;
        }, m.prototype.$__save = function(g) {
          var _ = this;
          return p(function() {
            return g(null, _);
          });
        }, m.prototype.$isValid = function(g) {
          var _ = this.$parent(), b = this.$__pathRelativeToParent(g);
          return _ != null && b != null ? _.$isValid(b) : y.prototype.$isValid.call(this, g);
        }, m.prototype.markModified = function(g) {
          y.prototype.markModified.call(this, g);
          var _ = this.$parent();
          if (_ != null) {
            var b = this.$__pathRelativeToParent(g);
            if (b != null) {
              var w = this.$__pathRelativeToParent().replace(/\.$/, "");
              _.isDirectModified(w) || this.isNew || this.$__parent.markModified(b, this);
            }
          }
        }, m.prototype.isModified = function(g, _, b) {
          var w = this, A = this.$parent();
          return A != null ? (Array.isArray(g) || typeof g == "string" ? g = (g = Array.isArray(g) ? g : g.split(" ")).map(function(E) {
            return w.$__pathRelativeToParent(E);
          }).filter(function(E) {
            return E != null;
          }) : g || (g = this.$__pathRelativeToParent()), A.$isModified(g, _, b)) : y.prototype.isModified.call(this, g, _, b);
        }, m.prototype.$markValid = function(g) {
          y.prototype.$markValid.call(this, g);
          var _ = this.$parent(), b = this.$__pathRelativeToParent(g);
          _ != null && b != null && _.$markValid(b);
        }, m.prototype.invalidate = function(g, _, b) {
          y.prototype.invalidate.call(this, g, _, b);
          var w = this.$parent(), A = this.$__pathRelativeToParent(g);
          if (w != null && A != null) w.invalidate(A, _, b);
          else if (_.kind === "cast" || _.name === "CastError" || A == null) throw _;
          return this.ownerDocument().$__.validationError;
        }, m.prototype.$ignore = function(g) {
          y.prototype.$ignore.call(this, g);
          var _ = this.$parent(), b = this.$__pathRelativeToParent(g);
          _ != null && b != null && _.$ignore(b);
        }, m.prototype.ownerDocument = function() {
          if (this.$__.ownerDocument) return this.$__.ownerDocument;
          for (var g = this, _ = [], b = /* @__PURE__ */ new Set([g]); typeof g.$__pathRelativeToParent == "function"; ) {
            _.unshift(g.$__pathRelativeToParent(void 0, !0));
            var w = g.$parent();
            if (w == null) break;
            if (g = w, b.has(g)) throw new Error("Infinite subdocument loop: subdoc with _id " + g._id + " is a parent of itself");
            b.add(g);
          }
          return this.$__.fullPath = _.join("."), this.$__.ownerDocument = g, this.$__.ownerDocument;
        }, m.prototype.$__fullPathWithIndexes = function() {
          for (var g = this, _ = [], b = /* @__PURE__ */ new Set([g]); typeof g.$__pathRelativeToParent == "function"; ) {
            _.unshift(g.$__pathRelativeToParent(void 0, !1));
            var w = g.$parent();
            if (w == null) break;
            if (g = w, b.has(g)) throw new Error("Infinite subdocument loop: subdoc with _id " + g._id + " is a parent of itself");
            b.add(g);
          }
          return _.join(".");
        }, m.prototype.parent = function() {
          return this.$__parent;
        }, m.prototype.$parent = m.prototype.parent, m.prototype.$__deleteOne = function(g) {
          if (g != null) return g(null, this);
        }, m.prototype.$__removeFromParent = function() {
          this.$__parent.set(this.$basePath, null);
        }, m.prototype.deleteOne = function(g, _) {
          if (typeof g == "function" && (_ = g, g = null), (function(w) {
            var A = w.ownerDocument();
            function E() {
              A.$removeListener("save", E), A.$removeListener("deleteOne", E), w.emit("deleteOne", w), w.constructor.emit("deleteOne", w);
            }
            A.$on("save", E), A.$on("deleteOne", E);
          })(this), !g || !g.noop) {
            this.$__removeFromParent();
            var b = this.ownerDocument();
            b.$__.removedSubdocs = b.$__.removedSubdocs || [], b.$__.removedSubdocs.push(this);
          }
          return this.$__deleteOne(_);
        }, m.prototype.populate = function() {
          throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
        }, m.prototype.inspect = function() {
          return this.toObject();
        }, d.inspect.custom && (m.prototype[d.inspect.custom] = m.prototype.inspect), m.prototype.$toObject = function(g, _) {
          var b, w, A, E, O = y.prototype.$toObject.call(this, g, _);
          if (Object.keys(O).length !== 0 || g?._calledWithOptions == null || !((b = (w = (A = g._calledWithOptions) === null || A === void 0 ? void 0 : A.minimize) !== null && w !== void 0 ? w : this == null || (E = this.$__schemaTypeOptions) === null || E === void 0 ? void 0 : E.minimize) !== null && b !== void 0 ? b : g.minimize) || this.constructor.$__required) return O;
        };
      }, 9460: (o, s, a) => {
        var u = a(5832).hp, c = a(3609);
        function f(h, y) {
          var p = Number(y);
          if (isNaN(p)) throw new c("number", y, h);
          return p;
        }
        o.exports = function(h) {
          var y = this;
          return Array.isArray(h) ? h.map(function(p) {
            return f(y.path, p);
          }) : u.isBuffer(h) ? h : f(y.path, h);
        };
      }, 9471: (o) => {
        o.exports = Math.abs;
      }, 9528: (o, s, a) => {
        function u(l) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, u(l);
        }
        function c() {
          try {
            var l = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (c = function() {
            return !!l;
          })();
        }
        function f(l) {
          return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(d) {
            return d.__proto__ || Object.getPrototypeOf(d);
          }, f(l);
        }
        function h(l, d) {
          return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, m) {
            return v.__proto__ = m, v;
          }, h(l, d);
        }
        var y = (function(l) {
          function d() {
            return (function(m, g) {
              if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
            })(this, d), (function(m, g, _) {
              return g = f(g), (function(b, w) {
                if (w && (u(w) == "object" || typeof w == "function")) return w;
                if (w !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(A) {
                  if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return A;
                })(b);
              })(m, c() ? Reflect.construct(g, _ || [], f(m).constructor) : g.apply(m, _));
            })(this, d, arguments);
          }
          return (function(m, g) {
            if (typeof g != "function" && g !== null) throw new TypeError("Super expression must either be null or a function");
            m.prototype = Object.create(g && g.prototype, { constructor: { value: m, writable: !0, configurable: !0 } }), Object.defineProperty(m, "prototype", { writable: !1 }), g && h(m, g);
          })(d, l), v = d, Object.defineProperty(v, "prototype", { writable: !1 }), v;
          var v;
        })(a(8879)), p = a(5761);
        Object.defineProperty(y.prototype, "enum", p), Object.defineProperty(y.prototype, "match", p), Object.defineProperty(y.prototype, "lowercase", p), Object.defineProperty(y.prototype, "trim", p), Object.defineProperty(y.prototype, "uppercase", p), Object.defineProperty(y.prototype, "minLength", p), Object.defineProperty(y.prototype, "minlength", p), Object.defineProperty(y.prototype, "maxLength", p), Object.defineProperty(y.prototype, "maxlength", p), Object.defineProperty(y.prototype, "populate", p), o.exports = y;
      }, 9538: (o, s, a) => {
        function u(m) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, u(m);
        }
        function c(m, g) {
          for (var _ = 0; _ < g.length; _++) {
            var b = g[_];
            b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(m, f(b.key), b);
          }
        }
        function f(m) {
          var g = (function(_) {
            if (u(_) != "object" || !_) return _;
            var b = _[Symbol.toPrimitive];
            if (b !== void 0) {
              var w = b.call(_, "string");
              if (u(w) != "object") return w;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(_);
          })(m);
          return u(g) == "symbol" ? g : g + "";
        }
        function h() {
          try {
            var m = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (h = function() {
            return !!m;
          })();
        }
        function y(m) {
          return y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(g) {
            return g.__proto__ || Object.getPrototypeOf(g);
          }, y(m);
        }
        function p(m, g) {
          return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(_, b) {
            return _.__proto__ = b, _;
          }, p(m, g);
        }
        var l = a(8213), d = (function(m) {
          function g(w, A) {
            var E;
            (function(k, j) {
              if (!(k instanceof j)) throw new TypeError("Cannot call a class as a function");
            })(this, g);
            var O = w.message;
            O || (O = l.messages.general.default);
            var $ = v(O, w, A);
            return E = (function(k, j, P) {
              return j = y(j), (function(R, I) {
                if (I && (u(I) == "object" || typeof I == "function")) return I;
                if (I !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
                return (function(z) {
                  if (z === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return z;
                })(R);
              })(k, h() ? Reflect.construct(j, P || [], y(k).constructor) : j.apply(k, P));
            })(this, g, [$]), w = Object.assign({}, w, { message: $ }), E.properties = w, E.kind = w.type, E.path = w.path, E.value = w.value, E.reason = w.reason, E;
          }
          return (function(w, A) {
            if (typeof A != "function" && A !== null) throw new TypeError("Super expression must either be null or a function");
            w.prototype = Object.create(A && A.prototype, { constructor: { value: w, writable: !0, configurable: !0 } }), Object.defineProperty(w, "prototype", { writable: !1 }), A && p(w, A);
          })(g, m), _ = g, (b = [{ key: "toString", value: function() {
            return this.message;
          } }, { key: "toJSON", value: function() {
            return Object.assign({ name: this.name, message: this.message }, this);
          } }]) && c(_.prototype, b), Object.defineProperty(_, "prototype", { writable: !1 }), _;
          var _, b;
        })(l);
        function v(m, g, _) {
          if (typeof m == "function") return m(g, _);
          for (var b = 0, w = Object.keys(g); b < w.length; b++) {
            var A = w[b];
            A !== "message" && (m = m.replace("{" + A.toUpperCase() + "}", g[A]));
          }
          return m;
        }
        Object.defineProperty(d.prototype, "name", { value: "ValidatorError" }), Object.defineProperty(d.prototype, "properties", { enumerable: !1, writable: !0, value: null }), d.prototype.formatMessage = v, o.exports = d;
      }, 9539: (o) => {
        function s(u, c) {
          return (function(f) {
            if (Array.isArray(f)) return f;
          })(u) || (function(f, h) {
            var y = f == null ? null : typeof Symbol < "u" && f[Symbol.iterator] || f["@@iterator"];
            if (y != null) {
              var p, l, d, v, m = [], g = !0, _ = !1;
              try {
                if (d = (y = y.call(f)).next, h !== 0) for (; !(g = (p = d.call(y)).done) && (m.push(p.value), m.length !== h); g = !0) ;
              } catch (b) {
                _ = !0, l = b;
              } finally {
                try {
                  if (!g && y.return != null && (v = y.return(), Object(v) !== v)) return;
                } finally {
                  if (_) throw l;
                }
              }
              return m;
            }
          })(u, c) || (function(f, h) {
            if (f) {
              if (typeof f == "string") return a(f, h);
              var y = {}.toString.call(f).slice(8, -1);
              return y === "Object" && f.constructor && (y = f.constructor.name), y === "Map" || y === "Set" ? Array.from(f) : y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y) ? a(f, h) : void 0;
            }
          })(u, c) || (function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          })();
        }
        function a(u, c) {
          (c == null || c > u.length) && (c = u.length);
          for (var f = 0, h = Array(c); f < c; f++) h[f] = u[f];
          return h;
        }
        o.exports = function(u, c, f) {
          for (var h = {}, y = 0, p = Object.keys(c.tree); y < p.length; y++) {
            var l = p[y];
            f && (u.paths[l] || u.nested[l] || u.singleNestedPaths[l]) || (h[l] = c.tree[l]);
          }
          u.options._isMerging = !0, u.add(h, null), delete u.options._isMerging, u.callQueue = u.callQueue.concat(c.callQueue), u.method(c.methods), u.static(c.statics);
          for (var d = 0, v = Object.entries(c._userProvidedOptions); d < v.length; d++) {
            var m = s(v[d], 2), g = m[0], _ = m[1];
            g in u._userProvidedOptions || u.set(g, _);
          }
          for (var b in c.query) u.query[b] = c.query[b];
          for (var w in c.virtuals) u.virtuals[w] = c.virtuals[w].clone();
          u._indexes = u._indexes.concat(c._indexes || []), u.s.hooks.merge(c.s.hooks, !1);
        };
      }, 9553: (o, s, a) => {
        var u = a(5832).hp;
        function c(y) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p) {
            return typeof p;
          } : function(p) {
            return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
          }, c(y);
        }
        var f = a(9639), h = a(2402);
        o.exports = function(y) {
          return y == null ? y : c(y) === "object" && typeof y.$numberDecimal == "string" ? f.fromString(y.$numberDecimal) : y instanceof f ? y : typeof y == "string" ? f.fromString(y) : typeof u == "function" && u.isBuffer(y) || typeof Uint8Array == "function" && y instanceof Uint8Array ? new f(y) : typeof y == "number" ? f.fromString(String(y)) : typeof y.valueOf == "function" && typeof y.valueOf() == "string" ? f.fromString(y.valueOf()) : void h.ok(!1);
        };
      }, 9600: (o, s, a) => {
        s.Array = a(7557), s.Buffer = a(6365), s.Document = s.Embedded = a(6547), s.DocumentArray = a(4878), s.Double = a(2822), s.Decimal128 = a(9639), s.ObjectId = a(5549), s.Map = a(2081), s.Subdocument = a(9380), s.UUID = a(1344);
      }, 9604: (o, s, a) => {
        var u = a(5558).p, c = a(5558).G;
        function f(y, p) {
          switch (y.$geometry.type) {
            case "Polygon":
            case "LineString":
            case "Point":
              u(y.$geometry.coordinates, p);
          }
          return h(p, y), y;
        }
        function h(y, p) {
          p.$maxDistance && (p.$maxDistance = c.call(y, p.$maxDistance)), p.$minDistance && (p.$minDistance = c.call(y, p.$minDistance));
        }
        s.cast$geoIntersects = function(y) {
          if (y.$geometry) return f(y, this), y;
        }, s.cast$near = function(y) {
          var p = a(7760);
          if (Array.isArray(y)) return u(y, this), y;
          if (h(this, y), y && y.$geometry) return f(y, this);
          if (!Array.isArray(y)) throw new TypeError("$near must be either an array or an object with a $geometry property");
          return p.prototype.castForQuery.call(this, null, y);
        }, s.cast$within = function(y) {
          var p = this;
          if (h(this, y), y.$box || y.$polygon) {
            var l = y.$box ? "$box" : "$polygon";
            y[l].forEach(function(v) {
              if (!Array.isArray(v)) throw new TypeError("Invalid $within $box argument. Expected an array, received " + v);
              v.forEach(function(m, g) {
                v[g] = c.call(p, m);
              });
            });
          } else if (y.$center || y.$centerSphere) {
            var d = y.$center ? "$center" : "$centerSphere";
            y[d].forEach(function(v, m) {
              Array.isArray(v) ? v.forEach(function(g, _) {
                v[_] = c.call(p, g);
              }) : y[d][m] = c.call(p, v);
            });
          } else y.$geometry && f(y, this);
          return y;
        };
      }, 9639: (o, s, a) => {
        o.exports = a(6353).Decimal128;
      }, 9696: (o) => {
        var s = /^function\s*([^\s(]+)/;
        o.exports = function(a) {
          return a.name || (a.toString().trim().match(s) || [])[1];
        };
      }, 9809: (o) => {
        function s(_) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, s(_);
        }
        var a, u, c = Function.prototype.toString, f = (typeof Reflect > "u" ? "undefined" : s(Reflect)) === "object" && Reflect !== null && Reflect.apply;
        if (typeof f == "function" && typeof Object.defineProperty == "function") try {
          a = Object.defineProperty({}, "length", { get: function() {
            throw u;
          } }), u = {}, f(function() {
            throw 42;
          }, null, a);
        } catch (_) {
          _ !== u && (f = null);
        }
        else f = null;
        var h = /^\s*class\b/, y = function(_) {
          try {
            var b = c.call(_);
            return h.test(b);
          } catch {
            return !1;
          }
        }, p = function(_) {
          try {
            return !y(_) && (c.call(_), !0);
          } catch {
            return !1;
          }
        }, l = Object.prototype.toString, d = typeof Symbol == "function" && !!Symbol.toStringTag, v = !(0 in [,]), m = function() {
          return !1;
        };
        if ((typeof document > "u" ? "undefined" : s(document)) === "object") {
          var g = document.all;
          l.call(g) === l.call(document.all) && (m = function(_) {
            if ((v || !_) && (_ === void 0 || s(_) === "object")) try {
              var b = l.call(_);
              return (b === "[object HTMLAllCollection]" || b === "[object HTML document.all class]" || b === "[object HTMLCollection]" || b === "[object Object]") && _("") == null;
            } catch {
            }
            return !1;
          });
        }
        o.exports = f ? function(_) {
          if (m(_)) return !0;
          if (!_ || typeof _ != "function" && s(_) !== "object") return !1;
          try {
            f(_, null, a);
          } catch (b) {
            if (b !== u) return !1;
          }
          return !y(_) && p(_);
        } : function(_) {
          if (m(_)) return !0;
          if (!_ || typeof _ != "function" && s(_) !== "object") return !1;
          if (d) return p(_);
          if (y(_)) return !1;
          var b = l.call(_);
          return !(b !== "[object Function]" && b !== "[object GeneratorFunction]" && !/^\[object HTML/.test(b)) && p(_);
        };
      }, 9834: (o, s, a) => {
        function u(A) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          }, u(A);
        }
        var c = a(3777), f = a(3426), h = a(9122), y = a(3071), p = a(1464), l = a(209), d = y("Object.prototype.toString"), v = a(953)(), m = typeof globalThis > "u" ? a.g : globalThis, g = f(), _ = y("String.prototype.slice"), b = y("Array.prototype.indexOf", !0) || function(A, E) {
          for (var O = 0; O < A.length; O += 1) if (A[O] === E) return O;
          return -1;
        }, w = { __proto__: null };
        c(g, v && p && l ? function(A) {
          var E = new m[A]();
          if (Symbol.toStringTag in E && l) {
            var O = l(E), $ = p(O, Symbol.toStringTag);
            if (!$ && O) {
              var k = l(O);
              $ = p(k, Symbol.toStringTag);
            }
            w["$" + A] = h($.get);
          }
        } : function(A) {
          var E = new m[A](), O = E.slice || E.set;
          O && (w["$" + A] = h(O));
        }), o.exports = function(A) {
          if (!A || u(A) !== "object") return !1;
          if (!v) {
            var E = _(d(A), 8, -1);
            return b(g, E) > -1 ? E : E === "Object" && (function(O) {
              var $ = !1;
              return c(w, function(k, j) {
                if (!$) try {
                  k(O), $ = _(j, 1);
                } catch {
                }
              }), $;
            })(A);
          }
          return p ? (function(O) {
            var $ = !1;
            return c(w, function(k, j) {
              if (!$) try {
                "$" + k(O) === j && ($ = _(j, 1));
              } catch {
              }
            }), $;
          })(A) : null;
        };
      }, 9848: (o) => {
        function s(a) {
          return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
            return typeof u;
          } : function(u) {
            return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
          }, s(a);
        }
        o.exports = function(a) {
          a.pre("save", !1, function(u, c) {
            var f = this, h = this;
            if (this.$isSubdocument) return u();
            if (c && s(c) === "object" && "validateBeforeSave" in c ? c.validateBeforeSave : this.$__schema.options.validateBeforeSave) {
              var y = c && s(c) === "object" && "validateModifiedOnly" in c ? { validateModifiedOnly: c.validateModifiedOnly } : null;
              this.$validate(y).then(function() {
                f.$op = "save", u();
              }, function(p) {
                h.$__schema.s.hooks.execPost("save:error", h, [h], { error: p }, function(l) {
                  h.$op = "save", u(l);
                });
              });
            } else u();
          }, null, !0);
        };
      }, 9870: (o) => {
        o.exports = Error;
      }, 9907: (o) => {
        o.exports = SyntaxError;
      }, 9939: (o) => {
        o.exports = RangeError;
      } }, i = {};
      function n(o) {
        var s = i[o];
        if (s !== void 0) return s.exports;
        var a = i[o] = { exports: {} };
        return r[o](a, a.exports, n), a.exports;
      }
      return n.d = (o, s) => {
        for (var a in s) n.o(s, a) && !n.o(o, a) && Object.defineProperty(o, a, { enumerable: !0, get: s[a] });
      }, n.g = (function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      })(), n.o = (o, s) => Object.prototype.hasOwnProperty.call(o, s), n.r = (o) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
      }, n(4829);
    })());
  })(Rs)), Rs.exports;
}
var zR = DR();
const aq = /* @__PURE__ */ Bi(zR);
var So = { exports: {} }, Fc, Rv;
function UR() {
  if (Rv) return Fc;
  Rv = 1;
  function e(a, u) {
    var c = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
      var f = Object.getOwnPropertySymbols(a);
      u && (f = f.filter(function(h) {
        return Object.getOwnPropertyDescriptor(a, h).enumerable;
      })), c.push.apply(c, f);
    }
    return c;
  }
  function t(a) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u] != null ? arguments[u] : {};
      u % 2 ? e(Object(c), !0).forEach(function(f) {
        r(a, f, c[f]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(c)) : e(Object(c)).forEach(function(f) {
        Object.defineProperty(a, f, Object.getOwnPropertyDescriptor(c, f));
      });
    }
    return a;
  }
  function r(a, u, c) {
    return u in a ? Object.defineProperty(a, u, { value: c, enumerable: !0, configurable: !0, writable: !0 }) : a[u] = c, a;
  }
  function i(a, u) {
    if (!(a instanceof u))
      throw new TypeError("Cannot call a class as a function");
  }
  function n(a, u) {
    for (var c = 0; c < u.length; c++) {
      var f = u[c];
      f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(a, f.key, f);
    }
  }
  function o(a, u, c) {
    return u && n(a.prototype, u), a;
  }
  var s = /* @__PURE__ */ (function() {
    function a(u) {
      i(this, a), this.query = u.query;
    }
    return o(a, [{
      key: "booleanOpt",
      value: function(c) {
        return typeof c == "string" ? c === "true" : c;
      }
      /**
       * Handle options that are strings or objects (including arrays)
       *
       * @param {object|string} option
       * @return {object|string}
       * */
    }, {
      key: "optObjectOrString",
      value: function(c) {
        var f = ["{", "["], h = ["}", "]"], y = c[0] && f.includes(c[0]), p = c[c.length - 1] && h.includes(c[c.length - 1]), l = y && p;
        try {
          return l ? JSON.parse(c) : c;
        } catch {
          return {};
        }
      }
      /**
       * Yields the "query" parameter for Model.paginate()
       * given any attributes of the Express req.query-Object,
       * */
    }, {
      key: "getQuery",
      value: function() {
        var c, f = (c = this.query) === null || c === void 0 ? void 0 : c.query;
        if (!f) return {};
        try {
          return JSON.parse(f);
        } catch {
          return {};
        }
      }
      /**
       * Yields the "options" parameter for Model.paginate(),
       * given any attributes of the Express req.query-Object
       * */
    }, {
      key: "getOptions",
      value: function() {
        if (!this.query) return {};
        var c = {}, f = this.query.select, h = this.query.collation, y = this.query.sort, p = this.query.populate, l = this.query.projection, d = this.query.lean, v = this.query.leanWithId, m = this.query.leanWithVirtuals, g = this.query.offset, _ = this.query.page, b = this.query.limit, w = this.query.customLabels, A = this.query.pagination, E = this.query.useEstimatedCount, O = this.query.useCustomCountFn, $ = this.query.forceCountFn, k = this.query.allowDiskUse, j = this.query.read, P = this.query.options;
        return f && (c.select = this.optObjectOrString(f)), h && (c.collation = this.optObjectOrString(h)), y && (c.sort = this.optObjectOrString(y)), p && (c.populate = this.optObjectOrString(p)), l !== void 0 && (c.projection = this.optObjectOrString(l)), d !== void 0 && (c.lean = this.booleanOpt(d)), v !== void 0 && (c.leanWithId = this.booleanOpt(v)), m !== void 0 && (c.leanWithVirtuals = this.booleanOpt(m)), g && (c.offset = Number(g)), _ && (c.page = Number(_)), (b || b == 0) && (c.limit = Number(b)), w && (c.customLabels = this.optObjectOrString(w)), A !== void 0 && (c.pagination = this.booleanOpt(A)), E !== void 0 && (c.useEstimatedCount = this.booleanOpt(E)), O !== void 0 && (c.useCustomCountFn = this.booleanOpt(O)), $ !== void 0 && (c.forceCountFn = this.booleanOpt($)), k && (c.allowDiskUse = this.booleanOpt(k)), j && (c.read = this.optObjectOrString(j)), P && (c.options = this.getOptions(P)), c;
      }
      /**
       * Yields an array with positions:
       * [0] "query" parameter, for Model.paginate()
       * [1] "options" parameter, for Model.paginate()
       * */
    }, {
      key: "get",
      value: function() {
        return [t({}, this.getQuery()), t({}, this.getOptions())];
      }
    }]), a;
  })();
  return Fc = s, Fc;
}
var Lc, Dv;
function MR() {
  if (Dv) return Lc;
  Dv = 1;
  function e(n, o) {
    var s = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
      var a = Object.getOwnPropertySymbols(n);
      o && (a = a.filter(function(u) {
        return Object.getOwnPropertyDescriptor(n, u).enumerable;
      })), s.push.apply(s, a);
    }
    return s;
  }
  function t(n) {
    for (var o = 1; o < arguments.length; o++) {
      var s = arguments[o] != null ? arguments[o] : {};
      o % 2 ? e(Object(s), !0).forEach(function(a) {
        r(n, a, s[a]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(s)) : e(Object(s)).forEach(function(a) {
        Object.defineProperty(n, a, Object.getOwnPropertyDescriptor(s, a));
      });
    }
    return n;
  }
  function r(n, o, s) {
    return o in n ? Object.defineProperty(n, o, { value: s, enumerable: !0, configurable: !0, writable: !0 }) : n[o] = s, n;
  }
  function i(n, o, s) {
    function a(b) {
      var w = b.populate, A = b.page, E = A === void 0 ? 1 : A, O = b.limit, $ = O === void 0 ? 10 : O;
      if (!w)
        throw new Error("populate is required");
      var k = (E - 1) * $;
      b.offset = k;
      var j = {
        skip: k,
        limit: $
      };
      return typeof w == "string" ? w = t({
        path: w
      }, j) : typeof w == "object" && !Array.isArray(w) && (w = Object.assign(w, j)), b.populate = w, w;
    }
    function u(b, w) {
      return b.populate(w);
    }
    function c(b, w) {
      var A = w.populate, E = w.offset, O = E === void 0 ? 0 : E, $ = w.page, k = $ === void 0 ? 1 : $, j = w.limit, P = j === void 0 ? 10 : j, R = A.path, I = w.count, z = b[R];
      if (!z)
        throw new Error(`Parse error! Cannot find key on result with path ${R}`);
      k = Math.ceil((O + 1) / P);
      var W = {
        docs: z,
        totalDocs: I || 1,
        limit: P,
        page: k,
        prevPage: null,
        nextPage: null,
        hasPrevPage: !1,
        hasNextPage: !1
      }, F = P > 0 ? Math.ceil(I / P) || 1 : null;
      W.totalPages = F, W.pagingCounter = (k - 1) * P + 1, k > 1 ? (W.hasPrevPage = !0, W.prevPage = k - 1) : k == 1 && O !== 0 && (W.hasPrevPage = !0, W.prevPage = 1), k < F && (W.hasNextPage = !0, W.nextPage = k + 1), P == 0 && (W.limit = 0, W.totalPages = 1, W.page = 1, W.pagingCounter = 1), Object.defineProperty(b, R, {
        value: W,
        writable: !1
      });
    }
    var f = o.populate, h = o.read, y = h === void 0 ? {} : h, p = o.select, l = p === void 0 ? "" : p, d = o.pagination, v = d === void 0 ? !0 : d, m = o.pagingOptions, g = o.projection, _ = this.findOne(n, g);
    return y && y.pref && _.read(y.pref, y.tags), l && _.select(l), new Promise(function(b, w) {
      _.exec().then(function(A) {
        var E = [];
        if (f && E.push(E), v && m)
          if (Array.isArray(m))
            m.forEach(function($) {
              var k = a($);
              $.count = A[k.path].length, E.push(k);
            });
          else {
            var O = a(m);
            m.count = A[O.path].length, E.push(O);
          }
        u(A, E).then(function($) {
          v && m && (Array.isArray(m) ? m.forEach(function(k) {
            c($, k);
          }) : c($, m)), s && s(null, $), b($);
        });
      }).catch(function(A) {
        console.error(A.message), s && s(A, null), w(A);
      });
    });
  }
  return Lc = i, Lc;
}
var Bc, zv;
function FR() {
  if (zv) return Bc;
  zv = 1;
  function e(t) {
    return this.model.paginate(this.getQuery(), t);
  }
  return Bc = e, Bc;
}
var Uv;
function LR() {
  if (Uv) return So.exports;
  Uv = 1;
  function e(u, c) {
    var f = Object.keys(u);
    if (Object.getOwnPropertySymbols) {
      var h = Object.getOwnPropertySymbols(u);
      c && (h = h.filter(function(y) {
        return Object.getOwnPropertyDescriptor(u, y).enumerable;
      })), f.push.apply(f, h);
    }
    return f;
  }
  function t(u) {
    for (var c = 1; c < arguments.length; c++) {
      var f = arguments[c] != null ? arguments[c] : {};
      c % 2 ? e(Object(f), !0).forEach(function(h) {
        r(u, h, f[h]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(u, Object.getOwnPropertyDescriptors(f)) : e(Object(f)).forEach(function(h) {
        Object.defineProperty(u, h, Object.getOwnPropertyDescriptor(f, h));
      });
    }
    return u;
  }
  function r(u, c, f) {
    return c in u ? Object.defineProperty(u, c, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : u[c] = f, u;
  }
  var i = UR(), n = MR(), o = FR(), s = {
    customLabels: {
      totalDocs: "totalDocs",
      limit: "limit",
      page: "page",
      totalPages: "totalPages",
      docs: "docs",
      nextPage: "nextPage",
      prevPage: "prevPage",
      pagingCounter: "pagingCounter",
      hasPrevPage: "hasPrevPage",
      hasNextPage: "hasNextPage",
      meta: null
    },
    collation: {},
    lean: !1,
    leanWithId: !0,
    leanWithVirtuals: !1,
    limit: 10,
    projection: {},
    select: "",
    options: {},
    pagination: !0,
    useEstimatedCount: !1,
    useCustomCountFn: !1,
    forceCountFn: !1,
    allowDiskUse: !1,
    customFind: "find"
  };
  function a(u, c, f) {
    c = t(t(t({}, s), a.options), c), u = u || {};
    var h = c, y = h.collation, p = h.lean, l = h.leanWithId, d = h.leanWithVirtuals, v = h.populate, m = h.projection, g = h.read, _ = h.select, b = h.sort, w = h.pagination, A = h.useEstimatedCount, E = h.useCustomCountFn, O = h.forceCountFn, $ = h.allowDiskUse, k = h.customFind, j = t(t({}, s.customLabels), c.customLabels), P = s.limit;
    w && !isNaN(Number(c.limit)) && (P = parseInt(c.limit, 10) > 0 ? parseInt(c.limit, 10) : 0);
    var R = typeof f == "function", I = c.options, z, W, F, te = [], ee = j.docs, V = j.limit, T = j.nextPage, D = j.page, L = j.pagingCounter, M = j.prevPage, N = j.totalDocs, Z = j.totalPages, Y = j.hasPrevPage, ie = j.hasNextPage, le = j.meta;
    Object.prototype.hasOwnProperty.call(c, "offset") ? (z = parseInt(c.offset, 10), F = z) : Object.prototype.hasOwnProperty.call(c, "page") ? (W = parseInt(c.page, 10) > 0 ? parseInt(c.page, 10) : 1, F = (W - 1) * P) : (z = 0, W = 1, F = z), w || (W = 1);
    var de;
    if (w && (O === !0 ? Object.keys(y).length > 0 ? de = this.countDocuments(u, I).collation(y).exec() : de = this.countDocuments(u).exec() : A === !0 ? de = this.estimatedDocumentCount().exec() : typeof E == "function" ? de = E() : Object.keys(y).length > 0 ? de = this.countDocuments(u, I).collation(y).exec() : de = this.countDocuments(u).exec()), P) {
      var ae = this[k](u, m, I);
      v && ae.populate(v), ae.select(_), ae.sort(b), p && (d ? ae.lean({
        virtuals: d
      }) : ae.lean(p)), g && g.pref && ae.read(g.pref, g.tags), Object.keys(y).length > 0 && ae.collation(y), w && (ae.skip(F), ae.limit(P));
      try {
        $ === !0 && ae.allowDiskUse();
      } catch {
        console.error("Your MongoDB version does not support `allowDiskUse`.");
      }
      te = ae.exec(), p && l && (te = te.then(function(ne) {
        return ne.forEach(function(he) {
          he._id && (he.id = String(he._id));
        }), ne;
      }));
    }
    return Promise.all([de, te]).then(function(ne) {
      var he = ne[0], x = ne[1];
      w !== !0 && (he = x.length);
      var U = {
        [N]: he
      }, B = {};
      typeof z < "u" && (U.offset = z, W = Math.ceil((z + 1) / P));
      var J = P > 0 ? Math.ceil(he / P) || 1 : null;
      return U[V] = he, U[Z] = 1, U[D] = W, U[L] = (W - 1) * P + 1, U[Y] = !1, U[ie] = !1, U[M] = null, U[T] = null, w && (U[V] = P, U[Z] = J, W > 1 ? (U[Y] = !0, U[M] = W - 1) : W == 1 && typeof z < "u" && z !== 0 && (U[Y] = !0, U[M] = 1), W < J && (U[ie] = !0, U[T] = W + 1)), delete U.false, P == 0 && (U[V] = 0, U[Z] = 1, U[D] = 1, U[L] = 1, U[M] = null, U[T] = null, U[Y] = !1, U[ie] = !1), le ? B = {
        [ee]: x,
        [le]: U
      } : B = t({
        [ee]: x
      }, U), R ? f(null, B) : Promise.resolve(B);
    }).catch(function(ne) {
      return R ? f(ne) : Promise.reject(ne);
    });
  }
  return So.exports = function(u) {
    u.statics.paginate = a, u.statics.paginateSubDocs = n, u.query.paginate = o;
  }, So.exports.PaginationParameters = i, So.exports.paginateSubDocs = n, So.exports.paginate = a, So.exports;
}
var BR = LR();
const sq = /* @__PURE__ */ Bi(BR);
function Ge(e, t, r) {
  function i(a, u) {
    var c;
    Object.defineProperty(a, "_zod", {
      value: a._zod ?? {},
      enumerable: !1
    }), (c = a._zod).traits ?? (c.traits = /* @__PURE__ */ new Set()), a._zod.traits.add(e), t(a, u);
    for (const f in s.prototype)
      f in a || Object.defineProperty(a, f, { value: s.prototype[f].bind(a) });
    a._zod.constr = s, a._zod.def = u;
  }
  const n = r?.Parent ?? Object;
  class o extends n {
  }
  Object.defineProperty(o, "name", { value: e });
  function s(a) {
    var u;
    const c = r?.Parent ? new o() : this;
    i(c, a), (u = c._zod).deferred ?? (u.deferred = []);
    for (const f of c._zod.deferred)
      f();
    return c;
  }
  return Object.defineProperty(s, "init", { value: i }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => r?.Parent && a instanceof r.Parent ? !0 : a?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
class ko extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class MA extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const FA = {};
function Ri(e) {
  return FA;
}
function qR(e) {
  const t = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e).filter(([i, n]) => t.indexOf(+i) === -1).map(([i, n]) => n);
}
function wp(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function zy(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function Uy(e) {
  return e == null;
}
function My(e) {
  const t = e.startsWith("^") ? 1 : 0, r = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, r);
}
function ZR(e, t) {
  const r = (e.toString().split(".")[1] || "").length, i = t.toString();
  let n = (i.split(".")[1] || "").length;
  if (n === 0 && /\d?e-\d?/.test(i)) {
    const u = i.match(/\d?e-(\d?)/);
    u?.[1] && (n = Number.parseInt(u[1]));
  }
  const o = r > n ? r : n, s = Number.parseInt(e.toFixed(o).replace(".", "")), a = Number.parseInt(t.toFixed(o).replace(".", ""));
  return s % a / 10 ** o;
}
const Mv = Symbol("evaluating");
function pr(e, t, r) {
  let i;
  Object.defineProperty(e, t, {
    get() {
      if (i !== Mv)
        return i === void 0 && (i = Mv, i = r()), i;
    },
    set(n) {
      Object.defineProperty(e, t, {
        value: n
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function go(e, t, r) {
  Object.defineProperty(e, t, {
    value: r,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function vo(...e) {
  const t = {};
  for (const r of e) {
    const i = Object.getOwnPropertyDescriptors(r);
    Object.assign(t, i);
  }
  return Object.defineProperties({}, t);
}
function Fv(e) {
  return JSON.stringify(e);
}
const LA = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function lu(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const VR = zy(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function Bo(e) {
  if (lu(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(lu(r) === !1 || Object.prototype.hasOwnProperty.call(r, "isPrototypeOf") === !1);
}
function BA(e) {
  return Bo(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const WR = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function Qu(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Zi(e, t, r) {
  const i = new e._zod.constr(t ?? e._zod.def);
  return (!t || r?.parent) && (i._zod.parent = e), i;
}
function bt(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function GR(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const KR = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function HR(e, t) {
  const r = e._zod.def, i = vo(e._zod.def, {
    get shape() {
      const n = {};
      for (const o in t) {
        if (!(o in r.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && (n[o] = r.shape[o]);
      }
      return go(this, "shape", n), n;
    },
    checks: []
  });
  return Zi(e, i);
}
function JR(e, t) {
  const r = e._zod.def, i = vo(e._zod.def, {
    get shape() {
      const n = { ...e._zod.def.shape };
      for (const o in t) {
        if (!(o in r.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && delete n[o];
      }
      return go(this, "shape", n), n;
    },
    checks: []
  });
  return Zi(e, i);
}
function YR(e, t) {
  if (!Bo(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const r = e._zod.def.checks;
  if (r && r.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const n = vo(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return go(this, "shape", o), o;
    },
    checks: []
  });
  return Zi(e, n);
}
function XR(e, t) {
  if (!Bo(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const r = {
    ...e._zod.def,
    get shape() {
      const i = { ...e._zod.def.shape, ...t };
      return go(this, "shape", i), i;
    },
    checks: e._zod.def.checks
  };
  return Zi(e, r);
}
function QR(e, t) {
  const r = vo(e._zod.def, {
    get shape() {
      const i = { ...e._zod.def.shape, ...t._zod.def.shape };
      return go(this, "shape", i), i;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Zi(e, r);
}
function eD(e, t, r) {
  const i = vo(t._zod.def, {
    get shape() {
      const n = t._zod.def.shape, o = { ...n };
      if (r)
        for (const s in r) {
          if (!(s in n))
            throw new Error(`Unrecognized key: "${s}"`);
          r[s] && (o[s] = e ? new e({
            type: "optional",
            innerType: n[s]
          }) : n[s]);
        }
      else
        for (const s in n)
          o[s] = e ? new e({
            type: "optional",
            innerType: n[s]
          }) : n[s];
      return go(this, "shape", o), o;
    },
    checks: []
  });
  return Zi(t, i);
}
function tD(e, t, r) {
  const i = vo(t._zod.def, {
    get shape() {
      const n = t._zod.def.shape, o = { ...n };
      if (r)
        for (const s in r) {
          if (!(s in o))
            throw new Error(`Unrecognized key: "${s}"`);
          r[s] && (o[s] = new e({
            type: "nonoptional",
            innerType: n[s]
          }));
        }
      else
        for (const s in n)
          o[s] = new e({
            type: "nonoptional",
            innerType: n[s]
          });
      return go(this, "shape", o), o;
    },
    checks: []
  });
  return Zi(t, i);
}
function xo(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let r = t; r < e.issues.length; r++)
    if (e.issues[r]?.continue !== !0)
      return !0;
  return !1;
}
function Ao(e, t) {
  return t.map((r) => {
    var i;
    return (i = r).path ?? (i.path = []), r.path.unshift(e), r;
  });
}
function Os(e) {
  return typeof e == "string" ? e : e?.message;
}
function Di(e, t, r) {
  const i = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const n = Os(e.inst?._zod.def?.error?.(e)) ?? Os(t?.error?.(e)) ?? Os(r.customError?.(e)) ?? Os(r.localeError?.(e)) ?? "Invalid input";
    i.message = n;
  }
  return delete i.inst, delete i.continue, t?.reportInput || delete i.input, i;
}
function Fy(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function Ra(...e) {
  const [t, r, i] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: r,
    inst: i
  } : { ...t };
}
const qA = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, wp, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, ZA = Ge("$ZodError", qA), VA = Ge("$ZodError", qA, { Parent: Error });
function rD(e, t = (r) => r.message) {
  const r = {}, i = [];
  for (const n of e.issues)
    n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [], r[n.path[0]].push(t(n))) : i.push(t(n));
  return { formErrors: i, fieldErrors: r };
}
function nD(e, t = (r) => r.message) {
  const r = { _errors: [] }, i = (n) => {
    for (const o of n.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((s) => i({ issues: s }));
      else if (o.code === "invalid_key")
        i({ issues: o.issues });
      else if (o.code === "invalid_element")
        i({ issues: o.issues });
      else if (o.path.length === 0)
        r._errors.push(t(o));
      else {
        let s = r, a = 0;
        for (; a < o.path.length; ) {
          const u = o.path[a];
          a === o.path.length - 1 ? (s[u] = s[u] || { _errors: [] }, s[u]._errors.push(t(o))) : s[u] = s[u] || { _errors: [] }, s = s[u], a++;
        }
      }
  };
  return i(e), r;
}
const Ly = (e) => (t, r, i, n) => {
  const o = i ? Object.assign(i, { async: !1 }) : { async: !1 }, s = t._zod.run({ value: r, issues: [] }, o);
  if (s instanceof Promise)
    throw new ko();
  if (s.issues.length) {
    const a = new (n?.Err ?? e)(s.issues.map((u) => Di(u, o, Ri())));
    throw LA(a, n?.callee), a;
  }
  return s.value;
}, By = (e) => async (t, r, i, n) => {
  const o = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: r, issues: [] }, o);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new (n?.Err ?? e)(s.issues.map((u) => Di(u, o, Ri())));
    throw LA(a, n?.callee), a;
  }
  return s.value;
}, ec = (e) => (t, r, i) => {
  const n = i ? { ...i, async: !1 } : { async: !1 }, o = t._zod.run({ value: r, issues: [] }, n);
  if (o instanceof Promise)
    throw new ko();
  return o.issues.length ? {
    success: !1,
    error: new (e ?? ZA)(o.issues.map((s) => Di(s, n, Ri())))
  } : { success: !0, data: o.value };
}, iD = /* @__PURE__ */ ec(VA), tc = (e) => async (t, r, i) => {
  const n = i ? Object.assign(i, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: r, issues: [] }, n);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new e(o.issues.map((s) => Di(s, n, Ri())))
  } : { success: !0, data: o.value };
}, oD = /* @__PURE__ */ tc(VA), aD = (e) => (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return Ly(e)(t, r, n);
}, sD = (e) => (t, r, i) => Ly(e)(t, r, i), uD = (e) => async (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return By(e)(t, r, n);
}, cD = (e) => async (t, r, i) => By(e)(t, r, i), lD = (e) => (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return ec(e)(t, r, n);
}, fD = (e) => (t, r, i) => ec(e)(t, r, i), hD = (e) => async (t, r, i) => {
  const n = i ? Object.assign(i, { direction: "backward" }) : { direction: "backward" };
  return tc(e)(t, r, n);
}, pD = (e) => async (t, r, i) => tc(e)(t, r, i), dD = /^[cC][^\s-]{8,}$/, mD = /^[0-9a-z]+$/, yD = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, gD = /^[0-9a-vA-V]{20}$/, vD = /^[A-Za-z0-9]{27}$/, bD = /^[a-zA-Z0-9_-]{21}$/, _D = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, wD = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Lv = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, OD = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, $D = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function SD() {
  return new RegExp($D, "u");
}
const ED = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, xD = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, AD = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, jD = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, kD = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, WA = /^[A-Za-z0-9_-]*$/, PD = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, ID = /^\+(?:[0-9]){6,14}[0-9]$/, GA = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", TD = /* @__PURE__ */ new RegExp(`^${GA}$`);
function KA(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function ND(e) {
  return new RegExp(`^${KA(e)}$`);
}
function CD(e) {
  const t = KA({ precision: e.precision }), r = ["Z"];
  e.local && r.push(""), e.offset && r.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const i = `${t}(?:${r.join("|")})`;
  return new RegExp(`^${GA}T(?:${i})$`);
}
const RD = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, DD = /^-?\d+$/, zD = /^-?\d+(?:\.\d+)?/, UD = /^(?:true|false)$/i, MD = /^[^A-Z]*$/, FD = /^[^a-z]*$/, wn = /* @__PURE__ */ Ge("$ZodCheck", (e, t) => {
  var r;
  e._zod ?? (e._zod = {}), e._zod.def = t, (r = e._zod).onattach ?? (r.onattach = []);
}), HA = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, JA = /* @__PURE__ */ Ge("$ZodCheckLessThan", (e, t) => {
  wn.init(e, t);
  const r = HA[typeof t.value];
  e._zod.onattach.push((i) => {
    const n = i._zod.bag, o = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? n.maximum = t.value : n.exclusiveMaximum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value <= t.value : i.value < t.value) || i.issues.push({
      origin: r,
      code: "too_big",
      maximum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), YA = /* @__PURE__ */ Ge("$ZodCheckGreaterThan", (e, t) => {
  wn.init(e, t);
  const r = HA[typeof t.value];
  e._zod.onattach.push((i) => {
    const n = i._zod.bag, o = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? n.minimum = t.value : n.exclusiveMinimum = t.value);
  }), e._zod.check = (i) => {
    (t.inclusive ? i.value >= t.value : i.value > t.value) || i.issues.push({
      origin: r,
      code: "too_small",
      minimum: t.value,
      input: i.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), LD = /* @__PURE__ */ Ge("$ZodCheckMultipleOf", (e, t) => {
  wn.init(e, t), e._zod.onattach.push((r) => {
    var i;
    (i = r._zod.bag).multipleOf ?? (i.multipleOf = t.value);
  }), e._zod.check = (r) => {
    if (typeof r.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof r.value == "bigint" ? r.value % t.value === BigInt(0) : ZR(r.value, t.value) === 0) || r.issues.push({
      origin: typeof r.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), BD = /* @__PURE__ */ Ge("$ZodCheckNumberFormat", (e, t) => {
  wn.init(e, t), t.format = t.format || "float64";
  const r = t.format?.includes("int"), i = r ? "int" : "number", [n, o] = KR[t.format];
  e._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = t.format, a.minimum = n, a.maximum = o, r && (a.pattern = DD);
  }), e._zod.check = (s) => {
    const a = s.value;
    if (r) {
      if (!Number.isInteger(a)) {
        s.issues.push({
          expected: i,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: a,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(a)) {
        a > 0 ? s.issues.push({
          input: a,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        }) : s.issues.push({
          input: a,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: i,
          continue: !t.abort
        });
        return;
      }
    }
    a < n && s.issues.push({
      origin: "number",
      input: a,
      code: "too_small",
      minimum: n,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), a > o && s.issues.push({
      origin: "number",
      input: a,
      code: "too_big",
      maximum: o,
      inst: e
    });
  };
}), qD = /* @__PURE__ */ Ge("$ZodCheckMaxLength", (e, t) => {
  var r;
  wn.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !Uy(n) && n.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (i._zod.bag.maximum = t.maximum);
  }), e._zod.check = (i) => {
    const n = i.value;
    if (n.length <= t.maximum)
      return;
    const s = Fy(n);
    i.issues.push({
      origin: s,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), ZD = /* @__PURE__ */ Ge("$ZodCheckMinLength", (e, t) => {
  var r;
  wn.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !Uy(n) && n.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (i._zod.bag.minimum = t.minimum);
  }), e._zod.check = (i) => {
    const n = i.value;
    if (n.length >= t.minimum)
      return;
    const s = Fy(n);
    i.issues.push({
      origin: s,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), VD = /* @__PURE__ */ Ge("$ZodCheckLengthEquals", (e, t) => {
  var r;
  wn.init(e, t), (r = e._zod.def).when ?? (r.when = (i) => {
    const n = i.value;
    return !Uy(n) && n.length !== void 0;
  }), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.minimum = t.length, n.maximum = t.length, n.length = t.length;
  }), e._zod.check = (i) => {
    const n = i.value, o = n.length;
    if (o === t.length)
      return;
    const s = Fy(n), a = o > t.length;
    i.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), rc = /* @__PURE__ */ Ge("$ZodCheckStringFormat", (e, t) => {
  var r, i;
  wn.init(e, t), e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.format = t.format, t.pattern && (o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t.pattern));
  }), t.pattern ? (r = e._zod).check ?? (r.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: n.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (i = e._zod).check ?? (i.check = () => {
  });
}), WD = /* @__PURE__ */ Ge("$ZodCheckRegex", (e, t) => {
  rc.init(e, t), e._zod.check = (r) => {
    t.pattern.lastIndex = 0, !t.pattern.test(r.value) && r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: r.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), GD = /* @__PURE__ */ Ge("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = MD), rc.init(e, t);
}), KD = /* @__PURE__ */ Ge("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = FD), rc.init(e, t);
}), HD = /* @__PURE__ */ Ge("$ZodCheckIncludes", (e, t) => {
  wn.init(e, t);
  const r = Qu(t.includes), i = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${r}` : r);
  t.pattern = i, e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(i);
  }), e._zod.check = (n) => {
    n.value.includes(t.includes, t.position) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), JD = /* @__PURE__ */ Ge("$ZodCheckStartsWith", (e, t) => {
  wn.init(e, t);
  const r = new RegExp(`^${Qu(t.prefix)}.*`);
  t.pattern ?? (t.pattern = r), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.startsWith(t.prefix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), YD = /* @__PURE__ */ Ge("$ZodCheckEndsWith", (e, t) => {
  wn.init(e, t);
  const r = new RegExp(`.*${Qu(t.suffix)}$`);
  t.pattern ?? (t.pattern = r), e._zod.onattach.push((i) => {
    const n = i._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.endsWith(t.suffix) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), XD = /* @__PURE__ */ Ge("$ZodCheckOverwrite", (e, t) => {
  wn.init(e, t), e._zod.check = (r) => {
    r.value = t.tx(r.value);
  };
});
class QD {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const i = t.split(`
`).filter((s) => s), n = Math.min(...i.map((s) => s.length - s.trimStart().length)), o = i.map((s) => s.slice(n)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of o)
      this.content.push(s);
  }
  compile() {
    const t = Function, r = this?.args, n = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new t(...r, n.join(`
`));
  }
}
const ez = {
  major: 4,
  minor: 1,
  patch: 12
}, jr = /* @__PURE__ */ Ge("$ZodType", (e, t) => {
  var r;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = ez;
  const i = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && i.unshift(e);
  for (const n of i)
    for (const o of n._zod.onattach)
      o(e);
  if (i.length === 0)
    (r = e._zod).deferred ?? (r.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const n = (s, a, u) => {
      let c = xo(s), f;
      for (const h of a) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(s))
            continue;
        } else if (c)
          continue;
        const y = s.issues.length, p = h._zod.check(s);
        if (p instanceof Promise && u?.async === !1)
          throw new ko();
        if (f || p instanceof Promise)
          f = (f ?? Promise.resolve()).then(async () => {
            await p, s.issues.length !== y && (c || (c = xo(s, y)));
          });
        else {
          if (s.issues.length === y)
            continue;
          c || (c = xo(s, y));
        }
      }
      return f ? f.then(() => s) : s;
    }, o = (s, a, u) => {
      if (xo(s))
        return s.aborted = !0, s;
      const c = n(a, i, u);
      if (c instanceof Promise) {
        if (u.async === !1)
          throw new ko();
        return c.then((f) => e._zod.parse(f, u));
      }
      return e._zod.parse(c, u);
    };
    e._zod.run = (s, a) => {
      if (a.skipChecks)
        return e._zod.parse(s, a);
      if (a.direction === "backward") {
        const c = e._zod.parse({ value: s.value, issues: [] }, { ...a, skipChecks: !0 });
        return c instanceof Promise ? c.then((f) => o(f, s, a)) : o(c, s, a);
      }
      const u = e._zod.parse(s, a);
      if (u instanceof Promise) {
        if (a.async === !1)
          throw new ko();
        return u.then((c) => n(c, i, a));
      }
      return n(u, i, a);
    };
  }
  e["~standard"] = {
    validate: (n) => {
      try {
        const o = iD(e, n);
        return o.success ? { value: o.data } : { issues: o.error?.issues };
      } catch {
        return oD(e, n).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), qy = /* @__PURE__ */ Ge("$ZodString", (e, t) => {
  jr.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? RD(e._zod.bag), e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = String(r.value);
      } catch {
      }
    return typeof r.value == "string" || r.issues.push({
      expected: "string",
      code: "invalid_type",
      input: r.value,
      inst: e
    }), r;
  };
}), Er = /* @__PURE__ */ Ge("$ZodStringFormat", (e, t) => {
  rc.init(e, t), qy.init(e, t);
}), tz = /* @__PURE__ */ Ge("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = wD), Er.init(e, t);
}), rz = /* @__PURE__ */ Ge("$ZodUUID", (e, t) => {
  if (t.version) {
    const i = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (i === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = Lv(i));
  } else
    t.pattern ?? (t.pattern = Lv());
  Er.init(e, t);
}), nz = /* @__PURE__ */ Ge("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = OD), Er.init(e, t);
}), iz = /* @__PURE__ */ Ge("$ZodURL", (e, t) => {
  Er.init(e, t), e._zod.check = (r) => {
    try {
      const i = r.value.trim(), n = new URL(i);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(n.hostname) || r.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: PD.source,
        input: r.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(n.protocol.endsWith(":") ? n.protocol.slice(0, -1) : n.protocol) || r.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: r.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? r.value = n.href : r.value = i;
      return;
    } catch {
      r.issues.push({
        code: "invalid_format",
        format: "url",
        input: r.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), oz = /* @__PURE__ */ Ge("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = SD()), Er.init(e, t);
}), az = /* @__PURE__ */ Ge("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = bD), Er.init(e, t);
}), sz = /* @__PURE__ */ Ge("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = dD), Er.init(e, t);
}), uz = /* @__PURE__ */ Ge("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = mD), Er.init(e, t);
}), cz = /* @__PURE__ */ Ge("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = yD), Er.init(e, t);
}), lz = /* @__PURE__ */ Ge("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = gD), Er.init(e, t);
}), fz = /* @__PURE__ */ Ge("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = vD), Er.init(e, t);
}), hz = /* @__PURE__ */ Ge("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = CD(t)), Er.init(e, t);
}), pz = /* @__PURE__ */ Ge("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = TD), Er.init(e, t);
}), dz = /* @__PURE__ */ Ge("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = ND(t)), Er.init(e, t);
}), mz = /* @__PURE__ */ Ge("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = _D), Er.init(e, t);
}), yz = /* @__PURE__ */ Ge("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = ED), Er.init(e, t), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.format = "ipv4";
  });
}), gz = /* @__PURE__ */ Ge("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = xD), Er.init(e, t), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.format = "ipv6";
  }), e._zod.check = (r) => {
    try {
      new URL(`http://[${r.value}]`);
    } catch {
      r.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: r.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), vz = /* @__PURE__ */ Ge("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = AD), Er.init(e, t);
}), bz = /* @__PURE__ */ Ge("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = jD), Er.init(e, t), e._zod.check = (r) => {
    const i = r.value.split("/");
    try {
      if (i.length !== 2)
        throw new Error();
      const [n, o] = i;
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${n}]`);
    } catch {
      r.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: r.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function XA(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const _z = /* @__PURE__ */ Ge("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = kD), Er.init(e, t), e._zod.onattach.push((r) => {
    r._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (r) => {
    XA(r.value) || r.issues.push({
      code: "invalid_format",
      format: "base64",
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function wz(e) {
  if (!WA.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (i) => i === "-" ? "+" : "/"), r = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return XA(r);
}
const Oz = /* @__PURE__ */ Ge("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = WA), Er.init(e, t), e._zod.onattach.push((r) => {
    r._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (r) => {
    wz(r.value) || r.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), $z = /* @__PURE__ */ Ge("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = ID), Er.init(e, t);
});
function Sz(e, t = null) {
  try {
    const r = e.split(".");
    if (r.length !== 3)
      return !1;
    const [i] = r;
    if (!i)
      return !1;
    const n = JSON.parse(atob(i));
    return !("typ" in n && n?.typ !== "JWT" || !n.alg || t && (!("alg" in n) || n.alg !== t));
  } catch {
    return !1;
  }
}
const Ez = /* @__PURE__ */ Ge("$ZodJWT", (e, t) => {
  Er.init(e, t), e._zod.check = (r) => {
    Sz(r.value, t.alg) || r.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), QA = /* @__PURE__ */ Ge("$ZodNumber", (e, t) => {
  jr.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? zD, e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = Number(r.value);
      } catch {
      }
    const n = r.value;
    if (typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n))
      return r;
    const o = typeof n == "number" ? Number.isNaN(n) ? "NaN" : Number.isFinite(n) ? void 0 : "Infinity" : void 0;
    return r.issues.push({
      expected: "number",
      code: "invalid_type",
      input: n,
      inst: e,
      ...o ? { received: o } : {}
    }), r;
  };
}), xz = /* @__PURE__ */ Ge("$ZodNumber", (e, t) => {
  BD.init(e, t), QA.init(e, t);
}), Az = /* @__PURE__ */ Ge("$ZodBoolean", (e, t) => {
  jr.init(e, t), e._zod.pattern = UD, e._zod.parse = (r, i) => {
    if (t.coerce)
      try {
        r.value = !!r.value;
      } catch {
      }
    const n = r.value;
    return typeof n == "boolean" || r.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: n,
      inst: e
    }), r;
  };
}), jz = /* @__PURE__ */ Ge("$ZodAny", (e, t) => {
  jr.init(e, t), e._zod.parse = (r) => r;
}), kz = /* @__PURE__ */ Ge("$ZodUnknown", (e, t) => {
  jr.init(e, t), e._zod.parse = (r) => r;
}), Pz = /* @__PURE__ */ Ge("$ZodNever", (e, t) => {
  jr.init(e, t), e._zod.parse = (r, i) => (r.issues.push({
    expected: "never",
    code: "invalid_type",
    input: r.value,
    inst: e
  }), r);
});
function Bv(e, t, r) {
  e.issues.length && t.issues.push(...Ao(r, e.issues)), t.value[r] = e.value;
}
const Iz = /* @__PURE__ */ Ge("$ZodArray", (e, t) => {
  jr.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    if (!Array.isArray(n))
      return r.issues.push({
        expected: "array",
        code: "invalid_type",
        input: n,
        inst: e
      }), r;
    r.value = Array(n.length);
    const o = [];
    for (let s = 0; s < n.length; s++) {
      const a = n[s], u = t.element._zod.run({
        value: a,
        issues: []
      }, i);
      u instanceof Promise ? o.push(u.then((c) => Bv(c, r, s))) : Bv(u, r, s);
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
});
function fu(e, t, r, i) {
  e.issues.length && t.issues.push(...Ao(r, e.issues)), e.value === void 0 ? r in i && (t.value[r] = void 0) : t.value[r] = e.value;
}
function e2(e) {
  const t = Object.keys(e.shape);
  for (const i of t)
    if (!e.shape?.[i]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${i}": expected a Zod schema`);
  const r = GR(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(r)
  };
}
function t2(e, t, r, i, n, o) {
  const s = [], a = n.keySet, u = n.catchall._zod, c = u.def.type;
  for (const f of Object.keys(t)) {
    if (a.has(f))
      continue;
    if (c === "never") {
      s.push(f);
      continue;
    }
    const h = u.run({ value: t[f], issues: [] }, i);
    h instanceof Promise ? e.push(h.then((y) => fu(y, r, f, t))) : fu(h, r, f, t);
  }
  return s.length && r.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: t,
    inst: o
  }), e.length ? Promise.all(e).then(() => r) : r;
}
const Tz = /* @__PURE__ */ Ge("$ZodObject", (e, t) => {
  if (jr.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const a = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const u = { ...a };
        return Object.defineProperty(t, "shape", {
          value: u
        }), u;
      }
    });
  }
  const i = zy(() => e2(t));
  pr(e._zod, "propValues", () => {
    const a = t.shape, u = {};
    for (const c in a) {
      const f = a[c]._zod;
      if (f.values) {
        u[c] ?? (u[c] = /* @__PURE__ */ new Set());
        for (const h of f.values)
          u[c].add(h);
      }
    }
    return u;
  });
  const n = lu, o = t.catchall;
  let s;
  e._zod.parse = (a, u) => {
    s ?? (s = i.value);
    const c = a.value;
    if (!n(c))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: c,
        inst: e
      }), a;
    a.value = {};
    const f = [], h = s.shape;
    for (const y of s.keys) {
      const l = h[y]._zod.run({ value: c[y], issues: [] }, u);
      l instanceof Promise ? f.push(l.then((d) => fu(d, a, y, c))) : fu(l, a, y, c);
    }
    return o ? t2(f, c, a, u, i.value, e) : f.length ? Promise.all(f).then(() => a) : a;
  };
}), Nz = /* @__PURE__ */ Ge("$ZodObjectJIT", (e, t) => {
  Tz.init(e, t);
  const r = e._zod.parse, i = zy(() => e2(t)), n = (y) => {
    const p = new QD(["shape", "payload", "ctx"]), l = i.value, d = (_) => {
      const b = Fv(_);
      return `shape[${b}]._zod.run({ value: input[${b}], issues: [] }, ctx)`;
    };
    p.write("const input = payload.value;");
    const v = /* @__PURE__ */ Object.create(null);
    let m = 0;
    for (const _ of l.keys)
      v[_] = `key_${m++}`;
    p.write("const newResult = {};");
    for (const _ of l.keys) {
      const b = v[_], w = Fv(_);
      p.write(`const ${b} = ${d(_)};`), p.write(`
        if (${b}.issues.length) {
          payload.issues = payload.issues.concat(${b}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${w}, ...iss.path] : [${w}]
          })));
        }
        
        
        if (${b}.value === undefined) {
          if (${w} in input) {
            newResult[${w}] = undefined;
          }
        } else {
          newResult[${w}] = ${b}.value;
        }
        
      `);
    }
    p.write("payload.value = newResult;"), p.write("return payload;");
    const g = p.compile();
    return (_, b) => g(y, _, b);
  };
  let o;
  const s = lu, a = !FA.jitless, c = a && VR.value, f = t.catchall;
  let h;
  e._zod.parse = (y, p) => {
    h ?? (h = i.value);
    const l = y.value;
    return s(l) ? a && c && p?.async === !1 && p.jitless !== !0 ? (o || (o = n(t.shape)), y = o(y, p), f ? t2([], l, y, p, h, e) : y) : r(y, p) : (y.issues.push({
      expected: "object",
      code: "invalid_type",
      input: l,
      inst: e
    }), y);
  };
});
function qv(e, t, r, i) {
  for (const o of e)
    if (o.issues.length === 0)
      return t.value = o.value, t;
  const n = e.filter((o) => !xo(o));
  return n.length === 1 ? (t.value = n[0].value, n[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: r,
    errors: e.map((o) => o.issues.map((s) => Di(s, i, Ri())))
  }), t);
}
const Cz = /* @__PURE__ */ Ge("$ZodUnion", (e, t) => {
  jr.init(e, t), pr(e._zod, "optin", () => t.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), pr(e._zod, "optout", () => t.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), pr(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values))
      return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), pr(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      const n = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${n.map((o) => My(o.source)).join("|")})$`);
    }
  });
  const r = t.options.length === 1, i = t.options[0]._zod.run;
  e._zod.parse = (n, o) => {
    if (r)
      return i(n, o);
    let s = !1;
    const a = [];
    for (const u of t.options) {
      const c = u._zod.run({
        value: n.value,
        issues: []
      }, o);
      if (c instanceof Promise)
        a.push(c), s = !0;
      else {
        if (c.issues.length === 0)
          return c;
        a.push(c);
      }
    }
    return s ? Promise.all(a).then((u) => qv(u, n, e, o)) : qv(a, n, e, o);
  };
}), Rz = /* @__PURE__ */ Ge("$ZodIntersection", (e, t) => {
  jr.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value, o = t.left._zod.run({ value: n, issues: [] }, i), s = t.right._zod.run({ value: n, issues: [] }, i);
    return o instanceof Promise || s instanceof Promise ? Promise.all([o, s]).then(([u, c]) => Zv(r, u, c)) : Zv(r, o, s);
  };
});
function Op(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (Bo(e) && Bo(t)) {
    const r = Object.keys(t), i = Object.keys(e).filter((o) => r.indexOf(o) !== -1), n = { ...e, ...t };
    for (const o of i) {
      const s = Op(e[o], t[o]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...s.mergeErrorPath]
        };
      n[o] = s.data;
    }
    return { valid: !0, data: n };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const r = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = t[i], s = Op(n, o);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...s.mergeErrorPath]
        };
      r.push(s.data);
    }
    return { valid: !0, data: r };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Zv(e, t, r) {
  if (t.issues.length && e.issues.push(...t.issues), r.issues.length && e.issues.push(...r.issues), xo(e))
    return e;
  const i = Op(t.value, r.value);
  if (!i.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`);
  return e.value = i.data, e;
}
const Dz = /* @__PURE__ */ Ge("$ZodRecord", (e, t) => {
  jr.init(e, t), e._zod.parse = (r, i) => {
    const n = r.value;
    if (!Bo(n))
      return r.issues.push({
        expected: "record",
        code: "invalid_type",
        input: n,
        inst: e
      }), r;
    const o = [];
    if (t.keyType._zod.values) {
      const s = t.keyType._zod.values;
      r.value = {};
      for (const u of s)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          const c = t.valueType._zod.run({ value: n[u], issues: [] }, i);
          c instanceof Promise ? o.push(c.then((f) => {
            f.issues.length && r.issues.push(...Ao(u, f.issues)), r.value[u] = f.value;
          })) : (c.issues.length && r.issues.push(...Ao(u, c.issues)), r.value[u] = c.value);
        }
      let a;
      for (const u in n)
        s.has(u) || (a = a ?? [], a.push(u));
      a && a.length > 0 && r.issues.push({
        code: "unrecognized_keys",
        input: n,
        inst: e,
        keys: a
      });
    } else {
      r.value = {};
      for (const s of Reflect.ownKeys(n)) {
        if (s === "__proto__")
          continue;
        const a = t.keyType._zod.run({ value: s, issues: [] }, i);
        if (a instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (a.issues.length) {
          r.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: a.issues.map((c) => Di(c, i, Ri())),
            input: s,
            path: [s],
            inst: e
          }), r.value[a.value] = a.value;
          continue;
        }
        const u = t.valueType._zod.run({ value: n[s], issues: [] }, i);
        u instanceof Promise ? o.push(u.then((c) => {
          c.issues.length && r.issues.push(...Ao(s, c.issues)), r.value[a.value] = c.value;
        })) : (u.issues.length && r.issues.push(...Ao(s, u.issues)), r.value[a.value] = u.value);
      }
    }
    return o.length ? Promise.all(o).then(() => r) : r;
  };
}), zz = /* @__PURE__ */ Ge("$ZodEnum", (e, t) => {
  jr.init(e, t);
  const r = qR(t.entries), i = new Set(r);
  e._zod.values = i, e._zod.pattern = new RegExp(`^(${r.filter((n) => WR.has(typeof n)).map((n) => typeof n == "string" ? Qu(n) : n.toString()).join("|")})$`), e._zod.parse = (n, o) => {
    const s = n.value;
    return i.has(s) || n.issues.push({
      code: "invalid_value",
      values: r,
      input: s,
      inst: e
    }), n;
  };
}), Uz = /* @__PURE__ */ Ge("$ZodTransform", (e, t) => {
  jr.init(e, t), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      throw new MA(e.constructor.name);
    const n = t.transform(r.value, r);
    if (i.async)
      return (n instanceof Promise ? n : Promise.resolve(n)).then((s) => (r.value = s, r));
    if (n instanceof Promise)
      throw new ko();
    return r.value = n, r;
  };
});
function Vv(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const Mz = /* @__PURE__ */ Ge("$ZodOptional", (e, t) => {
  jr.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", pr(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), pr(e._zod, "pattern", () => {
    const r = t.innerType._zod.pattern;
    return r ? new RegExp(`^(${My(r.source)})?$`) : void 0;
  }), e._zod.parse = (r, i) => {
    if (t.innerType._zod.optin === "optional") {
      const n = t.innerType._zod.run(r, i);
      return n instanceof Promise ? n.then((o) => Vv(o, r.value)) : Vv(n, r.value);
    }
    return r.value === void 0 ? r : t.innerType._zod.run(r, i);
  };
}), Fz = /* @__PURE__ */ Ge("$ZodNullable", (e, t) => {
  jr.init(e, t), pr(e._zod, "optin", () => t.innerType._zod.optin), pr(e._zod, "optout", () => t.innerType._zod.optout), pr(e._zod, "pattern", () => {
    const r = t.innerType._zod.pattern;
    return r ? new RegExp(`^(${My(r.source)}|null)$`) : void 0;
  }), pr(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (r, i) => r.value === null ? r : t.innerType._zod.run(r, i);
}), Lz = /* @__PURE__ */ Ge("$ZodDefault", (e, t) => {
  jr.init(e, t), e._zod.optin = "optional", pr(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(r, i);
    if (r.value === void 0)
      return r.value = t.defaultValue, r;
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => Wv(o, t)) : Wv(n, t);
  };
});
function Wv(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Bz = /* @__PURE__ */ Ge("$ZodPrefault", (e, t) => {
  jr.init(e, t), e._zod.optin = "optional", pr(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (r, i) => (i.direction === "backward" || r.value === void 0 && (r.value = t.defaultValue), t.innerType._zod.run(r, i));
}), qz = /* @__PURE__ */ Ge("$ZodNonOptional", (e, t) => {
  jr.init(e, t), pr(e._zod, "values", () => {
    const r = t.innerType._zod.values;
    return r ? new Set([...r].filter((i) => i !== void 0)) : void 0;
  }), e._zod.parse = (r, i) => {
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => Gv(o, e)) : Gv(n, e);
  };
});
function Gv(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Zz = /* @__PURE__ */ Ge("$ZodCatch", (e, t) => {
  jr.init(e, t), pr(e._zod, "optin", () => t.innerType._zod.optin), pr(e._zod, "optout", () => t.innerType._zod.optout), pr(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(r, i);
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => (r.value = o.value, o.issues.length && (r.value = t.catchValue({
      ...r,
      error: {
        issues: o.issues.map((s) => Di(s, i, Ri()))
      },
      input: r.value
    }), r.issues = []), r)) : (r.value = n.value, n.issues.length && (r.value = t.catchValue({
      ...r,
      error: {
        issues: n.issues.map((o) => Di(o, i, Ri()))
      },
      input: r.value
    }), r.issues = []), r);
  };
}), Vz = /* @__PURE__ */ Ge("$ZodPipe", (e, t) => {
  jr.init(e, t), pr(e._zod, "values", () => t.in._zod.values), pr(e._zod, "optin", () => t.in._zod.optin), pr(e._zod, "optout", () => t.out._zod.optout), pr(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (r, i) => {
    if (i.direction === "backward") {
      const o = t.out._zod.run(r, i);
      return o instanceof Promise ? o.then((s) => $s(s, t.in, i)) : $s(o, t.in, i);
    }
    const n = t.in._zod.run(r, i);
    return n instanceof Promise ? n.then((o) => $s(o, t.out, i)) : $s(n, t.out, i);
  };
});
function $s(e, t, r) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, r);
}
const Wz = /* @__PURE__ */ Ge("$ZodReadonly", (e, t) => {
  jr.init(e, t), pr(e._zod, "propValues", () => t.innerType._zod.propValues), pr(e._zod, "values", () => t.innerType._zod.values), pr(e._zod, "optin", () => t.innerType._zod.optin), pr(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      return t.innerType._zod.run(r, i);
    const n = t.innerType._zod.run(r, i);
    return n instanceof Promise ? n.then(Kv) : Kv(n);
  };
});
function Kv(e) {
  return e.value = Object.freeze(e.value), e;
}
const Gz = /* @__PURE__ */ Ge("$ZodCustom", (e, t) => {
  wn.init(e, t), jr.init(e, t), e._zod.parse = (r, i) => r, e._zod.check = (r) => {
    const i = r.value, n = t.fn(i);
    if (n instanceof Promise)
      return n.then((o) => Hv(o, r, i, e));
    Hv(n, r, i, e);
  };
});
function Hv(e, t, r, i) {
  if (!e) {
    const n = {
      code: "custom",
      input: r,
      inst: i,
      // incorporates params.error into issue reporting
      path: [...i._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !i._zod.def.abort
      // params: inst._zod.def.params,
    };
    i._zod.def.params && (n.params = i._zod.def.params), t.issues.push(Ra(n));
  }
}
class Kz {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...r) {
    const i = r[0];
    if (this._map.set(t, i), i && typeof i == "object" && "id" in i) {
      if (this._idmap.has(i.id))
        throw new Error(`ID ${i.id} already exists in the registry`);
      this._idmap.set(i.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const r = this._map.get(t);
    return r && typeof r == "object" && "id" in r && this._idmap.delete(r.id), this._map.delete(t), this;
  }
  get(t) {
    const r = t._zod.parent;
    if (r) {
      const i = { ...this.get(r) ?? {} };
      delete i.id;
      const n = { ...i, ...this._map.get(t) };
      return Object.keys(n).length ? n : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function Hz() {
  return new Kz();
}
const Ss = /* @__PURE__ */ Hz();
function Jz(e, t) {
  return new e({
    type: "string",
    ...bt(t)
  });
}
function Yz(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function Jv(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function Xz(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function Qz(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...bt(t)
  });
}
function e8(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...bt(t)
  });
}
function t8(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...bt(t)
  });
}
function r8(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function n8(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function i8(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function o8(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function a8(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function s8(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function u8(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function c8(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function l8(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function f8(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function h8(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function p8(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function d8(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function m8(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function y8(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function g8(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...bt(t)
  });
}
function v8(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...bt(t)
  });
}
function b8(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...bt(t)
  });
}
function _8(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...bt(t)
  });
}
function w8(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...bt(t)
  });
}
function O8(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...bt(t)
  });
}
function $8(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...bt(t)
  });
}
function S8(e, t) {
  return new e({
    type: "boolean",
    ...bt(t)
  });
}
function E8(e) {
  return new e({
    type: "any"
  });
}
function x8(e) {
  return new e({
    type: "unknown"
  });
}
function A8(e, t) {
  return new e({
    type: "never",
    ...bt(t)
  });
}
function Yv(e, t) {
  return new JA({
    check: "less_than",
    ...bt(t),
    value: e,
    inclusive: !1
  });
}
function qc(e, t) {
  return new JA({
    check: "less_than",
    ...bt(t),
    value: e,
    inclusive: !0
  });
}
function Xv(e, t) {
  return new YA({
    check: "greater_than",
    ...bt(t),
    value: e,
    inclusive: !1
  });
}
function Zc(e, t) {
  return new YA({
    check: "greater_than",
    ...bt(t),
    value: e,
    inclusive: !0
  });
}
function Qv(e, t) {
  return new LD({
    check: "multiple_of",
    ...bt(t),
    value: e
  });
}
function r2(e, t) {
  return new qD({
    check: "max_length",
    ...bt(t),
    maximum: e
  });
}
function hu(e, t) {
  return new ZD({
    check: "min_length",
    ...bt(t),
    minimum: e
  });
}
function n2(e, t) {
  return new VD({
    check: "length_equals",
    ...bt(t),
    length: e
  });
}
function j8(e, t) {
  return new WD({
    check: "string_format",
    format: "regex",
    ...bt(t),
    pattern: e
  });
}
function k8(e) {
  return new GD({
    check: "string_format",
    format: "lowercase",
    ...bt(e)
  });
}
function P8(e) {
  return new KD({
    check: "string_format",
    format: "uppercase",
    ...bt(e)
  });
}
function I8(e, t) {
  return new HD({
    check: "string_format",
    format: "includes",
    ...bt(t),
    includes: e
  });
}
function T8(e, t) {
  return new JD({
    check: "string_format",
    format: "starts_with",
    ...bt(t),
    prefix: e
  });
}
function N8(e, t) {
  return new YD({
    check: "string_format",
    format: "ends_with",
    ...bt(t),
    suffix: e
  });
}
function ns(e) {
  return new XD({
    check: "overwrite",
    tx: e
  });
}
function C8(e) {
  return ns((t) => t.normalize(e));
}
function R8() {
  return ns((e) => e.trim());
}
function D8() {
  return ns((e) => e.toLowerCase());
}
function z8() {
  return ns((e) => e.toUpperCase());
}
function U8(e, t, r) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...bt(r)
  });
}
function M8(e, t, r) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...bt(r)
  });
}
function F8(e) {
  const t = L8((r) => (r.addIssue = (i) => {
    if (typeof i == "string")
      r.issues.push(Ra(i, r.value, t._zod.def));
    else {
      const n = i;
      n.fatal && (n.continue = !1), n.code ?? (n.code = "custom"), n.input ?? (n.input = r.value), n.inst ?? (n.inst = t), n.continue ?? (n.continue = !t._zod.def.abort), r.issues.push(Ra(n));
    }
  }, e(r.value, r)));
  return t;
}
function L8(e, t) {
  const r = new wn({
    check: "custom",
    ...bt(t)
  });
  return r._zod.check = e, r;
}
const B8 = /* @__PURE__ */ Ge("ZodISODateTime", (e, t) => {
  hz.init(e, t), kr.init(e, t);
});
function q8(e) {
  return v8(B8, e);
}
const Z8 = /* @__PURE__ */ Ge("ZodISODate", (e, t) => {
  pz.init(e, t), kr.init(e, t);
});
function V8(e) {
  return b8(Z8, e);
}
const W8 = /* @__PURE__ */ Ge("ZodISOTime", (e, t) => {
  dz.init(e, t), kr.init(e, t);
});
function G8(e) {
  return _8(W8, e);
}
const K8 = /* @__PURE__ */ Ge("ZodISODuration", (e, t) => {
  mz.init(e, t), kr.init(e, t);
});
function H8(e) {
  return w8(K8, e);
}
const J8 = (e, t) => {
  ZA.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (r) => nD(e, r)
      // enumerable: false,
    },
    flatten: {
      value: (r) => rD(e, r)
      // enumerable: false,
    },
    addIssue: {
      value: (r) => {
        e.issues.push(r), e.message = JSON.stringify(e.issues, wp, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (r) => {
        e.issues.push(...r), e.message = JSON.stringify(e.issues, wp, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Mn = Ge("ZodError", J8, {
  Parent: Error
}), Y8 = /* @__PURE__ */ Ly(Mn), X8 = /* @__PURE__ */ By(Mn), Q8 = /* @__PURE__ */ ec(Mn), e5 = /* @__PURE__ */ tc(Mn), t5 = /* @__PURE__ */ aD(Mn), r5 = /* @__PURE__ */ sD(Mn), n5 = /* @__PURE__ */ uD(Mn), i5 = /* @__PURE__ */ cD(Mn), o5 = /* @__PURE__ */ lD(Mn), a5 = /* @__PURE__ */ fD(Mn), s5 = /* @__PURE__ */ hD(Mn), u5 = /* @__PURE__ */ pD(Mn), Rr = /* @__PURE__ */ Ge("ZodType", (e, t) => (jr.init(e, t), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...r) => e.clone(vo(t, {
  checks: [
    ...t.checks ?? [],
    ...r.map((i) => typeof i == "function" ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } } : i)
  ]
})), e.clone = (r, i) => Zi(e, r, i), e.brand = () => e, e.register = ((r, i) => (r.add(e, i), e)), e.parse = (r, i) => Y8(e, r, i, { callee: e.parse }), e.safeParse = (r, i) => Q8(e, r, i), e.parseAsync = async (r, i) => X8(e, r, i, { callee: e.parseAsync }), e.safeParseAsync = async (r, i) => e5(e, r, i), e.spa = e.safeParseAsync, e.encode = (r, i) => t5(e, r, i), e.decode = (r, i) => r5(e, r, i), e.encodeAsync = async (r, i) => n5(e, r, i), e.decodeAsync = async (r, i) => i5(e, r, i), e.safeEncode = (r, i) => o5(e, r, i), e.safeDecode = (r, i) => a5(e, r, i), e.safeEncodeAsync = async (r, i) => s5(e, r, i), e.safeDecodeAsync = async (r, i) => u5(e, r, i), e.refine = (r, i) => e.check(rU(r, i)), e.superRefine = (r) => e.check(nU(r)), e.overwrite = (r) => e.check(ns(r)), e.optional = () => nb(e), e.nullable = () => ib(e), e.nullish = () => nb(ib(e)), e.nonoptional = (r) => H5(e, r), e.array = () => C5(e), e.or = (r) => z5([e, r]), e.and = (r) => M5(e, r), e.transform = (r) => ob(e, q5(r)), e.default = (r) => W5(e, r), e.prefault = (r) => K5(e, r), e.catch = (r) => Y5(e, r), e.pipe = (r) => ob(e, r), e.readonly = () => eU(e), e.describe = (r) => {
  const i = e.clone();
  return Ss.add(i, { description: r }), i;
}, Object.defineProperty(e, "description", {
  get() {
    return Ss.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...r) => {
  if (r.length === 0)
    return Ss.get(e);
  const i = e.clone();
  return Ss.add(i, r[0]), i;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), i2 = /* @__PURE__ */ Ge("_ZodString", (e, t) => {
  qy.init(e, t), Rr.init(e, t);
  const r = e._zod.bag;
  e.format = r.format ?? null, e.minLength = r.minimum ?? null, e.maxLength = r.maximum ?? null, e.regex = (...i) => e.check(j8(...i)), e.includes = (...i) => e.check(I8(...i)), e.startsWith = (...i) => e.check(T8(...i)), e.endsWith = (...i) => e.check(N8(...i)), e.min = (...i) => e.check(hu(...i)), e.max = (...i) => e.check(r2(...i)), e.length = (...i) => e.check(n2(...i)), e.nonempty = (...i) => e.check(hu(1, ...i)), e.lowercase = (i) => e.check(k8(i)), e.uppercase = (i) => e.check(P8(i)), e.trim = () => e.check(R8()), e.normalize = (...i) => e.check(C8(...i)), e.toLowerCase = () => e.check(D8()), e.toUpperCase = () => e.check(z8());
}), c5 = /* @__PURE__ */ Ge("ZodString", (e, t) => {
  qy.init(e, t), i2.init(e, t), e.email = (r) => e.check(Yz(l5, r)), e.url = (r) => e.check(r8(f5, r)), e.jwt = (r) => e.check(g8(x5, r)), e.emoji = (r) => e.check(n8(h5, r)), e.guid = (r) => e.check(Jv(eb, r)), e.uuid = (r) => e.check(Xz(Es, r)), e.uuidv4 = (r) => e.check(Qz(Es, r)), e.uuidv6 = (r) => e.check(e8(Es, r)), e.uuidv7 = (r) => e.check(t8(Es, r)), e.nanoid = (r) => e.check(i8(p5, r)), e.guid = (r) => e.check(Jv(eb, r)), e.cuid = (r) => e.check(o8(d5, r)), e.cuid2 = (r) => e.check(a8(m5, r)), e.ulid = (r) => e.check(s8(y5, r)), e.base64 = (r) => e.check(d8($5, r)), e.base64url = (r) => e.check(m8(S5, r)), e.xid = (r) => e.check(u8(g5, r)), e.ksuid = (r) => e.check(c8(v5, r)), e.ipv4 = (r) => e.check(l8(b5, r)), e.ipv6 = (r) => e.check(f8(_5, r)), e.cidrv4 = (r) => e.check(h8(w5, r)), e.cidrv6 = (r) => e.check(p8(O5, r)), e.e164 = (r) => e.check(y8(E5, r)), e.datetime = (r) => e.check(q8(r)), e.date = (r) => e.check(V8(r)), e.time = (r) => e.check(G8(r)), e.duration = (r) => e.check(H8(r));
});
function uq(e) {
  return Jz(c5, e);
}
const kr = /* @__PURE__ */ Ge("ZodStringFormat", (e, t) => {
  Er.init(e, t), i2.init(e, t);
}), l5 = /* @__PURE__ */ Ge("ZodEmail", (e, t) => {
  nz.init(e, t), kr.init(e, t);
}), eb = /* @__PURE__ */ Ge("ZodGUID", (e, t) => {
  tz.init(e, t), kr.init(e, t);
}), Es = /* @__PURE__ */ Ge("ZodUUID", (e, t) => {
  rz.init(e, t), kr.init(e, t);
}), f5 = /* @__PURE__ */ Ge("ZodURL", (e, t) => {
  iz.init(e, t), kr.init(e, t);
}), h5 = /* @__PURE__ */ Ge("ZodEmoji", (e, t) => {
  oz.init(e, t), kr.init(e, t);
}), p5 = /* @__PURE__ */ Ge("ZodNanoID", (e, t) => {
  az.init(e, t), kr.init(e, t);
}), d5 = /* @__PURE__ */ Ge("ZodCUID", (e, t) => {
  sz.init(e, t), kr.init(e, t);
}), m5 = /* @__PURE__ */ Ge("ZodCUID2", (e, t) => {
  uz.init(e, t), kr.init(e, t);
}), y5 = /* @__PURE__ */ Ge("ZodULID", (e, t) => {
  cz.init(e, t), kr.init(e, t);
}), g5 = /* @__PURE__ */ Ge("ZodXID", (e, t) => {
  lz.init(e, t), kr.init(e, t);
}), v5 = /* @__PURE__ */ Ge("ZodKSUID", (e, t) => {
  fz.init(e, t), kr.init(e, t);
}), b5 = /* @__PURE__ */ Ge("ZodIPv4", (e, t) => {
  yz.init(e, t), kr.init(e, t);
}), _5 = /* @__PURE__ */ Ge("ZodIPv6", (e, t) => {
  gz.init(e, t), kr.init(e, t);
}), w5 = /* @__PURE__ */ Ge("ZodCIDRv4", (e, t) => {
  vz.init(e, t), kr.init(e, t);
}), O5 = /* @__PURE__ */ Ge("ZodCIDRv6", (e, t) => {
  bz.init(e, t), kr.init(e, t);
}), $5 = /* @__PURE__ */ Ge("ZodBase64", (e, t) => {
  _z.init(e, t), kr.init(e, t);
}), S5 = /* @__PURE__ */ Ge("ZodBase64URL", (e, t) => {
  Oz.init(e, t), kr.init(e, t);
}), E5 = /* @__PURE__ */ Ge("ZodE164", (e, t) => {
  $z.init(e, t), kr.init(e, t);
}), x5 = /* @__PURE__ */ Ge("ZodJWT", (e, t) => {
  Ez.init(e, t), kr.init(e, t);
}), o2 = /* @__PURE__ */ Ge("ZodNumber", (e, t) => {
  QA.init(e, t), Rr.init(e, t), e.gt = (i, n) => e.check(Xv(i, n)), e.gte = (i, n) => e.check(Zc(i, n)), e.min = (i, n) => e.check(Zc(i, n)), e.lt = (i, n) => e.check(Yv(i, n)), e.lte = (i, n) => e.check(qc(i, n)), e.max = (i, n) => e.check(qc(i, n)), e.int = (i) => e.check(tb(i)), e.safe = (i) => e.check(tb(i)), e.positive = (i) => e.check(Xv(0, i)), e.nonnegative = (i) => e.check(Zc(0, i)), e.negative = (i) => e.check(Yv(0, i)), e.nonpositive = (i) => e.check(qc(0, i)), e.multipleOf = (i, n) => e.check(Qv(i, n)), e.step = (i, n) => e.check(Qv(i, n)), e.finite = () => e;
  const r = e._zod.bag;
  e.minValue = Math.max(r.minimum ?? Number.NEGATIVE_INFINITY, r.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(r.maximum ?? Number.POSITIVE_INFINITY, r.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (r.format ?? "").includes("int") || Number.isSafeInteger(r.multipleOf ?? 0.5), e.isFinite = !0, e.format = r.format ?? null;
});
function cq(e) {
  return O8(o2, e);
}
const A5 = /* @__PURE__ */ Ge("ZodNumberFormat", (e, t) => {
  xz.init(e, t), o2.init(e, t);
});
function tb(e) {
  return $8(A5, e);
}
const j5 = /* @__PURE__ */ Ge("ZodBoolean", (e, t) => {
  Az.init(e, t), Rr.init(e, t);
});
function lq(e) {
  return S8(j5, e);
}
const k5 = /* @__PURE__ */ Ge("ZodAny", (e, t) => {
  jz.init(e, t), Rr.init(e, t);
});
function fq() {
  return E8(k5);
}
const P5 = /* @__PURE__ */ Ge("ZodUnknown", (e, t) => {
  kz.init(e, t), Rr.init(e, t);
});
function rb() {
  return x8(P5);
}
const I5 = /* @__PURE__ */ Ge("ZodNever", (e, t) => {
  Pz.init(e, t), Rr.init(e, t);
});
function T5(e) {
  return A8(I5, e);
}
const N5 = /* @__PURE__ */ Ge("ZodArray", (e, t) => {
  Iz.init(e, t), Rr.init(e, t), e.element = t.element, e.min = (r, i) => e.check(hu(r, i)), e.nonempty = (r) => e.check(hu(1, r)), e.max = (r, i) => e.check(r2(r, i)), e.length = (r, i) => e.check(n2(r, i)), e.unwrap = () => e.element;
});
function C5(e, t) {
  return U8(N5, e, t);
}
const R5 = /* @__PURE__ */ Ge("ZodObject", (e, t) => {
  Nz.init(e, t), Rr.init(e, t), pr(e, "shape", () => t.shape), e.keyof = () => L5(Object.keys(e._zod.def.shape)), e.catchall = (r) => e.clone({ ...e._zod.def, catchall: r }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: rb() }), e.loose = () => e.clone({ ...e._zod.def, catchall: rb() }), e.strict = () => e.clone({ ...e._zod.def, catchall: T5() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (r) => YR(e, r), e.safeExtend = (r) => XR(e, r), e.merge = (r) => QR(e, r), e.pick = (r) => HR(e, r), e.omit = (r) => JR(e, r), e.partial = (...r) => eD(a2, e, r[0]), e.required = (...r) => tD(s2, e, r[0]);
});
function hq(e, t) {
  const r = {
    type: "object",
    shape: e ?? {},
    ...bt(t)
  };
  return new R5(r);
}
const D5 = /* @__PURE__ */ Ge("ZodUnion", (e, t) => {
  Cz.init(e, t), Rr.init(e, t), e.options = t.options;
});
function z5(e, t) {
  return new D5({
    type: "union",
    options: e,
    ...bt(t)
  });
}
const U5 = /* @__PURE__ */ Ge("ZodIntersection", (e, t) => {
  Rz.init(e, t), Rr.init(e, t);
});
function M5(e, t) {
  return new U5({
    type: "intersection",
    left: e,
    right: t
  });
}
const F5 = /* @__PURE__ */ Ge("ZodRecord", (e, t) => {
  Dz.init(e, t), Rr.init(e, t), e.keyType = t.keyType, e.valueType = t.valueType;
});
function pq(e, t, r) {
  return new F5({
    type: "record",
    keyType: e,
    valueType: t,
    ...bt(r)
  });
}
const $p = /* @__PURE__ */ Ge("ZodEnum", (e, t) => {
  zz.init(e, t), Rr.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const r = new Set(Object.keys(t.entries));
  e.extract = (i, n) => {
    const o = {};
    for (const s of i)
      if (r.has(s))
        o[s] = t.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new $p({
      ...t,
      checks: [],
      ...bt(n),
      entries: o
    });
  }, e.exclude = (i, n) => {
    const o = { ...t.entries };
    for (const s of i)
      if (r.has(s))
        delete o[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new $p({
      ...t,
      checks: [],
      ...bt(n),
      entries: o
    });
  };
});
function L5(e, t) {
  const r = Array.isArray(e) ? Object.fromEntries(e.map((i) => [i, i])) : e;
  return new $p({
    type: "enum",
    entries: r,
    ...bt(t)
  });
}
const B5 = /* @__PURE__ */ Ge("ZodTransform", (e, t) => {
  Uz.init(e, t), Rr.init(e, t), e._zod.parse = (r, i) => {
    if (i.direction === "backward")
      throw new MA(e.constructor.name);
    r.addIssue = (o) => {
      if (typeof o == "string")
        r.issues.push(Ra(o, r.value, t));
      else {
        const s = o;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = r.value), s.inst ?? (s.inst = e), r.issues.push(Ra(s));
      }
    };
    const n = t.transform(r.value, r);
    return n instanceof Promise ? n.then((o) => (r.value = o, r)) : (r.value = n, r);
  };
});
function q5(e) {
  return new B5({
    type: "transform",
    transform: e
  });
}
const a2 = /* @__PURE__ */ Ge("ZodOptional", (e, t) => {
  Mz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function nb(e) {
  return new a2({
    type: "optional",
    innerType: e
  });
}
const Z5 = /* @__PURE__ */ Ge("ZodNullable", (e, t) => {
  Fz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function ib(e) {
  return new Z5({
    type: "nullable",
    innerType: e
  });
}
const V5 = /* @__PURE__ */ Ge("ZodDefault", (e, t) => {
  Lz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function W5(e, t) {
  return new V5({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : BA(t);
    }
  });
}
const G5 = /* @__PURE__ */ Ge("ZodPrefault", (e, t) => {
  Bz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function K5(e, t) {
  return new G5({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : BA(t);
    }
  });
}
const s2 = /* @__PURE__ */ Ge("ZodNonOptional", (e, t) => {
  qz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function H5(e, t) {
  return new s2({
    type: "nonoptional",
    innerType: e,
    ...bt(t)
  });
}
const J5 = /* @__PURE__ */ Ge("ZodCatch", (e, t) => {
  Zz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Y5(e, t) {
  return new J5({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const X5 = /* @__PURE__ */ Ge("ZodPipe", (e, t) => {
  Vz.init(e, t), Rr.init(e, t), e.in = t.in, e.out = t.out;
});
function ob(e, t) {
  return new X5({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const Q5 = /* @__PURE__ */ Ge("ZodReadonly", (e, t) => {
  Wz.init(e, t), Rr.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function eU(e) {
  return new Q5({
    type: "readonly",
    innerType: e
  });
}
const tU = /* @__PURE__ */ Ge("ZodCustom", (e, t) => {
  Gz.init(e, t), Rr.init(e, t);
});
function rU(e, t = {}) {
  return M8(tU, e, t);
}
function nU(e) {
  return F8(e);
}
/*!
* Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
* License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
* Copyright 2024 Fonticons, Inc.
*/
function iU(e, t, r) {
  return (t = aU(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function ab(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function nt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ab(Object(r), !0).forEach(function(i) {
      iU(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ab(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function oU(e, t) {
  if (typeof e != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function aU(e) {
  var t = oU(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
const sb = () => {
};
let Zy = {}, u2 = {}, c2 = null, l2 = {
  mark: sb,
  measure: sb
};
try {
  typeof window < "u" && (Zy = window), typeof document < "u" && (u2 = document), typeof MutationObserver < "u" && (c2 = MutationObserver), typeof performance < "u" && (l2 = performance);
} catch {
}
const {
  userAgent: ub = ""
} = Zy.navigator || {}, zi = Zy, br = u2, cb = c2, xs = l2;
zi.document;
const $i = !!br.documentElement && !!br.head && typeof br.addEventListener == "function" && typeof br.createElement == "function", f2 = ~ub.indexOf("MSIE") || ~ub.indexOf("Trident/");
var sU = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, uU = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, h2 = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
}, cU = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, p2 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], un = "classic", nc = "duotone", lU = "sharp", fU = "sharp-duotone", d2 = [un, nc, lU, fU], hU = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, pU = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, dU = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]), mU = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
}, yU = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], lb = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, gU = ["kit"], vU = {
  kit: {
    "fa-kit": "fak"
  }
}, bU = ["fak", "fakd"], _U = {
  kit: {
    fak: "fa-kit"
  }
}, fb = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, As = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, wU = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], OU = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], $U = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, SU = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
}, EU = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
}, Sp = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
}, xU = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], Ep = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...wU, ...xU], AU = ["solid", "regular", "light", "thin", "duotone", "brands"], m2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], jU = m2.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), kU = [...Object.keys(EU), ...AU, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", As.GROUP, As.SWAP_OPACITY, As.PRIMARY, As.SECONDARY].concat(m2.map((e) => "".concat(e, "x"))).concat(jU.map((e) => "w-".concat(e))), PU = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
const vi = "___FONT_AWESOME___", xp = 16, y2 = "fa", g2 = "svg-inline--fa", so = "data-fa-i2svg", Ap = "data-fa-pseudo-element", IU = "data-fa-pseudo-element-pending", Vy = "data-prefix", Wy = "data-icon", hb = "fontawesome-i2svg", TU = "async", NU = ["HTML", "HEAD", "STYLE", "SCRIPT"], v2 = (() => {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function is(e) {
  return new Proxy(e, {
    get(t, r) {
      return r in t ? t[r] : t[un];
    }
  });
}
const b2 = nt({}, h2);
b2[un] = nt(nt(nt(nt({}, {
  "fa-duotone": "duotone"
}), h2[un]), lb.kit), lb["kit-duotone"]);
const CU = is(b2), jp = nt({}, mU);
jp[un] = nt(nt(nt(nt({}, {
  duotone: "fad"
}), jp[un]), fb.kit), fb["kit-duotone"]);
const pb = is(jp), kp = nt({}, Sp);
kp[un] = nt(nt({}, kp[un]), _U.kit);
const Gy = is(kp), Pp = nt({}, SU);
Pp[un] = nt(nt({}, Pp[un]), vU.kit);
is(Pp);
const RU = sU, _2 = "fa-layers-text", DU = uU, zU = nt({}, hU);
is(zU);
const UU = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], Vc = cU, MU = [...gU, ...kU], Aa = zi.FontAwesomeConfig || {};
function FU(e) {
  var t = br.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function LU(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
br && typeof br.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((t) => {
  let [r, i] = t;
  const n = LU(FU(r));
  n != null && (Aa[i] = n);
});
const w2 = {
  styleDefault: "solid",
  familyDefault: un,
  cssPrefix: y2,
  replacementClass: g2,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Aa.familyPrefix && (Aa.cssPrefix = Aa.familyPrefix);
const qo = nt(nt({}, w2), Aa);
qo.autoReplaceSvg || (qo.observeMutations = !1);
const vt = {};
Object.keys(w2).forEach((e) => {
  Object.defineProperty(vt, e, {
    enumerable: !0,
    set: function(t) {
      qo[e] = t, ja.forEach((r) => r(vt));
    },
    get: function() {
      return qo[e];
    }
  });
});
Object.defineProperty(vt, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    qo.cssPrefix = e, ja.forEach((t) => t(vt));
  },
  get: function() {
    return qo.cssPrefix;
  }
});
zi.FontAwesomeConfig = vt;
const ja = [];
function BU(e) {
  return ja.push(e), () => {
    ja.splice(ja.indexOf(e), 1);
  };
}
const Ai = xp, ii = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function qU(e) {
  if (!e || !$i)
    return;
  const t = br.createElement("style");
  t.setAttribute("type", "text/css"), t.innerHTML = e;
  const r = br.head.childNodes;
  let i = null;
  for (let n = r.length - 1; n > -1; n--) {
    const o = r[n], s = (o.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(s) > -1 && (i = o);
  }
  return br.head.insertBefore(t, i), e;
}
const ZU = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function Da() {
  let e = 12, t = "";
  for (; e-- > 0; )
    t += ZU[Math.random() * 62 | 0];
  return t;
}
function Yo(e) {
  const t = [];
  for (let r = (e || []).length >>> 0; r--; )
    t[r] = e[r];
  return t;
}
function Ky(e) {
  return e.classList ? Yo(e.classList) : (e.getAttribute("class") || "").split(" ").filter((t) => t);
}
function O2(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function VU(e) {
  return Object.keys(e || {}).reduce((t, r) => t + "".concat(r, '="').concat(O2(e[r]), '" '), "").trim();
}
function ic(e) {
  return Object.keys(e || {}).reduce((t, r) => t + "".concat(r, ": ").concat(e[r].trim(), ";"), "");
}
function Hy(e) {
  return e.size !== ii.size || e.x !== ii.x || e.y !== ii.y || e.rotate !== ii.rotate || e.flipX || e.flipY;
}
function WU(e) {
  let {
    transform: t,
    containerWidth: r,
    iconWidth: i
  } = e;
  const n = {
    transform: "translate(".concat(r / 2, " 256)")
  }, o = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), s = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), a = "rotate(".concat(t.rotate, " 0 0)"), u = {
    transform: "".concat(o, " ").concat(s, " ").concat(a)
  }, c = {
    transform: "translate(".concat(i / 2 * -1, " -256)")
  };
  return {
    outer: n,
    inner: u,
    path: c
  };
}
function GU(e) {
  let {
    transform: t,
    width: r = xp,
    height: i = xp,
    startCentered: n = !1
  } = e, o = "";
  return n && f2 ? o += "translate(".concat(t.x / Ai - r / 2, "em, ").concat(t.y / Ai - i / 2, "em) ") : n ? o += "translate(calc(-50% + ".concat(t.x / Ai, "em), calc(-50% + ").concat(t.y / Ai, "em)) ") : o += "translate(".concat(t.x / Ai, "em, ").concat(t.y / Ai, "em) "), o += "scale(".concat(t.size / Ai * (t.flipX ? -1 : 1), ", ").concat(t.size / Ai * (t.flipY ? -1 : 1), ") "), o += "rotate(".concat(t.rotate, "deg) "), o;
}
var KU = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function $2() {
  const e = y2, t = g2, r = vt.cssPrefix, i = vt.replacementClass;
  let n = KU;
  if (r !== e || i !== t) {
    const o = new RegExp("\\.".concat(e, "\\-"), "g"), s = new RegExp("\\--".concat(e, "\\-"), "g"), a = new RegExp("\\.".concat(t), "g");
    n = n.replace(o, ".".concat(r, "-")).replace(s, "--".concat(r, "-")).replace(a, ".".concat(i));
  }
  return n;
}
let db = !1;
function Wc() {
  vt.autoAddCss && !db && (qU($2()), db = !0);
}
var HU = {
  mixout() {
    return {
      dom: {
        css: $2,
        insertCss: Wc
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        Wc();
      },
      beforeI2svg() {
        Wc();
      }
    };
  }
};
const bi = zi || {};
bi[vi] || (bi[vi] = {});
bi[vi].styles || (bi[vi].styles = {});
bi[vi].hooks || (bi[vi].hooks = {});
bi[vi].shims || (bi[vi].shims = []);
var oi = bi[vi];
const S2 = [], E2 = function() {
  br.removeEventListener("DOMContentLoaded", E2), pu = 1, S2.map((e) => e());
};
let pu = !1;
$i && (pu = (br.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(br.readyState), pu || br.addEventListener("DOMContentLoaded", E2));
function JU(e) {
  $i && (pu ? setTimeout(e, 0) : S2.push(e));
}
function os(e) {
  const {
    tag: t,
    attributes: r = {},
    children: i = []
  } = e;
  return typeof e == "string" ? O2(e) : "<".concat(t, " ").concat(VU(r), ">").concat(i.map(os).join(""), "</").concat(t, ">");
}
function mb(e, t, r) {
  if (e && e[t] && e[t][r])
    return {
      prefix: t,
      iconName: r,
      icon: e[t][r]
    };
}
var Gc = function(t, r, i, n) {
  var o = Object.keys(t), s = o.length, a = r, u, c, f;
  for (i === void 0 ? (u = 1, f = t[o[0]]) : (u = 0, f = i); u < s; u++)
    c = o[u], f = a(f, t[c], c, t);
  return f;
};
function YU(e) {
  const t = [];
  let r = 0;
  const i = e.length;
  for (; r < i; ) {
    const n = e.charCodeAt(r++);
    if (n >= 55296 && n <= 56319 && r < i) {
      const o = e.charCodeAt(r++);
      (o & 64512) == 56320 ? t.push(((n & 1023) << 10) + (o & 1023) + 65536) : (t.push(n), r--);
    } else
      t.push(n);
  }
  return t;
}
function Ip(e) {
  const t = YU(e);
  return t.length === 1 ? t[0].toString(16) : null;
}
function XU(e, t) {
  const r = e.length;
  let i = e.charCodeAt(t), n;
  return i >= 55296 && i <= 56319 && r > t + 1 && (n = e.charCodeAt(t + 1), n >= 56320 && n <= 57343) ? (i - 55296) * 1024 + n - 56320 + 65536 : i;
}
function yb(e) {
  return Object.keys(e).reduce((t, r) => {
    const i = e[r];
    return !!i.icon ? t[i.iconName] = i.icon : t[r] = i, t;
  }, {});
}
function Tp(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: i = !1
  } = r, n = yb(t);
  typeof oi.hooks.addPack == "function" && !i ? oi.hooks.addPack(e, yb(t)) : oi.styles[e] = nt(nt({}, oi.styles[e] || {}), n), e === "fas" && Tp("fa", t);
}
const {
  styles: za,
  shims: QU
} = oi, x2 = Object.keys(Gy), eM = x2.reduce((e, t) => (e[t] = Object.keys(Gy[t]), e), {});
let Jy = null, A2 = {}, j2 = {}, k2 = {}, P2 = {}, I2 = {};
function tM(e) {
  return ~MU.indexOf(e);
}
function rM(e, t) {
  const r = t.split("-"), i = r[0], n = r.slice(1).join("-");
  return i === e && n !== "" && !tM(n) ? n : null;
}
const T2 = () => {
  const e = (i) => Gc(za, (n, o, s) => (n[s] = Gc(o, i, {}), n), {});
  A2 = e((i, n, o) => (n[3] && (i[n[3]] = o), n[2] && n[2].filter((a) => typeof a == "number").forEach((a) => {
    i[a.toString(16)] = o;
  }), i)), j2 = e((i, n, o) => (i[o] = o, n[2] && n[2].filter((a) => typeof a == "string").forEach((a) => {
    i[a] = o;
  }), i)), I2 = e((i, n, o) => {
    const s = n[2];
    return i[o] = o, s.forEach((a) => {
      i[a] = o;
    }), i;
  });
  const t = "far" in za || vt.autoFetchSvg, r = Gc(QU, (i, n) => {
    const o = n[0];
    let s = n[1];
    const a = n[2];
    return s === "far" && !t && (s = "fas"), typeof o == "string" && (i.names[o] = {
      prefix: s,
      iconName: a
    }), typeof o == "number" && (i.unicodes[o.toString(16)] = {
      prefix: s,
      iconName: a
    }), i;
  }, {
    names: {},
    unicodes: {}
  });
  k2 = r.names, P2 = r.unicodes, Jy = oc(vt.styleDefault, {
    family: vt.familyDefault
  });
};
BU((e) => {
  Jy = oc(e.styleDefault, {
    family: vt.familyDefault
  });
});
T2();
function Yy(e, t) {
  return (A2[e] || {})[t];
}
function nM(e, t) {
  return (j2[e] || {})[t];
}
function Yi(e, t) {
  return (I2[e] || {})[t];
}
function N2(e) {
  return k2[e] || {
    prefix: null,
    iconName: null
  };
}
function iM(e) {
  const t = P2[e], r = Yy("fas", e);
  return t || (r ? {
    prefix: "fas",
    iconName: r
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Ui() {
  return Jy;
}
const C2 = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function oM(e) {
  let t = un;
  const r = x2.reduce((i, n) => (i[n] = "".concat(vt.cssPrefix, "-").concat(n), i), {});
  return d2.forEach((i) => {
    (e.includes(r[i]) || e.some((n) => eM[i].includes(n))) && (t = i);
  }), t;
}
function oc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: r = un
  } = t, i = CU[r][e];
  if (r === nc && !e)
    return "fad";
  const n = pb[r][e] || pb[r][i], o = e in oi.styles ? e : null;
  return n || o || null;
}
function aM(e) {
  let t = [], r = null;
  return e.forEach((i) => {
    const n = rM(vt.cssPrefix, i);
    n ? r = n : i && t.push(i);
  }), {
    iconName: r,
    rest: t
  };
}
function gb(e) {
  return e.sort().filter((t, r, i) => i.indexOf(t) === r);
}
function ac(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: r = !1
  } = t;
  let i = null;
  const n = Ep.concat(OU), o = gb(e.filter((h) => n.includes(h))), s = gb(e.filter((h) => !Ep.includes(h))), a = o.filter((h) => (i = h, !p2.includes(h))), [u = null] = a, c = oM(o), f = nt(nt({}, aM(s)), {}, {
    prefix: oc(u, {
      family: c
    })
  });
  return nt(nt(nt({}, f), lM({
    values: e,
    family: c,
    styles: za,
    config: vt,
    canonical: f,
    givenPrefix: i
  })), sM(r, i, f));
}
function sM(e, t, r) {
  let {
    prefix: i,
    iconName: n
  } = r;
  if (e || !i || !n)
    return {
      prefix: i,
      iconName: n
    };
  const o = t === "fa" ? N2(n) : {}, s = Yi(i, n);
  return n = o.iconName || s || n, i = o.prefix || i, i === "far" && !za.far && za.fas && !vt.autoFetchSvg && (i = "fas"), {
    prefix: i,
    iconName: n
  };
}
const uM = d2.filter((e) => e !== un || e !== nc), cM = Object.keys(Sp).filter((e) => e !== un).map((e) => Object.keys(Sp[e])).flat();
function lM(e) {
  const {
    values: t,
    family: r,
    canonical: i,
    givenPrefix: n = "",
    styles: o = {},
    config: s = {}
  } = e, a = r === nc, u = t.includes("fa-duotone") || t.includes("fad"), c = s.familyDefault === "duotone", f = i.prefix === "fad" || i.prefix === "fa-duotone";
  if (!a && (u || c || f) && (i.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (i.prefix = "fab"), !i.prefix && uM.includes(r) && (Object.keys(o).find((y) => cM.includes(y)) || s.autoFetchSvg)) {
    const y = dU.get(r).defaultShortPrefixId;
    i.prefix = y, i.iconName = Yi(i.prefix, i.iconName) || i.iconName;
  }
  return (i.prefix === "fa" || n === "fa") && (i.prefix = Ui() || "fas"), i;
}
class fM {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
      r[i] = arguments[i];
    const n = r.reduce(this._pullDefinitions, {});
    Object.keys(n).forEach((o) => {
      this.definitions[o] = nt(nt({}, this.definitions[o] || {}), n[o]), Tp(o, n[o]);
      const s = Gy[un][o];
      s && Tp(s, n[o]), T2();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(t, r) {
    const i = r.prefix && r.iconName && r.icon ? {
      0: r
    } : r;
    return Object.keys(i).map((n) => {
      const {
        prefix: o,
        iconName: s,
        icon: a
      } = i[n], u = a[2];
      t[o] || (t[o] = {}), u.length > 0 && u.forEach((c) => {
        typeof c == "string" && (t[o][c] = a);
      }), t[o][s] = a;
    }), t;
  }
}
let vb = [], jo = {};
const Po = {}, hM = Object.keys(Po);
function pM(e, t) {
  let {
    mixoutsTo: r
  } = t;
  return vb = e, jo = {}, Object.keys(Po).forEach((i) => {
    hM.indexOf(i) === -1 && delete Po[i];
  }), vb.forEach((i) => {
    const n = i.mixout ? i.mixout() : {};
    if (Object.keys(n).forEach((o) => {
      typeof n[o] == "function" && (r[o] = n[o]), typeof n[o] == "object" && Object.keys(n[o]).forEach((s) => {
        r[o] || (r[o] = {}), r[o][s] = n[o][s];
      });
    }), i.hooks) {
      const o = i.hooks();
      Object.keys(o).forEach((s) => {
        jo[s] || (jo[s] = []), jo[s].push(o[s]);
      });
    }
    i.provides && i.provides(Po);
  }), r;
}
function Np(e, t) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), n = 2; n < r; n++)
    i[n - 2] = arguments[n];
  return (jo[e] || []).forEach((s) => {
    t = s.apply(null, [t, ...i]);
  }), t;
}
function uo(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    r[i - 1] = arguments[i];
  (jo[e] || []).forEach((o) => {
    o.apply(null, r);
  });
}
function Mi() {
  const e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return Po[e] ? Po[e].apply(null, t) : void 0;
}
function Cp(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  let {
    iconName: t
  } = e;
  const r = e.prefix || Ui();
  if (t)
    return t = Yi(r, t) || t, mb(R2.definitions, r, t) || mb(oi.styles, r, t);
}
const R2 = new fM(), dM = () => {
  vt.autoReplaceSvg = !1, vt.observeMutations = !1, uo("noAuto");
}, mM = {
  i2svg: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return $i ? (uo("beforeI2svg", e), Mi("pseudoElements2svg", e), Mi("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: t
    } = e;
    vt.autoReplaceSvg === !1 && (vt.autoReplaceSvg = !0), vt.observeMutations = !0, JU(() => {
      gM({
        autoReplaceSvgRoot: t
      }), uo("watch", e);
    });
  }
}, yM = {
  icon: (e) => {
    if (e === null)
      return null;
    if (typeof e == "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: Yi(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      const t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], r = oc(e[0]);
      return {
        prefix: r,
        iconName: Yi(r, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(vt.cssPrefix, "-")) > -1 || e.match(RU))) {
      const t = ac(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: t.prefix || Ui(),
        iconName: Yi(t.prefix, t.iconName) || t.iconName
      };
    }
    if (typeof e == "string") {
      const t = Ui();
      return {
        prefix: t,
        iconName: Yi(t, e) || e
      };
    }
  }
}, On = {
  noAuto: dM,
  config: vt,
  dom: mM,
  parse: yM,
  library: R2,
  findIconDefinition: Cp,
  toHtml: os
}, gM = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: t = br
  } = e;
  (Object.keys(oi.styles).length > 0 || vt.autoFetchSvg) && $i && vt.autoReplaceSvg && On.dom.i2svg({
    node: t
  });
};
function sc(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map((r) => os(r));
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (!$i) return;
      const r = br.createElement("div");
      return r.innerHTML = e.html, r.children;
    }
  }), e;
}
function vM(e) {
  let {
    children: t,
    main: r,
    mask: i,
    attributes: n,
    styles: o,
    transform: s
  } = e;
  if (Hy(s) && r.found && !i.found) {
    const {
      width: a,
      height: u
    } = r, c = {
      x: a / u / 2,
      y: 0.5
    };
    n.style = ic(nt(nt({}, o), {}, {
      "transform-origin": "".concat(c.x + s.x / 16, "em ").concat(c.y + s.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: n,
    children: t
  }];
}
function bM(e) {
  let {
    prefix: t,
    iconName: r,
    children: i,
    attributes: n,
    symbol: o
  } = e;
  const s = o === !0 ? "".concat(t, "-").concat(vt.cssPrefix, "-").concat(r) : o;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: nt(nt({}, n), {}, {
        id: s
      }),
      children: i
    }]
  }];
}
function Xy(e) {
  const {
    icons: {
      main: t,
      mask: r
    },
    prefix: i,
    iconName: n,
    transform: o,
    symbol: s,
    title: a,
    maskId: u,
    titleId: c,
    extra: f,
    watchable: h = !1
  } = e, {
    width: y,
    height: p
  } = r.found ? r : t, l = bU.includes(i), d = [vt.replacementClass, n ? "".concat(vt.cssPrefix, "-").concat(n) : ""].filter((w) => f.classes.indexOf(w) === -1).filter((w) => w !== "" || !!w).concat(f.classes).join(" ");
  let v = {
    children: [],
    attributes: nt(nt({}, f.attributes), {}, {
      "data-prefix": i,
      "data-icon": n,
      class: d,
      role: f.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(y, " ").concat(p)
    })
  };
  const m = l && !~f.classes.indexOf("fa-fw") ? {
    width: "".concat(y / p * 16 * 0.0625, "em")
  } : {};
  h && (v.attributes[so] = ""), a && (v.children.push({
    tag: "title",
    attributes: {
      id: v.attributes["aria-labelledby"] || "title-".concat(c || Da())
    },
    children: [a]
  }), delete v.attributes.title);
  const g = nt(nt({}, v), {}, {
    prefix: i,
    iconName: n,
    main: t,
    mask: r,
    maskId: u,
    transform: o,
    symbol: s,
    styles: nt(nt({}, m), f.styles)
  }), {
    children: _,
    attributes: b
  } = r.found && t.found ? Mi("generateAbstractMask", g) || {
    children: [],
    attributes: {}
  } : Mi("generateAbstractIcon", g) || {
    children: [],
    attributes: {}
  };
  return g.children = _, g.attributes = b, s ? bM(g) : vM(g);
}
function bb(e) {
  const {
    content: t,
    width: r,
    height: i,
    transform: n,
    title: o,
    extra: s,
    watchable: a = !1
  } = e, u = nt(nt(nt({}, s.attributes), o ? {
    title: o
  } : {}), {}, {
    class: s.classes.join(" ")
  });
  a && (u[so] = "");
  const c = nt({}, s.styles);
  Hy(n) && (c.transform = GU({
    transform: n,
    startCentered: !0,
    width: r,
    height: i
  }), c["-webkit-transform"] = c.transform);
  const f = ic(c);
  f.length > 0 && (u.style = f);
  const h = [];
  return h.push({
    tag: "span",
    attributes: u,
    children: [t]
  }), o && h.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [o]
  }), h;
}
function _M(e) {
  const {
    content: t,
    title: r,
    extra: i
  } = e, n = nt(nt(nt({}, i.attributes), r ? {
    title: r
  } : {}), {}, {
    class: i.classes.join(" ")
  }), o = ic(i.styles);
  o.length > 0 && (n.style = o);
  const s = [];
  return s.push({
    tag: "span",
    attributes: n,
    children: [t]
  }), r && s.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [r]
  }), s;
}
const {
  styles: Kc
} = oi;
function Rp(e) {
  const t = e[0], r = e[1], [i] = e.slice(4);
  let n = null;
  return Array.isArray(i) ? n = {
    tag: "g",
    attributes: {
      class: "".concat(vt.cssPrefix, "-").concat(Vc.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(vt.cssPrefix, "-").concat(Vc.SECONDARY),
        fill: "currentColor",
        d: i[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(vt.cssPrefix, "-").concat(Vc.PRIMARY),
        fill: "currentColor",
        d: i[1]
      }
    }]
  } : n = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: i
    }
  }, {
    found: !0,
    width: t,
    height: r,
    icon: n
  };
}
const wM = {
  found: !1,
  width: 512,
  height: 512
};
function OM(e, t) {
  !v2 && !vt.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function Dp(e, t) {
  let r = t;
  return t === "fa" && vt.styleDefault !== null && (t = Ui()), new Promise((i, n) => {
    if (r === "fa") {
      const o = N2(e) || {};
      e = o.iconName || e, t = o.prefix || t;
    }
    if (e && t && Kc[t] && Kc[t][e]) {
      const o = Kc[t][e];
      return i(Rp(o));
    }
    OM(e, t), i(nt(nt({}, wM), {}, {
      icon: vt.showMissingIcons && e ? Mi("missingIconAbstract") || {} : {}
    }));
  });
}
const _b = () => {
}, zp = vt.measurePerformance && xs && xs.mark && xs.measure ? xs : {
  mark: _b,
  measure: _b
}, Oa = 'FA "6.7.2"', $M = (e) => (zp.mark("".concat(Oa, " ").concat(e, " begins")), () => D2(e)), D2 = (e) => {
  zp.mark("".concat(Oa, " ").concat(e, " ends")), zp.measure("".concat(Oa, " ").concat(e), "".concat(Oa, " ").concat(e, " begins"), "".concat(Oa, " ").concat(e, " ends"));
};
var Qy = {
  begin: $M,
  end: D2
};
const Ds = () => {
};
function wb(e) {
  return typeof (e.getAttribute ? e.getAttribute(so) : null) == "string";
}
function SM(e) {
  const t = e.getAttribute ? e.getAttribute(Vy) : null, r = e.getAttribute ? e.getAttribute(Wy) : null;
  return t && r;
}
function EM(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(vt.replacementClass);
}
function xM() {
  return vt.autoReplaceSvg === !0 ? zs.replace : zs[vt.autoReplaceSvg] || zs.replace;
}
function AM(e) {
  return br.createElementNS("http://www.w3.org/2000/svg", e);
}
function jM(e) {
  return br.createElement(e);
}
function z2(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: r = e.tag === "svg" ? AM : jM
  } = t;
  if (typeof e == "string")
    return br.createTextNode(e);
  const i = r(e.tag);
  return Object.keys(e.attributes || []).forEach(function(o) {
    i.setAttribute(o, e.attributes[o]);
  }), (e.children || []).forEach(function(o) {
    i.appendChild(z2(o, {
      ceFn: r
    }));
  }), i;
}
function kM(e) {
  let t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
const zs = {
  replace: function(e) {
    const t = e[0];
    if (t.parentNode)
      if (e[1].forEach((r) => {
        t.parentNode.insertBefore(z2(r), t);
      }), t.getAttribute(so) === null && vt.keepOriginalSource) {
        let r = br.createComment(kM(t));
        t.parentNode.replaceChild(r, t);
      } else
        t.remove();
  },
  nest: function(e) {
    const t = e[0], r = e[1];
    if (~Ky(t).indexOf(vt.replacementClass))
      return zs.replace(e);
    const i = new RegExp("".concat(vt.cssPrefix, "-.*"));
    if (delete r[0].attributes.id, r[0].attributes.class) {
      const o = r[0].attributes.class.split(" ").reduce((s, a) => (a === vt.replacementClass || a.match(i) ? s.toSvg.push(a) : s.toNode.push(a), s), {
        toNode: [],
        toSvg: []
      });
      r[0].attributes.class = o.toSvg.join(" "), o.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", o.toNode.join(" "));
    }
    const n = r.map((o) => os(o)).join(`
`);
    t.setAttribute(so, ""), t.innerHTML = n;
  }
};
function Ob(e) {
  e();
}
function U2(e, t) {
  const r = typeof t == "function" ? t : Ds;
  if (e.length === 0)
    r();
  else {
    let i = Ob;
    vt.mutateApproach === TU && (i = zi.requestAnimationFrame || Ob), i(() => {
      const n = xM(), o = Qy.begin("mutate");
      e.map(n), o(), r();
    });
  }
}
let eg = !1;
function M2() {
  eg = !0;
}
function Up() {
  eg = !1;
}
let du = null;
function $b(e) {
  if (!cb || !vt.observeMutations)
    return;
  const {
    treeCallback: t = Ds,
    nodeCallback: r = Ds,
    pseudoElementsCallback: i = Ds,
    observeMutationsRoot: n = br
  } = e;
  du = new cb((o) => {
    if (eg) return;
    const s = Ui();
    Yo(o).forEach((a) => {
      if (a.type === "childList" && a.addedNodes.length > 0 && !wb(a.addedNodes[0]) && (vt.searchPseudoElements && i(a.target), t(a.target)), a.type === "attributes" && a.target.parentNode && vt.searchPseudoElements && i(a.target.parentNode), a.type === "attributes" && wb(a.target) && ~UU.indexOf(a.attributeName))
        if (a.attributeName === "class" && SM(a.target)) {
          const {
            prefix: u,
            iconName: c
          } = ac(Ky(a.target));
          a.target.setAttribute(Vy, u || s), c && a.target.setAttribute(Wy, c);
        } else EM(a.target) && r(a.target);
    });
  }), $i && du.observe(n, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function PM() {
  du && du.disconnect();
}
function IM(e) {
  const t = e.getAttribute("style");
  let r = [];
  return t && (r = t.split(";").reduce((i, n) => {
    const o = n.split(":"), s = o[0], a = o.slice(1);
    return s && a.length > 0 && (i[s] = a.join(":").trim()), i;
  }, {})), r;
}
function TM(e) {
  const t = e.getAttribute("data-prefix"), r = e.getAttribute("data-icon"), i = e.innerText !== void 0 ? e.innerText.trim() : "";
  let n = ac(Ky(e));
  return n.prefix || (n.prefix = Ui()), t && r && (n.prefix = t, n.iconName = r), n.iconName && n.prefix || (n.prefix && i.length > 0 && (n.iconName = nM(n.prefix, e.innerText) || Yy(n.prefix, Ip(e.innerText))), !n.iconName && vt.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (n.iconName = e.firstChild.data)), n;
}
function NM(e) {
  const t = Yo(e.attributes).reduce((n, o) => (n.name !== "class" && n.name !== "style" && (n[o.name] = o.value), n), {}), r = e.getAttribute("title"), i = e.getAttribute("data-fa-title-id");
  return vt.autoA11y && (r ? t["aria-labelledby"] = "".concat(vt.replacementClass, "-title-").concat(i || Da()) : (t["aria-hidden"] = "true", t.focusable = "false")), t;
}
function CM() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: ii,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function Sb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: r,
    prefix: i,
    rest: n
  } = TM(e), o = NM(e), s = Np("parseNodeAttributes", {}, e);
  let a = t.styleParser ? IM(e) : [];
  return nt({
    iconName: r,
    title: e.getAttribute("title"),
    titleId: e.getAttribute("data-fa-title-id"),
    prefix: i,
    transform: ii,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: n,
      styles: a,
      attributes: o
    }
  }, s);
}
const {
  styles: RM
} = oi;
function F2(e) {
  const t = vt.autoReplaceSvg === "nest" ? Sb(e, {
    styleParser: !1
  }) : Sb(e);
  return ~t.extra.classes.indexOf(_2) ? Mi("generateLayersText", e, t) : Mi("generateSvgReplacementMutation", e, t);
}
function DM() {
  return [...yU, ...Ep];
}
function Eb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!$i) return Promise.resolve();
  const r = br.documentElement.classList, i = (f) => r.add("".concat(hb, "-").concat(f)), n = (f) => r.remove("".concat(hb, "-").concat(f)), o = vt.autoFetchSvg ? DM() : p2.concat(Object.keys(RM));
  o.includes("fa") || o.push("fa");
  const s = [".".concat(_2, ":not([").concat(so, "])")].concat(o.map((f) => ".".concat(f, ":not([").concat(so, "])"))).join(", ");
  if (s.length === 0)
    return Promise.resolve();
  let a = [];
  try {
    a = Yo(e.querySelectorAll(s));
  } catch {
  }
  if (a.length > 0)
    i("pending"), n("complete");
  else
    return Promise.resolve();
  const u = Qy.begin("onTree"), c = a.reduce((f, h) => {
    try {
      const y = F2(h);
      y && f.push(y);
    } catch (y) {
      v2 || y.name === "MissingIcon" && console.error(y);
    }
    return f;
  }, []);
  return new Promise((f, h) => {
    Promise.all(c).then((y) => {
      U2(y, () => {
        i("active"), i("complete"), n("pending"), typeof t == "function" && t(), u(), f();
      });
    }).catch((y) => {
      u(), h(y);
    });
  });
}
function zM(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  F2(e).then((r) => {
    r && U2([r], t);
  });
}
function UM(e) {
  return function(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = (t || {}).icon ? t : Cp(t || {});
    let {
      mask: n
    } = r;
    return n && (n = (n || {}).icon ? n : Cp(n || {})), e(i, nt(nt({}, r), {}, {
      mask: n
    }));
  };
}
const MM = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: r = ii,
    symbol: i = !1,
    mask: n = null,
    maskId: o = null,
    title: s = null,
    titleId: a = null,
    classes: u = [],
    attributes: c = {},
    styles: f = {}
  } = t;
  if (!e) return;
  const {
    prefix: h,
    iconName: y,
    icon: p
  } = e;
  return sc(nt({
    type: "icon"
  }, e), () => (uo("beforeDOMElementCreation", {
    iconDefinition: e,
    params: t
  }), vt.autoA11y && (s ? c["aria-labelledby"] = "".concat(vt.replacementClass, "-title-").concat(a || Da()) : (c["aria-hidden"] = "true", c.focusable = "false")), Xy({
    icons: {
      main: Rp(p),
      mask: n ? Rp(n.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: h,
    iconName: y,
    transform: nt(nt({}, ii), r),
    symbol: i,
    title: s,
    maskId: o,
    titleId: a,
    extra: {
      attributes: c,
      styles: f,
      classes: u
    }
  })));
};
var FM = {
  mixout() {
    return {
      icon: UM(MM)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.treeCallback = Eb, e.nodeCallback = zM, e;
      }
    };
  },
  provides(e) {
    e.i2svg = function(t) {
      const {
        node: r = br,
        callback: i = () => {
        }
      } = t;
      return Eb(r, i);
    }, e.generateSvgReplacementMutation = function(t, r) {
      const {
        iconName: i,
        title: n,
        titleId: o,
        prefix: s,
        transform: a,
        symbol: u,
        mask: c,
        maskId: f,
        extra: h
      } = r;
      return new Promise((y, p) => {
        Promise.all([Dp(i, s), c.iconName ? Dp(c.iconName, c.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((l) => {
          let [d, v] = l;
          y([t, Xy({
            icons: {
              main: d,
              mask: v
            },
            prefix: s,
            iconName: i,
            transform: a,
            symbol: u,
            maskId: f,
            title: n,
            titleId: o,
            extra: h,
            watchable: !0
          })]);
        }).catch(p);
      });
    }, e.generateAbstractIcon = function(t) {
      let {
        children: r,
        attributes: i,
        main: n,
        transform: o,
        styles: s
      } = t;
      const a = ic(s);
      a.length > 0 && (i.style = a);
      let u;
      return Hy(o) && (u = Mi("generateAbstractTransformGrouping", {
        main: n,
        transform: o,
        containerWidth: n.width,
        iconWidth: n.width
      })), r.push(u || n.icon), {
        children: r,
        attributes: i
      };
    };
  }
}, LM = {
  mixout() {
    return {
      layer(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: r = []
        } = t;
        return sc({
          type: "layer"
        }, () => {
          uo("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          let i = [];
          return e((n) => {
            Array.isArray(n) ? n.map((o) => {
              i = i.concat(o.abstract);
            }) : i = i.concat(n.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(vt.cssPrefix, "-layers"), ...r].join(" ")
            },
            children: i
          }];
        });
      }
    };
  }
}, BM = {
  mixout() {
    return {
      counter(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: r = null,
          classes: i = [],
          attributes: n = {},
          styles: o = {}
        } = t;
        return sc({
          type: "counter",
          content: e
        }, () => (uo("beforeDOMElementCreation", {
          content: e,
          params: t
        }), _M({
          content: e.toString(),
          title: r,
          extra: {
            attributes: n,
            styles: o,
            classes: ["".concat(vt.cssPrefix, "-layers-counter"), ...i]
          }
        })));
      }
    };
  }
}, qM = {
  mixout() {
    return {
      text(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: r = ii,
          title: i = null,
          classes: n = [],
          attributes: o = {},
          styles: s = {}
        } = t;
        return sc({
          type: "text",
          content: e
        }, () => (uo("beforeDOMElementCreation", {
          content: e,
          params: t
        }), bb({
          content: e,
          transform: nt(nt({}, ii), r),
          title: i,
          extra: {
            attributes: o,
            styles: s,
            classes: ["".concat(vt.cssPrefix, "-layers-text"), ...n]
          }
        })));
      }
    };
  },
  provides(e) {
    e.generateLayersText = function(t, r) {
      const {
        title: i,
        transform: n,
        extra: o
      } = r;
      let s = null, a = null;
      if (f2) {
        const u = parseInt(getComputedStyle(t).fontSize, 10), c = t.getBoundingClientRect();
        s = c.width / u, a = c.height / u;
      }
      return vt.autoA11y && !i && (o.attributes["aria-hidden"] = "true"), Promise.resolve([t, bb({
        content: t.innerHTML,
        width: s,
        height: a,
        transform: n,
        title: i,
        extra: o,
        watchable: !0
      })]);
    };
  }
};
const ZM = new RegExp('"', "ug"), xb = [1105920, 1112319], Ab = nt(nt(nt(nt({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), pU), PU), $U), Mp = Object.keys(Ab).reduce((e, t) => (e[t.toLowerCase()] = Ab[t], e), {}), VM = Object.keys(Mp).reduce((e, t) => {
  const r = Mp[t];
  return e[t] = r[900] || [...Object.entries(r)][0][1], e;
}, {});
function WM(e) {
  const t = e.replace(ZM, ""), r = XU(t, 0), i = r >= xb[0] && r <= xb[1], n = t.length === 2 ? t[0] === t[1] : !1;
  return {
    value: Ip(n ? t[0] : t),
    isSecondary: i || n
  };
}
function GM(e, t) {
  const r = e.replace(/^['"]|['"]$/g, "").toLowerCase(), i = parseInt(t), n = isNaN(i) ? "normal" : i;
  return (Mp[r] || {})[n] || VM[r];
}
function jb(e, t) {
  const r = "".concat(IU).concat(t.replace(":", "-"));
  return new Promise((i, n) => {
    if (e.getAttribute(r) !== null)
      return i();
    const s = Yo(e.children).filter((y) => y.getAttribute(Ap) === t)[0], a = zi.getComputedStyle(e, t), u = a.getPropertyValue("font-family"), c = u.match(DU), f = a.getPropertyValue("font-weight"), h = a.getPropertyValue("content");
    if (s && !c)
      return e.removeChild(s), i();
    if (c && h !== "none" && h !== "") {
      const y = a.getPropertyValue("content");
      let p = GM(u, f);
      const {
        value: l,
        isSecondary: d
      } = WM(y), v = c[0].startsWith("FontAwesome");
      let m = Yy(p, l), g = m;
      if (v) {
        const _ = iM(l);
        _.iconName && _.prefix && (m = _.iconName, p = _.prefix);
      }
      if (m && !d && (!s || s.getAttribute(Vy) !== p || s.getAttribute(Wy) !== g)) {
        e.setAttribute(r, g), s && e.removeChild(s);
        const _ = CM(), {
          extra: b
        } = _;
        b.attributes[Ap] = t, Dp(m, p).then((w) => {
          const A = Xy(nt(nt({}, _), {}, {
            icons: {
              main: w,
              mask: C2()
            },
            prefix: p,
            iconName: g,
            extra: b,
            watchable: !0
          })), E = br.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(E, e.firstChild) : e.appendChild(E), E.outerHTML = A.map((O) => os(O)).join(`
`), e.removeAttribute(r), i();
        }).catch(n);
      } else
        i();
    } else
      i();
  });
}
function KM(e) {
  return Promise.all([jb(e, "::before"), jb(e, "::after")]);
}
function HM(e) {
  return e.parentNode !== document.head && !~NU.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(Ap) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
function kb(e) {
  if ($i)
    return new Promise((t, r) => {
      const i = Yo(e.querySelectorAll("*")).filter(HM).map(KM), n = Qy.begin("searchPseudoElements");
      M2(), Promise.all(i).then(() => {
        n(), Up(), t();
      }).catch(() => {
        n(), Up(), r();
      });
    });
}
var JM = {
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.pseudoElementsCallback = kb, e;
      }
    };
  },
  provides(e) {
    e.pseudoElements2svg = function(t) {
      const {
        node: r = br
      } = t;
      vt.searchPseudoElements && kb(r);
    };
  }
};
let Pb = !1;
var YM = {
  mixout() {
    return {
      dom: {
        unwatch() {
          M2(), Pb = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        $b(Np("mutationObserverCallbacks", {}));
      },
      noAuto() {
        PM();
      },
      watch(e) {
        const {
          observeMutationsRoot: t
        } = e;
        Pb ? Up() : $b(Np("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
};
const Ib = (e) => {
  let t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce((r, i) => {
    const n = i.toLowerCase().split("-"), o = n[0];
    let s = n.slice(1).join("-");
    if (o && s === "h")
      return r.flipX = !0, r;
    if (o && s === "v")
      return r.flipY = !0, r;
    if (s = parseFloat(s), isNaN(s))
      return r;
    switch (o) {
      case "grow":
        r.size = r.size + s;
        break;
      case "shrink":
        r.size = r.size - s;
        break;
      case "left":
        r.x = r.x - s;
        break;
      case "right":
        r.x = r.x + s;
        break;
      case "up":
        r.y = r.y - s;
        break;
      case "down":
        r.y = r.y + s;
        break;
      case "rotate":
        r.rotate = r.rotate + s;
        break;
    }
    return r;
  }, t);
};
var XM = {
  mixout() {
    return {
      parse: {
        transform: (e) => Ib(e)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const r = t.getAttribute("data-fa-transform");
        return r && (e.transform = Ib(r)), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractTransformGrouping = function(t) {
      let {
        main: r,
        transform: i,
        containerWidth: n,
        iconWidth: o
      } = t;
      const s = {
        transform: "translate(".concat(n / 2, " 256)")
      }, a = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "), u = "scale(".concat(i.size / 16 * (i.flipX ? -1 : 1), ", ").concat(i.size / 16 * (i.flipY ? -1 : 1), ") "), c = "rotate(".concat(i.rotate, " 0 0)"), f = {
        transform: "".concat(a, " ").concat(u, " ").concat(c)
      }, h = {
        transform: "translate(".concat(o / 2 * -1, " -256)")
      }, y = {
        outer: s,
        inner: f,
        path: h
      };
      return {
        tag: "g",
        attributes: nt({}, y.outer),
        children: [{
          tag: "g",
          attributes: nt({}, y.inner),
          children: [{
            tag: r.icon.tag,
            children: r.icon.children,
            attributes: nt(nt({}, r.icon.attributes), y.path)
          }]
        }]
      };
    };
  }
};
const Hc = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function Tb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function QM(e) {
  return e.tag === "g" ? e.children : [e];
}
var eF = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const r = t.getAttribute("data-fa-mask"), i = r ? ac(r.split(" ").map((n) => n.trim())) : C2();
        return i.prefix || (i.prefix = Ui()), e.mask = i, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractMask = function(t) {
      let {
        children: r,
        attributes: i,
        main: n,
        mask: o,
        maskId: s,
        transform: a
      } = t;
      const {
        width: u,
        icon: c
      } = n, {
        width: f,
        icon: h
      } = o, y = WU({
        transform: a,
        containerWidth: f,
        iconWidth: u
      }), p = {
        tag: "rect",
        attributes: nt(nt({}, Hc), {}, {
          fill: "white"
        })
      }, l = c.children ? {
        children: c.children.map(Tb)
      } : {}, d = {
        tag: "g",
        attributes: nt({}, y.inner),
        children: [Tb(nt({
          tag: c.tag,
          attributes: nt(nt({}, c.attributes), y.path)
        }, l))]
      }, v = {
        tag: "g",
        attributes: nt({}, y.outer),
        children: [d]
      }, m = "mask-".concat(s || Da()), g = "clip-".concat(s || Da()), _ = {
        tag: "mask",
        attributes: nt(nt({}, Hc), {}, {
          id: m,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [p, v]
      }, b = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: g
          },
          children: QM(h)
        }, _]
      };
      return r.push(b, {
        tag: "rect",
        attributes: nt({
          fill: "currentColor",
          "clip-path": "url(#".concat(g, ")"),
          mask: "url(#".concat(m, ")")
        }, Hc)
      }), {
        children: r,
        attributes: i
      };
    };
  }
}, tF = {
  provides(e) {
    let t = !1;
    zi.matchMedia && (t = zi.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      const r = [], i = {
        fill: "currentColor"
      }, n = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      r.push({
        tag: "path",
        attributes: nt(nt({}, i), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const o = nt(nt({}, n), {}, {
        attributeName: "opacity"
      }), s = {
        tag: "circle",
        attributes: nt(nt({}, i), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || s.children.push({
        tag: "animate",
        attributes: nt(nt({}, n), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: nt(nt({}, o), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), r.push(s), r.push({
        tag: "path",
        attributes: nt(nt({}, i), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: nt(nt({}, o), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || r.push({
        tag: "path",
        attributes: nt(nt({}, i), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: nt(nt({}, o), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: r
      };
    };
  }
}, rF = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const r = t.getAttribute("data-fa-symbol"), i = r === null ? !1 : r === "" ? !0 : r;
        return e.symbol = i, e;
      }
    };
  }
}, nF = [HU, FM, LM, BM, qM, JM, YM, XM, eF, tF, rF];
pM(nF, {
  mixoutsTo: On
});
On.noAuto;
On.config;
const iF = On.library;
On.dom;
const oF = On.parse;
On.findIconDefinition;
On.toHtml;
const aF = On.icon;
On.layer;
On.text;
On.counter;
const dq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, api: On, icon: aF, library: iF, parse: oF }, Symbol.toStringTag, { value: "Module" }));
/*!
* Font Awesome Pro 6.7.2 by @fontawesome - https://fontawesome.com
* License - https://fontawesome.com/license (Commercial License)
* Copyright 2024 Fonticons, Inc.
*/
const sF = {
  prefix: "fasr",
  iconName: "arrows-left-right",
  icon: [512, 512, ["arrows-h"], "f07e", "M493.8 273l17-17-17-17-96-96-17-17L346.9 160l17 17 55 55L93.1 232l55-55 17-17-33.9-33.9-17 17-96 96-17 17 17 17 96 96 17 17L165.1 352l-17-17-55-55 325.7 0-55 55-17 17 33.9 33.9 17-17 96-96z"]
}, uF = {
  prefix: "fasr",
  iconName: "plus-large",
  icon: [512, 512, [], "e59e", "M488 232l24 0 0 48-24 0-208 0 0 208 0 24-48 0 0-24 0-208L24 280 0 280l0-48 24 0 208 0 0-208 0-24 48 0 0 24 0 208 208 0z"]
}, cF = {
  prefix: "fasr",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M136 32l24 0 0 48-24 0L48 80l0 88 0 24L0 192l0-24L0 56 0 32l24 0 112 0zM0 344l0-24 48 0 0 24 0 88 88 0 24 0 0 48-24 0L24 480 0 480l0-24L0 344zM424 32l24 0 0 24 0 112 0 24-48 0 0-24 0-88-88 0-24 0 0-48 24 0 112 0zM400 344l0-24 48 0 0 24 0 112 0 24-24 0-112 0-24 0 0-48 24 0 88 0 0-88z"]
}, lF = {
  prefix: "fasr",
  iconName: "arrows-up-down",
  icon: [320, 512, ["arrows-v"], "f07d", "M177 18.2l-17-17-17 17-96 96-17 17L64 165.1l17-17 55-55 0 325.7-55-55-17-17L30.1 380.8l17 17 96 96 17 17 17-17 96-96 17-17L256 346.9l-17 17-55 55 0-325.7 55 55 17 17 33.9-33.9-17-17-96-96z"]
}, mq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, faArrowsLeftRight: sF, faArrowsUpDown: lF, faExpand: cF, faPlusLarge: uF }, Symbol.toStringTag, { value: "Module" }));
/*!
* Font Awesome Pro 6.7.2 by @fontawesome - https://fontawesome.com
* License - https://fontawesome.com/license (Commercial License)
* Copyright 2024 Fonticons, Inc.
*/
const fF = {
  prefix: "fass",
  iconName: "spray-can",
  icon: [512, 512, [], "f5bd", "M224 0l0 128L96 128 96 0 224 0zM0 256c0-53 43-96 96-96l128 0c53 0 96 43 96 96l0 256L0 512 0 256zm240 80A80 80 0 1 0 80 336a80 80 0 1 0 160 0zM256 64a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zM384 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm64 32a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm32 64a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM448 256a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zM384 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"]
}, hF = {
  prefix: "fass",
  iconName: "image",
  icon: [512, 512, [], "f03e", "M0 32l512 0 0 448L0 480 0 32zM323.5 202.1L304 174.7l-19.5 27.3L196.2 325.6l-26.3-29.6L152 275.9l-17.9 20.2-64 72L64 374.9l0 9.1 0 8 0 24 24 0 72 0 24 0 32 0 24 0 184 0 24 0 0-24 0-8 0-7.7-4.5-6.3-120-168zM112 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"]
}, pF = {
  prefix: "fass",
  iconName: "hammer-brush",
  icon: [640, 512, [], "e620", "M256 0L144 0C64.5 0 0 64.5 0 144l0 16 80-32 32 32 144 0 0-32 32 0 0 32 64 0L352 0 288 0l0 32-32 0 0-32zM96 512l128 0L208 192l-96 0L96 512zm320 0l32-96 32 96 160 0 0-192-288 0 0 192 64 0zM352 256l0 32 288 0 0-32-96-64L544 0 448 0l0 192-96 64zM496 64a16 16 0 1 1 0-32 16 16 0 1 1 0 32z"]
}, dF = {
  prefix: "fass",
  iconName: "files",
  icon: [448, 512, [], "e178", "M320 96l0 32 32 0 96 0 0 288L96 416 96 0 320 0l0 96zm128 0l-45.3 0L384 96l-32 0 0-32 0-18.7L352 0l32 32 32 32 32 32zM48 120l0 344 280 0 24 0 0 48-24 0L24 512 0 512l0-24L0 120 0 96l48 0 0 24z"]
}, mF = {
  prefix: "fass",
  iconName: "trash",
  icon: [448, 512, [], "f1f8", "M144 0L128 32 0 32 0 96l448 0 0-64L320 32 304 0 144 0zM416 128L32 128 56 512l336 0 24-384z"]
}, yF = {
  prefix: "fass",
  iconName: "plus-large",
  icon: [512, 512, [], "e59e", "M288 32l0-32L224 0l0 32 0 192L32 224 0 224l0 64 32 0 192 0 0 192 0 32 64 0 0-32 0-192 192 0 32 0 0-64-32 0-192 0 0-192z"]
}, gF = {
  prefix: "fass",
  iconName: "calculator",
  icon: [384, 512, [128425], "f1ec", "M384 0L0 0 0 512l384 0L384 0zM320 64l0 96L64 160l0-96 256 0zM64 192l64 0 0 64-64 0 0-64zm64 96l0 64-64 0 0-64 64 0zM64 384l160 0 0 64L64 448l0-64zM224 192l0 64-64 0 0-64 64 0zm-64 96l64 0 0 64-64 0 0-64zm160-96l0 64-64 0 0-64 64 0zm-64 96l64 0 0 64-64 0 0-64zm64 96l0 64-64 0 0-64 64 0z"]
}, vF = {
  prefix: "fass",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32L0 32 0 64l0 96 0 32 64 0 0-32 0-64 64 0 32 0 0-64-32 0L32 32zM64 352l0-32L0 320l0 32 0 96 0 32 32 0 96 0 32 0 0-64-32 0-64 0 0-64zM320 32l-32 0 0 64 32 0 64 0 0 64 0 32 64 0 0-32 0-96 0-32-32 0-96 0zM448 352l0-32-64 0 0 32 0 64-64 0-32 0 0 64 32 0 96 0 32 0 0-32 0-96z"]
}, bF = {
  prefix: "fass",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M326.6 166.6L349.3 144 304 98.7l-22.6 22.6L192 210.7l-89.4-89.4L80 98.7 34.7 144l22.6 22.6L146.7 256 57.4 345.4 34.7 368 80 413.3l22.6-22.6L192 301.3l89.4 89.4L304 413.3 349.3 368l-22.6-22.6L237.3 256l89.4-89.4z"]
}, _F = {
  prefix: "fass",
  iconName: "hammer",
  icon: [576, 512, [128296], "f6e3", "M225.6 18.2L176 48l96 48 0 48L384 256l24-24 24 24-24 24 48 48L576 208l-48-48-24 24-24-24 24-24L405.5 37.5C381.5 13.5 348.9 0 315 0L291.5 0c-23.2 0-46 6.3-65.9 18.2zM0 416l96 96L330.7 248 264 181.3 0 416z"]
}, yq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, faCalculator: gF, faExpand: vF, faFiles: dF, faHammer: _F, faHammerBrush: pF, faImage: hF, faPlusLarge: yF, faSprayCan: fF, faTrash: mF, faXmark: bF }, Symbol.toStringTag, { value: "Module" })), mu = Math.min, eo = Math.max, yu = Math.round, js = Math.floor, ai = (e) => ({
  x: e,
  y: e
}), wF = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, OF = {
  start: "end",
  end: "start"
};
function Nb(e, t, r) {
  return eo(e, mu(t, r));
}
function uc(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function co(e) {
  return e.split("-")[0];
}
function cc(e) {
  return e.split("-")[1];
}
function L2(e) {
  return e === "x" ? "y" : "x";
}
function B2(e) {
  return e === "y" ? "height" : "width";
}
const $F = /* @__PURE__ */ new Set(["top", "bottom"]);
function Ii(e) {
  return $F.has(co(e)) ? "y" : "x";
}
function q2(e) {
  return L2(Ii(e));
}
function SF(e, t, r) {
  r === void 0 && (r = !1);
  const i = cc(e), n = q2(e), o = B2(n);
  let s = n === "x" ? i === (r ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = gu(s)), [s, gu(s)];
}
function EF(e) {
  const t = gu(e);
  return [Fp(e), t, Fp(t)];
}
function Fp(e) {
  return e.replace(/start|end/g, (t) => OF[t]);
}
const Cb = ["left", "right"], Rb = ["right", "left"], xF = ["top", "bottom"], AF = ["bottom", "top"];
function jF(e, t, r) {
  switch (e) {
    case "top":
    case "bottom":
      return r ? t ? Rb : Cb : t ? Cb : Rb;
    case "left":
    case "right":
      return t ? xF : AF;
    default:
      return [];
  }
}
function kF(e, t, r, i) {
  const n = cc(e);
  let o = jF(co(e), r === "start", i);
  return n && (o = o.map((s) => s + "-" + n), t && (o = o.concat(o.map(Fp)))), o;
}
function gu(e) {
  return e.replace(/left|right|bottom|top/g, (t) => wF[t]);
}
function PF(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function IF(e) {
  return typeof e != "number" ? PF(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function vu(e) {
  const {
    x: t,
    y: r,
    width: i,
    height: n
  } = e;
  return {
    width: i,
    height: n,
    top: r,
    left: t,
    right: t + i,
    bottom: r + n,
    x: t,
    y: r
  };
}
function Db(e, t, r) {
  let {
    reference: i,
    floating: n
  } = e;
  const o = Ii(t), s = q2(t), a = B2(s), u = co(t), c = o === "y", f = i.x + i.width / 2 - n.width / 2, h = i.y + i.height / 2 - n.height / 2, y = i[a] / 2 - n[a] / 2;
  let p;
  switch (u) {
    case "top":
      p = {
        x: f,
        y: i.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: f,
        y: i.y + i.height
      };
      break;
    case "right":
      p = {
        x: i.x + i.width,
        y: h
      };
      break;
    case "left":
      p = {
        x: i.x - n.width,
        y: h
      };
      break;
    default:
      p = {
        x: i.x,
        y: i.y
      };
  }
  switch (cc(t)) {
    case "start":
      p[s] -= y * (r && c ? -1 : 1);
      break;
    case "end":
      p[s] += y * (r && c ? -1 : 1);
      break;
  }
  return p;
}
const TF = async (e, t, r) => {
  const {
    placement: i = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: s
  } = r, a = o.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let c = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: n
  }), {
    x: f,
    y: h
  } = Db(c, i, u), y = i, p = {}, l = 0;
  for (let d = 0; d < a.length; d++) {
    const {
      name: v,
      fn: m
    } = a[d], {
      x: g,
      y: _,
      data: b,
      reset: w
    } = await m({
      x: f,
      y: h,
      initialPlacement: i,
      placement: y,
      strategy: n,
      middlewareData: p,
      rects: c,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = g ?? f, h = _ ?? h, p = {
      ...p,
      [v]: {
        ...p[v],
        ...b
      }
    }, w && l <= 50 && (l++, typeof w == "object" && (w.placement && (y = w.placement), w.rects && (c = w.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: n
    }) : w.rects), {
      x: f,
      y: h
    } = Db(c, y, u)), d = -1);
  }
  return {
    x: f,
    y: h,
    placement: y,
    strategy: n,
    middlewareData: p
  };
};
async function Z2(e, t) {
  var r;
  t === void 0 && (t = {});
  const {
    x: i,
    y: n,
    platform: o,
    rects: s,
    elements: a,
    strategy: u
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: h = "floating",
    altBoundary: y = !1,
    padding: p = 0
  } = uc(t, e), l = IF(p), v = a[y ? h === "floating" ? "reference" : "floating" : h], m = vu(await o.getClippingRect({
    element: (r = await (o.isElement == null ? void 0 : o.isElement(v))) == null || r ? v : v.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: f,
    strategy: u
  })), g = h === "floating" ? {
    x: i,
    y: n,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, _ = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), b = await (o.isElement == null ? void 0 : o.isElement(_)) ? await (o.getScale == null ? void 0 : o.getScale(_)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = vu(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: g,
    offsetParent: _,
    strategy: u
  }) : g);
  return {
    top: (m.top - w.top + l.top) / b.y,
    bottom: (w.bottom - m.bottom + l.bottom) / b.y,
    left: (m.left - w.left + l.left) / b.x,
    right: (w.right - m.right + l.right) / b.x
  };
}
const NF = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var r, i;
      const {
        placement: n,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: u,
        elements: c
      } = t, {
        mainAxis: f = !0,
        crossAxis: h = !0,
        fallbackPlacements: y,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: l = "none",
        flipAlignment: d = !0,
        ...v
      } = uc(e, t);
      if ((r = o.arrow) != null && r.alignmentOffset)
        return {};
      const m = co(n), g = Ii(a), _ = co(a) === a, b = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), w = y || (_ || !d ? [gu(a)] : EF(a)), A = l !== "none";
      !y && A && w.push(...kF(a, d, l, b));
      const E = [a, ...w], O = await Z2(t, v), $ = [];
      let k = ((i = o.flip) == null ? void 0 : i.overflows) || [];
      if (f && $.push(O[m]), h) {
        const I = SF(n, s, b);
        $.push(O[I[0]], O[I[1]]);
      }
      if (k = [...k, {
        placement: n,
        overflows: $
      }], !$.every((I) => I <= 0)) {
        var j, P;
        const I = (((j = o.flip) == null ? void 0 : j.index) || 0) + 1, z = E[I];
        if (z && (!(h === "alignment" ? g !== Ii(z) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        k.every((te) => Ii(te.placement) === g ? te.overflows[0] > 0 : !0)))
          return {
            data: {
              index: I,
              overflows: k
            },
            reset: {
              placement: z
            }
          };
        let W = (P = k.filter((F) => F.overflows[0] <= 0).sort((F, te) => F.overflows[1] - te.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!W)
          switch (p) {
            case "bestFit": {
              var R;
              const F = (R = k.filter((te) => {
                if (A) {
                  const ee = Ii(te.placement);
                  return ee === g || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ee === "y";
                }
                return !0;
              }).map((te) => [te.placement, te.overflows.filter((ee) => ee > 0).reduce((ee, V) => ee + V, 0)]).sort((te, ee) => te[1] - ee[1])[0]) == null ? void 0 : R[0];
              F && (W = F);
              break;
            }
            case "initialPlacement":
              W = a;
              break;
          }
        if (n !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
}, CF = /* @__PURE__ */ new Set(["left", "top"]);
async function RF(e, t) {
  const {
    placement: r,
    platform: i,
    elements: n
  } = e, o = await (i.isRTL == null ? void 0 : i.isRTL(n.floating)), s = co(r), a = cc(r), u = Ii(r) === "y", c = CF.has(s) ? -1 : 1, f = o && u ? -1 : 1, h = uc(t, e);
  let {
    mainAxis: y,
    crossAxis: p,
    alignmentAxis: l
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof l == "number" && (p = a === "end" ? l * -1 : l), u ? {
    x: p * f,
    y: y * c
  } : {
    x: y * c,
    y: p * f
  };
}
const DF = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var r, i;
      const {
        x: n,
        y: o,
        placement: s,
        middlewareData: a
      } = t, u = await RF(t, e);
      return s === ((r = a.offset) == null ? void 0 : r.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: n + u.x,
        y: o + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, zF = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: r,
        y: i,
        placement: n
      } = t, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (v) => {
            let {
              x: m,
              y: g
            } = v;
            return {
              x: m,
              y: g
            };
          }
        },
        ...u
      } = uc(e, t), c = {
        x: r,
        y: i
      }, f = await Z2(t, u), h = Ii(co(n)), y = L2(h);
      let p = c[y], l = c[h];
      if (o) {
        const v = y === "y" ? "top" : "left", m = y === "y" ? "bottom" : "right", g = p + f[v], _ = p - f[m];
        p = Nb(g, p, _);
      }
      if (s) {
        const v = h === "y" ? "top" : "left", m = h === "y" ? "bottom" : "right", g = l + f[v], _ = l - f[m];
        l = Nb(g, l, _);
      }
      const d = a.fn({
        ...t,
        [y]: p,
        [h]: l
      });
      return {
        ...d,
        data: {
          x: d.x - r,
          y: d.y - i,
          enabled: {
            [y]: o,
            [h]: s
          }
        }
      };
    }
  };
};
function lc() {
  return typeof window < "u";
}
function Xo(e) {
  return V2(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function In(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function li(e) {
  var t;
  return (t = (V2(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function V2(e) {
  return lc() ? e instanceof Node || e instanceof In(e).Node : !1;
}
function Hn(e) {
  return lc() ? e instanceof Element || e instanceof In(e).Element : !1;
}
function ui(e) {
  return lc() ? e instanceof HTMLElement || e instanceof In(e).HTMLElement : !1;
}
function zb(e) {
  return !lc() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof In(e).ShadowRoot;
}
const UF = /* @__PURE__ */ new Set(["inline", "contents"]);
function as(e) {
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
    display: n
  } = Jn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + r) && !UF.has(n);
}
const MF = /* @__PURE__ */ new Set(["table", "td", "th"]);
function FF(e) {
  return MF.has(Xo(e));
}
const LF = [":popover-open", ":modal"];
function fc(e) {
  return LF.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const BF = ["transform", "translate", "scale", "rotate", "perspective"], qF = ["transform", "translate", "scale", "rotate", "perspective", "filter"], ZF = ["paint", "layout", "strict", "content"];
function tg(e) {
  const t = rg(), r = Hn(e) ? Jn(e) : e;
  return BF.some((i) => r[i] ? r[i] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !t && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !t && (r.filter ? r.filter !== "none" : !1) || qF.some((i) => (r.willChange || "").includes(i)) || ZF.some((i) => (r.contain || "").includes(i));
}
function VF(e) {
  let t = Fi(e);
  for (; ui(t) && !Zo(t); ) {
    if (tg(t))
      return t;
    if (fc(t))
      return null;
    t = Fi(t);
  }
  return null;
}
function rg() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const WF = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Zo(e) {
  return WF.has(Xo(e));
}
function Jn(e) {
  return In(e).getComputedStyle(e);
}
function hc(e) {
  return Hn(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Fi(e) {
  if (Xo(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    zb(e) && e.host || // Fallback.
    li(e)
  );
  return zb(t) ? t.host : t;
}
function W2(e) {
  const t = Fi(e);
  return Zo(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ui(t) && as(t) ? t : W2(t);
}
function Ua(e, t, r) {
  var i;
  t === void 0 && (t = []), r === void 0 && (r = !0);
  const n = W2(e), o = n === ((i = e.ownerDocument) == null ? void 0 : i.body), s = In(n);
  if (o) {
    const a = Lp(s);
    return t.concat(s, s.visualViewport || [], as(n) ? n : [], a && r ? Ua(a) : []);
  }
  return t.concat(n, Ua(n, [], r));
}
function Lp(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function G2(e) {
  const t = Jn(e);
  let r = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const n = ui(e), o = n ? e.offsetWidth : r, s = n ? e.offsetHeight : i, a = yu(r) !== o || yu(i) !== s;
  return a && (r = o, i = s), {
    width: r,
    height: i,
    $: a
  };
}
function ng(e) {
  return Hn(e) ? e : e.contextElement;
}
function Io(e) {
  const t = ng(e);
  if (!ui(t))
    return ai(1);
  const r = t.getBoundingClientRect(), {
    width: i,
    height: n,
    $: o
  } = G2(t);
  let s = (o ? yu(r.width) : r.width) / i, a = (o ? yu(r.height) : r.height) / n;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const GF = /* @__PURE__ */ ai(0);
function K2(e) {
  const t = In(e);
  return !rg() || !t.visualViewport ? GF : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function KF(e, t, r) {
  return t === void 0 && (t = !1), !r || t && r !== In(e) ? !1 : t;
}
function lo(e, t, r, i) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const n = e.getBoundingClientRect(), o = ng(e);
  let s = ai(1);
  t && (i ? Hn(i) && (s = Io(i)) : s = Io(e));
  const a = KF(o, r, i) ? K2(o) : ai(0);
  let u = (n.left + a.x) / s.x, c = (n.top + a.y) / s.y, f = n.width / s.x, h = n.height / s.y;
  if (o) {
    const y = In(o), p = i && Hn(i) ? In(i) : i;
    let l = y, d = Lp(l);
    for (; d && i && p !== l; ) {
      const v = Io(d), m = d.getBoundingClientRect(), g = Jn(d), _ = m.left + (d.clientLeft + parseFloat(g.paddingLeft)) * v.x, b = m.top + (d.clientTop + parseFloat(g.paddingTop)) * v.y;
      u *= v.x, c *= v.y, f *= v.x, h *= v.y, u += _, c += b, l = In(d), d = Lp(l);
    }
  }
  return vu({
    width: f,
    height: h,
    x: u,
    y: c
  });
}
function pc(e, t) {
  const r = hc(e).scrollLeft;
  return t ? t.left + r : lo(li(e)).left + r;
}
function H2(e, t) {
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - pc(e, r), n = r.top + t.scrollTop;
  return {
    x: i,
    y: n
  };
}
function HF(e) {
  let {
    elements: t,
    rect: r,
    offsetParent: i,
    strategy: n
  } = e;
  const o = n === "fixed", s = li(i), a = t ? fc(t.floating) : !1;
  if (i === s || a && o)
    return r;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = ai(1);
  const f = ai(0), h = ui(i);
  if ((h || !h && !o) && ((Xo(i) !== "body" || as(s)) && (u = hc(i)), ui(i))) {
    const p = lo(i);
    c = Io(i), f.x = p.x + i.clientLeft, f.y = p.y + i.clientTop;
  }
  const y = s && !h && !o ? H2(s, u) : ai(0);
  return {
    width: r.width * c.x,
    height: r.height * c.y,
    x: r.x * c.x - u.scrollLeft * c.x + f.x + y.x,
    y: r.y * c.y - u.scrollTop * c.y + f.y + y.y
  };
}
function JF(e) {
  return Array.from(e.getClientRects());
}
function YF(e) {
  const t = li(e), r = hc(e), i = e.ownerDocument.body, n = eo(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), o = eo(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let s = -r.scrollLeft + pc(e);
  const a = -r.scrollTop;
  return Jn(i).direction === "rtl" && (s += eo(t.clientWidth, i.clientWidth) - n), {
    width: n,
    height: o,
    x: s,
    y: a
  };
}
const Ub = 25;
function XF(e, t) {
  const r = In(e), i = li(e), n = r.visualViewport;
  let o = i.clientWidth, s = i.clientHeight, a = 0, u = 0;
  if (n) {
    o = n.width, s = n.height;
    const f = rg();
    (!f || f && t === "fixed") && (a = n.offsetLeft, u = n.offsetTop);
  }
  const c = pc(i);
  if (c <= 0) {
    const f = i.ownerDocument, h = f.body, y = getComputedStyle(h), p = f.compatMode === "CSS1Compat" && parseFloat(y.marginLeft) + parseFloat(y.marginRight) || 0, l = Math.abs(i.clientWidth - h.clientWidth - p);
    l <= Ub && (o -= l);
  } else c <= Ub && (o += c);
  return {
    width: o,
    height: s,
    x: a,
    y: u
  };
}
const QF = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function eL(e, t) {
  const r = lo(e, !0, t === "fixed"), i = r.top + e.clientTop, n = r.left + e.clientLeft, o = ui(e) ? Io(e) : ai(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, u = n * o.x, c = i * o.y;
  return {
    width: s,
    height: a,
    x: u,
    y: c
  };
}
function Mb(e, t, r) {
  let i;
  if (t === "viewport")
    i = XF(e, r);
  else if (t === "document")
    i = YF(li(e));
  else if (Hn(t))
    i = eL(t, r);
  else {
    const n = K2(e);
    i = {
      x: t.x - n.x,
      y: t.y - n.y,
      width: t.width,
      height: t.height
    };
  }
  return vu(i);
}
function J2(e, t) {
  const r = Fi(e);
  return r === t || !Hn(r) || Zo(r) ? !1 : Jn(r).position === "fixed" || J2(r, t);
}
function tL(e, t) {
  const r = t.get(e);
  if (r)
    return r;
  let i = Ua(e, [], !1).filter((a) => Hn(a) && Xo(a) !== "body"), n = null;
  const o = Jn(e).position === "fixed";
  let s = o ? Fi(e) : e;
  for (; Hn(s) && !Zo(s); ) {
    const a = Jn(s), u = tg(s);
    !u && a.position === "fixed" && (n = null), (o ? !u && !n : !u && a.position === "static" && !!n && QF.has(n.position) || as(s) && !u && J2(e, s)) ? i = i.filter((f) => f !== s) : n = a, s = Fi(s);
  }
  return t.set(e, i), i;
}
function rL(e) {
  let {
    element: t,
    boundary: r,
    rootBoundary: i,
    strategy: n
  } = e;
  const s = [...r === "clippingAncestors" ? fc(t) ? [] : tL(t, this._c) : [].concat(r), i], a = s[0], u = s.reduce((c, f) => {
    const h = Mb(t, f, n);
    return c.top = eo(h.top, c.top), c.right = mu(h.right, c.right), c.bottom = mu(h.bottom, c.bottom), c.left = eo(h.left, c.left), c;
  }, Mb(t, a, n));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function nL(e) {
  const {
    width: t,
    height: r
  } = G2(e);
  return {
    width: t,
    height: r
  };
}
function iL(e, t, r) {
  const i = ui(t), n = li(t), o = r === "fixed", s = lo(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = ai(0);
  function c() {
    u.x = pc(n);
  }
  if (i || !i && !o)
    if ((Xo(t) !== "body" || as(n)) && (a = hc(t)), i) {
      const p = lo(t, !0, o, t);
      u.x = p.x + t.clientLeft, u.y = p.y + t.clientTop;
    } else n && c();
  o && !i && n && c();
  const f = n && !i && !o ? H2(n, a) : ai(0), h = s.left + a.scrollLeft - u.x - f.x, y = s.top + a.scrollTop - u.y - f.y;
  return {
    x: h,
    y,
    width: s.width,
    height: s.height
  };
}
function Jc(e) {
  return Jn(e).position === "static";
}
function Fb(e, t) {
  if (!ui(e) || Jn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let r = e.offsetParent;
  return li(e) === r && (r = r.ownerDocument.body), r;
}
function Y2(e, t) {
  const r = In(e);
  if (fc(e))
    return r;
  if (!ui(e)) {
    let n = Fi(e);
    for (; n && !Zo(n); ) {
      if (Hn(n) && !Jc(n))
        return n;
      n = Fi(n);
    }
    return r;
  }
  let i = Fb(e, t);
  for (; i && FF(i) && Jc(i); )
    i = Fb(i, t);
  return i && Zo(i) && Jc(i) && !tg(i) ? r : i || VF(e) || r;
}
const oL = async function(e) {
  const t = this.getOffsetParent || Y2, r = this.getDimensions, i = await r(e.floating);
  return {
    reference: iL(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function aL(e) {
  return Jn(e).direction === "rtl";
}
const sL = {
  convertOffsetParentRelativeRectToViewportRelativeRect: HF,
  getDocumentElement: li,
  getClippingRect: rL,
  getOffsetParent: Y2,
  getElementRects: oL,
  getClientRects: JF,
  getDimensions: nL,
  getScale: Io,
  isElement: Hn,
  isRTL: aL
};
function X2(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function uL(e, t) {
  let r = null, i;
  const n = li(e);
  function o() {
    var a;
    clearTimeout(i), (a = r) == null || a.disconnect(), r = null;
  }
  function s(a, u) {
    a === void 0 && (a = !1), u === void 0 && (u = 1), o();
    const c = e.getBoundingClientRect(), {
      left: f,
      top: h,
      width: y,
      height: p
    } = c;
    if (a || t(), !y || !p)
      return;
    const l = js(h), d = js(n.clientWidth - (f + y)), v = js(n.clientHeight - (h + p)), m = js(f), _ = {
      rootMargin: -l + "px " + -d + "px " + -v + "px " + -m + "px",
      threshold: eo(0, mu(1, u)) || 1
    };
    let b = !0;
    function w(A) {
      const E = A[0].intersectionRatio;
      if (E !== u) {
        if (!b)
          return s();
        E ? s(!1, E) : i = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      E === 1 && !X2(c, e.getBoundingClientRect()) && s(), b = !1;
    }
    try {
      r = new IntersectionObserver(w, {
        ..._,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(w, _);
    }
    r.observe(e);
  }
  return s(!0), o;
}
function gq(e, t, r, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = i, c = ng(e), f = n || o ? [...c ? Ua(c) : [], ...Ua(t)] : [];
  f.forEach((m) => {
    n && m.addEventListener("scroll", r, {
      passive: !0
    }), o && m.addEventListener("resize", r);
  });
  const h = c && a ? uL(c, r) : null;
  let y = -1, p = null;
  s && (p = new ResizeObserver((m) => {
    let [g] = m;
    g && g.target === c && p && (p.unobserve(t), cancelAnimationFrame(y), y = requestAnimationFrame(() => {
      var _;
      (_ = p) == null || _.observe(t);
    })), r();
  }), c && !u && p.observe(c), p.observe(t));
  let l, d = u ? lo(e) : null;
  u && v();
  function v() {
    const m = lo(e);
    d && !X2(d, m) && r(), d = m, l = requestAnimationFrame(v);
  }
  return r(), () => {
    var m;
    f.forEach((g) => {
      n && g.removeEventListener("scroll", r), o && g.removeEventListener("resize", r);
    }), h?.(), (m = p) == null || m.disconnect(), p = null, u && cancelAnimationFrame(l);
  };
}
const vq = DF, bq = zF, _q = NF, wq = (e, t, r) => {
  const i = /* @__PURE__ */ new Map(), n = {
    platform: sL,
    ...r
  }, o = {
    ...n.platform,
    _c: i
  };
  return TF(e, t, {
    ...n,
    platform: o
  });
}, ci = /* @__PURE__ */ Object.create(null);
ci.open = "0";
ci.close = "1";
ci.ping = "2";
ci.pong = "3";
ci.message = "4";
ci.upgrade = "5";
ci.noop = "6";
const Us = /* @__PURE__ */ Object.create(null);
Object.keys(ci).forEach((e) => {
  Us[ci[e]] = e;
});
const Bp = { type: "error", data: "parser error" }, Q2 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", ej = typeof ArrayBuffer == "function", tj = (e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer, ig = ({ type: e, data: t }, r, i) => Q2 && t instanceof Blob ? r ? i(t) : Lb(t, i) : ej && (t instanceof ArrayBuffer || tj(t)) ? r ? i(t) : Lb(new Blob([t]), i) : i(ci[e] + (t || "")), Lb = (e, t) => {
  const r = new FileReader();
  return r.onload = function() {
    const i = r.result.split(",")[1];
    t("b" + (i || ""));
  }, r.readAsDataURL(e);
};
function Bb(e) {
  return e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}
let Yc;
function cL(e, t) {
  if (Q2 && e.data instanceof Blob)
    return e.data.arrayBuffer().then(Bb).then(t);
  if (ej && (e.data instanceof ArrayBuffer || tj(e.data)))
    return t(Bb(e.data));
  ig(e, !1, (r) => {
    Yc || (Yc = new TextEncoder()), t(Yc.encode(r));
  });
}
const qb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $a = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let e = 0; e < qb.length; e++)
  $a[qb.charCodeAt(e)] = e;
const lL = (e) => {
  let t = e.length * 0.75, r = e.length, i, n = 0, o, s, a, u;
  e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
  const c = new ArrayBuffer(t), f = new Uint8Array(c);
  for (i = 0; i < r; i += 4)
    o = $a[e.charCodeAt(i)], s = $a[e.charCodeAt(i + 1)], a = $a[e.charCodeAt(i + 2)], u = $a[e.charCodeAt(i + 3)], f[n++] = o << 2 | s >> 4, f[n++] = (s & 15) << 4 | a >> 2, f[n++] = (a & 3) << 6 | u & 63;
  return c;
}, fL = typeof ArrayBuffer == "function", og = (e, t) => {
  if (typeof e != "string")
    return {
      type: "message",
      data: rj(e, t)
    };
  const r = e.charAt(0);
  return r === "b" ? {
    type: "message",
    data: hL(e.substring(1), t)
  } : Us[r] ? e.length > 1 ? {
    type: Us[r],
    data: e.substring(1)
  } : {
    type: Us[r]
  } : Bp;
}, hL = (e, t) => {
  if (fL) {
    const r = lL(e);
    return rj(r, t);
  } else
    return { base64: !0, data: e };
}, rj = (e, t) => {
  switch (t) {
    case "blob":
      return e instanceof Blob ? e : new Blob([e]);
    case "arraybuffer":
    default:
      return e instanceof ArrayBuffer ? e : e.buffer;
  }
}, nj = "", pL = (e, t) => {
  const r = e.length, i = new Array(r);
  let n = 0;
  e.forEach((o, s) => {
    ig(o, !1, (a) => {
      i[s] = a, ++n === r && t(i.join(nj));
    });
  });
}, dL = (e, t) => {
  const r = e.split(nj), i = [];
  for (let n = 0; n < r.length; n++) {
    const o = og(r[n], t);
    if (i.push(o), o.type === "error")
      break;
  }
  return i;
};
function mL() {
  return new TransformStream({
    transform(e, t) {
      cL(e, (r) => {
        const i = r.length;
        let n;
        if (i < 126)
          n = new Uint8Array(1), new DataView(n.buffer).setUint8(0, i);
        else if (i < 65536) {
          n = new Uint8Array(3);
          const o = new DataView(n.buffer);
          o.setUint8(0, 126), o.setUint16(1, i);
        } else {
          n = new Uint8Array(9);
          const o = new DataView(n.buffer);
          o.setUint8(0, 127), o.setBigUint64(1, BigInt(i));
        }
        e.data && typeof e.data != "string" && (n[0] |= 128), t.enqueue(n), t.enqueue(r);
      });
    }
  });
}
let Xc;
function ks(e) {
  return e.reduce((t, r) => t + r.length, 0);
}
function Ps(e, t) {
  if (e[0].length === t)
    return e.shift();
  const r = new Uint8Array(t);
  let i = 0;
  for (let n = 0; n < t; n++)
    r[n] = e[0][i++], i === e[0].length && (e.shift(), i = 0);
  return e.length && i < e[0].length && (e[0] = e[0].slice(i)), r;
}
function yL(e, t) {
  Xc || (Xc = new TextDecoder());
  const r = [];
  let i = 0, n = -1, o = !1;
  return new TransformStream({
    transform(s, a) {
      for (r.push(s); ; ) {
        if (i === 0) {
          if (ks(r) < 1)
            break;
          const u = Ps(r, 1);
          o = (u[0] & 128) === 128, n = u[0] & 127, n < 126 ? i = 3 : n === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (ks(r) < 2)
            break;
          const u = Ps(r, 2);
          n = new DataView(u.buffer, u.byteOffset, u.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (ks(r) < 8)
            break;
          const u = Ps(r, 8), c = new DataView(u.buffer, u.byteOffset, u.length), f = c.getUint32(0);
          if (f > Math.pow(2, 21) - 1) {
            a.enqueue(Bp);
            break;
          }
          n = f * Math.pow(2, 32) + c.getUint32(4), i = 3;
        } else {
          if (ks(r) < n)
            break;
          const u = Ps(r, n);
          a.enqueue(og(o ? u : Xc.decode(u), t)), i = 0;
        }
        if (n === 0 || n > e) {
          a.enqueue(Bp);
          break;
        }
      }
    }
  });
}
const ij = 4;
function Vr(e) {
  if (e) return gL(e);
}
function gL(e) {
  for (var t in Vr.prototype)
    e[t] = Vr.prototype[t];
  return e;
}
Vr.prototype.on = Vr.prototype.addEventListener = function(e, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this;
};
Vr.prototype.once = function(e, t) {
  function r() {
    this.off(e, r), t.apply(this, arguments);
  }
  return r.fn = t, this.on(e, r), this;
};
Vr.prototype.off = Vr.prototype.removeListener = Vr.prototype.removeAllListeners = Vr.prototype.removeEventListener = function(e, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var r = this._callbacks["$" + e];
  if (!r) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + e], this;
  for (var i, n = 0; n < r.length; n++)
    if (i = r[n], i === t || i.fn === t) {
      r.splice(n, 1);
      break;
    }
  return r.length === 0 && delete this._callbacks["$" + e], this;
};
Vr.prototype.emit = function(e) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), r = this._callbacks["$" + e], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (r) {
    r = r.slice(0);
    for (var i = 0, n = r.length; i < n; ++i)
      r[i].apply(this, t);
  }
  return this;
};
Vr.prototype.emitReserved = Vr.prototype.emit;
Vr.prototype.listeners = function(e) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || [];
};
Vr.prototype.hasListeners = function(e) {
  return !!this.listeners(e).length;
};
const dc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, r) => r(t, 0), Rn = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), vL = "arraybuffer";
function oj(e, ...t) {
  return t.reduce((r, i) => (e.hasOwnProperty(i) && (r[i] = e[i]), r), {});
}
const bL = Rn.setTimeout, _L = Rn.clearTimeout;
function mc(e, t) {
  t.useNativeTimers ? (e.setTimeoutFn = bL.bind(Rn), e.clearTimeoutFn = _L.bind(Rn)) : (e.setTimeoutFn = Rn.setTimeout.bind(Rn), e.clearTimeoutFn = Rn.clearTimeout.bind(Rn));
}
const wL = 1.33;
function OL(e) {
  return typeof e == "string" ? $L(e) : Math.ceil((e.byteLength || e.size) * wL);
}
function $L(e) {
  let t = 0, r = 0;
  for (let i = 0, n = e.length; i < n; i++)
    t = e.charCodeAt(i), t < 128 ? r += 1 : t < 2048 ? r += 2 : t < 55296 || t >= 57344 ? r += 3 : (i++, r += 4);
  return r;
}
function aj() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function SL(e) {
  let t = "";
  for (let r in e)
    e.hasOwnProperty(r) && (t.length && (t += "&"), t += encodeURIComponent(r) + "=" + encodeURIComponent(e[r]));
  return t;
}
function EL(e) {
  let t = {}, r = e.split("&");
  for (let i = 0, n = r.length; i < n; i++) {
    let o = r[i].split("=");
    t[decodeURIComponent(o[0])] = decodeURIComponent(o[1]);
  }
  return t;
}
class xL extends Error {
  constructor(t, r, i) {
    super(t), this.description = r, this.context = i, this.type = "TransportError";
  }
}
class ag extends Vr {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, mc(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, r, i) {
    return super.emitReserved("error", new xL(t, r, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const r = og(t, this.socket.binaryType);
    this.onPacket(r);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, r = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(r);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const r = SL(t);
    return r.length ? "?" + r : "";
  }
}
class AL extends ag {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const r = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || r();
      })), this.writable || (i++, this.once("drain", function() {
        --i || r();
      }));
    } else
      r();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const r = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    dL(t, this.socket.binaryType).forEach(r), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, pL(t, (r) => {
      this.doWrite(r, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", r = this.query || {};
    return this.opts.timestampRequests !== !1 && (r[this.opts.timestampParam] = aj()), !this.supportsBinary && !r.sid && (r.b64 = 1), this.createUri(t, r);
  }
}
let sj = !1;
try {
  sj = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const jL = sj;
function kL() {
}
class PL extends AL {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const r = location.protocol === "https:";
      let i = location.port;
      i || (i = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, r) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", r), i.on("error", (n, o) => {
      this.onError("xhr post error", n, o);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (r, i) => {
      this.onError("xhr poll error", r, i);
    }), this.pollXhr = t;
  }
}
class si extends Vr {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, r, i) {
    super(), this.createRequest = t, mc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = r, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const r = oj(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    r.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(r);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let n in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(n) && i.setRequestHeader(n, this._opts.extraHeaders[n]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var n;
        i.readyState === 3 && ((n = this._opts.cookieJar) === null || n === void 0 || n.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (n) {
      this.setTimeoutFn(() => {
        this._onError(n);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = si.requestsCount++, si.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = kL, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete si.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
si.requestsCount = 0;
si.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", Zb);
  else if (typeof addEventListener == "function") {
    const e = "onpagehide" in Rn ? "pagehide" : "unload";
    addEventListener(e, Zb, !1);
  }
}
function Zb() {
  for (let e in si.requests)
    si.requests.hasOwnProperty(e) && si.requests[e].abort();
}
const IL = (function() {
  const e = uj({
    xdomain: !1
  });
  return e && e.responseType !== null;
})();
class TL extends PL {
  constructor(t) {
    super(t);
    const r = t && t.forceBase64;
    this.supportsBinary = IL && !r;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new si(uj, this.uri(), t);
  }
}
function uj(e) {
  const t = e.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || jL))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new Rn[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const cj = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class NL extends ag {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), r = this.opts.protocols, i = cj ? {} : oj(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, r, i);
    } catch (n) {
      return this.emitReserved("error", n);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let r = 0; r < t.length; r++) {
      const i = t[r], n = r === t.length - 1;
      ig(i, this.supportsBinary, (o) => {
        try {
          this.doWrite(i, o);
        } catch {
        }
        n && dc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", r = this.query || {};
    return this.opts.timestampRequests && (r[this.opts.timestampParam] = aj()), this.supportsBinary || (r.b64 = 1), this.createUri(t, r);
  }
}
const Qc = Rn.WebSocket || Rn.MozWebSocket;
class CL extends NL {
  createSocket(t, r, i) {
    return cj ? new Qc(t, r, i) : r ? new Qc(t, r) : new Qc(t);
  }
  doWrite(t, r) {
    this.ws.send(r);
  }
}
class RL extends ag {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const r = yL(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(r).getReader(), n = mL();
        n.readable.pipeTo(t.writable), this._writer = n.writable.getWriter();
        const o = () => {
          i.read().then(({ done: a, value: u }) => {
            a || (this.onPacket(u), o());
          }).catch((a) => {
          });
        };
        o();
        const s = { type: "open" };
        this.query.sid && (s.data = `{"sid":"${this.query.sid}"}`), this._writer.write(s).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let r = 0; r < t.length; r++) {
      const i = t[r], n = r === t.length - 1;
      this._writer.write(i).then(() => {
        n && dc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const DL = {
  websocket: CL,
  webtransport: RL,
  polling: TL
}, zL = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, UL = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function qp(e) {
  if (e.length > 8e3)
    throw "URI too long";
  const t = e, r = e.indexOf("["), i = e.indexOf("]");
  r != -1 && i != -1 && (e = e.substring(0, r) + e.substring(r, i).replace(/:/g, ";") + e.substring(i, e.length));
  let n = zL.exec(e || ""), o = {}, s = 14;
  for (; s--; )
    o[UL[s]] = n[s] || "";
  return r != -1 && i != -1 && (o.source = t, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = !0), o.pathNames = ML(o, o.path), o.queryKey = FL(o, o.query), o;
}
function ML(e, t) {
  const r = /\/{2,9}/g, i = t.replace(r, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function FL(e, t) {
  const r = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, n, o) {
    n && (r[n] = o);
  }), r;
}
const Zp = typeof addEventListener == "function" && typeof removeEventListener == "function", Ms = [];
Zp && addEventListener("offline", () => {
  Ms.forEach((e) => e());
}, !1);
class Ni extends Vr {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, r) {
    if (super(), this.binaryType = vL, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (r = t, t = null), t) {
      const i = qp(t);
      r.hostname = i.host, r.secure = i.protocol === "https" || i.protocol === "wss", r.port = i.port, i.query && (r.query = i.query);
    } else r.host && (r.hostname = qp(r.host).host);
    mc(this, r), this.secure = r.secure != null ? r.secure : typeof location < "u" && location.protocol === "https:", r.hostname && !r.port && (r.port = this.secure ? "443" : "80"), this.hostname = r.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = r.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, r.transports.forEach((i) => {
      const n = i.prototype.name;
      this.transports.push(n), this._transportsByName[n] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, r), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = EL(this.opts.query)), Zp && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, Ms.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const r = Object.assign({}, this.opts.query);
    r.EIO = ij, r.transport = t, this.id && (r.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: r,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && Ni.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const r = this.createTransport(t);
    r.open(), this.setTransport(r);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (r) => this._onClose("transport close", r));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", Ni.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const r = new Error("server error");
          r.code = t.data, this._onError(r);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let r = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const n = this.writeBuffer[i].data;
      if (n && (r += OL(n)), i > 0 && r > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      r += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, dc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, r, i) {
    return this._sendPacket("message", t, r, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, r, i) {
    return this._sendPacket("message", t, r, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, r, i, n) {
    if (typeof r == "function" && (n = r, r = void 0), typeof i == "function" && (n = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const o = {
      type: t,
      data: r,
      options: i
    };
    this.emitReserved("packetCreate", o), this.writeBuffer.push(o), n && this.once("flush", n), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, r = () => {
      this.off("upgrade", r), this.off("upgradeError", r), t();
    }, i = () => {
      this.once("upgrade", r), this.once("upgradeError", r);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (Ni.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, r) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), Zp && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = Ms.indexOf(this._offlineEventListener);
        i !== -1 && Ms.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, r), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
Ni.protocol = ij;
class LL extends Ni {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let r = this.createTransport(t), i = !1;
    Ni.priorWebsocketSuccess = !1;
    const n = () => {
      i || (r.send([{ type: "ping", data: "probe" }]), r.once("packet", (h) => {
        if (!i)
          if (h.type === "pong" && h.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", r), !r)
              return;
            Ni.priorWebsocketSuccess = r.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (f(), this.setTransport(r), r.send([{ type: "upgrade" }]), this.emitReserved("upgrade", r), r = null, this.upgrading = !1, this.flush());
            });
          } else {
            const y = new Error("probe error");
            y.transport = r.name, this.emitReserved("upgradeError", y);
          }
      }));
    };
    function o() {
      i || (i = !0, f(), r.close(), r = null);
    }
    const s = (h) => {
      const y = new Error("probe error: " + h);
      y.transport = r.name, o(), this.emitReserved("upgradeError", y);
    };
    function a() {
      s("transport closed");
    }
    function u() {
      s("socket closed");
    }
    function c(h) {
      r && h.name !== r.name && o();
    }
    const f = () => {
      r.removeListener("open", n), r.removeListener("error", s), r.removeListener("close", a), this.off("close", u), this.off("upgrading", c);
    };
    r.once("open", n), r.once("error", s), r.once("close", a), this.once("close", u), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      i || r.open();
    }, 200) : r.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const r = [];
    for (let i = 0; i < t.length; i++)
      ~this.transports.indexOf(t[i]) && r.push(t[i]);
    return r;
  }
}
let BL = class extends LL {
  constructor(t, r = {}) {
    const i = typeof t == "object" ? t : r;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((n) => DL[n]).filter((n) => !!n)), super(t, i);
  }
};
function qL(e, t = "", r) {
  let i = e;
  r = r || typeof location < "u" && location, e == null && (e = r.protocol + "//" + r.host), typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = r.protocol + e : e = r.host + e), /^(https?|wss?):\/\//.test(e) || (typeof r < "u" ? e = r.protocol + "//" + e : e = "https://" + e), i = qp(e)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const o = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + o + ":" + i.port + t, i.href = i.protocol + "://" + o + (r && r.port === i.port ? "" : ":" + i.port), i;
}
const ZL = typeof ArrayBuffer == "function", VL = (e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer, lj = Object.prototype.toString, WL = typeof Blob == "function" || typeof Blob < "u" && lj.call(Blob) === "[object BlobConstructor]", GL = typeof File == "function" || typeof File < "u" && lj.call(File) === "[object FileConstructor]";
function sg(e) {
  return ZL && (e instanceof ArrayBuffer || VL(e)) || WL && e instanceof Blob || GL && e instanceof File;
}
function Fs(e, t) {
  if (!e || typeof e != "object")
    return !1;
  if (Array.isArray(e)) {
    for (let r = 0, i = e.length; r < i; r++)
      if (Fs(e[r]))
        return !0;
    return !1;
  }
  if (sg(e))
    return !0;
  if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1)
    return Fs(e.toJSON(), !0);
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r) && Fs(e[r]))
      return !0;
  return !1;
}
function KL(e) {
  const t = [], r = e.data, i = e;
  return i.data = Vp(r, t), i.attachments = t.length, { packet: i, buffers: t };
}
function Vp(e, t) {
  if (!e)
    return e;
  if (sg(e)) {
    const r = { _placeholder: !0, num: t.length };
    return t.push(e), r;
  } else if (Array.isArray(e)) {
    const r = new Array(e.length);
    for (let i = 0; i < e.length; i++)
      r[i] = Vp(e[i], t);
    return r;
  } else if (typeof e == "object" && !(e instanceof Date)) {
    const r = {};
    for (const i in e)
      Object.prototype.hasOwnProperty.call(e, i) && (r[i] = Vp(e[i], t));
    return r;
  }
  return e;
}
function HL(e, t) {
  return e.data = Wp(e.data, t), delete e.attachments, e;
}
function Wp(e, t) {
  if (!e)
    return e;
  if (e && e._placeholder === !0) {
    if (typeof e.num == "number" && e.num >= 0 && e.num < t.length)
      return t[e.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(e))
    for (let r = 0; r < e.length; r++)
      e[r] = Wp(e[r], t);
  else if (typeof e == "object")
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (e[r] = Wp(e[r], t));
  return e;
}
const JL = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], YL = 5;
var Jt;
(function(e) {
  e[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK";
})(Jt || (Jt = {}));
class XL {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === Jt.EVENT || t.type === Jt.ACK) && Fs(t) ? this.encodeAsBinary({
      type: t.type === Jt.EVENT ? Jt.BINARY_EVENT : Jt.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let r = "" + t.type;
    return (t.type === Jt.BINARY_EVENT || t.type === Jt.BINARY_ACK) && (r += t.attachments + "-"), t.nsp && t.nsp !== "/" && (r += t.nsp + ","), t.id != null && (r += t.id), t.data != null && (r += JSON.stringify(t.data, this.replacer)), r;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const r = KL(t), i = this.encodeAsString(r.packet), n = r.buffers;
    return n.unshift(i), n;
  }
}
function Vb(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
class ug extends Vr {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let r;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      r = this.decodeString(t);
      const i = r.type === Jt.BINARY_EVENT;
      i || r.type === Jt.BINARY_ACK ? (r.type = i ? Jt.EVENT : Jt.ACK, this.reconstructor = new QL(r), r.attachments === 0 && super.emitReserved("decoded", r)) : super.emitReserved("decoded", r);
    } else if (sg(t) || t.base64)
      if (this.reconstructor)
        r = this.reconstructor.takeBinaryData(t), r && (this.reconstructor = null, super.emitReserved("decoded", r));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let r = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (Jt[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === Jt.BINARY_EVENT || i.type === Jt.BINARY_ACK) {
      const o = r + 1;
      for (; t.charAt(++r) !== "-" && r != t.length; )
        ;
      const s = t.substring(o, r);
      if (s != Number(s) || t.charAt(r) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(s);
    }
    if (t.charAt(r + 1) === "/") {
      const o = r + 1;
      for (; ++r && !(t.charAt(r) === "," || r === t.length); )
        ;
      i.nsp = t.substring(o, r);
    } else
      i.nsp = "/";
    const n = t.charAt(r + 1);
    if (n !== "" && Number(n) == n) {
      const o = r + 1;
      for (; ++r; ) {
        const s = t.charAt(r);
        if (s == null || Number(s) != s) {
          --r;
          break;
        }
        if (r === t.length)
          break;
      }
      i.id = Number(t.substring(o, r + 1));
    }
    if (t.charAt(++r)) {
      const o = this.tryParse(t.substr(r));
      if (ug.isPayloadValid(i.type, o))
        i.data = o;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, r) {
    switch (t) {
      case Jt.CONNECT:
        return Vb(r);
      case Jt.DISCONNECT:
        return r === void 0;
      case Jt.CONNECT_ERROR:
        return typeof r == "string" || Vb(r);
      case Jt.EVENT:
      case Jt.BINARY_EVENT:
        return Array.isArray(r) && (typeof r[0] == "number" || typeof r[0] == "string" && JL.indexOf(r[0]) === -1);
      case Jt.ACK:
      case Jt.BINARY_ACK:
        return Array.isArray(r);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class QL {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const r = HL(this.reconPack, this.buffers);
      return this.finishedReconstruction(), r;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const eB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Decoder: ug, Encoder: XL, get PacketType() {
  return Jt;
}, protocol: YL }, Symbol.toStringTag, { value: "Module" }));
function Zn(e, t, r) {
  return e.on(t, r), function() {
    e.off(t, r);
  };
}
const tB = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class fj extends Vr {
  /**
   * `Socket` constructor.
   */
  constructor(t, r, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = r, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      Zn(t, "open", this.onopen.bind(this)),
      Zn(t, "packet", this.onpacket.bind(this)),
      Zn(t, "error", this.onerror.bind(this)),
      Zn(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...r) {
    var i, n, o;
    if (tB.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (r.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(r), this;
    const s = {
      type: Jt.EVENT,
      data: r
    };
    if (s.options = {}, s.options.compress = this.flags.compress !== !1, typeof r[r.length - 1] == "function") {
      const f = this.ids++, h = r.pop();
      this._registerAckCallback(f, h), s.id = f;
    }
    const a = (n = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || n === void 0 ? void 0 : n.writable, u = this.connected && !(!((o = this.io.engine) === null || o === void 0) && o._hasPingExpired());
    return this.flags.volatile && !a || (u ? (this.notifyOutgoingListeners(s), this.packet(s)) : this.sendBuffer.push(s)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, r) {
    var i;
    const n = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (n === void 0) {
      this.acks[t] = r;
      return;
    }
    const o = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      r.call(this, new Error("operation has timed out"));
    }, n), s = (...a) => {
      this.io.clearTimeoutFn(o), r.apply(this, a);
    };
    s.withError = !0, this.acks[t] = s;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...r) {
    return new Promise((i, n) => {
      const o = (s, a) => s ? n(s) : i(a);
      o.withError = !0, r.push(o), this.emit(t, ...r);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let r;
    typeof t[t.length - 1] == "function" && (r = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((n, ...o) => i !== this._queue[0] ? void 0 : (n !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), r && r(n)) : (this._queue.shift(), r && r(null, ...o)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const r = this._queue[0];
    r.pending && !t || (r.pending = !0, r.tryCount++, this.flags = r.flags, this.emit.apply(this, r.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: Jt.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, r) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, r), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((i) => String(i.id) === t)) {
        const i = this.acks[t];
        delete this.acks[t], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case Jt.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case Jt.EVENT:
        case Jt.BINARY_EVENT:
          this.onevent(t);
          break;
        case Jt.ACK:
        case Jt.BINARY_ACK:
          this.onack(t);
          break;
        case Jt.DISCONNECT:
          this.ondisconnect();
          break;
        case Jt.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const r = t.data || [];
    t.id != null && r.push(this.ack(t.id)), this.connected ? this.emitEvent(r) : this.receiveBuffer.push(Object.freeze(r));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const r = this._anyListeners.slice();
      for (const i of r)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const r = this;
    let i = !1;
    return function(...n) {
      i || (i = !0, r.packet({
        type: Jt.ACK,
        id: t,
        data: n
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const r = this.acks[t.id];
    typeof r == "function" && (delete this.acks[t.id], r.withError && t.data.unshift(null), r.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, r) {
    this.id = t, this.recovered = r && this._pid === r, this._pid = r, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: Jt.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const r = this._anyListeners;
      for (let i = 0; i < r.length; i++)
        if (t === r[i])
          return r.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const r = this._anyOutgoingListeners;
      for (let i = 0; i < r.length; i++)
        if (t === r[i])
          return r.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const r = this._anyOutgoingListeners.slice();
      for (const i of r)
        i.apply(this, t.data);
    }
  }
}
function Qo(e) {
  e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0;
}
Qo.prototype.duration = function() {
  var e = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), r = Math.floor(t * this.jitter * e);
    e = (Math.floor(t * 10) & 1) == 0 ? e - r : e + r;
  }
  return Math.min(e, this.max) | 0;
};
Qo.prototype.reset = function() {
  this.attempts = 0;
};
Qo.prototype.setMin = function(e) {
  this.ms = e;
};
Qo.prototype.setMax = function(e) {
  this.max = e;
};
Qo.prototype.setJitter = function(e) {
  this.jitter = e;
};
class Gp extends Vr {
  constructor(t, r) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (r = t, t = void 0), r = r || {}, r.path = r.path || "/socket.io", this.opts = r, mc(this, r), this.reconnection(r.reconnection !== !1), this.reconnectionAttempts(r.reconnectionAttempts || 1 / 0), this.reconnectionDelay(r.reconnectionDelay || 1e3), this.reconnectionDelayMax(r.reconnectionDelayMax || 5e3), this.randomizationFactor((i = r.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Qo({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(r.timeout == null ? 2e4 : r.timeout), this._readyState = "closed", this.uri = t;
    const n = r.parser || eB;
    this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this._autoConnect = r.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var r;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (r = this.backoff) === null || r === void 0 || r.setMin(t), this);
  }
  randomizationFactor(t) {
    var r;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (r = this.backoff) === null || r === void 0 || r.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var r;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (r = this.backoff) === null || r === void 0 || r.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new BL(this.uri, this.opts);
    const r = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const n = Zn(r, "open", function() {
      i.onopen(), t && t();
    }), o = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), t ? t(a) : this.maybeReconnectOnOpen();
    }, s = Zn(r, "error", o);
    if (this._timeout !== !1) {
      const a = this._timeout, u = this.setTimeoutFn(() => {
        n(), o(new Error("timeout")), r.close();
      }, a);
      this.opts.autoUnref && u.unref(), this.subs.push(() => {
        this.clearTimeoutFn(u);
      });
    }
    return this.subs.push(n), this.subs.push(s), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      Zn(t, "ping", this.onping.bind(this)),
      Zn(t, "data", this.ondata.bind(this)),
      Zn(t, "error", this.onerror.bind(this)),
      Zn(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      Zn(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (r) {
      this.onclose("parse error", r);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    dc(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, r) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new fj(this, t, r), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const r = Object.keys(this.nsps);
    for (const i of r)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const r = this.encoder.encode(t);
    for (let i = 0; i < r.length; i++)
      this.engine.write(r[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, r) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, r), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const r = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((n) => {
          n ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", n)) : t.onreconnect();
        }));
      }, r);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const ca = {};
function el(e, t) {
  typeof e == "object" && (t = e, e = void 0), t = t || {};
  const r = qL(e, t.path || "/socket.io"), i = r.source, n = r.id, o = r.path, s = ca[n] && o in ca[n].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || s;
  let u;
  return a ? u = new Gp(i, t) : (ca[n] || (ca[n] = new Gp(i, t)), u = ca[n]), r.query && !t.query && (t.query = r.queryKey), u.socket(r.path, t);
}
Object.assign(el, {
  Manager: Gp,
  Socket: fj,
  io: el,
  connect: el
});
function Is(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var tl = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
var Wb;
function rB() {
  return Wb || (Wb = 1, (function(e, t) {
    (function(r) {
      e.exports = r();
    })(function() {
      return (function r(i, n, o) {
        function s(c, f) {
          if (!n[c]) {
            if (!i[c]) {
              var h = typeof Is == "function" && Is;
              if (!f && h) return h(c, !0);
              if (a) return a(c, !0);
              var y = new Error("Cannot find module '" + c + "'");
              throw y.code = "MODULE_NOT_FOUND", y;
            }
            var p = n[c] = { exports: {} };
            i[c][0].call(p.exports, function(l) {
              var d = i[c][1][l];
              return s(d || l);
            }, p, p.exports, r, i, n, o);
          }
          return n[c].exports;
        }
        for (var a = typeof Is == "function" && Is, u = 0; u < o.length; u++) s(o[u]);
        return s;
      })({ 1: [function(r, i, n) {
        var o = r("./utils"), s = r("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        n.encode = function(u) {
          for (var c, f, h, y, p, l, d, v = [], m = 0, g = u.length, _ = g, b = o.getTypeOf(u) !== "string"; m < u.length; ) _ = g - m, h = b ? (c = u[m++], f = m < g ? u[m++] : 0, m < g ? u[m++] : 0) : (c = u.charCodeAt(m++), f = m < g ? u.charCodeAt(m++) : 0, m < g ? u.charCodeAt(m++) : 0), y = c >> 2, p = (3 & c) << 4 | f >> 4, l = 1 < _ ? (15 & f) << 2 | h >> 6 : 64, d = 2 < _ ? 63 & h : 64, v.push(a.charAt(y) + a.charAt(p) + a.charAt(l) + a.charAt(d));
          return v.join("");
        }, n.decode = function(u) {
          var c, f, h, y, p, l, d = 0, v = 0, m = "data:";
          if (u.substr(0, m.length) === m) throw new Error("Invalid base64 input, it looks like a data url.");
          var g, _ = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (u.charAt(u.length - 1) === a.charAt(64) && _--, u.charAt(u.length - 2) === a.charAt(64) && _--, _ % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (g = s.uint8array ? new Uint8Array(0 | _) : new Array(0 | _); d < u.length; ) c = a.indexOf(u.charAt(d++)) << 2 | (y = a.indexOf(u.charAt(d++))) >> 4, f = (15 & y) << 4 | (p = a.indexOf(u.charAt(d++))) >> 2, h = (3 & p) << 6 | (l = a.indexOf(u.charAt(d++))), g[v++] = c, p !== 64 && (g[v++] = f), l !== 64 && (g[v++] = h);
          return g;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(r, i, n) {
        var o = r("./external"), s = r("./stream/DataWorker"), a = r("./stream/Crc32Probe"), u = r("./stream/DataLengthProbe");
        function c(f, h, y, p, l) {
          this.compressedSize = f, this.uncompressedSize = h, this.crc32 = y, this.compression = p, this.compressedContent = l;
        }
        c.prototype = { getContentWorker: function() {
          var f = new s(o.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), h = this;
          return f.on("end", function() {
            if (this.streamInfo.data_length !== h.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), f;
        }, getCompressedWorker: function() {
          return new s(o.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, c.createWorkerFrom = function(f, h, y) {
          return f.pipe(new a()).pipe(new u("uncompressedSize")).pipe(h.compressWorker(y)).pipe(new u("compressedSize")).withStreamInfo("compression", h);
        }, i.exports = c;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(r, i, n) {
        var o = r("./stream/GenericWorker");
        n.STORE = { magic: "\0\0", compressWorker: function() {
          return new o("STORE compression");
        }, uncompressWorker: function() {
          return new o("STORE decompression");
        } }, n.DEFLATE = r("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(r, i, n) {
        var o = r("./utils"), s = (function() {
          for (var a, u = [], c = 0; c < 256; c++) {
            a = c;
            for (var f = 0; f < 8; f++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
            u[c] = a;
          }
          return u;
        })();
        i.exports = function(a, u) {
          return a !== void 0 && a.length ? o.getTypeOf(a) !== "string" ? (function(c, f, h, y) {
            var p = s, l = y + h;
            c ^= -1;
            for (var d = y; d < l; d++) c = c >>> 8 ^ p[255 & (c ^ f[d])];
            return -1 ^ c;
          })(0 | u, a, a.length, 0) : (function(c, f, h, y) {
            var p = s, l = y + h;
            c ^= -1;
            for (var d = y; d < l; d++) c = c >>> 8 ^ p[255 & (c ^ f.charCodeAt(d))];
            return -1 ^ c;
          })(0 | u, a, a.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(r, i, n) {
        n.base64 = !1, n.binary = !1, n.dir = !1, n.createFolders = !0, n.date = null, n.compression = null, n.compressionOptions = null, n.comment = null, n.unixPermissions = null, n.dosPermissions = null;
      }, {}], 6: [function(r, i, n) {
        var o = null;
        o = typeof Promise < "u" ? Promise : r("lie"), i.exports = { Promise: o };
      }, { lie: 37 }], 7: [function(r, i, n) {
        var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", s = r("pako"), a = r("./utils"), u = r("./stream/GenericWorker"), c = o ? "uint8array" : "array";
        function f(h, y) {
          u.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = y, this.meta = {};
        }
        n.magic = "\b\0", a.inherits(f, u), f.prototype.processChunk = function(h) {
          this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, h.data), !1);
        }, f.prototype.flush = function() {
          u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
        }, f.prototype.cleanUp = function() {
          u.prototype.cleanUp.call(this), this._pako = null;
        }, f.prototype._createPako = function() {
          this._pako = new s[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
          var h = this;
          this._pako.onData = function(y) {
            h.push({ data: y, meta: h.meta });
          };
        }, n.compressWorker = function(h) {
          return new f("Deflate", h);
        }, n.uncompressWorker = function() {
          return new f("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(r, i, n) {
        function o(p, l) {
          var d, v = "";
          for (d = 0; d < l; d++) v += String.fromCharCode(255 & p), p >>>= 8;
          return v;
        }
        function s(p, l, d, v, m, g) {
          var _, b, w = p.file, A = p.compression, E = g !== c.utf8encode, O = a.transformTo("string", g(w.name)), $ = a.transformTo("string", c.utf8encode(w.name)), k = w.comment, j = a.transformTo("string", g(k)), P = a.transformTo("string", c.utf8encode(k)), R = $.length !== w.name.length, I = P.length !== k.length, z = "", W = "", F = "", te = w.dir, ee = w.date, V = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          l && !d || (V.crc32 = p.crc32, V.compressedSize = p.compressedSize, V.uncompressedSize = p.uncompressedSize);
          var T = 0;
          l && (T |= 8), E || !R && !I || (T |= 2048);
          var D = 0, L = 0;
          te && (D |= 16), m === "UNIX" ? (L = 798, D |= (function(N, Z) {
            var Y = N;
            return N || (Y = Z ? 16893 : 33204), (65535 & Y) << 16;
          })(w.unixPermissions, te)) : (L = 20, D |= (function(N) {
            return 63 & (N || 0);
          })(w.dosPermissions)), _ = ee.getUTCHours(), _ <<= 6, _ |= ee.getUTCMinutes(), _ <<= 5, _ |= ee.getUTCSeconds() / 2, b = ee.getUTCFullYear() - 1980, b <<= 4, b |= ee.getUTCMonth() + 1, b <<= 5, b |= ee.getUTCDate(), R && (W = o(1, 1) + o(f(O), 4) + $, z += "up" + o(W.length, 2) + W), I && (F = o(1, 1) + o(f(j), 4) + P, z += "uc" + o(F.length, 2) + F);
          var M = "";
          return M += `
\0`, M += o(T, 2), M += A.magic, M += o(_, 2), M += o(b, 2), M += o(V.crc32, 4), M += o(V.compressedSize, 4), M += o(V.uncompressedSize, 4), M += o(O.length, 2), M += o(z.length, 2), { fileRecord: h.LOCAL_FILE_HEADER + M + O + z, dirRecord: h.CENTRAL_FILE_HEADER + o(L, 2) + M + o(j.length, 2) + "\0\0\0\0" + o(D, 4) + o(v, 4) + O + z + j };
        }
        var a = r("../utils"), u = r("../stream/GenericWorker"), c = r("../utf8"), f = r("../crc32"), h = r("../signature");
        function y(p, l, d, v) {
          u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = l, this.zipPlatform = d, this.encodeFileName = v, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        a.inherits(y, u), y.prototype.push = function(p) {
          var l = p.meta.percent || 0, d = this.entriesCount, v = this._sources.length;
          this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, u.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: d ? (l + 100 * (d - v - 1)) / d : 100 } }));
        }, y.prototype.openedSource = function(p) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
          var l = this.streamFiles && !p.file.dir;
          if (l) {
            var d = s(p, l, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: d.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = !0;
        }, y.prototype.closedSource = function(p) {
          this.accumulate = !1;
          var l = this.streamFiles && !p.file.dir, d = s(p, l, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(d.dirRecord), l) this.push({ data: (function(v) {
            return h.DATA_DESCRIPTOR + o(v.crc32, 4) + o(v.compressedSize, 4) + o(v.uncompressedSize, 4);
          })(p), meta: { percent: 100 } });
          else for (this.push({ data: d.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, y.prototype.flush = function() {
          for (var p = this.bytesWritten, l = 0; l < this.dirRecords.length; l++) this.push({ data: this.dirRecords[l], meta: { percent: 100 } });
          var d = this.bytesWritten - p, v = (function(m, g, _, b, w) {
            var A = a.transformTo("string", w(b));
            return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + o(m, 2) + o(m, 2) + o(g, 4) + o(_, 4) + o(A.length, 2) + A;
          })(this.dirRecords.length, d, p, this.zipComment, this.encodeFileName);
          this.push({ data: v, meta: { percent: 100 } });
        }, y.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, y.prototype.registerPrevious = function(p) {
          this._sources.push(p);
          var l = this;
          return p.on("data", function(d) {
            l.processChunk(d);
          }), p.on("end", function() {
            l.closedSource(l.previous.streamInfo), l._sources.length ? l.prepareNextSource() : l.end();
          }), p.on("error", function(d) {
            l.error(d);
          }), this;
        }, y.prototype.resume = function() {
          return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
        }, y.prototype.error = function(p) {
          var l = this._sources;
          if (!u.prototype.error.call(this, p)) return !1;
          for (var d = 0; d < l.length; d++) try {
            l[d].error(p);
          } catch {
          }
          return !0;
        }, y.prototype.lock = function() {
          u.prototype.lock.call(this);
          for (var p = this._sources, l = 0; l < p.length; l++) p[l].lock();
        }, i.exports = y;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(r, i, n) {
        var o = r("../compressions"), s = r("./ZipFileWorker");
        n.generateWorker = function(a, u, c) {
          var f = new s(u.streamFiles, c, u.platform, u.encodeFileName), h = 0;
          try {
            a.forEach(function(y, p) {
              h++;
              var l = (function(g, _) {
                var b = g || _, w = o[b];
                if (!w) throw new Error(b + " is not a valid compression method !");
                return w;
              })(p.options.compression, u.compression), d = p.options.compressionOptions || u.compressionOptions || {}, v = p.dir, m = p.date;
              p._compressWorker(l, d).withStreamInfo("file", { name: y, dir: v, date: m, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(f);
            }), f.entriesCount = h;
          } catch (y) {
            f.error(y);
          }
          return f;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(r, i, n) {
        function o() {
          if (!(this instanceof o)) return new o();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var s = new o();
            for (var a in this) typeof this[a] != "function" && (s[a] = this[a]);
            return s;
          };
        }
        (o.prototype = r("./object")).loadAsync = r("./load"), o.support = r("./support"), o.defaults = r("./defaults"), o.version = "3.10.1", o.loadAsync = function(s, a) {
          return new o().loadAsync(s, a);
        }, o.external = r("./external"), i.exports = o;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(r, i, n) {
        var o = r("./utils"), s = r("./external"), a = r("./utf8"), u = r("./zipEntries"), c = r("./stream/Crc32Probe"), f = r("./nodejsUtils");
        function h(y) {
          return new s.Promise(function(p, l) {
            var d = y.decompressed.getContentWorker().pipe(new c());
            d.on("error", function(v) {
              l(v);
            }).on("end", function() {
              d.streamInfo.crc32 !== y.decompressed.crc32 ? l(new Error("Corrupted zip : CRC32 mismatch")) : p();
            }).resume();
          });
        }
        i.exports = function(y, p) {
          var l = this;
          return p = o.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), f.isNode && f.isStream(y) ? s.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : o.prepareContent("the loaded zip file", y, !0, p.optimizedBinaryString, p.base64).then(function(d) {
            var v = new u(p);
            return v.load(d), v;
          }).then(function(d) {
            var v = [s.Promise.resolve(d)], m = d.files;
            if (p.checkCRC32) for (var g = 0; g < m.length; g++) v.push(h(m[g]));
            return s.Promise.all(v);
          }).then(function(d) {
            for (var v = d.shift(), m = v.files, g = 0; g < m.length; g++) {
              var _ = m[g], b = _.fileNameStr, w = o.resolve(_.fileNameStr);
              l.file(w, _.decompressed, { binary: !0, optimizedBinaryString: !0, date: _.date, dir: _.dir, comment: _.fileCommentStr.length ? _.fileCommentStr : null, unixPermissions: _.unixPermissions, dosPermissions: _.dosPermissions, createFolders: p.createFolders }), _.dir || (l.file(w).unsafeOriginalName = b);
            }
            return v.zipComment.length && (l.comment = v.zipComment), l;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(r, i, n) {
        var o = r("../utils"), s = r("../stream/GenericWorker");
        function a(u, c) {
          s.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(c);
        }
        o.inherits(a, s), a.prototype._bindStream = function(u) {
          var c = this;
          (this._stream = u).pause(), u.on("data", function(f) {
            c.push({ data: f, meta: { percent: 0 } });
          }).on("error", function(f) {
            c.isPaused ? this.generatedError = f : c.error(f);
          }).on("end", function() {
            c.isPaused ? c._upstreamEnded = !0 : c.end();
          });
        }, a.prototype.pause = function() {
          return !!s.prototype.pause.call(this) && (this._stream.pause(), !0);
        }, a.prototype.resume = function() {
          return !!s.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
        }, i.exports = a;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(r, i, n) {
        var o = r("readable-stream").Readable;
        function s(a, u, c) {
          o.call(this, u), this._helper = a;
          var f = this;
          a.on("data", function(h, y) {
            f.push(h) || f._helper.pause(), c && c(y);
          }).on("error", function(h) {
            f.emit("error", h);
          }).on("end", function() {
            f.push(null);
          });
        }
        r("../utils").inherits(s, o), s.prototype._read = function() {
          this._helper.resume();
        }, i.exports = s;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(r, i, n) {
        i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(o, s) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(o, s);
          if (typeof o == "number") throw new Error('The "data" argument must not be a number');
          return new Buffer(o, s);
        }, allocBuffer: function(o) {
          if (Buffer.alloc) return Buffer.alloc(o);
          var s = new Buffer(o);
          return s.fill(0), s;
        }, isBuffer: function(o) {
          return Buffer.isBuffer(o);
        }, isStream: function(o) {
          return o && typeof o.on == "function" && typeof o.pause == "function" && typeof o.resume == "function";
        } };
      }, {}], 15: [function(r, i, n) {
        function o(w, A, E) {
          var O, $ = a.getTypeOf(A), k = a.extend(E || {}, f);
          k.date = k.date || /* @__PURE__ */ new Date(), k.compression !== null && (k.compression = k.compression.toUpperCase()), typeof k.unixPermissions == "string" && (k.unixPermissions = parseInt(k.unixPermissions, 8)), k.unixPermissions && 16384 & k.unixPermissions && (k.dir = !0), k.dosPermissions && 16 & k.dosPermissions && (k.dir = !0), k.dir && (w = m(w)), k.createFolders && (O = v(w)) && g.call(this, O, !0);
          var j = $ === "string" && k.binary === !1 && k.base64 === !1;
          E && E.binary !== void 0 || (k.binary = !j), (A instanceof h && A.uncompressedSize === 0 || k.dir || !A || A.length === 0) && (k.base64 = !1, k.binary = !0, A = "", k.compression = "STORE", $ = "string");
          var P = null;
          P = A instanceof h || A instanceof u ? A : l.isNode && l.isStream(A) ? new d(w, A) : a.prepareContent(w, A, k.binary, k.optimizedBinaryString, k.base64);
          var R = new y(w, P, k);
          this.files[w] = R;
        }
        var s = r("./utf8"), a = r("./utils"), u = r("./stream/GenericWorker"), c = r("./stream/StreamHelper"), f = r("./defaults"), h = r("./compressedObject"), y = r("./zipObject"), p = r("./generate"), l = r("./nodejsUtils"), d = r("./nodejs/NodejsStreamInputAdapter"), v = function(w) {
          w.slice(-1) === "/" && (w = w.substring(0, w.length - 1));
          var A = w.lastIndexOf("/");
          return 0 < A ? w.substring(0, A) : "";
        }, m = function(w) {
          return w.slice(-1) !== "/" && (w += "/"), w;
        }, g = function(w, A) {
          return A = A !== void 0 ? A : f.createFolders, w = m(w), this.files[w] || o.call(this, w, null, { dir: !0, createFolders: A }), this.files[w];
        };
        function _(w) {
          return Object.prototype.toString.call(w) === "[object RegExp]";
        }
        var b = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(w) {
          var A, E, O;
          for (A in this.files) O = this.files[A], (E = A.slice(this.root.length, A.length)) && A.slice(0, this.root.length) === this.root && w(E, O);
        }, filter: function(w) {
          var A = [];
          return this.forEach(function(E, O) {
            w(E, O) && A.push(O);
          }), A;
        }, file: function(w, A, E) {
          if (arguments.length !== 1) return w = this.root + w, o.call(this, w, A, E), this;
          if (_(w)) {
            var O = w;
            return this.filter(function(k, j) {
              return !j.dir && O.test(k);
            });
          }
          var $ = this.files[this.root + w];
          return $ && !$.dir ? $ : null;
        }, folder: function(w) {
          if (!w) return this;
          if (_(w)) return this.filter(function($, k) {
            return k.dir && w.test($);
          });
          var A = this.root + w, E = g.call(this, A), O = this.clone();
          return O.root = E.name, O;
        }, remove: function(w) {
          w = this.root + w;
          var A = this.files[w];
          if (A || (w.slice(-1) !== "/" && (w += "/"), A = this.files[w]), A && !A.dir) delete this.files[w];
          else for (var E = this.filter(function($, k) {
            return k.name.slice(0, w.length) === w;
          }), O = 0; O < E.length; O++) delete this.files[E[O].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(w) {
          var A, E = {};
          try {
            if ((E = a.extend(w || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: s.utf8encode })).type = E.type.toLowerCase(), E.compression = E.compression.toUpperCase(), E.type === "binarystring" && (E.type = "string"), !E.type) throw new Error("No output type specified.");
            a.checkSupport(E.type), E.platform !== "darwin" && E.platform !== "freebsd" && E.platform !== "linux" && E.platform !== "sunos" || (E.platform = "UNIX"), E.platform === "win32" && (E.platform = "DOS");
            var O = E.comment || this.comment || "";
            A = p.generateWorker(this, E, O);
          } catch ($) {
            (A = new u("error")).error($);
          }
          return new c(A, E.type || "string", E.mimeType);
        }, generateAsync: function(w, A) {
          return this.generateInternalStream(w).accumulate(A);
        }, generateNodeStream: function(w, A) {
          return (w = w || {}).type || (w.type = "nodebuffer"), this.generateInternalStream(w).toNodejsStream(A);
        } };
        i.exports = b;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(r, i, n) {
        i.exports = r("stream");
      }, { stream: void 0 }], 17: [function(r, i, n) {
        var o = r("./DataReader");
        function s(a) {
          o.call(this, a);
          for (var u = 0; u < this.data.length; u++) a[u] = 255 & a[u];
        }
        r("../utils").inherits(s, o), s.prototype.byteAt = function(a) {
          return this.data[this.zero + a];
        }, s.prototype.lastIndexOfSignature = function(a) {
          for (var u = a.charCodeAt(0), c = a.charCodeAt(1), f = a.charCodeAt(2), h = a.charCodeAt(3), y = this.length - 4; 0 <= y; --y) if (this.data[y] === u && this.data[y + 1] === c && this.data[y + 2] === f && this.data[y + 3] === h) return y - this.zero;
          return -1;
        }, s.prototype.readAndCheckSignature = function(a) {
          var u = a.charCodeAt(0), c = a.charCodeAt(1), f = a.charCodeAt(2), h = a.charCodeAt(3), y = this.readData(4);
          return u === y[0] && c === y[1] && f === y[2] && h === y[3];
        }, s.prototype.readData = function(a) {
          if (this.checkOffset(a), a === 0) return [];
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, u;
        }, i.exports = s;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(r, i, n) {
        var o = r("../utils");
        function s(a) {
          this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
        }
        s.prototype = { checkOffset: function(a) {
          this.checkIndex(this.index + a);
        }, checkIndex: function(a) {
          if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
        }, setIndex: function(a) {
          this.checkIndex(a), this.index = a;
        }, skip: function(a) {
          this.setIndex(this.index + a);
        }, byteAt: function() {
        }, readInt: function(a) {
          var u, c = 0;
          for (this.checkOffset(a), u = this.index + a - 1; u >= this.index; u--) c = (c << 8) + this.byteAt(u);
          return this.index += a, c;
        }, readString: function(a) {
          return o.transformTo("string", this.readData(a));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var a = this.readInt(4);
          return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
        } }, i.exports = s;
      }, { "../utils": 32 }], 19: [function(r, i, n) {
        var o = r("./Uint8ArrayReader");
        function s(a) {
          o.call(this, a);
        }
        r("../utils").inherits(s, o), s.prototype.readData = function(a) {
          this.checkOffset(a);
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, u;
        }, i.exports = s;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(r, i, n) {
        var o = r("./DataReader");
        function s(a) {
          o.call(this, a);
        }
        r("../utils").inherits(s, o), s.prototype.byteAt = function(a) {
          return this.data.charCodeAt(this.zero + a);
        }, s.prototype.lastIndexOfSignature = function(a) {
          return this.data.lastIndexOf(a) - this.zero;
        }, s.prototype.readAndCheckSignature = function(a) {
          return a === this.readData(4);
        }, s.prototype.readData = function(a) {
          this.checkOffset(a);
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, u;
        }, i.exports = s;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(r, i, n) {
        var o = r("./ArrayReader");
        function s(a) {
          o.call(this, a);
        }
        r("../utils").inherits(s, o), s.prototype.readData = function(a) {
          if (this.checkOffset(a), a === 0) return new Uint8Array(0);
          var u = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
          return this.index += a, u;
        }, i.exports = s;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(r, i, n) {
        var o = r("../utils"), s = r("../support"), a = r("./ArrayReader"), u = r("./StringReader"), c = r("./NodeBufferReader"), f = r("./Uint8ArrayReader");
        i.exports = function(h) {
          var y = o.getTypeOf(h);
          return o.checkSupport(y), y !== "string" || s.uint8array ? y === "nodebuffer" ? new c(h) : s.uint8array ? new f(o.transformTo("uint8array", h)) : new a(o.transformTo("array", h)) : new u(h);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(r, i, n) {
        n.LOCAL_FILE_HEADER = "PK", n.CENTRAL_FILE_HEADER = "PK", n.CENTRAL_DIRECTORY_END = "PK", n.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", n.ZIP64_CENTRAL_DIRECTORY_END = "PK", n.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(r, i, n) {
        var o = r("./GenericWorker"), s = r("../utils");
        function a(u) {
          o.call(this, "ConvertWorker to " + u), this.destType = u;
        }
        s.inherits(a, o), a.prototype.processChunk = function(u) {
          this.push({ data: s.transformTo(this.destType, u.data), meta: u.meta });
        }, i.exports = a;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(r, i, n) {
        var o = r("./GenericWorker"), s = r("../crc32");
        function a() {
          o.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        r("../utils").inherits(a, o), a.prototype.processChunk = function(u) {
          this.streamInfo.crc32 = s(u.data, this.streamInfo.crc32 || 0), this.push(u);
        }, i.exports = a;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(r, i, n) {
        var o = r("../utils"), s = r("./GenericWorker");
        function a(u) {
          s.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
        }
        o.inherits(a, s), a.prototype.processChunk = function(u) {
          if (u) {
            var c = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = c + u.data.length;
          }
          s.prototype.processChunk.call(this, u);
        }, i.exports = a;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(r, i, n) {
        var o = r("../utils"), s = r("./GenericWorker");
        function a(u) {
          s.call(this, "DataWorker");
          var c = this;
          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(f) {
            c.dataIsReady = !0, c.data = f, c.max = f && f.length || 0, c.type = o.getTypeOf(f), c.isPaused || c._tickAndRepeat();
          }, function(f) {
            c.error(f);
          });
        }
        o.inherits(a, s), a.prototype.cleanUp = function() {
          s.prototype.cleanUp.call(this), this.data = null;
        }, a.prototype.resume = function() {
          return !!s.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, o.delay(this._tickAndRepeat, [], this)), !0);
        }, a.prototype._tickAndRepeat = function() {
          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (o.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
        }, a.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return !1;
          var u = null, c = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              u = this.data.substring(this.index, c);
              break;
            case "uint8array":
              u = this.data.subarray(this.index, c);
              break;
            case "array":
            case "nodebuffer":
              u = this.data.slice(this.index, c);
          }
          return this.index = c, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, i.exports = a;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(r, i, n) {
        function o(s) {
          this.name = s || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        o.prototype = { push: function(s) {
          this.emit("data", s);
        }, end: function() {
          if (this.isFinished) return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (s) {
            this.emit("error", s);
          }
          return !0;
        }, error: function(s) {
          return !this.isFinished && (this.isPaused ? this.generatedError = s : (this.isFinished = !0, this.emit("error", s), this.previous && this.previous.error(s), this.cleanUp()), !0);
        }, on: function(s, a) {
          return this._listeners[s].push(a), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(s, a) {
          if (this._listeners[s]) for (var u = 0; u < this._listeners[s].length; u++) this._listeners[s][u].call(this, a);
        }, pipe: function(s) {
          return s.registerPrevious(this);
        }, registerPrevious: function(s) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = s.streamInfo, this.mergeStreamInfo(), this.previous = s;
          var a = this;
          return s.on("data", function(u) {
            a.processChunk(u);
          }), s.on("end", function() {
            a.end();
          }), s.on("error", function(u) {
            a.error(u);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return !1;
          var s = this.isPaused = !1;
          return this.generatedError && (this.error(this.generatedError), s = !0), this.previous && this.previous.resume(), !s;
        }, flush: function() {
        }, processChunk: function(s) {
          this.push(s);
        }, withStreamInfo: function(s, a) {
          return this.extraStreamInfo[s] = a, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var s in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, s) && (this.streamInfo[s] = this.extraStreamInfo[s]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        }, toString: function() {
          var s = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + s : s;
        } }, i.exports = o;
      }, {}], 29: [function(r, i, n) {
        var o = r("../utils"), s = r("./ConvertWorker"), a = r("./GenericWorker"), u = r("../base64"), c = r("../support"), f = r("../external"), h = null;
        if (c.nodestream) try {
          h = r("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
        function y(l, d) {
          return new f.Promise(function(v, m) {
            var g = [], _ = l._internalType, b = l._outputType, w = l._mimeType;
            l.on("data", function(A, E) {
              g.push(A), d && d(E);
            }).on("error", function(A) {
              g = [], m(A);
            }).on("end", function() {
              try {
                var A = (function(E, O, $) {
                  switch (E) {
                    case "blob":
                      return o.newBlob(o.transformTo("arraybuffer", O), $);
                    case "base64":
                      return u.encode(O);
                    default:
                      return o.transformTo(E, O);
                  }
                })(b, (function(E, O) {
                  var $, k = 0, j = null, P = 0;
                  for ($ = 0; $ < O.length; $++) P += O[$].length;
                  switch (E) {
                    case "string":
                      return O.join("");
                    case "array":
                      return Array.prototype.concat.apply([], O);
                    case "uint8array":
                      for (j = new Uint8Array(P), $ = 0; $ < O.length; $++) j.set(O[$], k), k += O[$].length;
                      return j;
                    case "nodebuffer":
                      return Buffer.concat(O);
                    default:
                      throw new Error("concat : unsupported type '" + E + "'");
                  }
                })(_, g), w);
                v(A);
              } catch (E) {
                m(E);
              }
              g = [];
            }).resume();
          });
        }
        function p(l, d, v) {
          var m = d;
          switch (d) {
            case "blob":
            case "arraybuffer":
              m = "uint8array";
              break;
            case "base64":
              m = "string";
          }
          try {
            this._internalType = m, this._outputType = d, this._mimeType = v, o.checkSupport(m), this._worker = l.pipe(new s(m)), l.lock();
          } catch (g) {
            this._worker = new a("error"), this._worker.error(g);
          }
        }
        p.prototype = { accumulate: function(l) {
          return y(this, l);
        }, on: function(l, d) {
          var v = this;
          return l === "data" ? this._worker.on(l, function(m) {
            d.call(v, m.data, m.meta);
          }) : this._worker.on(l, function() {
            o.delay(d, arguments, v);
          }), this;
        }, resume: function() {
          return o.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(l) {
          if (o.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
          return new h(this, { objectMode: this._outputType !== "nodebuffer" }, l);
        } }, i.exports = p;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(r, i, n) {
        if (n.base64 = !0, n.array = !0, n.string = !0, n.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", n.nodebuffer = typeof Buffer < "u", n.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") n.blob = !1;
        else {
          var o = new ArrayBuffer(0);
          try {
            n.blob = new Blob([o], { type: "application/zip" }).size === 0;
          } catch {
            try {
              var s = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              s.append(o), n.blob = s.getBlob("application/zip").size === 0;
            } catch {
              n.blob = !1;
            }
          }
        }
        try {
          n.nodestream = !!r("readable-stream").Readable;
        } catch {
          n.nodestream = !1;
        }
      }, { "readable-stream": 16 }], 31: [function(r, i, n) {
        for (var o = r("./utils"), s = r("./support"), a = r("./nodejsUtils"), u = r("./stream/GenericWorker"), c = new Array(256), f = 0; f < 256; f++) c[f] = 252 <= f ? 6 : 248 <= f ? 5 : 240 <= f ? 4 : 224 <= f ? 3 : 192 <= f ? 2 : 1;
        c[254] = c[254] = 1;
        function h() {
          u.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function y() {
          u.call(this, "utf-8 encode");
        }
        n.utf8encode = function(p) {
          return s.nodebuffer ? a.newBufferFrom(p, "utf-8") : (function(l) {
            var d, v, m, g, _, b = l.length, w = 0;
            for (g = 0; g < b; g++) (64512 & (v = l.charCodeAt(g))) == 55296 && g + 1 < b && (64512 & (m = l.charCodeAt(g + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), g++), w += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
            for (d = s.uint8array ? new Uint8Array(w) : new Array(w), g = _ = 0; _ < w; g++) (64512 & (v = l.charCodeAt(g))) == 55296 && g + 1 < b && (64512 & (m = l.charCodeAt(g + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (m - 56320), g++), v < 128 ? d[_++] = v : (v < 2048 ? d[_++] = 192 | v >>> 6 : (v < 65536 ? d[_++] = 224 | v >>> 12 : (d[_++] = 240 | v >>> 18, d[_++] = 128 | v >>> 12 & 63), d[_++] = 128 | v >>> 6 & 63), d[_++] = 128 | 63 & v);
            return d;
          })(p);
        }, n.utf8decode = function(p) {
          return s.nodebuffer ? o.transformTo("nodebuffer", p).toString("utf-8") : (function(l) {
            var d, v, m, g, _ = l.length, b = new Array(2 * _);
            for (d = v = 0; d < _; ) if ((m = l[d++]) < 128) b[v++] = m;
            else if (4 < (g = c[m])) b[v++] = 65533, d += g - 1;
            else {
              for (m &= g === 2 ? 31 : g === 3 ? 15 : 7; 1 < g && d < _; ) m = m << 6 | 63 & l[d++], g--;
              1 < g ? b[v++] = 65533 : m < 65536 ? b[v++] = m : (m -= 65536, b[v++] = 55296 | m >> 10 & 1023, b[v++] = 56320 | 1023 & m);
            }
            return b.length !== v && (b.subarray ? b = b.subarray(0, v) : b.length = v), o.applyFromCharCode(b);
          })(p = o.transformTo(s.uint8array ? "uint8array" : "array", p));
        }, o.inherits(h, u), h.prototype.processChunk = function(p) {
          var l = o.transformTo(s.uint8array ? "uint8array" : "array", p.data);
          if (this.leftOver && this.leftOver.length) {
            if (s.uint8array) {
              var d = l;
              (l = new Uint8Array(d.length + this.leftOver.length)).set(this.leftOver, 0), l.set(d, this.leftOver.length);
            } else l = this.leftOver.concat(l);
            this.leftOver = null;
          }
          var v = (function(g, _) {
            var b;
            for ((_ = _ || g.length) > g.length && (_ = g.length), b = _ - 1; 0 <= b && (192 & g[b]) == 128; ) b--;
            return b < 0 || b === 0 ? _ : b + c[g[b]] > _ ? b : _;
          })(l), m = l;
          v !== l.length && (s.uint8array ? (m = l.subarray(0, v), this.leftOver = l.subarray(v, l.length)) : (m = l.slice(0, v), this.leftOver = l.slice(v, l.length))), this.push({ data: n.utf8decode(m), meta: p.meta });
        }, h.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: n.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, n.Utf8DecodeWorker = h, o.inherits(y, u), y.prototype.processChunk = function(p) {
          this.push({ data: n.utf8encode(p.data), meta: p.meta });
        }, n.Utf8EncodeWorker = y;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(r, i, n) {
        var o = r("./support"), s = r("./base64"), a = r("./nodejsUtils"), u = r("./external");
        function c(d) {
          return d;
        }
        function f(d, v) {
          for (var m = 0; m < d.length; ++m) v[m] = 255 & d.charCodeAt(m);
          return v;
        }
        r("setimmediate"), n.newBlob = function(d, v) {
          n.checkSupport("blob");
          try {
            return new Blob([d], { type: v });
          } catch {
            try {
              var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return m.append(d), m.getBlob(v);
            } catch {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var h = { stringifyByChunk: function(d, v, m) {
          var g = [], _ = 0, b = d.length;
          if (b <= m) return String.fromCharCode.apply(null, d);
          for (; _ < b; ) v === "array" || v === "nodebuffer" ? g.push(String.fromCharCode.apply(null, d.slice(_, Math.min(_ + m, b)))) : g.push(String.fromCharCode.apply(null, d.subarray(_, Math.min(_ + m, b)))), _ += m;
          return g.join("");
        }, stringifyByChar: function(d) {
          for (var v = "", m = 0; m < d.length; m++) v += String.fromCharCode(d[m]);
          return v;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch {
            return !1;
          }
        })(), nodebuffer: (function() {
          try {
            return o.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
          } catch {
            return !1;
          }
        })() } };
        function y(d) {
          var v = 65536, m = n.getTypeOf(d), g = !0;
          if (m === "uint8array" ? g = h.applyCanBeUsed.uint8array : m === "nodebuffer" && (g = h.applyCanBeUsed.nodebuffer), g) for (; 1 < v; ) try {
            return h.stringifyByChunk(d, m, v);
          } catch {
            v = Math.floor(v / 2);
          }
          return h.stringifyByChar(d);
        }
        function p(d, v) {
          for (var m = 0; m < d.length; m++) v[m] = d[m];
          return v;
        }
        n.applyFromCharCode = y;
        var l = {};
        l.string = { string: c, array: function(d) {
          return f(d, new Array(d.length));
        }, arraybuffer: function(d) {
          return l.string.uint8array(d).buffer;
        }, uint8array: function(d) {
          return f(d, new Uint8Array(d.length));
        }, nodebuffer: function(d) {
          return f(d, a.allocBuffer(d.length));
        } }, l.array = { string: y, array: c, arraybuffer: function(d) {
          return new Uint8Array(d).buffer;
        }, uint8array: function(d) {
          return new Uint8Array(d);
        }, nodebuffer: function(d) {
          return a.newBufferFrom(d);
        } }, l.arraybuffer = { string: function(d) {
          return y(new Uint8Array(d));
        }, array: function(d) {
          return p(new Uint8Array(d), new Array(d.byteLength));
        }, arraybuffer: c, uint8array: function(d) {
          return new Uint8Array(d);
        }, nodebuffer: function(d) {
          return a.newBufferFrom(new Uint8Array(d));
        } }, l.uint8array = { string: y, array: function(d) {
          return p(d, new Array(d.length));
        }, arraybuffer: function(d) {
          return d.buffer;
        }, uint8array: c, nodebuffer: function(d) {
          return a.newBufferFrom(d);
        } }, l.nodebuffer = { string: y, array: function(d) {
          return p(d, new Array(d.length));
        }, arraybuffer: function(d) {
          return l.nodebuffer.uint8array(d).buffer;
        }, uint8array: function(d) {
          return p(d, new Uint8Array(d.length));
        }, nodebuffer: c }, n.transformTo = function(d, v) {
          if (v = v || "", !d) return v;
          n.checkSupport(d);
          var m = n.getTypeOf(v);
          return l[m][d](v);
        }, n.resolve = function(d) {
          for (var v = d.split("/"), m = [], g = 0; g < v.length; g++) {
            var _ = v[g];
            _ === "." || _ === "" && g !== 0 && g !== v.length - 1 || (_ === ".." ? m.pop() : m.push(_));
          }
          return m.join("/");
        }, n.getTypeOf = function(d) {
          return typeof d == "string" ? "string" : Object.prototype.toString.call(d) === "[object Array]" ? "array" : o.nodebuffer && a.isBuffer(d) ? "nodebuffer" : o.uint8array && d instanceof Uint8Array ? "uint8array" : o.arraybuffer && d instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, n.checkSupport = function(d) {
          if (!o[d.toLowerCase()]) throw new Error(d + " is not supported by this platform");
        }, n.MAX_VALUE_16BITS = 65535, n.MAX_VALUE_32BITS = -1, n.pretty = function(d) {
          var v, m, g = "";
          for (m = 0; m < (d || "").length; m++) g += "\\x" + ((v = d.charCodeAt(m)) < 16 ? "0" : "") + v.toString(16).toUpperCase();
          return g;
        }, n.delay = function(d, v, m) {
          setImmediate(function() {
            d.apply(m || null, v || []);
          });
        }, n.inherits = function(d, v) {
          function m() {
          }
          m.prototype = v.prototype, d.prototype = new m();
        }, n.extend = function() {
          var d, v, m = {};
          for (d = 0; d < arguments.length; d++) for (v in arguments[d]) Object.prototype.hasOwnProperty.call(arguments[d], v) && m[v] === void 0 && (m[v] = arguments[d][v]);
          return m;
        }, n.prepareContent = function(d, v, m, g, _) {
          return u.Promise.resolve(v).then(function(b) {
            return o.blob && (b instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(b)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(w, A) {
              var E = new FileReader();
              E.onload = function(O) {
                w(O.target.result);
              }, E.onerror = function(O) {
                A(O.target.error);
              }, E.readAsArrayBuffer(b);
            }) : b;
          }).then(function(b) {
            var w = n.getTypeOf(b);
            return w ? (w === "arraybuffer" ? b = n.transformTo("uint8array", b) : w === "string" && (_ ? b = s.decode(b) : m && g !== !0 && (b = (function(A) {
              return f(A, o.uint8array ? new Uint8Array(A.length) : new Array(A.length));
            })(b))), b) : u.Promise.reject(new Error("Can't read the data of '" + d + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(r, i, n) {
        var o = r("./reader/readerFor"), s = r("./utils"), a = r("./signature"), u = r("./zipEntry"), c = r("./support");
        function f(h) {
          this.files = [], this.loadOptions = h;
        }
        f.prototype = { checkSignature: function(h) {
          if (!this.reader.readAndCheckSignature(h)) {
            this.reader.index -= 4;
            var y = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + s.pretty(y) + ", expected " + s.pretty(h) + ")");
          }
        }, isSignature: function(h, y) {
          var p = this.reader.index;
          this.reader.setIndex(h);
          var l = this.reader.readString(4) === y;
          return this.reader.setIndex(p), l;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var h = this.reader.readData(this.zipCommentLength), y = c.uint8array ? "uint8array" : "array", p = s.transformTo(y, h);
          this.zipComment = this.loadOptions.decodeFileName(p);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var h, y, p, l = this.zip64EndOfCentralSize - 44; 0 < l; ) h = this.reader.readInt(2), y = this.reader.readInt(4), p = this.reader.readData(y), this.zip64ExtensibleData[h] = { id: h, length: y, value: p };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var h, y;
          for (h = 0; h < this.files.length; h++) y = this.files[h], this.reader.setIndex(y.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), y.readLocalPart(this.reader), y.handleUTF8(), y.processAttributes();
        }, readCentralDir: function() {
          var h;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (h = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var h = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
          if (h < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          this.reader.setIndex(h);
          var y = h;
          if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === s.MAX_VALUE_16BITS || this.diskWithCentralDirStart === s.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === s.MAX_VALUE_16BITS || this.centralDirRecords === s.MAX_VALUE_16BITS || this.centralDirSize === s.MAX_VALUE_32BITS || this.centralDirOffset === s.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, (h = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(h), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var p = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
          var l = y - p;
          if (0 < l) this.isSignature(y, a.CENTRAL_FILE_HEADER) || (this.reader.zero = l);
          else if (l < 0) throw new Error("Corrupted zip: missing " + Math.abs(l) + " bytes.");
        }, prepareReader: function(h) {
          this.reader = o(h);
        }, load: function(h) {
          this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, i.exports = f;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(r, i, n) {
        var o = r("./reader/readerFor"), s = r("./utils"), a = r("./compressedObject"), u = r("./crc32"), c = r("./utf8"), f = r("./compressions"), h = r("./support");
        function y(p, l) {
          this.options = p, this.loadOptions = l;
        }
        y.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(p) {
          var l, d;
          if (p.skip(22), this.fileNameLength = p.readInt(2), d = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(d), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((l = (function(v) {
            for (var m in f) if (Object.prototype.hasOwnProperty.call(f, m) && f[m].magic === v) return f[m];
            return null;
          })(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, l, p.readData(this.compressedSize));
        }, readCentralPart: function(p) {
          this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
          var l = p.readInt(2);
          if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          p.skip(l), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var p = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var p = o(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
          }
        }, readExtraFields: function(p) {
          var l, d, v, m = p.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); p.index + 4 < m; ) l = p.readInt(2), d = p.readInt(2), v = p.readData(d), this.extraFields[l] = { id: l, length: d, value: v };
          p.setIndex(m);
        }, handleUTF8: function() {
          var p = h.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
          else {
            var l = this.findExtraFieldUnicodePath();
            if (l !== null) this.fileNameStr = l;
            else {
              var d = s.transformTo(p, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(d);
            }
            var v = this.findExtraFieldUnicodeComment();
            if (v !== null) this.fileCommentStr = v;
            else {
              var m = s.transformTo(p, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(m);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var p = this.extraFields[28789];
          if (p) {
            var l = o(p.value);
            return l.readInt(1) !== 1 || u(this.fileName) !== l.readInt(4) ? null : c.utf8decode(l.readData(p.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var p = this.extraFields[25461];
          if (p) {
            var l = o(p.value);
            return l.readInt(1) !== 1 || u(this.fileComment) !== l.readInt(4) ? null : c.utf8decode(l.readData(p.length - 5));
          }
          return null;
        } }, i.exports = y;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(r, i, n) {
        function o(l, d, v) {
          this.name = l, this.dir = v.dir, this.date = v.date, this.comment = v.comment, this.unixPermissions = v.unixPermissions, this.dosPermissions = v.dosPermissions, this._data = d, this._dataBinary = v.binary, this.options = { compression: v.compression, compressionOptions: v.compressionOptions };
        }
        var s = r("./stream/StreamHelper"), a = r("./stream/DataWorker"), u = r("./utf8"), c = r("./compressedObject"), f = r("./stream/GenericWorker");
        o.prototype = { internalStream: function(l) {
          var d = null, v = "string";
          try {
            if (!l) throw new Error("No output type specified.");
            var m = (v = l.toLowerCase()) === "string" || v === "text";
            v !== "binarystring" && v !== "text" || (v = "string"), d = this._decompressWorker();
            var g = !this._dataBinary;
            g && !m && (d = d.pipe(new u.Utf8EncodeWorker())), !g && m && (d = d.pipe(new u.Utf8DecodeWorker()));
          } catch (_) {
            (d = new f("error")).error(_);
          }
          return new s(d, v, "");
        }, async: function(l, d) {
          return this.internalStream(l).accumulate(d);
        }, nodeStream: function(l, d) {
          return this.internalStream(l || "nodebuffer").toNodejsStream(d);
        }, _compressWorker: function(l, d) {
          if (this._data instanceof c && this._data.compression.magic === l.magic) return this._data.getCompressedWorker();
          var v = this._decompressWorker();
          return this._dataBinary || (v = v.pipe(new u.Utf8EncodeWorker())), c.createWorkerFrom(v, l, d);
        }, _decompressWorker: function() {
          return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof f ? this._data : new a(this._data);
        } };
        for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], y = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, p = 0; p < h.length; p++) o.prototype[h[p]] = y;
        i.exports = o;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(r, i, n) {
        (function(o) {
          var s, a, u = o.MutationObserver || o.WebKitMutationObserver;
          if (u) {
            var c = 0, f = new u(l), h = o.document.createTextNode("");
            f.observe(h, { characterData: !0 }), s = function() {
              h.data = c = ++c % 2;
            };
          } else if (o.setImmediate || o.MessageChannel === void 0) s = "document" in o && "onreadystatechange" in o.document.createElement("script") ? function() {
            var d = o.document.createElement("script");
            d.onreadystatechange = function() {
              l(), d.onreadystatechange = null, d.parentNode.removeChild(d), d = null;
            }, o.document.documentElement.appendChild(d);
          } : function() {
            setTimeout(l, 0);
          };
          else {
            var y = new o.MessageChannel();
            y.port1.onmessage = l, s = function() {
              y.port2.postMessage(0);
            };
          }
          var p = [];
          function l() {
            var d, v;
            a = !0;
            for (var m = p.length; m; ) {
              for (v = p, p = [], d = -1; ++d < m; ) v[d]();
              m = p.length;
            }
            a = !1;
          }
          i.exports = function(d) {
            p.push(d) !== 1 || a || s();
          };
        }).call(this, typeof Ji < "u" ? Ji : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 37: [function(r, i, n) {
        var o = r("immediate");
        function s() {
        }
        var a = {}, u = ["REJECTED"], c = ["FULFILLED"], f = ["PENDING"];
        function h(m) {
          if (typeof m != "function") throw new TypeError("resolver must be a function");
          this.state = f, this.queue = [], this.outcome = void 0, m !== s && d(this, m);
        }
        function y(m, g, _) {
          this.promise = m, typeof g == "function" && (this.onFulfilled = g, this.callFulfilled = this.otherCallFulfilled), typeof _ == "function" && (this.onRejected = _, this.callRejected = this.otherCallRejected);
        }
        function p(m, g, _) {
          o(function() {
            var b;
            try {
              b = g(_);
            } catch (w) {
              return a.reject(m, w);
            }
            b === m ? a.reject(m, new TypeError("Cannot resolve promise with itself")) : a.resolve(m, b);
          });
        }
        function l(m) {
          var g = m && m.then;
          if (m && (typeof m == "object" || typeof m == "function") && typeof g == "function") return function() {
            g.apply(m, arguments);
          };
        }
        function d(m, g) {
          var _ = !1;
          function b(E) {
            _ || (_ = !0, a.reject(m, E));
          }
          function w(E) {
            _ || (_ = !0, a.resolve(m, E));
          }
          var A = v(function() {
            g(w, b);
          });
          A.status === "error" && b(A.value);
        }
        function v(m, g) {
          var _ = {};
          try {
            _.value = m(g), _.status = "success";
          } catch (b) {
            _.status = "error", _.value = b;
          }
          return _;
        }
        (i.exports = h).prototype.finally = function(m) {
          if (typeof m != "function") return this;
          var g = this.constructor;
          return this.then(function(_) {
            return g.resolve(m()).then(function() {
              return _;
            });
          }, function(_) {
            return g.resolve(m()).then(function() {
              throw _;
            });
          });
        }, h.prototype.catch = function(m) {
          return this.then(null, m);
        }, h.prototype.then = function(m, g) {
          if (typeof m != "function" && this.state === c || typeof g != "function" && this.state === u) return this;
          var _ = new this.constructor(s);
          return this.state !== f ? p(_, this.state === c ? m : g, this.outcome) : this.queue.push(new y(_, m, g)), _;
        }, y.prototype.callFulfilled = function(m) {
          a.resolve(this.promise, m);
        }, y.prototype.otherCallFulfilled = function(m) {
          p(this.promise, this.onFulfilled, m);
        }, y.prototype.callRejected = function(m) {
          a.reject(this.promise, m);
        }, y.prototype.otherCallRejected = function(m) {
          p(this.promise, this.onRejected, m);
        }, a.resolve = function(m, g) {
          var _ = v(l, g);
          if (_.status === "error") return a.reject(m, _.value);
          var b = _.value;
          if (b) d(m, b);
          else {
            m.state = c, m.outcome = g;
            for (var w = -1, A = m.queue.length; ++w < A; ) m.queue[w].callFulfilled(g);
          }
          return m;
        }, a.reject = function(m, g) {
          m.state = u, m.outcome = g;
          for (var _ = -1, b = m.queue.length; ++_ < b; ) m.queue[_].callRejected(g);
          return m;
        }, h.resolve = function(m) {
          return m instanceof this ? m : a.resolve(new this(s), m);
        }, h.reject = function(m) {
          var g = new this(s);
          return a.reject(g, m);
        }, h.all = function(m) {
          var g = this;
          if (Object.prototype.toString.call(m) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var _ = m.length, b = !1;
          if (!_) return this.resolve([]);
          for (var w = new Array(_), A = 0, E = -1, O = new this(s); ++E < _; ) $(m[E], E);
          return O;
          function $(k, j) {
            g.resolve(k).then(function(P) {
              w[j] = P, ++A !== _ || b || (b = !0, a.resolve(O, w));
            }, function(P) {
              b || (b = !0, a.reject(O, P));
            });
          }
        }, h.race = function(m) {
          var g = this;
          if (Object.prototype.toString.call(m) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var _ = m.length, b = !1;
          if (!_) return this.resolve([]);
          for (var w = -1, A = new this(s); ++w < _; ) E = m[w], g.resolve(E).then(function(O) {
            b || (b = !0, a.resolve(A, O));
          }, function(O) {
            b || (b = !0, a.reject(A, O));
          });
          var E;
          return A;
        };
      }, { immediate: 36 }], 38: [function(r, i, n) {
        var o = {};
        (0, r("./lib/utils/common").assign)(o, r("./lib/deflate"), r("./lib/inflate"), r("./lib/zlib/constants")), i.exports = o;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(r, i, n) {
        var o = r("./zlib/deflate"), s = r("./utils/common"), a = r("./utils/strings"), u = r("./zlib/messages"), c = r("./zlib/zstream"), f = Object.prototype.toString, h = 0, y = -1, p = 0, l = 8;
        function d(m) {
          if (!(this instanceof d)) return new d(m);
          this.options = s.assign({ level: y, method: l, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, m || {});
          var g = this.options;
          g.raw && 0 < g.windowBits ? g.windowBits = -g.windowBits : g.gzip && 0 < g.windowBits && g.windowBits < 16 && (g.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
          var _ = o.deflateInit2(this.strm, g.level, g.method, g.windowBits, g.memLevel, g.strategy);
          if (_ !== h) throw new Error(u[_]);
          if (g.header && o.deflateSetHeader(this.strm, g.header), g.dictionary) {
            var b;
            if (b = typeof g.dictionary == "string" ? a.string2buf(g.dictionary) : f.call(g.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(g.dictionary) : g.dictionary, (_ = o.deflateSetDictionary(this.strm, b)) !== h) throw new Error(u[_]);
            this._dict_set = !0;
          }
        }
        function v(m, g) {
          var _ = new d(g);
          if (_.push(m, !0), _.err) throw _.msg || u[_.err];
          return _.result;
        }
        d.prototype.push = function(m, g) {
          var _, b, w = this.strm, A = this.options.chunkSize;
          if (this.ended) return !1;
          b = g === ~~g ? g : g === !0 ? 4 : 0, typeof m == "string" ? w.input = a.string2buf(m) : f.call(m) === "[object ArrayBuffer]" ? w.input = new Uint8Array(m) : w.input = m, w.next_in = 0, w.avail_in = w.input.length;
          do {
            if (w.avail_out === 0 && (w.output = new s.Buf8(A), w.next_out = 0, w.avail_out = A), (_ = o.deflate(w, b)) !== 1 && _ !== h) return this.onEnd(_), !(this.ended = !0);
            w.avail_out !== 0 && (w.avail_in !== 0 || b !== 4 && b !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(s.shrinkBuf(w.output, w.next_out))) : this.onData(s.shrinkBuf(w.output, w.next_out)));
          } while ((0 < w.avail_in || w.avail_out === 0) && _ !== 1);
          return b === 4 ? (_ = o.deflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === h) : b !== 2 || (this.onEnd(h), !(w.avail_out = 0));
        }, d.prototype.onData = function(m) {
          this.chunks.push(m);
        }, d.prototype.onEnd = function(m) {
          m === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
        }, n.Deflate = d, n.deflate = v, n.deflateRaw = function(m, g) {
          return (g = g || {}).raw = !0, v(m, g);
        }, n.gzip = function(m, g) {
          return (g = g || {}).gzip = !0, v(m, g);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(r, i, n) {
        var o = r("./zlib/inflate"), s = r("./utils/common"), a = r("./utils/strings"), u = r("./zlib/constants"), c = r("./zlib/messages"), f = r("./zlib/zstream"), h = r("./zlib/gzheader"), y = Object.prototype.toString;
        function p(d) {
          if (!(this instanceof p)) return new p(d);
          this.options = s.assign({ chunkSize: 16384, windowBits: 0, to: "" }, d || {});
          var v = this.options;
          v.raw && 0 <= v.windowBits && v.windowBits < 16 && (v.windowBits = -v.windowBits, v.windowBits === 0 && (v.windowBits = -15)), !(0 <= v.windowBits && v.windowBits < 16) || d && d.windowBits || (v.windowBits += 32), 15 < v.windowBits && v.windowBits < 48 && (15 & v.windowBits) == 0 && (v.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
          var m = o.inflateInit2(this.strm, v.windowBits);
          if (m !== u.Z_OK) throw new Error(c[m]);
          this.header = new h(), o.inflateGetHeader(this.strm, this.header);
        }
        function l(d, v) {
          var m = new p(v);
          if (m.push(d, !0), m.err) throw m.msg || c[m.err];
          return m.result;
        }
        p.prototype.push = function(d, v) {
          var m, g, _, b, w, A, E = this.strm, O = this.options.chunkSize, $ = this.options.dictionary, k = !1;
          if (this.ended) return !1;
          g = v === ~~v ? v : v === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof d == "string" ? E.input = a.binstring2buf(d) : y.call(d) === "[object ArrayBuffer]" ? E.input = new Uint8Array(d) : E.input = d, E.next_in = 0, E.avail_in = E.input.length;
          do {
            if (E.avail_out === 0 && (E.output = new s.Buf8(O), E.next_out = 0, E.avail_out = O), (m = o.inflate(E, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && $ && (A = typeof $ == "string" ? a.string2buf($) : y.call($) === "[object ArrayBuffer]" ? new Uint8Array($) : $, m = o.inflateSetDictionary(this.strm, A)), m === u.Z_BUF_ERROR && k === !0 && (m = u.Z_OK, k = !1), m !== u.Z_STREAM_END && m !== u.Z_OK) return this.onEnd(m), !(this.ended = !0);
            E.next_out && (E.avail_out !== 0 && m !== u.Z_STREAM_END && (E.avail_in !== 0 || g !== u.Z_FINISH && g !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (_ = a.utf8border(E.output, E.next_out), b = E.next_out - _, w = a.buf2string(E.output, _), E.next_out = b, E.avail_out = O - b, b && s.arraySet(E.output, E.output, _, b, 0), this.onData(w)) : this.onData(s.shrinkBuf(E.output, E.next_out)))), E.avail_in === 0 && E.avail_out === 0 && (k = !0);
          } while ((0 < E.avail_in || E.avail_out === 0) && m !== u.Z_STREAM_END);
          return m === u.Z_STREAM_END && (g = u.Z_FINISH), g === u.Z_FINISH ? (m = o.inflateEnd(this.strm), this.onEnd(m), this.ended = !0, m === u.Z_OK) : g !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(E.avail_out = 0));
        }, p.prototype.onData = function(d) {
          this.chunks.push(d);
        }, p.prototype.onEnd = function(d) {
          d === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = d, this.msg = this.strm.msg;
        }, n.Inflate = p, n.inflate = l, n.inflateRaw = function(d, v) {
          return (v = v || {}).raw = !0, l(d, v);
        }, n.ungzip = l;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(r, i, n) {
        var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        n.assign = function(u) {
          for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
            var f = c.shift();
            if (f) {
              if (typeof f != "object") throw new TypeError(f + "must be non-object");
              for (var h in f) f.hasOwnProperty(h) && (u[h] = f[h]);
            }
          }
          return u;
        }, n.shrinkBuf = function(u, c) {
          return u.length === c ? u : u.subarray ? u.subarray(0, c) : (u.length = c, u);
        };
        var s = { arraySet: function(u, c, f, h, y) {
          if (c.subarray && u.subarray) u.set(c.subarray(f, f + h), y);
          else for (var p = 0; p < h; p++) u[y + p] = c[f + p];
        }, flattenChunks: function(u) {
          var c, f, h, y, p, l;
          for (c = h = 0, f = u.length; c < f; c++) h += u[c].length;
          for (l = new Uint8Array(h), c = y = 0, f = u.length; c < f; c++) p = u[c], l.set(p, y), y += p.length;
          return l;
        } }, a = { arraySet: function(u, c, f, h, y) {
          for (var p = 0; p < h; p++) u[y + p] = c[f + p];
        }, flattenChunks: function(u) {
          return [].concat.apply([], u);
        } };
        n.setTyped = function(u) {
          u ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, s)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, a));
        }, n.setTyped(o);
      }, {}], 42: [function(r, i, n) {
        var o = r("./common"), s = !0, a = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          s = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          a = !1;
        }
        for (var u = new o.Buf8(256), c = 0; c < 256; c++) u[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
        function f(h, y) {
          if (y < 65537 && (h.subarray && a || !h.subarray && s)) return String.fromCharCode.apply(null, o.shrinkBuf(h, y));
          for (var p = "", l = 0; l < y; l++) p += String.fromCharCode(h[l]);
          return p;
        }
        u[254] = u[254] = 1, n.string2buf = function(h) {
          var y, p, l, d, v, m = h.length, g = 0;
          for (d = 0; d < m; d++) (64512 & (p = h.charCodeAt(d))) == 55296 && d + 1 < m && (64512 & (l = h.charCodeAt(d + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (l - 56320), d++), g += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
          for (y = new o.Buf8(g), d = v = 0; v < g; d++) (64512 & (p = h.charCodeAt(d))) == 55296 && d + 1 < m && (64512 & (l = h.charCodeAt(d + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (l - 56320), d++), p < 128 ? y[v++] = p : (p < 2048 ? y[v++] = 192 | p >>> 6 : (p < 65536 ? y[v++] = 224 | p >>> 12 : (y[v++] = 240 | p >>> 18, y[v++] = 128 | p >>> 12 & 63), y[v++] = 128 | p >>> 6 & 63), y[v++] = 128 | 63 & p);
          return y;
        }, n.buf2binstring = function(h) {
          return f(h, h.length);
        }, n.binstring2buf = function(h) {
          for (var y = new o.Buf8(h.length), p = 0, l = y.length; p < l; p++) y[p] = h.charCodeAt(p);
          return y;
        }, n.buf2string = function(h, y) {
          var p, l, d, v, m = y || h.length, g = new Array(2 * m);
          for (p = l = 0; p < m; ) if ((d = h[p++]) < 128) g[l++] = d;
          else if (4 < (v = u[d])) g[l++] = 65533, p += v - 1;
          else {
            for (d &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && p < m; ) d = d << 6 | 63 & h[p++], v--;
            1 < v ? g[l++] = 65533 : d < 65536 ? g[l++] = d : (d -= 65536, g[l++] = 55296 | d >> 10 & 1023, g[l++] = 56320 | 1023 & d);
          }
          return f(g, l);
        }, n.utf8border = function(h, y) {
          var p;
          for ((y = y || h.length) > h.length && (y = h.length), p = y - 1; 0 <= p && (192 & h[p]) == 128; ) p--;
          return p < 0 || p === 0 ? y : p + u[h[p]] > y ? p : y;
        };
      }, { "./common": 41 }], 43: [function(r, i, n) {
        i.exports = function(o, s, a, u) {
          for (var c = 65535 & o | 0, f = o >>> 16 & 65535 | 0, h = 0; a !== 0; ) {
            for (a -= h = 2e3 < a ? 2e3 : a; f = f + (c = c + s[u++] | 0) | 0, --h; ) ;
            c %= 65521, f %= 65521;
          }
          return c | f << 16 | 0;
        };
      }, {}], 44: [function(r, i, n) {
        i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(r, i, n) {
        var o = (function() {
          for (var s, a = [], u = 0; u < 256; u++) {
            s = u;
            for (var c = 0; c < 8; c++) s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
            a[u] = s;
          }
          return a;
        })();
        i.exports = function(s, a, u, c) {
          var f = o, h = c + u;
          s ^= -1;
          for (var y = c; y < h; y++) s = s >>> 8 ^ f[255 & (s ^ a[y])];
          return -1 ^ s;
        };
      }, {}], 46: [function(r, i, n) {
        var o, s = r("../utils/common"), a = r("./trees"), u = r("./adler32"), c = r("./crc32"), f = r("./messages"), h = 0, y = 4, p = 0, l = -2, d = -1, v = 4, m = 2, g = 8, _ = 9, b = 286, w = 30, A = 19, E = 2 * b + 1, O = 15, $ = 3, k = 258, j = k + $ + 1, P = 42, R = 113, I = 1, z = 2, W = 3, F = 4;
        function te(x, U) {
          return x.msg = f[U], U;
        }
        function ee(x) {
          return (x << 1) - (4 < x ? 9 : 0);
        }
        function V(x) {
          for (var U = x.length; 0 <= --U; ) x[U] = 0;
        }
        function T(x) {
          var U = x.state, B = U.pending;
          B > x.avail_out && (B = x.avail_out), B !== 0 && (s.arraySet(x.output, U.pending_buf, U.pending_out, B, x.next_out), x.next_out += B, U.pending_out += B, x.total_out += B, x.avail_out -= B, U.pending -= B, U.pending === 0 && (U.pending_out = 0));
        }
        function D(x, U) {
          a._tr_flush_block(x, 0 <= x.block_start ? x.block_start : -1, x.strstart - x.block_start, U), x.block_start = x.strstart, T(x.strm);
        }
        function L(x, U) {
          x.pending_buf[x.pending++] = U;
        }
        function M(x, U) {
          x.pending_buf[x.pending++] = U >>> 8 & 255, x.pending_buf[x.pending++] = 255 & U;
        }
        function N(x, U) {
          var B, J, X = x.max_chain_length, oe = x.strstart, ye = x.prev_length, q = x.nice_match, G = x.strstart > x.w_size - j ? x.strstart - (x.w_size - j) : 0, ce = x.window, ue = x.w_mask, re = x.prev, pe = x.strstart + k, xe = ce[oe + ye - 1], be = ce[oe + ye];
          x.prev_length >= x.good_match && (X >>= 2), q > x.lookahead && (q = x.lookahead);
          do
            if (ce[(B = U) + ye] === be && ce[B + ye - 1] === xe && ce[B] === ce[oe] && ce[++B] === ce[oe + 1]) {
              oe += 2, B++;
              do
                ;
              while (ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && ce[++oe] === ce[++B] && oe < pe);
              if (J = k - (pe - oe), oe = pe - k, ye < J) {
                if (x.match_start = U, q <= (ye = J)) break;
                xe = ce[oe + ye - 1], be = ce[oe + ye];
              }
            }
          while ((U = re[U & ue]) > G && --X != 0);
          return ye <= x.lookahead ? ye : x.lookahead;
        }
        function Z(x) {
          var U, B, J, X, oe, ye, q, G, ce, ue, re = x.w_size;
          do {
            if (X = x.window_size - x.lookahead - x.strstart, x.strstart >= re + (re - j)) {
              for (s.arraySet(x.window, x.window, re, re, 0), x.match_start -= re, x.strstart -= re, x.block_start -= re, U = B = x.hash_size; J = x.head[--U], x.head[U] = re <= J ? J - re : 0, --B; ) ;
              for (U = B = re; J = x.prev[--U], x.prev[U] = re <= J ? J - re : 0, --B; ) ;
              X += re;
            }
            if (x.strm.avail_in === 0) break;
            if (ye = x.strm, q = x.window, G = x.strstart + x.lookahead, ce = X, ue = void 0, ue = ye.avail_in, ce < ue && (ue = ce), B = ue === 0 ? 0 : (ye.avail_in -= ue, s.arraySet(q, ye.input, ye.next_in, ue, G), ye.state.wrap === 1 ? ye.adler = u(ye.adler, q, ue, G) : ye.state.wrap === 2 && (ye.adler = c(ye.adler, q, ue, G)), ye.next_in += ue, ye.total_in += ue, ue), x.lookahead += B, x.lookahead + x.insert >= $) for (oe = x.strstart - x.insert, x.ins_h = x.window[oe], x.ins_h = (x.ins_h << x.hash_shift ^ x.window[oe + 1]) & x.hash_mask; x.insert && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[oe + $ - 1]) & x.hash_mask, x.prev[oe & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = oe, oe++, x.insert--, !(x.lookahead + x.insert < $)); ) ;
          } while (x.lookahead < j && x.strm.avail_in !== 0);
        }
        function Y(x, U) {
          for (var B, J; ; ) {
            if (x.lookahead < j) {
              if (Z(x), x.lookahead < j && U === h) return I;
              if (x.lookahead === 0) break;
            }
            if (B = 0, x.lookahead >= $ && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + $ - 1]) & x.hash_mask, B = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), B !== 0 && x.strstart - B <= x.w_size - j && (x.match_length = N(x, B)), x.match_length >= $) if (J = a._tr_tally(x, x.strstart - x.match_start, x.match_length - $), x.lookahead -= x.match_length, x.match_length <= x.max_lazy_match && x.lookahead >= $) {
              for (x.match_length--; x.strstart++, x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + $ - 1]) & x.hash_mask, B = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart, --x.match_length != 0; ) ;
              x.strstart++;
            } else x.strstart += x.match_length, x.match_length = 0, x.ins_h = x.window[x.strstart], x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + 1]) & x.hash_mask;
            else J = a._tr_tally(x, 0, x.window[x.strstart]), x.lookahead--, x.strstart++;
            if (J && (D(x, !1), x.strm.avail_out === 0)) return I;
          }
          return x.insert = x.strstart < $ - 1 ? x.strstart : $ - 1, U === y ? (D(x, !0), x.strm.avail_out === 0 ? W : F) : x.last_lit && (D(x, !1), x.strm.avail_out === 0) ? I : z;
        }
        function ie(x, U) {
          for (var B, J, X; ; ) {
            if (x.lookahead < j) {
              if (Z(x), x.lookahead < j && U === h) return I;
              if (x.lookahead === 0) break;
            }
            if (B = 0, x.lookahead >= $ && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + $ - 1]) & x.hash_mask, B = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), x.prev_length = x.match_length, x.prev_match = x.match_start, x.match_length = $ - 1, B !== 0 && x.prev_length < x.max_lazy_match && x.strstart - B <= x.w_size - j && (x.match_length = N(x, B), x.match_length <= 5 && (x.strategy === 1 || x.match_length === $ && 4096 < x.strstart - x.match_start) && (x.match_length = $ - 1)), x.prev_length >= $ && x.match_length <= x.prev_length) {
              for (X = x.strstart + x.lookahead - $, J = a._tr_tally(x, x.strstart - 1 - x.prev_match, x.prev_length - $), x.lookahead -= x.prev_length - 1, x.prev_length -= 2; ++x.strstart <= X && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + $ - 1]) & x.hash_mask, B = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), --x.prev_length != 0; ) ;
              if (x.match_available = 0, x.match_length = $ - 1, x.strstart++, J && (D(x, !1), x.strm.avail_out === 0)) return I;
            } else if (x.match_available) {
              if ((J = a._tr_tally(x, 0, x.window[x.strstart - 1])) && D(x, !1), x.strstart++, x.lookahead--, x.strm.avail_out === 0) return I;
            } else x.match_available = 1, x.strstart++, x.lookahead--;
          }
          return x.match_available && (J = a._tr_tally(x, 0, x.window[x.strstart - 1]), x.match_available = 0), x.insert = x.strstart < $ - 1 ? x.strstart : $ - 1, U === y ? (D(x, !0), x.strm.avail_out === 0 ? W : F) : x.last_lit && (D(x, !1), x.strm.avail_out === 0) ? I : z;
        }
        function le(x, U, B, J, X) {
          this.good_length = x, this.max_lazy = U, this.nice_length = B, this.max_chain = J, this.func = X;
        }
        function de() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = g, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new s.Buf16(2 * E), this.dyn_dtree = new s.Buf16(2 * (2 * w + 1)), this.bl_tree = new s.Buf16(2 * (2 * A + 1)), V(this.dyn_ltree), V(this.dyn_dtree), V(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new s.Buf16(O + 1), this.heap = new s.Buf16(2 * b + 1), V(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new s.Buf16(2 * b + 1), V(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function ae(x) {
          var U;
          return x && x.state ? (x.total_in = x.total_out = 0, x.data_type = m, (U = x.state).pending = 0, U.pending_out = 0, U.wrap < 0 && (U.wrap = -U.wrap), U.status = U.wrap ? P : R, x.adler = U.wrap === 2 ? 0 : 1, U.last_flush = h, a._tr_init(U), p) : te(x, l);
        }
        function ne(x) {
          var U = ae(x);
          return U === p && (function(B) {
            B.window_size = 2 * B.w_size, V(B.head), B.max_lazy_match = o[B.level].max_lazy, B.good_match = o[B.level].good_length, B.nice_match = o[B.level].nice_length, B.max_chain_length = o[B.level].max_chain, B.strstart = 0, B.block_start = 0, B.lookahead = 0, B.insert = 0, B.match_length = B.prev_length = $ - 1, B.match_available = 0, B.ins_h = 0;
          })(x.state), U;
        }
        function he(x, U, B, J, X, oe) {
          if (!x) return l;
          var ye = 1;
          if (U === d && (U = 6), J < 0 ? (ye = 0, J = -J) : 15 < J && (ye = 2, J -= 16), X < 1 || _ < X || B !== g || J < 8 || 15 < J || U < 0 || 9 < U || oe < 0 || v < oe) return te(x, l);
          J === 8 && (J = 9);
          var q = new de();
          return (x.state = q).strm = x, q.wrap = ye, q.gzhead = null, q.w_bits = J, q.w_size = 1 << q.w_bits, q.w_mask = q.w_size - 1, q.hash_bits = X + 7, q.hash_size = 1 << q.hash_bits, q.hash_mask = q.hash_size - 1, q.hash_shift = ~~((q.hash_bits + $ - 1) / $), q.window = new s.Buf8(2 * q.w_size), q.head = new s.Buf16(q.hash_size), q.prev = new s.Buf16(q.w_size), q.lit_bufsize = 1 << X + 6, q.pending_buf_size = 4 * q.lit_bufsize, q.pending_buf = new s.Buf8(q.pending_buf_size), q.d_buf = 1 * q.lit_bufsize, q.l_buf = 3 * q.lit_bufsize, q.level = U, q.strategy = oe, q.method = B, ne(x);
        }
        o = [new le(0, 0, 0, 0, function(x, U) {
          var B = 65535;
          for (B > x.pending_buf_size - 5 && (B = x.pending_buf_size - 5); ; ) {
            if (x.lookahead <= 1) {
              if (Z(x), x.lookahead === 0 && U === h) return I;
              if (x.lookahead === 0) break;
            }
            x.strstart += x.lookahead, x.lookahead = 0;
            var J = x.block_start + B;
            if ((x.strstart === 0 || x.strstart >= J) && (x.lookahead = x.strstart - J, x.strstart = J, D(x, !1), x.strm.avail_out === 0) || x.strstart - x.block_start >= x.w_size - j && (D(x, !1), x.strm.avail_out === 0)) return I;
          }
          return x.insert = 0, U === y ? (D(x, !0), x.strm.avail_out === 0 ? W : F) : (x.strstart > x.block_start && (D(x, !1), x.strm.avail_out), I);
        }), new le(4, 4, 8, 4, Y), new le(4, 5, 16, 8, Y), new le(4, 6, 32, 32, Y), new le(4, 4, 16, 16, ie), new le(8, 16, 32, 32, ie), new le(8, 16, 128, 128, ie), new le(8, 32, 128, 256, ie), new le(32, 128, 258, 1024, ie), new le(32, 258, 258, 4096, ie)], n.deflateInit = function(x, U) {
          return he(x, U, g, 15, 8, 0);
        }, n.deflateInit2 = he, n.deflateReset = ne, n.deflateResetKeep = ae, n.deflateSetHeader = function(x, U) {
          return x && x.state ? x.state.wrap !== 2 ? l : (x.state.gzhead = U, p) : l;
        }, n.deflate = function(x, U) {
          var B, J, X, oe;
          if (!x || !x.state || 5 < U || U < 0) return x ? te(x, l) : l;
          if (J = x.state, !x.output || !x.input && x.avail_in !== 0 || J.status === 666 && U !== y) return te(x, x.avail_out === 0 ? -5 : l);
          if (J.strm = x, B = J.last_flush, J.last_flush = U, J.status === P) if (J.wrap === 2) x.adler = 0, L(J, 31), L(J, 139), L(J, 8), J.gzhead ? (L(J, (J.gzhead.text ? 1 : 0) + (J.gzhead.hcrc ? 2 : 0) + (J.gzhead.extra ? 4 : 0) + (J.gzhead.name ? 8 : 0) + (J.gzhead.comment ? 16 : 0)), L(J, 255 & J.gzhead.time), L(J, J.gzhead.time >> 8 & 255), L(J, J.gzhead.time >> 16 & 255), L(J, J.gzhead.time >> 24 & 255), L(J, J.level === 9 ? 2 : 2 <= J.strategy || J.level < 2 ? 4 : 0), L(J, 255 & J.gzhead.os), J.gzhead.extra && J.gzhead.extra.length && (L(J, 255 & J.gzhead.extra.length), L(J, J.gzhead.extra.length >> 8 & 255)), J.gzhead.hcrc && (x.adler = c(x.adler, J.pending_buf, J.pending, 0)), J.gzindex = 0, J.status = 69) : (L(J, 0), L(J, 0), L(J, 0), L(J, 0), L(J, 0), L(J, J.level === 9 ? 2 : 2 <= J.strategy || J.level < 2 ? 4 : 0), L(J, 3), J.status = R);
          else {
            var ye = g + (J.w_bits - 8 << 4) << 8;
            ye |= (2 <= J.strategy || J.level < 2 ? 0 : J.level < 6 ? 1 : J.level === 6 ? 2 : 3) << 6, J.strstart !== 0 && (ye |= 32), ye += 31 - ye % 31, J.status = R, M(J, ye), J.strstart !== 0 && (M(J, x.adler >>> 16), M(J, 65535 & x.adler)), x.adler = 1;
          }
          if (J.status === 69) if (J.gzhead.extra) {
            for (X = J.pending; J.gzindex < (65535 & J.gzhead.extra.length) && (J.pending !== J.pending_buf_size || (J.gzhead.hcrc && J.pending > X && (x.adler = c(x.adler, J.pending_buf, J.pending - X, X)), T(x), X = J.pending, J.pending !== J.pending_buf_size)); ) L(J, 255 & J.gzhead.extra[J.gzindex]), J.gzindex++;
            J.gzhead.hcrc && J.pending > X && (x.adler = c(x.adler, J.pending_buf, J.pending - X, X)), J.gzindex === J.gzhead.extra.length && (J.gzindex = 0, J.status = 73);
          } else J.status = 73;
          if (J.status === 73) if (J.gzhead.name) {
            X = J.pending;
            do {
              if (J.pending === J.pending_buf_size && (J.gzhead.hcrc && J.pending > X && (x.adler = c(x.adler, J.pending_buf, J.pending - X, X)), T(x), X = J.pending, J.pending === J.pending_buf_size)) {
                oe = 1;
                break;
              }
              oe = J.gzindex < J.gzhead.name.length ? 255 & J.gzhead.name.charCodeAt(J.gzindex++) : 0, L(J, oe);
            } while (oe !== 0);
            J.gzhead.hcrc && J.pending > X && (x.adler = c(x.adler, J.pending_buf, J.pending - X, X)), oe === 0 && (J.gzindex = 0, J.status = 91);
          } else J.status = 91;
          if (J.status === 91) if (J.gzhead.comment) {
            X = J.pending;
            do {
              if (J.pending === J.pending_buf_size && (J.gzhead.hcrc && J.pending > X && (x.adler = c(x.adler, J.pending_buf, J.pending - X, X)), T(x), X = J.pending, J.pending === J.pending_buf_size)) {
                oe = 1;
                break;
              }
              oe = J.gzindex < J.gzhead.comment.length ? 255 & J.gzhead.comment.charCodeAt(J.gzindex++) : 0, L(J, oe);
            } while (oe !== 0);
            J.gzhead.hcrc && J.pending > X && (x.adler = c(x.adler, J.pending_buf, J.pending - X, X)), oe === 0 && (J.status = 103);
          } else J.status = 103;
          if (J.status === 103 && (J.gzhead.hcrc ? (J.pending + 2 > J.pending_buf_size && T(x), J.pending + 2 <= J.pending_buf_size && (L(J, 255 & x.adler), L(J, x.adler >> 8 & 255), x.adler = 0, J.status = R)) : J.status = R), J.pending !== 0) {
            if (T(x), x.avail_out === 0) return J.last_flush = -1, p;
          } else if (x.avail_in === 0 && ee(U) <= ee(B) && U !== y) return te(x, -5);
          if (J.status === 666 && x.avail_in !== 0) return te(x, -5);
          if (x.avail_in !== 0 || J.lookahead !== 0 || U !== h && J.status !== 666) {
            var q = J.strategy === 2 ? (function(G, ce) {
              for (var ue; ; ) {
                if (G.lookahead === 0 && (Z(G), G.lookahead === 0)) {
                  if (ce === h) return I;
                  break;
                }
                if (G.match_length = 0, ue = a._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++, ue && (D(G, !1), G.strm.avail_out === 0)) return I;
              }
              return G.insert = 0, ce === y ? (D(G, !0), G.strm.avail_out === 0 ? W : F) : G.last_lit && (D(G, !1), G.strm.avail_out === 0) ? I : z;
            })(J, U) : J.strategy === 3 ? (function(G, ce) {
              for (var ue, re, pe, xe, be = G.window; ; ) {
                if (G.lookahead <= k) {
                  if (Z(G), G.lookahead <= k && ce === h) return I;
                  if (G.lookahead === 0) break;
                }
                if (G.match_length = 0, G.lookahead >= $ && 0 < G.strstart && (re = be[pe = G.strstart - 1]) === be[++pe] && re === be[++pe] && re === be[++pe]) {
                  xe = G.strstart + k;
                  do
                    ;
                  while (re === be[++pe] && re === be[++pe] && re === be[++pe] && re === be[++pe] && re === be[++pe] && re === be[++pe] && re === be[++pe] && re === be[++pe] && pe < xe);
                  G.match_length = k - (xe - pe), G.match_length > G.lookahead && (G.match_length = G.lookahead);
                }
                if (G.match_length >= $ ? (ue = a._tr_tally(G, 1, G.match_length - $), G.lookahead -= G.match_length, G.strstart += G.match_length, G.match_length = 0) : (ue = a._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++), ue && (D(G, !1), G.strm.avail_out === 0)) return I;
              }
              return G.insert = 0, ce === y ? (D(G, !0), G.strm.avail_out === 0 ? W : F) : G.last_lit && (D(G, !1), G.strm.avail_out === 0) ? I : z;
            })(J, U) : o[J.level].func(J, U);
            if (q !== W && q !== F || (J.status = 666), q === I || q === W) return x.avail_out === 0 && (J.last_flush = -1), p;
            if (q === z && (U === 1 ? a._tr_align(J) : U !== 5 && (a._tr_stored_block(J, 0, 0, !1), U === 3 && (V(J.head), J.lookahead === 0 && (J.strstart = 0, J.block_start = 0, J.insert = 0))), T(x), x.avail_out === 0)) return J.last_flush = -1, p;
          }
          return U !== y ? p : J.wrap <= 0 ? 1 : (J.wrap === 2 ? (L(J, 255 & x.adler), L(J, x.adler >> 8 & 255), L(J, x.adler >> 16 & 255), L(J, x.adler >> 24 & 255), L(J, 255 & x.total_in), L(J, x.total_in >> 8 & 255), L(J, x.total_in >> 16 & 255), L(J, x.total_in >> 24 & 255)) : (M(J, x.adler >>> 16), M(J, 65535 & x.adler)), T(x), 0 < J.wrap && (J.wrap = -J.wrap), J.pending !== 0 ? p : 1);
        }, n.deflateEnd = function(x) {
          var U;
          return x && x.state ? (U = x.state.status) !== P && U !== 69 && U !== 73 && U !== 91 && U !== 103 && U !== R && U !== 666 ? te(x, l) : (x.state = null, U === R ? te(x, -3) : p) : l;
        }, n.deflateSetDictionary = function(x, U) {
          var B, J, X, oe, ye, q, G, ce, ue = U.length;
          if (!x || !x.state || (oe = (B = x.state).wrap) === 2 || oe === 1 && B.status !== P || B.lookahead) return l;
          for (oe === 1 && (x.adler = u(x.adler, U, ue, 0)), B.wrap = 0, ue >= B.w_size && (oe === 0 && (V(B.head), B.strstart = 0, B.block_start = 0, B.insert = 0), ce = new s.Buf8(B.w_size), s.arraySet(ce, U, ue - B.w_size, B.w_size, 0), U = ce, ue = B.w_size), ye = x.avail_in, q = x.next_in, G = x.input, x.avail_in = ue, x.next_in = 0, x.input = U, Z(B); B.lookahead >= $; ) {
            for (J = B.strstart, X = B.lookahead - ($ - 1); B.ins_h = (B.ins_h << B.hash_shift ^ B.window[J + $ - 1]) & B.hash_mask, B.prev[J & B.w_mask] = B.head[B.ins_h], B.head[B.ins_h] = J, J++, --X; ) ;
            B.strstart = J, B.lookahead = $ - 1, Z(B);
          }
          return B.strstart += B.lookahead, B.block_start = B.strstart, B.insert = B.lookahead, B.lookahead = 0, B.match_length = B.prev_length = $ - 1, B.match_available = 0, x.next_in = q, x.input = G, x.avail_in = ye, B.wrap = oe, p;
        }, n.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(r, i, n) {
        i.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        };
      }, {}], 48: [function(r, i, n) {
        i.exports = function(o, s) {
          var a, u, c, f, h, y, p, l, d, v, m, g, _, b, w, A, E, O, $, k, j, P, R, I, z;
          a = o.state, u = o.next_in, I = o.input, c = u + (o.avail_in - 5), f = o.next_out, z = o.output, h = f - (s - o.avail_out), y = f + (o.avail_out - 257), p = a.dmax, l = a.wsize, d = a.whave, v = a.wnext, m = a.window, g = a.hold, _ = a.bits, b = a.lencode, w = a.distcode, A = (1 << a.lenbits) - 1, E = (1 << a.distbits) - 1;
          e: do {
            _ < 15 && (g += I[u++] << _, _ += 8, g += I[u++] << _, _ += 8), O = b[g & A];
            t: for (; ; ) {
              if (g >>>= $ = O >>> 24, _ -= $, ($ = O >>> 16 & 255) === 0) z[f++] = 65535 & O;
              else {
                if (!(16 & $)) {
                  if ((64 & $) == 0) {
                    O = b[(65535 & O) + (g & (1 << $) - 1)];
                    continue t;
                  }
                  if (32 & $) {
                    a.mode = 12;
                    break e;
                  }
                  o.msg = "invalid literal/length code", a.mode = 30;
                  break e;
                }
                k = 65535 & O, ($ &= 15) && (_ < $ && (g += I[u++] << _, _ += 8), k += g & (1 << $) - 1, g >>>= $, _ -= $), _ < 15 && (g += I[u++] << _, _ += 8, g += I[u++] << _, _ += 8), O = w[g & E];
                r: for (; ; ) {
                  if (g >>>= $ = O >>> 24, _ -= $, !(16 & ($ = O >>> 16 & 255))) {
                    if ((64 & $) == 0) {
                      O = w[(65535 & O) + (g & (1 << $) - 1)];
                      continue r;
                    }
                    o.msg = "invalid distance code", a.mode = 30;
                    break e;
                  }
                  if (j = 65535 & O, _ < ($ &= 15) && (g += I[u++] << _, (_ += 8) < $ && (g += I[u++] << _, _ += 8)), p < (j += g & (1 << $) - 1)) {
                    o.msg = "invalid distance too far back", a.mode = 30;
                    break e;
                  }
                  if (g >>>= $, _ -= $, ($ = f - h) < j) {
                    if (d < ($ = j - $) && a.sane) {
                      o.msg = "invalid distance too far back", a.mode = 30;
                      break e;
                    }
                    if (R = m, (P = 0) === v) {
                      if (P += l - $, $ < k) {
                        for (k -= $; z[f++] = m[P++], --$; ) ;
                        P = f - j, R = z;
                      }
                    } else if (v < $) {
                      if (P += l + v - $, ($ -= v) < k) {
                        for (k -= $; z[f++] = m[P++], --$; ) ;
                        if (P = 0, v < k) {
                          for (k -= $ = v; z[f++] = m[P++], --$; ) ;
                          P = f - j, R = z;
                        }
                      }
                    } else if (P += v - $, $ < k) {
                      for (k -= $; z[f++] = m[P++], --$; ) ;
                      P = f - j, R = z;
                    }
                    for (; 2 < k; ) z[f++] = R[P++], z[f++] = R[P++], z[f++] = R[P++], k -= 3;
                    k && (z[f++] = R[P++], 1 < k && (z[f++] = R[P++]));
                  } else {
                    for (P = f - j; z[f++] = z[P++], z[f++] = z[P++], z[f++] = z[P++], 2 < (k -= 3); ) ;
                    k && (z[f++] = z[P++], 1 < k && (z[f++] = z[P++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (u < c && f < y);
          u -= k = _ >> 3, g &= (1 << (_ -= k << 3)) - 1, o.next_in = u, o.next_out = f, o.avail_in = u < c ? c - u + 5 : 5 - (u - c), o.avail_out = f < y ? y - f + 257 : 257 - (f - y), a.hold = g, a.bits = _;
        };
      }, {}], 49: [function(r, i, n) {
        var o = r("../utils/common"), s = r("./adler32"), a = r("./crc32"), u = r("./inffast"), c = r("./inftrees"), f = 1, h = 2, y = 0, p = -2, l = 1, d = 852, v = 592;
        function m(P) {
          return (P >>> 24 & 255) + (P >>> 8 & 65280) + ((65280 & P) << 8) + ((255 & P) << 24);
        }
        function g() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function _(P) {
          var R;
          return P && P.state ? (R = P.state, P.total_in = P.total_out = R.total = 0, P.msg = "", R.wrap && (P.adler = 1 & R.wrap), R.mode = l, R.last = 0, R.havedict = 0, R.dmax = 32768, R.head = null, R.hold = 0, R.bits = 0, R.lencode = R.lendyn = new o.Buf32(d), R.distcode = R.distdyn = new o.Buf32(v), R.sane = 1, R.back = -1, y) : p;
        }
        function b(P) {
          var R;
          return P && P.state ? ((R = P.state).wsize = 0, R.whave = 0, R.wnext = 0, _(P)) : p;
        }
        function w(P, R) {
          var I, z;
          return P && P.state ? (z = P.state, R < 0 ? (I = 0, R = -R) : (I = 1 + (R >> 4), R < 48 && (R &= 15)), R && (R < 8 || 15 < R) ? p : (z.window !== null && z.wbits !== R && (z.window = null), z.wrap = I, z.wbits = R, b(P))) : p;
        }
        function A(P, R) {
          var I, z;
          return P ? (z = new g(), (P.state = z).window = null, (I = w(P, R)) !== y && (P.state = null), I) : p;
        }
        var E, O, $ = !0;
        function k(P) {
          if ($) {
            var R;
            for (E = new o.Buf32(512), O = new o.Buf32(32), R = 0; R < 144; ) P.lens[R++] = 8;
            for (; R < 256; ) P.lens[R++] = 9;
            for (; R < 280; ) P.lens[R++] = 7;
            for (; R < 288; ) P.lens[R++] = 8;
            for (c(f, P.lens, 0, 288, E, 0, P.work, { bits: 9 }), R = 0; R < 32; ) P.lens[R++] = 5;
            c(h, P.lens, 0, 32, O, 0, P.work, { bits: 5 }), $ = !1;
          }
          P.lencode = E, P.lenbits = 9, P.distcode = O, P.distbits = 5;
        }
        function j(P, R, I, z) {
          var W, F = P.state;
          return F.window === null && (F.wsize = 1 << F.wbits, F.wnext = 0, F.whave = 0, F.window = new o.Buf8(F.wsize)), z >= F.wsize ? (o.arraySet(F.window, R, I - F.wsize, F.wsize, 0), F.wnext = 0, F.whave = F.wsize) : (z < (W = F.wsize - F.wnext) && (W = z), o.arraySet(F.window, R, I - z, W, F.wnext), (z -= W) ? (o.arraySet(F.window, R, I - z, z, 0), F.wnext = z, F.whave = F.wsize) : (F.wnext += W, F.wnext === F.wsize && (F.wnext = 0), F.whave < F.wsize && (F.whave += W))), 0;
        }
        n.inflateReset = b, n.inflateReset2 = w, n.inflateResetKeep = _, n.inflateInit = function(P) {
          return A(P, 15);
        }, n.inflateInit2 = A, n.inflate = function(P, R) {
          var I, z, W, F, te, ee, V, T, D, L, M, N, Z, Y, ie, le, de, ae, ne, he, x, U, B, J, X = 0, oe = new o.Buf8(4), ye = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!P || !P.state || !P.output || !P.input && P.avail_in !== 0) return p;
          (I = P.state).mode === 12 && (I.mode = 13), te = P.next_out, W = P.output, V = P.avail_out, F = P.next_in, z = P.input, ee = P.avail_in, T = I.hold, D = I.bits, L = ee, M = V, U = y;
          e: for (; ; ) switch (I.mode) {
            case l:
              if (I.wrap === 0) {
                I.mode = 13;
                break;
              }
              for (; D < 16; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              if (2 & I.wrap && T === 35615) {
                oe[I.check = 0] = 255 & T, oe[1] = T >>> 8 & 255, I.check = a(I.check, oe, 2, 0), D = T = 0, I.mode = 2;
                break;
              }
              if (I.flags = 0, I.head && (I.head.done = !1), !(1 & I.wrap) || (((255 & T) << 8) + (T >> 8)) % 31) {
                P.msg = "incorrect header check", I.mode = 30;
                break;
              }
              if ((15 & T) != 8) {
                P.msg = "unknown compression method", I.mode = 30;
                break;
              }
              if (D -= 4, x = 8 + (15 & (T >>>= 4)), I.wbits === 0) I.wbits = x;
              else if (x > I.wbits) {
                P.msg = "invalid window size", I.mode = 30;
                break;
              }
              I.dmax = 1 << x, P.adler = I.check = 1, I.mode = 512 & T ? 10 : 12, D = T = 0;
              break;
            case 2:
              for (; D < 16; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              if (I.flags = T, (255 & I.flags) != 8) {
                P.msg = "unknown compression method", I.mode = 30;
                break;
              }
              if (57344 & I.flags) {
                P.msg = "unknown header flags set", I.mode = 30;
                break;
              }
              I.head && (I.head.text = T >> 8 & 1), 512 & I.flags && (oe[0] = 255 & T, oe[1] = T >>> 8 & 255, I.check = a(I.check, oe, 2, 0)), D = T = 0, I.mode = 3;
            case 3:
              for (; D < 32; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              I.head && (I.head.time = T), 512 & I.flags && (oe[0] = 255 & T, oe[1] = T >>> 8 & 255, oe[2] = T >>> 16 & 255, oe[3] = T >>> 24 & 255, I.check = a(I.check, oe, 4, 0)), D = T = 0, I.mode = 4;
            case 4:
              for (; D < 16; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              I.head && (I.head.xflags = 255 & T, I.head.os = T >> 8), 512 & I.flags && (oe[0] = 255 & T, oe[1] = T >>> 8 & 255, I.check = a(I.check, oe, 2, 0)), D = T = 0, I.mode = 5;
            case 5:
              if (1024 & I.flags) {
                for (; D < 16; ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                I.length = T, I.head && (I.head.extra_len = T), 512 & I.flags && (oe[0] = 255 & T, oe[1] = T >>> 8 & 255, I.check = a(I.check, oe, 2, 0)), D = T = 0;
              } else I.head && (I.head.extra = null);
              I.mode = 6;
            case 6:
              if (1024 & I.flags && (ee < (N = I.length) && (N = ee), N && (I.head && (x = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), o.arraySet(I.head.extra, z, F, N, x)), 512 & I.flags && (I.check = a(I.check, z, N, F)), ee -= N, F += N, I.length -= N), I.length)) break e;
              I.length = 0, I.mode = 7;
            case 7:
              if (2048 & I.flags) {
                if (ee === 0) break e;
                for (N = 0; x = z[F + N++], I.head && x && I.length < 65536 && (I.head.name += String.fromCharCode(x)), x && N < ee; ) ;
                if (512 & I.flags && (I.check = a(I.check, z, N, F)), ee -= N, F += N, x) break e;
              } else I.head && (I.head.name = null);
              I.length = 0, I.mode = 8;
            case 8:
              if (4096 & I.flags) {
                if (ee === 0) break e;
                for (N = 0; x = z[F + N++], I.head && x && I.length < 65536 && (I.head.comment += String.fromCharCode(x)), x && N < ee; ) ;
                if (512 & I.flags && (I.check = a(I.check, z, N, F)), ee -= N, F += N, x) break e;
              } else I.head && (I.head.comment = null);
              I.mode = 9;
            case 9:
              if (512 & I.flags) {
                for (; D < 16; ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                if (T !== (65535 & I.check)) {
                  P.msg = "header crc mismatch", I.mode = 30;
                  break;
                }
                D = T = 0;
              }
              I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), P.adler = I.check = 0, I.mode = 12;
              break;
            case 10:
              for (; D < 32; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              P.adler = I.check = m(T), D = T = 0, I.mode = 11;
            case 11:
              if (I.havedict === 0) return P.next_out = te, P.avail_out = V, P.next_in = F, P.avail_in = ee, I.hold = T, I.bits = D, 2;
              P.adler = I.check = 1, I.mode = 12;
            case 12:
              if (R === 5 || R === 6) break e;
            case 13:
              if (I.last) {
                T >>>= 7 & D, D -= 7 & D, I.mode = 27;
                break;
              }
              for (; D < 3; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              switch (I.last = 1 & T, D -= 1, 3 & (T >>>= 1)) {
                case 0:
                  I.mode = 14;
                  break;
                case 1:
                  if (k(I), I.mode = 20, R !== 6) break;
                  T >>>= 2, D -= 2;
                  break e;
                case 2:
                  I.mode = 17;
                  break;
                case 3:
                  P.msg = "invalid block type", I.mode = 30;
              }
              T >>>= 2, D -= 2;
              break;
            case 14:
              for (T >>>= 7 & D, D -= 7 & D; D < 32; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              if ((65535 & T) != (T >>> 16 ^ 65535)) {
                P.msg = "invalid stored block lengths", I.mode = 30;
                break;
              }
              if (I.length = 65535 & T, D = T = 0, I.mode = 15, R === 6) break e;
            case 15:
              I.mode = 16;
            case 16:
              if (N = I.length) {
                if (ee < N && (N = ee), V < N && (N = V), N === 0) break e;
                o.arraySet(W, z, F, N, te), ee -= N, F += N, V -= N, te += N, I.length -= N;
                break;
              }
              I.mode = 12;
              break;
            case 17:
              for (; D < 14; ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              if (I.nlen = 257 + (31 & T), T >>>= 5, D -= 5, I.ndist = 1 + (31 & T), T >>>= 5, D -= 5, I.ncode = 4 + (15 & T), T >>>= 4, D -= 4, 286 < I.nlen || 30 < I.ndist) {
                P.msg = "too many length or distance symbols", I.mode = 30;
                break;
              }
              I.have = 0, I.mode = 18;
            case 18:
              for (; I.have < I.ncode; ) {
                for (; D < 3; ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                I.lens[ye[I.have++]] = 7 & T, T >>>= 3, D -= 3;
              }
              for (; I.have < 19; ) I.lens[ye[I.have++]] = 0;
              if (I.lencode = I.lendyn, I.lenbits = 7, B = { bits: I.lenbits }, U = c(0, I.lens, 0, 19, I.lencode, 0, I.work, B), I.lenbits = B.bits, U) {
                P.msg = "invalid code lengths set", I.mode = 30;
                break;
              }
              I.have = 0, I.mode = 19;
            case 19:
              for (; I.have < I.nlen + I.ndist; ) {
                for (; le = (X = I.lencode[T & (1 << I.lenbits) - 1]) >>> 16 & 255, de = 65535 & X, !((ie = X >>> 24) <= D); ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                if (de < 16) T >>>= ie, D -= ie, I.lens[I.have++] = de;
                else {
                  if (de === 16) {
                    for (J = ie + 2; D < J; ) {
                      if (ee === 0) break e;
                      ee--, T += z[F++] << D, D += 8;
                    }
                    if (T >>>= ie, D -= ie, I.have === 0) {
                      P.msg = "invalid bit length repeat", I.mode = 30;
                      break;
                    }
                    x = I.lens[I.have - 1], N = 3 + (3 & T), T >>>= 2, D -= 2;
                  } else if (de === 17) {
                    for (J = ie + 3; D < J; ) {
                      if (ee === 0) break e;
                      ee--, T += z[F++] << D, D += 8;
                    }
                    D -= ie, x = 0, N = 3 + (7 & (T >>>= ie)), T >>>= 3, D -= 3;
                  } else {
                    for (J = ie + 7; D < J; ) {
                      if (ee === 0) break e;
                      ee--, T += z[F++] << D, D += 8;
                    }
                    D -= ie, x = 0, N = 11 + (127 & (T >>>= ie)), T >>>= 7, D -= 7;
                  }
                  if (I.have + N > I.nlen + I.ndist) {
                    P.msg = "invalid bit length repeat", I.mode = 30;
                    break;
                  }
                  for (; N--; ) I.lens[I.have++] = x;
                }
              }
              if (I.mode === 30) break;
              if (I.lens[256] === 0) {
                P.msg = "invalid code -- missing end-of-block", I.mode = 30;
                break;
              }
              if (I.lenbits = 9, B = { bits: I.lenbits }, U = c(f, I.lens, 0, I.nlen, I.lencode, 0, I.work, B), I.lenbits = B.bits, U) {
                P.msg = "invalid literal/lengths set", I.mode = 30;
                break;
              }
              if (I.distbits = 6, I.distcode = I.distdyn, B = { bits: I.distbits }, U = c(h, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, B), I.distbits = B.bits, U) {
                P.msg = "invalid distances set", I.mode = 30;
                break;
              }
              if (I.mode = 20, R === 6) break e;
            case 20:
              I.mode = 21;
            case 21:
              if (6 <= ee && 258 <= V) {
                P.next_out = te, P.avail_out = V, P.next_in = F, P.avail_in = ee, I.hold = T, I.bits = D, u(P, M), te = P.next_out, W = P.output, V = P.avail_out, F = P.next_in, z = P.input, ee = P.avail_in, T = I.hold, D = I.bits, I.mode === 12 && (I.back = -1);
                break;
              }
              for (I.back = 0; le = (X = I.lencode[T & (1 << I.lenbits) - 1]) >>> 16 & 255, de = 65535 & X, !((ie = X >>> 24) <= D); ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              if (le && (240 & le) == 0) {
                for (ae = ie, ne = le, he = de; le = (X = I.lencode[he + ((T & (1 << ae + ne) - 1) >> ae)]) >>> 16 & 255, de = 65535 & X, !(ae + (ie = X >>> 24) <= D); ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                T >>>= ae, D -= ae, I.back += ae;
              }
              if (T >>>= ie, D -= ie, I.back += ie, I.length = de, le === 0) {
                I.mode = 26;
                break;
              }
              if (32 & le) {
                I.back = -1, I.mode = 12;
                break;
              }
              if (64 & le) {
                P.msg = "invalid literal/length code", I.mode = 30;
                break;
              }
              I.extra = 15 & le, I.mode = 22;
            case 22:
              if (I.extra) {
                for (J = I.extra; D < J; ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                I.length += T & (1 << I.extra) - 1, T >>>= I.extra, D -= I.extra, I.back += I.extra;
              }
              I.was = I.length, I.mode = 23;
            case 23:
              for (; le = (X = I.distcode[T & (1 << I.distbits) - 1]) >>> 16 & 255, de = 65535 & X, !((ie = X >>> 24) <= D); ) {
                if (ee === 0) break e;
                ee--, T += z[F++] << D, D += 8;
              }
              if ((240 & le) == 0) {
                for (ae = ie, ne = le, he = de; le = (X = I.distcode[he + ((T & (1 << ae + ne) - 1) >> ae)]) >>> 16 & 255, de = 65535 & X, !(ae + (ie = X >>> 24) <= D); ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                T >>>= ae, D -= ae, I.back += ae;
              }
              if (T >>>= ie, D -= ie, I.back += ie, 64 & le) {
                P.msg = "invalid distance code", I.mode = 30;
                break;
              }
              I.offset = de, I.extra = 15 & le, I.mode = 24;
            case 24:
              if (I.extra) {
                for (J = I.extra; D < J; ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                I.offset += T & (1 << I.extra) - 1, T >>>= I.extra, D -= I.extra, I.back += I.extra;
              }
              if (I.offset > I.dmax) {
                P.msg = "invalid distance too far back", I.mode = 30;
                break;
              }
              I.mode = 25;
            case 25:
              if (V === 0) break e;
              if (N = M - V, I.offset > N) {
                if ((N = I.offset - N) > I.whave && I.sane) {
                  P.msg = "invalid distance too far back", I.mode = 30;
                  break;
                }
                Z = N > I.wnext ? (N -= I.wnext, I.wsize - N) : I.wnext - N, N > I.length && (N = I.length), Y = I.window;
              } else Y = W, Z = te - I.offset, N = I.length;
              for (V < N && (N = V), V -= N, I.length -= N; W[te++] = Y[Z++], --N; ) ;
              I.length === 0 && (I.mode = 21);
              break;
            case 26:
              if (V === 0) break e;
              W[te++] = I.length, V--, I.mode = 21;
              break;
            case 27:
              if (I.wrap) {
                for (; D < 32; ) {
                  if (ee === 0) break e;
                  ee--, T |= z[F++] << D, D += 8;
                }
                if (M -= V, P.total_out += M, I.total += M, M && (P.adler = I.check = I.flags ? a(I.check, W, M, te - M) : s(I.check, W, M, te - M)), M = V, (I.flags ? T : m(T)) !== I.check) {
                  P.msg = "incorrect data check", I.mode = 30;
                  break;
                }
                D = T = 0;
              }
              I.mode = 28;
            case 28:
              if (I.wrap && I.flags) {
                for (; D < 32; ) {
                  if (ee === 0) break e;
                  ee--, T += z[F++] << D, D += 8;
                }
                if (T !== (4294967295 & I.total)) {
                  P.msg = "incorrect length check", I.mode = 30;
                  break;
                }
                D = T = 0;
              }
              I.mode = 29;
            case 29:
              U = 1;
              break e;
            case 30:
              U = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return p;
          }
          return P.next_out = te, P.avail_out = V, P.next_in = F, P.avail_in = ee, I.hold = T, I.bits = D, (I.wsize || M !== P.avail_out && I.mode < 30 && (I.mode < 27 || R !== 4)) && j(P, P.output, P.next_out, M - P.avail_out) ? (I.mode = 31, -4) : (L -= P.avail_in, M -= P.avail_out, P.total_in += L, P.total_out += M, I.total += M, I.wrap && M && (P.adler = I.check = I.flags ? a(I.check, W, M, P.next_out - M) : s(I.check, W, M, P.next_out - M)), P.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === 12 ? 128 : 0) + (I.mode === 20 || I.mode === 15 ? 256 : 0), (L == 0 && M === 0 || R === 4) && U === y && (U = -5), U);
        }, n.inflateEnd = function(P) {
          if (!P || !P.state) return p;
          var R = P.state;
          return R.window && (R.window = null), P.state = null, y;
        }, n.inflateGetHeader = function(P, R) {
          var I;
          return P && P.state ? (2 & (I = P.state).wrap) == 0 ? p : ((I.head = R).done = !1, y) : p;
        }, n.inflateSetDictionary = function(P, R) {
          var I, z = R.length;
          return P && P.state ? (I = P.state).wrap !== 0 && I.mode !== 11 ? p : I.mode === 11 && s(1, R, z, 0) !== I.check ? -3 : j(P, R, z, z) ? (I.mode = 31, -4) : (I.havedict = 1, y) : p;
        }, n.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(r, i, n) {
        var o = r("../utils/common"), s = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        i.exports = function(f, h, y, p, l, d, v, m) {
          var g, _, b, w, A, E, O, $, k, j = m.bits, P = 0, R = 0, I = 0, z = 0, W = 0, F = 0, te = 0, ee = 0, V = 0, T = 0, D = null, L = 0, M = new o.Buf16(16), N = new o.Buf16(16), Z = null, Y = 0;
          for (P = 0; P <= 15; P++) M[P] = 0;
          for (R = 0; R < p; R++) M[h[y + R]]++;
          for (W = j, z = 15; 1 <= z && M[z] === 0; z--) ;
          if (z < W && (W = z), z === 0) return l[d++] = 20971520, l[d++] = 20971520, m.bits = 1, 0;
          for (I = 1; I < z && M[I] === 0; I++) ;
          for (W < I && (W = I), P = ee = 1; P <= 15; P++) if (ee <<= 1, (ee -= M[P]) < 0) return -1;
          if (0 < ee && (f === 0 || z !== 1)) return -1;
          for (N[1] = 0, P = 1; P < 15; P++) N[P + 1] = N[P] + M[P];
          for (R = 0; R < p; R++) h[y + R] !== 0 && (v[N[h[y + R]]++] = R);
          if (E = f === 0 ? (D = Z = v, 19) : f === 1 ? (D = s, L -= 257, Z = a, Y -= 257, 256) : (D = u, Z = c, -1), P = I, A = d, te = R = T = 0, b = -1, w = (V = 1 << (F = W)) - 1, f === 1 && 852 < V || f === 2 && 592 < V) return 1;
          for (; ; ) {
            for (O = P - te, k = v[R] < E ? ($ = 0, v[R]) : v[R] > E ? ($ = Z[Y + v[R]], D[L + v[R]]) : ($ = 96, 0), g = 1 << P - te, I = _ = 1 << F; l[A + (T >> te) + (_ -= g)] = O << 24 | $ << 16 | k | 0, _ !== 0; ) ;
            for (g = 1 << P - 1; T & g; ) g >>= 1;
            if (g !== 0 ? (T &= g - 1, T += g) : T = 0, R++, --M[P] == 0) {
              if (P === z) break;
              P = h[y + v[R]];
            }
            if (W < P && (T & w) !== b) {
              for (te === 0 && (te = W), A += I, ee = 1 << (F = P - te); F + te < z && !((ee -= M[F + te]) <= 0); ) F++, ee <<= 1;
              if (V += 1 << F, f === 1 && 852 < V || f === 2 && 592 < V) return 1;
              l[b = T & w] = W << 24 | F << 16 | A - d | 0;
            }
          }
          return T !== 0 && (l[A + T] = P - te << 24 | 64 << 16 | 0), m.bits = W, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(r, i, n) {
        i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(r, i, n) {
        var o = r("../utils/common"), s = 0, a = 1;
        function u(X) {
          for (var oe = X.length; 0 <= --oe; ) X[oe] = 0;
        }
        var c = 0, f = 29, h = 256, y = h + 1 + f, p = 30, l = 19, d = 2 * y + 1, v = 15, m = 16, g = 7, _ = 256, b = 16, w = 17, A = 18, E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], O = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], $ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], k = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], j = new Array(2 * (y + 2));
        u(j);
        var P = new Array(2 * p);
        u(P);
        var R = new Array(512);
        u(R);
        var I = new Array(256);
        u(I);
        var z = new Array(f);
        u(z);
        var W, F, te, ee = new Array(p);
        function V(X, oe, ye, q, G) {
          this.static_tree = X, this.extra_bits = oe, this.extra_base = ye, this.elems = q, this.max_length = G, this.has_stree = X && X.length;
        }
        function T(X, oe) {
          this.dyn_tree = X, this.max_code = 0, this.stat_desc = oe;
        }
        function D(X) {
          return X < 256 ? R[X] : R[256 + (X >>> 7)];
        }
        function L(X, oe) {
          X.pending_buf[X.pending++] = 255 & oe, X.pending_buf[X.pending++] = oe >>> 8 & 255;
        }
        function M(X, oe, ye) {
          X.bi_valid > m - ye ? (X.bi_buf |= oe << X.bi_valid & 65535, L(X, X.bi_buf), X.bi_buf = oe >> m - X.bi_valid, X.bi_valid += ye - m) : (X.bi_buf |= oe << X.bi_valid & 65535, X.bi_valid += ye);
        }
        function N(X, oe, ye) {
          M(X, ye[2 * oe], ye[2 * oe + 1]);
        }
        function Z(X, oe) {
          for (var ye = 0; ye |= 1 & X, X >>>= 1, ye <<= 1, 0 < --oe; ) ;
          return ye >>> 1;
        }
        function Y(X, oe, ye) {
          var q, G, ce = new Array(v + 1), ue = 0;
          for (q = 1; q <= v; q++) ce[q] = ue = ue + ye[q - 1] << 1;
          for (G = 0; G <= oe; G++) {
            var re = X[2 * G + 1];
            re !== 0 && (X[2 * G] = Z(ce[re]++, re));
          }
        }
        function ie(X) {
          var oe;
          for (oe = 0; oe < y; oe++) X.dyn_ltree[2 * oe] = 0;
          for (oe = 0; oe < p; oe++) X.dyn_dtree[2 * oe] = 0;
          for (oe = 0; oe < l; oe++) X.bl_tree[2 * oe] = 0;
          X.dyn_ltree[2 * _] = 1, X.opt_len = X.static_len = 0, X.last_lit = X.matches = 0;
        }
        function le(X) {
          8 < X.bi_valid ? L(X, X.bi_buf) : 0 < X.bi_valid && (X.pending_buf[X.pending++] = X.bi_buf), X.bi_buf = 0, X.bi_valid = 0;
        }
        function de(X, oe, ye, q) {
          var G = 2 * oe, ce = 2 * ye;
          return X[G] < X[ce] || X[G] === X[ce] && q[oe] <= q[ye];
        }
        function ae(X, oe, ye) {
          for (var q = X.heap[ye], G = ye << 1; G <= X.heap_len && (G < X.heap_len && de(oe, X.heap[G + 1], X.heap[G], X.depth) && G++, !de(oe, q, X.heap[G], X.depth)); ) X.heap[ye] = X.heap[G], ye = G, G <<= 1;
          X.heap[ye] = q;
        }
        function ne(X, oe, ye) {
          var q, G, ce, ue, re = 0;
          if (X.last_lit !== 0) for (; q = X.pending_buf[X.d_buf + 2 * re] << 8 | X.pending_buf[X.d_buf + 2 * re + 1], G = X.pending_buf[X.l_buf + re], re++, q === 0 ? N(X, G, oe) : (N(X, (ce = I[G]) + h + 1, oe), (ue = E[ce]) !== 0 && M(X, G -= z[ce], ue), N(X, ce = D(--q), ye), (ue = O[ce]) !== 0 && M(X, q -= ee[ce], ue)), re < X.last_lit; ) ;
          N(X, _, oe);
        }
        function he(X, oe) {
          var ye, q, G, ce = oe.dyn_tree, ue = oe.stat_desc.static_tree, re = oe.stat_desc.has_stree, pe = oe.stat_desc.elems, xe = -1;
          for (X.heap_len = 0, X.heap_max = d, ye = 0; ye < pe; ye++) ce[2 * ye] !== 0 ? (X.heap[++X.heap_len] = xe = ye, X.depth[ye] = 0) : ce[2 * ye + 1] = 0;
          for (; X.heap_len < 2; ) ce[2 * (G = X.heap[++X.heap_len] = xe < 2 ? ++xe : 0)] = 1, X.depth[G] = 0, X.opt_len--, re && (X.static_len -= ue[2 * G + 1]);
          for (oe.max_code = xe, ye = X.heap_len >> 1; 1 <= ye; ye--) ae(X, ce, ye);
          for (G = pe; ye = X.heap[1], X.heap[1] = X.heap[X.heap_len--], ae(X, ce, 1), q = X.heap[1], X.heap[--X.heap_max] = ye, X.heap[--X.heap_max] = q, ce[2 * G] = ce[2 * ye] + ce[2 * q], X.depth[G] = (X.depth[ye] >= X.depth[q] ? X.depth[ye] : X.depth[q]) + 1, ce[2 * ye + 1] = ce[2 * q + 1] = G, X.heap[1] = G++, ae(X, ce, 1), 2 <= X.heap_len; ) ;
          X.heap[--X.heap_max] = X.heap[1], (function(be, Ee) {
            var Ue, Ae, Me, et, lt, ft, Ke = Ee.dyn_tree, Xt = Ee.max_code, $t = Ee.stat_desc.static_tree, Pt = Ee.stat_desc.has_stree, Tt = Ee.stat_desc.extra_bits, Ft = Ee.stat_desc.extra_base, xt = Ee.stat_desc.max_length, ir = 0;
            for (et = 0; et <= v; et++) be.bl_count[et] = 0;
            for (Ke[2 * be.heap[be.heap_max] + 1] = 0, Ue = be.heap_max + 1; Ue < d; Ue++) xt < (et = Ke[2 * Ke[2 * (Ae = be.heap[Ue]) + 1] + 1] + 1) && (et = xt, ir++), Ke[2 * Ae + 1] = et, Xt < Ae || (be.bl_count[et]++, lt = 0, Ft <= Ae && (lt = Tt[Ae - Ft]), ft = Ke[2 * Ae], be.opt_len += ft * (et + lt), Pt && (be.static_len += ft * ($t[2 * Ae + 1] + lt)));
            if (ir !== 0) {
              do {
                for (et = xt - 1; be.bl_count[et] === 0; ) et--;
                be.bl_count[et]--, be.bl_count[et + 1] += 2, be.bl_count[xt]--, ir -= 2;
              } while (0 < ir);
              for (et = xt; et !== 0; et--) for (Ae = be.bl_count[et]; Ae !== 0; ) Xt < (Me = be.heap[--Ue]) || (Ke[2 * Me + 1] !== et && (be.opt_len += (et - Ke[2 * Me + 1]) * Ke[2 * Me], Ke[2 * Me + 1] = et), Ae--);
            }
          })(X, oe), Y(ce, xe, X.bl_count);
        }
        function x(X, oe, ye) {
          var q, G, ce = -1, ue = oe[1], re = 0, pe = 7, xe = 4;
          for (ue === 0 && (pe = 138, xe = 3), oe[2 * (ye + 1) + 1] = 65535, q = 0; q <= ye; q++) G = ue, ue = oe[2 * (q + 1) + 1], ++re < pe && G === ue || (re < xe ? X.bl_tree[2 * G] += re : G !== 0 ? (G !== ce && X.bl_tree[2 * G]++, X.bl_tree[2 * b]++) : re <= 10 ? X.bl_tree[2 * w]++ : X.bl_tree[2 * A]++, ce = G, xe = (re = 0) === ue ? (pe = 138, 3) : G === ue ? (pe = 6, 3) : (pe = 7, 4));
        }
        function U(X, oe, ye) {
          var q, G, ce = -1, ue = oe[1], re = 0, pe = 7, xe = 4;
          for (ue === 0 && (pe = 138, xe = 3), q = 0; q <= ye; q++) if (G = ue, ue = oe[2 * (q + 1) + 1], !(++re < pe && G === ue)) {
            if (re < xe) for (; N(X, G, X.bl_tree), --re != 0; ) ;
            else G !== 0 ? (G !== ce && (N(X, G, X.bl_tree), re--), N(X, b, X.bl_tree), M(X, re - 3, 2)) : re <= 10 ? (N(X, w, X.bl_tree), M(X, re - 3, 3)) : (N(X, A, X.bl_tree), M(X, re - 11, 7));
            ce = G, xe = (re = 0) === ue ? (pe = 138, 3) : G === ue ? (pe = 6, 3) : (pe = 7, 4);
          }
        }
        u(ee);
        var B = !1;
        function J(X, oe, ye, q) {
          M(X, (c << 1) + (q ? 1 : 0), 3), (function(G, ce, ue, re) {
            le(G), L(G, ue), L(G, ~ue), o.arraySet(G.pending_buf, G.window, ce, ue, G.pending), G.pending += ue;
          })(X, oe, ye);
        }
        n._tr_init = function(X) {
          B || ((function() {
            var oe, ye, q, G, ce, ue = new Array(v + 1);
            for (G = q = 0; G < f - 1; G++) for (z[G] = q, oe = 0; oe < 1 << E[G]; oe++) I[q++] = G;
            for (I[q - 1] = G, G = ce = 0; G < 16; G++) for (ee[G] = ce, oe = 0; oe < 1 << O[G]; oe++) R[ce++] = G;
            for (ce >>= 7; G < p; G++) for (ee[G] = ce << 7, oe = 0; oe < 1 << O[G] - 7; oe++) R[256 + ce++] = G;
            for (ye = 0; ye <= v; ye++) ue[ye] = 0;
            for (oe = 0; oe <= 143; ) j[2 * oe + 1] = 8, oe++, ue[8]++;
            for (; oe <= 255; ) j[2 * oe + 1] = 9, oe++, ue[9]++;
            for (; oe <= 279; ) j[2 * oe + 1] = 7, oe++, ue[7]++;
            for (; oe <= 287; ) j[2 * oe + 1] = 8, oe++, ue[8]++;
            for (Y(j, y + 1, ue), oe = 0; oe < p; oe++) P[2 * oe + 1] = 5, P[2 * oe] = Z(oe, 5);
            W = new V(j, E, h + 1, y, v), F = new V(P, O, 0, p, v), te = new V(new Array(0), $, 0, l, g);
          })(), B = !0), X.l_desc = new T(X.dyn_ltree, W), X.d_desc = new T(X.dyn_dtree, F), X.bl_desc = new T(X.bl_tree, te), X.bi_buf = 0, X.bi_valid = 0, ie(X);
        }, n._tr_stored_block = J, n._tr_flush_block = function(X, oe, ye, q) {
          var G, ce, ue = 0;
          0 < X.level ? (X.strm.data_type === 2 && (X.strm.data_type = (function(re) {
            var pe, xe = 4093624447;
            for (pe = 0; pe <= 31; pe++, xe >>>= 1) if (1 & xe && re.dyn_ltree[2 * pe] !== 0) return s;
            if (re.dyn_ltree[18] !== 0 || re.dyn_ltree[20] !== 0 || re.dyn_ltree[26] !== 0) return a;
            for (pe = 32; pe < h; pe++) if (re.dyn_ltree[2 * pe] !== 0) return a;
            return s;
          })(X)), he(X, X.l_desc), he(X, X.d_desc), ue = (function(re) {
            var pe;
            for (x(re, re.dyn_ltree, re.l_desc.max_code), x(re, re.dyn_dtree, re.d_desc.max_code), he(re, re.bl_desc), pe = l - 1; 3 <= pe && re.bl_tree[2 * k[pe] + 1] === 0; pe--) ;
            return re.opt_len += 3 * (pe + 1) + 5 + 5 + 4, pe;
          })(X), G = X.opt_len + 3 + 7 >>> 3, (ce = X.static_len + 3 + 7 >>> 3) <= G && (G = ce)) : G = ce = ye + 5, ye + 4 <= G && oe !== -1 ? J(X, oe, ye, q) : X.strategy === 4 || ce === G ? (M(X, 2 + (q ? 1 : 0), 3), ne(X, j, P)) : (M(X, 4 + (q ? 1 : 0), 3), (function(re, pe, xe, be) {
            var Ee;
            for (M(re, pe - 257, 5), M(re, xe - 1, 5), M(re, be - 4, 4), Ee = 0; Ee < be; Ee++) M(re, re.bl_tree[2 * k[Ee] + 1], 3);
            U(re, re.dyn_ltree, pe - 1), U(re, re.dyn_dtree, xe - 1);
          })(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, ue + 1), ne(X, X.dyn_ltree, X.dyn_dtree)), ie(X), q && le(X);
        }, n._tr_tally = function(X, oe, ye) {
          return X.pending_buf[X.d_buf + 2 * X.last_lit] = oe >>> 8 & 255, X.pending_buf[X.d_buf + 2 * X.last_lit + 1] = 255 & oe, X.pending_buf[X.l_buf + X.last_lit] = 255 & ye, X.last_lit++, oe === 0 ? X.dyn_ltree[2 * ye]++ : (X.matches++, oe--, X.dyn_ltree[2 * (I[ye] + h + 1)]++, X.dyn_dtree[2 * D(oe)]++), X.last_lit === X.lit_bufsize - 1;
        }, n._tr_align = function(X) {
          M(X, 2, 3), N(X, _, j), (function(oe) {
            oe.bi_valid === 16 ? (L(oe, oe.bi_buf), oe.bi_buf = 0, oe.bi_valid = 0) : 8 <= oe.bi_valid && (oe.pending_buf[oe.pending++] = 255 & oe.bi_buf, oe.bi_buf >>= 8, oe.bi_valid -= 8);
          })(X);
        };
      }, { "../utils/common": 41 }], 53: [function(r, i, n) {
        i.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(r, i, n) {
        (function(o) {
          (function(s, a) {
            if (!s.setImmediate) {
              var u, c, f, h, y = 1, p = {}, l = !1, d = s.document, v = Object.getPrototypeOf && Object.getPrototypeOf(s);
              v = v && v.setTimeout ? v : s, u = {}.toString.call(s.process) === "[object process]" ? function(b) {
                process.nextTick(function() {
                  g(b);
                });
              } : (function() {
                if (s.postMessage && !s.importScripts) {
                  var b = !0, w = s.onmessage;
                  return s.onmessage = function() {
                    b = !1;
                  }, s.postMessage("", "*"), s.onmessage = w, b;
                }
              })() ? (h = "setImmediate$" + Math.random() + "$", s.addEventListener ? s.addEventListener("message", _, !1) : s.attachEvent("onmessage", _), function(b) {
                s.postMessage(h + b, "*");
              }) : s.MessageChannel ? ((f = new MessageChannel()).port1.onmessage = function(b) {
                g(b.data);
              }, function(b) {
                f.port2.postMessage(b);
              }) : d && "onreadystatechange" in d.createElement("script") ? (c = d.documentElement, function(b) {
                var w = d.createElement("script");
                w.onreadystatechange = function() {
                  g(b), w.onreadystatechange = null, c.removeChild(w), w = null;
                }, c.appendChild(w);
              }) : function(b) {
                setTimeout(g, 0, b);
              }, v.setImmediate = function(b) {
                typeof b != "function" && (b = new Function("" + b));
                for (var w = new Array(arguments.length - 1), A = 0; A < w.length; A++) w[A] = arguments[A + 1];
                var E = { callback: b, args: w };
                return p[y] = E, u(y), y++;
              }, v.clearImmediate = m;
            }
            function m(b) {
              delete p[b];
            }
            function g(b) {
              if (l) setTimeout(g, 0, b);
              else {
                var w = p[b];
                if (w) {
                  l = !0;
                  try {
                    (function(A) {
                      var E = A.callback, O = A.args;
                      switch (O.length) {
                        case 0:
                          E();
                          break;
                        case 1:
                          E(O[0]);
                          break;
                        case 2:
                          E(O[0], O[1]);
                          break;
                        case 3:
                          E(O[0], O[1], O[2]);
                          break;
                        default:
                          E.apply(a, O);
                      }
                    })(w);
                  } finally {
                    m(b), l = !1;
                  }
                }
              }
            }
            function _(b) {
              b.source === s && typeof b.data == "string" && b.data.indexOf(h) === 0 && g(+b.data.slice(h.length));
            }
          })(typeof self > "u" ? o === void 0 ? this : o : self);
        }).call(this, typeof Ji < "u" ? Ji : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(tl)), tl.exports;
}
var nB = rB();
const $q = /* @__PURE__ */ Bi(nB);
function Ma(e) {
  "@babel/helpers - typeof";
  return Ma = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ma(e);
}
var Yn = Uint8Array, Pn = Uint16Array, cg = Int32Array, lg = new Yn([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), fg = new Yn([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Gb = new Yn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), hj = function(e, t) {
  for (var r = new Pn(31), i = 0; i < 31; ++i)
    r[i] = t += 1 << e[i - 1];
  for (var n = new cg(r[30]), i = 1; i < 30; ++i)
    for (var o = r[i]; o < r[i + 1]; ++o)
      n[o] = o - r[i] << 5 | i;
  return { b: r, r: n };
}, pj = hj(lg, 2), iB = pj.b, Kp = pj.r;
iB[28] = 258, Kp[258] = 28;
var oB = hj(fg, 0), Kb = oB.r, Hp = new Pn(32768);
for (var vr = 0; vr < 32768; ++vr) {
  var ji = (vr & 43690) >> 1 | (vr & 21845) << 1;
  ji = (ji & 52428) >> 2 | (ji & 13107) << 2, ji = (ji & 61680) >> 4 | (ji & 3855) << 4, Hp[vr] = ((ji & 65280) >> 8 | (ji & 255) << 8) >> 1;
}
var ka = (function(e, t, r) {
  for (var i = e.length, n = 0, o = new Pn(t); n < i; ++n)
    e[n] && ++o[e[n] - 1];
  var s = new Pn(t);
  for (n = 1; n < t; ++n)
    s[n] = s[n - 1] + o[n - 1] << 1;
  var a;
  if (r) {
    a = new Pn(1 << t);
    var u = 15 - t;
    for (n = 0; n < i; ++n)
      if (e[n])
        for (var c = n << 4 | e[n], f = t - e[n], h = s[e[n] - 1]++ << f, y = h | (1 << f) - 1; h <= y; ++h)
          a[Hp[h] >> u] = c;
  } else
    for (a = new Pn(i), n = 0; n < i; ++n)
      e[n] && (a[n] = Hp[s[e[n] - 1]++] >> 15 - e[n]);
  return a;
}), fo = new Yn(288);
for (var vr = 0; vr < 144; ++vr)
  fo[vr] = 8;
for (var vr = 144; vr < 256; ++vr)
  fo[vr] = 9;
for (var vr = 256; vr < 280; ++vr)
  fo[vr] = 7;
for (var vr = 280; vr < 288; ++vr)
  fo[vr] = 8;
var bu = new Yn(32);
for (var vr = 0; vr < 32; ++vr)
  bu[vr] = 5;
var aB = /* @__PURE__ */ ka(fo, 9, 0), sB = /* @__PURE__ */ ka(bu, 5, 0), dj = function(e) {
  return (e + 7) / 8 | 0;
}, uB = function(e, t, r) {
  return (r == null || r > e.length) && (r = e.length), new Yn(e.subarray(t, r));
}, di = function(e, t, r) {
  r <<= t & 7;
  var i = t / 8 | 0;
  e[i] |= r, e[i + 1] |= r >> 8;
}, la = function(e, t, r) {
  r <<= t & 7;
  var i = t / 8 | 0;
  e[i] |= r, e[i + 1] |= r >> 8, e[i + 2] |= r >> 16;
}, rl = function(e, t) {
  for (var r = [], i = 0; i < e.length; ++i)
    e[i] && r.push({ s: i, f: e[i] });
  var n = r.length, o = r.slice();
  if (!n)
    return { t: yj, l: 0 };
  if (n == 1) {
    var s = new Yn(r[0].s + 1);
    return s[r[0].s] = 1, { t: s, l: 1 };
  }
  r.sort(function(w, A) {
    return w.f - A.f;
  }), r.push({ s: -1, f: 25001 });
  var a = r[0], u = r[1], c = 0, f = 1, h = 2;
  for (r[0] = { s: -1, f: a.f + u.f, l: a, r: u }; f != n - 1; )
    a = r[r[c].f < r[h].f ? c++ : h++], u = r[c != f && r[c].f < r[h].f ? c++ : h++], r[f++] = { s: -1, f: a.f + u.f, l: a, r: u };
  for (var y = o[0].s, i = 1; i < n; ++i)
    o[i].s > y && (y = o[i].s);
  var p = new Pn(y + 1), l = Jp(r[f - 1], p, 0);
  if (l > t) {
    var i = 0, d = 0, v = l - t, m = 1 << v;
    for (o.sort(function(A, E) {
      return p[E.s] - p[A.s] || A.f - E.f;
    }); i < n; ++i) {
      var g = o[i].s;
      if (p[g] > t)
        d += m - (1 << l - p[g]), p[g] = t;
      else
        break;
    }
    for (d >>= v; d > 0; ) {
      var _ = o[i].s;
      p[_] < t ? d -= 1 << t - p[_]++ - 1 : ++i;
    }
    for (; i >= 0 && d; --i) {
      var b = o[i].s;
      p[b] == t && (--p[b], ++d);
    }
    l = t;
  }
  return { t: new Yn(p), l };
}, Jp = function(e, t, r) {
  return e.s == -1 ? Math.max(Jp(e.l, t, r + 1), Jp(e.r, t, r + 1)) : t[e.s] = r;
}, Hb = function(e) {
  for (var t = e.length; t && !e[--t]; )
    ;
  for (var r = new Pn(++t), i = 0, n = e[0], o = 1, s = function(u) {
    r[i++] = u;
  }, a = 1; a <= t; ++a)
    if (e[a] == n && a != t)
      ++o;
    else {
      if (!n && o > 2) {
        for (; o > 138; o -= 138)
          s(32754);
        o > 2 && (s(o > 10 ? o - 11 << 5 | 28690 : o - 3 << 5 | 12305), o = 0);
      } else if (o > 3) {
        for (s(n), --o; o > 6; o -= 6)
          s(8304);
        o > 2 && (s(o - 3 << 5 | 8208), o = 0);
      }
      for (; o--; )
        s(n);
      o = 1, n = e[a];
    }
  return { c: r.subarray(0, i), n: t };
}, fa = function(e, t) {
  for (var r = 0, i = 0; i < t.length; ++i)
    r += e[i] * t[i];
  return r;
}, mj = function(e, t, r) {
  var i = r.length, n = dj(t + 2);
  e[n] = i & 255, e[n + 1] = i >> 8, e[n + 2] = e[n] ^ 255, e[n + 3] = e[n + 1] ^ 255;
  for (var o = 0; o < i; ++o)
    e[n + o + 4] = r[o];
  return (n + 4 + i) * 8;
}, Jb = function(e, t, r, i, n, o, s, a, u, c, f) {
  di(t, f++, r), ++n[256];
  for (var h = rl(n, 15), y = h.t, p = h.l, l = rl(o, 15), d = l.t, v = l.l, m = Hb(y), g = m.c, _ = m.n, b = Hb(d), w = b.c, A = b.n, E = new Pn(19), O = 0; O < g.length; ++O)
    ++E[g[O] & 31];
  for (var O = 0; O < w.length; ++O)
    ++E[w[O] & 31];
  for (var $ = rl(E, 7), k = $.t, j = $.l, P = 19; P > 4 && !k[Gb[P - 1]]; --P)
    ;
  var R = c + 5 << 3, I = fa(n, fo) + fa(o, bu) + s, z = fa(n, y) + fa(o, d) + s + 14 + 3 * P + fa(E, k) + 2 * E[16] + 3 * E[17] + 7 * E[18];
  if (u >= 0 && R <= I && R <= z)
    return mj(t, f, e.subarray(u, u + c));
  var W, F, te, ee;
  if (di(t, f, 1 + (z < I)), f += 2, z < I) {
    W = ka(y, p, 0), F = y, te = ka(d, v, 0), ee = d;
    var V = ka(k, j, 0);
    di(t, f, _ - 257), di(t, f + 5, A - 1), di(t, f + 10, P - 4), f += 14;
    for (var O = 0; O < P; ++O)
      di(t, f + 3 * O, k[Gb[O]]);
    f += 3 * P;
    for (var T = [g, w], D = 0; D < 2; ++D)
      for (var L = T[D], O = 0; O < L.length; ++O) {
        var M = L[O] & 31;
        di(t, f, V[M]), f += k[M], M > 15 && (di(t, f, L[O] >> 5 & 127), f += L[O] >> 12);
      }
  } else
    W = aB, F = fo, te = sB, ee = bu;
  for (var O = 0; O < a; ++O) {
    var N = i[O];
    if (N > 255) {
      var M = N >> 18 & 31;
      la(t, f, W[M + 257]), f += F[M + 257], M > 7 && (di(t, f, N >> 23 & 31), f += lg[M]);
      var Z = N & 31;
      la(t, f, te[Z]), f += ee[Z], Z > 3 && (la(t, f, N >> 5 & 8191), f += fg[Z]);
    } else
      la(t, f, W[N]), f += F[N];
  }
  return la(t, f, W[256]), f + F[256];
}, cB = /* @__PURE__ */ new cg([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), yj = /* @__PURE__ */ new Yn(0), lB = function(e, t, r, i, n, o) {
  var s = o.z || e.length, a = new Yn(i + s + 5 * (1 + Math.ceil(s / 7e3)) + n), u = a.subarray(i, a.length - n), c = o.l, f = (o.r || 0) & 7;
  if (t) {
    f && (u[0] = o.r >> 3);
    for (var h = cB[t - 1], y = h >> 13, p = h & 8191, l = (1 << r) - 1, d = o.p || new Pn(32768), v = o.h || new Pn(l + 1), m = Math.ceil(r / 3), g = 2 * m, _ = function(x) {
      return (e[x] ^ e[x + 1] << m ^ e[x + 2] << g) & l;
    }, b = new cg(25e3), w = new Pn(288), A = new Pn(32), E = 0, O = 0, $ = o.i || 0, k = 0, j = o.w || 0, P = 0; $ + 2 < s; ++$) {
      var R = _($), I = $ & 32767, z = v[R];
      if (d[I] = z, v[R] = I, j <= $) {
        var W = s - $;
        if ((E > 7e3 || k > 24576) && (W > 423 || !c)) {
          f = Jb(e, u, 0, b, w, A, O, k, P, $ - P, f), k = E = O = 0, P = $;
          for (var F = 0; F < 286; ++F)
            w[F] = 0;
          for (var F = 0; F < 30; ++F)
            A[F] = 0;
        }
        var te = 2, ee = 0, V = p, T = I - z & 32767;
        if (W > 2 && R == _($ - T))
          for (var D = Math.min(y, W) - 1, L = Math.min(32767, $), M = Math.min(258, W); T <= L && --V && I != z; ) {
            if (e[$ + te] == e[$ + te - T]) {
              for (var N = 0; N < M && e[$ + N] == e[$ + N - T]; ++N)
                ;
              if (N > te) {
                if (te = N, ee = T, N > D)
                  break;
                for (var Z = Math.min(T, N - 2), Y = 0, F = 0; F < Z; ++F) {
                  var ie = $ - T + F & 32767, le = d[ie], de = ie - le & 32767;
                  de > Y && (Y = de, z = ie);
                }
              }
            }
            I = z, z = d[I], T += I - z & 32767;
          }
        if (ee) {
          b[k++] = 268435456 | Kp[te] << 18 | Kb[ee];
          var ae = Kp[te] & 31, ne = Kb[ee] & 31;
          O += lg[ae] + fg[ne], ++w[257 + ae], ++A[ne], j = $ + te, ++E;
        } else
          b[k++] = e[$], ++w[e[$]];
      }
    }
    for ($ = Math.max($, j); $ < s; ++$)
      b[k++] = e[$], ++w[e[$]];
    f = Jb(e, u, c, b, w, A, O, k, P, $ - P, f), c || (o.r = f & 7 | u[f / 8 | 0] << 3, f -= 7, o.h = v, o.p = d, o.i = $, o.w = j);
  } else {
    for (var $ = o.w || 0; $ < s + c; $ += 65535) {
      var he = $ + 65535;
      he >= s && (u[f / 8 | 0] = c, he = s), f = mj(u, f + 1, e.subarray($, he));
    }
    o.i = s;
  }
  return uB(a, 0, i + dj(f) + n);
}, gj = function() {
  var e = 1, t = 0;
  return {
    p: function(r) {
      for (var i = e, n = t, o = r.length | 0, s = 0; s != o; ) {
        for (var a = Math.min(s + 2655, o); s < a; ++s)
          n += i += r[s];
        i = (i & 65535) + 15 * (i >> 16), n = (n & 65535) + 15 * (n >> 16);
      }
      e = i, t = n;
    },
    d: function() {
      return e %= 65521, t %= 65521, (e & 255) << 24 | (e & 65280) << 8 | (t & 255) << 8 | t >> 8;
    }
  };
}, fB = function(e, t, r, i, n) {
  if (!n && (n = { l: 1 }, t.dictionary)) {
    var o = t.dictionary.subarray(-32768), s = new Yn(o.length + e.length);
    s.set(o), s.set(e, o.length), e = s, n.w = o.length;
  }
  return lB(e, t.level == null ? 6 : t.level, t.mem == null ? n.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(e.length))) * 1.5) : 20 : 12 + t.mem, r, i, n);
}, vj = function(e, t, r) {
  for (; r; ++t)
    e[t] = r, r >>>= 8;
}, hB = function(e, t) {
  var r = t.level, i = r == 0 ? 0 : r < 6 ? 1 : r == 9 ? 3 : 2;
  if (e[0] = 120, e[1] = i << 6 | (t.dictionary && 32), e[1] |= 31 - (e[0] << 8 | e[1]) % 31, t.dictionary) {
    var n = gj();
    n.p(t.dictionary), vj(e, 2, n.d());
  }
};
function Sq(e, t) {
  t || (t = {});
  var r = gj();
  r.p(e);
  var i = fB(e, t, t.dictionary ? 6 : 2, 4);
  return hB(i, t), vj(i, i.length - 4, r.d()), i;
}
var pB = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), dB = 0;
try {
  pB.decode(yj, { stream: !0 }), dB = 1;
} catch {
}
function mB(e) {
  if (Array.isArray(e)) return e;
}
function yB(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var i, n, o, s, a = [], u = !0, c = !1;
    try {
      if (o = (r = r.call(e)).next, t !== 0) for (; !(u = (i = o.call(r)).done) && (a.push(i.value), a.length !== t); u = !0) ;
    } catch (f) {
      c = !0, n = f;
    } finally {
      try {
        if (!u && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (c) throw n;
      }
    }
    return a;
  }
}
function Yb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = Array(t); r < t; r++) i[r] = e[r];
  return i;
}
function gB(e, t) {
  if (e) {
    if (typeof e == "string") return Yb(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Yb(e, t) : void 0;
  }
}
function vB() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Eq(e, t) {
  return mB(e) || yB(e, t) || gB(e, t) || vB();
}
function Xb(e, t = "utf8") {
  return new TextDecoder(t).decode(e);
}
const bB = new TextEncoder();
function _B(e) {
  return bB.encode(e);
}
const wB = 1024 * 8, OB = (() => {
  const e = new Uint8Array(4), t = new Uint32Array(e.buffer);
  return !((t[0] = 1) & e[0]);
})(), nl = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
class hg {
  /**
   * Reference to the internal ArrayBuffer object.
   */
  buffer;
  /**
   * Byte length of the internal ArrayBuffer.
   */
  byteLength;
  /**
   * Byte offset of the internal ArrayBuffer.
   */
  byteOffset;
  /**
   * Byte length of the internal ArrayBuffer.
   */
  length;
  /**
   * The current offset of the buffer's pointer.
   */
  offset;
  lastWrittenByte;
  littleEndian;
  _data;
  _mark;
  _marks;
  /**
   * Create a new IOBuffer.
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options - An object for the options.
   * @returns A new IOBuffer instance.
   */
  constructor(t = wB, r = {}) {
    let i = !1;
    typeof t == "number" ? t = new ArrayBuffer(t) : (i = !0, this.lastWrittenByte = t.byteLength);
    const n = r.offset ? r.offset >>> 0 : 0, o = t.byteLength - n;
    let s = n;
    (ArrayBuffer.isView(t) || t instanceof hg) && (t.byteLength !== t.buffer.byteLength && (s = t.byteOffset + n), t = t.buffer), i ? this.lastWrittenByte = o : this.lastWrittenByte = 0, this.buffer = t, this.length = o, this.byteLength = o, this.byteOffset = s, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, s, o), this._mark = 0, this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(t = 1) {
    return this.offset + t <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setLittleEndian() {
    return this.littleEndian = !0, this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setBigEndian() {
    return this.littleEndian = !1, this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   * @returns This.
   */
  skip(t = 1) {
    return this.offset += t, this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   * @returns This.
   */
  back(t = 1) {
    return this.offset -= t, this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset - The offset to move to.
   * @returns This.
   */
  seek(t) {
    return this.offset = t, this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   * @returns This.
   */
  mark() {
    return this._mark = this.offset, this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   * @returns This.
   */
  reset() {
    return this.offset = this._mark, this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   * @returns This.
   */
  pushMark() {
    return this._marks.push(this.offset), this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   * @returns This.
   */
  popMark() {
    const t = this._marks.pop();
    if (t === void 0)
      throw new Error("Mark stack empty");
    return this.seek(t), this;
  }
  /**
   * Move the pointer offset back to 0.
   * @returns This.
   */
  rewind() {
    return this.offset = 0, this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength - The needed memory in bytes.
   * @returns This.
   */
  ensureAvailable(t = 1) {
    if (!this.available(t)) {
      const i = (this.offset + t) * 2, n = new Uint8Array(i);
      n.set(new Uint8Array(this.buffer)), this.buffer = n.buffer, this.length = i, this.byteLength = i, this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   * @returns The read boolean.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   * @returns The read byte.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The read bytes.
   */
  readBytes(t = 1) {
    return this.readArray(t, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   * @returns The read array.
   */
  readArray(t, r) {
    const i = nl[r].BYTES_PER_ELEMENT * t, n = this.byteOffset + this.offset, o = this.buffer.slice(n, n + i);
    if (this.littleEndian === OB && r !== "uint8" && r !== "int8") {
      const a = new Uint8Array(this.buffer.slice(n, n + i));
      a.reverse();
      const u = new nl[r](a.buffer);
      return this.offset += i, u.reverse(), u;
    }
    const s = new nl[r](o);
    return this.offset += i, s;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readInt16() {
    const t = this._data.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, t;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readUint16() {
    const t = this._data.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, t;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readInt32() {
    const t = this._data.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, t;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readUint32() {
    const t = this._data.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, t;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readFloat32() {
    const t = this._data.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, t;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readFloat64() {
    const t = this._data.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, t;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigInt64() {
    const t = this._data.getBigInt64(this.offset, this.littleEndian);
    return this.offset += 8, t;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigUint64() {
    const t = this._data.getBigUint64(this.offset, this.littleEndian);
    return this.offset += 8, t;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   * @returns The read character.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   * @param n - Number of characters to read.
   * @returns The read characters.
   */
  readChars(t = 1) {
    let r = "";
    for (let i = 0; i < t; i++)
      r += this.readChar();
    return r;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The decoded string.
   */
  readUtf8(t = 1) {
    return Xb(this.readBytes(t));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   * @param n - Number of bytes to read.
   * @param encoding - The encoding to use. Default is 'utf8'.
   * @returns The decoded string.
   */
  decodeText(t = 1, r = "utf8") {
    return Xb(this.readBytes(t), r);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeBoolean(t) {
    return this.writeUint8(t ? 255 : 0), this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt8(t) {
    return this.ensureAvailable(1), this._data.setInt8(this.offset++, t), this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint8(t) {
    return this.ensureAvailable(1), this._data.setUint8(this.offset++, t), this._updateLastWrittenByte(), this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   * @param value - The value to write.
   * @returns This.
   */
  writeByte(t) {
    return this.writeUint8(t);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   * @param bytes - The array of bytes to write.
   * @returns This.
   */
  writeBytes(t) {
    this.ensureAvailable(t.length);
    for (let r = 0; r < t.length; r++)
      this._data.setUint8(this.offset++, t[r]);
    return this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt16(t) {
    return this.ensureAvailable(2), this._data.setInt16(this.offset, t, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint16(t) {
    return this.ensureAvailable(2), this._data.setUint16(this.offset, t, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt32(t) {
    return this.ensureAvailable(4), this._data.setInt32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint32(t) {
    return this.ensureAvailable(4), this._data.setUint32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat32(t) {
    return this.ensureAvailable(4), this._data.setFloat32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat64(t) {
    return this.ensureAvailable(8), this._data.setFloat64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigInt64(t) {
    return this.ensureAvailable(8), this._data.setBigInt64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigUint64(t) {
    return this.ensureAvailable(8), this._data.setBigUint64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   * @param str - The character to write.
   * @returns This.
   */
  writeChar(t) {
    return this.writeUint8(t.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   * @param str - The characters to write.
   * @returns This.
   */
  writeChars(t) {
    for (let r = 0; r < t.length; r++)
      this.writeUint8(t.charCodeAt(r));
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   * @param str - The string to write.
   * @returns This.
   */
  writeUtf8(t) {
    return this.writeBytes(_B(t));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   * @returns A new Uint8Array view.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   *  Get the total number of bytes written so far, regardless of the current offset.
   * @returns - Total number of bytes.
   */
  getWrittenByteLength() {
    return this.lastWrittenByte - this.byteOffset;
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
  }
}
const bj = [];
for (let e = 0; e < 256; e++) {
  let t = e;
  for (let r = 0; r < 8; r++)
    t & 1 ? t = 3988292384 ^ t >>> 1 : t = t >>> 1;
  bj[e] = t;
}
const Qb = 4294967295;
function $B(e, t, r) {
  let i = e;
  for (let n = 0; n < r; n++)
    i = bj[(i ^ t[n]) & 255] ^ i >>> 8;
  return i;
}
function SB(e, t) {
  return ($B(Qb, e, t) ^ Qb) >>> 0;
}
function e_(e, t, r) {
  const i = e.readUint32(), n = SB(new Uint8Array(e.buffer, e.byteOffset + e.offset - t - 4, t), t);
  if (n !== i)
    throw new Error(`CRC mismatch for chunk ${r}. Expected ${i}, found ${n}`);
}
function _j(e, t, r) {
  for (let i = 0; i < r; i++)
    t[i] = e[i];
}
function wj(e, t, r, i) {
  let n = 0;
  for (; n < i; n++)
    t[n] = e[n];
  for (; n < r; n++)
    t[n] = e[n] + t[n - i] & 255;
}
function Oj(e, t, r, i) {
  let n = 0;
  if (r.length === 0)
    for (; n < i; n++)
      t[n] = e[n];
  else
    for (; n < i; n++)
      t[n] = e[n] + r[n] & 255;
}
function $j(e, t, r, i, n) {
  let o = 0;
  if (r.length === 0) {
    for (; o < n; o++)
      t[o] = e[o];
    for (; o < i; o++)
      t[o] = e[o] + (t[o - n] >> 1) & 255;
  } else {
    for (; o < n; o++)
      t[o] = e[o] + (r[o] >> 1) & 255;
    for (; o < i; o++)
      t[o] = e[o] + (t[o - n] + r[o] >> 1) & 255;
  }
}
function Sj(e, t, r, i, n) {
  let o = 0;
  if (r.length === 0) {
    for (; o < n; o++)
      t[o] = e[o];
    for (; o < i; o++)
      t[o] = e[o] + t[o - n] & 255;
  } else {
    for (; o < n; o++)
      t[o] = e[o] + r[o] & 255;
    for (; o < i; o++)
      t[o] = e[o] + EB(t[o - n], r[o], r[o - n]) & 255;
  }
}
function EB(e, t, r) {
  const i = e + t - r, n = Math.abs(i - e), o = Math.abs(i - t), s = Math.abs(i - r);
  return n <= o && n <= s ? e : o <= s ? t : r;
}
function xB(e, t, r, i, n, o) {
  switch (e) {
    case 0:
      _j(t, r, n);
      break;
    case 1:
      wj(t, r, n, o);
      break;
    case 2:
      Oj(t, r, i, n);
      break;
    case 3:
      $j(t, r, i, n, o);
      break;
    case 4:
      Sj(t, r, i, n, o);
      break;
    default:
      throw new Error(`Unsupported filter: ${e}`);
  }
}
const AB = new Uint16Array([255]), jB = new Uint8Array(AB.buffer), kB = jB[0] === 255;
function PB(e) {
  const { data: t, width: r, height: i, channels: n, depth: o } = e, s = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ], a = Math.ceil(o / 8) * n, u = new Uint8Array(i * r * a);
  let c = 0;
  for (let f = 0; f < 7; f++) {
    const h = s[f], y = Math.ceil((r - h.x) / h.xStep), p = Math.ceil((i - h.y) / h.yStep);
    if (y <= 0 || p <= 0)
      continue;
    const l = y * a, d = new Uint8Array(l);
    for (let v = 0; v < p; v++) {
      const m = t[c++], g = t.subarray(c, c + l);
      c += l;
      const _ = new Uint8Array(l);
      xB(m, g, _, d, l, a), d.set(_);
      for (let b = 0; b < y; b++) {
        const w = h.x + b * h.xStep, A = h.y + v * h.yStep;
        if (!(w >= r || A >= i))
          for (let E = 0; E < a; E++)
            u[(A * r + w) * a + E] = _[b * a + E];
      }
    }
  }
  if (o === 16) {
    const f = new Uint16Array(u.buffer);
    if (kB)
      for (let h = 0; h < f.length; h++)
        f[h] = IB(f[h]);
    return f;
  } else
    return u;
}
function IB(e) {
  return (e & 255) << 8 | e >> 8 & 255;
}
const TB = new Uint16Array([255]), NB = new Uint8Array(TB.buffer), CB = NB[0] === 255, RB = new Uint8Array(0);
function t_(e) {
  const { data: t, width: r, height: i, channels: n, depth: o } = e, s = Math.ceil(o / 8) * n, a = Math.ceil(o / 8 * n * r), u = new Uint8Array(i * a);
  let c = RB, f = 0, h, y;
  for (let p = 0; p < i; p++) {
    switch (h = t.subarray(f + 1, f + 1 + a), y = u.subarray(p * a, (p + 1) * a), t[f]) {
      case 0:
        _j(h, y, a);
        break;
      case 1:
        wj(h, y, a, s);
        break;
      case 2:
        Oj(h, y, c, a);
        break;
      case 3:
        $j(h, y, c, a, s);
        break;
      case 4:
        Sj(h, y, c, a, s);
        break;
      default:
        throw new Error(`Unsupported filter: ${t[f]}`);
    }
    c = y, f += a + 1;
  }
  if (o === 16) {
    const p = new Uint16Array(u.buffer);
    if (CB)
      for (let l = 0; l < p.length; l++)
        p[l] = DB(p[l]);
    return p;
  } else
    return u;
}
function DB(e) {
  return (e & 255) << 8 | e >> 8 & 255;
}
const Ls = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function r_(e) {
  if (!zB(e.readBytes(Ls.length)))
    throw new Error("wrong PNG signature");
}
function zB(e) {
  if (e.length < Ls.length)
    return !1;
  for (let t = 0; t < Ls.length; t++)
    if (e[t] !== Ls[t])
      return !1;
  return !0;
}
const UB = "tEXt", MB = 0, Ej = new TextDecoder("latin1");
function FB(e) {
  if (BB(e), e.length === 0 || e.length > 79)
    throw new Error("keyword length must be between 1 and 79");
}
const LB = /^[\u0000-\u00FF]*$/;
function BB(e) {
  if (!LB.test(e))
    throw new Error("invalid latin1 text");
}
function qB(e, t, r) {
  const i = xj(t);
  e[i] = ZB(t, r - i.length - 1);
}
function xj(e) {
  for (e.mark(); e.readByte() !== MB; )
    ;
  const t = e.offset;
  e.reset();
  const r = Ej.decode(e.readBytes(t - e.offset - 1));
  return e.skip(1), FB(r), r;
}
function ZB(e, t) {
  return Ej.decode(e.readBytes(t));
}
const An = {
  UNKNOWN: -1,
  GREYSCALE: 0,
  TRUECOLOUR: 2,
  INDEXED_COLOUR: 3,
  GREYSCALE_ALPHA: 4,
  TRUECOLOUR_ALPHA: 6
}, il = {
  UNKNOWN: -1,
  DEFLATE: 0
}, n_ = {
  UNKNOWN: -1,
  ADAPTIVE: 0
}, ol = {
  UNKNOWN: -1,
  NO_INTERLACE: 0,
  ADAM7: 1
}, Ts = {
  NONE: 0,
  BACKGROUND: 1,
  PREVIOUS: 2
}, al = {
  SOURCE: 0,
  OVER: 1
};
class VB extends hg {
  _checkCrc;
  _inflator;
  _png;
  _apng;
  _end;
  _hasPalette;
  _palette;
  _hasTransparency;
  _transparency;
  _compressionMethod;
  _filterMethod;
  _interlaceMethod;
  _colorType;
  _isAnimated;
  _numberOfFrames;
  _numberOfPlays;
  _frames;
  _writingDataChunks;
  constructor(t, r = {}) {
    super(t);
    const { checkCrc: i = !1 } = r;
    this._checkCrc = i, this._inflator = new Rg(), this._png = {
      width: -1,
      height: -1,
      channels: -1,
      data: new Uint8Array(0),
      depth: 1,
      text: {}
    }, this._apng = {
      width: -1,
      height: -1,
      channels: -1,
      depth: 1,
      numberOfFrames: 1,
      numberOfPlays: 0,
      text: {},
      frames: []
    }, this._end = !1, this._hasPalette = !1, this._palette = [], this._hasTransparency = !1, this._transparency = new Uint16Array(0), this._compressionMethod = il.UNKNOWN, this._filterMethod = n_.UNKNOWN, this._interlaceMethod = ol.UNKNOWN, this._colorType = An.UNKNOWN, this._isAnimated = !1, this._numberOfFrames = 1, this._numberOfPlays = 0, this._frames = [], this._writingDataChunks = !1, this.setBigEndian();
  }
  decode() {
    for (r_(this); !this._end; ) {
      const t = this.readUint32(), r = this.readChars(4);
      this.decodeChunk(t, r);
    }
    return this.decodeImage(), this._png;
  }
  decodeApng() {
    for (r_(this); !this._end; ) {
      const t = this.readUint32(), r = this.readChars(4);
      this.decodeApngChunk(t, r);
    }
    return this.decodeApngImage(), this._apng;
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk(t, r) {
    const i = this.offset;
    switch (r) {
      // 11.2 Critical chunks
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(t);
        break;
      case "IDAT":
        this.decodeIDAT(t);
        break;
      case "IEND":
        this._end = !0;
        break;
      // 11.3 Ancillary chunks
      case "tRNS":
        this.decodetRNS(t);
        break;
      case "iCCP":
        this.decodeiCCP(t);
        break;
      case UB:
        qB(this._png.text, this, t);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(t);
        break;
    }
    if (this.offset - i !== t)
      throw new Error(`Length mismatch while decoding chunk ${r}`);
    this._checkCrc ? e_(this, t + 4, r) : this.skip(4);
  }
  decodeApngChunk(t, r) {
    const i = this.offset;
    switch (r !== "fdAT" && r !== "IDAT" && this._writingDataChunks && this.pushDataToFrame(), r) {
      case "acTL":
        this.decodeACTL();
        break;
      case "fcTL":
        this.decodeFCTL();
        break;
      case "fdAT":
        this.decodeFDAT(t);
        break;
      default:
        this.decodeChunk(t, r), this.offset = i + t;
        break;
    }
    if (this.offset - i !== t)
      throw new Error(`Length mismatch while decoding chunk ${r}`);
    this._checkCrc ? e_(this, t + 4, r) : this.skip(4);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const t = this._png;
    t.width = this.readUint32(), t.height = this.readUint32(), t.depth = WB(this.readUint8());
    const r = this.readUint8();
    this._colorType = r;
    let i;
    switch (r) {
      case An.GREYSCALE:
        i = 1;
        break;
      case An.TRUECOLOUR:
        i = 3;
        break;
      case An.INDEXED_COLOUR:
        i = 1;
        break;
      case An.GREYSCALE_ALPHA:
        i = 2;
        break;
      case An.TRUECOLOUR_ALPHA:
        i = 4;
        break;
      // Kept for exhaustiveness.
      // eslint-disable-next-line unicorn/no-useless-switch-case
      case An.UNKNOWN:
      default:
        throw new Error(`Unknown color type: ${r}`);
    }
    if (this._png.channels = i, this._compressionMethod = this.readUint8(), this._compressionMethod !== il.DEFLATE)
      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8();
  }
  decodeACTL() {
    this._numberOfFrames = this.readUint32(), this._numberOfPlays = this.readUint32(), this._isAnimated = !0;
  }
  decodeFCTL() {
    const t = {
      sequenceNumber: this.readUint32(),
      width: this.readUint32(),
      height: this.readUint32(),
      xOffset: this.readUint32(),
      yOffset: this.readUint32(),
      delayNumber: this.readUint16(),
      delayDenominator: this.readUint16(),
      disposeOp: this.readUint8(),
      blendOp: this.readUint8(),
      data: new Uint8Array(0)
    };
    this._frames.push(t);
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(t) {
    if (t % 3 !== 0)
      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${t}`);
    const r = t / 3;
    this._hasPalette = !0;
    const i = [];
    this._palette = i;
    for (let n = 0; n < r; n++)
      i.push([this.readUint8(), this.readUint8(), this.readUint8()]);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(t) {
    this._writingDataChunks = !0;
    const r = t, i = this.offset + this.byteOffset;
    if (this._inflator.push(new Uint8Array(this.buffer, i, r)), this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    this.skip(t);
  }
  decodeFDAT(t) {
    this._writingDataChunks = !0;
    let r = t, i = this.offset + this.byteOffset;
    if (i += 4, r -= 4, this._inflator.push(new Uint8Array(this.buffer, i, r)), this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    this.skip(t);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(t) {
    switch (this._colorType) {
      case An.GREYSCALE:
      case An.TRUECOLOUR: {
        if (t % 2 !== 0)
          throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${t}`);
        if (t / 2 > this._png.width * this._png.height)
          throw new Error(`tRNS chunk contains more alpha values than there are pixels (${t / 2} vs ${this._png.width * this._png.height})`);
        this._hasTransparency = !0, this._transparency = new Uint16Array(t / 2);
        for (let r = 0; r < t / 2; r++)
          this._transparency[r] = this.readUint16();
        break;
      }
      case An.INDEXED_COLOUR: {
        if (t > this._palette.length)
          throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${t} vs ${this._palette.length})`);
        let r = 0;
        for (; r < t; r++) {
          const i = this.readByte();
          this._palette[r].push(i);
        }
        for (; r < this._palette.length; r++)
          this._palette[r].push(255);
        break;
      }
      // Kept for exhaustiveness.
      /* eslint-disable unicorn/no-useless-switch-case */
      case An.UNKNOWN:
      case An.GREYSCALE_ALPHA:
      case An.TRUECOLOUR_ALPHA:
      default:
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(t) {
    const r = xj(this), i = this.readUint8();
    if (i !== il.DEFLATE)
      throw new Error(`Unsupported iCCP compression method: ${i}`);
    const n = this.readBytes(t - r.length - 2);
    this._png.iccEmbeddedProfile = {
      name: r,
      profile: fk(n)
    };
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const t = this.readUint32(), r = this.readUint32(), i = this.readByte();
    this._png.resolution = { x: t, y: r, unit: i };
  }
  decodeApngImage() {
    this._apng.width = this._png.width, this._apng.height = this._png.height, this._apng.channels = this._png.channels, this._apng.depth = this._png.depth, this._apng.numberOfFrames = this._numberOfFrames, this._apng.numberOfPlays = this._numberOfPlays, this._apng.text = this._png.text, this._apng.resolution = this._png.resolution;
    for (let t = 0; t < this._numberOfFrames; t++) {
      const r = {
        sequenceNumber: this._frames[t].sequenceNumber,
        delayNumber: this._frames[t].delayNumber,
        delayDenominator: this._frames[t].delayDenominator,
        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
      }, i = this._frames.at(t);
      if (i) {
        if (i.data = t_({
          data: i.data,
          width: i.width,
          height: i.height,
          channels: this._apng.channels,
          depth: this._apng.depth
        }), this._hasPalette && (this._apng.palette = this._palette), this._hasTransparency && (this._apng.transparency = this._transparency), t === 0 || i.xOffset === 0 && i.yOffset === 0 && i.width === this._png.width && i.height === this._png.height)
          r.data = i.data;
        else {
          const n = this._apng.frames.at(t - 1);
          this.disposeFrame(i, n, r), this.addFrameDataToCanvas(r, i);
        }
        this._apng.frames.push(r);
      }
    }
    return this._apng;
  }
  disposeFrame(t, r, i) {
    switch (t.disposeOp) {
      case Ts.NONE:
        break;
      case Ts.BACKGROUND:
        for (let n = 0; n < this._png.height; n++)
          for (let o = 0; o < this._png.width; o++) {
            const s = (n * t.width + o) * this._png.channels;
            for (let a = 0; a < this._png.channels; a++)
              i.data[s + a] = 0;
          }
        break;
      case Ts.PREVIOUS:
        i.data.set(r.data);
        break;
      default:
        throw new Error("Unknown disposeOp");
    }
  }
  addFrameDataToCanvas(t, r) {
    const i = 1 << this._png.depth, n = (o, s) => {
      const a = ((o + r.yOffset) * this._png.width + r.xOffset + s) * this._png.channels, u = (o * r.width + s) * this._png.channels;
      return { index: a, frameIndex: u };
    };
    switch (r.blendOp) {
      case al.SOURCE:
        for (let o = 0; o < r.height; o++)
          for (let s = 0; s < r.width; s++) {
            const { index: a, frameIndex: u } = n(o, s);
            for (let c = 0; c < this._png.channels; c++)
              t.data[a + c] = r.data[u + c];
          }
        break;
      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
      case al.OVER:
        for (let o = 0; o < r.height; o++)
          for (let s = 0; s < r.width; s++) {
            const { index: a, frameIndex: u } = n(o, s);
            for (let c = 0; c < this._png.channels; c++) {
              const f = r.data[u + this._png.channels - 1] / i, h = c % (this._png.channels - 1) === 0 ? 1 : r.data[u + c], y = Math.floor(f * h + (1 - f) * t.data[a + c]);
              t.data[a + c] += y;
            }
          }
        break;
      default:
        throw new Error("Unknown blendOp");
    }
  }
  decodeImage() {
    if (this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    const t = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;
    if (this._filterMethod !== n_.ADAPTIVE)
      throw new Error(`Filter method ${this._filterMethod} not supported`);
    if (this._interlaceMethod === ol.NO_INTERLACE)
      this._png.data = t_({
        data: t,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    else if (this._interlaceMethod === ol.ADAM7)
      this._png.data = PB({
        data: t,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    else
      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    this._hasPalette && (this._png.palette = this._palette), this._hasTransparency && (this._png.transparency = this._transparency);
  }
  pushDataToFrame() {
    const t = this._inflator.result, r = this._frames.at(-1);
    r ? r.data = t : this._frames.push({
      sequenceNumber: 0,
      width: this._png.width,
      height: this._png.height,
      xOffset: 0,
      yOffset: 0,
      delayNumber: 0,
      delayDenominator: 0,
      disposeOp: Ts.NONE,
      blendOp: al.SOURCE,
      data: t
    }), this._inflator = new Rg(), this._writingDataChunks = !1;
  }
}
function WB(e) {
  if (e !== 1 && e !== 2 && e !== 4 && e !== 8 && e !== 16)
    throw new Error(`invalid bit depth: ${e}`);
  return e;
}
var i_;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.METRE = 1] = "METRE";
})(i_ || (i_ = {}));
function xq(e, t) {
  return new VB(e, t).decode();
}
var Bs = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
var GB = Bs.exports, o_;
function KB() {
  return o_ || (o_ = 1, (function(e, t) {
    ((r, i) => {
      e.exports = i();
    })(GB, function r() {
      var i = typeof self < "u" ? self : typeof window < "u" ? window : i !== void 0 ? i : {}, n, o = !i.document && !!i.postMessage, s = i.IS_PAPA_WORKER || !1, a = {}, u = 0, c = {};
      function f(O) {
        this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, function($) {
          var k = w($);
          k.chunkSize = parseInt(k.chunkSize), $.step || $.chunk || (k.chunkSize = null), this._handle = new d(k), (this._handle.streamer = this)._config = k;
        }.call(this, O), this.parseChunk = function($, k) {
          var j = parseInt(this._config.skipFirstNLines) || 0;
          if (this.isFirstChunk && 0 < j) {
            let R = this._config.newline;
            R || (P = this._config.quoteChar || '"', R = this._handle.guessLineEndings($, P)), $ = [...$.split(R).slice(j)].join(R);
          }
          this.isFirstChunk && E(this._config.beforeFirstChunk) && (P = this._config.beforeFirstChunk($)) !== void 0 && ($ = P), this.isFirstChunk = !1, this._halted = !1;
          var j = this._partialLine + $, P = (this._partialLine = "", this._handle.parse(j, this._baseIndex, !this._finished));
          if (!this._handle.paused() && !this._handle.aborted()) {
            if ($ = P.meta.cursor, j = (this._finished || (this._partialLine = j.substring($ - this._baseIndex), this._baseIndex = $), P && P.data && (this._rowCount += P.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), s) i.postMessage({ results: P, workerId: c.WORKER_ID, finished: j });
            else if (E(this._config.chunk) && !k) {
              if (this._config.chunk(P, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
              this._completeResults = P = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(P.data), this._completeResults.errors = this._completeResults.errors.concat(P.errors), this._completeResults.meta = P.meta), this._completed || !j || !E(this._config.complete) || P && P.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), j || P && P.meta.paused || this._nextChunk(), P;
          }
          this._halted = !0;
        }, this._sendError = function($) {
          E(this._config.error) ? this._config.error($) : s && this._config.error && i.postMessage({ workerId: c.WORKER_ID, error: $, finished: !1 });
        };
      }
      function h(O) {
        var $;
        (O = O || {}).chunkSize || (O.chunkSize = c.RemoteChunkSize), f.call(this, O), this._nextChunk = o ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(k) {
          this._input = k, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if ($ = new XMLHttpRequest(), this._config.withCredentials && ($.withCredentials = this._config.withCredentials), o || ($.onload = A(this._chunkLoaded, this), $.onerror = A(this._chunkError, this)), $.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !o), this._config.downloadRequestHeaders) {
              var k, j = this._config.downloadRequestHeaders;
              for (k in j) $.setRequestHeader(k, j[k]);
            }
            var P;
            this._config.chunkSize && (P = this._start + this._config.chunkSize - 1, $.setRequestHeader("Range", "bytes=" + this._start + "-" + P));
            try {
              $.send(this._config.downloadRequestBody);
            } catch (R) {
              this._chunkError(R.message);
            }
            o && $.status === 0 && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          $.readyState === 4 && ($.status < 200 || 400 <= $.status ? this._chunkError() : (this._start += this._config.chunkSize || $.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((k) => (k = k.getResponseHeader("Content-Range")) !== null ? parseInt(k.substring(k.lastIndexOf("/") + 1)) : -1)($), this.parseChunk($.responseText)));
        }, this._chunkError = function(k) {
          k = $.statusText || k, this._sendError(new Error(k));
        };
      }
      function y(O) {
        (O = O || {}).chunkSize || (O.chunkSize = c.LocalChunkSize), f.call(this, O);
        var $, k, j = typeof FileReader < "u";
        this.stream = function(P) {
          this._input = P, k = P.slice || P.webkitSlice || P.mozSlice, j ? (($ = new FileReader()).onload = A(this._chunkLoaded, this), $.onerror = A(this._chunkError, this)) : $ = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var P = this._input, R = (this._config.chunkSize && (R = Math.min(this._start + this._config.chunkSize, this._input.size), P = k.call(P, this._start, R)), $.readAsText(P, this._config.encoding));
          j || this._chunkLoaded({ target: { result: R } });
        }, this._chunkLoaded = function(P) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(P.target.result);
        }, this._chunkError = function() {
          this._sendError($.error);
        };
      }
      function p(O) {
        var $;
        f.call(this, O = O || {}), this.stream = function(k) {
          return $ = k, this._nextChunk();
        }, this._nextChunk = function() {
          var k, j;
          if (!this._finished) return k = this._config.chunkSize, $ = k ? (j = $.substring(0, k), $.substring(k)) : (j = $, ""), this._finished = !$, this.parseChunk(j);
        };
      }
      function l(O) {
        f.call(this, O = O || {});
        var $ = [], k = !0, j = !1;
        this.pause = function() {
          f.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          f.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(P) {
          this._input = P, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          j && $.length === 1 && (this._finished = !0);
        }, this._nextChunk = function() {
          this._checkIsFinished(), $.length ? this.parseChunk($.shift()) : k = !0;
        }, this._streamData = A(function(P) {
          try {
            $.push(typeof P == "string" ? P : P.toString(this._config.encoding)), k && (k = !1, this._checkIsFinished(), this.parseChunk($.shift()));
          } catch (R) {
            this._streamError(R);
          }
        }, this), this._streamError = A(function(P) {
          this._streamCleanUp(), this._sendError(P);
        }, this), this._streamEnd = A(function() {
          this._streamCleanUp(), j = !0, this._streamData("");
        }, this), this._streamCleanUp = A(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function d(O) {
        var $, k, j, P, R = Math.pow(2, 53), I = -R, z = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, W = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, F = this, te = 0, ee = 0, V = !1, T = !1, D = [], L = { data: [], errors: [], meta: {} };
        function M(ie) {
          return O.skipEmptyLines === "greedy" ? ie.join("").trim() === "" : ie.length === 1 && ie[0].length === 0;
        }
        function N() {
          if (L && j && (Y("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), j = !1), O.skipEmptyLines && (L.data = L.data.filter(function(ae) {
            return !M(ae);
          })), Z()) {
            let ae = function(ne, he) {
              E(O.transformHeader) && (ne = O.transformHeader(ne, he)), D.push(ne);
            };
            if (L) if (Array.isArray(L.data[0])) {
              for (var ie = 0; Z() && ie < L.data.length; ie++) L.data[ie].forEach(ae);
              L.data.splice(0, 1);
            } else L.data.forEach(ae);
          }
          function le(ae, ne) {
            for (var he = O.header ? {} : [], x = 0; x < ae.length; x++) {
              var U = x, B = ae[x], B = ((J, X) => ((oe) => (O.dynamicTypingFunction && O.dynamicTyping[oe] === void 0 && (O.dynamicTyping[oe] = O.dynamicTypingFunction(oe)), (O.dynamicTyping[oe] || O.dynamicTyping) === !0))(J) ? X === "true" || X === "TRUE" || X !== "false" && X !== "FALSE" && (((oe) => {
                if (z.test(oe) && (oe = parseFloat(oe), I < oe && oe < R))
                  return 1;
              })(X) ? parseFloat(X) : W.test(X) ? new Date(X) : X === "" ? null : X) : X)(U = O.header ? x >= D.length ? "__parsed_extra" : D[x] : U, B = O.transform ? O.transform(B, U) : B);
              U === "__parsed_extra" ? (he[U] = he[U] || [], he[U].push(B)) : he[U] = B;
            }
            return O.header && (x > D.length ? Y("FieldMismatch", "TooManyFields", "Too many fields: expected " + D.length + " fields but parsed " + x, ee + ne) : x < D.length && Y("FieldMismatch", "TooFewFields", "Too few fields: expected " + D.length + " fields but parsed " + x, ee + ne)), he;
          }
          var de;
          L && (O.header || O.dynamicTyping || O.transform) && (de = 1, !L.data.length || Array.isArray(L.data[0]) ? (L.data = L.data.map(le), de = L.data.length) : L.data = le(L.data, 0), O.header && L.meta && (L.meta.fields = D), ee += de);
        }
        function Z() {
          return O.header && D.length === 0;
        }
        function Y(ie, le, de, ae) {
          ie = { type: ie, code: le, message: de }, ae !== void 0 && (ie.row = ae), L.errors.push(ie);
        }
        E(O.step) && (P = O.step, O.step = function(ie) {
          L = ie, Z() ? N() : (N(), L.data.length !== 0 && (te += ie.data.length, O.preview && te > O.preview ? k.abort() : (L.data = L.data[0], P(L, F))));
        }), this.parse = function(ie, le, de) {
          var ae = O.quoteChar || '"', ae = (O.newline || (O.newline = this.guessLineEndings(ie, ae)), j = !1, O.delimiter ? E(O.delimiter) && (O.delimiter = O.delimiter(ie), L.meta.delimiter = O.delimiter) : ((ae = ((ne, he, x, U, B) => {
            var J, X, oe, ye;
            B = B || [",", "	", "|", ";", c.RECORD_SEP, c.UNIT_SEP];
            for (var q = 0; q < B.length; q++) {
              for (var G, ce = B[q], ue = 0, re = 0, pe = 0, xe = (oe = void 0, new m({ comments: U, delimiter: ce, newline: he, preview: 10 }).parse(ne)), be = 0; be < xe.data.length; be++) x && M(xe.data[be]) ? pe++ : (G = xe.data[be].length, re += G, oe === void 0 ? oe = G : 0 < G && (ue += Math.abs(G - oe), oe = G));
              0 < xe.data.length && (re /= xe.data.length - pe), (X === void 0 || ue <= X) && (ye === void 0 || ye < re) && 1.99 < re && (X = ue, J = ce, ye = re);
            }
            return { successful: !!(O.delimiter = J), bestDelimiter: J };
          })(ie, O.newline, O.skipEmptyLines, O.comments, O.delimitersToGuess)).successful ? O.delimiter = ae.bestDelimiter : (j = !0, O.delimiter = c.DefaultDelimiter), L.meta.delimiter = O.delimiter), w(O));
          return O.preview && O.header && ae.preview++, $ = ie, k = new m(ae), L = k.parse($, le, de), N(), V ? { meta: { paused: !0 } } : L || { meta: { paused: !1 } };
        }, this.paused = function() {
          return V;
        }, this.pause = function() {
          V = !0, k.abort(), $ = E(O.chunk) ? "" : $.substring(k.getCharIndex());
        }, this.resume = function() {
          F.streamer._halted ? (V = !1, F.streamer.parseChunk($, !0)) : setTimeout(F.resume, 3);
        }, this.aborted = function() {
          return T;
        }, this.abort = function() {
          T = !0, k.abort(), L.meta.aborted = !0, E(O.complete) && O.complete(L), $ = "";
        }, this.guessLineEndings = function(ne, ae) {
          ne = ne.substring(0, 1048576);
          var ae = new RegExp(v(ae) + "([^]*?)" + v(ae), "gm"), de = (ne = ne.replace(ae, "")).split("\r"), ae = ne.split(`
`), ne = 1 < ae.length && ae[0].length < de[0].length;
          if (de.length === 1 || ne) return `
`;
          for (var he = 0, x = 0; x < de.length; x++) de[x][0] === `
` && he++;
          return he >= de.length / 2 ? `\r
` : "\r";
        };
      }
      function v(O) {
        return O.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function m(O) {
        var $ = (O = O || {}).delimiter, k = O.newline, j = O.comments, P = O.step, R = O.preview, I = O.fastMode, z = null, W = !1, F = O.quoteChar == null ? '"' : O.quoteChar, te = F;
        if (O.escapeChar !== void 0 && (te = O.escapeChar), (typeof $ != "string" || -1 < c.BAD_DELIMITERS.indexOf($)) && ($ = ","), j === $) throw new Error("Comment character same as delimiter");
        j === !0 ? j = "#" : (typeof j != "string" || -1 < c.BAD_DELIMITERS.indexOf(j)) && (j = !1), k !== `
` && k !== "\r" && k !== `\r
` && (k = `
`);
        var ee = 0, V = !1;
        this.parse = function(T, D, L) {
          if (typeof T != "string") throw new Error("Input must be a string");
          var M = T.length, N = $.length, Z = k.length, Y = j.length, ie = E(P), le = [], de = [], ae = [], ne = ee = 0;
          if (!T) return ue();
          if (I || I !== !1 && T.indexOf(F) === -1) {
            for (var he = T.split(k), x = 0; x < he.length; x++) {
              if (ae = he[x], ee += ae.length, x !== he.length - 1) ee += k.length;
              else if (L) return ue();
              if (!j || ae.substring(0, Y) !== j) {
                if (ie) {
                  if (le = [], ye(ae.split($)), re(), V) return ue();
                } else ye(ae.split($));
                if (R && R <= x) return le = le.slice(0, R), ue(!0);
              }
            }
            return ue();
          }
          for (var U = T.indexOf($, ee), B = T.indexOf(k, ee), J = new RegExp(v(te) + v(F), "g"), X = T.indexOf(F, ee); ; ) if (T[ee] === F) for (X = ee, ee++; ; ) {
            if ((X = T.indexOf(F, X + 1)) === -1) return L || de.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: le.length, index: ee }), G();
            if (X === M - 1) return G(T.substring(ee, X).replace(J, F));
            if (F === te && T[X + 1] === te) X++;
            else if (F === te || X === 0 || T[X - 1] !== te) {
              U !== -1 && U < X + 1 && (U = T.indexOf($, X + 1));
              var oe = q((B = B !== -1 && B < X + 1 ? T.indexOf(k, X + 1) : B) === -1 ? U : Math.min(U, B));
              if (T.substr(X + 1 + oe, N) === $) {
                ae.push(T.substring(ee, X).replace(J, F)), T[ee = X + 1 + oe + N] !== F && (X = T.indexOf(F, ee)), U = T.indexOf($, ee), B = T.indexOf(k, ee);
                break;
              }
              if (oe = q(B), T.substring(X + 1 + oe, X + 1 + oe + Z) === k) {
                if (ae.push(T.substring(ee, X).replace(J, F)), ce(X + 1 + oe + Z), U = T.indexOf($, ee), X = T.indexOf(F, ee), ie && (re(), V)) return ue();
                if (R && le.length >= R) return ue(!0);
                break;
              }
              de.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: le.length, index: ee }), X++;
            }
          }
          else if (j && ae.length === 0 && T.substring(ee, ee + Y) === j) {
            if (B === -1) return ue();
            ee = B + Z, B = T.indexOf(k, ee), U = T.indexOf($, ee);
          } else if (U !== -1 && (U < B || B === -1)) ae.push(T.substring(ee, U)), ee = U + N, U = T.indexOf($, ee);
          else {
            if (B === -1) break;
            if (ae.push(T.substring(ee, B)), ce(B + Z), ie && (re(), V)) return ue();
            if (R && le.length >= R) return ue(!0);
          }
          return G();
          function ye(pe) {
            le.push(pe), ne = ee;
          }
          function q(pe) {
            var xe = 0;
            return xe = pe !== -1 && (pe = T.substring(X + 1, pe)) && pe.trim() === "" ? pe.length : xe;
          }
          function G(pe) {
            return L || (pe === void 0 && (pe = T.substring(ee)), ae.push(pe), ee = M, ye(ae), ie && re()), ue();
          }
          function ce(pe) {
            ee = pe, ye(ae), ae = [], B = T.indexOf(k, ee);
          }
          function ue(pe) {
            if (O.header && !D && le.length && !W) {
              var xe = le[0], be = /* @__PURE__ */ Object.create(null), Ee = new Set(xe);
              let Ue = !1;
              for (let Ae = 0; Ae < xe.length; Ae++) {
                let Me = xe[Ae];
                if (be[Me = E(O.transformHeader) ? O.transformHeader(Me, Ae) : Me]) {
                  let et, lt = be[Me];
                  for (; et = Me + "_" + lt, lt++, Ee.has(et); ) ;
                  Ee.add(et), xe[Ae] = et, be[Me]++, Ue = !0, (z = z === null ? {} : z)[et] = Me;
                } else be[Me] = 1, xe[Ae] = Me;
                Ee.add(Me);
              }
              Ue && console.warn("Duplicate headers found and renamed."), W = !0;
            }
            return { data: le, errors: de, meta: { delimiter: $, linebreak: k, aborted: V, truncated: !!pe, cursor: ne + (D || 0), renamedHeaders: z } };
          }
          function re() {
            P(ue()), le = [], de = [];
          }
        }, this.abort = function() {
          V = !0;
        }, this.getCharIndex = function() {
          return ee;
        };
      }
      function g(O) {
        var $ = O.data, k = a[$.workerId], j = !1;
        if ($.error) k.userError($.error, $.file);
        else if ($.results && $.results.data) {
          var P = { abort: function() {
            j = !0, _($.workerId, { data: [], errors: [], meta: { aborted: !0 } });
          }, pause: b, resume: b };
          if (E(k.userStep)) {
            for (var R = 0; R < $.results.data.length && (k.userStep({ data: $.results.data[R], errors: $.results.errors, meta: $.results.meta }, P), !j); R++) ;
            delete $.results;
          } else E(k.userChunk) && (k.userChunk($.results, P, $.file), delete $.results);
        }
        $.finished && !j && _($.workerId, $.results);
      }
      function _(O, $) {
        var k = a[O];
        E(k.userComplete) && k.userComplete($), k.terminate(), delete a[O];
      }
      function b() {
        throw new Error("Not implemented.");
      }
      function w(O) {
        if (typeof O != "object" || O === null) return O;
        var $, k = Array.isArray(O) ? [] : {};
        for ($ in O) k[$] = w(O[$]);
        return k;
      }
      function A(O, $) {
        return function() {
          O.apply($, arguments);
        };
      }
      function E(O) {
        return typeof O == "function";
      }
      return c.parse = function(O, $) {
        var k = ($ = $ || {}).dynamicTyping || !1;
        if (E(k) && ($.dynamicTypingFunction = k, k = {}), $.dynamicTyping = k, $.transform = !!E($.transform) && $.transform, !$.worker || !c.WORKERS_SUPPORTED) return k = null, c.NODE_STREAM_INPUT, typeof O == "string" ? (O = ((j) => j.charCodeAt(0) !== 65279 ? j : j.slice(1))(O), k = new ($.download ? h : p)($)) : O.readable === !0 && E(O.read) && E(O.on) ? k = new l($) : (i.File && O instanceof File || O instanceof Object) && (k = new y($)), k.stream(O);
        (k = (() => {
          var j;
          return !!c.WORKERS_SUPPORTED && (j = (() => {
            var P = i.URL || i.webkitURL || null, R = r.toString();
            return c.BLOB_URL || (c.BLOB_URL = P.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", R, ")();"], { type: "text/javascript" })));
          })(), (j = new i.Worker(j)).onmessage = g, j.id = u++, a[j.id] = j);
        })()).userStep = $.step, k.userChunk = $.chunk, k.userComplete = $.complete, k.userError = $.error, $.step = E($.step), $.chunk = E($.chunk), $.complete = E($.complete), $.error = E($.error), delete $.worker, k.postMessage({ input: O, config: $, workerId: k.id });
      }, c.unparse = function(O, $) {
        var k = !1, j = !0, P = ",", R = `\r
`, I = '"', z = I + I, W = !1, F = null, te = !1, ee = ((() => {
          if (typeof $ == "object") {
            if (typeof $.delimiter != "string" || c.BAD_DELIMITERS.filter(function(D) {
              return $.delimiter.indexOf(D) !== -1;
            }).length || (P = $.delimiter), typeof $.quotes != "boolean" && typeof $.quotes != "function" && !Array.isArray($.quotes) || (k = $.quotes), typeof $.skipEmptyLines != "boolean" && typeof $.skipEmptyLines != "string" || (W = $.skipEmptyLines), typeof $.newline == "string" && (R = $.newline), typeof $.quoteChar == "string" && (I = $.quoteChar), typeof $.header == "boolean" && (j = $.header), Array.isArray($.columns)) {
              if ($.columns.length === 0) throw new Error("Option columns is empty");
              F = $.columns;
            }
            $.escapeChar !== void 0 && (z = $.escapeChar + I), $.escapeFormulae instanceof RegExp ? te = $.escapeFormulae : typeof $.escapeFormulae == "boolean" && $.escapeFormulae && (te = /^[=+\-@\t\r].*$/);
          }
        })(), new RegExp(v(I), "g"));
        if (typeof O == "string" && (O = JSON.parse(O)), Array.isArray(O)) {
          if (!O.length || Array.isArray(O[0])) return V(null, O, W);
          if (typeof O[0] == "object") return V(F || Object.keys(O[0]), O, W);
        } else if (typeof O == "object") return typeof O.data == "string" && (O.data = JSON.parse(O.data)), Array.isArray(O.data) && (O.fields || (O.fields = O.meta && O.meta.fields || F), O.fields || (O.fields = Array.isArray(O.data[0]) ? O.fields : typeof O.data[0] == "object" ? Object.keys(O.data[0]) : []), Array.isArray(O.data[0]) || typeof O.data[0] == "object" || (O.data = [O.data])), V(O.fields || [], O.data || [], W);
        throw new Error("Unable to serialize unrecognized input");
        function V(D, L, M) {
          var N = "", Z = (typeof D == "string" && (D = JSON.parse(D)), typeof L == "string" && (L = JSON.parse(L)), Array.isArray(D) && 0 < D.length), Y = !Array.isArray(L[0]);
          if (Z && j) {
            for (var ie = 0; ie < D.length; ie++) 0 < ie && (N += P), N += T(D[ie], ie);
            0 < L.length && (N += R);
          }
          for (var le = 0; le < L.length; le++) {
            var de = (Z ? D : L[le]).length, ae = !1, ne = Z ? Object.keys(L[le]).length === 0 : L[le].length === 0;
            if (M && !Z && (ae = M === "greedy" ? L[le].join("").trim() === "" : L[le].length === 1 && L[le][0].length === 0), M === "greedy" && Z) {
              for (var he = [], x = 0; x < de; x++) {
                var U = Y ? D[x] : x;
                he.push(L[le][U]);
              }
              ae = he.join("").trim() === "";
            }
            if (!ae) {
              for (var B = 0; B < de; B++) {
                0 < B && !ne && (N += P);
                var J = Z && Y ? D[B] : B;
                N += T(L[le][J], B);
              }
              le < L.length - 1 && (!M || 0 < de && !ne) && (N += R);
            }
          }
          return N;
        }
        function T(D, L) {
          var M, N;
          return D == null ? "" : D.constructor === Date ? JSON.stringify(D).slice(1, 25) : (N = !1, te && typeof D == "string" && te.test(D) && (D = "'" + D, N = !0), M = D.toString().replace(ee, z), (N = N || k === !0 || typeof k == "function" && k(D, L) || Array.isArray(k) && k[L] || ((Z, Y) => {
            for (var ie = 0; ie < Y.length; ie++) if (-1 < Z.indexOf(Y[ie])) return !0;
            return !1;
          })(M, c.BAD_DELIMITERS) || -1 < M.indexOf(P) || M.charAt(0) === " " || M.charAt(M.length - 1) === " ") ? I + M + I : M);
        }
      }, c.RECORD_SEP = "", c.UNIT_SEP = "", c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = ["\r", `
`, '"', c.BYTE_ORDER_MARK], c.WORKERS_SUPPORTED = !o && !!i.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = m, c.ParserHandle = d, c.NetworkStreamer = h, c.FileStreamer = y, c.StringStreamer = p, c.ReadableStreamStreamer = l, i.jQuery && ((n = i.jQuery).fn.parse = function(O) {
        var $ = O.config || {}, k = [];
        return this.each(function(R) {
          if (!(n(this).prop("tagName").toUpperCase() === "INPUT" && n(this).attr("type").toLowerCase() === "file" && i.FileReader) || !this.files || this.files.length === 0) return !0;
          for (var I = 0; I < this.files.length; I++) k.push({ file: this.files[I], inputElem: this, instanceConfig: n.extend({}, $) });
        }), j(), this;
        function j() {
          if (k.length === 0) E(O.complete) && O.complete();
          else {
            var R, I, z, W, F = k[0];
            if (E(O.before)) {
              var te = O.before(F.file, F.inputElem);
              if (typeof te == "object") {
                if (te.action === "abort") return R = "AbortError", I = F.file, z = F.inputElem, W = te.reason, void (E(O.error) && O.error({ name: R }, I, z, W));
                if (te.action === "skip") return void P();
                typeof te.config == "object" && (F.instanceConfig = n.extend(F.instanceConfig, te.config));
              } else if (te === "skip") return void P();
            }
            var ee = F.instanceConfig.complete;
            F.instanceConfig.complete = function(V) {
              E(ee) && ee(V, F.file, F.inputElem), P();
            }, c.parse(F.file, F.instanceConfig);
          }
        }
        function P() {
          k.splice(0, 1), j();
        }
      }), s && (i.onmessage = function(O) {
        O = O.data, c.WORKER_ID === void 0 && O && (c.WORKER_ID = O.workerId), typeof O.input == "string" ? i.postMessage({ workerId: c.WORKER_ID, results: c.parse(O.input, O.config), finished: !0 }) : (i.File && O.input instanceof File || O.input instanceof Object) && (O = c.parse(O.input, O.config)) && i.postMessage({ workerId: c.WORKER_ID, results: O, finished: !0 });
      }), (h.prototype = Object.create(f.prototype)).constructor = h, (y.prototype = Object.create(f.prototype)).constructor = y, (p.prototype = Object.create(p.prototype)).constructor = p, (l.prototype = Object.create(f.prototype)).constructor = l, c;
    });
  })(Bs)), Bs.exports;
}
var HB = KB();
const Aq = /* @__PURE__ */ Bi(HB);
/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */
const {
  entries: Aj,
  setPrototypeOf: a_,
  isFrozen: JB,
  getPrototypeOf: YB,
  getOwnPropertyDescriptor: XB
} = Object;
let {
  freeze: dn,
  seal: zn,
  create: Yp
} = Object, {
  apply: Xp,
  construct: Qp
} = typeof Reflect < "u" && Reflect;
dn || (dn = function(t) {
  return t;
});
zn || (zn = function(t) {
  return t;
});
Xp || (Xp = function(t, r) {
  for (var i = arguments.length, n = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)
    n[o - 2] = arguments[o];
  return t.apply(r, n);
});
Qp || (Qp = function(t) {
  for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)
    i[n - 1] = arguments[n];
  return new t(...i);
});
const Ns = mn(Array.prototype.forEach), QB = mn(Array.prototype.lastIndexOf), s_ = mn(Array.prototype.pop), ha = mn(Array.prototype.push), e9 = mn(Array.prototype.splice), qs = mn(String.prototype.toLowerCase), sl = mn(String.prototype.toString), ul = mn(String.prototype.match), pa = mn(String.prototype.replace), t9 = mn(String.prototype.indexOf), r9 = mn(String.prototype.trim), qn = mn(Object.prototype.hasOwnProperty), fn = mn(RegExp.prototype.test), da = n9(TypeError);
function mn(e) {
  return function(t) {
    t instanceof RegExp && (t.lastIndex = 0);
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)
      i[n - 1] = arguments[n];
    return Xp(e, t, i);
  };
}
function n9(e) {
  return function() {
    for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
      r[i] = arguments[i];
    return Qp(e, r);
  };
}
function Vt(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : qs;
  a_ && a_(e, null);
  let i = t.length;
  for (; i--; ) {
    let n = t[i];
    if (typeof n == "string") {
      const o = r(n);
      o !== n && (JB(t) || (t[i] = o), n = o);
    }
    e[n] = !0;
  }
  return e;
}
function i9(e) {
  for (let t = 0; t < e.length; t++)
    qn(e, t) || (e[t] = null);
  return e;
}
function yi(e) {
  const t = Yp(null);
  for (const [r, i] of Aj(e))
    qn(e, r) && (Array.isArray(i) ? t[r] = i9(i) : i && typeof i == "object" && i.constructor === Object ? t[r] = yi(i) : t[r] = i);
  return t;
}
function ma(e, t) {
  for (; e !== null; ) {
    const i = XB(e, t);
    if (i) {
      if (i.get)
        return mn(i.get);
      if (typeof i.value == "function")
        return mn(i.value);
    }
    e = YB(e);
  }
  function r() {
    return null;
  }
  return r;
}
const u_ = dn(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), cl = dn(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ll = dn(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), o9 = dn(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), fl = dn(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), a9 = dn(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), c_ = dn(["#text"]), l_ = dn(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), hl = dn(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), f_ = dn(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Cs = dn(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), s9 = zn(/\{\{[\w\W]*|[\w\W]*\}\}/gm), u9 = zn(/<%[\w\W]*|[\w\W]*%>/gm), c9 = zn(/\$\{[\w\W]*/gm), l9 = zn(/^data-[\-\w.\u00B7-\uFFFF]+$/), f9 = zn(/^aria-[\-\w]+$/), jj = zn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), h9 = zn(/^(?:\w+script|data):/i), p9 = zn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), kj = zn(/^html$/i), d9 = zn(/^[a-z][.\w]*(-[.\w]+)+$/i);
var h_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: f9,
  ATTR_WHITESPACE: p9,
  CUSTOM_ELEMENT: d9,
  DATA_ATTR: l9,
  DOCTYPE_NAME: kj,
  ERB_EXPR: u9,
  IS_ALLOWED_URI: jj,
  IS_SCRIPT_OR_DATA: h9,
  MUSTACHE_EXPR: s9,
  TMPLIT_EXPR: c9
});
const ya = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, m9 = function() {
  return typeof window > "u" ? null : window;
}, y9 = function(t, r) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let i = null;
  const n = "data-tt-policy-suffix";
  r && r.hasAttribute(n) && (i = r.getAttribute(n));
  const o = "dompurify" + (i ? "#" + i : "");
  try {
    return t.createPolicy(o, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + o + " could not be created."), null;
  }
}, p_ = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function Pj() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : m9();
  const t = (Ne) => Pj(Ne);
  if (t.version = "3.3.0", t.removed = [], !e || !e.document || e.document.nodeType !== ya.document || !e.Element)
    return t.isSupported = !1, t;
  let {
    document: r
  } = e;
  const i = r, n = i.currentScript, {
    DocumentFragment: o,
    HTMLTemplateElement: s,
    Node: a,
    Element: u,
    NodeFilter: c,
    NamedNodeMap: f = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: y,
    trustedTypes: p
  } = e, l = u.prototype, d = ma(l, "cloneNode"), v = ma(l, "remove"), m = ma(l, "nextSibling"), g = ma(l, "childNodes"), _ = ma(l, "parentNode");
  if (typeof s == "function") {
    const Ne = r.createElement("template");
    Ne.content && Ne.content.ownerDocument && (r = Ne.content.ownerDocument);
  }
  let b, w = "";
  const {
    implementation: A,
    createNodeIterator: E,
    createDocumentFragment: O,
    getElementsByTagName: $
  } = r, {
    importNode: k
  } = i;
  let j = p_();
  t.isSupported = typeof Aj == "function" && typeof _ == "function" && A && A.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: P,
    ERB_EXPR: R,
    TMPLIT_EXPR: I,
    DATA_ATTR: z,
    ARIA_ATTR: W,
    IS_SCRIPT_OR_DATA: F,
    ATTR_WHITESPACE: te,
    CUSTOM_ELEMENT: ee
  } = h_;
  let {
    IS_ALLOWED_URI: V
  } = h_, T = null;
  const D = Vt({}, [...u_, ...cl, ...ll, ...fl, ...c_]);
  let L = null;
  const M = Vt({}, [...l_, ...hl, ...f_, ...Cs]);
  let N = Object.seal(Yp(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Z = null, Y = null;
  const ie = Object.seal(Yp(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let le = !0, de = !0, ae = !1, ne = !0, he = !1, x = !0, U = !1, B = !1, J = !1, X = !1, oe = !1, ye = !1, q = !0, G = !1;
  const ce = "user-content-";
  let ue = !0, re = !1, pe = {}, xe = null;
  const be = Vt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Ee = null;
  const Ue = Vt({}, ["audio", "video", "img", "source", "image", "track"]);
  let Ae = null;
  const Me = Vt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), et = "http://www.w3.org/1998/Math/MathML", lt = "http://www.w3.org/2000/svg", ft = "http://www.w3.org/1999/xhtml";
  let Ke = ft, Xt = !1, $t = null;
  const Pt = Vt({}, [et, lt, ft], sl);
  let Tt = Vt({}, ["mi", "mo", "mn", "ms", "mtext"]), Ft = Vt({}, ["annotation-xml"]);
  const xt = Vt({}, ["title", "style", "font", "a", "script"]);
  let ir = null;
  const Le = ["application/xhtml+xml", "text/html"], Pr = "text/html";
  let It = null, je = null;
  const qr = r.createElement("form"), Cn = function(fe) {
    return fe instanceof RegExp || fe instanceof Function;
  }, Wr = function() {
    let fe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(je && je === fe)) {
      if ((!fe || typeof fe != "object") && (fe = {}), fe = yi(fe), ir = // eslint-disable-next-line unicorn/prefer-includes
      Le.indexOf(fe.PARSER_MEDIA_TYPE) === -1 ? Pr : fe.PARSER_MEDIA_TYPE, It = ir === "application/xhtml+xml" ? sl : qs, T = qn(fe, "ALLOWED_TAGS") ? Vt({}, fe.ALLOWED_TAGS, It) : D, L = qn(fe, "ALLOWED_ATTR") ? Vt({}, fe.ALLOWED_ATTR, It) : M, $t = qn(fe, "ALLOWED_NAMESPACES") ? Vt({}, fe.ALLOWED_NAMESPACES, sl) : Pt, Ae = qn(fe, "ADD_URI_SAFE_ATTR") ? Vt(yi(Me), fe.ADD_URI_SAFE_ATTR, It) : Me, Ee = qn(fe, "ADD_DATA_URI_TAGS") ? Vt(yi(Ue), fe.ADD_DATA_URI_TAGS, It) : Ue, xe = qn(fe, "FORBID_CONTENTS") ? Vt({}, fe.FORBID_CONTENTS, It) : be, Z = qn(fe, "FORBID_TAGS") ? Vt({}, fe.FORBID_TAGS, It) : yi({}), Y = qn(fe, "FORBID_ATTR") ? Vt({}, fe.FORBID_ATTR, It) : yi({}), pe = qn(fe, "USE_PROFILES") ? fe.USE_PROFILES : !1, le = fe.ALLOW_ARIA_ATTR !== !1, de = fe.ALLOW_DATA_ATTR !== !1, ae = fe.ALLOW_UNKNOWN_PROTOCOLS || !1, ne = fe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, he = fe.SAFE_FOR_TEMPLATES || !1, x = fe.SAFE_FOR_XML !== !1, U = fe.WHOLE_DOCUMENT || !1, X = fe.RETURN_DOM || !1, oe = fe.RETURN_DOM_FRAGMENT || !1, ye = fe.RETURN_TRUSTED_TYPE || !1, J = fe.FORCE_BODY || !1, q = fe.SANITIZE_DOM !== !1, G = fe.SANITIZE_NAMED_PROPS || !1, ue = fe.KEEP_CONTENT !== !1, re = fe.IN_PLACE || !1, V = fe.ALLOWED_URI_REGEXP || jj, Ke = fe.NAMESPACE || ft, Tt = fe.MATHML_TEXT_INTEGRATION_POINTS || Tt, Ft = fe.HTML_INTEGRATION_POINTS || Ft, N = fe.CUSTOM_ELEMENT_HANDLING || {}, fe.CUSTOM_ELEMENT_HANDLING && Cn(fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (N.tagNameCheck = fe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), fe.CUSTOM_ELEMENT_HANDLING && Cn(fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (N.attributeNameCheck = fe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), fe.CUSTOM_ELEMENT_HANDLING && typeof fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (N.allowCustomizedBuiltInElements = fe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), he && (de = !1), oe && (X = !0), pe && (T = Vt({}, c_), L = [], pe.html === !0 && (Vt(T, u_), Vt(L, l_)), pe.svg === !0 && (Vt(T, cl), Vt(L, hl), Vt(L, Cs)), pe.svgFilters === !0 && (Vt(T, ll), Vt(L, hl), Vt(L, Cs)), pe.mathMl === !0 && (Vt(T, fl), Vt(L, f_), Vt(L, Cs))), fe.ADD_TAGS && (typeof fe.ADD_TAGS == "function" ? ie.tagCheck = fe.ADD_TAGS : (T === D && (T = yi(T)), Vt(T, fe.ADD_TAGS, It))), fe.ADD_ATTR && (typeof fe.ADD_ATTR == "function" ? ie.attributeCheck = fe.ADD_ATTR : (L === M && (L = yi(L)), Vt(L, fe.ADD_ATTR, It))), fe.ADD_URI_SAFE_ATTR && Vt(Ae, fe.ADD_URI_SAFE_ATTR, It), fe.FORBID_CONTENTS && (xe === be && (xe = yi(xe)), Vt(xe, fe.FORBID_CONTENTS, It)), ue && (T["#text"] = !0), U && Vt(T, ["html", "head", "body"]), T.table && (Vt(T, ["tbody"]), delete Z.tbody), fe.TRUSTED_TYPES_POLICY) {
        if (typeof fe.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw da('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof fe.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw da('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        b = fe.TRUSTED_TYPES_POLICY, w = b.createHTML("");
      } else
        b === void 0 && (b = y9(p, n)), b !== null && typeof w == "string" && (w = b.createHTML(""));
      dn && dn(fe), je = fe;
    }
  }, or = Vt({}, [...cl, ...ll, ...o9]), Gr = Vt({}, [...fl, ...a9]), ti = function(fe) {
    let Pe = _(fe);
    (!Pe || !Pe.tagName) && (Pe = {
      namespaceURI: Ke,
      tagName: "template"
    });
    const De = qs(fe.tagName), We = qs(Pe.tagName);
    return $t[fe.namespaceURI] ? fe.namespaceURI === lt ? Pe.namespaceURI === ft ? De === "svg" : Pe.namespaceURI === et ? De === "svg" && (We === "annotation-xml" || Tt[We]) : !!or[De] : fe.namespaceURI === et ? Pe.namespaceURI === ft ? De === "math" : Pe.namespaceURI === lt ? De === "math" && Ft[We] : !!Gr[De] : fe.namespaceURI === ft ? Pe.namespaceURI === lt && !Ft[We] || Pe.namespaceURI === et && !Tt[We] ? !1 : !Gr[De] && (xt[De] || !or[De]) : !!(ir === "application/xhtml+xml" && $t[fe.namespaceURI]) : !1;
  }, mr = function(fe) {
    ha(t.removed, {
      element: fe
    });
    try {
      _(fe).removeChild(fe);
    } catch {
      v(fe);
    }
  }, on = function(fe, Pe) {
    try {
      ha(t.removed, {
        attribute: Pe.getAttributeNode(fe),
        from: Pe
      });
    } catch {
      ha(t.removed, {
        attribute: null,
        from: Pe
      });
    }
    if (Pe.removeAttribute(fe), fe === "is")
      if (X || oe)
        try {
          mr(Pe);
        } catch {
        }
      else
        try {
          Pe.setAttribute(fe, "");
        } catch {
        }
  }, K = function(fe) {
    let Pe = null, De = null;
    if (J)
      fe = "<remove></remove>" + fe;
    else {
      const rt = ul(fe, /^[\r\n\t ]+/);
      De = rt && rt[0];
    }
    ir === "application/xhtml+xml" && Ke === ft && (fe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + fe + "</body></html>");
    const We = b ? b.createHTML(fe) : fe;
    if (Ke === ft)
      try {
        Pe = new y().parseFromString(We, ir);
      } catch {
      }
    if (!Pe || !Pe.documentElement) {
      Pe = A.createDocument(Ke, "template", null);
      try {
        Pe.documentElement.innerHTML = Xt ? w : We;
      } catch {
      }
    }
    const Qe = Pe.body || Pe.documentElement;
    return fe && De && Qe.insertBefore(r.createTextNode(De), Qe.childNodes[0] || null), Ke === ft ? $.call(Pe, U ? "html" : "body")[0] : U ? Pe.documentElement : Qe;
  }, se = function(fe) {
    return E.call(
      fe.ownerDocument || fe,
      fe,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, me = function(fe) {
    return fe instanceof h && (typeof fe.nodeName != "string" || typeof fe.textContent != "string" || typeof fe.removeChild != "function" || !(fe.attributes instanceof f) || typeof fe.removeAttribute != "function" || typeof fe.setAttribute != "function" || typeof fe.namespaceURI != "string" || typeof fe.insertBefore != "function" || typeof fe.hasChildNodes != "function");
  }, ge = function(fe) {
    return typeof a == "function" && fe instanceof a;
  };
  function _e(Ne, fe, Pe) {
    Ns(Ne, (De) => {
      De.call(t, fe, Pe, je);
    });
  }
  const $e = function(fe) {
    let Pe = null;
    if (_e(j.beforeSanitizeElements, fe, null), me(fe))
      return mr(fe), !0;
    const De = It(fe.nodeName);
    if (_e(j.uponSanitizeElement, fe, {
      tagName: De,
      allowedTags: T
    }), x && fe.hasChildNodes() && !ge(fe.firstElementChild) && fn(/<[/\w!]/g, fe.innerHTML) && fn(/<[/\w!]/g, fe.textContent) || fe.nodeType === ya.progressingInstruction || x && fe.nodeType === ya.comment && fn(/<[/\w]/g, fe.data))
      return mr(fe), !0;
    if (!(ie.tagCheck instanceof Function && ie.tagCheck(De)) && (!T[De] || Z[De])) {
      if (!Z[De] && Ie(De) && (N.tagNameCheck instanceof RegExp && fn(N.tagNameCheck, De) || N.tagNameCheck instanceof Function && N.tagNameCheck(De)))
        return !1;
      if (ue && !xe[De]) {
        const We = _(fe) || fe.parentNode, Qe = g(fe) || fe.childNodes;
        if (Qe && We) {
          const rt = Qe.length;
          for (let ot = rt - 1; ot >= 0; --ot) {
            const Ot = d(Qe[ot], !0);
            Ot.__removalCount = (fe.__removalCount || 0) + 1, We.insertBefore(Ot, m(fe));
          }
        }
      }
      return mr(fe), !0;
    }
    return fe instanceof u && !ti(fe) || (De === "noscript" || De === "noembed" || De === "noframes") && fn(/<\/no(script|embed|frames)/i, fe.innerHTML) ? (mr(fe), !0) : (he && fe.nodeType === ya.text && (Pe = fe.textContent, Ns([P, R, I], (We) => {
      Pe = pa(Pe, We, " ");
    }), fe.textContent !== Pe && (ha(t.removed, {
      element: fe.cloneNode()
    }), fe.textContent = Pe)), _e(j.afterSanitizeElements, fe, null), !1);
  }, Te = function(fe, Pe, De) {
    if (q && (Pe === "id" || Pe === "name") && (De in r || De in qr))
      return !1;
    if (!(de && !Y[Pe] && fn(z, Pe))) {
      if (!(le && fn(W, Pe))) {
        if (!(ie.attributeCheck instanceof Function && ie.attributeCheck(Pe, fe))) {
          if (!L[Pe] || Y[Pe]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(Ie(fe) && (N.tagNameCheck instanceof RegExp && fn(N.tagNameCheck, fe) || N.tagNameCheck instanceof Function && N.tagNameCheck(fe)) && (N.attributeNameCheck instanceof RegExp && fn(N.attributeNameCheck, Pe) || N.attributeNameCheck instanceof Function && N.attributeNameCheck(Pe, fe)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Pe === "is" && N.allowCustomizedBuiltInElements && (N.tagNameCheck instanceof RegExp && fn(N.tagNameCheck, De) || N.tagNameCheck instanceof Function && N.tagNameCheck(De)))
            ) return !1;
          } else if (!Ae[Pe]) {
            if (!fn(V, pa(De, te, ""))) {
              if (!((Pe === "src" || Pe === "xlink:href" || Pe === "href") && fe !== "script" && t9(De, "data:") === 0 && Ee[fe])) {
                if (!(ae && !fn(F, pa(De, te, "")))) {
                  if (De)
                    return !1;
                }
              }
            }
          }
        }
      }
    }
    return !0;
  }, Ie = function(fe) {
    return fe !== "annotation-xml" && ul(fe, ee);
  }, qe = function(fe) {
    _e(j.beforeSanitizeAttributes, fe, null);
    const {
      attributes: Pe
    } = fe;
    if (!Pe || me(fe))
      return;
    const De = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: L,
      forceKeepAttr: void 0
    };
    let We = Pe.length;
    for (; We--; ) {
      const Qe = Pe[We], {
        name: rt,
        namespaceURI: ot,
        value: Ot
      } = Qe, Lt = It(rt), _t = Ot;
      let St = rt === "value" ? _t : r9(_t);
      if (De.attrName = Lt, De.attrValue = St, De.keepAttr = !0, De.forceKeepAttr = void 0, _e(j.uponSanitizeAttribute, fe, De), St = De.attrValue, G && (Lt === "id" || Lt === "name") && (on(rt, fe), St = ce + St), x && fn(/((--!?|])>)|<\/(style|title|textarea)/i, St)) {
        on(rt, fe);
        continue;
      }
      if (Lt === "attributename" && ul(St, "href")) {
        on(rt, fe);
        continue;
      }
      if (De.forceKeepAttr)
        continue;
      if (!De.keepAttr) {
        on(rt, fe);
        continue;
      }
      if (!ne && fn(/\/>/i, St)) {
        on(rt, fe);
        continue;
      }
      he && Ns([P, R, I], (Et) => {
        St = pa(St, Et, " ");
      });
      const zt = It(fe.nodeName);
      if (!Te(zt, Lt, St)) {
        on(rt, fe);
        continue;
      }
      if (b && typeof p == "object" && typeof p.getAttributeType == "function" && !ot)
        switch (p.getAttributeType(zt, Lt)) {
          case "TrustedHTML": {
            St = b.createHTML(St);
            break;
          }
          case "TrustedScriptURL": {
            St = b.createScriptURL(St);
            break;
          }
        }
      if (St !== _t)
        try {
          ot ? fe.setAttributeNS(ot, rt, St) : fe.setAttribute(rt, St), me(fe) ? mr(fe) : s_(t.removed);
        } catch {
          on(rt, fe);
        }
    }
    _e(j.afterSanitizeAttributes, fe, null);
  }, Fe = function Ne(fe) {
    let Pe = null;
    const De = se(fe);
    for (_e(j.beforeSanitizeShadowDOM, fe, null); Pe = De.nextNode(); )
      _e(j.uponSanitizeShadowNode, Pe, null), $e(Pe), qe(Pe), Pe.content instanceof o && Ne(Pe.content);
    _e(j.afterSanitizeShadowDOM, fe, null);
  };
  return t.sanitize = function(Ne) {
    let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Pe = null, De = null, We = null, Qe = null;
    if (Xt = !Ne, Xt && (Ne = "<!-->"), typeof Ne != "string" && !ge(Ne))
      if (typeof Ne.toString == "function") {
        if (Ne = Ne.toString(), typeof Ne != "string")
          throw da("dirty is not a string, aborting");
      } else
        throw da("toString is not a function");
    if (!t.isSupported)
      return Ne;
    if (B || Wr(fe), t.removed = [], typeof Ne == "string" && (re = !1), re) {
      if (Ne.nodeName) {
        const Ot = It(Ne.nodeName);
        if (!T[Ot] || Z[Ot])
          throw da("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ne instanceof a)
      Pe = K("<!---->"), De = Pe.ownerDocument.importNode(Ne, !0), De.nodeType === ya.element && De.nodeName === "BODY" || De.nodeName === "HTML" ? Pe = De : Pe.appendChild(De);
    else {
      if (!X && !he && !U && // eslint-disable-next-line unicorn/prefer-includes
      Ne.indexOf("<") === -1)
        return b && ye ? b.createHTML(Ne) : Ne;
      if (Pe = K(Ne), !Pe)
        return X ? null : ye ? w : "";
    }
    Pe && J && mr(Pe.firstChild);
    const rt = se(re ? Ne : Pe);
    for (; We = rt.nextNode(); )
      $e(We), qe(We), We.content instanceof o && Fe(We.content);
    if (re)
      return Ne;
    if (X) {
      if (oe)
        for (Qe = O.call(Pe.ownerDocument); Pe.firstChild; )
          Qe.appendChild(Pe.firstChild);
      else
        Qe = Pe;
      return (L.shadowroot || L.shadowrootmode) && (Qe = k.call(i, Qe, !0)), Qe;
    }
    let ot = U ? Pe.outerHTML : Pe.innerHTML;
    return U && T["!doctype"] && Pe.ownerDocument && Pe.ownerDocument.doctype && Pe.ownerDocument.doctype.name && fn(kj, Pe.ownerDocument.doctype.name) && (ot = "<!DOCTYPE " + Pe.ownerDocument.doctype.name + `>
` + ot), he && Ns([P, R, I], (Ot) => {
      ot = pa(ot, Ot, " ");
    }), b && ye ? b.createHTML(ot) : ot;
  }, t.setConfig = function() {
    let Ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Wr(Ne), B = !0;
  }, t.clearConfig = function() {
    je = null, B = !1;
  }, t.isValidAttribute = function(Ne, fe, Pe) {
    je || Wr({});
    const De = It(Ne), We = It(fe);
    return Te(De, We, Pe);
  }, t.addHook = function(Ne, fe) {
    typeof fe == "function" && ha(j[Ne], fe);
  }, t.removeHook = function(Ne, fe) {
    if (fe !== void 0) {
      const Pe = QB(j[Ne], fe);
      return Pe === -1 ? void 0 : e9(j[Ne], Pe, 1)[0];
    }
    return s_(j[Ne]);
  }, t.removeHooks = function(Ne) {
    j[Ne] = [];
  }, t.removeAllHooks = function() {
    j = p_();
  }, t;
}
var g9 = Pj();
const jq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: g9 }, Symbol.toStringTag, { value: "Module" }));
var d_ = {}, m_ = {}, ga, y_;
function xr() {
  if (y_) return ga;
  y_ = 1;
  var e = function(t) {
    return t && t.Math === Math && t;
  };
  return ga = // eslint-disable-next-line es/no-global-this -- safe
  e(typeof globalThis == "object" && globalThis) || e(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  e(typeof self == "object" && self) || e(typeof Ji == "object" && Ji) || e(typeof ga == "object" && ga) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ (function() {
    return this;
  })() || Function("return this")(), ga;
}
var pl = {}, dl, g_;
function Dr() {
  return g_ || (g_ = 1, dl = function(e) {
    try {
      return !!e();
    } catch {
      return !0;
    }
  }), dl;
}
var ml, v_;
function Xn() {
  if (v_) return ml;
  v_ = 1;
  var e = Dr();
  return ml = !e(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  }), ml;
}
var yl, b_;
function yc() {
  if (b_) return yl;
  b_ = 1;
  var e = Dr();
  return yl = !e(function() {
    var t = (function() {
    }).bind();
    return typeof t != "function" || t.hasOwnProperty("prototype");
  }), yl;
}
var gl, __;
function nn() {
  if (__) return gl;
  __ = 1;
  var e = yc(), t = Function.prototype.call;
  return gl = e ? t.bind(t) : function() {
    return t.apply(t, arguments);
  }, gl;
}
var vl = {}, w_;
function v9() {
  if (w_) return vl;
  w_ = 1;
  var e = {}.propertyIsEnumerable, t = Object.getOwnPropertyDescriptor, r = t && !e.call({ 1: 2 }, 1);
  return vl.f = r ? function(n) {
    var o = t(this, n);
    return !!o && o.enumerable;
  } : e, vl;
}
var bl, O_;
function pg() {
  return O_ || (O_ = 1, bl = function(e, t) {
    return {
      enumerable: !(e & 1),
      configurable: !(e & 2),
      writable: !(e & 4),
      value: t
    };
  }), bl;
}
var _l, $_;
function zr() {
  if ($_) return _l;
  $_ = 1;
  var e = yc(), t = Function.prototype, r = t.call, i = e && t.bind.bind(r, r);
  return _l = e ? i : function(n) {
    return function() {
      return r.apply(n, arguments);
    };
  }, _l;
}
var wl, S_;
function bo() {
  if (S_) return wl;
  S_ = 1;
  var e = zr(), t = e({}.toString), r = e("".slice);
  return wl = function(i) {
    return r(t(i), 8, -1);
  }, wl;
}
var Ol, E_;
function Ij() {
  if (E_) return Ol;
  E_ = 1;
  var e = zr(), t = Dr(), r = bo(), i = Object, n = e("".split);
  return Ol = t(function() {
    return !i("z").propertyIsEnumerable(0);
  }) ? function(o) {
    return r(o) === "String" ? n(o, "") : i(o);
  } : i, Ol;
}
var $l, x_;
function gc() {
  return x_ || (x_ = 1, $l = function(e) {
    return e == null;
  }), $l;
}
var Sl, A_;
function Qn() {
  if (A_) return Sl;
  A_ = 1;
  var e = gc(), t = TypeError;
  return Sl = function(r) {
    if (e(r)) throw new t("Can't call method on " + r);
    return r;
  }, Sl;
}
var El, j_;
function ss() {
  if (j_) return El;
  j_ = 1;
  var e = Ij(), t = Qn();
  return El = function(r) {
    return e(t(r));
  }, El;
}
var xl, k_;
function Br() {
  if (k_) return xl;
  k_ = 1;
  var e = typeof document == "object" && document.all;
  return xl = typeof e > "u" && e !== void 0 ? function(t) {
    return typeof t == "function" || t === e;
  } : function(t) {
    return typeof t == "function";
  }, xl;
}
var Al, P_;
function $n() {
  if (P_) return Al;
  P_ = 1;
  var e = Br();
  return Al = function(t) {
    return typeof t == "object" ? t !== null : e(t);
  }, Al;
}
var jl, I_;
function _o() {
  if (I_) return jl;
  I_ = 1;
  var e = xr(), t = Br(), r = function(i) {
    return t(i) ? i : void 0;
  };
  return jl = function(i, n) {
    return arguments.length < 2 ? r(e[i]) : e[i] && e[i][n];
  }, jl;
}
var kl, T_;
function vc() {
  if (T_) return kl;
  T_ = 1;
  var e = zr();
  return kl = e({}.isPrototypeOf), kl;
}
var Pl, N_;
function us() {
  if (N_) return Pl;
  N_ = 1;
  var e = xr(), t = e.navigator, r = t && t.userAgent;
  return Pl = r ? String(r) : "", Pl;
}
var Il, C_;
function dg() {
  if (C_) return Il;
  C_ = 1;
  var e = xr(), t = us(), r = e.process, i = e.Deno, n = r && r.versions || i && i.version, o = n && n.v8, s, a;
  return o && (s = o.split("."), a = s[0] > 0 && s[0] < 4 ? 1 : +(s[0] + s[1])), !a && t && (s = t.match(/Edge\/(\d+)/), (!s || s[1] >= 74) && (s = t.match(/Chrome\/(\d+)/), s && (a = +s[1]))), Il = a, Il;
}
var Tl, R_;
function Tj() {
  if (R_) return Tl;
  R_ = 1;
  var e = dg(), t = Dr(), r = xr(), i = r.String;
  return Tl = !!Object.getOwnPropertySymbols && !t(function() {
    var n = Symbol("symbol detection");
    return !i(n) || !(Object(n) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && e && e < 41;
  }), Tl;
}
var Nl, D_;
function Nj() {
  if (D_) return Nl;
  D_ = 1;
  var e = Tj();
  return Nl = e && !Symbol.sham && typeof Symbol.iterator == "symbol", Nl;
}
var Cl, z_;
function Cj() {
  if (z_) return Cl;
  z_ = 1;
  var e = _o(), t = Br(), r = vc(), i = Nj(), n = Object;
  return Cl = i ? function(o) {
    return typeof o == "symbol";
  } : function(o) {
    var s = e("Symbol");
    return t(s) && r(s.prototype, n(o));
  }, Cl;
}
var Rl, U_;
function bc() {
  if (U_) return Rl;
  U_ = 1;
  var e = String;
  return Rl = function(t) {
    try {
      return e(t);
    } catch {
      return "Object";
    }
  }, Rl;
}
var Dl, M_;
function Si() {
  if (M_) return Dl;
  M_ = 1;
  var e = Br(), t = bc(), r = TypeError;
  return Dl = function(i) {
    if (e(i)) return i;
    throw new r(t(i) + " is not a function");
  }, Dl;
}
var zl, F_;
function ea() {
  if (F_) return zl;
  F_ = 1;
  var e = Si(), t = gc();
  return zl = function(r, i) {
    var n = r[i];
    return t(n) ? void 0 : e(n);
  }, zl;
}
var Ul, L_;
function b9() {
  if (L_) return Ul;
  L_ = 1;
  var e = nn(), t = Br(), r = $n(), i = TypeError;
  return Ul = function(n, o) {
    var s, a;
    if (o === "string" && t(s = n.toString) && !r(a = e(s, n)) || t(s = n.valueOf) && !r(a = e(s, n)) || o !== "string" && t(s = n.toString) && !r(a = e(s, n))) return a;
    throw new i("Can't convert object to primitive value");
  }, Ul;
}
var Ml = { exports: {} }, Fl, B_;
function fi() {
  return B_ || (B_ = 1, Fl = !1), Fl;
}
var Ll, q_;
function mg() {
  if (q_) return Ll;
  q_ = 1;
  var e = xr(), t = Object.defineProperty;
  return Ll = function(r, i) {
    try {
      t(e, r, { value: i, configurable: !0, writable: !0 });
    } catch {
      e[r] = i;
    }
    return i;
  }, Ll;
}
var Z_;
function yg() {
  if (Z_) return Ml.exports;
  Z_ = 1;
  var e = fi(), t = xr(), r = mg(), i = "__core-js_shared__", n = Ml.exports = t[i] || r(i, {});
  return (n.versions || (n.versions = [])).push({
    version: "3.46.0",
    mode: e ? "pure" : "global",
    copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)",
    license: "https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  }), Ml.exports;
}
var Bl, V_;
function gg() {
  if (V_) return Bl;
  V_ = 1;
  var e = yg();
  return Bl = function(t, r) {
    return e[t] || (e[t] = r || {});
  }, Bl;
}
var ql, W_;
function _c() {
  if (W_) return ql;
  W_ = 1;
  var e = Qn(), t = Object;
  return ql = function(r) {
    return t(e(r));
  }, ql;
}
var Zl, G_;
function ei() {
  if (G_) return Zl;
  G_ = 1;
  var e = zr(), t = _c(), r = e({}.hasOwnProperty);
  return Zl = Object.hasOwn || function(n, o) {
    return r(t(n), o);
  }, Zl;
}
var Vl, K_;
function Rj() {
  if (K_) return Vl;
  K_ = 1;
  var e = zr(), t = 0, r = Math.random(), i = e(1.1.toString);
  return Vl = function(n) {
    return "Symbol(" + (n === void 0 ? "" : n) + ")_" + i(++t + r, 36);
  }, Vl;
}
var Wl, H_;
function rn() {
  if (H_) return Wl;
  H_ = 1;
  var e = xr(), t = gg(), r = ei(), i = Rj(), n = Tj(), o = Nj(), s = e.Symbol, a = t("wks"), u = o ? s.for || s : s && s.withoutSetter || i;
  return Wl = function(c) {
    return r(a, c) || (a[c] = n && r(s, c) ? s[c] : u("Symbol." + c)), a[c];
  }, Wl;
}
var Gl, J_;
function _9() {
  if (J_) return Gl;
  J_ = 1;
  var e = nn(), t = $n(), r = Cj(), i = ea(), n = b9(), o = rn(), s = TypeError, a = o("toPrimitive");
  return Gl = function(u, c) {
    if (!t(u) || r(u)) return u;
    var f = i(u, a), h;
    if (f) {
      if (c === void 0 && (c = "default"), h = e(f, u, c), !t(h) || r(h)) return h;
      throw new s("Can't convert object to primitive value");
    }
    return c === void 0 && (c = "number"), n(u, c);
  }, Gl;
}
var Kl, Y_;
function Dj() {
  if (Y_) return Kl;
  Y_ = 1;
  var e = _9(), t = Cj();
  return Kl = function(r) {
    var i = e(r, "string");
    return t(i) ? i : i + "";
  }, Kl;
}
var Hl, X_;
function wc() {
  if (X_) return Hl;
  X_ = 1;
  var e = xr(), t = $n(), r = e.document, i = t(r) && t(r.createElement);
  return Hl = function(n) {
    return i ? r.createElement(n) : {};
  }, Hl;
}
var Jl, Q_;
function zj() {
  if (Q_) return Jl;
  Q_ = 1;
  var e = Xn(), t = Dr(), r = wc();
  return Jl = !e && !t(function() {
    return Object.defineProperty(r("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  }), Jl;
}
var e0;
function Oc() {
  if (e0) return pl;
  e0 = 1;
  var e = Xn(), t = nn(), r = v9(), i = pg(), n = ss(), o = Dj(), s = ei(), a = zj(), u = Object.getOwnPropertyDescriptor;
  return pl.f = e ? u : function(f, h) {
    if (f = n(f), h = o(h), a) try {
      return u(f, h);
    } catch {
    }
    if (s(f, h)) return i(!t(r.f, f, h), f[h]);
  }, pl;
}
var Yl = {}, Xl, t0;
function Uj() {
  if (t0) return Xl;
  t0 = 1;
  var e = Xn(), t = Dr();
  return Xl = e && t(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: !1
    }).prototype !== 42;
  }), Xl;
}
var Ql, r0;
function yn() {
  if (r0) return Ql;
  r0 = 1;
  var e = $n(), t = String, r = TypeError;
  return Ql = function(i) {
    if (e(i)) return i;
    throw new r(t(i) + " is not an object");
  }, Ql;
}
var n0;
function Vi() {
  if (n0) return Yl;
  n0 = 1;
  var e = Xn(), t = zj(), r = Uj(), i = yn(), n = Dj(), o = TypeError, s = Object.defineProperty, a = Object.getOwnPropertyDescriptor, u = "enumerable", c = "configurable", f = "writable";
  return Yl.f = e ? r ? function(y, p, l) {
    if (i(y), p = n(p), i(l), typeof y == "function" && p === "prototype" && "value" in l && f in l && !l[f]) {
      var d = a(y, p);
      d && d[f] && (y[p] = l.value, l = {
        configurable: c in l ? l[c] : d[c],
        enumerable: u in l ? l[u] : d[u],
        writable: !1
      });
    }
    return s(y, p, l);
  } : s : function(y, p, l) {
    if (i(y), p = n(p), i(l), t) try {
      return s(y, p, l);
    } catch {
    }
    if ("get" in l || "set" in l) throw new o("Accessors not supported");
    return "value" in l && (y[p] = l.value), y;
  }, Yl;
}
var ef, i0;
function cs() {
  if (i0) return ef;
  i0 = 1;
  var e = Xn(), t = Vi(), r = pg();
  return ef = e ? function(i, n, o) {
    return t.f(i, n, r(1, o));
  } : function(i, n, o) {
    return i[n] = o, i;
  }, ef;
}
var tf = { exports: {} }, rf, o0;
function $c() {
  if (o0) return rf;
  o0 = 1;
  var e = Xn(), t = ei(), r = Function.prototype, i = e && Object.getOwnPropertyDescriptor, n = t(r, "name"), o = n && (function() {
  }).name === "something", s = n && (!e || e && i(r, "name").configurable);
  return rf = {
    EXISTS: n,
    PROPER: o,
    CONFIGURABLE: s
  }, rf;
}
var nf, a0;
function vg() {
  if (a0) return nf;
  a0 = 1;
  var e = zr(), t = Br(), r = yg(), i = e(Function.toString);
  return t(r.inspectSource) || (r.inspectSource = function(n) {
    return i(n);
  }), nf = r.inspectSource, nf;
}
var of, s0;
function w9() {
  if (s0) return of;
  s0 = 1;
  var e = xr(), t = Br(), r = e.WeakMap;
  return of = t(r) && /native code/.test(String(r)), of;
}
var af, u0;
function bg() {
  if (u0) return af;
  u0 = 1;
  var e = gg(), t = Rj(), r = e("keys");
  return af = function(i) {
    return r[i] || (r[i] = t(i));
  }, af;
}
var sf, c0;
function _g() {
  return c0 || (c0 = 1, sf = {}), sf;
}
var uf, l0;
function Sc() {
  if (l0) return uf;
  l0 = 1;
  var e = w9(), t = xr(), r = $n(), i = cs(), n = ei(), o = yg(), s = bg(), a = _g(), u = "Object already initialized", c = t.TypeError, f = t.WeakMap, h, y, p, l = function(g) {
    return p(g) ? y(g) : h(g, {});
  }, d = function(g) {
    return function(_) {
      var b;
      if (!r(_) || (b = y(_)).type !== g)
        throw new c("Incompatible receiver, " + g + " required");
      return b;
    };
  };
  if (e || o.state) {
    var v = o.state || (o.state = new f());
    v.get = v.get, v.has = v.has, v.set = v.set, h = function(g, _) {
      if (v.has(g)) throw new c(u);
      return _.facade = g, v.set(g, _), _;
    }, y = function(g) {
      return v.get(g) || {};
    }, p = function(g) {
      return v.has(g);
    };
  } else {
    var m = s("state");
    a[m] = !0, h = function(g, _) {
      if (n(g, m)) throw new c(u);
      return _.facade = g, i(g, m, _), _;
    }, y = function(g) {
      return n(g, m) ? g[m] : {};
    }, p = function(g) {
      return n(g, m);
    };
  }
  return uf = {
    set: h,
    get: y,
    has: p,
    enforce: l,
    getterFor: d
  }, uf;
}
var f0;
function Mj() {
  if (f0) return tf.exports;
  f0 = 1;
  var e = zr(), t = Dr(), r = Br(), i = ei(), n = Xn(), o = $c().CONFIGURABLE, s = vg(), a = Sc(), u = a.enforce, c = a.get, f = String, h = Object.defineProperty, y = e("".slice), p = e("".replace), l = e([].join), d = n && !t(function() {
    return h(function() {
    }, "length", { value: 8 }).length !== 8;
  }), v = String(String).split("String"), m = tf.exports = function(g, _, b) {
    y(f(_), 0, 7) === "Symbol(" && (_ = "[" + p(f(_), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), b && b.getter && (_ = "get " + _), b && b.setter && (_ = "set " + _), (!i(g, "name") || o && g.name !== _) && (n ? h(g, "name", { value: _, configurable: !0 }) : g.name = _), d && b && i(b, "arity") && g.length !== b.arity && h(g, "length", { value: b.arity });
    try {
      b && i(b, "constructor") && b.constructor ? n && h(g, "prototype", { writable: !1 }) : g.prototype && (g.prototype = void 0);
    } catch {
    }
    var w = u(g);
    return i(w, "source") || (w.source = l(v, typeof _ == "string" ? _ : "")), g;
  };
  return Function.prototype.toString = m(function() {
    return r(this) && c(this).source || s(this);
  }, "toString"), tf.exports;
}
var cf, h0;
function wo() {
  if (h0) return cf;
  h0 = 1;
  var e = Br(), t = Vi(), r = Mj(), i = mg();
  return cf = function(n, o, s, a) {
    a || (a = {});
    var u = a.enumerable, c = a.name !== void 0 ? a.name : o;
    if (e(s) && r(s, c, a), a.global)
      u ? n[o] = s : i(o, s);
    else {
      try {
        a.unsafe ? n[o] && (u = !0) : delete n[o];
      } catch {
      }
      u ? n[o] = s : t.f(n, o, {
        value: s,
        enumerable: !1,
        configurable: !a.nonConfigurable,
        writable: !a.nonWritable
      });
    }
    return n;
  }, cf;
}
var lf = {}, ff, p0;
function O9() {
  if (p0) return ff;
  p0 = 1;
  var e = Math.ceil, t = Math.floor;
  return ff = Math.trunc || function(i) {
    var n = +i;
    return (n > 0 ? t : e)(n);
  }, ff;
}
var hf, d0;
function Ec() {
  if (d0) return hf;
  d0 = 1;
  var e = O9();
  return hf = function(t) {
    var r = +t;
    return r !== r || r === 0 ? 0 : e(r);
  }, hf;
}
var pf, m0;
function $9() {
  if (m0) return pf;
  m0 = 1;
  var e = Ec(), t = Math.max, r = Math.min;
  return pf = function(i, n) {
    var o = e(i);
    return o < 0 ? t(o + n, 0) : r(o, n);
  }, pf;
}
var df, y0;
function ta() {
  if (y0) return df;
  y0 = 1;
  var e = Ec(), t = Math.min;
  return df = function(r) {
    var i = e(r);
    return i > 0 ? t(i, 9007199254740991) : 0;
  }, df;
}
var mf, g0;
function wg() {
  if (g0) return mf;
  g0 = 1;
  var e = ta();
  return mf = function(t) {
    return e(t.length);
  }, mf;
}
var yf, v0;
function Fj() {
  if (v0) return yf;
  v0 = 1;
  var e = ss(), t = $9(), r = wg(), i = function(n) {
    return function(o, s, a) {
      var u = e(o), c = r(u);
      if (c === 0) return !n && -1;
      var f = t(a, c), h;
      if (n && s !== s) {
        for (; c > f; )
          if (h = u[f++], h !== h) return !0;
      } else for (; c > f; f++)
        if ((n || f in u) && u[f] === s) return n || f || 0;
      return !n && -1;
    };
  };
  return yf = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: i(!0),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: i(!1)
  }, yf;
}
var gf, b0;
function Lj() {
  if (b0) return gf;
  b0 = 1;
  var e = zr(), t = ei(), r = ss(), i = Fj().indexOf, n = _g(), o = e([].push);
  return gf = function(s, a) {
    var u = r(s), c = 0, f = [], h;
    for (h in u) !t(n, h) && t(u, h) && o(f, h);
    for (; a.length > c; ) t(u, h = a[c++]) && (~i(f, h) || o(f, h));
    return f;
  }, gf;
}
var vf, _0;
function Og() {
  return _0 || (_0 = 1, vf = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ]), vf;
}
var w0;
function S9() {
  if (w0) return lf;
  w0 = 1;
  var e = Lj(), t = Og(), r = t.concat("length", "prototype");
  return lf.f = Object.getOwnPropertyNames || function(n) {
    return e(n, r);
  }, lf;
}
var bf = {}, O0;
function E9() {
  return O0 || (O0 = 1, bf.f = Object.getOwnPropertySymbols), bf;
}
var _f, $0;
function x9() {
  if ($0) return _f;
  $0 = 1;
  var e = _o(), t = zr(), r = S9(), i = E9(), n = yn(), o = t([].concat);
  return _f = e("Reflect", "ownKeys") || function(a) {
    var u = r.f(n(a)), c = i.f;
    return c ? o(u, c(a)) : u;
  }, _f;
}
var wf, S0;
function A9() {
  if (S0) return wf;
  S0 = 1;
  var e = ei(), t = x9(), r = Oc(), i = Vi();
  return wf = function(n, o, s) {
    for (var a = t(o), u = i.f, c = r.f, f = 0; f < a.length; f++) {
      var h = a[f];
      !e(n, h) && !(s && e(s, h)) && u(n, h, c(o, h));
    }
  }, wf;
}
var Of, E0;
function Bj() {
  if (E0) return Of;
  E0 = 1;
  var e = Dr(), t = Br(), r = /#|\.prototype\./, i = function(u, c) {
    var f = o[n(u)];
    return f === a ? !0 : f === s ? !1 : t(c) ? e(c) : !!c;
  }, n = i.normalize = function(u) {
    return String(u).replace(r, ".").toLowerCase();
  }, o = i.data = {}, s = i.NATIVE = "N", a = i.POLYFILL = "P";
  return Of = i, Of;
}
var $f, x0;
function gn() {
  if (x0) return $f;
  x0 = 1;
  var e = xr(), t = Oc().f, r = cs(), i = wo(), n = mg(), o = A9(), s = Bj();
  return $f = function(a, u) {
    var c = a.target, f = a.global, h = a.stat, y, p, l, d, v, m;
    if (f ? p = e : h ? p = e[c] || n(c, {}) : p = e[c] && e[c].prototype, p) for (l in u) {
      if (v = u[l], a.dontCallGetSet ? (m = t(p, l), d = m && m.value) : d = p[l], y = s(f ? l : c + (h ? "." : "#") + l, a.forced), !y && d !== void 0) {
        if (typeof v == typeof d) continue;
        o(v, d);
      }
      (a.sham || d && d.sham) && r(v, "sham", !0), i(p, l, v, a);
    }
  }, $f;
}
var Sf, A0;
function qj() {
  if (A0) return Sf;
  A0 = 1;
  var e = xr(), t = us(), r = bo(), i = function(n) {
    return t.slice(0, n.length) === n;
  };
  return Sf = (function() {
    return i("Bun/") ? "BUN" : i("Cloudflare-Workers") ? "CLOUDFLARE" : i("Deno/") ? "DENO" : i("Node.js/") ? "NODE" : e.Bun && typeof Bun.version == "string" ? "BUN" : e.Deno && typeof Deno.version == "object" ? "DENO" : r(e.process) === "process" ? "NODE" : e.window && e.document ? "BROWSER" : "REST";
  })(), Sf;
}
var Ef, j0;
function xc() {
  if (j0) return Ef;
  j0 = 1;
  var e = qj();
  return Ef = e === "NODE", Ef;
}
var xf, k0;
function j9() {
  if (k0) return xf;
  k0 = 1;
  var e = xr();
  return xf = e, xf;
}
var Af, P0;
function k9() {
  if (P0) return Af;
  P0 = 1;
  var e = zr(), t = Si();
  return Af = function(r, i, n) {
    try {
      return e(t(Object.getOwnPropertyDescriptor(r, i)[n]));
    } catch {
    }
  }, Af;
}
var jf, I0;
function P9() {
  if (I0) return jf;
  I0 = 1;
  var e = $n();
  return jf = function(t) {
    return e(t) || t === null;
  }, jf;
}
var kf, T0;
function I9() {
  if (T0) return kf;
  T0 = 1;
  var e = P9(), t = String, r = TypeError;
  return kf = function(i) {
    if (e(i)) return i;
    throw new r("Can't set " + t(i) + " as a prototype");
  }, kf;
}
var Pf, N0;
function Zj() {
  if (N0) return Pf;
  N0 = 1;
  var e = k9(), t = $n(), r = Qn(), i = I9();
  return Pf = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var n = !1, o = {}, s;
    try {
      s = e(Object.prototype, "__proto__", "set"), s(o, []), n = o instanceof Array;
    } catch {
    }
    return function(u, c) {
      return r(u), i(c), t(u) && (n ? s(u, c) : u.__proto__ = c), u;
    };
  })() : void 0), Pf;
}
var If, C0;
function Ac() {
  if (C0) return If;
  C0 = 1;
  var e = Vi().f, t = ei(), r = rn(), i = r("toStringTag");
  return If = function(n, o, s) {
    n && !s && (n = n.prototype), n && !t(n, i) && e(n, i, { configurable: !0, value: o });
  }, If;
}
var Tf, R0;
function T9() {
  if (R0) return Tf;
  R0 = 1;
  var e = Mj(), t = Vi();
  return Tf = function(r, i, n) {
    return n.get && e(n.get, i, { getter: !0 }), n.set && e(n.set, i, { setter: !0 }), t.f(r, i, n);
  }, Tf;
}
var Nf, D0;
function N9() {
  if (D0) return Nf;
  D0 = 1;
  var e = _o(), t = T9(), r = rn(), i = Xn(), n = r("species");
  return Nf = function(o) {
    var s = e(o);
    i && s && !s[n] && t(s, n, {
      configurable: !0,
      get: function() {
        return this;
      }
    });
  }, Nf;
}
var Cf, z0;
function C9() {
  if (z0) return Cf;
  z0 = 1;
  var e = vc(), t = TypeError;
  return Cf = function(r, i) {
    if (e(i, r)) return r;
    throw new t("Incorrect invocation");
  }, Cf;
}
var Rf, U0;
function R9() {
  if (U0) return Rf;
  U0 = 1;
  var e = rn(), t = e("toStringTag"), r = {};
  return r[t] = "z", Rf = String(r) === "[object z]", Rf;
}
var Df, M0;
function $g() {
  if (M0) return Df;
  M0 = 1;
  var e = R9(), t = Br(), r = bo(), i = rn(), n = i("toStringTag"), o = Object, s = r(/* @__PURE__ */ (function() {
    return arguments;
  })()) === "Arguments", a = function(u, c) {
    try {
      return u[c];
    } catch {
    }
  };
  return Df = e ? r : function(u) {
    var c, f, h;
    return u === void 0 ? "Undefined" : u === null ? "Null" : typeof (f = a(c = o(u), n)) == "string" ? f : s ? r(c) : (h = r(c)) === "Object" && t(c.callee) ? "Arguments" : h;
  }, Df;
}
var zf, F0;
function D9() {
  if (F0) return zf;
  F0 = 1;
  var e = zr(), t = Dr(), r = Br(), i = $g(), n = _o(), o = vg(), s = function() {
  }, a = n("Reflect", "construct"), u = /^\s*(?:class|function)\b/, c = e(u.exec), f = !u.test(s), h = function(l) {
    if (!r(l)) return !1;
    try {
      return a(s, [], l), !0;
    } catch {
      return !1;
    }
  }, y = function(l) {
    if (!r(l)) return !1;
    switch (i(l)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1;
    }
    try {
      return f || !!c(u, o(l));
    } catch {
      return !0;
    }
  };
  return y.sham = !0, zf = !a || t(function() {
    var p;
    return h(h.call) || !h(Object) || !h(function() {
      p = !0;
    }) || p;
  }) ? y : h, zf;
}
var Uf, L0;
function z9() {
  if (L0) return Uf;
  L0 = 1;
  var e = D9(), t = bc(), r = TypeError;
  return Uf = function(i) {
    if (e(i)) return i;
    throw new r(t(i) + " is not a constructor");
  }, Uf;
}
var Mf, B0;
function Vj() {
  if (B0) return Mf;
  B0 = 1;
  var e = yn(), t = z9(), r = gc(), i = rn(), n = i("species");
  return Mf = function(o, s) {
    var a = e(o).constructor, u;
    return a === void 0 || r(u = e(a)[n]) ? s : t(u);
  }, Mf;
}
var Ff, q0;
function Wj() {
  if (q0) return Ff;
  q0 = 1;
  var e = yc(), t = Function.prototype, r = t.apply, i = t.call;
  return Ff = typeof Reflect == "object" && Reflect.apply || (e ? i.bind(r) : function() {
    return i.apply(r, arguments);
  }), Ff;
}
var Lf, Z0;
function jc() {
  if (Z0) return Lf;
  Z0 = 1;
  var e = bo(), t = zr();
  return Lf = function(r) {
    if (e(r) === "Function") return t(r);
  }, Lf;
}
var Bf, V0;
function Sg() {
  if (V0) return Bf;
  V0 = 1;
  var e = jc(), t = Si(), r = yc(), i = e(e.bind);
  return Bf = function(n, o) {
    return t(n), o === void 0 ? n : r ? i(n, o) : function() {
      return n.apply(o, arguments);
    };
  }, Bf;
}
var qf, W0;
function Gj() {
  if (W0) return qf;
  W0 = 1;
  var e = _o();
  return qf = e("document", "documentElement"), qf;
}
var Zf, G0;
function U9() {
  if (G0) return Zf;
  G0 = 1;
  var e = zr();
  return Zf = e([].slice), Zf;
}
var Vf, K0;
function M9() {
  if (K0) return Vf;
  K0 = 1;
  var e = TypeError;
  return Vf = function(t, r) {
    if (t < r) throw new e("Not enough arguments");
    return t;
  }, Vf;
}
var Wf, H0;
function Kj() {
  if (H0) return Wf;
  H0 = 1;
  var e = us();
  return Wf = /(?:ipad|iphone|ipod).*applewebkit/i.test(e), Wf;
}
var Gf, J0;
function Hj() {
  if (J0) return Gf;
  J0 = 1;
  var e = xr(), t = Wj(), r = Sg(), i = Br(), n = ei(), o = Dr(), s = Gj(), a = U9(), u = wc(), c = M9(), f = Kj(), h = xc(), y = e.setImmediate, p = e.clearImmediate, l = e.process, d = e.Dispatch, v = e.Function, m = e.MessageChannel, g = e.String, _ = 0, b = {}, w = "onreadystatechange", A, E, O, $;
  o(function() {
    A = e.location;
  });
  var k = function(I) {
    if (n(b, I)) {
      var z = b[I];
      delete b[I], z();
    }
  }, j = function(I) {
    return function() {
      k(I);
    };
  }, P = function(I) {
    k(I.data);
  }, R = function(I) {
    e.postMessage(g(I), A.protocol + "//" + A.host);
  };
  return (!y || !p) && (y = function(z) {
    c(arguments.length, 1);
    var W = i(z) ? z : v(z), F = a(arguments, 1);
    return b[++_] = function() {
      t(W, void 0, F);
    }, E(_), _;
  }, p = function(z) {
    delete b[z];
  }, h ? E = function(I) {
    l.nextTick(j(I));
  } : d && d.now ? E = function(I) {
    d.now(j(I));
  } : m && !f ? (O = new m(), $ = O.port2, O.port1.onmessage = P, E = r($.postMessage, $)) : e.addEventListener && i(e.postMessage) && !e.importScripts && A && A.protocol !== "file:" && !o(R) ? (E = R, e.addEventListener("message", P, !1)) : w in u("script") ? E = function(I) {
    s.appendChild(u("script"))[w] = function() {
      s.removeChild(this), k(I);
    };
  } : E = function(I) {
    setTimeout(j(I), 0);
  }), Gf = {
    set: y,
    clear: p
  }, Gf;
}
var Kf, Y0;
function F9() {
  if (Y0) return Kf;
  Y0 = 1;
  var e = xr(), t = Xn(), r = Object.getOwnPropertyDescriptor;
  return Kf = function(i) {
    if (!t) return e[i];
    var n = r(e, i);
    return n && n.value;
  }, Kf;
}
var Hf, X0;
function Jj() {
  if (X0) return Hf;
  X0 = 1;
  var e = function() {
    this.head = null, this.tail = null;
  };
  return e.prototype = {
    add: function(t) {
      var r = { item: t, next: null }, i = this.tail;
      i ? i.next = r : this.head = r, this.tail = r;
    },
    get: function() {
      var t = this.head;
      if (t) {
        var r = this.head = t.next;
        return r === null && (this.tail = null), t.item;
      }
    }
  }, Hf = e, Hf;
}
var Jf, Q0;
function L9() {
  if (Q0) return Jf;
  Q0 = 1;
  var e = us();
  return Jf = /ipad|iphone|ipod/i.test(e) && typeof Pebble < "u", Jf;
}
var Yf, ew;
function B9() {
  if (ew) return Yf;
  ew = 1;
  var e = us();
  return Yf = /web0s(?!.*chrome)/i.test(e), Yf;
}
var Xf, tw;
function q9() {
  if (tw) return Xf;
  tw = 1;
  var e = xr(), t = F9(), r = Sg(), i = Hj().set, n = Jj(), o = Kj(), s = L9(), a = B9(), u = xc(), c = e.MutationObserver || e.WebKitMutationObserver, f = e.document, h = e.process, y = e.Promise, p = t("queueMicrotask"), l, d, v, m, g;
  if (!p) {
    var _ = new n(), b = function() {
      var w, A;
      for (u && (w = h.domain) && w.exit(); A = _.get(); ) try {
        A();
      } catch (E) {
        throw _.head && l(), E;
      }
      w && w.enter();
    };
    !o && !u && !a && c && f ? (d = !0, v = f.createTextNode(""), new c(b).observe(v, { characterData: !0 }), l = function() {
      v.data = d = !d;
    }) : !s && y && y.resolve ? (m = y.resolve(void 0), m.constructor = y, g = r(m.then, m), l = function() {
      g(b);
    }) : u ? l = function() {
      h.nextTick(b);
    } : (i = r(i, e), l = function() {
      i(b);
    }), p = function(w) {
      _.head || l(), _.add(w);
    };
  }
  return Xf = p, Xf;
}
var Qf, rw;
function Z9() {
  return rw || (rw = 1, Qf = function(e, t) {
    try {
      arguments.length === 1 ? console.error(e) : console.error(e, t);
    } catch {
    }
  }), Qf;
}
var eh, nw;
function Eg() {
  return nw || (nw = 1, eh = function(e) {
    try {
      return { error: !1, value: e() };
    } catch (t) {
      return { error: !0, value: t };
    }
  }), eh;
}
var th, iw;
function ls() {
  if (iw) return th;
  iw = 1;
  var e = xr();
  return th = e.Promise, th;
}
var rh, ow;
function fs() {
  if (ow) return rh;
  ow = 1;
  var e = xr(), t = ls(), r = Br(), i = Bj(), n = vg(), o = rn(), s = qj(), a = fi(), u = dg(), c = t && t.prototype, f = o("species"), h = !1, y = r(e.PromiseRejectionEvent), p = i("Promise", function() {
    var l = n(t), d = l !== String(t);
    if (!d && u === 66 || a && !(c.catch && c.finally)) return !0;
    if (!u || u < 51 || !/native code/.test(l)) {
      var v = new t(function(_) {
        _(1);
      }), m = function(_) {
        _(function() {
        }, function() {
        });
      }, g = v.constructor = {};
      if (g[f] = m, h = v.then(function() {
      }) instanceof m, !h) return !0;
    }
    return !d && (s === "BROWSER" || s === "DENO") && !y;
  });
  return rh = {
    CONSTRUCTOR: p,
    REJECTION_EVENT: y,
    SUBCLASSING: h
  }, rh;
}
var nh = {}, aw;
function hs() {
  if (aw) return nh;
  aw = 1;
  var e = Si(), t = TypeError, r = function(i) {
    var n, o;
    this.promise = new i(function(s, a) {
      if (n !== void 0 || o !== void 0) throw new t("Bad Promise constructor");
      n = s, o = a;
    }), this.resolve = e(n), this.reject = e(o);
  };
  return nh.f = function(i) {
    return new r(i);
  }, nh;
}
var sw;
function V9() {
  if (sw) return m_;
  sw = 1;
  var e = gn(), t = fi(), r = xc(), i = xr(), n = j9(), o = nn(), s = wo(), a = Zj(), u = Ac(), c = N9(), f = Si(), h = Br(), y = $n(), p = C9(), l = Vj(), d = Hj().set, v = q9(), m = Z9(), g = Eg(), _ = Jj(), b = Sc(), w = ls(), A = fs(), E = hs(), O = "Promise", $ = A.CONSTRUCTOR, k = A.REJECTION_EVENT, j = A.SUBCLASSING, P = b.getterFor(O), R = b.set, I = w && w.prototype, z = w, W = I, F = i.TypeError, te = i.document, ee = i.process, V = E.f, T = V, D = !!(te && te.createEvent && i.dispatchEvent), L = "unhandledrejection", M = "rejectionhandled", N = 0, Z = 1, Y = 2, ie = 1, le = 2, de, ae, ne, he, x = function(ue) {
    var re;
    return y(ue) && h(re = ue.then) ? re : !1;
  }, U = function(ue, re) {
    var pe = re.value, xe = re.state === Z, be = xe ? ue.ok : ue.fail, Ee = ue.resolve, Ue = ue.reject, Ae = ue.domain, Me, et, lt;
    try {
      be ? (xe || (re.rejection === le && ye(re), re.rejection = ie), be === !0 ? Me = pe : (Ae && Ae.enter(), Me = be(pe), Ae && (Ae.exit(), lt = !0)), Me === ue.promise ? Ue(new F("Promise-chain cycle")) : (et = x(Me)) ? o(et, Me, Ee, Ue) : Ee(Me)) : Ue(pe);
    } catch (ft) {
      Ae && !lt && Ae.exit(), Ue(ft);
    }
  }, B = function(ue, re) {
    ue.notified || (ue.notified = !0, v(function() {
      for (var pe = ue.reactions, xe; xe = pe.get(); )
        U(xe, ue);
      ue.notified = !1, re && !ue.rejection && X(ue);
    }));
  }, J = function(ue, re, pe) {
    var xe, be;
    D ? (xe = te.createEvent("Event"), xe.promise = re, xe.reason = pe, xe.initEvent(ue, !1, !0), i.dispatchEvent(xe)) : xe = { promise: re, reason: pe }, !k && (be = i["on" + ue]) ? be(xe) : ue === L && m("Unhandled promise rejection", pe);
  }, X = function(ue) {
    o(d, i, function() {
      var re = ue.facade, pe = ue.value, xe = oe(ue), be;
      if (xe && (be = g(function() {
        r ? ee.emit("unhandledRejection", pe, re) : J(L, re, pe);
      }), ue.rejection = r || oe(ue) ? le : ie, be.error))
        throw be.value;
    });
  }, oe = function(ue) {
    return ue.rejection !== ie && !ue.parent;
  }, ye = function(ue) {
    o(d, i, function() {
      var re = ue.facade;
      r ? ee.emit("rejectionHandled", re) : J(M, re, ue.value);
    });
  }, q = function(ue, re, pe) {
    return function(xe) {
      ue(re, xe, pe);
    };
  }, G = function(ue, re, pe) {
    ue.done || (ue.done = !0, pe && (ue = pe), ue.value = re, ue.state = Y, B(ue, !0));
  }, ce = function(ue, re, pe) {
    if (!ue.done) {
      ue.done = !0, pe && (ue = pe);
      try {
        if (ue.facade === re) throw new F("Promise can't be resolved itself");
        var xe = x(re);
        xe ? v(function() {
          var be = { done: !1 };
          try {
            o(
              xe,
              re,
              q(ce, be, ue),
              q(G, be, ue)
            );
          } catch (Ee) {
            G(be, Ee, ue);
          }
        }) : (ue.value = re, ue.state = Z, B(ue, !1));
      } catch (be) {
        G({ done: !1 }, be, ue);
      }
    }
  };
  if ($ && (z = function(re) {
    p(this, W), f(re), o(de, this);
    var pe = P(this);
    try {
      re(q(ce, pe), q(G, pe));
    } catch (xe) {
      G(pe, xe);
    }
  }, W = z.prototype, de = function(re) {
    R(this, {
      type: O,
      done: !1,
      notified: !1,
      parent: !1,
      reactions: new _(),
      rejection: !1,
      state: N,
      value: null
    });
  }, de.prototype = s(W, "then", function(re, pe) {
    var xe = P(this), be = V(l(this, z));
    return xe.parent = !0, be.ok = h(re) ? re : !0, be.fail = h(pe) && pe, be.domain = r ? ee.domain : void 0, xe.state === N ? xe.reactions.add(be) : v(function() {
      U(be, xe);
    }), be.promise;
  }), ae = function() {
    var ue = new de(), re = P(ue);
    this.promise = ue, this.resolve = q(ce, re), this.reject = q(G, re);
  }, E.f = V = function(ue) {
    return ue === z || ue === ne ? new ae(ue) : T(ue);
  }, !t && h(w) && I !== Object.prototype)) {
    he = I.then, j || s(I, "then", function(re, pe) {
      var xe = this;
      return new z(function(be, Ee) {
        o(he, xe, be, Ee);
      }).then(re, pe);
    }, { unsafe: !0 });
    try {
      delete I.constructor;
    } catch {
    }
    a && a(I, W);
  }
  return e({ global: !0, constructor: !0, wrap: !0, forced: $ }, {
    Promise: z
  }), ne = n.Promise, u(z, O, !1, !0), c(O), m_;
}
var uw = {}, ih, cw;
function ps() {
  return cw || (cw = 1, ih = {}), ih;
}
var oh, lw;
function W9() {
  if (lw) return oh;
  lw = 1;
  var e = rn(), t = ps(), r = e("iterator"), i = Array.prototype;
  return oh = function(n) {
    return n !== void 0 && (t.Array === n || i[r] === n);
  }, oh;
}
var ah, fw;
function Yj() {
  if (fw) return ah;
  fw = 1;
  var e = $g(), t = ea(), r = gc(), i = ps(), n = rn(), o = n("iterator");
  return ah = function(s) {
    if (!r(s)) return t(s, o) || t(s, "@@iterator") || i[e(s)];
  }, ah;
}
var sh, hw;
function G9() {
  if (hw) return sh;
  hw = 1;
  var e = nn(), t = Si(), r = yn(), i = bc(), n = Yj(), o = TypeError;
  return sh = function(s, a) {
    var u = arguments.length < 2 ? n(s) : a;
    if (t(u)) return r(e(u, s));
    throw new o(i(s) + " is not iterable");
  }, sh;
}
var uh, pw;
function K9() {
  if (pw) return uh;
  pw = 1;
  var e = nn(), t = yn(), r = ea();
  return uh = function(i, n, o) {
    var s, a;
    t(i);
    try {
      if (s = r(i, "return"), !s) {
        if (n === "throw") throw o;
        return o;
      }
      s = e(s, i);
    } catch (u) {
      a = !0, s = u;
    }
    if (n === "throw") throw o;
    if (a) throw s;
    return t(s), o;
  }, uh;
}
var ch, dw;
function Xj() {
  if (dw) return ch;
  dw = 1;
  var e = Sg(), t = nn(), r = yn(), i = bc(), n = W9(), o = wg(), s = vc(), a = G9(), u = Yj(), c = K9(), f = TypeError, h = function(p, l) {
    this.stopped = p, this.result = l;
  }, y = h.prototype;
  return ch = function(p, l, d) {
    var v = d && d.that, m = !!(d && d.AS_ENTRIES), g = !!(d && d.IS_RECORD), _ = !!(d && d.IS_ITERATOR), b = !!(d && d.INTERRUPTED), w = e(l, v), A, E, O, $, k, j, P, R = function(z) {
      return A && c(A, "normal"), new h(!0, z);
    }, I = function(z) {
      return m ? (r(z), b ? w(z[0], z[1], R) : w(z[0], z[1])) : b ? w(z, R) : w(z);
    };
    if (g)
      A = p.iterator;
    else if (_)
      A = p;
    else {
      if (E = u(p), !E) throw new f(i(p) + " is not iterable");
      if (n(E)) {
        for (O = 0, $ = o(p); $ > O; O++)
          if (k = I(p[O]), k && s(y, k)) return k;
        return new h(!1);
      }
      A = a(p, E);
    }
    for (j = g ? p.next : A.next; !(P = t(j, A)).done; ) {
      try {
        k = I(P.value);
      } catch (z) {
        c(A, "throw", z);
      }
      if (typeof k == "object" && k && s(y, k)) return k;
    }
    return new h(!1);
  }, ch;
}
var lh, mw;
function H9() {
  if (mw) return lh;
  mw = 1;
  var e = rn(), t = e("iterator"), r = !1;
  try {
    var i = 0, n = {
      next: function() {
        return { done: !!i++ };
      },
      return: function() {
        r = !0;
      }
    };
    n[t] = function() {
      return this;
    }, Array.from(n, function() {
      throw 2;
    });
  } catch {
  }
  return lh = function(o, s) {
    try {
      if (!s && !r) return !1;
    } catch {
      return !1;
    }
    var a = !1;
    try {
      var u = {};
      u[t] = function() {
        return {
          next: function() {
            return { done: a = !0 };
          }
        };
      }, o(u);
    } catch {
    }
    return a;
  }, lh;
}
var fh, yw;
function Qj() {
  if (yw) return fh;
  yw = 1;
  var e = ls(), t = H9(), r = fs().CONSTRUCTOR;
  return fh = r || !t(function(i) {
    e.all(i).then(void 0, function() {
    });
  }), fh;
}
var gw;
function J9() {
  if (gw) return uw;
  gw = 1;
  var e = gn(), t = nn(), r = Si(), i = hs(), n = Eg(), o = Xj(), s = Qj();
  return e({ target: "Promise", stat: !0, forced: s }, {
    all: function(u) {
      var c = this, f = i.f(c), h = f.resolve, y = f.reject, p = n(function() {
        var l = r(c.resolve), d = [], v = 0, m = 1;
        o(u, function(g) {
          var _ = v++, b = !1;
          m++, t(l, c, g).then(function(w) {
            b || (b = !0, d[_] = w, --m || h(d));
          }, y);
        }), --m || h(d);
      });
      return p.error && y(p.value), f.promise;
    }
  }), uw;
}
var vw = {}, bw;
function Y9() {
  if (bw) return vw;
  bw = 1;
  var e = gn(), t = fi(), r = fs().CONSTRUCTOR, i = ls(), n = _o(), o = Br(), s = wo(), a = i && i.prototype;
  if (e({ target: "Promise", proto: !0, forced: r, real: !0 }, {
    catch: function(c) {
      return this.then(void 0, c);
    }
  }), !t && o(i)) {
    var u = n("Promise").prototype.catch;
    a.catch !== u && s(a, "catch", u, { unsafe: !0 });
  }
  return vw;
}
var _w = {}, ww;
function X9() {
  if (ww) return _w;
  ww = 1;
  var e = gn(), t = nn(), r = Si(), i = hs(), n = Eg(), o = Xj(), s = Qj();
  return e({ target: "Promise", stat: !0, forced: s }, {
    race: function(u) {
      var c = this, f = i.f(c), h = f.reject, y = n(function() {
        var p = r(c.resolve);
        o(u, function(l) {
          t(p, c, l).then(f.resolve, h);
        });
      });
      return y.error && h(y.value), f.promise;
    }
  }), _w;
}
var Ow = {}, $w;
function Q9() {
  if ($w) return Ow;
  $w = 1;
  var e = gn(), t = hs(), r = fs().CONSTRUCTOR;
  return e({ target: "Promise", stat: !0, forced: r }, {
    reject: function(n) {
      var o = t.f(this), s = o.reject;
      return s(n), o.promise;
    }
  }), Ow;
}
var Sw = {}, hh, Ew;
function e7() {
  if (Ew) return hh;
  Ew = 1;
  var e = yn(), t = $n(), r = hs();
  return hh = function(i, n) {
    if (e(i), t(n) && n.constructor === i) return n;
    var o = r.f(i), s = o.resolve;
    return s(n), o.promise;
  }, hh;
}
var xw;
function t7() {
  if (xw) return Sw;
  xw = 1;
  var e = gn(), t = _o(), r = fi(), i = ls(), n = fs().CONSTRUCTOR, o = e7(), s = t("Promise"), a = r && !n;
  return e({ target: "Promise", stat: !0, forced: r || n }, {
    resolve: function(c) {
      return o(a && this === s ? i : this, c);
    }
  }), Sw;
}
var Aw;
function r7() {
  return Aw || (Aw = 1, V9(), J9(), Y9(), X9(), Q9(), t7()), d_;
}
r7();
function jw(e, t, r, i, n, o, s) {
  try {
    var a = e[o](s), u = a.value;
  } catch (c) {
    return void r(c);
  }
  a.done ? t(u) : Promise.resolve(u).then(i, n);
}
function kq(e) {
  return function() {
    var t = this, r = arguments;
    return new Promise(function(i, n) {
      var o = e.apply(t, r);
      function s(u) {
        jw(o, i, n, s, a, "next", u);
      }
      function a(u) {
        jw(o, i, n, s, a, "throw", u);
      }
      s(void 0);
    });
  };
}
var kw = {}, Pw = {}, ph, Iw;
function hi() {
  if (Iw) return ph;
  Iw = 1;
  var e = $g(), t = String;
  return ph = function(r) {
    if (e(r) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
    return t(r);
  }, ph;
}
var dh, Tw;
function ek() {
  if (Tw) return dh;
  Tw = 1;
  var e = yn();
  return dh = function() {
    var t = e(this), r = "";
    return t.hasIndices && (r += "d"), t.global && (r += "g"), t.ignoreCase && (r += "i"), t.multiline && (r += "m"), t.dotAll && (r += "s"), t.unicode && (r += "u"), t.unicodeSets && (r += "v"), t.sticky && (r += "y"), r;
  }, dh;
}
var mh, Nw;
function tk() {
  if (Nw) return mh;
  Nw = 1;
  var e = Dr(), t = xr(), r = t.RegExp, i = e(function() {
    var s = r("a", "y");
    return s.lastIndex = 2, s.exec("abcd") !== null;
  }), n = i || e(function() {
    return !r("a", "y").sticky;
  }), o = i || e(function() {
    var s = r("^r", "gy");
    return s.lastIndex = 2, s.exec("str") !== null;
  });
  return mh = {
    BROKEN_CARET: o,
    MISSED_STICKY: n,
    UNSUPPORTED_Y: i
  }, mh;
}
var yh = {}, gh, Cw;
function n7() {
  if (Cw) return gh;
  Cw = 1;
  var e = Lj(), t = Og();
  return gh = Object.keys || function(i) {
    return e(i, t);
  }, gh;
}
var Rw;
function i7() {
  if (Rw) return yh;
  Rw = 1;
  var e = Xn(), t = Uj(), r = Vi(), i = yn(), n = ss(), o = n7();
  return yh.f = e && !t ? Object.defineProperties : function(a, u) {
    i(a);
    for (var c = n(u), f = o(u), h = f.length, y = 0, p; h > y; ) r.f(a, p = f[y++], c[p]);
    return a;
  }, yh;
}
var vh, Dw;
function kc() {
  if (Dw) return vh;
  Dw = 1;
  var e = yn(), t = i7(), r = Og(), i = _g(), n = Gj(), o = wc(), s = bg(), a = ">", u = "<", c = "prototype", f = "script", h = s("IE_PROTO"), y = function() {
  }, p = function(g) {
    return u + f + a + g + u + "/" + f + a;
  }, l = function(g) {
    g.write(p("")), g.close();
    var _ = g.parentWindow.Object;
    return g = null, _;
  }, d = function() {
    var g = o("iframe"), _ = "java" + f + ":", b;
    return g.style.display = "none", n.appendChild(g), g.src = String(_), b = g.contentWindow.document, b.open(), b.write(p("document.F=Object")), b.close(), b.F;
  }, v, m = function() {
    try {
      v = new ActiveXObject("htmlfile");
    } catch {
    }
    m = typeof document < "u" ? document.domain && v ? l(v) : d() : l(v);
    for (var g = r.length; g--; ) delete m[c][r[g]];
    return m();
  };
  return i[h] = !0, vh = Object.create || function(_, b) {
    var w;
    return _ !== null ? (y[c] = e(_), w = new y(), y[c] = null, w[h] = _) : w = m(), b === void 0 ? w : t.f(w, b);
  }, vh;
}
var bh, zw;
function o7() {
  if (zw) return bh;
  zw = 1;
  var e = Dr(), t = xr(), r = t.RegExp;
  return bh = e(function() {
    var i = r(".", "s");
    return !(i.dotAll && i.test(`
`) && i.flags === "s");
  }), bh;
}
var _h, Uw;
function a7() {
  if (Uw) return _h;
  Uw = 1;
  var e = Dr(), t = xr(), r = t.RegExp;
  return _h = e(function() {
    var i = r("(?<a>b)", "g");
    return i.exec("b").groups.a !== "b" || "b".replace(i, "$<a>c") !== "bc";
  }), _h;
}
var wh, Mw;
function xg() {
  if (Mw) return wh;
  Mw = 1;
  var e = nn(), t = zr(), r = hi(), i = ek(), n = tk(), o = gg(), s = kc(), a = Sc().get, u = o7(), c = a7(), f = o("native-string-replace", String.prototype.replace), h = RegExp.prototype.exec, y = h, p = t("".charAt), l = t("".indexOf), d = t("".replace), v = t("".slice), m = (function() {
    var w = /a/, A = /b*/g;
    return e(h, w, "a"), e(h, A, "a"), w.lastIndex !== 0 || A.lastIndex !== 0;
  })(), g = n.BROKEN_CARET, _ = /()??/.exec("")[1] !== void 0, b = m || _ || g || u || c;
  return b && (y = function(A) {
    var E = this, O = a(E), $ = r(A), k = O.raw, j, P, R, I, z, W, F;
    if (k)
      return k.lastIndex = E.lastIndex, j = e(y, k, $), E.lastIndex = k.lastIndex, j;
    var te = O.groups, ee = g && E.sticky, V = e(i, E), T = E.source, D = 0, L = $;
    if (ee && (V = d(V, "y", ""), l(V, "g") === -1 && (V += "g"), L = v($, E.lastIndex), E.lastIndex > 0 && (!E.multiline || E.multiline && p($, E.lastIndex - 1) !== `
`) && (T = "(?: " + T + ")", L = " " + L, D++), P = new RegExp("^(?:" + T + ")", V)), _ && (P = new RegExp("^" + T + "$(?!\\s)", V)), m && (R = E.lastIndex), I = e(h, ee ? P : E, L), ee ? I ? (I.input = v(I.input, D), I[0] = v(I[0], D), I.index = E.lastIndex, E.lastIndex += I[0].length) : E.lastIndex = 0 : m && I && (E.lastIndex = E.global ? I.index + I[0].length : R), _ && I && I.length > 1 && e(f, I[0], P, function() {
      for (z = 1; z < arguments.length - 2; z++)
        arguments[z] === void 0 && (I[z] = void 0);
    }), I && te)
      for (I.groups = W = s(null), z = 0; z < te.length; z++)
        F = te[z], W[F[0]] = I[F[1]];
    return I;
  }), wh = y, wh;
}
var Fw;
function s7() {
  if (Fw) return Pw;
  Fw = 1;
  var e = gn(), t = xg();
  return e({ target: "RegExp", proto: !0, forced: /./.exec !== t }, {
    exec: t
  }), Pw;
}
var Oh, Lw;
function Ag() {
  if (Lw) return Oh;
  Lw = 1, s7();
  var e = nn(), t = wo(), r = xg(), i = Dr(), n = rn(), o = cs(), s = n("species"), a = RegExp.prototype;
  return Oh = function(u, c, f, h) {
    var y = n(u), p = !i(function() {
      var m = {};
      return m[y] = function() {
        return 7;
      }, ""[u](m) !== 7;
    }), l = p && !i(function() {
      var m = !1, g = /a/;
      return u === "split" && (g = {}, g.constructor = {}, g.constructor[s] = function() {
        return g;
      }, g.flags = "", g[y] = /./[y]), g.exec = function() {
        return m = !0, null;
      }, g[y](""), !m;
    });
    if (!p || !l || f) {
      var d = /./[y], v = c(y, ""[u], function(m, g, _, b, w) {
        var A = g.exec;
        return A === r || A === a.exec ? p && !w ? { done: !0, value: e(d, g, _, b) } : { done: !0, value: e(m, _, g, b) } : { done: !1 };
      });
      t(String.prototype, u, v[0]), t(a, y, v[1]);
    }
    h && o(a[y], "sham", !0);
  }, Oh;
}
var $h, Bw;
function u7() {
  if (Bw) return $h;
  Bw = 1;
  var e = zr(), t = Ec(), r = hi(), i = Qn(), n = e("".charAt), o = e("".charCodeAt), s = e("".slice), a = function(u) {
    return function(c, f) {
      var h = r(i(c)), y = t(f), p = h.length, l, d;
      return y < 0 || y >= p ? u ? "" : void 0 : (l = o(h, y), l < 55296 || l > 56319 || y + 1 === p || (d = o(h, y + 1)) < 56320 || d > 57343 ? u ? n(h, y) : l : u ? s(h, y, y + 2) : (l - 55296 << 10) + (d - 56320) + 65536);
    };
  };
  return $h = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: a(!1),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: a(!0)
  }, $h;
}
var Sh, qw;
function jg() {
  if (qw) return Sh;
  qw = 1;
  var e = u7().charAt;
  return Sh = function(t, r, i) {
    return r + (i ? e(t, r).length : 1);
  }, Sh;
}
var Eh, Zw;
function c7() {
  if (Zw) return Eh;
  Zw = 1;
  var e = xr(), t = Dr(), r = e.RegExp, i = !t(function() {
    var n = !0;
    try {
      r(".", "d");
    } catch {
      n = !1;
    }
    var o = {}, s = "", a = n ? "dgimsy" : "gimsy", u = function(y, p) {
      Object.defineProperty(o, y, { get: function() {
        return s += p, !0;
      } });
    }, c = {
      dotAll: "s",
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      sticky: "y"
    };
    n && (c.hasIndices = "d");
    for (var f in c) u(f, c[f]);
    var h = Object.getOwnPropertyDescriptor(r.prototype, "flags").get.call(o);
    return h !== a || s !== a;
  });
  return Eh = { correct: i }, Eh;
}
var xh, Vw;
function kg() {
  if (Vw) return xh;
  Vw = 1;
  var e = nn(), t = ei(), r = vc(), i = c7(), n = ek(), o = RegExp.prototype;
  return xh = i.correct ? function(s) {
    return s.flags;
  } : function(s) {
    return !i.correct && r(o, s) && !t(s, "flags") ? e(n, s) : s.flags;
  }, xh;
}
var Ah, Ww;
function Pg() {
  if (Ww) return Ah;
  Ww = 1;
  var e = nn(), t = yn(), r = Br(), i = bo(), n = xg(), o = TypeError;
  return Ah = function(s, a) {
    var u = s.exec;
    if (r(u)) {
      var c = e(u, s, a);
      return c !== null && t(c), c;
    }
    if (i(s) === "RegExp") return e(n, s, a);
    throw new o("RegExp#exec called on incompatible receiver");
  }, Ah;
}
var Gw;
function l7() {
  if (Gw) return kw;
  Gw = 1;
  var e = nn(), t = zr(), r = Ag(), i = yn(), n = $n(), o = ta(), s = hi(), a = Qn(), u = ea(), c = jg(), f = kg(), h = Pg(), y = t("".indexOf);
  return r("match", function(p, l, d) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function(m) {
        var g = a(this), _ = n(m) ? u(m, p) : void 0;
        return _ ? e(_, m, g) : new RegExp(m)[p](s(g));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function(v) {
        var m = i(this), g = s(v), _ = d(l, m, g);
        if (_.done) return _.value;
        var b = s(f(m));
        if (y(b, "g") === -1) return h(m, g);
        var w = y(b, "u") !== -1;
        m.lastIndex = 0;
        for (var A = [], E = 0, O; (O = h(m, g)) !== null; ) {
          var $ = s(O[0]);
          A[E] = $, $ === "" && (m.lastIndex = c(g, o(m.lastIndex), w)), E++;
        }
        return E === 0 ? null : A;
      }
    ];
  }), kw;
}
l7();
var Kw = {}, jh, Hw;
function f7() {
  if (Hw) return jh;
  Hw = 1;
  var e = zr(), t = _c(), r = Math.floor, i = e("".charAt), n = e("".replace), o = e("".slice), s = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, a = /\$([$&'`]|\d{1,2})/g;
  return jh = function(u, c, f, h, y, p) {
    var l = f + u.length, d = h.length, v = a;
    return y !== void 0 && (y = t(y), v = s), n(p, v, function(m, g) {
      var _;
      switch (i(g, 0)) {
        case "$":
          return "$";
        case "&":
          return u;
        case "`":
          return o(c, 0, f);
        case "'":
          return o(c, l);
        case "<":
          _ = y[o(g, 1, -1)];
          break;
        default:
          var b = +g;
          if (b === 0) return m;
          if (b > d) {
            var w = r(b / 10);
            return w === 0 ? m : w <= d ? h[w - 1] === void 0 ? i(g, 1) : h[w - 1] + i(g, 1) : m;
          }
          _ = h[b - 1];
      }
      return _ === void 0 ? "" : _;
    });
  }, jh;
}
var Jw;
function h7() {
  if (Jw) return Kw;
  Jw = 1;
  var e = Wj(), t = nn(), r = zr(), i = Ag(), n = Dr(), o = yn(), s = Br(), a = $n(), u = Ec(), c = ta(), f = hi(), h = Qn(), y = jg(), p = ea(), l = f7(), d = kg(), v = Pg(), m = rn(), g = m("replace"), _ = Math.max, b = Math.min, w = r([].concat), A = r([].push), E = r("".indexOf), O = r("".slice), $ = function(R) {
    return R === void 0 ? R : String(R);
  }, k = (function() {
    return "a".replace(/./, "$0") === "$0";
  })(), j = (function() {
    return /./[g] ? /./[g]("a", "$0") === "" : !1;
  })(), P = !n(function() {
    var R = /./;
    return R.exec = function() {
      var I = [];
      return I.groups = { a: "7" }, I;
    }, "".replace(R, "$<a>") !== "7";
  });
  return i("replace", function(R, I, z) {
    var W = j ? "$" : "$0";
    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function(te, ee) {
        var V = h(this), T = a(te) ? p(te, g) : void 0;
        return T ? t(T, te, V, ee) : t(I, f(V), te, ee);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function(F, te) {
        var ee = o(this), V = f(F);
        if (typeof te == "string" && E(te, W) === -1 && E(te, "$<") === -1) {
          var T = z(I, ee, V, te);
          if (T.done) return T.value;
        }
        var D = s(te);
        D || (te = f(te));
        var L = f(d(ee)), M = E(L, "g") !== -1, N;
        M && (N = E(L, "u") !== -1, ee.lastIndex = 0);
        for (var Z = [], Y; Y = v(ee, V), !(Y === null || (A(Z, Y), !M)); ) {
          var ie = f(Y[0]);
          ie === "" && (ee.lastIndex = y(V, c(ee.lastIndex), N));
        }
        for (var le = "", de = 0, ae = 0; ae < Z.length; ae++) {
          Y = Z[ae];
          for (var ne = f(Y[0]), he = _(b(u(Y.index), V.length), 0), x = [], U, B = 1; B < Y.length; B++) A(x, $(Y[B]));
          var J = Y.groups;
          if (D) {
            var X = w([ne], x, he, V);
            J !== void 0 && A(X, J), U = f(e(te, void 0, X));
          } else
            U = l(ne, V, he, x, J, te);
          he >= de && (le += O(V, de, he) + U, de = he + ne.length);
        }
        return le + O(V, de);
      }
    ];
  }, !P || !k || j), Kw;
}
h7();
var Yw = {}, kh, Xw;
function p7() {
  if (Xw) return kh;
  Xw = 1;
  var e = $n(), t = bo(), r = rn(), i = r("match");
  return kh = function(n) {
    var o;
    return e(n) && ((o = n[i]) !== void 0 ? !!o : t(n) === "RegExp");
  }, kh;
}
var Ph, Qw;
function Ig() {
  if (Qw) return Ph;
  Qw = 1;
  var e = p7(), t = TypeError;
  return Ph = function(r) {
    if (e(r))
      throw new t("The method doesn't accept regular expressions");
    return r;
  }, Ph;
}
var Ih, e1;
function Tg() {
  if (e1) return Ih;
  e1 = 1;
  var e = rn(), t = e("match");
  return Ih = function(r) {
    var i = /./;
    try {
      "/./"[r](i);
    } catch {
      try {
        return i[t] = !1, "/./"[r](i);
      } catch {
      }
    }
    return !1;
  }, Ih;
}
var t1;
function d7() {
  if (t1) return Yw;
  t1 = 1;
  var e = gn(), t = jc(), r = Oc().f, i = ta(), n = hi(), o = Ig(), s = Qn(), a = Tg(), u = fi(), c = t("".slice), f = Math.min, h = a("startsWith"), y = !u && !h && !!(function() {
    var p = r(String.prototype, "startsWith");
    return p && !p.writable;
  })();
  return e({ target: "String", proto: !0, forced: !y && !h }, {
    startsWith: function(l) {
      var d = n(s(this));
      o(l);
      var v = i(f(arguments.length > 1 ? arguments[1] : void 0, d.length)), m = n(l);
      return c(d, v, v + m.length) === m;
    }
  }), Yw;
}
d7();
var Th, r1;
function m7() {
  if (r1) return Th;
  r1 = 1;
  var e = rn(), t = kc(), r = Vi().f, i = e("unscopables"), n = Array.prototype;
  return n[i] === void 0 && r(n, i, {
    configurable: !0,
    value: t(null)
  }), Th = function(o) {
    n[i][o] = !0;
  }, Th;
}
var Nh, n1;
function y7() {
  if (n1) return Nh;
  n1 = 1;
  var e = Dr();
  return Nh = !e(function() {
    function t() {
    }
    return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;
  }), Nh;
}
var Ch, i1;
function rk() {
  if (i1) return Ch;
  i1 = 1;
  var e = ei(), t = Br(), r = _c(), i = bg(), n = y7(), o = i("IE_PROTO"), s = Object, a = s.prototype;
  return Ch = n ? s.getPrototypeOf : function(u) {
    var c = r(u);
    if (e(c, o)) return c[o];
    var f = c.constructor;
    return t(f) && c instanceof f ? f.prototype : c instanceof s ? a : null;
  }, Ch;
}
var Rh, o1;
function nk() {
  if (o1) return Rh;
  o1 = 1;
  var e = Dr(), t = Br(), r = $n(), i = kc(), n = rk(), o = wo(), s = rn(), a = fi(), u = s("iterator"), c = !1, f, h, y;
  [].keys && (y = [].keys(), "next" in y ? (h = n(n(y)), h !== Object.prototype && (f = h)) : c = !0);
  var p = !r(f) || e(function() {
    var l = {};
    return f[u].call(l) !== l;
  });
  return p ? f = {} : a && (f = i(f)), t(f[u]) || o(f, u, function() {
    return this;
  }), Rh = {
    IteratorPrototype: f,
    BUGGY_SAFARI_ITERATORS: c
  }, Rh;
}
var Dh, a1;
function g7() {
  if (a1) return Dh;
  a1 = 1;
  var e = nk().IteratorPrototype, t = kc(), r = pg(), i = Ac(), n = ps(), o = function() {
    return this;
  };
  return Dh = function(s, a, u, c) {
    var f = a + " Iterator";
    return s.prototype = t(e, { next: r(+!c, u) }), i(s, f, !1, !0), n[f] = o, s;
  }, Dh;
}
var zh, s1;
function v7() {
  if (s1) return zh;
  s1 = 1;
  var e = gn(), t = nn(), r = fi(), i = $c(), n = Br(), o = g7(), s = rk(), a = Zj(), u = Ac(), c = cs(), f = wo(), h = rn(), y = ps(), p = nk(), l = i.PROPER, d = i.CONFIGURABLE, v = p.IteratorPrototype, m = p.BUGGY_SAFARI_ITERATORS, g = h("iterator"), _ = "keys", b = "values", w = "entries", A = function() {
    return this;
  };
  return zh = function(E, O, $, k, j, P, R) {
    o($, O, k);
    var I = function(M) {
      if (M === j && ee) return ee;
      if (!m && M && M in F) return F[M];
      switch (M) {
        case _:
          return function() {
            return new $(this, M);
          };
        case b:
          return function() {
            return new $(this, M);
          };
        case w:
          return function() {
            return new $(this, M);
          };
      }
      return function() {
        return new $(this);
      };
    }, z = O + " Iterator", W = !1, F = E.prototype, te = F[g] || F["@@iterator"] || j && F[j], ee = !m && te || I(j), V = O === "Array" && F.entries || te, T, D, L;
    if (V && (T = s(V.call(new E())), T !== Object.prototype && T.next && (!r && s(T) !== v && (a ? a(T, v) : n(T[g]) || f(T, g, A)), u(T, z, !0, !0), r && (y[z] = A))), l && j === b && te && te.name !== b && (!r && d ? c(F, "name", b) : (W = !0, ee = function() {
      return t(te, this);
    })), j)
      if (D = {
        values: I(b),
        keys: P ? ee : I(_),
        entries: I(w)
      }, R) for (L in D)
        (m || W || !(L in F)) && f(F, L, D[L]);
      else e({ target: O, proto: !0, forced: m || W }, D);
    return (!r || R) && F[g] !== ee && f(F, g, ee, { name: j }), y[O] = ee, D;
  }, zh;
}
var Uh, u1;
function b7() {
  return u1 || (u1 = 1, Uh = function(e, t) {
    return { value: e, done: t };
  }), Uh;
}
var Mh, c1;
function ik() {
  if (c1) return Mh;
  c1 = 1;
  var e = ss(), t = m7(), r = ps(), i = Sc(), n = Vi().f, o = v7(), s = b7(), a = fi(), u = Xn(), c = "Array Iterator", f = i.set, h = i.getterFor(c);
  Mh = o(Array, "Array", function(p, l) {
    f(this, {
      type: c,
      target: e(p),
      // target
      index: 0,
      // next index
      kind: l
      // kind
    });
  }, function() {
    var p = h(this), l = p.target, d = p.index++;
    if (!l || d >= l.length)
      return p.target = null, s(void 0, !0);
    switch (p.kind) {
      case "keys":
        return s(d, !1);
      case "values":
        return s(l[d], !1);
    }
    return s([d, l[d]], !1);
  }, "values");
  var y = r.Arguments = r.Array;
  if (t("keys"), t("values"), t("entries"), !a && u && y.name !== "values") try {
    n(y, "name", { value: "values" });
  } catch {
  }
  return Mh;
}
ik();
var l1 = {}, Fh, f1;
function _7() {
  return f1 || (f1 = 1, Fh = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  }), Fh;
}
var Lh, h1;
function w7() {
  if (h1) return Lh;
  h1 = 1;
  var e = wc(), t = e("span").classList, r = t && t.constructor && t.constructor.prototype;
  return Lh = r === Object.prototype ? void 0 : r, Lh;
}
var p1;
function O7() {
  if (p1) return l1;
  p1 = 1;
  var e = xr(), t = _7(), r = w7(), i = ik(), n = cs(), o = Ac(), s = rn(), a = s("iterator"), u = i.values, c = function(h, y) {
    if (h) {
      if (h[a] !== u) try {
        n(h, a, u);
      } catch {
        h[a] = u;
      }
      if (o(h, y, !0), t[y]) {
        for (var p in i)
          if (h[p] !== i[p]) try {
            n(h, p, i[p]);
          } catch {
            h[p] = i[p];
          }
      }
    }
  };
  for (var f in t)
    c(e[f] && e[f].prototype, f);
  return c(r, "DOMTokenList"), l1;
}
O7();
function $7(e, t) {
  if (Ma(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var i = r.call(e, t);
    if (Ma(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function S7(e) {
  var t = $7(e, "string");
  return Ma(t) == "symbol" ? t : t + "";
}
function Pq(e, t, r) {
  return (t = S7(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
var d1 = {}, Bh, m1;
function E7() {
  if (m1) return Bh;
  m1 = 1;
  var e = Si(), t = _c(), r = Ij(), i = wg(), n = TypeError, o = "Reduce of empty array with no initial value", s = function(a) {
    return function(u, c, f, h) {
      var y = t(u), p = r(y), l = i(y);
      if (e(c), l === 0 && f < 2) throw new n(o);
      var d = a ? l - 1 : 0, v = a ? -1 : 1;
      if (f < 2) for (; ; ) {
        if (d in p) {
          h = p[d], d += v;
          break;
        }
        if (d += v, a ? d < 0 : l <= d)
          throw new n(o);
      }
      for (; a ? d >= 0 : l > d; d += v) d in p && (h = c(h, p[d], d, y));
      return h;
    };
  };
  return Bh = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: s(!1),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: s(!0)
  }, Bh;
}
var qh, y1;
function ok() {
  if (y1) return qh;
  y1 = 1;
  var e = Dr();
  return qh = function(t, r) {
    var i = [][t];
    return !!i && e(function() {
      i.call(null, r || function() {
        return 1;
      }, 1);
    });
  }, qh;
}
var g1;
function x7() {
  if (g1) return d1;
  g1 = 1;
  var e = gn(), t = E7().left, r = ok(), i = dg(), n = xc(), o = !n && i > 79 && i < 83, s = o || !r("reduce");
  return e({ target: "Array", proto: !0, forced: s }, {
    reduce: function(u) {
      var c = arguments.length;
      return t(this, u, c, c > 1 ? arguments[1] : void 0);
    }
  }), d1;
}
x7();
var v1 = {}, b1;
function A7() {
  if (b1) return v1;
  b1 = 1;
  var e = gn(), t = jc(), r = Oc().f, i = ta(), n = hi(), o = Ig(), s = Qn(), a = Tg(), u = fi(), c = t("".slice), f = Math.min, h = a("endsWith"), y = !u && !h && !!(function() {
    var p = r(String.prototype, "endsWith");
    return p && !p.writable;
  })();
  return e({ target: "String", proto: !0, forced: !y && !h }, {
    endsWith: function(l) {
      var d = n(s(this));
      o(l);
      var v = arguments.length > 1 ? arguments[1] : void 0, m = d.length, g = v === void 0 ? m : f(i(v), m), _ = n(l);
      return c(d, g - _.length, g) === _;
    }
  }), v1;
}
A7();
var _1 = {}, w1;
function j7() {
  if (w1) return _1;
  w1 = 1;
  var e = nn(), t = zr(), r = Ag(), i = yn(), n = $n(), o = Qn(), s = Vj(), a = jg(), u = ta(), c = hi(), f = ea(), h = Pg(), y = tk(), p = Dr(), l = y.UNSUPPORTED_Y, d = 4294967295, v = Math.min, m = t([].push), g = t("".slice), _ = !p(function() {
    var w = /(?:)/, A = w.exec;
    w.exec = function() {
      return A.apply(this, arguments);
    };
    var E = "ab".split(w);
    return E.length !== 2 || E[0] !== "a" || E[1] !== "b";
  }), b = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
  "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
  ".".split(/()()/).length > 1 || "".split(/.?/).length;
  return r("split", function(w, A, E) {
    var O = "0".split(void 0, 0).length ? function($, k) {
      return $ === void 0 && k === 0 ? [] : e(A, this, $, k);
    } : A;
    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function(k, j) {
        var P = o(this), R = n(k) ? f(k, w) : void 0;
        return R ? e(R, k, P, j) : e(O, c(P), k, j);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function($, k) {
        var j = i(this), P = c($);
        if (!b) {
          var R = E(O, j, P, k, O !== A);
          if (R.done) return R.value;
        }
        var I = s(j, RegExp), z = j.unicode, W = (j.ignoreCase ? "i" : "") + (j.multiline ? "m" : "") + (j.unicode ? "u" : "") + (l ? "g" : "y"), F = new I(l ? "^(?:" + j.source + ")" : j, W), te = k === void 0 ? d : k >>> 0;
        if (te === 0) return [];
        if (P.length === 0) return h(F, P) === null ? [P] : [];
        for (var ee = 0, V = 0, T = []; V < P.length; ) {
          F.lastIndex = l ? 0 : V;
          var D = h(F, l ? g(P, V) : P), L;
          if (D === null || (L = v(u(F.lastIndex + (l ? V : 0)), P.length)) === ee)
            V = a(P, V, z);
          else {
            if (m(T, g(P, ee, V)), T.length === te) return T;
            for (var M = 1; M <= D.length - 1; M++)
              if (m(T, D[M]), T.length === te) return T;
            V = ee = L;
          }
        }
        return m(T, g(P, ee)), T;
      }
    ];
  }, b || !_, l), _1;
}
j7();
var va = { exports: {} }, Wi = { exports: {} }, k7 = Wi.exports, O1;
function P7() {
  return O1 || (O1 = 1, (function() {
    var e, t, r, i, n, o;
    typeof performance < "u" && performance !== null && performance.now ? Wi.exports = function() {
      return performance.now();
    } : typeof process < "u" && process !== null && process.hrtime ? (Wi.exports = function() {
      return (e() - n) / 1e6;
    }, t = process.hrtime, e = function() {
      var s;
      return s = t(), s[0] * 1e9 + s[1];
    }, i = e(), o = process.uptime() * 1e9, n = i - o) : Date.now ? (Wi.exports = function() {
      return Date.now() - r;
    }, r = Date.now()) : (Wi.exports = function() {
      return (/* @__PURE__ */ new Date()).getTime() - r;
    }, r = (/* @__PURE__ */ new Date()).getTime());
  }).call(k7)), Wi.exports;
}
var $1;
function I7() {
  if ($1) return va.exports;
  $1 = 1;
  for (var e = P7(), t = typeof window > "u" ? Ji : window, r = ["moz", "webkit"], i = "AnimationFrame", n = t["request" + i], o = t["cancel" + i] || t["cancelRequest" + i], s = 0; !n && s < r.length; s++)
    n = t[r[s] + "Request" + i], o = t[r[s] + "Cancel" + i] || t[r[s] + "CancelRequest" + i];
  if (!n || !o) {
    var a = 0, u = 0, c = [], f = 1e3 / 60;
    n = function(h) {
      if (c.length === 0) {
        var y = e(), p = Math.max(0, f - (y - a));
        a = p + y, setTimeout(function() {
          var l = c.slice(0);
          c.length = 0;
          for (var d = 0; d < l.length; d++)
            if (!l[d].cancelled)
              try {
                l[d].callback(a);
              } catch (v) {
                setTimeout(function() {
                  throw v;
                }, 0);
              }
        }, Math.round(p));
      }
      return c.push({
        handle: ++u,
        callback: h,
        cancelled: !1
      }), u;
    }, o = function(h) {
      for (var y = 0; y < c.length; y++)
        c[y].handle === h && (c[y].cancelled = !0);
    };
  }
  return va.exports = function(h) {
    return n.call(t, h);
  }, va.exports.cancel = function() {
    o.apply(t, arguments);
  }, va.exports.polyfill = function(h) {
    h || (h = t), h.requestAnimationFrame = n, h.cancelAnimationFrame = o;
  }, va.exports;
}
var T7 = I7();
const Iq = /* @__PURE__ */ Bi(T7);
var S1 = {}, Zh, E1;
function ak() {
  return E1 || (E1 = 1, Zh = `	
\v\f\r                　\u2028\u2029\uFEFF`), Zh;
}
var Vh, x1;
function N7() {
  if (x1) return Vh;
  x1 = 1;
  var e = zr(), t = Qn(), r = hi(), i = ak(), n = e("".replace), o = RegExp("^[" + i + "]+"), s = RegExp("(^|[^" + i + "])[" + i + "]+$"), a = function(u) {
    return function(c) {
      var f = r(t(c));
      return u & 1 && (f = n(f, o, "")), u & 2 && (f = n(f, s, "$1")), f;
    };
  };
  return Vh = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: a(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: a(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: a(3)
  }, Vh;
}
var Wh, A1;
function C7() {
  if (A1) return Wh;
  A1 = 1;
  var e = $c().PROPER, t = Dr(), r = ak(), i = "​᠎";
  return Wh = function(n) {
    return t(function() {
      return !!r[n]() || i[n]() !== i || e && r[n].name !== n;
    });
  }, Wh;
}
var j1;
function R7() {
  if (j1) return S1;
  j1 = 1;
  var e = gn(), t = N7().trim, r = C7();
  return e({ target: "String", proto: !0, forced: r("trim") }, {
    trim: function() {
      return t(this);
    }
  }), S1;
}
R7();
var Gh, k1;
function D7() {
  return k1 || (k1 = 1, Gh = function(e) {
    this.ok = !1, this.alpha = 1, e.charAt(0) == "#" && (e = e.substr(1, 6)), e = e.replace(/ /g, ""), e = e.toLowerCase();
    var t = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    };
    e = t[e] || e;
    for (var r = [
      {
        re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
        example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
        process: function(u) {
          return [
            parseInt(u[1]),
            parseInt(u[2]),
            parseInt(u[3]),
            parseFloat(u[4])
          ];
        }
      },
      {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function(u) {
          return [
            parseInt(u[1]),
            parseInt(u[2]),
            parseInt(u[3])
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        example: ["#00ff00", "336699"],
        process: function(u) {
          return [
            parseInt(u[1], 16),
            parseInt(u[2], 16),
            parseInt(u[3], 16)
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        example: ["#fb0", "f0f"],
        process: function(u) {
          return [
            parseInt(u[1] + u[1], 16),
            parseInt(u[2] + u[2], 16),
            parseInt(u[3] + u[3], 16)
          ];
        }
      }
    ], i = 0; i < r.length; i++) {
      var n = r[i].re, o = r[i].process, s = n.exec(e);
      if (s) {
        var a = o(s);
        this.r = a[0], this.g = a[1], this.b = a[2], a.length > 3 && (this.alpha = a[3]), this.ok = !0;
      }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, this.toRGBA = function() {
      return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
    }, this.toHex = function() {
      var u = this.r.toString(16), c = this.g.toString(16), f = this.b.toString(16);
      return u.length == 1 && (u = "0" + u), c.length == 1 && (c = "0" + c), f.length == 1 && (f = "0" + f), "#" + u + c + f;
    }, this.getHelpXML = function() {
      for (var u = new Array(), c = 0; c < r.length; c++)
        for (var f = r[c].example, h = 0; h < f.length; h++)
          u[u.length] = f[h];
      for (var y in t)
        u[u.length] = y;
      var p = document.createElement("ul");
      p.setAttribute("id", "rgbcolor-examples");
      for (var c = 0; c < u.length; c++)
        try {
          var l = document.createElement("li"), d = new RGBColor(u[c]), v = document.createElement("div");
          v.style.cssText = "margin: 3px; border: 1px solid black; background:" + d.toHex() + "; color:" + d.toHex(), v.appendChild(document.createTextNode("test"));
          var m = document.createTextNode(
            " " + u[c] + " -> " + d.toRGB() + " -> " + d.toHex()
          );
          l.appendChild(v), l.appendChild(m), p.appendChild(l);
        } catch {
        }
      return p;
    };
  }), Gh;
}
var z7 = D7();
const Tq = /* @__PURE__ */ Bi(z7);
var P1 = {}, I1;
function U7() {
  if (I1) return P1;
  I1 = 1;
  var e = gn(), t = jc(), r = Fj().indexOf, i = ok(), n = t([].indexOf), o = !!n && 1 / n([1], 1, -0) < 0, s = o || !i("indexOf");
  return e({ target: "Array", proto: !0, forced: s }, {
    indexOf: function(u) {
      var c = arguments.length > 1 ? arguments[1] : void 0;
      return o ? n(this, u, c) || 0 : r(this, u, c);
    }
  }), P1;
}
U7();
var T1 = {}, N1;
function M7() {
  if (N1) return T1;
  N1 = 1;
  var e = gn(), t = zr(), r = Ig(), i = Qn(), n = hi(), o = Tg(), s = t("".indexOf);
  return e({ target: "String", proto: !0, forced: !o("includes") }, {
    includes: function(u) {
      return !!~s(
        n(i(this)),
        n(r(u)),
        arguments.length > 1 ? arguments[1] : void 0
      );
    }
  }), T1;
}
M7();
var C1 = {}, Kh, R1;
function F7() {
  if (R1) return Kh;
  R1 = 1;
  var e = bo();
  return Kh = Array.isArray || function(r) {
    return e(r) === "Array";
  }, Kh;
}
var D1;
function L7() {
  if (D1) return C1;
  D1 = 1;
  var e = gn(), t = zr(), r = F7(), i = t([].reverse), n = [1, 2];
  return e({ target: "Array", proto: !0, forced: String(n) === String(n.reverse()) }, {
    reverse: function() {
      return r(this) && (this.length = this.length), i(this);
    }
  }), C1;
}
L7();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var sk = function(e, t) {
  return (sk = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
    r.__proto__ = i;
  } || function(r, i) {
    for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (r[n] = i[n]);
  })(e, t);
};
function uk(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function r() {
    this.constructor = e;
  }
  sk(e, t), e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
function B7(e) {
  var t = "";
  Array.isArray(e) || (e = [e]);
  for (var r = 0; r < e.length; r++) {
    var i = e[r];
    if (i.type === tt.CLOSE_PATH) t += "z";
    else if (i.type === tt.HORIZ_LINE_TO) t += (i.relative ? "h" : "H") + i.x;
    else if (i.type === tt.VERT_LINE_TO) t += (i.relative ? "v" : "V") + i.y;
    else if (i.type === tt.MOVE_TO) t += (i.relative ? "m" : "M") + i.x + " " + i.y;
    else if (i.type === tt.LINE_TO) t += (i.relative ? "l" : "L") + i.x + " " + i.y;
    else if (i.type === tt.CURVE_TO) t += (i.relative ? "c" : "C") + i.x1 + " " + i.y1 + " " + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === tt.SMOOTH_CURVE_TO) t += (i.relative ? "s" : "S") + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === tt.QUAD_TO) t += (i.relative ? "q" : "Q") + i.x1 + " " + i.y1 + " " + i.x + " " + i.y;
    else if (i.type === tt.SMOOTH_QUAD_TO) t += (i.relative ? "t" : "T") + i.x + " " + i.y;
    else {
      if (i.type !== tt.ARC) throw new Error('Unexpected command type "' + i.type + '" at index ' + r + ".");
      t += (i.relative ? "a" : "A") + i.rX + " " + i.rY + " " + i.xRot + " " + +i.lArcFlag + " " + +i.sweepFlag + " " + i.x + " " + i.y;
    }
  }
  return t;
}
function ed(e, t) {
  var r = e[0], i = e[1];
  return [r * Math.cos(t) - i * Math.sin(t), r * Math.sin(t) + i * Math.cos(t)];
}
function Bn() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  for (var r = 0; r < e.length; r++) if (typeof e[r] != "number") throw new Error("assertNumbers arguments[" + r + "] is not a number. " + typeof e[r] + " == typeof " + e[r]);
  return !0;
}
var Pi = Math.PI;
function Hh(e, t, r) {
  e.lArcFlag = e.lArcFlag === 0 ? 0 : 1, e.sweepFlag = e.sweepFlag === 0 ? 0 : 1;
  var i = e.rX, n = e.rY, o = e.x, s = e.y;
  i = Math.abs(e.rX), n = Math.abs(e.rY);
  var a = ed([(t - o) / 2, (r - s) / 2], -e.xRot / 180 * Pi), u = a[0], c = a[1], f = Math.pow(u, 2) / Math.pow(i, 2) + Math.pow(c, 2) / Math.pow(n, 2);
  1 < f && (i *= Math.sqrt(f), n *= Math.sqrt(f)), e.rX = i, e.rY = n;
  var h = Math.pow(i, 2) * Math.pow(c, 2) + Math.pow(n, 2) * Math.pow(u, 2), y = (e.lArcFlag !== e.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(i, 2) * Math.pow(n, 2) - h) / h)), p = i * c / n * y, l = -n * u / i * y, d = ed([p, l], e.xRot / 180 * Pi);
  e.cX = d[0] + (t + o) / 2, e.cY = d[1] + (r + s) / 2, e.phi1 = Math.atan2((c - l) / n, (u - p) / i), e.phi2 = Math.atan2((-c - l) / n, (-u - p) / i), e.sweepFlag === 0 && e.phi2 > e.phi1 && (e.phi2 -= 2 * Pi), e.sweepFlag === 1 && e.phi2 < e.phi1 && (e.phi2 += 2 * Pi), e.phi1 *= 180 / Pi, e.phi2 *= 180 / Pi;
}
function z1(e, t, r) {
  Bn(e, t, r);
  var i = e * e + t * t - r * r;
  if (0 > i) return [];
  if (i === 0) return [[e * r / (e * e + t * t), t * r / (e * e + t * t)]];
  var n = Math.sqrt(i);
  return [[(e * r + t * n) / (e * e + t * t), (t * r - e * n) / (e * e + t * t)], [(e * r - t * n) / (e * e + t * t), (t * r + e * n) / (e * e + t * t)]];
}
var Zr, mi = Math.PI / 180;
function U1(e, t, r) {
  return (1 - r) * e + r * t;
}
function M1(e, t, r, i) {
  return e + Math.cos(i / 180 * Pi) * t + Math.sin(i / 180 * Pi) * r;
}
function F1(e, t, r, i) {
  var n = 1e-6, o = t - e, s = r - t, a = 3 * o + 3 * (i - r) - 6 * s, u = 6 * (s - o), c = 3 * o;
  return Math.abs(a) < n ? [-c / u] : (function(f, h, y) {
    var p = f * f / 4 - h;
    if (p < -y) return [];
    if (p <= y) return [-f / 2];
    var l = Math.sqrt(p);
    return [-f / 2 - l, -f / 2 + l];
  })(u / a, c / a, n);
}
function L1(e, t, r, i, n) {
  var o = 1 - n;
  return e * (o * o * o) + t * (3 * o * o * n) + r * (3 * o * n * n) + i * (n * n * n);
}
(function(e) {
  function t() {
    return n((function(a, u, c) {
      return a.relative && (a.x1 !== void 0 && (a.x1 += u), a.y1 !== void 0 && (a.y1 += c), a.x2 !== void 0 && (a.x2 += u), a.y2 !== void 0 && (a.y2 += c), a.x !== void 0 && (a.x += u), a.y !== void 0 && (a.y += c), a.relative = !1), a;
    }));
  }
  function r() {
    var a = NaN, u = NaN, c = NaN, f = NaN;
    return n((function(h, y, p) {
      return h.type & tt.SMOOTH_CURVE_TO && (h.type = tt.CURVE_TO, a = isNaN(a) ? y : a, u = isNaN(u) ? p : u, h.x1 = h.relative ? y - a : 2 * y - a, h.y1 = h.relative ? p - u : 2 * p - u), h.type & tt.CURVE_TO ? (a = h.relative ? y + h.x2 : h.x2, u = h.relative ? p + h.y2 : h.y2) : (a = NaN, u = NaN), h.type & tt.SMOOTH_QUAD_TO && (h.type = tt.QUAD_TO, c = isNaN(c) ? y : c, f = isNaN(f) ? p : f, h.x1 = h.relative ? y - c : 2 * y - c, h.y1 = h.relative ? p - f : 2 * p - f), h.type & tt.QUAD_TO ? (c = h.relative ? y + h.x1 : h.x1, f = h.relative ? p + h.y1 : h.y1) : (c = NaN, f = NaN), h;
    }));
  }
  function i() {
    var a = NaN, u = NaN;
    return n((function(c, f, h) {
      if (c.type & tt.SMOOTH_QUAD_TO && (c.type = tt.QUAD_TO, a = isNaN(a) ? f : a, u = isNaN(u) ? h : u, c.x1 = c.relative ? f - a : 2 * f - a, c.y1 = c.relative ? h - u : 2 * h - u), c.type & tt.QUAD_TO) {
        a = c.relative ? f + c.x1 : c.x1, u = c.relative ? h + c.y1 : c.y1;
        var y = c.x1, p = c.y1;
        c.type = tt.CURVE_TO, c.x1 = ((c.relative ? 0 : f) + 2 * y) / 3, c.y1 = ((c.relative ? 0 : h) + 2 * p) / 3, c.x2 = (c.x + 2 * y) / 3, c.y2 = (c.y + 2 * p) / 3;
      } else a = NaN, u = NaN;
      return c;
    }));
  }
  function n(a) {
    var u = 0, c = 0, f = NaN, h = NaN;
    return function(y) {
      if (isNaN(f) && !(y.type & tt.MOVE_TO)) throw new Error("path must start with moveto");
      var p = a(y, u, c, f, h);
      return y.type & tt.CLOSE_PATH && (u = f, c = h), y.x !== void 0 && (u = y.relative ? u + y.x : y.x), y.y !== void 0 && (c = y.relative ? c + y.y : y.y), y.type & tt.MOVE_TO && (f = u, h = c), p;
    };
  }
  function o(a, u, c, f, h, y) {
    return Bn(a, u, c, f, h, y), n((function(p, l, d, v) {
      var m = p.x1, g = p.x2, _ = p.relative && !isNaN(v), b = p.x !== void 0 ? p.x : _ ? 0 : l, w = p.y !== void 0 ? p.y : _ ? 0 : d;
      function A(D) {
        return D * D;
      }
      p.type & tt.HORIZ_LINE_TO && u !== 0 && (p.type = tt.LINE_TO, p.y = p.relative ? 0 : d), p.type & tt.VERT_LINE_TO && c !== 0 && (p.type = tt.LINE_TO, p.x = p.relative ? 0 : l), p.x !== void 0 && (p.x = p.x * a + w * c + (_ ? 0 : h)), p.y !== void 0 && (p.y = b * u + p.y * f + (_ ? 0 : y)), p.x1 !== void 0 && (p.x1 = p.x1 * a + p.y1 * c + (_ ? 0 : h)), p.y1 !== void 0 && (p.y1 = m * u + p.y1 * f + (_ ? 0 : y)), p.x2 !== void 0 && (p.x2 = p.x2 * a + p.y2 * c + (_ ? 0 : h)), p.y2 !== void 0 && (p.y2 = g * u + p.y2 * f + (_ ? 0 : y));
      var E = a * f - u * c;
      if (p.xRot !== void 0 && (a !== 1 || u !== 0 || c !== 0 || f !== 1)) if (E === 0) delete p.rX, delete p.rY, delete p.xRot, delete p.lArcFlag, delete p.sweepFlag, p.type = tt.LINE_TO;
      else {
        var O = p.xRot * Math.PI / 180, $ = Math.sin(O), k = Math.cos(O), j = 1 / A(p.rX), P = 1 / A(p.rY), R = A(k) * j + A($) * P, I = 2 * $ * k * (j - P), z = A($) * j + A(k) * P, W = R * f * f - I * u * f + z * u * u, F = I * (a * f + u * c) - 2 * (R * c * f + z * a * u), te = R * c * c - I * a * c + z * a * a, ee = (Math.atan2(F, W - te) + Math.PI) % Math.PI / 2, V = Math.sin(ee), T = Math.cos(ee);
        p.rX = Math.abs(E) / Math.sqrt(W * A(T) + F * V * T + te * A(V)), p.rY = Math.abs(E) / Math.sqrt(W * A(V) - F * V * T + te * A(T)), p.xRot = 180 * ee / Math.PI;
      }
      return p.sweepFlag !== void 0 && 0 > E && (p.sweepFlag = +!p.sweepFlag), p;
    }));
  }
  function s() {
    return function(a) {
      var u = {};
      for (var c in a) u[c] = a[c];
      return u;
    };
  }
  e.ROUND = function(a) {
    function u(c) {
      return Math.round(c * a) / a;
    }
    return a === void 0 && (a = 1e13), Bn(a), function(c) {
      return c.x1 !== void 0 && (c.x1 = u(c.x1)), c.y1 !== void 0 && (c.y1 = u(c.y1)), c.x2 !== void 0 && (c.x2 = u(c.x2)), c.y2 !== void 0 && (c.y2 = u(c.y2)), c.x !== void 0 && (c.x = u(c.x)), c.y !== void 0 && (c.y = u(c.y)), c.rX !== void 0 && (c.rX = u(c.rX)), c.rY !== void 0 && (c.rY = u(c.rY)), c;
    };
  }, e.TO_ABS = t, e.TO_REL = function() {
    return n((function(a, u, c) {
      return a.relative || (a.x1 !== void 0 && (a.x1 -= u), a.y1 !== void 0 && (a.y1 -= c), a.x2 !== void 0 && (a.x2 -= u), a.y2 !== void 0 && (a.y2 -= c), a.x !== void 0 && (a.x -= u), a.y !== void 0 && (a.y -= c), a.relative = !0), a;
    }));
  }, e.NORMALIZE_HVZ = function(a, u, c) {
    return a === void 0 && (a = !0), u === void 0 && (u = !0), c === void 0 && (c = !0), n((function(f, h, y, p, l) {
      if (isNaN(p) && !(f.type & tt.MOVE_TO)) throw new Error("path must start with moveto");
      return u && f.type & tt.HORIZ_LINE_TO && (f.type = tt.LINE_TO, f.y = f.relative ? 0 : y), c && f.type & tt.VERT_LINE_TO && (f.type = tt.LINE_TO, f.x = f.relative ? 0 : h), a && f.type & tt.CLOSE_PATH && (f.type = tt.LINE_TO, f.x = f.relative ? p - h : p, f.y = f.relative ? l - y : l), f.type & tt.ARC && (f.rX === 0 || f.rY === 0) && (f.type = tt.LINE_TO, delete f.rX, delete f.rY, delete f.xRot, delete f.lArcFlag, delete f.sweepFlag), f;
    }));
  }, e.NORMALIZE_ST = r, e.QT_TO_C = i, e.INFO = n, e.SANITIZE = function(a) {
    a === void 0 && (a = 0), Bn(a);
    var u = NaN, c = NaN, f = NaN, h = NaN;
    return n((function(y, p, l, d, v) {
      var m = Math.abs, g = !1, _ = 0, b = 0;
      if (y.type & tt.SMOOTH_CURVE_TO && (_ = isNaN(u) ? 0 : p - u, b = isNaN(c) ? 0 : l - c), y.type & (tt.CURVE_TO | tt.SMOOTH_CURVE_TO) ? (u = y.relative ? p + y.x2 : y.x2, c = y.relative ? l + y.y2 : y.y2) : (u = NaN, c = NaN), y.type & tt.SMOOTH_QUAD_TO ? (f = isNaN(f) ? p : 2 * p - f, h = isNaN(h) ? l : 2 * l - h) : y.type & tt.QUAD_TO ? (f = y.relative ? p + y.x1 : y.x1, h = y.relative ? l + y.y1 : y.y2) : (f = NaN, h = NaN), y.type & tt.LINE_COMMANDS || y.type & tt.ARC && (y.rX === 0 || y.rY === 0 || !y.lArcFlag) || y.type & tt.CURVE_TO || y.type & tt.SMOOTH_CURVE_TO || y.type & tt.QUAD_TO || y.type & tt.SMOOTH_QUAD_TO) {
        var w = y.x === void 0 ? 0 : y.relative ? y.x : y.x - p, A = y.y === void 0 ? 0 : y.relative ? y.y : y.y - l;
        _ = isNaN(f) ? y.x1 === void 0 ? _ : y.relative ? y.x : y.x1 - p : f - p, b = isNaN(h) ? y.y1 === void 0 ? b : y.relative ? y.y : y.y1 - l : h - l;
        var E = y.x2 === void 0 ? 0 : y.relative ? y.x : y.x2 - p, O = y.y2 === void 0 ? 0 : y.relative ? y.y : y.y2 - l;
        m(w) <= a && m(A) <= a && m(_) <= a && m(b) <= a && m(E) <= a && m(O) <= a && (g = !0);
      }
      return y.type & tt.CLOSE_PATH && m(p - d) <= a && m(l - v) <= a && (g = !0), g ? [] : y;
    }));
  }, e.MATRIX = o, e.ROTATE = function(a, u, c) {
    u === void 0 && (u = 0), c === void 0 && (c = 0), Bn(a, u, c);
    var f = Math.sin(a), h = Math.cos(a);
    return o(h, f, -f, h, u - u * h + c * f, c - u * f - c * h);
  }, e.TRANSLATE = function(a, u) {
    return u === void 0 && (u = 0), Bn(a, u), o(1, 0, 0, 1, a, u);
  }, e.SCALE = function(a, u) {
    return u === void 0 && (u = a), Bn(a, u), o(a, 0, 0, u, 0, 0);
  }, e.SKEW_X = function(a) {
    return Bn(a), o(1, 0, Math.atan(a), 1, 0, 0);
  }, e.SKEW_Y = function(a) {
    return Bn(a), o(1, Math.atan(a), 0, 1, 0, 0);
  }, e.X_AXIS_SYMMETRY = function(a) {
    return a === void 0 && (a = 0), Bn(a), o(-1, 0, 0, 1, a, 0);
  }, e.Y_AXIS_SYMMETRY = function(a) {
    return a === void 0 && (a = 0), Bn(a), o(1, 0, 0, -1, 0, a);
  }, e.A_TO_C = function() {
    return n((function(a, u, c) {
      return tt.ARC === a.type ? (function(f, h, y) {
        var p, l, d, v;
        f.cX || Hh(f, h, y);
        for (var m = Math.min(f.phi1, f.phi2), g = Math.max(f.phi1, f.phi2) - m, _ = Math.ceil(g / 90), b = new Array(_), w = h, A = y, E = 0; E < _; E++) {
          var O = U1(f.phi1, f.phi2, E / _), $ = U1(f.phi1, f.phi2, (E + 1) / _), k = $ - O, j = 4 / 3 * Math.tan(k * mi / 4), P = [Math.cos(O * mi) - j * Math.sin(O * mi), Math.sin(O * mi) + j * Math.cos(O * mi)], R = P[0], I = P[1], z = [Math.cos($ * mi), Math.sin($ * mi)], W = z[0], F = z[1], te = [W + j * Math.sin($ * mi), F - j * Math.cos($ * mi)], ee = te[0], V = te[1];
          b[E] = { relative: f.relative, type: tt.CURVE_TO };
          var T = function(D, L) {
            var M = ed([D * f.rX, L * f.rY], f.xRot), N = M[0], Z = M[1];
            return [f.cX + N, f.cY + Z];
          };
          p = T(R, I), b[E].x1 = p[0], b[E].y1 = p[1], l = T(ee, V), b[E].x2 = l[0], b[E].y2 = l[1], d = T(W, F), b[E].x = d[0], b[E].y = d[1], f.relative && (b[E].x1 -= w, b[E].y1 -= A, b[E].x2 -= w, b[E].y2 -= A, b[E].x -= w, b[E].y -= A), w = (v = [b[E].x, b[E].y])[0], A = v[1];
        }
        return b;
      })(a, a.relative ? 0 : u, a.relative ? 0 : c) : a;
    }));
  }, e.ANNOTATE_ARCS = function() {
    return n((function(a, u, c) {
      return a.relative && (u = 0, c = 0), tt.ARC === a.type && Hh(a, u, c), a;
    }));
  }, e.CLONE = s, e.CALCULATE_BOUNDS = function() {
    var a = function(y) {
      var p = {};
      for (var l in y) p[l] = y[l];
      return p;
    }, u = t(), c = i(), f = r(), h = n((function(y, p, l) {
      var d = f(c(u(a(y))));
      function v(V) {
        V > h.maxX && (h.maxX = V), V < h.minX && (h.minX = V);
      }
      function m(V) {
        V > h.maxY && (h.maxY = V), V < h.minY && (h.minY = V);
      }
      if (d.type & tt.DRAWING_COMMANDS && (v(p), m(l)), d.type & tt.HORIZ_LINE_TO && v(d.x), d.type & tt.VERT_LINE_TO && m(d.y), d.type & tt.LINE_TO && (v(d.x), m(d.y)), d.type & tt.CURVE_TO) {
        v(d.x), m(d.y);
        for (var g = 0, _ = F1(p, d.x1, d.x2, d.x); g < _.length; g++)
          0 < (ee = _[g]) && 1 > ee && v(L1(p, d.x1, d.x2, d.x, ee));
        for (var b = 0, w = F1(l, d.y1, d.y2, d.y); b < w.length; b++)
          0 < (ee = w[b]) && 1 > ee && m(L1(l, d.y1, d.y2, d.y, ee));
      }
      if (d.type & tt.ARC) {
        v(d.x), m(d.y), Hh(d, p, l);
        for (var A = d.xRot / 180 * Math.PI, E = Math.cos(A) * d.rX, O = Math.sin(A) * d.rX, $ = -Math.sin(A) * d.rY, k = Math.cos(A) * d.rY, j = d.phi1 < d.phi2 ? [d.phi1, d.phi2] : -180 > d.phi2 ? [d.phi2 + 360, d.phi1 + 360] : [d.phi2, d.phi1], P = j[0], R = j[1], I = function(V) {
          var T = V[0], D = V[1], L = 180 * Math.atan2(D, T) / Math.PI;
          return L < P ? L + 360 : L;
        }, z = 0, W = z1($, -E, 0).map(I); z < W.length; z++)
          (ee = W[z]) > P && ee < R && v(M1(d.cX, E, $, ee));
        for (var F = 0, te = z1(k, -O, 0).map(I); F < te.length; F++) {
          var ee;
          (ee = te[F]) > P && ee < R && m(M1(d.cY, O, k, ee));
        }
      }
      return y;
    }));
    return h.minX = 1 / 0, h.maxX = -1 / 0, h.minY = 1 / 0, h.maxY = -1 / 0, h;
  };
})(Zr || (Zr = {}));
var Ln, ck = (function() {
  function e() {
  }
  return e.prototype.round = function(t) {
    return this.transform(Zr.ROUND(t));
  }, e.prototype.toAbs = function() {
    return this.transform(Zr.TO_ABS());
  }, e.prototype.toRel = function() {
    return this.transform(Zr.TO_REL());
  }, e.prototype.normalizeHVZ = function(t, r, i) {
    return this.transform(Zr.NORMALIZE_HVZ(t, r, i));
  }, e.prototype.normalizeST = function() {
    return this.transform(Zr.NORMALIZE_ST());
  }, e.prototype.qtToC = function() {
    return this.transform(Zr.QT_TO_C());
  }, e.prototype.aToC = function() {
    return this.transform(Zr.A_TO_C());
  }, e.prototype.sanitize = function(t) {
    return this.transform(Zr.SANITIZE(t));
  }, e.prototype.translate = function(t, r) {
    return this.transform(Zr.TRANSLATE(t, r));
  }, e.prototype.scale = function(t, r) {
    return this.transform(Zr.SCALE(t, r));
  }, e.prototype.rotate = function(t, r, i) {
    return this.transform(Zr.ROTATE(t, r, i));
  }, e.prototype.matrix = function(t, r, i, n, o, s) {
    return this.transform(Zr.MATRIX(t, r, i, n, o, s));
  }, e.prototype.skewX = function(t) {
    return this.transform(Zr.SKEW_X(t));
  }, e.prototype.skewY = function(t) {
    return this.transform(Zr.SKEW_Y(t));
  }, e.prototype.xSymmetry = function(t) {
    return this.transform(Zr.X_AXIS_SYMMETRY(t));
  }, e.prototype.ySymmetry = function(t) {
    return this.transform(Zr.Y_AXIS_SYMMETRY(t));
  }, e.prototype.annotateArcs = function() {
    return this.transform(Zr.ANNOTATE_ARCS());
  }, e;
})(), q7 = function(e) {
  return e === " " || e === "	" || e === "\r" || e === `
`;
}, B1 = function(e) {
  return 48 <= e.charCodeAt(0) && e.charCodeAt(0) <= 57;
}, Z7 = (function(e) {
  function t() {
    var r = e.call(this) || this;
    return r.curNumber = "", r.curCommandType = -1, r.curCommandRelative = !1, r.canParseCommandOrComma = !0, r.curNumberHasExp = !1, r.curNumberHasExpDigits = !1, r.curNumberHasDecimal = !1, r.curArgs = [], r;
  }
  return uk(t, e), t.prototype.finish = function(r) {
    if (r === void 0 && (r = []), this.parse(" ", r), this.curArgs.length !== 0 || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
    return r;
  }, t.prototype.parse = function(r, i) {
    var n = this;
    i === void 0 && (i = []);
    for (var o = function(h) {
      i.push(h), n.curArgs.length = 0, n.canParseCommandOrComma = !0;
    }, s = 0; s < r.length; s++) {
      var a = r[s], u = !(this.curCommandType !== tt.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), c = B1(a) && (this.curNumber === "0" && a === "0" || u);
      if (!B1(a) || c) if (a !== "e" && a !== "E") if (a !== "-" && a !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits) if (a !== "." || this.curNumberHasExp || this.curNumberHasDecimal || u) {
        if (this.curNumber && this.curCommandType !== -1) {
          var f = Number(this.curNumber);
          if (isNaN(f)) throw new SyntaxError("Invalid number ending at " + s);
          if (this.curCommandType === tt.ARC) {
            if (this.curArgs.length === 0 || this.curArgs.length === 1) {
              if (0 > f) throw new SyntaxError('Expected positive number, got "' + f + '" at index "' + s + '"');
            } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1") throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + s + '"');
          }
          this.curArgs.push(f), this.curArgs.length === V7[this.curCommandType] && (tt.HORIZ_LINE_TO === this.curCommandType ? o({ type: tt.HORIZ_LINE_TO, relative: this.curCommandRelative, x: f }) : tt.VERT_LINE_TO === this.curCommandType ? o({ type: tt.VERT_LINE_TO, relative: this.curCommandRelative, y: f }) : this.curCommandType === tt.MOVE_TO || this.curCommandType === tt.LINE_TO || this.curCommandType === tt.SMOOTH_QUAD_TO ? (o({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), tt.MOVE_TO === this.curCommandType && (this.curCommandType = tt.LINE_TO)) : this.curCommandType === tt.CURVE_TO ? o({ type: tt.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === tt.SMOOTH_CURVE_TO ? o({ type: tt.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === tt.QUAD_TO ? o({ type: tt.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === tt.ARC && o({ type: tt.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
        }
        if (!q7(a)) if (a === "," && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;
        else if (a !== "+" && a !== "-" && a !== ".") if (c) this.curNumber = a, this.curNumberHasDecimal = !1;
        else {
          if (this.curArgs.length !== 0) throw new SyntaxError("Unterminated command at index " + s + ".");
          if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + a + '" at index ' + s + ". Command cannot follow comma");
          if (this.canParseCommandOrComma = !1, a !== "z" && a !== "Z") if (a === "h" || a === "H") this.curCommandType = tt.HORIZ_LINE_TO, this.curCommandRelative = a === "h";
          else if (a === "v" || a === "V") this.curCommandType = tt.VERT_LINE_TO, this.curCommandRelative = a === "v";
          else if (a === "m" || a === "M") this.curCommandType = tt.MOVE_TO, this.curCommandRelative = a === "m";
          else if (a === "l" || a === "L") this.curCommandType = tt.LINE_TO, this.curCommandRelative = a === "l";
          else if (a === "c" || a === "C") this.curCommandType = tt.CURVE_TO, this.curCommandRelative = a === "c";
          else if (a === "s" || a === "S") this.curCommandType = tt.SMOOTH_CURVE_TO, this.curCommandRelative = a === "s";
          else if (a === "q" || a === "Q") this.curCommandType = tt.QUAD_TO, this.curCommandRelative = a === "q";
          else if (a === "t" || a === "T") this.curCommandType = tt.SMOOTH_QUAD_TO, this.curCommandRelative = a === "t";
          else {
            if (a !== "a" && a !== "A") throw new SyntaxError('Unexpected character "' + a + '" at index ' + s + ".");
            this.curCommandType = tt.ARC, this.curCommandRelative = a === "a";
          }
          else i.push({ type: tt.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
        }
        else this.curNumber = a, this.curNumberHasDecimal = a === ".";
      } else this.curNumber += a, this.curNumberHasDecimal = !0;
      else this.curNumber += a;
      else this.curNumber += a, this.curNumberHasExp = !0;
      else this.curNumber += a, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return i;
  }, t.prototype.transform = function(r) {
    return Object.create(this, { parse: { value: function(i, n) {
      n === void 0 && (n = []);
      for (var o = 0, s = Object.getPrototypeOf(this).parse.call(this, i); o < s.length; o++) {
        var a = s[o], u = r(a);
        Array.isArray(u) ? n.push.apply(n, u) : n.push(u);
      }
      return n;
    } } });
  }, t;
})(ck), tt = (function(e) {
  function t(r) {
    var i = e.call(this) || this;
    return i.commands = typeof r == "string" ? t.parse(r) : r, i;
  }
  return uk(t, e), t.prototype.encode = function() {
    return t.encode(this.commands);
  }, t.prototype.getBounds = function() {
    var r = Zr.CALCULATE_BOUNDS();
    return this.transform(r), r;
  }, t.prototype.transform = function(r) {
    for (var i = [], n = 0, o = this.commands; n < o.length; n++) {
      var s = r(o[n]);
      Array.isArray(s) ? i.push.apply(i, s) : i.push(s);
    }
    return this.commands = i, this;
  }, t.encode = function(r) {
    return B7(r);
  }, t.parse = function(r) {
    var i = new Z7(), n = [];
    return i.parse(r, n), i.finish(n), n;
  }, t.CLOSE_PATH = 1, t.MOVE_TO = 2, t.HORIZ_LINE_TO = 4, t.VERT_LINE_TO = 8, t.LINE_TO = 16, t.CURVE_TO = 32, t.SMOOTH_CURVE_TO = 64, t.QUAD_TO = 128, t.SMOOTH_QUAD_TO = 256, t.ARC = 512, t.LINE_COMMANDS = t.LINE_TO | t.HORIZ_LINE_TO | t.VERT_LINE_TO, t.DRAWING_COMMANDS = t.HORIZ_LINE_TO | t.VERT_LINE_TO | t.LINE_TO | t.CURVE_TO | t.SMOOTH_CURVE_TO | t.QUAD_TO | t.SMOOTH_QUAD_TO | t.ARC, t;
})(ck), V7 = ((Ln = {})[tt.MOVE_TO] = 2, Ln[tt.LINE_TO] = 2, Ln[tt.HORIZ_LINE_TO] = 1, Ln[tt.VERT_LINE_TO] = 1, Ln[tt.CLOSE_PATH] = 0, Ln[tt.QUAD_TO] = 4, Ln[tt.SMOOTH_QUAD_TO] = 2, Ln[tt.CURVE_TO] = 6, Ln[tt.SMOOTH_CURVE_TO] = 4, Ln[tt.ARC] = 7, Ln), q1 = {}, Z1;
function W7() {
  if (Z1) return q1;
  Z1 = 1;
  var e = $c().PROPER, t = wo(), r = yn(), i = hi(), n = Dr(), o = kg(), s = "toString", a = RegExp.prototype, u = a[s], c = n(function() {
    return u.call({ source: "a", flags: "b" }) !== "/a/b";
  }), f = e && u.name !== s;
  return (c || f) && t(a, s, function() {
    var y = r(this), p = i(y.source), l = i(o(y));
    return "/" + p + "/" + l;
  }, { unsafe: !0 }), q1;
}
W7();
export {
  KE as $,
  hn as A,
  rq as B,
  uu as C,
  C6 as D,
  i6 as E,
  Gm as F,
  d6 as G,
  oq as H,
  hq as I,
  lq as J,
  C5 as K,
  pq as L,
  T5 as M,
  uq as N,
  cq as O,
  fq as P,
  L5 as Q,
  vq as R,
  _q as S,
  bq as T,
  gq as U,
  Aq as V,
  _x as W,
  Tu as X,
  Ta as Y,
  Mt as Z,
  Nm as _,
  Cu as a,
  el as a0,
  Tq as a1,
  kq as a2,
  tt as a3,
  Iq as a4,
  Pq as a5,
  Ma as a6,
  xq as a7,
  Eq as a8,
  Sq as a9,
  oF as aa,
  aF as ab,
  V2 as ac,
  Xo as ad,
  wq as ae,
  T6 as af,
  aq as ag,
  sq as ah,
  Do as ai,
  $q as aj,
  dq as ak,
  mq as al,
  yq as am,
  jq as an,
  ME as b,
  o6 as c,
  qE as d,
  x6 as e,
  Ru as f,
  Q7 as g,
  eq as h,
  tq as i,
  OT as j,
  Pm as k,
  g6 as l,
  Iu as m,
  UE as n,
  c6 as o,
  P6 as p,
  ku as q,
  ex as r,
  tp as s,
  Rm as t,
  Im as u,
  ax as v,
  sx as w,
  iq as x,
  nq as y,
  X7 as z
};
