var k2 = Object.defineProperty;
var A2 = (n, t, e) => t in n ? k2(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var et = (n, t, e) => A2(n, typeof t != "symbol" ? t + "" : t, e);
import { i as N2, u as Oe, o as Io, n as Es, r as Ne, a as C2, w as cr, g as P2, b as L2, c as I2, s as co, d as pa, e as bp, f as Zr, m as gl, h as E2, j as Zt, k as ce, F as Qn, l as Pr, p as pi, q as Bn, t as ye, v as hn, x as Xg, y as Jg, z as O2, A as ke, B as ns, C as rn, D as Of, E as Zg, G as Fl, H as Wn, I as Zn, J as qu, K as T2, L as mo, M as F2, N as M2 } from "./main-DFMVGBIU.js";
let xu;
const D2 = new Uint8Array(16);
function R2() {
  if (!xu && (xu = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !xu))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return xu(D2);
}
const Kn = [];
for (let n = 0; n < 256; ++n)
  Kn.push((n + 256).toString(16).slice(1));
function B2(n, t = 0) {
  return Kn[n[t + 0]] + Kn[n[t + 1]] + Kn[n[t + 2]] + Kn[n[t + 3]] + "-" + Kn[n[t + 4]] + Kn[n[t + 5]] + "-" + Kn[n[t + 6]] + Kn[n[t + 7]] + "-" + Kn[n[t + 8]] + Kn[n[t + 9]] + "-" + Kn[n[t + 10]] + Kn[n[t + 11]] + Kn[n[t + 12]] + Kn[n[t + 13]] + Kn[n[t + 14]] + Kn[n[t + 15]];
}
const j2 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vp = {
  randomUUID: j2
};
function Qg(n, t, e) {
  if (vp.randomUUID && !t && !n)
    return vp.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || R2)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, B2(i);
}
const ha = 1e-10, q2 = 10, z2 = Number.MAX_SAFE_INTEGER, $2 = 4294967295, Jn = (n) => typeof n == "number" && Number.isFinite(n), zu = (n) => Array.isArray(n) && n.length > 0;
function al(n, t, e = ha) {
  if (n === t) return 0;
  if (Number.isInteger(n) && Number.isInteger(t))
    return n > t ? 1 : -1;
  const i = n - t;
  return Math.abs(i) < e ? 0 : i;
}
const U2 = {
  greaterThan: (n, t, e = ha) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) > 0,
  greaterThanOrEqualTo: (n, t, e = ha) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) >= 0,
  lessThan: (n, t, e = ha) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) < 0,
  lessThanOrEqualTo: (n, t, e = ha) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) <= 0,
  equalTo: (n, t, e = ha) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) === 0
};
function W2(n) {
  return Jn(n) ? Number.isInteger(n) ? n : Number(n.toFixed(q2)) : !1;
}
function H2(n) {
  if (!Jn(n) || n < 0 || n > z2)
    throw new Error("Invalid length parameter");
  return Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / ($2 + 1) * n);
}
function G2(n, t) {
  if (!zu(n))
    throw new Error("Invalid array parameter");
  if (!Jn(t) || t < 0 || t > n.length)
    throw new Error("Invalid size parameter");
  const e = n.slice(), i = n.length - t;
  for (let r = n.length - 1; r >= i; r--) {
    const s = Math.floor(Math.random() * (r + 1));
    [e[r], e[s]] = [e[s], e[r]];
  }
  return e.slice(i);
}
class _u {
  static calculateMean(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    return t.reduce((e, i) => e + i, 0) / t.length;
  }
  static calculateStandardDeviation(t, e = null) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const i = e ?? this.calculateMean(t), r = t.reduce((s, o) => {
      const a = o - i;
      return s + a * a;
    }, 0) / t.length;
    return Math.sqrt(r);
  }
  static calculateCoefficientOfVariation(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const e = this.calculateMean(t);
    if (e === 0)
      throw new Error("Mean is zero, coefficient of variation undefined");
    return this.calculateStandardDeviation(t, e) / e;
  }
}
const Ge = {
  ...U2,
  isNumber: Jn,
  round: W2,
  getRandom: H2,
  getRandomSample: G2,
  calculateStandardDeviation: _u.calculateStandardDeviation.bind(_u),
  calculateCoefficientOfVariation: _u.calculateCoefficientOfVariation.bind(_u)
}, Ju = {
  //sort by width then length - use .sort(sortHeightDescWidthDesc)
  WDLD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
  },
  WALA(n, t) {
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
  },
  //sort by length d then width d
  LDWD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
  },
  LAWA(n, t) {
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
  },
  //sort by width d
  WD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.w === t.w) return 0;
  },
  LD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.l === t.l) return 0;
  },
  LDIDA(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  WDIDA(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  //sort by proportion
  /* sortProportion: function(a, b) {
  
  		if (a.proportion < b.proportion) return 1;
  		if (a.proportion > b.proportion) return -1;
  
  		if (a.proportion === b.proportion) return a.index - b.index;
  
  	} */
  //area descending
  AD(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
  },
  AA(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) return 0;
  },
  AAID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  ADID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  //by id ascending
  ID(n, t) {
    if (!n.id || !t.id) return 0;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  IDDesc(n, t) {
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(i[0]) - parseInt(e[0]) : parseInt(i[1]) - parseInt(e[1]);
  },
  StockID(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  StockIDAD(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    const r = n.getArea(), s = t.getArea();
    if (r < s) return 1;
    if (r > s) return -1;
  },
  parentID(n, t) {
    return n.parentID - t.parentID;
  },
  YX(n, t) {
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
    if (n.y === t.y) return 0;
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
  },
  XY(n, t) {
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
    if (n.x === t.x) return 0;
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
  },
  subset(n, t) {
    if (n.totalLength < t.totalLength) return 1;
    if (n.totalLength > t.totalLength) return -1;
    if (n.area === t.area) return 0;
    if (n.area < t.area) return 1;
    if (n.area > t.area) return -1;
  },
  placementOrder(n, t) {
    return (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  typePlacementOrder(n, t) {
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  stockIDTypePlacementOrder(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  offcutPlacementOrder(n, t) {
    var r, s;
    if (!((r = n == null ? void 0 : n.stock) != null && r.id) || !((s = t == null ? void 0 : t.stock) != null && s.id)) return 0;
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : e[1] !== i[1] ? parseInt(e[1]) - parseInt(i[1]) : (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  groupPlacementOrder(n, t) {
    if (n.placementOrder > t.placementOrder) return 1;
    if (n.placementOrder < t.placementOrder) return -1;
    if (n.groupPlacementOrder === t.groupPlacementOrder) return 0;
    if (n.groupPlacementOrder > t.groupPlacementOrder) return 1;
    if (n.groupPlacementOrder < t.groupPlacementOrder) return -1;
  },
  swapFirstTwo(n) {
    const t = n[1];
    n[1] = n[0], n[0] = t;
  },
  //Fisher-Yates shuffle
  shuffle(n) {
    for (let t = n.length - 1; t > 0; t--) {
      const e = Math.floor(Math.random() * (t + 1));
      [n[t], n[e]] = [n[e], n[t]];
    }
  },
  /**
      * generator function which accepts a dimension to cater for shape rotation lock
      */
  fillThenArea(n) {
    return function(t, e) {
      return t.getLongSide(n) > e.getLongSide(n) ? -1 : t.getLongSide(n) < e.getLongSide(n) ? 1 : t.getArea() > e.getArea() ? -1 : t.getArea() < e.getArea() ? 1 : 0;
    };
  },
  aspect(n, t) {
    const e = n.getAspect(), i = t.getAspect();
    return e > i ? -1 : e < i ? 1 : 0;
  }
};
function V2(n) {
  if (n === "l") return "x";
  if (n === "w") return "y";
}
function Ao(n) {
  return n ? n === "l" ? "w" : "l" : null;
}
function Y2(n) {
  return n ? n === "x" ? "y" : "x" : null;
}
class ga {
  constructor(t) {
    et(this, "x1");
    et(this, "x2");
    et(this, "y1");
    et(this, "y2");
    et(this, "dimension");
    et(this, "direction");
    et(this, "shapeCollisions");
    et(this, "origin");
    et(this, "type");
    this.x1 = t.x1, this.x2 = t.x2, this.y1 = t.y1, this.y2 = t.y2, this.dimension = K2(this), this.direction = X2(this), this.type = t != null && t.type ? t.type : null, this.origin = t != null && t.origin ? t.origin : null;
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
}
function Ps(n, t, e, i, r = null, s = null) {
  return new ga({ x1: n, y1: t, x2: e, y2: i, origin: r, type: s });
}
function K2(n) {
  return typeof n > "u" || !Ge.isNumber(n.x1) || !Ge.isNumber(n.x2) || !Ge.isNumber(n.y1) || !Ge.isNumber(n.y2) ? null : n.x1 === n.x2 && n.y1 !== n.y2 ? "w" : n.y1 === n.y2 && n.x1 !== n.x2 ? "l" : null;
}
function X2(n) {
  return typeof n > "u" || !Ge.isNumber(n.x1) || !Ge.isNumber(n.x2) || !Ge.isNumber(n.y1) || !Ge.isNumber(n.y2) ? null : n.x1 < n.x2 ? "lr" : n.x1 > n.x2 ? "rl" : n.y1 < n.y2 ? "bt" : n.y1 > n.y2 ? "tb" : null;
}
function J2(n, t) {
  const e = n.getCorners(), i = {};
  return e.bottomLeft.x > 0 && e.bottomLeft.y > 0 && (i.bottomLeftDown = Ps(
    e.bottomLeft.x,
    e.bottomLeft.y,
    e.bottomLeft.x,
    0,
    "bottomLeft",
    "bottomLeftDown"
  ), i.bottomLeftLeft = Ps(
    e.bottomLeft.x,
    e.bottomLeft.y,
    0,
    e.bottomLeft.y,
    "bottomLeft",
    "bottomLeftLeft"
  )), e.topLeft.x > 0 && e.topLeft.y < t.w && (i.topLeftLeft = Ps(
    e.topLeft.x,
    e.topLeft.y,
    0,
    e.topLeft.y,
    "topLeft",
    "topLeftLeft"
  ), i.topLeftTop = Ps(
    e.topLeft.x,
    e.topLeft.y,
    e.topLeft.x,
    t.w,
    "topLeft",
    "topLeftTop"
  )), e.topRight.y < t.w && e.topRight.x < t.l && (i.topRightTop = Ps(
    e.topRight.x,
    e.topRight.y,
    e.topRight.x,
    t.w,
    "topRight",
    "topRightTop"
  ), i.topRightRight = Ps(
    e.topRight.x,
    e.topRight.y,
    t.l,
    e.topRight.y,
    "topRight",
    "topRightRight"
  )), e.bottomRight.x < t.l && e.bottomRight.y > 0 && (i.bottomRightRight = Ps(
    e.bottomRight.x,
    e.bottomRight.y,
    t.l,
    e.bottomRight.y,
    "bottomRight",
    "bottomRightRight"
  ), i.bottomRightDown = Ps(
    e.bottomRight.x,
    e.bottomRight.y,
    e.bottomRight.x,
    0,
    "bottomRight",
    "bottomRightDown"
  )), i;
}
var t0 = Object.defineProperty, Z2 = Object.getOwnPropertyNames, It = (n, t) => t0(n, "name", { value: t, configurable: !0 }), Q2 = (n, t) => function() {
  return t || (0, n[Z2(n)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Tf = (n, t) => {
  for (var e in t)
    t0(n, e, { get: t[e], enumerable: !0 });
}, ty = Q2({
  "(disabled):util"() {
  }
}), Zu = {};
Tf(Zu, {
  addChainableMethod: () => Hf,
  addLengthGuard: () => Rl,
  addMethod: () => $f,
  addProperty: () => zf,
  checkError: () => Mi,
  compareByInspect: () => nc,
  eql: () => C0,
  expectTypes: () => a0,
  flag: () => De,
  getActual: () => Sc,
  getMessage: () => Df,
  getName: () => Ac,
  getOperator: () => Kf,
  getOwnEnumerableProperties: () => Yf,
  getOwnEnumerablePropertySymbols: () => Vf,
  getPathInfo: () => qf,
  hasProperty: () => kc,
  inspect: () => He,
  isNaN: () => ic,
  isNumeric: () => Gn,
  isProxyEnabled: () => Dl,
  isRegExp: () => rc,
  objDisplay: () => yo,
  overwriteChainableMethod: () => Gf,
  overwriteMethod: () => Wf,
  overwriteProperty: () => Uf,
  proxify: () => Na,
  test: () => Ff,
  transferFlags: () => gr,
  type: () => sn
});
var Mi = {};
Tf(Mi, {
  compatibleConstructor: () => i0,
  compatibleInstance: () => n0,
  compatibleMessage: () => r0,
  getConstructorName: () => s0,
  getMessage: () => o0
});
function _c(n) {
  return n instanceof Error || Object.prototype.toString.call(n) === "[object Error]";
}
It(_c, "isErrorInstance");
function e0(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
It(e0, "isRegExp");
function n0(n, t) {
  return _c(t) && n === t;
}
It(n0, "compatibleInstance");
function i0(n, t) {
  return _c(t) ? n.constructor === t.constructor || n instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? n.constructor === t || n instanceof t : !1;
}
It(i0, "compatibleConstructor");
function r0(n, t) {
  const e = typeof n == "string" ? n : n.message;
  return e0(t) ? t.test(e) : typeof t == "string" ? e.indexOf(t) !== -1 : !1;
}
It(r0, "compatibleMessage");
function s0(n) {
  let t = n;
  return _c(n) ? t = n.constructor.name : typeof n == "function" && (t = n.name, t === "" && (t = new n().name || t)), t;
}
It(s0, "getConstructorName");
function o0(n) {
  let t = "";
  return n && n.message ? t = n.message : typeof n == "string" && (t = n), t;
}
It(o0, "getMessage");
function De(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    i[t] = e;
  else
    return i[t];
}
It(De, "flag");
function Ff(n, t) {
  var e = De(n, "negate"), i = t[0];
  return e ? !i : i;
}
It(Ff, "test");
function sn(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
It(sn, "type");
var ey = "captureStackTrace" in Error, ko, Ye = (ko = class extends Error {
  constructor(e = "Unspecified AssertionError", i, r) {
    super(e);
    et(this, "message");
    this.message = e, ey && Error.captureStackTrace(this, r || ko);
    for (const s in i)
      s in this || (this[s] = i[s]);
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, It(ko, "AssertionError"), ko);
function a0(n, t) {
  var e = De(n, "message"), i = De(n, "ssfi");
  e = e ? e + ": " : "", n = De(n, "object"), t = t.map(function(o) {
    return o.toLowerCase();
  }), t.sort();
  var r = t.map(function(o, a) {
    var l = ~["a", "e", "i", "o", "u"].indexOf(o.charAt(0)) ? "an" : "a", h = t.length > 1 && a === t.length - 1 ? "or " : "";
    return h + l + " " + o;
  }).join(", "), s = sn(n).toLowerCase();
  if (!t.some(function(o) {
    return s === o;
  }))
    throw new Ye(
      e + "object tested must be " + r + ", but " + s + " given",
      void 0,
      i
    );
}
It(a0, "expectTypes");
function Sc(n, t) {
  return t.length > 4 ? t[4] : n._obj;
}
It(Sc, "getActual");
var wp = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, ny = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, wa = "…";
function l0(n, t) {
  const e = wp[ny[t]] || wp[t] || "";
  return e ? `\x1B[${e[0]}m${String(n)}\x1B[${e[1]}m` : String(n);
}
It(l0, "colorise");
function u0({
  showHidden: n = !1,
  depth: t = 2,
  colors: e = !1,
  customInspect: i = !0,
  showProxy: r = !1,
  maxArrayLength: s = 1 / 0,
  breakLength: o = 1 / 0,
  seen: a = [],
  // eslint-disable-next-line no-shadow
  truncate: l = 1 / 0,
  stylize: h = String
} = {}, u) {
  const d = {
    showHidden: !!n,
    depth: Number(t),
    colors: !!e,
    customInspect: !!i,
    showProxy: !!r,
    maxArrayLength: Number(s),
    breakLength: Number(o),
    truncate: Number(l),
    seen: a,
    inspect: u,
    stylize: h
  };
  return d.colors && (d.stylize = l0), d;
}
It(u0, "normaliseOptions");
function c0(n) {
  return n >= "\uD800" && n <= "\uDBFF";
}
It(c0, "isHighSurrogate");
function is(n, t, e = wa) {
  n = String(n);
  const i = e.length, r = n.length;
  if (i > t && r > i)
    return e;
  if (r > t && r > i) {
    let s = t - i;
    return s > 0 && c0(n[s - 1]) && (s = s - 1), `${n.slice(0, s)}${e}`;
  }
  return n;
}
It(is, "truncate");
function Ji(n, t, e, i = ", ") {
  e = e || t.inspect;
  const r = n.length;
  if (r === 0)
    return "";
  const s = t.truncate;
  let o = "", a = "", l = "";
  for (let h = 0; h < r; h += 1) {
    const u = h + 1 === n.length, d = h + 2 === n.length;
    l = `${wa}(${n.length - h})`;
    const p = n[h];
    t.truncate = s - o.length - (u ? 0 : i.length);
    const f = a || e(p, t) + (u ? "" : i), g = o.length + f.length, b = g + l.length;
    if (u && g > s && o.length + l.length <= s || !u && !d && b > s || (a = u ? "" : e(n[h + 1], t) + (d ? "" : i), !u && d && b > s && g + a.length > s))
      break;
    if (o += f, !u && !d && g + a.length >= s) {
      l = `${wa}(${n.length - h - 1})`;
      break;
    }
    l = "";
  }
  return `${o}${l}`;
}
It(Ji, "inspectList");
function h0(n) {
  return n.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? n : JSON.stringify(n).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
It(h0, "quoteComplexKey");
function xa([n, t], e) {
  return e.truncate -= 2, typeof n == "string" ? n = h0(n) : typeof n != "number" && (n = `[${e.inspect(n, e)}]`), e.truncate -= n.length, t = e.inspect(t, e), `${n}: ${t}`;
}
It(xa, "inspectProperty");
function f0(n, t) {
  const e = Object.keys(n).slice(n.length);
  if (!n.length && !e.length)
    return "[]";
  t.truncate -= 4;
  const i = Ji(n, t);
  t.truncate -= i.length;
  let r = "";
  return e.length && (r = Ji(e.map((s) => [s, n[s]]), t, xa)), `[ ${i}${r ? `, ${r}` : ""} ]`;
}
It(f0, "inspectArray");
var iy = /* @__PURE__ */ It((n) => typeof Buffer == "function" && n instanceof Buffer ? "Buffer" : n[Symbol.toStringTag] ? n[Symbol.toStringTag] : n.constructor.name, "getArrayName");
function kr(n, t) {
  const e = iy(n);
  t.truncate -= e.length + 4;
  const i = Object.keys(n).slice(n.length);
  if (!n.length && !i.length)
    return `${e}[]`;
  let r = "";
  for (let o = 0; o < n.length; o++) {
    const a = `${t.stylize(is(n[o], t.truncate), "number")}${o === n.length - 1 ? "" : ", "}`;
    if (t.truncate -= a.length, n[o] !== n.length && t.truncate <= 3) {
      r += `${wa}(${n.length - n[o] + 1})`;
      break;
    }
    r += a;
  }
  let s = "";
  return i.length && (s = Ji(i.map((o) => [o, n[o]]), t, xa)), `${e}[ ${r}${s ? `, ${s}` : ""} ]`;
}
It(kr, "inspectTypedArray");
function d0(n, t) {
  const e = n.toJSON();
  if (e === null)
    return "Invalid Date";
  const i = e.split("T"), r = i[0];
  return t.stylize(`${r}T${is(i[1], t.truncate - r.length - 1)}`, "date");
}
It(d0, "inspectDate");
function qh(n, t) {
  const e = n[Symbol.toStringTag] || "Function", i = n.name;
  return i ? t.stylize(`[${e} ${is(i, t.truncate - 11)}]`, "special") : t.stylize(`[${e}]`, "special");
}
It(qh, "inspectFunction");
function p0([n, t], e) {
  return e.truncate -= 4, n = e.inspect(n, e), e.truncate -= n.length, t = e.inspect(t, e), `${n} => ${t}`;
}
It(p0, "inspectMapEntry");
function g0(n) {
  const t = [];
  return n.forEach((e, i) => {
    t.push([i, e]);
  }), t;
}
It(g0, "mapToEntries");
function m0(n, t) {
  return n.size - 1 <= 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Ji(g0(n), t, p0)} }`);
}
It(m0, "inspectMap");
var ry = Number.isNaN || ((n) => n !== n);
function zh(n, t) {
  return ry(n) ? t.stylize("NaN", "number") : n === 1 / 0 ? t.stylize("Infinity", "number") : n === -1 / 0 ? t.stylize("-Infinity", "number") : n === 0 ? t.stylize(1 / n === 1 / 0 ? "+0" : "-0", "number") : t.stylize(is(String(n), t.truncate), "number");
}
It(zh, "inspectNumber");
function $h(n, t) {
  let e = is(n.toString(), t.truncate - 1);
  return e !== wa && (e += "n"), t.stylize(e, "bigint");
}
It($h, "inspectBigInt");
function y0(n, t) {
  const e = n.toString().split("/")[2], i = t.truncate - (2 + e.length), r = n.source;
  return t.stylize(`/${is(r, i)}/${e}`, "regexp");
}
It(y0, "inspectRegExp");
function b0(n) {
  const t = [];
  return n.forEach((e) => {
    t.push(e);
  }), t;
}
It(b0, "arrayFromSet");
function v0(n, t) {
  return n.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Ji(b0(n), t)} }`);
}
It(v0, "inspectSet");
var xp = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), sy = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, oy = 16, ay = 4;
function w0(n) {
  return sy[n] || `\\u${`0000${n.charCodeAt(0).toString(oy)}`.slice(-ay)}`;
}
It(w0, "escape");
function Uh(n, t) {
  return xp.test(n) && (n = n.replace(xp, w0)), t.stylize(`'${is(n, t.truncate - 2)}'`, "string");
}
It(Uh, "inspectString");
function Wh(n) {
  return "description" in Symbol.prototype ? n.description ? `Symbol(${n.description})` : "Symbol()" : n.toString();
}
It(Wh, "inspectSymbol");
var x0 = /* @__PURE__ */ It(() => "Promise{…}", "getPromiseValue");
try {
  const { getPromiseDetails: n, kPending: t, kRejected: e } = process.binding("util");
  Array.isArray(n(Promise.resolve())) && (x0 = /* @__PURE__ */ It((i, r) => {
    const [s, o] = n(i);
    return s === t ? "Promise{<pending>}" : `Promise${s === e ? "!" : ""}{${r.inspect(o, r)}}`;
  }, "getPromiseValue"));
} catch {
}
var ly = x0;
function xl(n, t) {
  const e = Object.getOwnPropertyNames(n), i = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n) : [];
  if (e.length === 0 && i.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const r = Ji(e.map((a) => [a, n[a]]), t, xa), s = Ji(i.map((a) => [a, n[a]]), t, xa);
  t.seen.pop();
  let o = "";
  return r && s && (o = ", "), `{ ${r}${o}${s} }`;
}
It(xl, "inspectObject");
var mh = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function _0(n, t) {
  let e = "";
  return mh && mh in n && (e = n[mh]), e = e || n.constructor.name, (!e || e === "_class") && (e = "<Anonymous Class>"), t.truncate -= e.length, `${e}${xl(n, t)}`;
}
It(_0, "inspectClass");
function S0(n, t) {
  return n.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Ji(n, t)} ]`);
}
It(S0, "inspectArguments");
var uy = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function k0(n, t) {
  const e = Object.getOwnPropertyNames(n).filter((o) => uy.indexOf(o) === -1), i = n.name;
  t.truncate -= i.length;
  let r = "";
  if (typeof n.message == "string" ? r = is(n.message, t.truncate) : e.unshift("message"), r = r ? `: ${r}` : "", t.truncate -= r.length + 5, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const s = Ji(e.map((o) => [o, n[o]]), t, xa);
  return `${i}${r}${s ? ` { ${s} }` : ""}`;
}
It(k0, "inspectObject");
function A0([n, t], e) {
  return e.truncate -= 3, t ? `${e.stylize(String(n), "yellow")}=${e.stylize(`"${t}"`, "string")}` : `${e.stylize(String(n), "yellow")}`;
}
It(A0, "inspectAttribute");
function Qu(n, t) {
  return Ji(n, t, Mf, `
`);
}
It(Qu, "inspectHTMLCollection");
function Mf(n, t) {
  const e = n.getAttributeNames(), i = n.tagName.toLowerCase(), r = t.stylize(`<${i}`, "special"), s = t.stylize(">", "special"), o = t.stylize(`</${i}>`, "special");
  t.truncate -= i.length * 2 + 5;
  let a = "";
  e.length > 0 && (a += " ", a += Ji(e.map((u) => [u, n.getAttribute(u)]), t, A0, " ")), t.truncate -= a.length;
  const l = t.truncate;
  let h = Qu(n.children, t);
  return h && h.length > l && (h = `${wa}(${n.children.length})`), `${r}${a}${s}${h}${o}`;
}
It(Mf, "inspectHTML");
var cy = typeof Symbol == "function" && typeof Symbol.for == "function", yh = cy ? Symbol.for("chai/inspect") : "@@chai/inspect", ma = !1;
try {
  const n = ty();
  ma = n.inspect ? n.inspect.custom : !1;
} catch {
  ma = !1;
}
var _p = /* @__PURE__ */ new WeakMap(), Sp = {}, kp = {
  undefined: (n, t) => t.stylize("undefined", "undefined"),
  null: (n, t) => t.stylize("null", "null"),
  boolean: (n, t) => t.stylize(String(n), "boolean"),
  Boolean: (n, t) => t.stylize(String(n), "boolean"),
  number: zh,
  Number: zh,
  bigint: $h,
  BigInt: $h,
  string: Uh,
  String: Uh,
  function: qh,
  Function: qh,
  symbol: Wh,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: Wh,
  Array: f0,
  Date: d0,
  Map: m0,
  Set: v0,
  RegExp: y0,
  Promise: ly,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (n, t) => t.stylize("WeakSet{…}", "special"),
  WeakMap: (n, t) => t.stylize("WeakMap{…}", "special"),
  Arguments: S0,
  Int8Array: kr,
  Uint8Array: kr,
  Uint8ClampedArray: kr,
  Int16Array: kr,
  Uint16Array: kr,
  Int32Array: kr,
  Uint32Array: kr,
  Float32Array: kr,
  Float64Array: kr,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: k0,
  HTMLCollection: Qu,
  NodeList: Qu
}, hy = /* @__PURE__ */ It((n, t, e) => yh in n && typeof n[yh] == "function" ? n[yh](t) : ma && ma in n && typeof n[ma] == "function" ? n[ma](t.depth, t) : "inspect" in n && typeof n.inspect == "function" ? n.inspect(t.depth, t) : "constructor" in n && _p.has(n.constructor) ? _p.get(n.constructor)(n, t) : Sp[e] ? Sp[e](n, t) : "", "inspectCustom"), fy = Object.prototype.toString;
function tc(n, t = {}) {
  const e = u0(t, tc), { customInspect: i } = e;
  let r = n === null ? "null" : typeof n;
  if (r === "object" && (r = fy.call(n).slice(8, -1)), r in kp)
    return kp[r](n, e);
  if (i && n) {
    const o = hy(n, e, r);
    if (o)
      return typeof o == "string" ? o : tc(o, e);
  }
  const s = n ? Object.getPrototypeOf(n) : !1;
  return s === Object.prototype || s === null ? xl(n, e) : n && typeof HTMLElement == "function" && n instanceof HTMLElement ? Mf(n, e) : "constructor" in n ? n.constructor !== Object ? _0(n, e) : xl(n, e) : n === Object(n) ? xl(n, e) : e.stylize(String(n), r);
}
It(tc, "inspect");
var gi = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function He(n, t, e, i) {
  var r = {
    colors: i,
    depth: typeof e > "u" ? 2 : e,
    showHidden: t,
    truncate: gi.truncateThreshold ? gi.truncateThreshold : 1 / 0
  };
  return tc(n, r);
}
It(He, "inspect");
function yo(n) {
  var t = He(n), e = Object.prototype.toString.call(n);
  if (gi.truncateThreshold && t.length >= gi.truncateThreshold) {
    if (e === "[object Function]")
      return !n.name || n.name === "" ? "[Function]" : "[Function: " + n.name + "]";
    if (e === "[object Array]")
      return "[ Array(" + n.length + ") ]";
    if (e === "[object Object]") {
      var i = Object.keys(n), r = i.length > 2 ? i.splice(0, 2).join(", ") + ", ..." : i.join(", ");
      return "{ Object (" + r + ") }";
    } else
      return t;
  } else
    return t;
}
It(yo, "objDisplay");
function Df(n, t) {
  var e = De(n, "negate"), i = De(n, "object"), r = t[3], s = Sc(n, t), o = e ? t[2] : t[1], a = De(n, "message");
  return typeof o == "function" && (o = o()), o = o || "", o = o.replace(/#\{this\}/g, function() {
    return yo(i);
  }).replace(/#\{act\}/g, function() {
    return yo(s);
  }).replace(/#\{exp\}/g, function() {
    return yo(r);
  }), a ? a + ": " + o : o;
}
It(Df, "getMessage");
function gr(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), e = arguments.length === 3 ? e : !0;
  for (var r in i)
    (e || r !== "object" && r !== "ssfi" && r !== "lockSsfi" && r != "message") && (t.__flags[r] = i[r]);
}
It(gr, "transferFlags");
function Hh(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
It(Hh, "type");
function Rf() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
It(Rf, "FakeMap");
Rf.prototype = {
  get: /* @__PURE__ */ It(function(t) {
    return t[this._key];
  }, "get"),
  set: /* @__PURE__ */ It(function(t, e) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: e,
      configurable: !0
    });
  }, "set")
};
var N0 = typeof WeakMap == "function" ? WeakMap : Rf;
function Gh(n, t, e) {
  if (!e || No(n) || No(t))
    return null;
  var i = e.get(n);
  if (i) {
    var r = i.get(t);
    if (typeof r == "boolean")
      return r;
  }
  return null;
}
It(Gh, "memoizeCompare");
function ml(n, t, e, i) {
  if (!(!e || No(n) || No(t))) {
    var r = e.get(n);
    r ? r.set(t, i) : (r = new N0(), r.set(t, i), e.set(n, r));
  }
}
It(ml, "memoizeSet");
var C0 = Ml;
function Ml(n, t, e) {
  if (e && e.comparator)
    return Vh(n, t, e);
  var i = Bf(n, t);
  return i !== null ? i : Vh(n, t, e);
}
It(Ml, "deepEqual");
function Bf(n, t) {
  return n === t ? n !== 0 || 1 / n === 1 / t : n !== n && // eslint-disable-line no-self-compare
  t !== t ? !0 : No(n) || No(t) ? !1 : null;
}
It(Bf, "simpleEqual");
function Vh(n, t, e) {
  e = e || {}, e.memoize = e.memoize === !1 ? !1 : e.memoize || new N0();
  var i = e && e.comparator, r = Gh(n, t, e.memoize);
  if (r !== null)
    return r;
  var s = Gh(t, n, e.memoize);
  if (s !== null)
    return s;
  if (i) {
    var o = i(n, t);
    if (o === !1 || o === !0)
      return ml(n, t, e.memoize, o), o;
    var a = Bf(n, t);
    if (a !== null)
      return a;
  }
  var l = Hh(n);
  if (l !== Hh(t))
    return ml(n, t, e.memoize, !1), !1;
  ml(n, t, e.memoize, !0);
  var h = P0(n, t, l, e);
  return ml(n, t, e.memoize, h), h;
}
It(Vh, "extensiveDeepEqual");
function P0(n, t, e, i) {
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Ml(n.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return n === t;
    case "Error":
      return jf(n, t, ["name", "message", "code"], i);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Rs(n, t, i);
    case "RegExp":
      return L0(n, t);
    case "Generator":
      return I0(n, t, i);
    case "DataView":
      return Rs(new Uint8Array(n.buffer), new Uint8Array(t.buffer), i);
    case "ArrayBuffer":
      return Rs(new Uint8Array(n), new Uint8Array(t), i);
    case "Set":
      return Yh(n, t, i);
    case "Map":
      return Yh(n, t, i);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return n.equals(t);
    case "Temporal.Duration":
      return n.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return n.toString() === t.toString();
    default:
      return O0(n, t, i);
  }
}
It(P0, "extensiveDeepEqualByType");
function L0(n, t) {
  return n.toString() === t.toString();
}
It(L0, "regexpEqual");
function Yh(n, t, e) {
  try {
    if (n.size !== t.size)
      return !1;
    if (n.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var i = [], r = [];
  return n.forEach(/* @__PURE__ */ It(function(o, a) {
    i.push([o, a]);
  }, "gatherEntries")), t.forEach(/* @__PURE__ */ It(function(o, a) {
    r.push([o, a]);
  }, "gatherEntries")), Rs(i.sort(), r.sort(), e);
}
It(Yh, "entriesEqual");
function Rs(n, t, e) {
  var i = n.length;
  if (i !== t.length)
    return !1;
  if (i === 0)
    return !0;
  for (var r = -1; ++r < i; )
    if (Ml(n[r], t[r], e) === !1)
      return !1;
  return !0;
}
It(Rs, "iterableEqual");
function I0(n, t, e) {
  return Rs(ec(n), ec(t), e);
}
It(I0, "generatorEqual");
function E0(n) {
  return typeof Symbol < "u" && typeof n == "object" && typeof Symbol.iterator < "u" && typeof n[Symbol.iterator] == "function";
}
It(E0, "hasIteratorFunction");
function Kh(n) {
  if (E0(n))
    try {
      return ec(n[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
It(Kh, "getIteratorEntries");
function ec(n) {
  for (var t = n.next(), e = [t.value]; t.done === !1; )
    t = n.next(), e.push(t.value);
  return e;
}
It(ec, "getGeneratorEntries");
function Xh(n) {
  var t = [];
  for (var e in n)
    t.push(e);
  return t;
}
It(Xh, "getEnumerableKeys");
function Jh(n) {
  for (var t = [], e = Object.getOwnPropertySymbols(n), i = 0; i < e.length; i += 1) {
    var r = e[i];
    Object.getOwnPropertyDescriptor(n, r).enumerable && t.push(r);
  }
  return t;
}
It(Jh, "getEnumerableSymbols");
function jf(n, t, e, i) {
  var r = e.length;
  if (r === 0)
    return !0;
  for (var s = 0; s < r; s += 1)
    if (Ml(n[e[s]], t[e[s]], i) === !1)
      return !1;
  return !0;
}
It(jf, "keysEqual");
function O0(n, t, e) {
  var i = Xh(n), r = Xh(t), s = Jh(n), o = Jh(t);
  if (i = i.concat(s), r = r.concat(o), i.length && i.length === r.length)
    return Rs(Zh(i).sort(), Zh(r).sort()) === !1 ? !1 : jf(n, t, i, e);
  var a = Kh(n), l = Kh(t);
  return a.length && a.length === l.length ? (a.sort(), l.sort(), Rs(a, l, e)) : i.length === 0 && a.length === 0 && r.length === 0 && l.length === 0;
}
It(O0, "objectEqual");
function No(n) {
  return n === null || typeof n != "object";
}
It(No, "isPrimitive");
function Zh(n) {
  return n.map(/* @__PURE__ */ It(function(e) {
    return typeof e == "symbol" ? e.toString() : e;
  }, "mapSymbol"));
}
It(Zh, "mapSymbols");
function kc(n, t) {
  return typeof n > "u" || n === null ? !1 : t in Object(n);
}
It(kc, "hasProperty");
function T0(n) {
  return n.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((i) => {
    if (i === "constructor" || i === "__proto__" || i === "prototype")
      return {};
    const s = /^\[(\d+)\]$/.exec(i);
    let o = null;
    return s ? o = { i: parseFloat(s[1]) } : o = { p: i.replace(/\\([.[\]])/g, "$1") }, o;
  });
}
It(T0, "parsePath");
function Qh(n, t, e) {
  let i = n, r = null;
  e = typeof e > "u" ? t.length : e;
  for (let s = 0; s < e; s++) {
    const o = t[s];
    i && (typeof o.p > "u" ? i = i[o.i] : i = i[o.p], s === e - 1 && (r = i));
  }
  return r;
}
It(Qh, "internalGetPathValue");
function qf(n, t) {
  const e = T0(t), i = e[e.length - 1], r = {
    parent: e.length > 1 ? Qh(n, e, e.length - 1) : n,
    name: i.p || i.i,
    value: Qh(n, e)
  };
  return r.exists = kc(r.parent, r.name), r;
}
It(qf, "getPathInfo");
function lt(n, t, e, i) {
  return De(this, "ssfi", e || lt), De(this, "lockSsfi", i), De(this, "object", n), De(this, "message", t), De(this, "eql", gi.deepEqual || C0), Na(this);
}
It(lt, "Assertion");
Object.defineProperty(lt, "includeStack", {
  get: function() {
    return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), gi.includeStack;
  },
  set: function(n) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), gi.includeStack = n;
  }
});
Object.defineProperty(lt, "showDiff", {
  get: function() {
    return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), gi.showDiff;
  },
  set: function(n) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), gi.showDiff = n;
  }
});
lt.addProperty = function(n, t) {
  zf(this.prototype, n, t);
};
lt.addMethod = function(n, t) {
  $f(this.prototype, n, t);
};
lt.addChainableMethod = function(n, t, e) {
  Hf(this.prototype, n, t, e);
};
lt.overwriteProperty = function(n, t) {
  Uf(this.prototype, n, t);
};
lt.overwriteMethod = function(n, t) {
  Wf(this.prototype, n, t);
};
lt.overwriteChainableMethod = function(n, t, e) {
  Gf(this.prototype, n, t, e);
};
lt.prototype.assert = function(n, t, e, i, r, s) {
  var o = Ff(this, arguments);
  if (s !== !1 && (s = !0), i === void 0 && r === void 0 && (s = !1), gi.showDiff !== !0 && (s = !1), !o) {
    t = Df(this, arguments);
    var a = Sc(this, arguments), l = {
      actual: a,
      expected: i,
      showDiff: s
    }, h = Kf(this, arguments);
    throw h && (l.operator = h), new Ye(
      t,
      l,
      gi.includeStack ? this.assert : De(this, "ssfi")
    );
  }
};
Object.defineProperty(
  lt.prototype,
  "_obj",
  {
    get: function() {
      return De(this, "object");
    },
    set: function(n) {
      De(this, "object", n);
    }
  }
);
function Dl() {
  return gi.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
It(Dl, "isProxyEnabled");
function zf(n, t, e) {
  e = e === void 0 ? function() {
  } : e, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ It(function i() {
        !Dl() && !De(this, "lockSsfi") && De(this, "ssfi", i);
        var r = e.call(this);
        if (r !== void 0)
          return r;
        var s = new lt();
        return gr(this, s), s;
      }, "propertyGetter"),
      configurable: !0
    }
  );
}
It(zf, "addProperty");
var dy = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Rl(n, t, e) {
  return dy.configurable && Object.defineProperty(n, "length", {
    get: function() {
      throw Error(e ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".');
    }
  }), n;
}
It(Rl, "addLengthGuard");
function F0(n) {
  var t = Object.getOwnPropertyNames(n);
  function e(r) {
    t.indexOf(r) === -1 && t.push(r);
  }
  It(e, "addProperty");
  for (var i = Object.getPrototypeOf(n); i !== null; )
    Object.getOwnPropertyNames(i).forEach(e), i = Object.getPrototypeOf(i);
  return t;
}
It(F0, "getProperties");
var Ap = ["__flags", "__methods", "_obj", "assert"];
function Na(n, t) {
  return Dl() ? new Proxy(n, {
    get: /* @__PURE__ */ It(function e(i, r) {
      if (typeof r == "string" && gi.proxyExcludedKeys.indexOf(r) === -1 && !Reflect.has(i, r)) {
        if (t)
          throw Error("Invalid Chai property: " + t + "." + r + '. See docs for proper usage of "' + t + '".');
        var s = null, o = 4;
        throw F0(i).forEach(function(a) {
          if (!Object.prototype.hasOwnProperty(a) && Ap.indexOf(a) === -1) {
            var l = M0(
              r,
              a,
              o
            );
            l < o && (s = a, o = l);
          }
        }), Error(s !== null ? "Invalid Chai property: " + r + '. Did you mean "' + s + '"?' : "Invalid Chai property: " + r);
      }
      return Ap.indexOf(r) === -1 && !De(i, "lockSsfi") && De(i, "ssfi", e), Reflect.get(i, r);
    }, "proxyGetter")
  }) : n;
}
It(Na, "proxify");
function M0(n, t, e) {
  if (Math.abs(n.length - t.length) >= e)
    return e;
  for (var i = [], r = 0; r <= n.length; r++)
    i[r] = Array(t.length + 1).fill(0), i[r][0] = r;
  for (var s = 0; s < t.length; s++)
    i[0][s] = s;
  for (var r = 1; r <= n.length; r++)
    for (var o = n.charCodeAt(r - 1), s = 1; s <= t.length; s++) {
      if (Math.abs(r - s) >= e) {
        i[r][s] = e;
        continue;
      }
      i[r][s] = Math.min(
        i[r - 1][s] + 1,
        i[r][s - 1] + 1,
        i[r - 1][s - 1] + (o === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  return i[n.length][t.length];
}
It(M0, "stringDistanceCapped");
function $f(n, t, e) {
  var i = /* @__PURE__ */ It(function() {
    De(this, "lockSsfi") || De(this, "ssfi", i);
    var r = e.apply(this, arguments);
    if (r !== void 0)
      return r;
    var s = new lt();
    return gr(this, s), s;
  }, "methodWrapper");
  Rl(i, t, !1), n[t] = Na(i, t);
}
It($f, "addMethod");
function Uf(n, t, e) {
  var i = Object.getOwnPropertyDescriptor(n, t), r = /* @__PURE__ */ It(function() {
  }, "_super");
  i && typeof i.get == "function" && (r = i.get), Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ It(function s() {
        !Dl() && !De(this, "lockSsfi") && De(this, "ssfi", s);
        var o = De(this, "lockSsfi");
        De(this, "lockSsfi", !0);
        var a = e(r).call(this);
        if (De(this, "lockSsfi", o), a !== void 0)
          return a;
        var l = new lt();
        return gr(this, l), l;
      }, "overwritingPropertyGetter"),
      configurable: !0
    }
  );
}
It(Uf, "overwriteProperty");
function Wf(n, t, e) {
  var i = n[t], r = /* @__PURE__ */ It(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  i && typeof i == "function" && (r = i);
  var s = /* @__PURE__ */ It(function() {
    De(this, "lockSsfi") || De(this, "ssfi", s);
    var o = De(this, "lockSsfi");
    De(this, "lockSsfi", !0);
    var a = e(r).apply(this, arguments);
    if (De(this, "lockSsfi", o), a !== void 0)
      return a;
    var l = new lt();
    return gr(this, l), l;
  }, "overwritingMethodWrapper");
  Rl(s, t, !1), n[t] = Na(s, t);
}
It(Wf, "overwriteMethod");
var py = typeof Object.setPrototypeOf == "function", Np = /* @__PURE__ */ It(function() {
}, "testFn"), gy = Object.getOwnPropertyNames(Np).filter(function(n) {
  var t = Object.getOwnPropertyDescriptor(Np, n);
  return typeof t != "object" ? !0 : !t.configurable;
}), my = Function.prototype.call, yy = Function.prototype.apply;
function Hf(n, t, e, i) {
  typeof i != "function" && (i = /* @__PURE__ */ It(function() {
  }, "chainingBehavior"));
  var r = {
    method: e,
    chainingBehavior: i
  };
  n.__methods || (n.__methods = {}), n.__methods[t] = r, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ It(function() {
        r.chainingBehavior.call(this);
        var o = /* @__PURE__ */ It(function() {
          De(this, "lockSsfi") || De(this, "ssfi", o);
          var h = r.method.apply(this, arguments);
          if (h !== void 0)
            return h;
          var u = new lt();
          return gr(this, u), u;
        }, "chainableMethodWrapper");
        if (Rl(o, t, !0), py) {
          var a = Object.create(this);
          a.call = my, a.apply = yy, Object.setPrototypeOf(o, a);
        } else {
          var l = Object.getOwnPropertyNames(n);
          l.forEach(function(h) {
            if (gy.indexOf(h) === -1) {
              var u = Object.getOwnPropertyDescriptor(n, h);
              Object.defineProperty(o, h, u);
            }
          });
        }
        return gr(this, o), Na(o);
      }, "chainableMethodGetter"),
      configurable: !0
    }
  );
}
It(Hf, "addChainableMethod");
function Gf(n, t, e, i) {
  var r = n.__methods[t], s = r.chainingBehavior;
  r.chainingBehavior = /* @__PURE__ */ It(function() {
    var l = i(s).call(this);
    if (l !== void 0)
      return l;
    var h = new lt();
    return gr(this, h), h;
  }, "overwritingChainableMethodGetter");
  var o = r.method;
  r.method = /* @__PURE__ */ It(function() {
    var l = e(o).apply(this, arguments);
    if (l !== void 0)
      return l;
    var h = new lt();
    return gr(this, h), h;
  }, "overwritingChainableMethodWrapper");
}
It(Gf, "overwriteChainableMethod");
function nc(n, t) {
  return He(n) < He(t) ? -1 : 1;
}
It(nc, "compareByInspect");
function Vf(n) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(n).filter(function(t) {
    return Object.getOwnPropertyDescriptor(n, t).enumerable;
  });
}
It(Vf, "getOwnEnumerablePropertySymbols");
function Yf(n) {
  return Object.keys(n).concat(Vf(n));
}
It(Yf, "getOwnEnumerableProperties");
function D0(n) {
  return n !== n;
}
It(D0, "_isNaN");
var ic = Number.isNaN || D0;
function R0(n) {
  var t = sn(n), e = ["Array", "Object", "Function"];
  return e.indexOf(t) !== -1;
}
It(R0, "isObjectType");
function Kf(n, t) {
  var e = De(n, "operator"), i = De(n, "negate"), r = t[3], s = i ? t[2] : t[1];
  if (e)
    return e;
  if (typeof s == "function" && (s = s()), s = s || "", !!s && !/\shave\s/.test(s)) {
    var o = R0(r);
    return /\snot\s/.test(s) ? o ? "notDeepStrictEqual" : "notStrictEqual" : o ? "deepStrictEqual" : "strictEqual";
  }
}
It(Kf, "getOperator");
function Ac(n) {
  return n.name;
}
It(Ac, "getName");
function rc(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
It(rc, "isRegExp");
function Gn(n) {
  return ["Number", "BigInt"].includes(sn(n));
}
It(Gn, "isNumeric");
var { flag: kt } = Zu;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(n) {
  lt.addProperty(n);
});
lt.addProperty("not", function() {
  kt(this, "negate", !0);
});
lt.addProperty("deep", function() {
  kt(this, "deep", !0);
});
lt.addProperty("nested", function() {
  kt(this, "nested", !0);
});
lt.addProperty("own", function() {
  kt(this, "own", !0);
});
lt.addProperty("ordered", function() {
  kt(this, "ordered", !0);
});
lt.addProperty("any", function() {
  kt(this, "any", !0), kt(this, "all", !1);
});
lt.addProperty("all", function() {
  kt(this, "all", !0), kt(this, "any", !1);
});
var Cp = {
  function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function Xf(n, t) {
  t && kt(this, "message", t), n = n.toLowerCase();
  var e = kt(this, "object"), i = ~["a", "e", "i", "o", "u"].indexOf(n.charAt(0)) ? "an " : "a ";
  const r = sn(e).toLowerCase();
  Cp.function.includes(n) ? this.assert(
    Cp[n].includes(r),
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  ) : this.assert(
    n === r,
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  );
}
It(Xf, "an");
lt.addChainableMethod("an", Xf);
lt.addChainableMethod("a", Xf);
function B0(n, t) {
  return ic(n) && ic(t) || n === t;
}
It(B0, "SameValueZero");
function Bl() {
  kt(this, "contains", !0);
}
It(Bl, "includeChainingBehavior");
function jl(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = sn(e).toLowerCase(), r = kt(this, "message"), s = kt(this, "negate"), o = kt(this, "ssfi"), a = kt(this, "deep"), l = a ? "deep " : "", h = a ? kt(this, "eql") : B0;
  r = r ? r + ": " : "";
  var u = !1;
  switch (i) {
    case "string":
      u = e.indexOf(n) !== -1;
      break;
    case "weakset":
      if (a)
        throw new Ye(
          r + "unable to use .deep.include with WeakSet",
          void 0,
          o
        );
      u = e.has(n);
      break;
    case "map":
      e.forEach(function(g) {
        u = u || h(g, n);
      });
      break;
    case "set":
      a ? e.forEach(function(g) {
        u = u || h(g, n);
      }) : u = e.has(n);
      break;
    case "array":
      a ? u = e.some(function(g) {
        return h(g, n);
      }) : u = e.indexOf(n) !== -1;
      break;
    default:
      if (n !== Object(n))
        throw new Ye(
          r + "the given combination of arguments (" + i + " and " + sn(n).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + sn(n).toLowerCase(),
          void 0,
          o
        );
      var d = Object.keys(n), p = null, f = 0;
      if (d.forEach(function(g) {
        var b = new lt(e);
        if (gr(this, b, !0), kt(b, "lockSsfi", !0), !s || d.length === 1) {
          b.property(g, n[g]);
          return;
        }
        try {
          b.property(g, n[g]);
        } catch (x) {
          if (!Mi.compatibleConstructor(x, Ye))
            throw x;
          p === null && (p = x), f++;
        }
      }, this), s && d.length > 1 && f === d.length)
        throw p;
      return;
  }
  this.assert(
    u,
    "expected #{this} to " + l + "include " + He(n),
    "expected #{this} to not " + l + "include " + He(n)
  );
}
It(jl, "include");
lt.addChainableMethod("include", jl, Bl);
lt.addChainableMethod("contain", jl, Bl);
lt.addChainableMethod("contains", jl, Bl);
lt.addChainableMethod("includes", jl, Bl);
lt.addProperty("ok", function() {
  this.assert(
    kt(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
lt.addProperty("true", function() {
  this.assert(
    kt(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !kt(this, "negate")
  );
});
lt.addProperty("numeric", function() {
  const n = kt(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(sn(n)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !kt(this, "negate")
  );
});
lt.addProperty("callable", function() {
  const n = kt(this, "object"), t = kt(this, "ssfi"), e = kt(this, "message"), i = e ? `${e}: ` : "", r = kt(this, "negate"), s = r ? `${i}expected ${He(n)} not to be a callable function` : `${i}expected ${He(n)} to be a callable function`, o = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(sn(n));
  if (o && r || !o && !r)
    throw new Ye(
      s,
      void 0,
      t
    );
});
lt.addProperty("false", function() {
  this.assert(
    kt(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!kt(this, "negate")
  );
});
lt.addProperty("null", function() {
  this.assert(
    kt(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
lt.addProperty("undefined", function() {
  this.assert(
    kt(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
lt.addProperty("NaN", function() {
  this.assert(
    ic(kt(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function Jf() {
  var n = kt(this, "object");
  this.assert(
    n != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
It(Jf, "assertExist");
lt.addProperty("exist", Jf);
lt.addProperty("exists", Jf);
lt.addProperty("empty", function() {
  var n = kt(this, "object"), t = kt(this, "ssfi"), e = kt(this, "message"), i;
  switch (e = e ? e + ": " : "", sn(n).toLowerCase()) {
    case "array":
    case "string":
      i = n.length;
      break;
    case "map":
    case "set":
      i = n.size;
      break;
    case "weakmap":
    case "weakset":
      throw new Ye(
        e + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function":
      var r = e + ".empty was passed a function " + Ac(n);
      throw new Ye(r.trim(), void 0, t);
    default:
      if (n !== Object(n))
        throw new Ye(
          e + ".empty was passed non-string primitive " + He(n),
          void 0,
          t
        );
      i = Object.keys(n).length;
  }
  this.assert(
    i === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function Zf() {
  var n = kt(this, "object"), t = sn(n);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
It(Zf, "checkArguments");
lt.addProperty("arguments", Zf);
lt.addProperty("Arguments", Zf);
function Nc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object");
  if (kt(this, "deep")) {
    var i = kt(this, "lockSsfi");
    kt(this, "lockSsfi", !0), this.eql(n), kt(this, "lockSsfi", i);
  } else
    this.assert(
      n === e,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      n,
      this._obj,
      !0
    );
}
It(Nc, "assertEqual");
lt.addMethod("equal", Nc);
lt.addMethod("equals", Nc);
lt.addMethod("eq", Nc);
function Qf(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "eql");
  this.assert(
    e(n, kt(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    n,
    this._obj,
    !0
  );
}
It(Qf, "assertEql");
lt.addMethod("eql", Qf);
lt.addMethod("eqls", Qf);
function Cc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase();
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    throw new Ye(s + "the argument to above must be a date", void 0, o);
  if (!Gn(n) && (i || Gn(e)))
    throw new Ye(s + "the argument to above must be a number", void 0, o);
  if (!i && a !== "date" && !Gn(e)) {
    var h = a === "string" ? "'" + e + "'" : e;
    throw new Ye(s + "expected " + h + " to be a number or a date", void 0, o);
  }
  if (i) {
    var u = "length", d;
    a === "map" || a === "set" ? (u = "size", d = e.size) : d = e.length, this.assert(
      d > n,
      "expected #{this} to have a " + u + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + u + " above #{exp}",
      n,
      d
    );
  } else
    this.assert(
      e > n,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n
    );
}
It(Cc, "assertAbove");
lt.addMethod("above", Cc);
lt.addMethod("gt", Cc);
lt.addMethod("greaterThan", Cc);
function Pc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to least must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to least must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f >= n,
      "expected #{this} to have a " + p + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e >= n,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n
    );
}
It(Pc, "assertLeast");
lt.addMethod("least", Pc);
lt.addMethod("gte", Pc);
lt.addMethod("greaterThanOrEqual", Pc);
function Lc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to below must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to below must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f < n,
      "expected #{this} to have a " + p + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e < n,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n
    );
}
It(Lc, "assertBelow");
lt.addMethod("below", Lc);
lt.addMethod("lt", Lc);
lt.addMethod("lessThan", Lc);
function Ic(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to most must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to most must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f <= n,
      "expected #{this} to have a " + p + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + p + " above #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e <= n,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n
    );
}
It(Ic, "assertMost");
lt.addMethod("most", Ic);
lt.addMethod("lte", Ic);
lt.addMethod("lessThanOrEqual", Ic);
lt.addMethod("within", function(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "doLength"), s = kt(this, "message"), o = s ? s + ": " : "", a = kt(this, "ssfi"), l = sn(i).toLowerCase(), h = sn(n).toLowerCase(), u = sn(t).toLowerCase(), d, p = !0, f = h === "date" && u === "date" ? n.toISOString() + ".." + t.toISOString() : n + ".." + t;
  if (r && l !== "map" && l !== "set" && new lt(i, s, a, !0).to.have.property("length"), !r && l === "date" && (h !== "date" || u !== "date"))
    d = o + "the arguments to within must be dates";
  else if ((!Gn(n) || !Gn(t)) && (r || Gn(i)))
    d = o + "the arguments to within must be numbers";
  else if (!r && l !== "date" && !Gn(i)) {
    var g = l === "string" ? "'" + i + "'" : i;
    d = o + "expected " + g + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Ye(d, void 0, a);
  if (r) {
    var b = "length", x;
    l === "map" || l === "set" ? (b = "size", x = i.size) : x = i.length, this.assert(
      x >= n && x <= t,
      "expected #{this} to have a " + b + " within " + f,
      "expected #{this} to not have a " + b + " within " + f
    );
  } else
    this.assert(
      i >= n && i <= t,
      "expected #{this} to be within " + f,
      "expected #{this} to not be within " + f
    );
});
function td(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "ssfi"), r = kt(this, "message");
  try {
    var s = e instanceof n;
  } catch (a) {
    throw a instanceof TypeError ? (r = r ? r + ": " : "", new Ye(
      r + "The instanceof assertion needs a constructor but " + sn(n) + " was given.",
      void 0,
      i
    )) : a;
  }
  var o = Ac(n);
  o == null && (o = "an unnamed constructor"), this.assert(
    s,
    "expected #{this} to be an instance of " + o,
    "expected #{this} to not be an instance of " + o
  );
}
It(td, "assertInstanceOf");
lt.addMethod("instanceof", td);
lt.addMethod("instanceOf", td);
function ed(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "nested"), r = kt(this, "own"), s = kt(this, "message"), o = kt(this, "object"), a = kt(this, "ssfi"), l = typeof n;
  if (s = s ? s + ": " : "", i) {
    if (l !== "string")
      throw new Ye(
        s + "the argument to property must be a string when using nested syntax",
        void 0,
        a
      );
  } else if (l !== "string" && l !== "number" && l !== "symbol")
    throw new Ye(
      s + "the argument to property must be a string, number, or symbol",
      void 0,
      a
    );
  if (i && r)
    throw new Ye(
      s + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      a
    );
  if (o == null)
    throw new Ye(
      s + "Target cannot be null or undefined.",
      void 0,
      a
    );
  var h = kt(this, "deep"), u = kt(this, "negate"), d = i ? qf(o, n) : null, p = i ? d.value : o[n], f = h ? kt(this, "eql") : (x, y) => x === y, g = "";
  h && (g += "deep "), r && (g += "own "), i && (g += "nested "), g += "property ";
  var b;
  r ? b = Object.prototype.hasOwnProperty.call(o, n) : i ? b = d.exists : b = kc(o, n), (!u || arguments.length === 1) && this.assert(
    b,
    "expected #{this} to have " + g + He(n),
    "expected #{this} to not have " + g + He(n)
  ), arguments.length > 1 && this.assert(
    b && f(t, p),
    "expected #{this} to have " + g + He(n) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + g + He(n) + " of #{act}",
    t,
    p
  ), kt(this, "object", p);
}
It(ed, "assertProperty");
lt.addMethod("property", ed);
function nd(n, t, e) {
  kt(this, "own", !0), ed.apply(this, arguments);
}
It(nd, "assertOwnProperty");
lt.addMethod("ownProperty", nd);
lt.addMethod("haveOwnProperty", nd);
function id(n, t, e) {
  typeof t == "string" && (e = t, t = null), e && kt(this, "message", e);
  var i = kt(this, "object"), r = Object.getOwnPropertyDescriptor(Object(i), n), s = kt(this, "eql");
  r && t ? this.assert(
    s(t, r),
    "expected the own property descriptor for " + He(n) + " on #{this} to match " + He(t) + ", got " + He(r),
    "expected the own property descriptor for " + He(n) + " on #{this} to not match " + He(t),
    t,
    r,
    !0
  ) : this.assert(
    r,
    "expected #{this} to have an own property descriptor for " + He(n),
    "expected #{this} to not have an own property descriptor for " + He(n)
  ), kt(this, "object", r);
}
It(id, "assertOwnPropertyDescriptor");
lt.addMethod("ownPropertyDescriptor", id);
lt.addMethod("haveOwnPropertyDescriptor", id);
function rd() {
  kt(this, "doLength", !0);
}
It(rd, "assertLengthChain");
function sd(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = sn(e).toLowerCase(), r = kt(this, "message"), s = kt(this, "ssfi"), o = "length", a;
  switch (i) {
    case "map":
    case "set":
      o = "size", a = e.size;
      break;
    default:
      new lt(e, r, s, !0).to.have.property("length"), a = e.length;
  }
  this.assert(
    a == n,
    "expected #{this} to have a " + o + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + o + " of #{act}",
    n,
    a
  );
}
It(sd, "assertLength");
lt.addChainableMethod("length", sd, rd);
lt.addChainableMethod("lengthOf", sd, rd);
function od(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object");
  this.assert(
    n.exec(e),
    "expected #{this} to match " + n,
    "expected #{this} not to match " + n
  );
}
It(od, "assertMatch");
lt.addMethod("match", od);
lt.addMethod("matches", od);
lt.addMethod("string", function(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "message"), r = kt(this, "ssfi");
  new lt(e, i, r, !0).is.a("string"), this.assert(
    ~e.indexOf(n),
    "expected #{this} to contain " + He(n),
    "expected #{this} to not contain " + He(n)
  );
});
function ad(n) {
  var t = kt(this, "object"), e = sn(t), i = sn(n), r = kt(this, "ssfi"), s = kt(this, "deep"), o, a = "", l, h = !0, u = kt(this, "message");
  u = u ? u + ": " : "";
  var d = u + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (e === "Map" || e === "Set")
    a = s ? "deeply " : "", l = [], t.forEach(function(v, k) {
      l.push(k);
    }), i !== "Array" && (n = Array.prototype.slice.call(arguments));
  else {
    switch (l = Yf(t), i) {
      case "Array":
        if (arguments.length > 1)
          throw new Ye(d, void 0, r);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new Ye(d, void 0, r);
        n = Object.keys(n);
        break;
      default:
        n = Array.prototype.slice.call(arguments);
    }
    n = n.map(function(v) {
      return typeof v == "symbol" ? v : String(v);
    });
  }
  if (!n.length)
    throw new Ye(u + "keys required", void 0, r);
  var p = n.length, f = kt(this, "any"), g = kt(this, "all"), b = n, x = s ? kt(this, "eql") : (v, k) => v === k;
  if (!f && !g && (g = !0), f && (h = b.some(function(v) {
    return l.some(function(k) {
      return x(v, k);
    });
  })), g && (h = b.every(function(v) {
    return l.some(function(k) {
      return x(v, k);
    });
  }), kt(this, "contains") || (h = h && n.length == l.length)), p > 1) {
    n = n.map(function(v) {
      return He(v);
    });
    var y = n.pop();
    g && (o = n.join(", ") + ", and " + y), f && (o = n.join(", ") + ", or " + y);
  } else
    o = He(n[0]);
  o = (p > 1 ? "keys " : "key ") + o, o = (kt(this, "contains") ? "contain " : "have ") + o, this.assert(
    h,
    "expected #{this} to " + a + o,
    "expected #{this} to not " + a + o,
    b.slice(0).sort(nc),
    l.sort(nc),
    !0
  );
}
It(ad, "assertKeys");
lt.addMethod("keys", ad);
lt.addMethod("key", ad);
function Ec(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "ssfi"), s = kt(this, "message"), o = kt(this, "negate") || !1;
  new lt(i, s, r, !0).is.a("function"), (rc(n) || typeof n == "string") && (t = n, n = null);
  let a, l = !1;
  try {
    i();
  } catch (v) {
    l = !0, a = v;
  }
  var h = n === void 0 && t === void 0, u = !!(n && t), d = !1, p = !1;
  if (h || !h && !o) {
    var f = "an error";
    n instanceof Error ? f = "#{exp}" : n && (f = Mi.getConstructorName(n));
    let v = a;
    if (a instanceof Error)
      v = a.toString();
    else if (typeof a == "string")
      v = a;
    else if (a && (typeof a == "object" || typeof a == "function"))
      try {
        v = Mi.getConstructorName(a);
      } catch {
      }
    this.assert(
      l,
      "expected #{this} to throw " + f,
      "expected #{this} to not throw an error but #{act} was thrown",
      n && n.toString(),
      v
    );
  }
  if (n && a) {
    if (n instanceof Error) {
      var g = Mi.compatibleInstance(a, n);
      g === o && (u && o ? d = !0 : this.assert(
        o,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (a && !o ? " but #{act} was thrown" : ""),
        n.toString(),
        a.toString()
      ));
    }
    var b = Mi.compatibleConstructor(a, n);
    b === o && (u && o ? d = !0 : this.assert(
      o,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
      n instanceof Error ? n.toString() : n && Mi.getConstructorName(n),
      a instanceof Error ? a.toString() : a && Mi.getConstructorName(a)
    ));
  }
  if (a && t !== void 0 && t !== null) {
    var x = "including";
    rc(t) && (x = "matching");
    var y = Mi.compatibleMessage(a, t);
    y === o && (u && o ? p = !0 : this.assert(
      o,
      "expected #{this} to throw error " + x + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + x + " #{exp}",
      t,
      Mi.getMessage(a)
    ));
  }
  d && p && this.assert(
    o,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
    n instanceof Error ? n.toString() : n && Mi.getConstructorName(n),
    a instanceof Error ? a.toString() : a && Mi.getConstructorName(a)
  ), kt(this, "object", a);
}
It(Ec, "assertThrows");
lt.addMethod("throw", Ec);
lt.addMethod("throws", Ec);
lt.addMethod("Throw", Ec);
function ld(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "itself"), r = typeof e == "function" && !i ? e.prototype[n] : e[n];
  this.assert(
    typeof r == "function",
    "expected #{this} to respond to " + He(n),
    "expected #{this} to not respond to " + He(n)
  );
}
It(ld, "respondTo");
lt.addMethod("respondTo", ld);
lt.addMethod("respondsTo", ld);
lt.addProperty("itself", function() {
  kt(this, "itself", !0);
});
function ud(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = n(e);
  this.assert(
    i,
    "expected #{this} to satisfy " + yo(n),
    "expected #{this} to not satisfy" + yo(n),
    !kt(this, "negate"),
    i
  );
}
It(ud, "satisfy");
lt.addMethod("satisfy", ud);
lt.addMethod("satisfies", ud);
function cd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.numeric;
  let o = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new Ye(r ? `${r}: ${o}` : o, void 0, s);
  if (new lt(t, r, s, !0).is.numeric, o = "A `expected` value is required for `closeTo`", n == null)
    throw new Ye(r ? `${r}: ${o}` : o, void 0, s);
  new lt(n, r, s, !0).is.numeric;
  const a = /* @__PURE__ */ It((l) => l < 0n ? -l : l, "abs");
  this.assert(
    a(i - n) <= t,
    "expected #{this} to be close to " + n + " +/- " + t,
    "expected #{this} not to be close to " + n + " +/- " + t
  );
}
It(cd, "closeTo");
lt.addMethod("closeTo", cd);
lt.addMethod("approximately", cd);
function j0(n, t, e, i, r) {
  let s = Array.from(t), o = Array.from(n);
  if (!i) {
    if (o.length !== s.length)
      return !1;
    s = s.slice();
  }
  return o.every(function(a, l) {
    if (r)
      return e ? e(a, s[l]) : a === s[l];
    if (!e) {
      var h = s.indexOf(a);
      return h === -1 ? !1 : (i || s.splice(h, 1), !0);
    }
    return s.some(function(u, d) {
      return e(a, u) ? (i || s.splice(d, 1), !0) : !1;
    });
  });
}
It(j0, "isSubsetOf");
lt.addMethod("members", function(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "message"), r = kt(this, "ssfi");
  new lt(e, i, r, !0).to.be.iterable, new lt(n, i, r, !0).to.be.iterable;
  var s = kt(this, "contains"), o = kt(this, "ordered"), a, l, h;
  s ? (a = o ? "an ordered superset" : "a superset", l = "expected #{this} to be " + a + " of #{exp}", h = "expected #{this} to not be " + a + " of #{exp}") : (a = o ? "ordered members" : "members", l = "expected #{this} to have the same " + a + " as #{exp}", h = "expected #{this} to not have the same " + a + " as #{exp}");
  var u = kt(this, "deep") ? kt(this, "eql") : void 0;
  this.assert(
    j0(n, e, u, s, o),
    l,
    h,
    n,
    e,
    !0
  );
});
lt.addProperty("iterable", function(n) {
  n && kt(this, "message", n);
  var t = kt(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function q0(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "message"), r = kt(this, "ssfi"), s = kt(this, "contains"), o = kt(this, "deep"), a = kt(this, "eql");
  new lt(n, i, r, !0).to.be.an("array"), s ? this.assert(
    n.some(function(l) {
      return e.indexOf(l) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    n,
    e
  ) : o ? this.assert(
    n.some(function(l) {
      return a(e, l);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    n,
    e
  ) : this.assert(
    n.indexOf(e) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    n,
    e
  );
}
It(q0, "oneOf");
lt.addMethod("oneOf", q0);
function hd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  kt(this, "deltaMsgObj", l), kt(this, "initialDeltaValue", o), kt(this, "finalDeltaValue", a), kt(this, "deltaBehavior", "change"), kt(this, "realDelta", a !== o), this.assert(
    o !== a,
    "expected " + l + " to change",
    "expected " + l + " to not change"
  );
}
It(hd, "assertChanges");
lt.addMethod("change", hd);
lt.addMethod("changes", hd);
function fd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), new lt(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  kt(this, "deltaMsgObj", l), kt(this, "initialDeltaValue", o), kt(this, "finalDeltaValue", a), kt(this, "deltaBehavior", "increase"), kt(this, "realDelta", a - o), this.assert(
    a - o > 0,
    "expected " + l + " to increase",
    "expected " + l + " to not increase"
  );
}
It(fd, "assertIncreases");
lt.addMethod("increase", fd);
lt.addMethod("increases", fd);
function dd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), new lt(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  kt(this, "deltaMsgObj", l), kt(this, "initialDeltaValue", o), kt(this, "finalDeltaValue", a), kt(this, "deltaBehavior", "decrease"), kt(this, "realDelta", o - a), this.assert(
    a - o < 0,
    "expected " + l + " to decrease",
    "expected " + l + " to not decrease"
  );
}
It(dd, "assertDecreases");
lt.addMethod("decrease", dd);
lt.addMethod("decreases", dd);
function z0(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "deltaMsgObj"), i = kt(this, "initialDeltaValue"), r = kt(this, "finalDeltaValue"), s = kt(this, "deltaBehavior"), o = kt(this, "realDelta"), a;
  s === "change" ? a = Math.abs(r - i) === Math.abs(n) : a = o === Math.abs(n), this.assert(
    a,
    "expected " + e + " to " + s + " by " + n,
    "expected " + e + " to not " + s + " by " + n
  );
}
It(z0, "assertDelta");
lt.addMethod("by", z0);
lt.addProperty("extensible", function() {
  var n = kt(this, "object"), t = n === Object(n) && Object.isExtensible(n);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
lt.addProperty("sealed", function() {
  var n = kt(this, "object"), t = n === Object(n) ? Object.isSealed(n) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
lt.addProperty("frozen", function() {
  var n = kt(this, "object"), t = n === Object(n) ? Object.isFrozen(n) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
lt.addProperty("finite", function(n) {
  var t = kt(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Bs(n, t) {
  return new lt(n, t);
}
It(Bs, "expect");
Bs.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "expect.fail()", new Ye(e, {
    actual: n,
    expected: t,
    operator: i
  }, Bs.fail);
};
var $0 = {};
Tf($0, {
  Should: () => vy,
  should: () => by
});
function pd() {
  function n() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new lt(this.valueOf(), null, n) : new lt(this, null, n);
  }
  It(n, "shouldGetter");
  function t(i) {
    Object.defineProperty(this, "should", {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  It(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: n,
    configurable: !0
  });
  var e = {};
  return e.fail = function(i, r, s, o) {
    throw arguments.length < 2 && (s = i, i = void 0), s = s || "should.fail()", new Ye(s, {
      actual: i,
      expected: r,
      operator: o
    }, e.fail);
  }, e.equal = function(i, r, s) {
    new lt(i, s).to.equal(r);
  }, e.Throw = function(i, r, s, o) {
    new lt(i, o).to.Throw(r, s);
  }, e.exist = function(i, r) {
    new lt(i, r).to.exist;
  }, e.not = {}, e.not.equal = function(i, r, s) {
    new lt(i, s).to.not.equal(r);
  }, e.not.Throw = function(i, r, s, o) {
    new lt(i, o).to.not.Throw(r, s);
  }, e.not.exist = function(i, r) {
    new lt(i, r).to.not.exist;
  }, e.throw = e.Throw, e.not.throw = e.not.Throw, e;
}
It(pd, "loadShould");
var by = pd, vy = pd;
function at(n, t) {
  var e = new lt(null, null, at, !0);
  e.assert(
    n,
    t,
    "[ negation message unavailable ]"
  );
}
It(at, "assert");
at.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "assert.fail()", new Ye(e, {
    actual: n,
    expected: t,
    operator: i
  }, at.fail);
};
at.isOk = function(n, t) {
  new lt(n, t, at.isOk, !0).is.ok;
};
at.isNotOk = function(n, t) {
  new lt(n, t, at.isNotOk, !0).is.not.ok;
};
at.equal = function(n, t, e) {
  var i = new lt(n, e, at.equal, !0);
  i.assert(
    t == De(i, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    n,
    !0
  );
};
at.notEqual = function(n, t, e) {
  var i = new lt(n, e, at.notEqual, !0);
  i.assert(
    t != De(i, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    n,
    !0
  );
};
at.strictEqual = function(n, t, e) {
  new lt(n, e, at.strictEqual, !0).to.equal(t);
};
at.notStrictEqual = function(n, t, e) {
  new lt(n, e, at.notStrictEqual, !0).to.not.equal(t);
};
at.deepEqual = at.deepStrictEqual = function(n, t, e) {
  new lt(n, e, at.deepEqual, !0).to.eql(t);
};
at.notDeepEqual = function(n, t, e) {
  new lt(n, e, at.notDeepEqual, !0).to.not.eql(t);
};
at.isAbove = function(n, t, e) {
  new lt(n, e, at.isAbove, !0).to.be.above(t);
};
at.isAtLeast = function(n, t, e) {
  new lt(n, e, at.isAtLeast, !0).to.be.least(t);
};
at.isBelow = function(n, t, e) {
  new lt(n, e, at.isBelow, !0).to.be.below(t);
};
at.isAtMost = function(n, t, e) {
  new lt(n, e, at.isAtMost, !0).to.be.most(t);
};
at.isTrue = function(n, t) {
  new lt(n, t, at.isTrue, !0).is.true;
};
at.isNotTrue = function(n, t) {
  new lt(n, t, at.isNotTrue, !0).to.not.equal(!0);
};
at.isFalse = function(n, t) {
  new lt(n, t, at.isFalse, !0).is.false;
};
at.isNotFalse = function(n, t) {
  new lt(n, t, at.isNotFalse, !0).to.not.equal(!1);
};
at.isNull = function(n, t) {
  new lt(n, t, at.isNull, !0).to.equal(null);
};
at.isNotNull = function(n, t) {
  new lt(n, t, at.isNotNull, !0).to.not.equal(null);
};
at.isNaN = function(n, t) {
  new lt(n, t, at.isNaN, !0).to.be.NaN;
};
at.isNotNaN = function(n, t) {
  new lt(n, t, at.isNotNaN, !0).not.to.be.NaN;
};
at.exists = function(n, t) {
  new lt(n, t, at.exists, !0).to.exist;
};
at.notExists = function(n, t) {
  new lt(n, t, at.notExists, !0).to.not.exist;
};
at.isUndefined = function(n, t) {
  new lt(n, t, at.isUndefined, !0).to.equal(void 0);
};
at.isDefined = function(n, t) {
  new lt(n, t, at.isDefined, !0).to.not.equal(void 0);
};
at.isCallable = function(n, t) {
  new lt(n, t, at.isCallable, !0).is.callable;
};
at.isNotCallable = function(n, t) {
  new lt(n, t, at.isNotCallable, !0).is.not.callable;
};
at.isObject = function(n, t) {
  new lt(n, t, at.isObject, !0).to.be.a("object");
};
at.isNotObject = function(n, t) {
  new lt(n, t, at.isNotObject, !0).to.not.be.a("object");
};
at.isArray = function(n, t) {
  new lt(n, t, at.isArray, !0).to.be.an("array");
};
at.isNotArray = function(n, t) {
  new lt(n, t, at.isNotArray, !0).to.not.be.an("array");
};
at.isString = function(n, t) {
  new lt(n, t, at.isString, !0).to.be.a("string");
};
at.isNotString = function(n, t) {
  new lt(n, t, at.isNotString, !0).to.not.be.a("string");
};
at.isNumber = function(n, t) {
  new lt(n, t, at.isNumber, !0).to.be.a("number");
};
at.isNotNumber = function(n, t) {
  new lt(n, t, at.isNotNumber, !0).to.not.be.a("number");
};
at.isNumeric = function(n, t) {
  new lt(n, t, at.isNumeric, !0).is.numeric;
};
at.isNotNumeric = function(n, t) {
  new lt(n, t, at.isNotNumeric, !0).is.not.numeric;
};
at.isFinite = function(n, t) {
  new lt(n, t, at.isFinite, !0).to.be.finite;
};
at.isBoolean = function(n, t) {
  new lt(n, t, at.isBoolean, !0).to.be.a("boolean");
};
at.isNotBoolean = function(n, t) {
  new lt(n, t, at.isNotBoolean, !0).to.not.be.a("boolean");
};
at.typeOf = function(n, t, e) {
  new lt(n, e, at.typeOf, !0).to.be.a(t);
};
at.notTypeOf = function(n, t, e) {
  new lt(n, e, at.notTypeOf, !0).to.not.be.a(t);
};
at.instanceOf = function(n, t, e) {
  new lt(n, e, at.instanceOf, !0).to.be.instanceOf(t);
};
at.notInstanceOf = function(n, t, e) {
  new lt(n, e, at.notInstanceOf, !0).to.not.be.instanceOf(t);
};
at.include = function(n, t, e) {
  new lt(n, e, at.include, !0).include(t);
};
at.notInclude = function(n, t, e) {
  new lt(n, e, at.notInclude, !0).not.include(t);
};
at.deepInclude = function(n, t, e) {
  new lt(n, e, at.deepInclude, !0).deep.include(t);
};
at.notDeepInclude = function(n, t, e) {
  new lt(n, e, at.notDeepInclude, !0).not.deep.include(t);
};
at.nestedInclude = function(n, t, e) {
  new lt(n, e, at.nestedInclude, !0).nested.include(t);
};
at.notNestedInclude = function(n, t, e) {
  new lt(n, e, at.notNestedInclude, !0).not.nested.include(t);
};
at.deepNestedInclude = function(n, t, e) {
  new lt(n, e, at.deepNestedInclude, !0).deep.nested.include(t);
};
at.notDeepNestedInclude = function(n, t, e) {
  new lt(n, e, at.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
at.ownInclude = function(n, t, e) {
  new lt(n, e, at.ownInclude, !0).own.include(t);
};
at.notOwnInclude = function(n, t, e) {
  new lt(n, e, at.notOwnInclude, !0).not.own.include(t);
};
at.deepOwnInclude = function(n, t, e) {
  new lt(n, e, at.deepOwnInclude, !0).deep.own.include(t);
};
at.notDeepOwnInclude = function(n, t, e) {
  new lt(n, e, at.notDeepOwnInclude, !0).not.deep.own.include(t);
};
at.match = function(n, t, e) {
  new lt(n, e, at.match, !0).to.match(t);
};
at.notMatch = function(n, t, e) {
  new lt(n, e, at.notMatch, !0).to.not.match(t);
};
at.property = function(n, t, e) {
  new lt(n, e, at.property, !0).to.have.property(t);
};
at.notProperty = function(n, t, e) {
  new lt(n, e, at.notProperty, !0).to.not.have.property(t);
};
at.propertyVal = function(n, t, e, i) {
  new lt(n, i, at.propertyVal, !0).to.have.property(t, e);
};
at.notPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notPropertyVal, !0).to.not.have.property(t, e);
};
at.deepPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.deepPropertyVal, !0).to.have.deep.property(t, e);
};
at.notDeepPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notDeepPropertyVal, !0).to.not.have.deep.property(t, e);
};
at.ownProperty = function(n, t, e) {
  new lt(n, e, at.ownProperty, !0).to.have.own.property(t);
};
at.notOwnProperty = function(n, t, e) {
  new lt(n, e, at.notOwnProperty, !0).to.not.have.own.property(t);
};
at.ownPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.ownPropertyVal, !0).to.have.own.property(t, e);
};
at.notOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notOwnPropertyVal, !0).to.not.have.own.property(t, e);
};
at.deepOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.deepOwnPropertyVal, !0).to.have.deep.own.property(t, e);
};
at.notDeepOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, e);
};
at.nestedProperty = function(n, t, e) {
  new lt(n, e, at.nestedProperty, !0).to.have.nested.property(t);
};
at.notNestedProperty = function(n, t, e) {
  new lt(n, e, at.notNestedProperty, !0).to.not.have.nested.property(t);
};
at.nestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.nestedPropertyVal, !0).to.have.nested.property(t, e);
};
at.notNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notNestedPropertyVal, !0).to.not.have.nested.property(t, e);
};
at.deepNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, e);
};
at.notDeepNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, e);
};
at.lengthOf = function(n, t, e) {
  new lt(n, e, at.lengthOf, !0).to.have.lengthOf(t);
};
at.hasAnyKeys = function(n, t, e) {
  new lt(n, e, at.hasAnyKeys, !0).to.have.any.keys(t);
};
at.hasAllKeys = function(n, t, e) {
  new lt(n, e, at.hasAllKeys, !0).to.have.all.keys(t);
};
at.containsAllKeys = function(n, t, e) {
  new lt(n, e, at.containsAllKeys, !0).to.contain.all.keys(t);
};
at.doesNotHaveAnyKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
at.doesNotHaveAllKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
at.hasAnyDeepKeys = function(n, t, e) {
  new lt(n, e, at.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
at.hasAllDeepKeys = function(n, t, e) {
  new lt(n, e, at.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
at.containsAllDeepKeys = function(n, t, e) {
  new lt(n, e, at.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
at.doesNotHaveAnyDeepKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
at.doesNotHaveAllDeepKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
at.throws = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null);
  var r = new lt(n, i, at.throws, !0).to.throw(t, e);
  return De(r, "object");
};
at.doesNotThrow = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null), new lt(n, i, at.doesNotThrow, !0).to.not.throw(t, e);
};
at.operator = function(n, t, e, i) {
  var r;
  switch (t) {
    case "==":
      r = n == e;
      break;
    case "===":
      r = n === e;
      break;
    case ">":
      r = n > e;
      break;
    case ">=":
      r = n >= e;
      break;
    case "<":
      r = n < e;
      break;
    case "<=":
      r = n <= e;
      break;
    case "!=":
      r = n != e;
      break;
    case "!==":
      r = n !== e;
      break;
    default:
      throw i = i && i + ": ", new Ye(
        i + 'Invalid operator "' + t + '"',
        void 0,
        at.operator
      );
  }
  var s = new lt(r, i, at.operator, !0);
  s.assert(
    De(s, "object") === !0,
    "expected " + He(n) + " to be " + t + " " + He(e),
    "expected " + He(n) + " to not be " + t + " " + He(e)
  );
};
at.closeTo = function(n, t, e, i) {
  new lt(n, i, at.closeTo, !0).to.be.closeTo(t, e);
};
at.approximately = function(n, t, e, i) {
  new lt(n, i, at.approximately, !0).to.be.approximately(t, e);
};
at.sameMembers = function(n, t, e) {
  new lt(n, e, at.sameMembers, !0).to.have.same.members(t);
};
at.notSameMembers = function(n, t, e) {
  new lt(n, e, at.notSameMembers, !0).to.not.have.same.members(t);
};
at.sameDeepMembers = function(n, t, e) {
  new lt(n, e, at.sameDeepMembers, !0).to.have.same.deep.members(t);
};
at.notSameDeepMembers = function(n, t, e) {
  new lt(n, e, at.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
at.sameOrderedMembers = function(n, t, e) {
  new lt(n, e, at.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
at.notSameOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
at.sameDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
at.notSameDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
at.includeMembers = function(n, t, e) {
  new lt(n, e, at.includeMembers, !0).to.include.members(t);
};
at.notIncludeMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeMembers, !0).to.not.include.members(t);
};
at.includeDeepMembers = function(n, t, e) {
  new lt(n, e, at.includeDeepMembers, !0).to.include.deep.members(t);
};
at.notIncludeDeepMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
at.includeOrderedMembers = function(n, t, e) {
  new lt(n, e, at.includeOrderedMembers, !0).to.include.ordered.members(t);
};
at.notIncludeOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
at.includeDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
at.notIncludeDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
at.oneOf = function(n, t, e) {
  new lt(n, e, at.oneOf, !0).to.be.oneOf(t);
};
at.isIterable = function(n, t) {
  if (n == null || !n[Symbol.iterator])
    throw t = t ? `${t} expected ${He(n)} to be an iterable` : `expected ${He(n)} to be an iterable`, new Ye(
      t,
      void 0,
      at.isIterable
    );
};
at.changes = function(n, t, e, i) {
  arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.changes, !0).to.change(t, e);
};
at.changesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.changesBy, !0).to.change(t, e).by(i);
};
at.doesNotChange = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.doesNotChange, !0).to.not.change(t, e);
};
at.changesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.changesButNotBy, !0).to.change(t, e).but.not.by(i);
};
at.increases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.increases, !0).to.increase(t, e);
};
at.increasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.increasesBy, !0).to.increase(t, e).by(i);
};
at.doesNotIncrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.doesNotIncrease, !0).to.not.increase(t, e);
};
at.increasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.increasesButNotBy, !0).to.increase(t, e).but.not.by(i);
};
at.decreases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.decreases, !0).to.decrease(t, e);
};
at.decreasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.decreasesBy, !0).to.decrease(t, e).by(i);
};
at.doesNotDecrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.doesNotDecrease, !0).to.not.decrease(t, e);
};
at.doesNotDecreaseBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  return new lt(n, r, at.doesNotDecreaseBy, !0).to.not.decrease(t, e).by(i);
};
at.decreasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.decreasesButNotBy, !0).to.decrease(t, e).but.not.by(i);
};
at.ifError = function(n) {
  if (n)
    throw n;
};
at.isExtensible = function(n, t) {
  new lt(n, t, at.isExtensible, !0).to.be.extensible;
};
at.isNotExtensible = function(n, t) {
  new lt(n, t, at.isNotExtensible, !0).to.not.be.extensible;
};
at.isSealed = function(n, t) {
  new lt(n, t, at.isSealed, !0).to.be.sealed;
};
at.isNotSealed = function(n, t) {
  new lt(n, t, at.isNotSealed, !0).to.not.be.sealed;
};
at.isFrozen = function(n, t) {
  new lt(n, t, at.isFrozen, !0).to.be.frozen;
};
at.isNotFrozen = function(n, t) {
  new lt(n, t, at.isNotFrozen, !0).to.not.be.frozen;
};
at.isEmpty = function(n, t) {
  new lt(n, t, at.isEmpty, !0).to.be.empty;
};
at.isNotEmpty = function(n, t) {
  new lt(n, t, at.isNotEmpty, !0).to.not.be.empty;
};
(/* @__PURE__ */ It(function n(t, e) {
  return at[e] = at[t], n;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var Pp = [];
function wy(n) {
  const t = {
    AssertionError: Ye,
    util: Zu,
    config: gi,
    expect: Bs,
    assert: at,
    Assertion: lt,
    ...$0
  };
  return ~Pp.indexOf(n) || (n(t, Zu), Pp.push(n)), t;
}
It(wy, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var ho = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oc(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function xy(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(e, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), e;
}
var tf = { exports: {} }, bh, Lp;
function _y() {
  if (Lp) return bh;
  Lp = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  bh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var g = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (g ? "s" : "");
  }
  return bh;
}
function Sy(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = s, e.enable = r, e.enabled = o, e.humanize = _y(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, g;
    function b(...x) {
      if (!b.enabled)
        return;
      const y = b, v = Number(/* @__PURE__ */ new Date()), k = v - (d || v);
      y.diff = k, y.prev = d, y.curr = v, d = v, x[0] = e.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let C = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (D, E) => {
        if (D === "%%")
          return "%";
        C++;
        const O = e.formatters[E];
        if (typeof O == "function") {
          const M = x[C];
          D = O.call(y, M), x.splice(C, 1), C--;
        }
        return D;
      }), e.formatArgs.call(y, x), (y.log || e.log).apply(y, x);
    }
    return b.namespace = u, b.useColors = e.useColors(), b.color = e.selectColor(u), b.extend = i, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, g = e.enabled(u)), g),
      set: (x) => {
        p = x;
      }
    }), typeof e.init == "function" && e.init(b), b;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? e.skips.push(new RegExp("^" + u.slice(1) + "$")) : e.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [
      ...e.names.map(a),
      ...e.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = e.skips.length; d < p; d++)
      if (e.skips[d].test(u))
        return !1;
    for (d = 0, p = e.names.length; d < p; d++)
      if (e.names[d].test(u))
        return !0;
    return !1;
  }
  function a(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var ky = Sy;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = ky(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(tf, tf.exports);
var Ay = tf.exports;
const U0 = /* @__PURE__ */ Oc(Ay), Ny = {
  cacheResults: !0,
  successMetric: "efficiency",
  calculateCuts: !0,
  stack: !0,
  findDuplicatePatterns: !0,
  //dev specific
  captureProfile: !1,
  runTests: !1,
  throwErrorsOnFailedTests: !1,
  // recordPlacementPositions: isDevOrTest ? true : false,
  sample: {
    enable: !0,
    groupSize: 6,
    efficiency: 4,
    guillotine: 2
  },
  priority: {
    enable: !0,
    variationThreshold: 0.3
  },
  secondRun: {
    enabled: !1,
    efficiencyCutoff: 0.5,
    stack: !1
  },
  efficiency: {
    tidy: !1,
    //[] issue with picking winner when tidy is enabled
    rayCasting: !0
  },
  groups: {
    shapeAreaCutOff: 0.7,
    tolerance: 0.04,
    guillotine: {
      strips: !0,
      segments: !0,
      runWithout: !1
    },
    efficiency: {
      firstShapes: !0,
      position: !0,
      limit: 100
    }
  },
  guillotine: {
    viableShapeArea: 0.5,
    secondPass: !0,
    strips: {
      rearrange: !0,
      efficiencyThreshold: 0.7
    },
    stripShapes: {
      allocation: !0,
      iterations: 6,
      numPriorityShapes: 1
    }
  },
  subset: {
    shuffles: 80,
    //this is the default - can be overwritten (for example when creating groups)
    guillotine: {
      shuffles: 80
    },
    efficiency: {
      limit: 0.5
    }
  },
  evo: {
    disable: !1,
    stockLimit: 40
  }
};
gi.showDiff = !0;
const Ip = U0("tests");
U0("timers");
function W0() {
  return typeof process < "u" && (process != null && process.env), !1;
}
function H0(n, t = null) {
  if (n != null && n.length && W0() && Ny.runTests)
    for (const e of n)
      try {
        e();
      } catch (i) {
        t ? Ip(t, i.message) : Ip(i.message);
      }
}
var ef = { exports: {} }, vh, Ep;
function Cy() {
  if (Ep) return vh;
  Ep = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  vh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var g = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (g ? "s" : "");
  }
  return vh;
}
function Py(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = o, e.enable = r, e.enabled = a, e.humanize = Cy(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, g;
    function b(...x) {
      if (!b.enabled)
        return;
      const y = b, v = Number(/* @__PURE__ */ new Date()), k = v - (d || v);
      y.diff = k, y.prev = d, y.curr = v, d = v, x[0] = e.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let C = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (D, E) => {
        if (D === "%%")
          return "%";
        C++;
        const O = e.formatters[E];
        if (typeof O == "function") {
          const M = x[C];
          D = O.call(y, M), x.splice(C, 1), C--;
        }
        return D;
      }), e.formatArgs.call(y, x), (y.log || e.log).apply(y, x);
    }
    return b.namespace = u, b.useColors = e.useColors(), b.color = e.selectColor(u), b.extend = i, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, g = e.enabled(u)), g),
      set: (x) => {
        p = x;
      }
    }), typeof e.init == "function" && e.init(b), b;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    const d = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const p of d)
      p[0] === "-" ? e.skips.push(p.slice(1)) : e.names.push(p);
  }
  function s(u, d) {
    let p = 0, f = 0, g = -1, b = 0;
    for (; p < u.length; )
      if (f < d.length && (d[f] === u[p] || d[f] === "*"))
        d[f] === "*" ? (g = f, b = p, f++) : (p++, f++);
      else if (g !== -1)
        f = g + 1, b++, p = b;
      else
        return !1;
    for (; f < d.length && d[f] === "*"; )
      f++;
    return f === d.length;
  }
  function o() {
    const u = [
      ...e.names,
      ...e.skips.map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function a(u) {
    for (const d of e.skips)
      if (s(u, d))
        return !1;
    for (const d of e.names)
      if (s(u, d))
        return !0;
    return !1;
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var Ly = Py;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = Ly(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(ef, ef.exports);
var Iy = ef.exports;
const Zi = /* @__PURE__ */ Oc(Iy);
Zi.colors = [
  2,
  3,
  4,
  5,
  7,
  9,
  10,
  11,
  14,
  159
];
Zi("logs");
Zi("cuts");
Zi("guillotine");
Zi("results");
Zi("scoring");
Zi("calculations");
Zi("subset");
Zi("secondRun");
Zi("stack");
const Ey = Zi("errors");
Zi("allStock");
Ey.color = 1;
function Oy(n) {
  if (n != null && n.dimension)
    switch (n.dimension) {
      case "l":
        return n.x2 - n.x1;
      case "w":
        return n.y2 - n.y1;
    }
  switch (n.type) {
    case "top":
    case "bottom":
      return n.x2 - n.x1;
    case "left":
    case "right":
      return n.y2 - n.y1;
  }
  return 0;
}
class Tc extends ga {
  //used to mark for removal
  constructor(e) {
    var i, r, s, o;
    e.x2 < e.x1 && ([e.x1, e.x2] = [e.x2, e.x1]), e.y2 < e.y1 && ([e.y1, e.y2] = [e.y2, e.y1]);
    super(e);
    et(this, "stock");
    et(this, "stockId");
    et(this, "guillotine");
    et(this, "guillotineData");
    et(this, "isTrim");
    et(this, "distances");
    et(this, "beamTrimX1");
    et(this, "beamTrimY1");
    et(this, "type", null);
    et(this, "remove");
    jt(e == null ? void 0 : e.stock) && (((r = (i = e.stock) == null ? void 0 : i.constructor) == null ? void 0 : r.name) === "Stock" ? this.stock = e.stock : this.stock = new ts(e.stock), this.stockId = this.stock.id), this.stockId = (s = e == null ? void 0 : e.stock) == null ? void 0 : s.id, this.type = e.type ?? null, this.guillotine = e.guillotine, this.guillotineData = jt(e.guillotineData) ? e.guillotineData : {}, this.guillotineData.ptxDummyCut = (e == null ? void 0 : e.ptxDummyCut) || ((o = e == null ? void 0 : e.guillotineData) == null ? void 0 : o.ptxDummyCut) || !1, this.isTrim = jt(e.isTrim) ? e.isTrim : !1, this.distances = jt(e.distances) ? e.distances : {}, this.beamTrimX1 = e.beamTrimX1, this.beamTrimY1 = e.beamTrimY1;
  }
  //compress for saving / transfer
  compress() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.shapeCollisions, delete this.stock;
  }
  clone() {
    const e = structuredClone(this);
    return new Tc(e);
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
  trim() {
    this.dimension === "l" ? (this.x1 = this.x1 < 0 ? 0 : this.x1, this.x2 = this.x2 > this.stock.l ? this.stock.l : this.x2) : this.dimension === "w" && (this.y1 = this.y1 < 0 ? 0 : this.y1, this.y2 = this.y2 > this.stock.w ? this.stock.w : this.y2);
  }
  lookupDirectionByType(e) {
    const r = {
      top: "l",
      bottom: "l",
      left: "w",
      right: "w"
    }[e];
    if (r) return r;
    throw new Error("no direction found in lookupDirectionByType");
  }
  isInsideStock() {
    switch (this.type) {
      case "bottom":
        return Ge.greaterThan(
          this.y1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "left":
        return Ge.greaterThan(
          this.x1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "top":
        return Ge.lessThan(
          this.y1 - this.stock.getBladeWidth() / 2,
          this.stock.w
        );
      case "right":
        return Ge.lessThan(
          this.x1 - this.stock.getBladeWidth() / 2,
          this.stock.l
        );
      default:
        return !0;
    }
  }
  /**
      * the cuts are visualised differently from their exact dimensions
      * @param {string} coord
      */
  getVisCoords(e) {
    return this[e];
  }
  getLength() {
    return Oy(this);
  }
  getArea() {
    if (!this.stock) return 0;
    const e = this.getLength();
    return e ? e * this.stock.getBladeWidth() : 0;
  }
}
const Ty = {
  tb: {
    bottomLeft: {
      top: "topRight",
      topLeft: "topLeft"
    },
    bottomRight: {
      top: "topLeft",
      topRight: "topRight"
    }
  },
  bt: {
    topLeft: {
      bottom: "bottomRight",
      bottomLeft: "bottomLeft"
    },
    topRight: {
      bottom: "bottomLeft",
      bottomRight: "bottomRight"
    }
  },
  lr: {
    topRight: {
      left: "bottomLeft",
      topLeft: "topLeft"
    },
    bottomRight: {
      left: "topLeft",
      bottomLeft: "bottomLeft"
    }
  },
  rl: {
    topLeft: {
      right: "bottomRight",
      topRight: "topRight"
    },
    bottomLeft: {
      right: "topRight",
      bottomRight: "bottomRight"
    }
  }
}, Su = {
  topLeft: {
    top: ["topRight"],
    default: ["topRight"]
  },
  bottomRight: {
    right: ["topRight"],
    default: ["topRight"]
  }
}, ku = {
  topRight: {
    top: ["topLeft"],
    right: ["bottomRight"],
    default: ["topLeft", "bottomRight"]
  },
  topLeft: {
    top: ["topRight"],
    left: ["bottomLeft"],
    default: ["topRight", "bottomLeft"]
  },
  bottomRight: {
    bottom: ["bottomLeft"],
    right: ["topRight"],
    default: ["bottomLeft", "topRight"]
  },
  bottomLeft: {
    bottom: ["bottomRight"],
    left: ["topLeft"],
    default: ["bottomRight", "topLeft"]
  }
};
class Hn {
  constructor(t, e, i = null) {
    et(this, "x");
    et(this, "y");
    et(this, "z");
    et(this, "a");
    //shape id
    et(this, "b");
    //shape id
    et(this, "direction");
    //direction of the raay
    et(this, "type");
    //[] need to type
    et(this, "corner");
    //originating corner of this point
    et(this, "grid");
    //if a grid point, which grid position
    et(this, "stockID");
    et(this, "raycast");
    et(this, "collision");
    et(this, "tooClose");
    et(this, "adjustedForMinSpacing");
    this.x = parseFloat(t), this.y = parseFloat(e), this.z = parseFloat(i) || 0, this.validate();
  }
  /**
   * clone with the ability to change the coordinates
   * NOTE: looks odd for performance reasons
   */
  clone(t = null, e = null) {
    const i = new Hn(t ?? this.x, e ?? this.y);
    for (const r in this)
      r !== "x" && r !== "y" && (i[r] = this[r]);
    return i;
  }
  validate() {
    if (isNaN(this.x) || isNaN(this.y))
      throw new Error("invalid point coordinates");
  }
  coords() {
    return {
      x: this.x,
      y: this.y
    };
  }
  collidesWith(t) {
    return this.x >= t.x && this.x <= t.x + t.l && this.y >= t.y && this.y <= t.y + t.w;
  }
  isIdenticalTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * given a point from a shape corner or a ray, get the available positions for this shape
   * @returns the position of the shape relative to the point e.g. bottomRight means the shape is placed to the bottom right of the point
   * @remarks does not cater for diagonals
   */
  //[x] needs to cater for raycast coords, which don't originate from a shape corner
  //[x] cater for raycast corners and grid
  getAvailableShapePositions(t) {
    const e = /* @__PURE__ */ new Set();
    if (this.raycast) {
      const i = Ty[this.direction];
      return i && i[this.corner] && i[this.corner][this.grid] && e.add(i[this.corner][this.grid]), e;
    }
    return (t == null ? void 0 : t.cutType) !== "efficiency" ? (Su[this.corner] && (this.grid ? Su[this.corner][this.grid] && Su[this.corner][this.grid].forEach((i) => e.add(i)) : Su[this.corner].default.forEach((i) => e.add(i))), e) : (ku[this.corner] && (this.grid ? ku[this.corner][this.grid] && ku[this.corner][this.grid].forEach((i) => e.add(i)) : ku[this.corner].default.forEach((i) => e.add(i))), e);
  }
}
class Eo {
  constructor(t = []) {
    et(this, "points", /* @__PURE__ */ new Map());
    t.forEach((e) => this.addPoint(e));
  }
  addPoint(t, e = null) {
    if (this.contains(t)) {
      const i = this.getPoint(t);
      i.type === "group" && !e && (i.type = void 0);
      return;
    }
    t.validate(), e && (t.type = e), this.points.set(this.createKey(t), t);
  }
  addPoints(t, e = null) {
    for (const i of t) {
      if (!i) return;
      i.validate(), this.addPoint(i, e);
    }
  }
  createKey(t) {
    return `${t.x},${t.y}`;
  }
  getPoint(t) {
    return this.points.get(this.createKey(t));
  }
  deletePoint(t) {
    t.validate(), this.points.delete(this.createKey(t));
  }
  deletePoints(t) {
    for (const e of t)
      e.validate(), this.deletePoint(e);
  }
  clear() {
    this.points.clear();
  }
  toArray() {
    return Array.from(this.points.values());
  }
  contains(t) {
    return this.points.has(this.createKey(t));
  }
}
function Je(n, t, e, i, r) {
  const s = Fy[n](t, e);
  return i && (s.corner = i), r && (s.direction = r), s;
}
const Fy = {
  bottom: (n, t) => {
    const e = n.clone(n.x, n.y - t);
    return e.grid = "bottom", e;
  },
  bottomLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y - t);
    return e.grid = "bottomLeft", e;
  },
  bottomRight: (n, t) => {
    const e = n.clone(n.x + t, n.y - t);
    return e.grid = "bottomRight", e;
  },
  left: (n, t) => {
    const e = n.clone(n.x - t, n.y);
    return e.grid = "left", e;
  },
  centre: (n) => {
    const t = n.clone(n.x, n.y);
    return t.grid = "centre", t;
  },
  right: (n, t) => {
    const e = n.clone(n.x + t, n.y);
    return e.grid = "right", e;
  },
  top: (n, t) => {
    const e = n.clone(n.x, n.y + t);
    return e.grid = "top", e;
  },
  topLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y + t);
    return e.grid = "topLeft", e;
  },
  topRight: (n, t) => {
    const e = n.clone(n.x + t, n.y + t);
    return e.grid = "topRight", e;
  }
};
function My(n, t, e) {
  var o, a, l, h, u, d;
  const i = new Eo(), r = e.toArray().sort(G0), s = t.getBladeWidth();
  if (r.forEach((p) => {
    const f = p.corner, g = p.type;
    if (!s)
      i.addPoint(p);
    else
      switch (f) {
        case "topRight":
          i.addPoint(
            Je("top", p, s, f),
            g
          ), i.addPoint(
            Je("right", p, s, f),
            g
          );
          break;
        case "topLeft":
          i.addPoint(
            Je("top", p, s, f),
            g
          ), i.addPoint(
            Je("left", p, s, f),
            g
          );
          break;
        case "bottomRight":
          i.addPoint(
            Je("bottom", p, s, f),
            g
          ), i.addPoint(
            Je("right", p, s, f),
            g
          );
          break;
        case "bottomLeft":
          i.addPoint(
            Je("bottom", p, s, f),
            g
          ), i.addPoint(
            Je("left", p, s, f),
            g
          );
          break;
      }
    const b = i.toArray();
    if (s)
      for (let x = b.length; x--; ) {
        const y = b[x];
        e.contains(y) && i.deletePoint(y);
      }
    else
      for (let x = b.length; x--; ) {
        const y = b[x];
        for (let v = n.length; v--; ) {
          const k = n[v];
          if (y.x === k.x && y.y === k.y) {
            i.deletePoint(y);
            break;
          }
        }
      }
  }), s) {
    const p = /* @__PURE__ */ new Set();
    let f, g, b, x;
    ((o = t == null ? void 0 : t.constructor) == null ? void 0 : o.name) === "Stock" && (t != null && t.trimmed) || ((a = t == null ? void 0 : t.constructor) == null ? void 0 : a.name) === "Segment" ? (f = t.x, g = t.y, b = t.x + t.l, x = t.y + t.w) : (f = t.x + ((l = t == null ? void 0 : t.trim) == null ? void 0 : l.x1), g = t.y + ((h = t == null ? void 0 : t.trim) == null ? void 0 : h.y1), b = t.x + t.l - ((u = t == null ? void 0 : t.trim) == null ? void 0 : u.x2), x = t.y + t.w - ((d = t == null ? void 0 : t.trim) == null ? void 0 : d.y2));
    let y = i.toArray();
    for (let v = y.length; v--; ) {
      const k = y[v];
      (Ge.lessThan(k.x, f) || Ge.lessThan(k.y, g) || Ge.greaterThan(k.x, b) || Ge.greaterThan(k.y, x)) && y.splice(v, 1);
    }
    i.clear(), i.addPoints(y), p.clear(), y = i.toArray();
    for (let v = y.length; v--; ) {
      const k = y[v];
      for (let C = n.length; C--; ) {
        const I = n[C];
        if (k.collidesWith(I)) {
          i.deletePoint(k);
          break;
        }
      }
    }
  }
  return i;
}
function Dy(n, t, e) {
  let i = [];
  const r = n.getMinSpacing(e), s = t.corner, o = t.direction;
  if (t.type === "shape")
    switch (s) {
      case "topLeft":
        o === "rl" && (i.push(Je("right", t, r, s, o)), i.push(Je("topRight", t, r, s, o))), o === "bt" && (i.push(Je("bottom", t, r, s, o)), i.push(Je("bottomLeft", t, r, s, o)));
        break;
      case "topRight":
        o === "lr" && (i.push(Je("left", t, r, s, o)), i.push(Je("topLeft", t, r, s, o))), o === "bt" && (i.push(Je("bottom", t, r, s, o)), i.push(Je("bottomRight", t, r, s, o)));
        break;
      case "bottomRight":
        o === "lr" && (i.push(Je("left", t, r, s, o)), i.push(Je("bottomLeft", t, r, s, o))), o === "tb" && (i.push(Je("top", t, r, s, o)), i.push(Je("topRight", t, r, s, o)));
        break;
      case "bottomLeft":
        o === "rl" && (i.push(Je("right", t, r, s, o)), i.push(Je("bottomRight", t, r, s, o))), o === "tb" && (i.push(Je("top", t, r, s, o)), i.push(Je("topLeft", t, r, s, o)));
        break;
    }
  else if (t.type === "edge")
    switch (o) {
      case "rl":
      case "lr":
        i.push(Je("top", t, 0)), i.push(Je("centre", t, 0)), i.push(Je("bottom", t, 0));
        break;
      case "tb":
      case "bt":
        i.push(Je("left", t, 0)), i.push(Je("right", t, 0)), i.push(Je("centre", t, 0));
        break;
    }
  if (i = i.filter((l) => l.x >= 0 && l.y >= 0), !i.length) return null;
  const a = new Eo();
  for (const l of i)
    l.raycast = !0, a.addPoints(K0(n, l, e).toArray());
  return X0(n, e, a), a;
}
function Ry(n, t) {
  const e = new Eo();
  return n.sort(G0), n.forEach((i) => {
    Nr(i) ? (e.addPoints(i.getCoords(t)), i.shapes.forEach((r) => {
      const s = r.getCoords(t);
      e.addPoints(s, "group");
    })) : e.addPoints(i.getCoords(t));
  }), e.points.forEach((i) => {
    i.stockID = t.getStock().id;
  }), e;
}
function By(n = [], t, e) {
  const i = Ry(
    n === null ? t : n,
    e
  );
  return My(
    t,
    e,
    i
  );
}
function G0(n, t) {
  return n.y === t.y ? t.x - n.x : t.y - n.y;
}
function V0(n, t, e, i, r, s) {
  n.a = t.id, n.b = e ? e.id : null, n.direction = i, n.raycast = !0, n.type = r, n.corner = s;
}
function jy(n, t) {
  if (n.saw.cutType !== "efficiency" || t.length <= 1) return null;
  let e = new Eo();
  const i = Y0(t, n);
  for (const a of t)
    for (const l of i) {
      if (l.shape.id === a.id) continue;
      const h = Object.values(l.rays);
      for (const u of h)
        qy(
          u,
          l.shape,
          a,
          e
        );
    }
  const s = n.saw.efficiencyOptions.primaryCompression === "x" ? "lr" : "tb", o = t.reduce((a, l) => (s === "tb" ? a.x + a.l > l.x + l.l : a.y + a.w > l.y + l.w) ? a : l);
  return i.filter(({ shape: a }) => a.id === o.id).forEach(({ shape: a, rays: l }) => {
    const h = Object.values(l);
    for (const u of h) {
      const d = new Hn(u.x2, u.y2);
      s === u.direction && (V0(d, a, null, u.direction, "edge"), e.addPoint(d));
    }
  }), e = zy(e), e;
}
function Y0(n, t) {
  return n.map((e) => {
    const i = J2(e, t);
    return {
      shape: e,
      rays: i
    };
  });
}
function qy(n, t, e, i) {
  switch (n.direction) {
    case "rl":
      Au(
        n,
        t,
        e,
        i,
        e.x + e.l
      );
      break;
    case "lr":
      Au(
        n,
        t,
        e,
        i,
        e.x
      );
      break;
    case "tb":
      Au(
        n,
        t,
        e,
        i,
        e.y + e.w
      );
      break;
    case "bt":
      Au(
        n,
        t,
        e,
        i,
        e.y
      );
      break;
  }
}
function Au(n, t, e, i, r) {
  const s = n.dimension === "w", o = s ? "y" : "x", a = s ? "x" : "y", l = s ? "l" : "w";
  if (n[`${a}1`] >= e[a] && n[`${a}1`] <= e[a] + e[l]) {
    const h = n.direction === "lr" && n[`${o}1`] <= r && n[`${o}2`] >= r, u = n.direction === "rl" && n[`${o}1`] >= r && n[`${o}2`] <= r, d = n.direction === "bt" && n[`${o}1`] <= r && n[`${o}2`] >= r, p = n.direction === "tb" && n[`${o}1`] >= r && n[`${o}2`] <= r;
    if (h || u || d || p) {
      const g = s ? n[`${a}1`] : r, b = s ? r : n[`${a}1`], x = new Hn(g, b), y = n.origin;
      V0(x, t, e, n.direction, "shape", y), i.addPoint(x);
    }
  }
}
function zy(n) {
  const t = new Eo();
  return n.points.size === 0 || new Set(n.toArray().map((i) => i.a)).forEach((i) => {
    const r = n.toArray().filter((s) => s.a === i);
    ["right", "left", "top", "bottom"].forEach((s) => {
      const o = $y(
        r,
        s
      );
      o && t.addPoint(o);
    });
  }), t;
}
function $y(n, t) {
  return n.length === 0 ? null : n.reduce((e, i) => {
    switch (t) {
      case "left":
        return !e || i.x < e.x ? i : e;
      case "right":
        return !e || i.x > e.x ? i : e;
      case "top":
        return !e || i.y > e.y ? i : e;
      case "bottom":
        return !e || i.y < e.y ? i : e;
      default:
        return null;
    }
  }, null);
}
function K0(n, t, e) {
  const i = new Eo(), r = t.getAvailableShapePositions(e);
  for (const s of r) {
    let o;
    switch (o = Uy(t, n, e), s) {
      case "bottomLeft":
        o = o.clone(o.x - n.l, o.y - n.w), o.shapePosition = "bottomLeft";
        break;
      case "bottomRight":
        o = o.clone(o.x, o.y - n.w), o.shapePosition = "bottomRight";
        break;
      case "topLeft":
        o = o.clone(o.x - n.l, o.y), o.shapePosition = "topLeft";
        break;
      case "topRight":
        o = o.clone(o.x, o.y), o.shapePosition = "topRight";
        break;
    }
    i.addPoint(o);
  }
  return X0(n, e, i), i;
}
function Uy(n, t, e) {
  if (e.saw.cutType !== "efficiency") return n;
  const i = t.getMinSpacing(e), r = e.getBladeWidth();
  if (!i || i === r) return n;
  let s;
  if (!n.grid) return n;
  switch (n.grid) {
    case "bottom":
      s = n.clone(n.x, n.y - i + r);
      break;
    case "top":
      s = n.clone(n.x, n.y + i - r);
      break;
    case "left":
      s = n.clone(n.x - i + r, n.y);
      break;
    case "right":
      s = n.clone(n.x + i - r, n.y);
      break;
  }
  return s ? (s.x < 0 && (s.x = 0), s.y < 0 && (s.y = 0), s.adjustedForMinSpacing = !0, s) : n;
}
function X0(n, t, e) {
  var l, h, u, d, p, f;
  let i, r, s, o;
  ((l = t == null ? void 0 : t.constructor) == null ? void 0 : l.name) === "Stock" && (t != null && t.trimmed) || ((h = t == null ? void 0 : t.constructor) == null ? void 0 : h.name) === "Segment" ? (i = 0, r = 0, s = t.x + t.l - n.l, o = t.y + t.w - n.w) : (i = (u = t == null ? void 0 : t.trim) == null ? void 0 : u.x1, r = (d = t == null ? void 0 : t.trim) == null ? void 0 : d.y1, s = t.l - ((p = t == null ? void 0 : t.trim) == null ? void 0 : p.x2) - n.l, o = t.w - ((f = t == null ? void 0 : t.trim) == null ? void 0 : f.y2) - n.w);
  const a = e.toArray();
  for (let g = a.length; g--; ) {
    const b = a[g];
    (Ge.lessThan(b.x, i) || Ge.lessThan(b.y, r) || Ge.greaterThan(b.x, s) || Ge.greaterThan(b.y, o) || b.x < 0 || b.y < 0) && e.deletePoint(b);
  }
}
/**
* @license Fraction.js v4.3.7 31/08/2023
* https://www.xarg.org/2014/03/rational-numbers-in-javascript/
*
* Copyright (c) 2023, Robert Eisele (robert@raw.org)
* Dual licensed under the MIT or GPL Version 2 licenses.
**/
var Wy = 2e3, pe = {
  s: 1,
  n: 0,
  d: 1
};
function Xr(n, t) {
  if (isNaN(n = parseInt(n, 10)))
    throw $u();
  return n * t;
}
function mn(n, t) {
  if (t === 0)
    throw gd();
  var e = Object.create(Os.prototype);
  e.s = n < 0 ? -1 : 1, n = n < 0 ? -n : n;
  var i = ya(n, t);
  return e.n = n / i, e.d = t / i, e;
}
function Op(n) {
  for (var t = {}, e = n, i = 2, r = 4; r <= e; ) {
    for (; e % i === 0; )
      e /= i, t[i] = (t[i] || 0) + 1;
    r += 1 + 2 * i++;
  }
  return e !== n ? e > 1 && (t[e] = (t[e] || 0) + 1) : t[n] = (t[n] || 0) + 1, t;
}
var Fi = function(n, t) {
  var e = 0, i = 1, r = 1, s = 0, o = 0, a = 0, l = 1, h = 1, u = 0, d = 1, p = 1, f = 1, g = 1e7, b;
  if (n != null) if (t !== void 0) {
    if (e = n, i = t, r = e * i, e % 1 !== 0 || i % 1 !== 0)
      throw Yy();
  } else
    switch (typeof n) {
      case "object": {
        if ("d" in n && "n" in n)
          e = n.n, i = n.d, "s" in n && (e *= n.s);
        else if (0 in n)
          e = n[0], 1 in n && (i = n[1]);
        else
          throw $u();
        r = e * i;
        break;
      }
      case "number": {
        if (n < 0 && (r = n, n = -n), n % 1 === 0)
          e = n;
        else if (n > 0) {
          for (n >= 1 && (h = Math.pow(10, Math.floor(1 + Math.log(n) / Math.LN10)), n /= h); d <= g && f <= g; )
            if (b = (u + p) / (d + f), n === b) {
              d + f <= g ? (e = u + p, i = d + f) : f > d ? (e = p, i = f) : (e = u, i = d);
              break;
            } else
              n > b ? (u += p, d += f) : (p += u, f += d), d > g ? (e = p, i = f) : (e = u, i = d);
          e *= h;
        } else (isNaN(n) || isNaN(t)) && (i = e = NaN);
        break;
      }
      case "string": {
        if (d = n.match(/\d+|./g), d === null)
          throw $u();
        if (d[u] === "-" ? (r = -1, u++) : d[u] === "+" && u++, d.length === u + 1 ? o = Xr(d[u++], r) : d[u + 1] === "." || d[u] === "." ? (d[u] !== "." && (s = Xr(d[u++], r)), u++, (u + 1 === d.length || d[u + 1] === "(" && d[u + 3] === ")" || d[u + 1] === "'" && d[u + 3] === "'") && (o = Xr(d[u], r), l = Math.pow(10, d[u].length), u++), (d[u] === "(" && d[u + 2] === ")" || d[u] === "'" && d[u + 2] === "'") && (a = Xr(d[u + 1], r), h = Math.pow(10, d[u + 1].length) - 1, u += 3)) : d[u + 1] === "/" || d[u + 1] === ":" ? (o = Xr(d[u], r), l = Xr(d[u + 2], 1), u += 3) : d[u + 3] === "/" && d[u + 1] === " " && (s = Xr(d[u], r), o = Xr(d[u + 2], r), l = Xr(d[u + 4], 1), u += 5), d.length <= u) {
          i = l * h, r = /* void */
          e = a + i * s + h * o;
          break;
        }
      }
      default:
        throw $u();
    }
  if (i === 0)
    throw gd();
  pe.s = r < 0 ? -1 : 1, pe.n = Math.abs(e), pe.d = Math.abs(i);
};
function Hy(n, t, e) {
  for (var i = 1; t > 0; n = n * n % e, t >>= 1)
    t & 1 && (i = i * n % e);
  return i;
}
function Gy(n, t) {
  for (; t % 2 === 0; t /= 2)
    ;
  for (; t % 5 === 0; t /= 5)
    ;
  if (t === 1)
    return 0;
  for (var e = 10 % t, i = 1; e !== 1; i++)
    if (e = e * 10 % t, i > Wy)
      return 0;
  return i;
}
function Vy(n, t, e) {
  for (var i = 1, r = Hy(10, e, t), s = 0; s < 300; s++) {
    if (i === r)
      return s;
    i = i * 10 % t, r = r * 10 % t;
  }
  return 0;
}
function ya(n, t) {
  if (!n)
    return t;
  if (!t)
    return n;
  for (; ; ) {
    if (n %= t, !n)
      return t;
    if (t %= n, !t)
      return n;
  }
}
function Os(n, t) {
  if (Fi(n, t), this instanceof Os)
    n = ya(pe.d, pe.n), this.s = pe.s, this.n = pe.n / n, this.d = pe.d / n;
  else
    return mn(pe.s * pe.n, pe.d);
}
var gd = function() {
  return new Error("Division by Zero");
}, $u = function() {
  return new Error("Invalid argument");
}, Yy = function() {
  return new Error("Parameters must be integer");
};
Os.prototype = {
  s: 1,
  n: 0,
  d: 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return mn(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return mn(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(n, t) {
    return Fi(n, t), mn(
      this.s * this.n * pe.d + pe.s * this.d * pe.n,
      this.d * pe.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(n, t) {
    return Fi(n, t), mn(
      this.s * this.n * pe.d - pe.s * this.d * pe.n,
      this.d * pe.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(n, t) {
    return Fi(n, t), mn(
      this.s * pe.s * this.n * pe.n,
      this.d * pe.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(n, t) {
    return Fi(n, t), mn(
      this.s * pe.s * this.n * pe.d,
      this.d * pe.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return mn(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  mod: function(n, t) {
    if (isNaN(this.n) || isNaN(this.d))
      return new Os(NaN);
    if (n === void 0)
      return mn(this.s * this.n % this.d, 1);
    if (Fi(n, t), pe.n === 0 && this.d === 0)
      throw gd();
    return mn(
      this.s * (pe.d * this.n) % (pe.n * this.d),
      pe.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(n, t) {
    return Fi(n, t), mn(ya(pe.n, this.n) * ya(pe.d, this.d), pe.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(n, t) {
    return Fi(n, t), pe.n === 0 && this.n === 0 ? mn(0, 1) : mn(pe.n * this.n, ya(pe.n, this.n) * ya(pe.d, this.d));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Os(NaN) : mn(Math.ceil(n * this.s * this.n / this.d), n);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Os(NaN) : mn(Math.floor(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Os(NaN) : mn(Math.round(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  roundTo: function(n, t) {
    return Fi(n, t), mn(this.s * Math.round(this.n * pe.d / (this.d * pe.n)) * pe.n, pe.d);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return mn(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(n, t) {
    if (Fi(n, t), pe.d === 1)
      return pe.s < 0 ? mn(Math.pow(this.s * this.d, pe.n), Math.pow(this.n, pe.n)) : mn(Math.pow(this.s * this.n, pe.n), Math.pow(this.d, pe.n));
    if (this.s < 0) return null;
    var e = Op(this.n), i = Op(this.d), r = 1, s = 1;
    for (var o in e)
      if (o !== "1") {
        if (o === "0") {
          r = 0;
          break;
        }
        if (e[o] *= pe.n, e[o] % pe.d === 0)
          e[o] /= pe.d;
        else return null;
        r *= Math.pow(o, e[o]);
      }
    for (var o in i)
      if (o !== "1") {
        if (i[o] *= pe.n, i[o] % pe.d === 0)
          i[o] /= pe.d;
        else return null;
        s *= Math.pow(o, i[o]);
      }
    return pe.s < 0 ? mn(s, r) : mn(r, s);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(n, t) {
    return Fi(n, t), this.s * this.n * pe.d === pe.s * pe.n * this.d;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  compare: function(n, t) {
    Fi(n, t);
    var e = this.s * this.n * pe.d - pe.s * pe.n * this.d;
    return (0 < e) - (e < 0);
  },
  simplify: function(n) {
    if (isNaN(this.n) || isNaN(this.d))
      return this;
    n = n || 1e-3;
    for (var t = this.abs(), e = t.toContinued(), i = 1; i < e.length; i++) {
      for (var r = mn(e[i - 1], 1), s = i - 2; s >= 0; s--)
        r = r.inverse().add(e[s]);
      if (Math.abs(r.sub(t).valueOf()) < n)
        return r.mul(this.s);
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(n, t) {
    return Fi(n, t), !(!(pe.n * this.d) || this.n * pe.d % (pe.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return this.s * this.n / this.d;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  toFraction: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, e += " ", i %= r), e += i, e += "/", e += r), e;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, i %= r), e += "\\frac{", e += i, e += "}{", e += r, e += "}"), e;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    var n, t = this.n, e = this.d, i = [];
    if (isNaN(t) || isNaN(e))
      return i;
    do
      i.push(Math.floor(t / e)), n = t % e, t = e, e = n;
    while (t !== 1);
    return i;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(n) {
    var t = this.n, e = this.d;
    if (isNaN(t) || isNaN(e))
      return "NaN";
    n = n || 15;
    var i = Gy(t, e), r = Vy(t, e, i), s = this.s < 0 ? "-" : "";
    if (s += t / e | 0, t %= e, t *= 10, t && (s += "."), i) {
      for (var o = r; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += "(";
      for (var o = i; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += ")";
    } else
      for (var o = n; t && o--; )
        s += t / e | 0, t %= e, t *= 10;
    return s;
  }
};
function Ky(n) {
  if (!n) return null;
  if (n = n.toString().trim(), typeof navigator > "u" || typeof navigator.language > "u")
    return parseFloat(n);
  const { thousandsSeparator: t, decimalSeparator: e } = Xy();
  return n = Array.from(n, (i) => i === t ? "" : i === e ? "." : i).join(""), parseFloat(n);
}
function Xy() {
  const n = navigator.language, t = 123456789e-2.toLocaleString(n), e = t.replace(/\d/g, ""), i = Array.from(new Set(e.split("")));
  let r = "", s = "";
  if (i.length === 1)
    s = i[0];
  else if (i.length === 2) {
    const o = t[t.length - 3];
    i.includes(o) ? (s = o, r = i.find((a) => a !== o)) : (s = i[1], r = i[0]);
  }
  return { thousandsSeparator: r, decimalSeparator: s };
}
function J0(n) {
  if (!n || typeof n == "number") return !1;
  n = n.toString().replace(/[^0-9/ ]/g, "");
  const t = /\b\d+\/\d+\b/g;
  return n.match(t);
}
function Jy(n, t = !1) {
  if (!jt(n)) return null;
  if (n === 0) return "0";
  let e = n.toString().trim();
  if (!e) return null;
  if (J0(n))
    return e = e.replace(/[^0-9/,. -]/g, "").replace(/  +/g, " "), e;
  {
    e = e.replace(/[^0-9,. -]/g, ""), e.startsWith(".") && (e = "0" + e);
    let i;
    return t ? i = Ky(e) : i = parseFloat(e), i ? i.toString() : null;
  }
}
function ll(n) {
  let t;
  try {
    t = new Os(n);
  } catch {
    console.log(`issue parsing ${n} to new Fraction()`), t = 0;
  }
  return t;
}
function Qt(n, t = "decimal", e = !1, i = !1, r = 0) {
  if (!jt(n) || !t) return null;
  if (t !== "decimal" && t !== "fraction")
    return console.error("incorrect conversion type specified for convertUnit"), null;
  try {
    const s = Jy(n, i);
    if (!s) return 0;
    let o;
    if (t === "fraction")
      if (J0(s))
        o = ll(s);
      else {
        const a = parseFloat(s);
        Number.isInteger(a) ? o = ll(s) : o = ll(a);
      }
    else o = ll(s);
    switch (t) {
      case "fraction":
        if (r > 0) {
          const a = o.valueOf(), l = Math.round(a * r) / r;
          o = ll(l);
        }
        return o.toFraction(!0);
      case "decimal":
        if (e === !1 || typeof e != "number")
          return o.valueOf();
        {
          const a = o.valueOf();
          return a === 0 ? 0 : parseFloat(a.toFixed(e));
        }
      default:
        return 0;
    }
  } catch (s) {
    return console.error(s), 0;
  }
}
function Zy(n) {
  let t = n;
  return typeof n != "number" && (t = parseFloat(n)), t % 1 !== 0;
}
const li = {
  customData: (n, t = null) => {
    const e = [];
    return typeof n != "object" ? (e.push({ message: "Custom data must be an object." }), e) : (Object.entries(n).forEach(([i, r]) => {
      jt(r) && (["string", "number", "boolean"].includes(typeof r) || e.push({
        message: `Custom data ${i} must be a string, number or boolean.`,
        index: t
      }));
    }), e);
  },
  banding: (n, t = null) => {
    const e = [];
    if (!jt(n)) return [];
    if (typeof n != "object")
      return e.push({
        message: "Banding must be an object.",
        field: ["banding"],
        index: t
      }), e;
    Object.entries(n).forEach(([i, r]) => {
      jt(r) && r !== !0 && r !== !1 && e.push({
        message: `Banding ${i} must be a boolean.`,
        field: ["banding"],
        index: t
      });
    });
  },
  //when trim provided as number
  partTrim(n, t, e = null) {
    t = Qt(t);
    const i = Qt(n.l), r = Qt(n.w), s = i - t * 2, o = r - t * 2;
    return s < 0 || o < 0 ? [
      {
        message: `When applying trim of ${t}, part is ${s} x ${o}.`,
        field: ["trim"],
        index: e
      }
    ] : [];
  },
  //when trim provided as object
  trim: (n, t = null) => {
    const e = [];
    if (!jt(n.trim)) return e;
    if (dr.forEach((i) => {
      jt(n.trim[i]) || (n.trim[i] = 0);
    }), !Qr(n) || Qr(n) && !(n != null && n.trimmed)) {
      const i = ["l", "w"], [r, s] = i.map((d) => Qt(n[d])), [o, a, l, h] = dr.map((d) => Qt(n.trim[d]));
      Object.entries({ x1: o, x2: a, y1: l, y2: h }).forEach(([d, p]) => {
        isNaN(p) && e.push({
          message: `The value of trim ${sf[d]} is not understood.`,
          field: ["trim"],
          index: t
        });
      }), r && s && r > 0 && s > 0 && (o + a >= n.l && e.push({
        message: `Trim W1 + W2 = ${o + a}, which is greater than or equal to total length of ${r}.`,
        field: ["trim"],
        subField: ["x1", "x2"],
        index: t
      }), l + h >= n.w && e.push({
        message: `Trim L1 + L2 = ${l + h}, which is greater than or equal to total width of ${s}.`,
        field: ["trim"],
        subField: ["y1", "y2"],
        index: t
      }));
    }
    return e;
  },
  x: (n, t = null) => {
    const e = [];
    return jt(n) ? (n = Qt(n), isNaN(n) ? (e.push({ message: `X value is not understood, got ${n}`, index: t }), e) : (n < 0 && e.push({ message: `X must be greater than or equal to zero, got ${n}` }), e)) : e;
  },
  y: (n, t = null) => {
    const e = [];
    return jt(n) && (n = Qt(n), isNaN(n) && e.push({ message: `Y value is not understood, got ${n}`, index: t }), n < 0 && e.push({ message: `Y must be greater than or equal to zero, got ${n}`, index: t })), e;
  },
  l: (n, t = null, e = 0) => {
    const i = [];
    return jt(n) ? (n = Qt(n), isNaN(n) ? (i.push({
      message: `Length value is not understood, got ${n}`,
      field: ["l"],
      index: t
    }), i) : (n < e && i.push({
      message: `Length must be greater than or equal to ${e}, got ${n}`,
      field: ["l"],
      index: t
    }), i)) : (i.push({
      message: "Length is required.",
      field: ["l"],
      index: t
    }), i);
  },
  w: (n, t = null, e = 0) => {
    const i = [];
    return jt(n) ? (n = Qt(n), isNaN(n) ? (i.push({
      message: `Width value is not understood, got ${n}`,
      field: ["w"],
      index: t
    }), i) : (n < e && i.push({
      message: `Width must be greater than or equal to ${e}, got ${n}`,
      field: ["w"],
      index: t
    }), i)) : (i.push({
      message: "Width is required.",
      field: ["w"],
      index: t
    }), i);
  },
  t: (n, t = null) => {
    const e = [];
    return !jt(n) || n === "" ? e : (n = Qt(n), isNaN(n) ? (e.push({
      message: `Thickness value is not understood, got ${n}`,
      field: ["t"],
      index: t
    }), e) : (n && n <= 0 && e.push({
      message: `Thickness must be greater than zero, got ${n}`,
      field: ["t"],
      index: t
    }), e));
  },
  q: (n, t = null, e = null) => {
    const i = [];
    return jt(n) ? (n = parseInt(n), isNaN(n) ? (i.push({
      message: `Quantity value is not understood, got ${n}`,
      field: ["q"],
      index: e
    }), i) : (Zy(n) && i.push({
      message: "Quantity should be an integer.",
      field: ["q"],
      index: e
    }), n <= 0 && (t || i.push({
      message: `Quantity should be greater than or equal to zero, got ${n}`,
      field: ["q"],
      index: e
    })), i)) : (i.push({
      message: "Quantity should be set.",
      field: ["q"],
      index: e
    }), i);
  },
  orientationLock: (n, t = null) => {
    const e = [];
    return jt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Orientation lock must be l or w, got ${n}`,
      field: ["orientationLock"],
      index: t
    })), e;
  },
  grain: (n, t = null) => {
    const e = [];
    return jt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Grain must be l or w, got ${n}`,
      index: t
    })), e;
  },
  stockMatch: (n, t, e, i = 0, r = null) => {
    if (!n.q) return [];
    if (n.applyPartTrim(i), n.issues.length) return [];
    const s = Gb([n], t, e);
    if (!s) return [];
    const o = [];
    if (s.unusableShapes.length) {
      const a = s.unusableShapes[0], l = a.stockMatch;
      if (!l.fit) {
        const h = a.getTrimmedDimensions();
        o.push({
          message: `${h.l.toFixed(0)}x${h.w.toFixed(0)} will not fit on any stock - check trim, dimensions & orientation lock.`,
          field: ["l", "w"],
          index: r
        });
      }
      l.material || o.push({
        message: "No matching stock material found.",
        field: ["material"],
        index: r
      }), l.thickness || o.push({
        message: "No matching stock thickness found.",
        field: ["t"],
        index: r
      }), !l.width && e === "linear" && o.push({
        message: "No matching stock width found - required for linear calculations.",
        field: ["w"],
        index: r
      });
    }
    return o;
  },
  machining: (n, t = null) => {
    n.machining.validateEverything(n, t);
  }
};
function nf(n) {
  let t, e;
  switch (n) {
    case "l":
    case "length":
      t = "guillotine", e = "l";
      break;
    case "w":
    case "width":
      t = "guillotine", e = "w";
      break;
    case "flex":
      t = "guillotine", e = "flex";
      break;
    case "efficiency":
      t = "efficiency", e = "none";
      break;
    case "beam":
      t = "beam", e = "l";
      break;
    default:
      t = null, e = null;
      break;
  }
  return {
    cutPreference: e,
    cutType: t
  };
}
var Z0 = typeof global == "object" && global && global.Object === Object && global, Qy = typeof self == "object" && self && self.Object === Object && self, md = Z0 || Qy || Function("return this")(), sc = md.Symbol, Q0 = Object.prototype, t5 = Q0.hasOwnProperty, e5 = Q0.toString, ul = sc ? sc.toStringTag : void 0;
function n5(n) {
  var t = t5.call(n, ul), e = n[ul];
  try {
    n[ul] = void 0;
    var i = !0;
  } catch {
  }
  var r = e5.call(n);
  return i && (t ? n[ul] = e : delete n[ul]), r;
}
var i5 = Object.prototype, r5 = i5.toString;
function s5(n) {
  return r5.call(n);
}
var o5 = "[object Null]", a5 = "[object Undefined]", Tp = sc ? sc.toStringTag : void 0;
function yd(n) {
  return n == null ? n === void 0 ? a5 : o5 : Tp && Tp in Object(n) ? n5(n) : s5(n);
}
function bd(n) {
  return n != null && typeof n == "object";
}
var l5 = Array.isArray;
function Fc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
function t1(n) {
  return n;
}
var u5 = "[object AsyncFunction]", c5 = "[object Function]", h5 = "[object GeneratorFunction]", f5 = "[object Proxy]";
function e1(n) {
  if (!Fc(n))
    return !1;
  var t = yd(n);
  return t == c5 || t == h5 || t == u5 || t == f5;
}
var wh = md["__core-js_shared__"], Fp = function() {
  var n = /[^.]+$/.exec(wh && wh.keys && wh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function d5(n) {
  return !!Fp && Fp in n;
}
var p5 = Function.prototype, g5 = p5.toString;
function m5(n) {
  if (n != null) {
    try {
      return g5.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var y5 = /[\\^$.*+?()[\]{}|]/g, b5 = /^\[object .+?Constructor\]$/, v5 = Function.prototype, w5 = Object.prototype, x5 = v5.toString, _5 = w5.hasOwnProperty, S5 = RegExp(
  "^" + x5.call(_5).replace(y5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function k5(n) {
  if (!Fc(n) || d5(n))
    return !1;
  var t = e1(n) ? S5 : b5;
  return t.test(m5(n));
}
function A5(n, t) {
  return n == null ? void 0 : n[t];
}
function N5(n, t) {
  var e = A5(n, t);
  return k5(e) ? e : void 0;
}
function C5(n, t, e) {
  switch (e.length) {
    case 0:
      return n.call(t);
    case 1:
      return n.call(t, e[0]);
    case 2:
      return n.call(t, e[0], e[1]);
    case 3:
      return n.call(t, e[0], e[1], e[2]);
  }
  return n.apply(t, e);
}
var P5 = 800, L5 = 16, I5 = Date.now;
function E5(n) {
  var t = 0, e = 0;
  return function() {
    var i = I5(), r = L5 - (i - e);
    if (e = i, r > 0) {
      if (++t >= P5)
        return arguments[0];
    } else
      t = 0;
    return n.apply(void 0, arguments);
  };
}
function O5(n) {
  return function() {
    return n;
  };
}
var Mp = function() {
  try {
    var n = N5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), T5 = Mp ? function(n, t) {
  return Mp(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: O5(t),
    writable: !0
  });
} : t1, F5 = E5(T5), M5 = 9007199254740991, D5 = /^(?:0|[1-9]\d*)$/;
function n1(n, t) {
  var e = typeof n;
  return t = t ?? M5, !!t && (e == "number" || e != "symbol" && D5.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function i1(n, t) {
  return n === t || n !== n && t !== t;
}
var Dp = Math.max;
function R5(n, t, e) {
  return t = Dp(t === void 0 ? n.length - 1 : t, 0), function() {
    for (var i = arguments, r = -1, s = Dp(i.length - t, 0), o = Array(s); ++r < s; )
      o[r] = i[t + r];
    r = -1;
    for (var a = Array(t + 1); ++r < t; )
      a[r] = i[r];
    return a[t] = e(o), C5(n, this, a);
  };
}
function B5(n, t) {
  return F5(R5(n, t, t1), n + "");
}
var j5 = 9007199254740991;
function r1(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= j5;
}
function s1(n) {
  return n != null && r1(n.length) && !e1(n);
}
function q5(n, t, e) {
  if (!Fc(e))
    return !1;
  var i = typeof t;
  return (i == "number" ? s1(e) && n1(t, e.length) : i == "string" && t in e) ? i1(e[t], n) : !1;
}
var z5 = Object.prototype;
function $5(n) {
  var t = n && n.constructor, e = typeof t == "function" && t.prototype || z5;
  return n === e;
}
function U5(n, t) {
  for (var e = -1, i = Array(n); ++e < n; )
    i[e] = t(e);
  return i;
}
var W5 = "[object Arguments]";
function Rp(n) {
  return bd(n) && yd(n) == W5;
}
var o1 = Object.prototype, H5 = o1.hasOwnProperty, G5 = o1.propertyIsEnumerable, V5 = Rp(/* @__PURE__ */ function() {
  return arguments;
}()) ? Rp : function(n) {
  return bd(n) && H5.call(n, "callee") && !G5.call(n, "callee");
};
function Y5() {
  return !1;
}
var a1 = typeof exports == "object" && exports && !exports.nodeType && exports, Bp = a1 && typeof module == "object" && module && !module.nodeType && module, K5 = Bp && Bp.exports === a1, jp = K5 ? md.Buffer : void 0, X5 = jp ? jp.isBuffer : void 0, J5 = X5 || Y5, Z5 = "[object Arguments]", Q5 = "[object Array]", tb = "[object Boolean]", eb = "[object Date]", nb = "[object Error]", ib = "[object Function]", rb = "[object Map]", sb = "[object Number]", ob = "[object Object]", ab = "[object RegExp]", lb = "[object Set]", ub = "[object String]", cb = "[object WeakMap]", hb = "[object ArrayBuffer]", fb = "[object DataView]", db = "[object Float32Array]", pb = "[object Float64Array]", gb = "[object Int8Array]", mb = "[object Int16Array]", yb = "[object Int32Array]", bb = "[object Uint8Array]", vb = "[object Uint8ClampedArray]", wb = "[object Uint16Array]", xb = "[object Uint32Array]", cn = {};
cn[db] = cn[pb] = cn[gb] = cn[mb] = cn[yb] = cn[bb] = cn[vb] = cn[wb] = cn[xb] = !0;
cn[Z5] = cn[Q5] = cn[hb] = cn[tb] = cn[fb] = cn[eb] = cn[nb] = cn[ib] = cn[rb] = cn[sb] = cn[ob] = cn[ab] = cn[lb] = cn[ub] = cn[cb] = !1;
function _b(n) {
  return bd(n) && r1(n.length) && !!cn[yd(n)];
}
function Sb(n) {
  return function(t) {
    return n(t);
  };
}
var l1 = typeof exports == "object" && exports && !exports.nodeType && exports, _l = l1 && typeof module == "object" && module && !module.nodeType && module, kb = _l && _l.exports === l1, xh = kb && Z0.process, qp = function() {
  try {
    var n = _l && _l.require && _l.require("util").types;
    return n || xh && xh.binding && xh.binding("util");
  } catch {
  }
}(), zp = qp && qp.isTypedArray, Ab = zp ? Sb(zp) : _b;
function Nb(n, t) {
  var e = l5(n), i = !e && V5(n), r = !e && !i && J5(n), s = !e && !i && !r && Ab(n), o = e || i || r || s, a = o ? U5(n.length, String) : [], l = a.length;
  for (var h in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (h == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (h == "offset" || h == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || // Skip index properties.
    n1(h, l)) || a.push(h);
  return a;
}
function Cb(n) {
  var t = [];
  if (n != null)
    for (var e in Object(n))
      t.push(e);
  return t;
}
var Pb = Object.prototype, Lb = Pb.hasOwnProperty;
function Ib(n) {
  if (!Fc(n))
    return Cb(n);
  var t = $5(n), e = [];
  for (var i in n)
    i == "constructor" && (t || !Lb.call(n, i)) || e.push(i);
  return e;
}
function Eb(n) {
  return s1(n) ? Nb(n) : Ib(n);
}
var u1 = Object.prototype, Ob = u1.hasOwnProperty, yl = B5(function(n, t) {
  n = Object(n);
  var e = -1, i = t.length, r = i > 2 ? t[2] : void 0;
  for (r && q5(t[0], t[1], r) && (i = 1); ++e < i; )
    for (var s = t[e], o = Eb(s), a = -1, l = o.length; ++a < l; ) {
      var h = o[a], u = n[h];
      (u === void 0 || i1(u, u1[h]) && !Ob.call(n, h)) && (n[h] = s[h]);
    }
  return n;
});
function Tb(n, t, e) {
  if (!ql.includes(t) || !n.machining.corners) return 0;
  const i = c1(n, t);
  return e * i;
}
function c1(n, t) {
  if (!ql.includes(t) || !n.machining.corners) return 0;
  const e = n.machining.corners.find((r) => r.getCorner() === t);
  return e ? e.getLength() : 0;
}
function h1(n, t, e, i) {
  Object.keys(t).forEach((r) => {
    var s, o;
    r in n && ((s = t[r]) != null && s.min && Qt(n[r]) < Qt(t[r].min) ? e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be less than ${t[r].min}.`,
      fields: [r]
    }) : (o = t[r]) != null && o.max && Qt(n[r]) > Qt(t[r].max) && e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be greater than ${t[r].max}.`,
      fields: [r]
    }));
  });
}
class rf {
  constructor({ x: t, y: e, diameter: i, depth: r = 0, face: s = 0, type: o = null }) {
    et(this, "x");
    et(this, "y");
    et(this, "diameter");
    et(this, "depth");
    et(this, "face");
    et(this, "valid");
    et(this, "type");
    this.x = t, this.y = e, this.diameter = i, this.depth = r, this.face = s, this.type = o;
  }
  getFace() {
    return hr[this.face];
  }
  getXDrawPosition(t) {
    let e = 0;
    const i = Qt(this.x);
    return t.rot ? e = t.l - Qt(this.y) + ("x" in t ? Qt(t.x) : 0) : e = i + ("x" in t ? Qt(t.x) : 0), e;
  }
  getYDrawPosition(t, e, i) {
    let r = t.rot ? Qt(this.x) : Qt(this.y);
    return r += "y" in t ? Qt(t.y) : 0, e === 1 && (i ? r = Qt(i.w) - r : r = Qt(t.w) - r), r;
  }
  shouldShow(t, e) {
    return this.face === e || this.isThroughShape(t) === !0;
  }
  isThroughShape(t) {
    return !this.depth || Qt(this.depth) >= Qt(t.t);
  }
  getDistanceToEdge(t) {
    const e = this.x, i = this.y, r = this.diameter / 2, s = Qt(t.getLongSide()), o = Qt(t.getShortSide()), a = t.machining.corners.map((g) => g.type ? g.size : 0), l = [
      {
        edge: "left",
        distance: e - r
      },
      {
        edge: "right",
        distance: s - e - r
      },
      {
        edge: "bottom",
        distance: o - i - r
      },
      {
        edge: "top",
        distance: i - r
      }
    ], h = t.machining.corners.map((g, b) => {
      const x = b === 0 || b === 3, y = b < 2, v = x ? e : s - e;
      let k = null;
      this.face === 0 ? k = y ? i : o - i : this.face === 1 && (k = y ? o - i : i);
      const C = Math.sqrt(v * v + k * k);
      return {
        c: g,
        distance: C
      };
    }), u = Math.min(...l.map((g) => g.distance)), d = Math.min(...h.map((g) => g.distance)), p = h.findIndex((g) => g.distance === d), f = t.machining.corners[p];
    if (f && f.type === "radius") {
      let g = p === 0 || p === 3 ? 0 : s, b = p < 2 ? 0 : o;
      const x = p < 2;
      g += p === 0 || p === 3 ? a[p] : -a[p], b += x ? a[p] : -a[p];
      const v = e - g, k = p < 2;
      let C;
      this.face === 0 ? C = k ? i : o - i : this.face === 1 && (C = k ? o - i : i);
      const I = C - b, D = Math.sqrt(v * v + I * I), E = a[p] - D - r;
      let O = !1;
      return f.index === 0 ? O = e <= g && C <= b : f.index === 1 ? O = e >= g && C <= b : f.index === 2 ? O = e >= g && C >= b : f.index === 3 && (O = e <= g && C >= b), O && E < u ? E : u;
    } else if (f && f.type === "bevel") {
      let g, b, x;
      f.index === 0 ? (g = 1, b = 1, x = -f.size) : f.index === 1 ? (g = 1, b = -1, x = -s + f.size) : f.index === 2 ? (g = 1, b = 1, x = -s - o + f.size) : f.index === 3 && (g = -1, b = 1, x = -o + f.size);
      const y = f.index === 0 ? 1 : -1, v = (g * e + b * i + x) / Math.sqrt(g * g + b * b) * y - r;
      return v < u ? v : u;
    } else
      return u;
  }
  validate(t, e, i = null) {
    const r = [];
    if (!jt(this.x) || !jt(this.y) || !jt(this.diameter)) {
      const o = {
        index: e,
        message: "X, Y & diameter are all required.",
        fields: []
      };
      this.x || o.fields.push("x"), this.y || o.fields.push("y"), this.diameter || o.fields.push("diameter"), r.push(o);
    }
    return Qt(this.diameter) <= 0 && r.push({
      index: e,
      message: "Diameter cannot be negative or zero.",
      fields: ["diameter"]
    }), Qt(this.depth) < 0 && r.push({
      index: e,
      message: "Depth cannot be negative.",
      fields: ["depth"]
    }), "t" in t && Qt(t.t) > 0 && Qt(this.depth) > Qt(t.t) && r.push({
      index: e,
      message: "Depth cannot be greater than part thickness.",
      fields: ["depth"]
    }), (!("t" in t) || !t.t) && Qt(this.depth) > 0 && r.push({
      index: e,
      message: "Part thickness is not defined.",
      fields: ["depth"]
    }), this.getDistanceToEdge(t) < 0 && r.push({
      index: e,
      message: "Outside of part."
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class $p {
  constructor({
    position: t = null,
    //from left or bottom
    edge: e = "x1",
    face: i = 0,
    numHoles: r = null,
    diameter: s = 0,
    depth: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    hingeLength: h = 0,
    minimumHoleDistance: u = 0,
    positionLimit: d = 0
  }, p) {
    et(this, "position");
    et(this, "edge");
    et(this, "face");
    et(this, "numHoles");
    et(this, "holes", []);
    et(this, "diameter");
    et(this, "depth");
    et(this, "distanceFromEdge");
    //from edge to center of hole
    et(this, "outerSpacing");
    //from edge to center of hole
    et(this, "hingeLength");
    et(this, "minimumHoleDistance");
    et(this, "positionLimit");
    et(this, "valid");
    this.position = t, this.edge = e, this.face = i, this.numHoles = r, this.diameter = s, this.depth = o, this.distanceFromEdge = a, this.outerSpacing = l, this.hingeLength = h, this.minimumHoleDistance = u, this.positionLimit = d, p && this.createHoles(p);
  }
  getFace() {
    return hr[this.face];
  }
  getHoleSpacing() {
    const t = Qt(this.hingeLength) - Qt(this.outerSpacing) * 2, e = this.numHoles - 1;
    return t / e;
  }
  getHoleXPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
        i = this.distanceFromEdge;
        break;
      case "x2":
        i = t.getLongSide() - Qt(this.distanceFromEdge);
        break;
      case "y1":
      case "y2":
        i = Qt(this.position) + Qt(this.outerSpacing) + r * e;
        break;
    }
    return i;
  }
  getHoleYPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
      case "x2":
        i = Qt(this.position) + Qt(this.outerSpacing) + r * e;
        break;
      case "y1":
        i = Qt(this.distanceFromEdge);
        break;
      case "y2":
        i = t.getShortSide() - Qt(this.distanceFromEdge);
        break;
    }
    return i;
  }
  createHoles(t) {
    this.holes = [];
    for (let e = 0; e < this.numHoles; e++) {
      const i = new rf({
        x: this.getHoleXPosition(t, e),
        y: this.getHoleYPosition(t, e),
        diameter: this.diameter,
        depth: this.depth,
        face: this.face,
        type: "hinge"
      });
      this.holes.push(i);
    }
    return this.holes;
  }
  validate(t, e, i = null) {
    const r = [];
    return this.holes.forEach((s, o) => {
      const a = s.validate(t, o).map((l) => (l.index = e, l.message = `Hole ${o + 1}: ${l.message}`, l));
      r.push(...a);
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class Up {
  constructor({ type: t = "radius", size: e, index: i }) {
    et(this, "type");
    et(this, "size");
    et(this, "index");
    et(this, "valid");
    this.type = t, this.size = e, this.index = i;
  }
  getLength() {
    return this.type === "radius" ? Math.PI * this.size / 2 : this.type === "bevel" ? Math.sqrt(2) * this.size : 0;
  }
  getCorner() {
    return ["a", "b", "c", "d"][this.index];
  }
  isPresent() {
    return (this.valid === !0 || this.valid === void 0) && this.type !== null && this.size > 0;
  }
  validate(t, e) {
    const i = t.getShortSide(), r = [];
    if (this.type === null) {
      this.size = null;
      const s = this.getCorner();
      t.banding[s] = !1;
    }
    return this.type && Qt(this.size) <= 0 && r.push({
      index: e,
      message: "Corner size cannot be zero or negative"
    }), this.type && Qt(this.size) > i / 2 && (this.size = i / 2), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class f1 {
  //shelfHoles?: ShelfHoles[] = [];
  constructor({
    holes: t = [],
    hingeHoles: e = [],
    corners: i = []
  } = {}) {
    et(this, "holes", []);
    et(this, "corners", []);
    et(this, "hingeHoles", []);
    i && i.length === 4 ? this.corners = i.map((r) => new Up(r)) : [0, 1, 2, 3].forEach((r) => {
      this.corners.push(new Up({
        type: null,
        size: null,
        index: r
      }));
    }), t && (this.holes = t.map((r) => new rf(r))), e && (this.hingeHoles = e.map((r) => new $p(r)));
  }
  validateEverything(t, e = null) {
    const i = this.validate(t, "holes"), r = this.validate(t, "hingeHoles"), s = this.validate(t, "corners");
    t.issues.push(...i.map((o) => pr(t) ? { message: `Part ${t.id} hole issue: ${o.message}`, index: e } : { message: `Hole issue: ${o.message}`, index: e })), t.issues.push(...r.map((o) => pr(t) ? { message: `Part ${t.id} hinge hole issue: ${o.message}`, index: e } : { message: `Hinge hole issue: ${o.message}`, index: e })), t.issues.push(...s.map((o) => pr(t) ? { message: `Part ${t.id} corner issue: ${o.message}`, index: e } : { message: `Corner issue: ${o.message}`, index: e }));
  }
  validate(t, e, i = null) {
    if (!t) return [];
    if (!e) return [];
    const r = [];
    return r.push(...this.validateAll(t, e, i)), r;
  }
  validateAll(t, e, i = null) {
    if (!t) return [];
    const r = [];
    return this[e].forEach((s, o) => r.push(...s.validate(t, o, i))), r;
  }
  createHole(t, e, i, r = 0, s = 0) {
    const o = new rf({
      x: t,
      y: e,
      diameter: i,
      depth: r,
      face: s
    });
    return this.holes.push(o), o;
  }
  createHingeHoles({
    numHoles: t,
    position: e,
    diameter: i,
    depth: r = 0,
    edge: s = "x1",
    face: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    minimumHoleDistance: h = 0,
    hingeLength: u = 0
  }) {
    const d = new $p({
      numHoles: t,
      position: e,
      //from left or bottom
      edge: s,
      face: o,
      diameter: i,
      depth: r,
      distanceFromEdge: a,
      outerSpacing: l,
      minimumHoleDistance: h,
      hingeLength: u
    });
    return this.hingeHoles.push(d), d;
  }
  updateHingeHoles(t) {
    this.hingeHoles.forEach((e) => e.createHoles(t));
  }
  getAllHingeHoles(t) {
    const e = [];
    return this.hingeHoles.forEach((i) => {
      i.holes.length ? e.push(...i.holes) : (i.createHoles(t), e.push(...i.holes));
    }), e;
  }
  getNumHoles() {
    return this.holes.length + this.hingeHoles.reduce(
      (t, e) => t + e.numHoles,
      0
    );
  }
  getNumCorners() {
    return this.corners.filter((t) => t.type !== null).length;
  }
}
function d1(n) {
  var t, e, i, r, s, o, a, l;
  return !n || !(n != null && n.machining) ? !1 : (e = (t = n.machining) == null ? void 0 : t.holes) != null && e.length || (r = (i = n.machining) == null ? void 0 : i.hingeHoles) != null && r.length ? !0 : (o = (s = n.machining) == null ? void 0 : s.corners) != null && o.length ? (l = (a = n.machining) == null ? void 0 : a.corners) == null ? void 0 : l.some((h) => h.type && h.size) : !1;
}
function Fb(n) {
  var t, e, i, r;
  if ("machining" in n) {
    if (!d1(n)) {
      n.machining = null;
      return;
    }
    (t = n.machining.holes) != null && t.length || (n.machining.holes = null), (e = n.machining.hingeHoles) != null && e.length || (n.machining.hingeHoles = null), (r = (i = n.machining) == null ? void 0 : i.corners) != null && r.some((s) => s.type && s.size) || (n.machining.corners = null);
  }
}
class Mb {
  constructor(t = null) {
    et(this, "id");
    //api
    et(this, "listId");
    et(this, "shapeListIds", []);
    et(this, "shapes");
    et(this, "direction");
    et(this, "q");
    et(this, "duplicate", !1);
    et(this, "issues", []);
    et(this, "stockMatch");
    var e;
    this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Math.ceil(Math.random() * 1e16), this.id = t == null ? void 0 : t.id, this.shapes = jt(t == null ? void 0 : t.shapes) ? t.shapes.map((i) => i.toString()) : [], this.shapeListIds = jt(t == null ? void 0 : t.shapeListIds) ? t.shapeListIds : [], this.direction = jt(t == null ? void 0 : t.direction) ? t.direction : "l", this.q = jt(t == null ? void 0 : t.q) ? t.q : 1, jt(t == null ? void 0 : t.shapeList) && ((e = t.shapeList) != null && e.length) && this.validate(t.shapeList);
  }
  validate(t = []) {
    var o, a;
    if (this.issues = [], !(t != null && t.length))
      throw new Error("shapeList is required to validate user group");
    const e = this.findShapes(t);
    if (!e.length)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    const i = e[0];
    if (pr(i)) {
      if (!(this != null && this.shapes) || ((o = this.shapes) == null ? void 0 : o.length) < 2)
        return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    } else if (!(this != null && this.shapeListIds) || ((a = this.shapeListIds) == null ? void 0 : a.length) < 2)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    if (e.forEach((l, h) => {
      !l.isSquare() && !["l", "w"].includes(l.orientationLock) && this.issues.push({ message: `Part in position ${h + 1} must have orientation lock set to be part of a group.` });
    }), this.issues.length) return this.issues;
    const r = Ao(this.direction), s = i.getTrimmedDimensions(!0)[r];
    return e.forEach((l, h) => {
      if (l.id === i.id) return;
      const u = l.getTrimmedDimensions(!0)[r];
      Ge.equalTo(u, s) || this.issues.push({ message: `Part in position ${h + 1} final ${r === "l" ? "length" : "width"} is not correct for the group. Expected ${s} and is ${u}. Check the dimensions, trim & orientation lock.` });
    }), this.issues;
  }
  findShapes(t = []) {
    var i, r;
    if (!t.length) return [];
    let e = [];
    if (Cr(t[0])) {
      if (!((i = this.shapeListIds) != null && i.length)) return [];
      if (e = this.shapeListIds.map((s) => t.find((o) => o.listId === s)).filter((s) => s), !e.length)
        throw new Error("could not map group shapes to shape list");
      return e;
    } else {
      if (!((r = this.shapes) != null && r.length)) return [];
      const s = /* @__PURE__ */ new Set();
      e = this.shapes.map((o) => {
        const a = t.find((l) => l.parentID === o && !l.inUserGroup && !s.has(l.id));
        return a ? (s.add(a.id), a) : null;
      }).filter((o) => o);
    }
    if (!e.length)
      throw new Error("could not map group shapes to shape list");
    return e;
  }
  populateParentID(t) {
    var e;
    t != null && t.length && (e = this == null ? void 0 : this.shapeListIds) != null && e.length && (this.shapes = this.shapeListIds.map((i) => (t.findIndex((s) => s.listId === i) + 1).toString()));
  }
  //create a group from a user group
  createGroup(t = 0, e = 0, i = [], r = null) {
    if (!(i != null && i.length))
      throw new Error("some parts are required to create a user group");
    if (!pr(i[0]))
      throw new Error("shapeList must be of type Shape[]");
    const s = this.findShapes(i);
    if (!s.length) return !1;
    const o = s[0];
    s.forEach((u) => {
      const d = i.findIndex((p) => !p.inUserGroup && p.parentID === u.parentID);
      if (d === -1)
        throw new Error("shape not found in shapeList while creating user group.");
      i.splice(d, 1), u.setRotationToOrientationLockWithoutContainer(), u.inUserGroup = !0;
    });
    let a = 0, l = 0;
    this.direction === "l" ? l = o.w : a = o.l;
    let h;
    try {
      const u = {
        id: `ug${t}.${e}`,
        shapes: s,
        l: a,
        w: l,
        t: o == null ? void 0 : o.t,
        material: o == null ? void 0 : o.material,
        // joinDimension:
        //     referenceShape.l === l ? referenceShape.l : referenceShape.w,
        direction: this.direction,
        preventAutoRotation: !0,
        container: r,
        type: "user"
      };
      h = new Ws(u);
    } catch (u) {
      return console.error(u), !1;
    }
    return h.parentID = `ug${t}`, r && h.updateShapeSpacing(r), h;
  }
}
const dr = ["y1", "y2", "x1", "x2"], ql = ["a", "b", "c", "d"], Fs = [...dr, ...ql], hr = ["a", "b"];
function p1(n) {
  return ql.includes(n);
}
function Db(n) {
  return Fs.includes(n);
}
const sf = {
  x: "x",
  y: "y",
  l: "length",
  w: "width",
  t: "thickness",
  q: "quantity",
  orientationLock: "rotation",
  name: "name",
  material: "material",
  banding: "banding",
  finish: "finish",
  cost: "cost",
  grain: "grain",
  trim: "trim",
  x1: "w1",
  x2: "w2",
  y1: "l1",
  y2: "l2",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  all: "all"
};
function Rb(n) {
  return dr.map((t) => n[t] ?? null);
}
function Co(n) {
  if (!jt(n) || typeof n != "object") return {};
  n = { ...n };
  for (const [t, e] of Object.entries(n))
    t !== "_id" && t.startsWith("_") && (n[t.substring(1)] = e, delete n[t]);
  return n;
}
function Bb(n, t = null) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    var i;
    return delete e.id, t ? e.units = t : e.units || (e.units = ((i = this == null ? void 0 : this.optionsStore) == null ? void 0 : i.units) ?? "decimal"), new vd(e);
  });
}
function jb({
  stockList: n,
  removeScores: t = !1,
  saw: e = null,
  preventAutoRotation: i = !1,
  preventGrainRotation: r = !1
}) {
  return !n || !(n != null && n.length) ? [] : n.filter((s) => s).map((s) => {
    e && (s.saw = e), i && (s.preventAutoRotation = !0), r && (s.preventGrainRotation = !0);
    const o = new ts(s);
    if (o.issues.length)
      throw new Error(
        `Issues found when attempting to recreate stock list - ${o.issues.map((a) => a.message).join()}`,
        { cause: o.issues }
      );
    return t && delete o.algoBenchmark, o;
  }).sort(Ju.ID);
}
function qb({
  shapeList: n,
  stockList: t,
  preventAutoRotation: e = !1
}) {
  if (typeof t > "u")
    throw new Error("recreateShapeList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.filter((i) => i).map((i) => {
    var o;
    e && (i.preventAutoRotation = !0);
    let r;
    if (Yb(i) && ((o = i == null ? void 0 : i.shapes) != null && o.length)) {
      i.shapes = i.shapes.map((a) => new es(a));
      try {
        r = new Ws(i);
      } catch {
        throw new Error("error creating group from shape data");
      }
    } else
      r = new es(i);
    if (r.issues.length)
      throw new Error(`Issues found when attempting to recreate shape list - ${r.issues.join()}`);
    const s = t.find((a) => {
      var l;
      return a.id === (((l = i == null ? void 0 : i.stock) == null ? void 0 : l.id) ?? (i == null ? void 0 : i.stockId));
    });
    return r.stock = s, r;
  }).sort(Ju.ID);
}
function zb({
  cutList: n,
  stockList: t
}) {
  if (typeof t > "u")
    throw new Error("recreateCutList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = new Tc(e), r = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return i.stock = r, i;
  });
}
function $b({
  segmentList: n,
  stockList: t
}) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return e.stock = i, new y1(e);
  });
}
function g1(n = null, t = null, e = null) {
  if (!n) throw new Error("no container supplied to willItFit");
  if (!t) throw new Error("no shape supplied to willItFit");
  const i = t.rot;
  function r(p = !1, f = "l") {
    var g, b;
    return Ge.equalTo(
      t[p ? Ao(f) : f],
      n[f]
    ) || Ge.lessThanOrEqualTo(t[p ? Ao(f) : f], n[f] - (of(n) ? (b = (g = n == null ? void 0 : n.saw) == null ? void 0 : g.options) == null ? void 0 : b.minSpacing : 0));
  }
  function s(p = !0) {
    return t.forceRotate(i), p;
  }
  const o = t.getNecessaryOrientation(n);
  let a = null;
  if (o && (a = o === "l" ? 0 : 1), t.orientationLock) {
    if (jt(e) && e !== a)
      return s(!1);
    t.forceRotate(a);
  } else jt(e) && t.forceRotate(e);
  if (a && t.rot !== a)
    return s(!1);
  const l = r(!1, "l"), h = r(!1, "w"), u = r(!0, "l"), d = r(!0, "w");
  return jt(e) || o ? s(l && h) : s(l && h || u && d);
}
function oc(n, t, e = "decimal", i = !1) {
  return jt(n == null ? void 0 : n[t]) ? Qt(n[t], e, !1, i) : null;
}
class m1 {
  constructor(t, e = !1) {
    et(this, "readonly");
    et(this, "id");
    et(this, "listId");
    et(this, "units", "decimal");
    et(this, "l");
    et(this, "w");
    et(this, "t");
    et(this, "q");
    et(this, "name");
    et(this, "material");
    et(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    et(this, "cost", null);
    et(this, "grain", "");
    et(this, "selected", !1);
    //used for multiple editing
    et(this, "multiEdit", !1);
    //is this the multi-select stock
    et(this, "type", null);
    et(this, "autoAdd", !1);
    et(this, "used");
    et(this, "saw");
    et(this, "preventGrainRotation");
    et(this, "allowExactFitShapes");
    et(this, "issues", []);
    et(this, "warnings", []);
    et(this, "notes", "");
    var s, o;
    t = Co(t), jt(t.units) || console.warn("Attempting to create InputStock without units"), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((a) => {
      this[a] = oc(t, a, this.units, e);
    }), this.q = jt(t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.autoAdd = jt(t.autoAdd) ? t.autoAdd : !1, this.name = jt(t.name) ? $l(t.name).toUpperCase() : "", this.material = jt(t.material) ? t.material.trim().toUpperCase() : "";
    const r = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }, r.forEach((a) => {
      this.trim[a] = oc(t.trim, a, this.units, e);
    }), this.cost = jt(t.cost) ? t.cost : null, t.grain = (s = t == null ? void 0 : t.grain) == null ? void 0 : s.toLowerCase(), (t == null ? void 0 : t.grain) === " " && (t.grain = ""), this.grain = t.grain, this.multiEdit = t.multiEdit, this.type = t.type, this.allowExactFitShapes = jt(t == null ? void 0 : t.allowExactFitShapes) ? t.allowExactFitShapes : !1, this.preventGrainRotation = !0, this.notes = t != null && t.notes ? (o = t.notes) == null ? void 0 : o.replace(/,/g, "") : "";
  }
  //change the units of the stock
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? Qt(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = jt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  //change the type of stock
  changeType(t) {
    switch (t !== "sheet" && (this.grain = ""), t) {
      case "linear":
        this.trim.y1 = 0, this.trim.y2 = 0;
        break;
      case "roll":
        this.trim.x1 = 0, this.trim.x2 = 0, this.trim.y1 = 0, this.trim.y2 = 0, this.t = null;
        break;
    }
  }
  //create an id from an index
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  isSquare() {
    return this.l === this.w;
  }
  getWarnings() {
    this.warnings = [], ["q"].forEach((t) => this.warnings.push(...li[t](this[t])));
  }
  validate() {
    return this.issues = [], ["l", "w", "t"].forEach((t) => this.issues.push(...li[t](this[t]))), this.issues.push(...li.trim(this)), this.getWarnings(), this.issues;
  }
}
class vd {
  constructor(t, e = !1) {
    et(this, "readonly");
    et(this, "id");
    et(this, "listId");
    et(this, "units", "decimal");
    et(this, "l");
    et(this, "w");
    et(this, "t");
    et(this, "q", 1);
    et(this, "name", "");
    et(this, "material", "");
    et(this, "cost");
    et(this, "orientationLock");
    et(this, "selectedMaterial");
    et(this, "selected", !1);
    //used for multiple editing
    et(this, "multiEdit", !1);
    et(this, "issues", []);
    et(this, "warnings", []);
    et(this, "notes", "");
    et(this, "stockLock");
    et(this, "stockMatch");
    et(this, "customData");
    //objects
    et(this, "machining");
    et(this, "trim", Object.fromEntries(
      dr.map((t) => [t, 0])
    ));
    et(this, "banding", Object.fromEntries(
      Fs.map((t) => [t, !1])
    ));
    et(this, "bandingOptions", Object.fromEntries([
      ...Fs,
      "all"
    ].map((t) => [t, {}])));
    et(this, "finish", Object.fromEntries(
      hr.map((t) => [t, ""])
    ));
    et(this, "finishOptions", Object.fromEntries(
      hr.map((t) => [t, {}])
    ));
    var r, s, o, a, l;
    t = t = Co(t), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((h) => {
      this[h] = oc(t, h, this.units, e);
    }), this.q = jt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.name = jt(t.name) ? $l(t.name).toUpperCase() : "", this.material = jt(t.material) ? t.material.trim().toUpperCase() : "", this.multiEdit = t.multiEdit, this.notes = t != null && t.notes ? (r = t.notes) == null ? void 0 : r.replace(/,/g, "") : "", this.stockLock = (t == null ? void 0 : t.stockLock) ?? [];
    for (const h of Object.keys(this.trim))
      this.trim[h] = oc(t.trim, h, this.units, e);
    for (const h of Object.keys(this.banding))
      this.banding[h] = jt((s = t == null ? void 0 : t.banding) == null ? void 0 : s[h]) ? t.banding[h] : !1;
    for (const h of Object.keys(this.bandingOptions))
      this.bandingOptions[h] = jt((o = t == null ? void 0 : t.bandingOptions) == null ? void 0 : o[h]) ? t.bandingOptions[h] : {};
    for (const h of Object.keys(this.finish))
      this.finish[h] = jt((a = t == null ? void 0 : t.finish) == null ? void 0 : a[h]) ? t.finish[h] : "";
    for (const h of Object.keys(this.finishOptions))
      this.finishOptions[h] = jt((l = t == null ? void 0 : t.finishOptions) == null ? void 0 : l[h]) ? t.finishOptions[h] : {};
    this.orientationLock = jt(t.orientationLock) ? t.orientationLock.toLowerCase() : "", this.machining = new f1(t.machining ?? {
      holes: [],
      hingeHoles: [],
      corners: []
    }), this.customData = (t == null ? void 0 : t.customData) ?? {};
  }
  /**
   * change the units of the shape
   * @param {String} newUnits
   */
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? Qt(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = jt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  isSquare() {
    return this.l === this.w;
  }
  /**
   * change the type of the stock
   * @param {String} newType
   */
  changeStockType(t) {
    switch (t) {
      case "sheet":
      case "roll":
        this.orientationLock = "", t === "roll" && (this.t = null);
        break;
      case "linear":
        this.orientationLock = "", this.banding = Object.fromEntries(
          Fs.map((e) => [e, !1])
        );
        break;
    }
  }
  /**
   * create an id from an index
   * @param {Integer} index
   * @param {Integer} secondaryIndex
   */
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  getLongSide() {
    return Qt(this.l) > Qt(this.w) ? Qt(this.l) : Qt(this.w);
  }
  getShortSide() {
    return Qt(this.l) < Qt(this.w) ? Qt(this.l) : Qt(this.w);
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      name: this.name,
      listId: this.listId,
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      name: this.name,
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: Qt(this.l), w: Qt(this.w) };
    return t && (e = this.getRotatedDimensions()), {
      name: this.name,
      listId: this.listId,
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2),
      orientationLock: this.orientationLock
    };
  }
  //used to apply a single trim value to all sides
  applyPartTrim(t, e) {
    if (!this.readonly)
      if (t = Qt(t), this.trim) {
        for (const i in this.trim)
          this.trim[i] = t;
        e === "linear" && (this.trim.y1 = 0, this.trim.y2 = 0);
      } else
        this.trim = {
          x1: t,
          x2: t,
          y1: e !== "linear" ? t : 0,
          y2: e !== "linear" ? t : 0
        };
  }
  /**
   * to align with Shape
   * @remarks input shapes are always 0
   */
  get rot() {
    return 0;
  }
  validate(t, e, i, r = 0, s = !1) {
    return this.issues = [], ["l", "w", "t"].forEach((o) => {
      const a = li[o](this[o], e);
      a.length && this.issues.push(...a);
    }), r = Qt(r), this.issues.push(...li.partTrim(this, r, e)), this.issues.push(...li.trim(this, e)), li.machining(this, e), this.getWarnings(t, e, i, r, s), this.issues;
  }
  getWarnings(t, e = null, i, r = 0, s = !1) {
    this.warnings = [], ["q"].forEach((o) => {
      this.warnings.push(...li[o](this[o], e));
    }), t.length && !s && this.warnings.push(...li.stockMatch(this, t, i, r, e));
  }
}
class zl {
  constructor(t) {
    et(this, "id");
    et(this, "parentID");
    et(this, "name");
    et(this, "x");
    et(this, "y");
    et(this, "l");
    et(this, "w");
    et(this, "t");
    et(this, "q");
    et(this, "material");
    et(this, "grain");
    et(this, "orientationLock");
    et(this, "duplicate");
    et(this, "trimmed");
    et(this, "preventAutoRotation");
    et(this, "preventGrainRotation");
    et(this, "units");
    et(this, "issues", []);
    et(this, "stock");
    et(this, "stockId");
    //used when object is compressed
    et(this, "cost");
    et(this, "offcut");
    et(this, "notes");
    //for user notes
    et(this, "proximity");
    //objects
    et(this, "_trim", Object.fromEntries(
      dr.map((t) => [t, 0])
    ));
    et(this, "customData");
    this.initRectangle(t);
  }
  validateRectangle(t) {
    Nr(this) || ["x", "y", "l", "w", "t"].forEach((e) => {
      this.createIssues(li[e](t[e]));
    }), Qr(this) && "q" in t && this.createIssues(li.q((t == null ? void 0 : t.q) ?? 0, t.autoAdd)), "q" in t && this.isShape() && !this.isGroup() && !this.isUserGroup() && this.createIssues(li.q((t == null ? void 0 : t.q) ?? 0)), "customData" in t && this.createIssues(li.customData((t == null ? void 0 : t.customData) ?? {}));
  }
  initRectangle(t, e = !1) {
    var r, s, o;
    if (!e) {
      if (this.validateRectangle(t), this.issues.length) return;
      this.id = jt(t.id) ? t.id.toString() : this.id || null, this.setParentID(), jt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? this.q = parseInt(t.q) : this.q = t.q : this.q = 0, this.name = jt(t.name) && ((r = t == null ? void 0 : t.name) != null && r.length) ? (s = b1($l(t == null ? void 0 : t.name))) == null ? void 0 : s.toUpperCase() : null, jt(t == null ? void 0 : t.cost) ? typeof t.cost == "string" ? this.cost = parseFloat(t.cost) : typeof t.cost == "number" && (this.cost = t.cost) : this.cost = 0, this.material = jt(t.material) ? t.material.trim().toLowerCase() : null, this.duplicate = jt(t == null ? void 0 : t.duplicate) ? t.duplicate : !1, this.grain = typeof t.grain < "u" && jt(t == null ? void 0 : t.grain) ? t.grain.toLowerCase() : null, this.trimmed = jt(t == null ? void 0 : t.trimmed) ? t.trimmed : !1, this.offcut = jt(t == null ? void 0 : t.offcut) ? t.offcut : !1, this.notes = typeof (t == null ? void 0 : t.notes) == "string" && t.notes.length ? t.notes.replace(/,/g, "").substring(0, 200) : "", this.customData = (t == null ? void 0 : t.customData) ?? {}, this.proximity = {
        rectangle: null,
        distance: null
      };
      try {
        this.trim = t == null ? void 0 : t.trim;
      } catch (a) {
        if ((o = a == null ? void 0 : a.cause) != null && o.issues) this.issues.push(...a.cause.issues);
        else throw new Error("error when attempting to set trim");
      }
    }
    [
      {
        key: "x",
        default: 0,
        required: !1
      },
      {
        key: "y",
        default: 0,
        required: !1
      },
      {
        key: "l",
        default: null,
        required: !0
      },
      {
        key: "w",
        default: 1,
        //for linear
        required: !0
      },
      {
        key: "t",
        default: null,
        required: !1
      }
    ].forEach((a) => {
      let l = t[a.key];
      if (!jt(l))
        return this[a.key] = this[a.key] || a.default;
      typeof l == "string" && (l = Qt(l)), this[a.key] = l;
    }), !(t != null && t.preventAutoRotation) && !t.trimmed && this.w > this.l && ([this.l, this.w] = [this.w, this.l], this.grain && !(t != null && t.preventGrainRotation) && (this.grain = Ao(this.grain))), jt(t == null ? void 0 : t.stock) && (Qr(t.stock) ? this.stock = t.stock : this.stock = new ts(t.stock), this.stockId = this.stock.id);
  }
  updateRectangle(t) {
    t.preventAutoRotation = !0, this.initRectangle(t, !0);
  }
  set trim(t) {
    if (this._trim = Object.fromEntries(
      dr.map((e) => [e, 0])
    ), !!Po(t, !0))
      for (const e of dr) {
        let i;
        if (typeof t[e] == "string") {
          const r = Qt(t[e]);
          isNaN(r) || r < 0 ? (this.issues.push(
            this.createIssue(
              `${t[e] ?? "N/A"} is not a valid value for trim: ${e}`
            )
          ), i = 0) : i = r;
        } else
          i = t[e];
        this._trim[e] = i;
      }
  }
  get trim() {
    return this._trim;
  }
  get rot() {
    return this.w > this.l ? 1 : 0;
  }
  setParentID() {
    this.parentID = this.getParentID();
  }
  getParentID() {
    return this.id ? this.parentID ? this.parentID : typeof this.id != "number" && this.id.includes(".") ? this.id.split(".")[0] : typeof this.id != "number" && !this.id.includes(".") ? null : this != null && this.id ? this.id.toString() : null : null;
  }
  getCopyNumber() {
    return typeof this.id != "number" && this.id.includes(".") ? parseInt(this.id.split(".")[1]) : 0;
  }
  createIssues(t) {
    t != null && t.length && t.forEach((e) => {
      this.issues.push(this.createIssue(e.message, e.field));
    });
  }
  createIssue(t, e = null) {
    var o;
    let i = "";
    const r = this.getClass();
    switch (r) {
      case "Shape":
        i = "part";
        break;
      case "Stock":
        i = "stock";
        break;
      default:
        i = r.toLowerCase();
        break;
    }
    const s = (o = this == null ? void 0 : this.name) != null && o.length ? this.name.toUpperCase() : this.parentID;
    return s ? {
      message: `${t} [${i.charAt(0).toUpperCase() + i.slice(1)} ${s}]`,
      field: e
    } : { message: t, field: e };
  }
  dimensions() {
    return {
      id: this.id,
      l: this.l,
      w: this.w,
      t: this.t
    };
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  coords() {
    return {
      id: this.id,
      x: this.x,
      y: this.y
    };
  }
  hasCoords(t, e) {
    return this.x === t && this.y === e;
  }
  getAspect() {
    return this.l > this.w ? this.w / this.l : this.l / this.w;
  }
  getPerimeter() {
    return this.w * 2 + this.l * 2;
  }
  getLongSide() {
    return this.l > this.w ? this.l : this.w;
  }
  getShortSide() {
    return this.l < this.w ? this.l : this.w;
  }
  getSides() {
    return [
      this.getSide("bottom"),
      this.getSide("right"),
      this.getSide("top"),
      this.getSide("left")
    ];
  }
  getSide(t) {
    switch (t) {
      case "bottom":
        return new ga({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y,
          type: "bottom"
          // parentID: this.id
        });
      case "right":
        return new ga({
          x1: this.x + this.l,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y + this.w,
          type: "right"
          // parentID: this.id
        });
      case "top":
        return new ga({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y + this.w,
          y2: this.y + this.w,
          type: "top"
          // parentID: this.id
        });
      case "left":
        return new ga({
          x1: this.x,
          x2: this.x,
          y1: this.y,
          y2: this.y + this.w,
          type: "left"
          // parentID: this.id
        });
    }
  }
  getTopPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y + this.w + ((this.stock.getBladeWidth() || e) ?? 0) : this.y + this.w;
  }
  getRightPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x + this.l + ((this.stock.getBladeWidth() || e) ?? 0) : this.x + this.l;
  }
  getBottomPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y - ((this.stock.getBladeWidth() || e) ?? 0) : this.y;
  }
  getLeftPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x - ((this.stock.getBladeWidth() || e) ?? 0) : this.x;
  }
  sharesSide(t, e = 0, i = null) {
    switch (i) {
      case "left":
        return t.x + t.l + e === this.x;
      case "right":
        return t.x === this.x + this.l + e;
      case "bottom":
        return t.y + t.w + e === this.y;
      case "top":
        return t.y === this.y + this.w + e;
    }
    return !1;
  }
  sameSide(t, e = null) {
    switch (e) {
      case "left":
        return t.x === this.x;
      case "right":
        return t.x + t.l === this.x + this.l;
      case "bottom":
        return t.y === this.y;
      case "top":
        return t.y + t.w === this.y + this.w;
    }
    return !1;
  }
  //considers if the shape can rotate
  getLongestDimension(t) {
    return this.orientationLock ? this[t] : this.getLongSide();
  }
  getArea() {
    return this.w * this.l;
  }
  getCoords(t, e = !1) {
    const i = new Hn(this.x + this.l, this.y);
    i.corner = "bottomRight";
    const r = new Hn(this.x, this.y + this.w);
    if (r.corner = "topLeft", (t == null ? void 0 : t.cutType) !== "efficiency" && !e)
      return [r, i];
    const s = new Hn(this.x, this.y);
    s.corner = "bottomLeft";
    const o = new Hn(this.x + this.l, this.y + this.w);
    return o.corner = "topRight", [s, r, o, i];
  }
  getCorners() {
    return {
      bottomLeft: new Hn(this.x, this.y),
      topLeft: new Hn(this.x, this.y + this.w),
      topRight: new Hn(this.x + this.l, this.y + this.w),
      bottomRight: new Hn(this.x + this.l, this.y)
    };
  }
  round() {
    return {
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  getClass() {
    return this.constructor.name;
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: this.l, w: this.w };
    return t && (e = this.getRotatedDimensions()), this.trimmed ? e : {
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2)
    };
  }
  //trim the rectangle
  trimDimensions() {
    var t, e, i, r;
    return this.trimmed ? !1 : (this.trim && Object.values(this.trim).filter((s) => !isNaN(parseFloat(String(s)))).length && (jt(this.l) && (this.l -= ((t = this == null ? void 0 : this.trim) != null && t.x1 ? this.trim.x1 : 0) + ((e = this == null ? void 0 : this.trim) != null && e.x2 ? this.trim.x2 : 0), this.l <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative length")))), jt(this.w) && (this.w -= ((i = this == null ? void 0 : this.trim) != null && i.y1 ? this.trim.y1 : 0) + ((r = this == null ? void 0 : this.trim) != null && r.y2 ? this.trim.y2 : 0), this.w <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative width"))))), this.trimmed = !0, !0);
  }
  /**
   * change the size of the rectangle back to the original size
   */
  removeTrim() {
    var t, e, i, r;
    if (this.trimmed) {
      if (this.l += (typeof ((t = this == null ? void 0 : this.trim) == null ? void 0 : t.x1) == "number" ? this.trim.x1 : 0) + (typeof ((e = this == null ? void 0 : this.trim) == null ? void 0 : e.x2) == "number" ? this.trim.x2 : 0), this.w += (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.y1) == "number" ? this.trim.y1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.y2) == "number" ? this.trim.y2 : 0), this.l <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative length`);
      if (this.w <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative width`);
      this.trimmed = !1;
    }
  }
  getUntrimmedDimensions() {
    var i, r, s, o;
    if (!this.trimmed) return { l: this.l, w: this.w };
    const t = this.getLongSide(), e = this.getShortSide();
    return {
      l: t + (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.x1) == "number" ? this.trim.x1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.x2) == "number" ? this.trim.x2 : 0),
      w: e + (typeof ((s = this == null ? void 0 : this.trim) == null ? void 0 : s.y1) == "number" ? this.trim.y1 : 0) + (typeof ((o = this == null ? void 0 : this.trim) == null ? void 0 : o.y2) == "number" ? this.trim.y2 : 0)
    };
  }
  isIdentical(t, e = !1) {
    if (this.constructor !== t.constructor || this.t !== t.t || this.orientationLock !== t.orientationLock)
      return !1;
    if (Nr(this)) {
      if (t.id === this.id) return !0;
    } else {
      if (t.parentID === this.parentID) return !0;
      if (pr(this) && e && this.parentID !== t.parentID) return !1;
    }
    const { w: i, l: r } = this, { w: s, l: o } = t;
    if (!(i === s && r === o) && !(i === o && r === s))
      return !1;
    const a = this.trim, l = t.trim;
    return !a || !l ? a === l : a.x1 === l.x1 && a.x2 === l.x2 && a.y1 === l.y1 && a.y2 === l.y2;
  }
  /**
   * is this rectangle a square
   */
  isSquare() {
    return this.l === this.w;
  }
  getDistancesToContainerEdges(t) {
    return [
      this.x - t.x,
      t.l - (this.x + this.l),
      t.w - (this.y + this.w),
      this.y - t.y
    ];
  }
  isInsideStock(t) {
    return !(this.x + this.l > t.l || this.y + this.w > t.w || this.x < 0 || this.y < 0);
  }
  /**
  * Creates or retrieves a cached rectangle used for proximity detection.
  * Optimized for frequent calls with the same distance parameter.
  */
  getProximityRectangle(t) {
    if (!t || t < 0) return null;
    const e = this.proximity;
    if ((e == null ? void 0 : e.distance) === t) {
      const r = e.rectangle;
      return this.x === 0 ? (r.x = 0, r.l = this.l + t) : (r.x = this.x - t, r.l = this.l + t * 2), this.y === 0 ? (r.y = 0, r.w = this.w + t) : (r.y = this.y - t, r.w = this.w + t * 2), r;
    }
    const i = new zl({
      id: `${this.id}-proximity`,
      name: "proximity",
      x: this.x === 0 ? 0 : this.x - t,
      y: this.y === 0 ? 0 : this.y - t,
      l: this.x === 0 ? this.l + t : this.l + t * 2,
      w: this.y === 0 ? this.w + t : this.w + t * 2,
      preventAutoRotation: !0
    });
    return this.proximity = { rectangle: i, distance: t }, i;
  }
  isShape() {
    return pr(this);
  }
  isSegment() {
    return Xb(this);
  }
  isStock() {
    return Qr(this);
  }
  isGroup() {
    return Nr(this);
  }
  isUserGroup() {
    return xd(this);
  }
}
class wd extends zl {
  constructor(e) {
    super(e);
    et(this, "type");
    et(this, "saw");
    et(this, "algoBenchmark");
    //used by evo
    et(this, "shapes", []);
    switch (this.shapes = e.shapes, ["sheet", "linear", "roll", null, void 0, ""].includes(e.type) ? this.type = e.type : this.issues.push({ message: `Container type ${e.type ?? "N/A"} is not valid` }), this.type || (this.type = "sheet"), this.setSaw(e), this.cutType) {
      case "beam":
        (!jt(this.t) || this.t <= 0) && this.issues.push(this.createIssue("Stock for beam saws must have a thickness set"));
        break;
    }
  }
  setSaw(e) {
    var i, r, s, o;
    if (jt(e) || (this.saw = new zs(null)), jt(e == null ? void 0 : e.saw)) {
      if (!((r = e == null ? void 0 : e.saw) != null && r.cutType)) {
        const { cutType: a, cutPreference: l } = nf(e.saw.cutPreference);
        e.saw.cutType = a, e.saw.cutPreference = l;
      }
    } else {
      e.saw = {};
      const { cutType: a, cutPreference: l } = nf(e.cutPreference);
      e.saw.cutType = a, e.saw.cutPreference = l, jt(e == null ? void 0 : e.bladeWidth) && (e.saw.bladeWidth = e.bladeWidth), jt((i = e == null ? void 0 : e.blade) == null ? void 0 : i.width) && (e.saw.bladeWidth = e.blade.width), jt(e == null ? void 0 : e.efficiencyOptions) && (e.saw.efficiencyOptions = e.efficiencyOptions), jt(e == null ? void 0 : e.guillotineOptions) && (e.saw.guillotineOptions = e.guillotineOptions), jt(e == null ? void 0 : e.stackHeight) && (e.saw.stackHeight = e.stackHeight);
    }
    try {
      jt(e == null ? void 0 : e.saw) && (Jb(e.saw) ? this.saw = e.saw : this.saw = new zs(e.saw, this.type)), (o = (s = this.saw) == null ? void 0 : s.issues) != null && o.length && this.issues.push(...this.saw.issues);
    } catch (a) {
      throw new Error("error creating saw", { cause: a });
    }
  }
  get cutType() {
    var e, i, r, s;
    return jt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.cutType) ? this.saw.cutType : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutType) ?? null;
  }
  get cutPreference() {
    var e, i, r, s;
    return jt((e = this.saw) == null ? void 0 : e.cutPreference) ? this.saw.cutPreference : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutPreference) ?? null;
  }
  get guillotineOptions() {
    var e, i, r, s;
    return jt((e = this.saw) == null ? void 0 : e.guillotineOptions) ? this.saw.guillotineOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.guillotineOptions) ?? null;
  }
  get efficiencyOptions() {
    var e, i, r, s;
    return jt((e = this.saw) == null ? void 0 : e.efficiencyOptions) ? this.saw.efficiencyOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.efficiencyOptions) ?? null;
  }
  get primaryCompression() {
    var e, i;
    if (this.cutType === "efficiency")
      return (i = (e = this.saw) == null ? void 0 : e.efficiencyOptions) != null && i.primaryCompression ? this.efficiencyOptions.primaryCompression : "y";
  }
  getHalfBladeWidth() {
    const e = this.getBladeWidth();
    return e ? e / 2 : 0;
  }
  getBladeWidth() {
    var i, r, s;
    const e = (((i = this == null ? void 0 : this.saw) == null ? void 0 : i.bladeWidth) || ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.bladeWidth)) ?? 0;
    return isNaN(e) ? 0 : e;
  }
  getStock() {
    return Qr(this) ? this : this != null && this.stock ? this.stock : null;
  }
}
class zs {
  constructor(t, e = "sheet") {
    et(this, "issues");
    et(this, "bladeWidth");
    et(this, "cutType");
    et(this, "cutPreference");
    et(this, "guillotineOptions");
    et(this, "efficiencyOptions");
    et(this, "stackHeight");
    et(this, "stockType");
    et(this, "options");
    switch (t = Co(t), this.options = yl({}, t == null ? void 0 : t.options, {
      stockSelection: "efficiency",
      stackingMode: "dimensions",
      minSpacing: 0,
      minSpacingDimension: {}
    }), this.stackHeight = (t == null ? void 0 : t.stackHeight) ?? null, this.stockType = (t == null ? void 0 : t.stockType) ?? e, this.issues = [], ["sheet", "linear", "roll"].includes(this.stockType) || this.issues.push({ message: `Saw stock type: ${this.stockType} not valid` }), this.stockType || (this.stockType = "sheet"), this.cutType = t == null ? void 0 : t.cutType, this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "roll":
        ["efficiency", "guillotine", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "linear":
        break;
      default:
        ["none", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
    }
    switch (this.cutPreference = t == null ? void 0 : t.cutPreference, this.cutType) {
      case "guillotine":
        ["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.cutType === "guillotine" && this.cutPreference === "l" && this.stockType === "roll" && this.issues.push({ message: `Cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"} and stock type: ${this.stockType}` }), this.options.minSpacing = 0;
        break;
      case "beam":
        ["l", null, void 0].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.options.minSpacing = 0;
        break;
    }
    switch (jt(t == null ? void 0 : t.bladeWidth) ? typeof t.bladeWidth == "string" ? this.bladeWidth = Qt(t.bladeWidth) : this.bladeWidth = t.bladeWidth : this.bladeWidth = 0, (isNaN(this.bladeWidth) || this.bladeWidth < 0) && (this.issues.push({ message: `Blade width: ${this.bladeWidth ?? "N/A"} is not valid` }), this.bladeWidth = 0), this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Invalid cut type: ${this.cutType} for stock type: ${e}, cut preference: ${this.cutPreference}` }), this.cutType === "guillotine" && (["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Invalid cut preference: ${this.cutPreference} for stock type: ${e}, cut type: ${this.cutType}` })), this.cutType === "beam" && [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" }), this.cutType === "beam" && (this.cutPreference = "l"), this.cutType || (this.cutType = "efficiency");
        break;
      case "linear":
        this.cutType = null, this.cutPreference = null;
        break;
    }
    switch (this.cutType) {
      case "efficiency":
        this.efficiencyOptions = yl({}, t == null ? void 0 : t.efficiencyOptions, { primaryCompression: "y" });
        break;
      case "guillotine":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        break;
      case "beam":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null }), this.cutPreference = "l", [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" });
        break;
    }
  }
  clone() {
    const t = structuredClone(this);
    return new zs(t);
  }
}
class ts extends wd {
  constructor(e) {
    e = Co(e), e.preventAutoRotation = (e == null ? void 0 : e.type) === "roll", e.autoAdd && !e.q && (e.q = 1);
    super(e);
    et(this, "_id");
    //used for mongo
    et(this, "autoAdd");
    et(this, "allowExactFitShapes");
    et(this, "analysis");
    et(this, "tidy");
    et(this, "used");
    et(this, "stack");
    et(this, "winningStrategy");
    //used for reporting
    et(this, "unusable");
    //used by stock matching
    et(this, "duplicatePattern");
    et(this, "score");
    et(this, "rootSegment");
    delete this.stock, this._id = e == null ? void 0 : e._id, this.autoAdd = jt(e == null ? void 0 : e.autoAdd) ? e.autoAdd : !1, this.allowExactFitShapes = jt(e == null ? void 0 : e.allowExactFitShapes) ? e.allowExactFitShapes : !1, this.analysis = jt(e.analysis) ? e.analysis : null, this.tidy = jt(e == null ? void 0 : e.tidy) ? e.tidy : !1, this.algoBenchmark = null, this.used = jt(e == null ? void 0 : e.used) ? e.used : !1, this.stack = jt(e == null ? void 0 : e.stack) ? e.stack : !1, this.duplicatePattern = (e == null ? void 0 : e.duplicatePattern) ?? null, this.initStock(e);
  }
  initStock(e) {
    switch (this.type) {
      case "linear":
      case "roll":
        this.trim.y1 = 0, this.trim.y2 = 0, this.grain = null;
        break;
    }
    this.validateStock(e), this.issues.length;
  }
  reset() {
    this.used = !1, this.stack = null, this.score = null, this.rootSegment = null, this.tidy = null, this.analysis = null, this.duplicatePattern = null, this.shapes = [];
  }
  validateStock(e) {
    ["grain"].forEach((i) => {
      this.createIssues(li[i](e[i]));
    }), this.createIssues(li.trim(this));
  }
  /**
   * compress for saving / transfer
   */
  save() {
    delete this.tidy, delete this.score, delete this.rootSegment, delete this.shapes, delete this.saw, this == null || delete this.algoBenchmark, this.stack = Qr(this.stack) ? this.stack.id : this.stack, !this.trim.x1 && !this.trim.x2 && !this.trim.y1 && !this.trim.y2 && (this.trim = null);
  }
  resetStrategies() {
    this.algoBenchmark = null;
  }
  isIdentical(e) {
    let i = !1, r = !1, s = !1, o = !1;
    if (this.material === e.material && (i = !0), this.t === e.t && (r = !0), this.l === e.l && (s = !0), this.w === e.w && (o = !0), i && r && s && o) return !0;
  }
  hasStack() {
    return typeof this.stack == "number";
  }
  isStacked() {
    return Qr(this.stack) || typeof this.stack == "string";
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = parseInt(i.pop()), e++), i.push(e.toString());
    const r = i.join("."), s = structuredClone(this);
    return s.id = r, s.used = !1, s.duplicate = !0, s.stack = !1, s.saw = this.saw, new ts(s);
  }
}
class Ub extends zl {
  constructor(e) {
    super(e);
    et(this, "addToInventory");
    //for front end selection
    et(this, "added");
    //for adding to inputStock
    et(this, "placementOrder");
    et(this, "flex");
    this.cost = this.getCost(), this.addToInventory = (e == null ? void 0 : e.addToInventory) ?? !0, this.added = !1, this.placementOrder = (e == null ? void 0 : e.placementOrder) ?? null, this.offcut = !0;
  }
  compressForSaving() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) || ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this._trim, delete this.trimmed;
  }
  getCost() {
    var e;
    return (e = this.stock) != null && e.isStock() && this.stock ? parseFloat((this.getArea() / this.stock.getArea() * this.stock.cost).toFixed(2)) : 0;
  }
}
function Wb({
  offcuts: n,
  stockList: t,
  preventAutoRotation: e = !0
}) {
  return !n || !(n != null && n.length) ? [] : n.map((i) => {
    const r = t.find((o) => {
      var a;
      return o.id === (((a = i == null ? void 0 : i.stock) == null ? void 0 : a.id) ?? (i == null ? void 0 : i.stockId));
    });
    return i.stock = r, e && (i.preventAutoRotation = !0), new Ub(i);
  });
}
class es extends zl {
  constructor(e) {
    e = Co(e);
    super(e);
    et(this, "added");
    et(this, "guillotineData");
    et(this, "stockLock");
    et(this, "score");
    et(this, "bestScore");
    et(this, "placementOrder");
    //groups
    et(this, "groupPlacementOrder");
    et(this, "group");
    et(this, "groupID");
    et(this, "inGroup");
    //is the shape currently part of at least one group
    et(this, "inUserGroup");
    //is the shape currently part of a user group`
    et(this, "addedAsGroup");
    et(this, "isFirstShape");
    et(this, "firstShapeSampleRotations", []);
    //used for setting the rotation of the first shape (guillotine)
    et(this, "index");
    //used for ptx
    et(this, "patternMatch");
    //used for stack detection
    et(this, "stockMatch");
    et(this, "minSpacing");
    et(this, "priority");
    et(this, "weighting", {});
    //objects
    et(this, "machining");
    et(this, "_banding", Object.fromEntries(
      Fs.map((e) => [e, !1])
    ));
    et(this, "_finish", Object.fromEntries(
      hr.map((e) => [e, ""])
    ));
    this.initShape(e);
  }
  initShape(e, i = !1) {
    var r;
    if (!i) {
      if (this.validateShape(e), this.issues.length) throw new Error(this.issues.map((s) => s.message).join(`
`));
      e.orientationLock = (r = e == null ? void 0 : e.orientationLock) == null ? void 0 : r.toLowerCase(), (e == null ? void 0 : e.orientationLock) === " " && (e.orientationLock = ""), this.orientationLock = jt(e == null ? void 0 : e.orientationLock) && this.l !== this.w ? e.orientationLock : null, jt(e == null ? void 0 : e.stockLock) ? Array.isArray(e == null ? void 0 : e.stockLock) && (this.stockLock = e.stockLock.map((s) => s.toString())) : this.stockLock = [], this.banding = e == null ? void 0 : e.banding, this.finish = e == null ? void 0 : e.finish, this.machining = jt(e == null ? void 0 : e.machining) ? new f1(e.machining) : null;
    }
    this.added = jt(e == null ? void 0 : e.added) ? e.added : !1, this.initGuillotineData(e), this.inGroup = jt(e == null ? void 0 : e.inGroup) ? e.inGroup : this.inGroup || !1, this.inUserGroup = jt(e == null ? void 0 : e.inUserGroup) ? e.inUserGroup : this.inUserGroup || !1, this.groupID = jt(e == null ? void 0 : e.groupID) ? e.groupID : this.groupID || null, this.addedAsGroup = jt(e == null ? void 0 : e.addedAsGroup) ? e.addedAsGroup : this.addedAsGroup || !1, this.score = jt(e == null ? void 0 : e.score) ? e.score : this.score || null, this.bestScore = jt(e == null ? void 0 : e.bestScore) ? e.bestScore : this.bestScore || {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    }, this.placementOrder = jt(e == null ? void 0 : e.placementOrder) ? e.placementOrder : this.placementOrder || null, this.groupPlacementOrder = jt(e == null ? void 0 : e.groupPlacementOrder) ? e.groupPlacementOrder : this.groupPlacementOrder || null, this.minSpacing = (e == null ? void 0 : e.minSpacing) ?? (this.minSpacing || 0), this.priority = (e == null ? void 0 : e.priority) ?? {};
  }
  initGuillotineData(e) {
    var i, r, s, o, a, l, h, u;
    this.guillotineData = yl({}, e == null ? void 0 : e.guillotineData, {
      firstShape: ((i = this == null ? void 0 : this.guillotineData) == null ? void 0 : i.firstShape) || null,
      myPhase: ((r = this == null ? void 0 : this.guillotineData) == null ? void 0 : r.myPhase) || null,
      myStripParent: ((s = this == null ? void 0 : this.guillotineData) == null ? void 0 : s.myStripParent) || null,
      myStripDirection: ((o = this == null ? void 0 : this.guillotineData) == null ? void 0 : o.myStripDirection) || null,
      stripShapeBatches: {
        subsetUsed: ((l = (a = this == null ? void 0 : this.guillotineData) == null ? void 0 : a.stripShapeBatches) == null ? void 0 : l.subsetUsed) || !1,
        groups: ((u = (h = this == null ? void 0 : this.guillotineData) == null ? void 0 : h.stripShapeBatches) == null ? void 0 : u.groups) || {}
      }
    });
  }
  cloneGuillotineData() {
    var e;
    return (e = this.guillotineData) != null && e.myStripParent && (pr(this.guillotineData.myStripParent) || Nr(this.guillotineData.myStripParent)) && (this.guillotineData.myStripParent = this.guillotineData.myStripParent.compress()), structuredClone(this.guillotineData);
  }
  getCopyNumber() {
    return parseInt(this.id.split(".").pop());
  }
  getMinSpacing(e, i = !1) {
    var o, a;
    if (!e) return 0;
    let r = (this == null ? void 0 : this.minSpacing) || ((a = (o = e.saw) == null ? void 0 : o.options) == null ? void 0 : a.minSpacing) || 0;
    const s = e.getBladeWidth();
    return s > r && (r = s), i && (r -= s), r < 0 && (r = 0), r;
  }
  validateShape(e) {
    ["orientationLock", "banding"].forEach((i) => {
      this.createIssues(li[i](e[i]));
    }), this.machining && this.machining.validateEverything(this);
  }
  //individual shape weighting
  /* calculateWeighting()
  	{
  		// const aspect = this.w / this.l;
  		if ( aspect > 0.5 )
  		{
  			//cater for small parts
  			const area = s.getArea();
  			const areaPercentage = area / maxArea;
  
  			if ( areaPercentage <= 0.1 )
  			{
  				s.weighting.edge = areaPercentage;
  			}
  		}
  		//the closer to zero, the higher the edge weighting
  		this.weighting.edge = 1 - aspect;
  		this.weighting.edge *= 2;
  	} */
  update(e) {
    e = Co(e), this.initShape(e, !0), this.updateRectangle(e);
  }
  //banding
  set banding(e) {
    if (this._banding = Object.fromEntries(
      Fs.map((i) => [i, !1])
    ), !!Po(e, !0))
      for (const i of Fs)
        this._banding[i] = jt(e == null ? void 0 : e[i]) ? e[i] : !1;
  }
  get banding() {
    return this._banding;
  }
  //get an array of banding in the order L1, L2, W1, W2
  get bandingArray() {
    return Rb(this._banding);
  }
  get finish() {
    return this._finish;
  }
  get FacesArray() {
    return hr.map((e) => {
      var i;
      return (i = this.finish) == null ? void 0 : i[e];
    });
  }
  set finish(e) {
    if (this._finish = Object.fromEntries(
      hr.map((i) => [i, ""])
    ), !!Po(e, !0))
      for (const i of hr)
        this._finish[i] = jt(e == null ? void 0 : e[i]) ? e[i] : "";
  }
  //compress for saving / transfer
  save() {
    var e, i, r;
    delete this.group, (e = this == null ? void 0 : this.guillotineData) == null || delete e.stripShapeBatches, this.stockId = (i = this == null ? void 0 : this.stock) == null ? void 0 : i.id, delete this.stock, delete this.score, delete this.bestScore, Fs.every((s) => {
      var o;
      return !((o = this._banding) != null && o[s]);
    }) && (this._banding = null), hr.every((s) => {
      var o;
      return !((o = this._finish) != null && o[s]);
    }) && (this._finish = null), Fb(this), (r = this.guillotineData) == null || delete r.myStripParent, delete this.score, delete this.inGroup, delete this.groupID, delete this.addedAsGroup, delete this.proximity;
  }
  isExactFit(e) {
    return this.orientationLock === "w" && this.w === e.w || this.orientationLock === "l" && this.l === e.l || !this.orientationLock && this.w === e.w && this.l === e.l;
  }
  addToStock(e) {
    this.stock = e, this.stockId = e.id, this.added = !0, this.inGroup = !1, e.used = !0, this.grain = e.grain, e != null && e.grain && this.rot && (this.grain = Ao(e.grain)), H0([
      () => Bs(this.isInsideStock(e), `shape ${this.id} is not inside stock`).to.be.true
    ]);
  }
  removeFromStock() {
    this.placementOrder = null, this.stock = null, this.stockId = null, this.added = !1, this.addedAsGroup = !1, this == null || delete this.isFirstShape, Nr(this) && this.shapes.forEach((e) => e.removeFromStock());
  }
  setBestScore(e, i = null) {
    const r = {
      x: e.x,
      y: e.y,
      rot: e.rot,
      total: e.score.total,
      score: e.score,
      group: e.group,
      weighting: null,
      point: i
    };
    this.bestScore = r;
  }
  resetBestScore() {
    const e = {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.bestScore = e, this.resetGuillotineData(!0);
  }
  resetScore() {
    this.score = null, this.resetGuillotineData(!0);
  }
  resetBothScores() {
    this.resetBestScore(), this.resetScore();
  }
  resetPosition() {
    this.x = 0, this.y = 0, this.placementOrder = null, this.resetGuillotineData(!0);
  }
  resetGroupData() {
    this.inGroup = !1, this.group = null, this.groupID = null, this.groupPlacementOrder = null, this.grain = null;
  }
  resetGuillotineData(e = !1) {
    var r, s;
    const i = {
      firstShape: !1,
      myPhase: null,
      myStripDirection: null,
      stripShapeBatches: {
        subsetUsed: !1,
        groups: {}
      }
    };
    e && (i.stripShapeBatches.groups = (s = (r = this.guillotineData) == null ? void 0 : r.stripShapeBatches) == null ? void 0 : s.groups), this.guillotineData = i;
  }
  reset(e = !1, i = !0, r = !1) {
    this.removeFromStock(), this.resetPosition(), this.setRotation(0), this.placementOrder = null, this == null || delete this.isFirstShape, this.patternMatch = !1, e || this.resetBothScores(), r || this.resetGroupData(), this.resetGuillotineData(i);
  }
  round() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y),
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  //get an array of allowed rotations for this container
  getAllowedRotations(e) {
    const i = [];
    for (let r = 0; r <= 1; r++)
      this.canRotate(r, e) && this.willItFit(e, r) && i.push(r);
    return i;
  }
  /**
   * checks if a shape can rotate
   * checks for fit and grain
   * does not change the shape's rotation during the checks
   * @returns false if cannot rotate or can rotate but won't fit
   */
  canRotate(e = null, i = null) {
    if (!jt(e))
      throw new Error("no rotation provided to canRotate");
    if (e === !0 && (e = 1), e === !1 && (e = 0), this.isSquare() && e || i && !this.willItFit(i, e))
      return !1;
    const r = this.getNecessaryOrientation(i);
    return !(r === "l" && e === 1 || r === "w" && e === 0);
  }
  /**
   * can a shape rotate to produce the specified dimensions on a specific side
   * @todo tests
   */
  canRotateToDimension(e, i, r = null) {
    if (!i) throw new Error("requiredSide not supplied to canRotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (r) {
      if (i === "l") {
        if (s === e && this.canRotate(0, r) || o === e && this.canRotate(1, r)) return !0;
      } else if (i === "w" && (o === e && this.canRotate(0, r) || s === e && this.canRotate(1, r)))
        return !0;
    } else if (this.orientationLock) {
      if (this.orientationLock === "l")
        return i === "l" && e === s;
      if (this.orientationLock === "w")
        return i === "l" && e === o;
    }
    return !1;
  }
  canRotateToDimensionRange(e, i, r, s = null) {
    if (!r) throw new Error("requiredSide not supplied to canRotateToDimensionRange");
    if (this.l >= e && this.l <= i || this.w >= e && this.w <= i) {
      if (this.l === this.w) return !0;
      const o = this.getLongSide(), a = this.getShortSide();
      if (s) {
        if (r === "l") {
          if (o >= e && o <= i && this.canRotate(0, s) || a >= e && a <= i && this.canRotate(1, s)) return !0;
        } else if (r === "w" && (a >= e && a <= i && this.canRotate(0, s) || o >= e && o <= i && this.canRotate(1, s)))
          return !0;
      } else if (this.orientationLock) {
        if (this.orientationLock === "l")
          return r === "l" && o >= e && o <= i;
        if (this.orientationLock === "w")
          return r === "l" && a >= e && a <= i;
      }
    }
    return !1;
  }
  rotateToDimension(e, i, r) {
    if (!i) throw new Error("requiredSide not supplied to rotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (i === "l") {
      if (s === e && this.canRotate(0, r)) return this.setRotation(0);
      if (o === e && this.canRotate(1, r)) return this.setRotation(1);
    } else if (i === "w") {
      if (o === e && this.canRotate(0, r)) return this.setRotation(0);
      if (s === e && this.canRotate(1, r)) return this.setRotation(1);
    }
    return !1;
  }
  //get the orientation lock catering for container grain
  convertShapeGrainToOrientationLock(e) {
    if (!e) throw new Error("container not supplied to convertShapeGrainToOrientationLock");
    if (!of(e)) throw new Error("container is not a container");
    if (Nr(this)) return this.orientationLock;
    if (!jt(this.orientationLock)) return null;
    const i = e.getStock();
    return jt(i.grain) ? this.orientationLock === i.grain ? "l" : "w" : this.orientationLock;
  }
  /**
   * get the orientation lock catering for container grain
   */
  getNecessaryOrientation(e) {
    if (!e) return this.orientationLock;
    if (Nr(this)) return this.orientationLock;
    if (!jt(this.orientationLock)) return null;
    if (of(e))
      return this.convertShapeGrainToOrientationLock(e);
    if (Nr(this) || xd(this))
      return jt(this.orientationLock) ? this.orientationLock : null;
  }
  /**
   * get the required grain rotation
   * checks for stock grain and part orientationLock
   * does not check for fit
   */
  getGrainRotation(e) {
    if (Nr(this)) return this.rot;
    if (!jt(this.orientationLock)) return null;
    const i = e.getStock();
    return !this.orientationLock || !jt(i == null ? void 0 : i.grain) ? null : this.isGroup() ? this.orientationLock === "l" ? 0 : 1 : this.orientationLock === (i == null ? void 0 : i.grain) ? 0 : 1;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  rotate(e = null, i = null) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.canRotate(e, i) ? (this.rot === e || this.swapDimensions(), !0) : !1;
  }
  swapDimensions() {
    [this.l, this.w] = [this.w, this.l];
  }
  forceRotate(e) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.rot === e || this.swapDimensions(), !0;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotation(e = null, i = null) {
    return e ? e = 1 : e = 0, i && e && !this.willItFit(i, e) ? !1 : this.rotate(e, i);
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotationToOrientationLock(e) {
    if (!e)
      throw new Error("container not supplied to setRotationToOrientationLock");
    const i = this.getNecessaryOrientation(e);
    if (i === "l") return this.setRotation(0);
    if (i === "w") return this.setRotation(1);
  }
  setRotationToOrientationLockWithoutContainer() {
    if (this.orientationLock === "l") return this.setRotation(0);
    if (this.orientationLock === "w") return this.setRotation(1);
  }
  getBandingLength(e) {
    return !Db(e) || !this.banding[e] ? 0 : e === "x1" || e === "x2" ? this.getShortSide() : e === "y1" || e === "y2" ? this.getLongSide() : p1(e) ? c1(this, e) : 0;
  }
  getPriority(e) {
    var r;
    if (!e) return 0;
    const i = e.parentID;
    return (r = this.priority) != null && r[i] ? this.priority[i] : 0;
  }
  clearPriority() {
    this.priority = {};
  }
  getPerimeterCutVectors() {
    var r;
    const e = (r = this.stock) != null && r.isStock() ? this.stock.getBladeWidth() / 2 : null;
    return [
      //bottom
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y - e,
        type: "bottom"
      },
      //right
      {
        x1: this.x + this.l + e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "right"
      },
      //top
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y + this.w + e,
        y2: this.y + this.w + e,
        type: "top"
      },
      //left
      {
        x1: this.x - e,
        x2: this.x - e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "left"
      }
    ];
  }
  /* getTrimmedDimensions()
  	{
  		if ( this.trimmed )
  			return {
  				l: this.l,
  				w: this.w
  			};
  
  		return {
  			l: this.l - this.trim.x1 - this.trim.x2,
  			w: this.w - this.trim.y1 - this.trim.y2
  		};
  	} */
  /**
   * create cuts around the perimeter of a shape
   * @param {Stock} stock
   * @returns {Array} cuts
   */
  createPerimeterCuts(e = null) {
    let i = [];
    if (e = e || this.stock, !e) throw new Error("stock is required to create a cut");
    return this.getPerimeterCutVectors().forEach((s) => {
      var o;
      return i.push(new Tc({
        stock: (o = this.stock) != null && o.isStock() ? this.stock : e,
        x1: s.x1,
        x2: s.x2,
        y1: s.y1,
        y2: s.y2,
        type: s.type
      }));
    }), i = i.filter((s) => s.isInsideStock()), i;
  }
  createOffset(e) {
    if (!this.stock) throw new Error("createOffset - stock not defined");
    const i = {
      x: this.x - e,
      y: this.y - e,
      l: this.l + e * 2,
      w: this.w + e * 2
    };
    return i.x < 0 && (i.x = 0, i.l -= e), i.y < 0 && (i.y = 0, i.w -= e), i.x + i.l > this.stock.l && (i.l = this.stock.l - i.x), i.y + i.w > this.stock.w && (i.w = this.stock.w - i.y), i;
  }
  setPositionToBestScore() {
    this.setRotation(this.bestScore.rot), this.x = this.bestScore.x, this.y = this.bestScore.y;
  }
  /**
   * will this shape fit in a container
   */
  willItFit(e, i = null) {
    return g1(e, this, i);
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = i.pop(), e++), i.push(e);
    const r = i.join("."), s = this.stock;
    this.stock = null;
    const o = structuredClone(this);
    return o.stock = s, o.id = r, o.added = !1, o.duplicate = !0, delete o.score, delete o.bestScore, delete o.stock, delete o.placementOrder, delete o.inGroup, delete o.addedAsGroup, delete o.groupID, delete o.isFirstShape, new es(o);
  }
  //this is a compressed version of the shape to help with memory management
  compress() {
    const e = this.cloneGuillotineData();
    return e.myStripParent = Kb(this.guillotineData.myStripParent) ? this.guillotineData.myStripParent.id : this.guillotineData.myStripParent, {
      id: this.id,
      x: this.added ? this.x : 0,
      y: this.added ? this.y : 0,
      l: this.l,
      w: this.w,
      added: this.added,
      guillotineData: e,
      placementOrder: this.placementOrder,
      bestScore: this.bestScore,
      inGroup: this.inGroup,
      groupID: this.groupID,
      addedAsGroup: this.addedAsGroup,
      groupPlacementOrder: this.groupPlacementOrder,
      minSpacing: this.minSpacing,
      cloneType: "shape",
      priority: Object.assign({}, this.priority)
    };
  }
  isTooCloseToEdges(e) {
    var r, s;
    const i = ((s = (r = e.saw) == null ? void 0 : r.options) == null ? void 0 : s.minSpacing) || this.minSpacing;
    return i ? this.getDistancesToContainerEdges(e).some((o) => o > 0 && o <= i) : !1;
  }
  validateStripShapeBatches() {
    const e = Object.values(this.guillotineData.stripShapeBatches.groups);
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (r.id !== this.id)
        throw new Error(`strip shape group id does not match shape id ${this.id} ${r.id} ${i}`);
      if (![this.l, this.w].includes(r.dimension))
        throw new Error(`strip shape group dimension does not match shape dimensions ${this.id} ${r.id} ${i} ${this.l} ${this.w} ${r.dimension}`);
    }
  }
  getStripShapeBatchData(e) {
    var i;
    return typeof e != "number" || !((i = this == null ? void 0 : this.guillotineData) != null && i.stripShapeBatches) || !this.guillotineData.stripShapeBatches.groups || !(e in this.guillotineData.stripShapeBatches.groups) ? !1 : this.guillotineData.stripShapeBatches.groups[e];
  }
  isInStripShapeBatch(e) {
    return !!this.getStripShapeBatchData(e);
  }
  isStacked() {
    return this.added && this.stock && this.stock.isStacked();
  }
}
class y1 extends wd {
  constructor(e) {
    var t = (...sA) => (super(...sA), et(this, "firstShape"), et(this, "cuts"), et(this, "phase"), et(this, "merged"), et(this, "children"), et(this, "siblings"), //used by vis only
    et(this, "parent"), et(this, "segmentType"), et(this, "completed"), //used by vis only
    et(this, "rowSegment"), //used by cuts
    et(this, "placementOrder"), et(this, "hasBeamTrim"), et(this, "cutDirection"), this);
    if (e) {
      if (e.preventAutoRotation = !0, t(e), this.validateSegment(e), this.issues.length)
        throw new Error(`Segment validation failed - ${this.issues.join(" ")}`);
      delete this.trim, delete this.trimmed, this.shapes = jt(e == null ? void 0 : e.shapes) ? e.shapes : [], this.firstShape = jt(e == null ? void 0 : e.firstShape) ? e.firstShape : null, this.cuts = [], this.phase = jt(e == null ? void 0 : e.phase) ? e.phase : null, this.merged = jt(e == null ? void 0 : e.merged) ? e.merged : !1, this.parent = jt(e == null ? void 0 : e.parent) ? e.parent : null, this.children = jt(e == null ? void 0 : e.children) ? e.children : [], this.siblings = jt(e == null ? void 0 : e.siblings) ? e.siblings : [], this.offcut = jt(e == null ? void 0 : e.offcut) ? e.offcut : !1, this.segmentType = jt(e == null ? void 0 : e.segmentType) ? e.segmentType : null, this.placementOrder = null, this.cutDirection = jt(e == null ? void 0 : e.cutDirection) ? e.cutDirection : "l", this.hasBeamTrim = jt(e == null ? void 0 : e.hasBeamTrim) ? e.hasBeamTrim : !1;
    }
  }
  validateSegment(e) {
    var i, r;
    (Ge.lessThanOrEqualTo(e.w, 0) || Ge.lessThanOrEqualTo(e.l, 0)) && this.issues.push({ message: `Zero / negative dimension - l: ${e.l}, w: ${e.w}.` }), (Ge.lessThan(e.x, 0) || Ge.lessThan(e.y, 0)) && this.issues.push({ message: `Negative position - x: ${e == null ? void 0 : e.x}, y: ${e == null ? void 0 : e.y}.` }), e != null && e.stock && (Ge.greaterThan(e.x + e.l, e.stock.l) || Ge.greaterThan(e.y + e.w, e.stock.w)) && this.issues.push({ message: `Outside of stock ${e.stock.id} - x: ${e.x}, y: ${e.y}, l: ${e.l}, w: ${e.w}, sl: ${(i = e == null ? void 0 : e.stock) == null ? void 0 : i.l}, sw: ${(r = e == null ? void 0 : e.stock) == null ? void 0 : r.w}.` });
  }
  //compress for saving / transfer
  save() {
    var e;
    this.children = this.children.map((i) => ({
      id: i.id,
      x: i.x,
      y: i.y,
      l: i.l,
      w: i.w,
      offcut: i.offcut
    })), this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this.shapes, delete this.saw, delete this.siblings, delete this.parent, delete this.trim, this.algoBenchmark = null;
  }
  getBladeWidth() {
    return this.stock.getBladeWidth();
  }
  /**
   * create a normalised shape list to allow searching for duplicates
   */
  getNormalisedShapes(e) {
    return e.map((i) => ({
      x: i.x - this.x,
      y: i.y - this.y,
      l: i.l,
      w: i.w
    }));
  }
  reset() {
    this.stock.used = !1, this.children = [], this.siblings = [], this.parent = null, this.cuts = [], this.phase = null;
  }
}
class Ws extends es {
  //used for sorting
  constructor(e) {
    var i, r;
    if (e = Co(e), !((i = e == null ? void 0 : e.shapes) != null && i.length))
      throw new Error("attempting to create a group with no shapes");
    e.preventAutoRotation = !0;
    super(e);
    et(this, "shapes");
    et(this, "positions");
    et(this, "direction");
    et(this, "container");
    et(this, "outOfBounds");
    et(this, "collision");
    et(this, "counter", 0);
    et(this, "type");
    et(this, "efficiency");
    this.q = 1, delete this._banding, delete this._finish, delete this._trim, this.shapes = e.shapes, this.positions = (r = e == null ? void 0 : e.positions) != null && r.length ? e.positions : [], this.direction = e.direction, this.container = e.container, this.type = (e == null ? void 0 : e.type) ?? "auto", this.initGroup();
  }
  initGroup() {
    var e;
    (e = this == null ? void 0 : this.shapes) != null && e.length && (this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]));
  }
  setShapePositions() {
    if (!this.container) return;
    this.positions = [], this.type !== "user" && this.sortShapes();
    let e = 0;
    const i = V2(this.direction);
    this.shapes.forEach((o, a) => {
      this.positions.push({
        shape: o.id,
        [i]: e,
        [Y2(i)]: 0,
        rot: o.rot.valueOf()
      }), o.inGroup = !0, e += a === this.shapes.length - 1 ? o[this.direction] : o[this.direction] + o.getMinSpacing(this.container);
    }), this[this.direction] = e;
    const r = Ao(this.direction), s = this.shapes.reduce((o, a) => a[r] > o ? a[r] : o, 0);
    if (this[r] = s, W0()) {
      const o = this.shapes.slice(0, -1).reduce((h, u) => h + u.getMinSpacing(this.container), 0), l = this.shapes.reduce((h, u) => h + u[this.direction], 0) + o;
      H0([
        () => Bs(Ge.equalTo(l, this[this.direction]), "group dimension is incorrect in direction").to.be.true,
        () => Bs(e, "currentPosition is incorrect in direction").to.equal(this[this.direction]),
        () => Bs(s, "group dimension in other direction is not correct").to.equal(this[r])
      ]);
    }
    if (this.w > this.container.w || this.l > this.container.l)
      throw new Error(`group ${this.id} is bigger than container - group ${this.l}x${this.w}, container ${this.container.l}x${this.container.w}`);
  }
  //update the shape spacing and overall group dimensions to account for min spacing
  updateShapeSpacing(e) {
    this.container = e, this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]);
  }
  //get the area of the shapes (does not include blade width) - overwrites the rectangle method
  getArea() {
    return this.shapes.reduce((e, i) => e + i.getArea(), 0);
  }
  destroy() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !1);
  }
  reset() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !0);
  }
  /**
   * orientate all the shapes correctly to fit in the group
   */
  orientateShapes(e) {
    this.shapes.forEach((i) => {
      const r = this.positions.find((o) => o.shape === i.id);
      if (!r) throw new Error("position not found for shape in group");
      if (!i.rotate(r.rot, e)) throw new Error("orientateShapes - unable to rotate shape in group");
    });
  }
  /**
   * sort the shapes by size
   */
  sortShapes() {
    const e = Ao(this.direction);
    this.shapes.sort((i, r) => r[e] === i[e] ? r[this.direction] === i[this.direction] ? i.id.localeCompare(r.id, void 0, { numeric: !0 }) : r[this.direction] - i[this.direction] : r[e] - i[e]);
  }
  /**
   * place the group shapes on the stock
   */
  placeMyShapes(e) {
    if (!e) throw new Error("placeShapes requires stock");
    this.addToStock(e);
    for (let i = 0; i < this.shapes.length; i++) {
      const r = this.shapes[i];
      r.addToStock(e);
      const s = this.positions.find((l) => l.shape === r.id);
      if (!s) throw new Error("position not found for shape in group");
      if (r.x = this.x + s.x, r.y = this.y + s.y, !r.rotate(s.rot, e)) throw new Error("placeMyShapes - unable to rotate shape in group");
      i === 0 && this.x === 0 && this.y === 0 && (r.isFirstShape = !0), r.addedAsGroup = this.id, r.inGroup = !1, r.score = this.score;
      const a = r.guillotineData.stripShapeBatches;
      r.guillotineData = this.cloneGuillotineData(), r.guillotineData.stripShapeBatches = a, r.bestScore = this.bestScore, typeof this.placementOrder == "number" && (r.groupPlacementOrder = i, r.placementOrder = this.placementOrder + i / 1e6);
    }
  }
  //this is for groups which are created once and reused between stock e.g. user groups
  orientateCorrectly(e) {
    this.orientateShapes(e), this.setRotationToOrientationLock(e);
  }
  clone(e = []) {
    const r = `g${parseInt(this.id.split("g")[1]) + 1}`, s = this.shapes, o = this.container, a = this.stock;
    this.shapes = [], this.container = null, this.stock = null;
    const l = structuredClone(this);
    return this.shapes = s, this.container = o, this.stock = a, l.container = this.container, l.shapes = e, l.id = r, new Ws(l);
  }
  compress() {
    const e = super.compress.call(this);
    return e.direction = this.direction, e.positions = structuredClone(this.positions), e.shapes = this.shapes.map((i) => i.compress()), e.type = this.type, e.cloneType = "group", e;
  }
}
function Hb(n, t, e, i) {
  return t.filter((r, s) => {
    var o, a;
    return n.stockMatch.material[s] = null, n.stockMatch.thickness[s] = null, n.stockMatch.width[s] = null, n.stockMatch.fit[s] = null, (pr(n) || xd(n)) && (g1(r, n) ? n.stockMatch.fit[s] = !0 : n.stockMatch.fit[s] = !1), e ? !(r != null && r.material) && !(n != null && n.material) || ((o = r == null ? void 0 : r.material) == null ? void 0 : o.toLowerCase()) === ((a = n == null ? void 0 : n.material) == null ? void 0 : a.toLowerCase()) ? n.stockMatch.material[s] = !0 : n.stockMatch.material[s] = !1 : n.stockMatch.material[s] = !0, i ? jt(n.t) && jt(r.t) ? (pr(n) && Ge.equalTo(n.t, r.t) || n.t === r.t) && (n.stockMatch.thickness[s] = !0) : n.stockMatch.thickness[s] = !1 : n.stockMatch.thickness[s] = !0, r.type === "linear" ? pr(n) && (n.canRotate(0, r) && Ge.equalTo(n.w, r.w) || n.canRotate(1, r) && Ge.equalTo(n.l, r.w) ? n.stockMatch.width[s] = !0 : n.stockMatch.width[s] = !1) : n.stockMatch.width[s] = !0, n.stockMatch.fit[s] && n.stockMatch.material[s] && n.stockMatch.thickness[s] && n.stockMatch.width[s];
  });
}
function Gb(n, t, e) {
  const i = Cr(n[0]);
  if (i && (t = t.map((u) => {
    const d = new ts(u);
    return d.trimDimensions(), d;
  }), n = n.map((u) => {
    const d = new es(u);
    return d.trimDimensions(), d;
  })), Uu(t[0]) && (t = t.map((u, d) => (u.id = `${d.toString()}.0`, new ts(u)))), n.some((u) => jt(u.stockLock) && u.stockLock.length)) return;
  t = t.filter((u) => u.autoAdd === !0 || jt(u.q) && u.q > 0);
  const s = t.some((u) => jt(u.material)), o = t.some((u) => jt(u.t)), a = /* @__PURE__ */ new Set();
  for (const u of n) {
    u.stockMatch = {
      material: [],
      thickness: [],
      width: [],
      fit: []
    };
    const d = Hb(u, t, s, o);
    if (u.stockMatch.fit = !u.stockMatch.fit.every((p) => p === !1), u.stockMatch.material = !u.stockMatch.material.every((p) => p === !1), u.stockMatch.thickness = !u.stockMatch.thickness.every((p) => p === !1), u.stockMatch.width = !u.stockMatch.width.every((p) => p === !1), !i) {
      if (d.length) {
        const p = d.map((f) => f.getParentID());
        u.stockLock = p, p.forEach((f) => a.add(f));
      } else if (u.stockMatch.fit)
        u.stockMatch.material || u.issues.push({ message: `materials must match - could not find any stock with ${u.material ? u.material + " material" : "no material set"}` }), u.stockMatch.thickness || u.issues.push({ message: `thicknesses must match - could not find any stock with ${u.t ? "thickness " + u.t : "no thickness set"}` }), e === "linear" && !u.stockMatch.width && u.issues.push({ message: `widths must match for linear calculations - could not find any stock with ${u.w ? "width " + u.w : "no width set"}` });
      else {
        const p = u.getTrimmedDimensions();
        u.issues.push({ message: `${p.l.toFixed()}x${p.w.toFixed()} will not fit on any stock - check dimensions, min spacing, trim & orientation lock` });
      }
      u.stockMatch = null;
    }
  }
  const l = n.filter((u) => !u.stockLock || !u.stockLock.length).sort(Ju.ID), h = t.filter((u) => !a.has(u.parentID)).sort(Ju.ID);
  return t = t.filter((u) => Qr(u)).filter((u) => a.has(u.parentID)), (s || o) && (n = n.filter((u) => {
    var d;
    return (d = u == null ? void 0 : u.stockLock) == null ? void 0 : d.length;
  })), {
    stockList: t,
    unusableStock: h,
    shapeList: n,
    unusableShapes: l
  };
}
function Vb(n) {
  if (!n.length) return "n";
  const t = n.map((e) => e.grain).filter((e) => e);
  return t.length ? t.every((e) => e === "l") ? "l" : t.every((e) => e === "w") ? "w" : t.some((e) => e === "l" || e === "w") ? "y" : "n" : "n";
}
function Yb(n) {
  return n.shapes !== void 0;
}
function Nr(n) {
  return n instanceof Ws && n.type !== "user";
}
function xd(n) {
  return n instanceof Ws && n.type === "user";
}
function fo(n) {
  return n instanceof Mb;
}
function Uu(n) {
  return n instanceof m1;
}
function Cr(n) {
  return n instanceof vd;
}
function Qr(n) {
  return n instanceof ts;
}
function of(n) {
  return n instanceof wd;
}
function pr(n) {
  return n instanceof es && !(n instanceof Ws);
}
function Kb(n) {
  return n instanceof es || n instanceof Ws;
}
function Xb(n) {
  return n instanceof y1;
}
function Jb(n) {
  return n instanceof zs;
}
function Zb(n) {
  return !n || typeof n != "string" ? "" : n.toUpperCase();
}
function ac(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n) !== void 0;
}
function Rn(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n);
}
function jt(n) {
  return !(n === void 0 || n === null || n === "" || typeof n == "object" && !Object.values(n).length);
}
function Po(n, t = !1) {
  if (!jt(n) || typeof n != "object") return !1;
  const e = Object.values(n);
  return e.length === 0 ? !1 : t ? e.some((i) => jt(i) && i) : e.some((i) => jt(i));
}
function Qb(n) {
  return n != null && n.length ? n.filter((t) => t.used && (t.stack === !1 || typeof t.stack == "number")) : [];
}
function tv() {
  const n = document.documentElement;
  return "requestFullscreen" in n || "webkitRequestFullscreen" in n || "mozRequestFullScreen" in n || "msRequestFullscreen" in n;
}
function $l(n) {
  return n ? (n = n.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^ a-z0-9._\-|]/gim, ""), n.trim()) : null;
}
function b1(n, t = 100) {
  return n ? (n = n.trim(), n = n.substring(0, t), n) : "";
}
function en(n) {
  "@babel/helpers - typeof";
  return en = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, en(n);
}
var ui = Uint8Array, Di = Uint16Array, _d = Int32Array, Mc = new ui([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Dc = new ui([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), af = new ui([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), v1 = function(n, t) {
  for (var e = new Di(31), i = 0; i < 31; ++i)
    e[i] = t += 1 << n[i - 1];
  for (var r = new _d(e[30]), i = 1; i < 30; ++i)
    for (var s = e[i]; s < e[i + 1]; ++s)
      r[s] = s - e[i] << 5 | i;
  return { b: e, r };
}, w1 = v1(Mc, 2), x1 = w1.b, lf = w1.r;
x1[28] = 258, lf[258] = 28;
var _1 = v1(Dc, 0), ev = _1.b, Wp = _1.r, uf = new Di(32768);
for (var fn = 0; fn < 32768; ++fn) {
  var Ls = (fn & 43690) >> 1 | (fn & 21845) << 1;
  Ls = (Ls & 52428) >> 2 | (Ls & 13107) << 2, Ls = (Ls & 61680) >> 4 | (Ls & 3855) << 4, uf[fn] = ((Ls & 65280) >> 8 | (Ls & 255) << 8) >> 1;
}
var Er = function(n, t, e) {
  for (var i = n.length, r = 0, s = new Di(t); r < i; ++r)
    n[r] && ++s[n[r] - 1];
  var o = new Di(t);
  for (r = 1; r < t; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  var a;
  if (e) {
    a = new Di(1 << t);
    var l = 15 - t;
    for (r = 0; r < i; ++r)
      if (n[r])
        for (var h = r << 4 | n[r], u = t - n[r], d = o[n[r] - 1]++ << u, p = d | (1 << u) - 1; d <= p; ++d)
          a[uf[d] >> l] = h;
  } else
    for (a = new Di(i), r = 0; r < i; ++r)
      n[r] && (a[r] = uf[o[n[r] - 1]++] >> 15 - n[r]);
  return a;
}, $s = new ui(288);
for (var fn = 0; fn < 144; ++fn)
  $s[fn] = 8;
for (var fn = 144; fn < 256; ++fn)
  $s[fn] = 9;
for (var fn = 256; fn < 280; ++fn)
  $s[fn] = 7;
for (var fn = 280; fn < 288; ++fn)
  $s[fn] = 8;
var Pl = new ui(32);
for (var fn = 0; fn < 32; ++fn)
  Pl[fn] = 5;
var nv = /* @__PURE__ */ Er($s, 9, 0), iv = /* @__PURE__ */ Er($s, 9, 1), rv = /* @__PURE__ */ Er(Pl, 5, 0), sv = /* @__PURE__ */ Er(Pl, 5, 1), _h = function(n) {
  for (var t = n[0], e = 1; e < n.length; ++e)
    n[e] > t && (t = n[e]);
  return t;
}, or = function(n, t, e) {
  var i = t / 8 | 0;
  return (n[i] | n[i + 1] << 8) >> (t & 7) & e;
}, Sh = function(n, t) {
  var e = t / 8 | 0;
  return (n[e] | n[e + 1] << 8 | n[e + 2] << 16) >> (t & 7);
}, Sd = function(n) {
  return (n + 7) / 8 | 0;
}, S1 = function(n, t, e) {
  return (e == null || e > n.length) && (e = n.length), new ui(n.subarray(t, e));
}, ov = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], lr = function(n, t, e) {
  var i = new Error(t || ov[n]);
  if (i.code = n, Error.captureStackTrace && Error.captureStackTrace(i, lr), !e)
    throw i;
  return i;
}, av = function(n, t, e, i) {
  var r = n.length, s = 0;
  if (!r || t.f && !t.l)
    return e || new ui(0);
  var o = !e, a = o || t.i != 2, l = t.i;
  o && (e = new ui(r * 3));
  var h = function(Rt) {
    var Yt = e.length;
    if (Rt > Yt) {
      var Kt = new ui(Math.max(Yt * 2, Rt));
      Kt.set(e), e = Kt;
    }
  }, u = t.f || 0, d = t.p || 0, p = t.b || 0, f = t.l, g = t.d, b = t.m, x = t.n, y = r * 8;
  do {
    if (!f) {
      u = or(n, d, 1);
      var v = or(n, d + 1, 3);
      if (d += 3, v)
        if (v == 1)
          f = iv, g = sv, b = 9, x = 5;
        else if (v == 2) {
          var D = or(n, d, 31) + 257, E = or(n, d + 10, 15) + 4, O = D + or(n, d + 5, 31) + 1;
          d += 14;
          for (var M = new ui(O), q = new ui(19), P = 0; P < E; ++P)
            q[af[P]] = or(n, d + P * 3, 7);
          d += E * 3;
          for (var A = _h(q), F = (1 << A) - 1, _ = Er(q, A, 1), P = 0; P < O; ) {
            var J = _[or(n, d, F)];
            d += J & 15;
            var k = J >> 4;
            if (k < 16)
              M[P++] = k;
            else {
              var V = 0, R = 0;
              for (k == 16 ? (R = 3 + or(n, d, 3), d += 2, V = M[P - 1]) : k == 17 ? (R = 3 + or(n, d, 7), d += 3) : k == 18 && (R = 11 + or(n, d, 127), d += 7); R--; )
                M[P++] = V;
            }
          }
          var tt = M.subarray(0, D), H = M.subarray(D);
          b = _h(tt), x = _h(H), f = Er(tt, b, 1), g = Er(H, x, 1);
        } else
          lr(1);
      else {
        var k = Sd(d) + 4, C = n[k - 4] | n[k - 3] << 8, I = k + C;
        if (I > r) {
          l && lr(0);
          break;
        }
        a && h(p + C), e.set(n.subarray(k, I), p), t.b = p += C, t.p = d = I * 8, t.f = u;
        continue;
      }
      if (d > y) {
        l && lr(0);
        break;
      }
    }
    a && h(p + 131072);
    for (var ct = (1 << b) - 1, it = (1 << x) - 1, N = d; ; N = d) {
      var V = f[Sh(n, d) & ct], z = V >> 4;
      if (d += V & 15, d > y) {
        l && lr(0);
        break;
      }
      if (V || lr(2), z < 256)
        e[p++] = z;
      else if (z == 256) {
        N = d, f = null;
        break;
      } else {
        var G = z - 254;
        if (z > 264) {
          var P = z - 257, Y = Mc[P];
          G = or(n, d, (1 << Y) - 1) + x1[P], d += Y;
        }
        var ot = g[Sh(n, d) & it], xt = ot >> 4;
        ot || lr(3), d += ot & 15;
        var H = ev[xt];
        if (xt > 3) {
          var Y = Dc[xt];
          H += Sh(n, d) & (1 << Y) - 1, d += Y;
        }
        if (d > y) {
          l && lr(0);
          break;
        }
        a && h(p + 131072);
        var gt = p + G;
        if (p < H) {
          var wt = s - H, qt = Math.min(H, gt);
          for (wt + p < 0 && lr(3); p < qt; ++p)
            e[p] = i[wt + p];
        }
        for (; p < gt; ++p)
          e[p] = e[p - H];
      }
    }
    t.l = f, t.p = N, t.b = p, t.f = u, f && (u = 1, t.m = b, t.d = g, t.n = x);
  } while (!u);
  return p != e.length && o ? S1(e, 0, p) : e.subarray(0, p);
}, Jr = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8;
}, cl = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8, n[i + 2] |= e >> 16;
}, kh = function(n, t) {
  for (var e = [], i = 0; i < n.length; ++i)
    n[i] && e.push({ s: i, f: n[i] });
  var r = e.length, s = e.slice();
  if (!r)
    return { t: A1, l: 0 };
  if (r == 1) {
    var o = new ui(e[0].s + 1);
    return o[e[0].s] = 1, { t: o, l: 1 };
  }
  e.sort(function(I, D) {
    return I.f - D.f;
  }), e.push({ s: -1, f: 25001 });
  var a = e[0], l = e[1], h = 0, u = 1, d = 2;
  for (e[0] = { s: -1, f: a.f + l.f, l: a, r: l }; u != r - 1; )
    a = e[e[h].f < e[d].f ? h++ : d++], l = e[h != u && e[h].f < e[d].f ? h++ : d++], e[u++] = { s: -1, f: a.f + l.f, l: a, r: l };
  for (var p = s[0].s, i = 1; i < r; ++i)
    s[i].s > p && (p = s[i].s);
  var f = new Di(p + 1), g = cf(e[u - 1], f, 0);
  if (g > t) {
    var i = 0, b = 0, x = g - t, y = 1 << x;
    for (s.sort(function(D, E) {
      return f[E.s] - f[D.s] || D.f - E.f;
    }); i < r; ++i) {
      var v = s[i].s;
      if (f[v] > t)
        b += y - (1 << g - f[v]), f[v] = t;
      else
        break;
    }
    for (b >>= x; b > 0; ) {
      var k = s[i].s;
      f[k] < t ? b -= 1 << t - f[k]++ - 1 : ++i;
    }
    for (; i >= 0 && b; --i) {
      var C = s[i].s;
      f[C] == t && (--f[C], ++b);
    }
    g = t;
  }
  return { t: new ui(f), l: g };
}, cf = function(n, t, e) {
  return n.s == -1 ? Math.max(cf(n.l, t, e + 1), cf(n.r, t, e + 1)) : t[n.s] = e;
}, Hp = function(n) {
  for (var t = n.length; t && !n[--t]; )
    ;
  for (var e = new Di(++t), i = 0, r = n[0], s = 1, o = function(l) {
    e[i++] = l;
  }, a = 1; a <= t; ++a)
    if (n[a] == r && a != t)
      ++s;
    else {
      if (!r && s > 2) {
        for (; s > 138; s -= 138)
          o(32754);
        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(r), --s; s > 6; s -= 6)
          o(8304);
        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        o(r);
      s = 1, r = n[a];
    }
  return { c: e.subarray(0, i), n: t };
}, hl = function(n, t) {
  for (var e = 0, i = 0; i < t.length; ++i)
    e += n[i] * t[i];
  return e;
}, k1 = function(n, t, e) {
  var i = e.length, r = Sd(t + 2);
  n[r] = i & 255, n[r + 1] = i >> 8, n[r + 2] = n[r] ^ 255, n[r + 3] = n[r + 1] ^ 255;
  for (var s = 0; s < i; ++s)
    n[r + s + 4] = e[s];
  return (r + 4 + i) * 8;
}, Gp = function(n, t, e, i, r, s, o, a, l, h, u) {
  Jr(t, u++, e), ++r[256];
  for (var d = kh(r, 15), p = d.t, f = d.l, g = kh(s, 15), b = g.t, x = g.l, y = Hp(p), v = y.c, k = y.n, C = Hp(b), I = C.c, D = C.n, E = new Di(19), O = 0; O < v.length; ++O)
    ++E[v[O] & 31];
  for (var O = 0; O < I.length; ++O)
    ++E[I[O] & 31];
  for (var M = kh(E, 7), q = M.t, P = M.l, A = 19; A > 4 && !q[af[A - 1]]; --A)
    ;
  var F = h + 5 << 3, _ = hl(r, $s) + hl(s, Pl) + o, J = hl(r, p) + hl(s, b) + o + 14 + 3 * A + hl(E, q) + 2 * E[16] + 3 * E[17] + 7 * E[18];
  if (l >= 0 && F <= _ && F <= J)
    return k1(t, u, n.subarray(l, l + h));
  var V, R, tt, H;
  if (Jr(t, u, 1 + (J < _)), u += 2, J < _) {
    V = Er(p, f, 0), R = p, tt = Er(b, x, 0), H = b;
    var ct = Er(q, P, 0);
    Jr(t, u, k - 257), Jr(t, u + 5, D - 1), Jr(t, u + 10, A - 4), u += 14;
    for (var O = 0; O < A; ++O)
      Jr(t, u + 3 * O, q[af[O]]);
    u += 3 * A;
    for (var it = [v, I], N = 0; N < 2; ++N)
      for (var z = it[N], O = 0; O < z.length; ++O) {
        var G = z[O] & 31;
        Jr(t, u, ct[G]), u += q[G], G > 15 && (Jr(t, u, z[O] >> 5 & 127), u += z[O] >> 12);
      }
  } else
    V = nv, R = $s, tt = rv, H = Pl;
  for (var O = 0; O < a; ++O) {
    var Y = i[O];
    if (Y > 255) {
      var G = Y >> 18 & 31;
      cl(t, u, V[G + 257]), u += R[G + 257], G > 7 && (Jr(t, u, Y >> 23 & 31), u += Mc[G]);
      var ot = Y & 31;
      cl(t, u, tt[ot]), u += H[ot], ot > 3 && (cl(t, u, Y >> 5 & 8191), u += Dc[ot]);
    } else
      cl(t, u, V[Y]), u += R[Y];
  }
  return cl(t, u, V[256]), u + R[256];
}, lv = /* @__PURE__ */ new _d([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), A1 = /* @__PURE__ */ new ui(0), uv = function(n, t, e, i, r, s) {
  var o = s.z || n.length, a = new ui(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r), l = a.subarray(i, a.length - r), h = s.l, u = (s.r || 0) & 7;
  if (t) {
    u && (l[0] = s.r >> 3);
    for (var d = lv[t - 1], p = d >> 13, f = d & 8191, g = (1 << e) - 1, b = s.p || new Di(32768), x = s.h || new Di(g + 1), y = Math.ceil(e / 3), v = 2 * y, k = function(T) {
      return (n[T] ^ n[T + 1] << y ^ n[T + 2] << v) & g;
    }, C = new _d(25e3), I = new Di(288), D = new Di(32), E = 0, O = 0, M = s.i || 0, q = 0, P = s.w || 0, A = 0; M + 2 < o; ++M) {
      var F = k(M), _ = M & 32767, J = x[F];
      if (b[_] = J, x[F] = _, P <= M) {
        var V = o - M;
        if ((E > 7e3 || q > 24576) && (V > 423 || !h)) {
          u = Gp(n, l, 0, C, I, D, O, q, A, M - A, u), q = E = O = 0, A = M;
          for (var R = 0; R < 286; ++R)
            I[R] = 0;
          for (var R = 0; R < 30; ++R)
            D[R] = 0;
        }
        var tt = 2, H = 0, ct = f, it = _ - J & 32767;
        if (V > 2 && F == k(M - it))
          for (var N = Math.min(p, V) - 1, z = Math.min(32767, M), G = Math.min(258, V); it <= z && --ct && _ != J; ) {
            if (n[M + tt] == n[M + tt - it]) {
              for (var Y = 0; Y < G && n[M + Y] == n[M + Y - it]; ++Y)
                ;
              if (Y > tt) {
                if (tt = Y, H = it, Y > N)
                  break;
                for (var ot = Math.min(it, Y - 2), xt = 0, R = 0; R < ot; ++R) {
                  var gt = M - it + R & 32767, wt = b[gt], qt = gt - wt & 32767;
                  qt > xt && (xt = qt, J = gt);
                }
              }
            }
            _ = J, J = b[_], it += _ - J & 32767;
          }
        if (H) {
          C[q++] = 268435456 | lf[tt] << 18 | Wp[H];
          var Rt = lf[tt] & 31, Yt = Wp[H] & 31;
          O += Mc[Rt] + Dc[Yt], ++I[257 + Rt], ++D[Yt], P = M + tt, ++E;
        } else
          C[q++] = n[M], ++I[n[M]];
      }
    }
    for (M = Math.max(M, P); M < o; ++M)
      C[q++] = n[M], ++I[n[M]];
    u = Gp(n, l, h, C, I, D, O, q, A, M - A, u), h || (s.r = u & 7 | l[u / 8 | 0] << 3, u -= 7, s.h = x, s.p = b, s.i = M, s.w = P);
  } else {
    for (var M = s.w || 0; M < o + h; M += 65535) {
      var Kt = M + 65535;
      Kt >= o && (l[u / 8 | 0] = h, Kt = o), u = k1(l, u + 1, n.subarray(M, Kt));
    }
    s.i = o;
  }
  return S1(a, 0, i + Sd(u) + r);
}, N1 = function() {
  var n = 1, t = 0;
  return {
    p: function(e) {
      for (var i = n, r = t, s = e.length | 0, o = 0; o != s; ) {
        for (var a = Math.min(o + 2655, s); o < a; ++o)
          r += i += e[o];
        i = (i & 65535) + 15 * (i >> 16), r = (r & 65535) + 15 * (r >> 16);
      }
      n = i, t = r;
    },
    d: function() {
      return n %= 65521, t %= 65521, (n & 255) << 24 | (n & 65280) << 8 | (t & 255) << 8 | t >> 8;
    }
  };
}, cv = function(n, t, e, i, r) {
  if (!r && (r = { l: 1 }, t.dictionary)) {
    var s = t.dictionary.subarray(-32768), o = new ui(s.length + n.length);
    o.set(s), o.set(n, s.length), n = o, r.w = s.length;
  }
  return uv(n, t.level == null ? 6 : t.level, t.mem == null ? r.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 20 : 12 + t.mem, e, i, r);
}, C1 = function(n, t, e) {
  for (; e; ++t)
    n[t] = e, e >>>= 8;
}, hv = function(n, t) {
  var e = t.level, i = e == 0 ? 0 : e < 6 ? 1 : e == 9 ? 3 : 2;
  if (n[0] = 120, n[1] = i << 6 | (t.dictionary && 32), n[1] |= 31 - (n[0] << 8 | n[1]) % 31, t.dictionary) {
    var r = N1();
    r.p(t.dictionary), C1(n, 2, r.d());
  }
}, fv = function(n, t) {
  return ((n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31) && lr(6, "invalid zlib data"), (n[1] >> 5 & 1) == +!t && lr(6, "invalid zlib data: " + (n[1] & 32 ? "need" : "unexpected") + " dictionary"), (n[1] >> 3 & 4) + 2;
};
function hf(n, t) {
  t || (t = {});
  var e = N1();
  e.p(n);
  var i = cv(n, t, t.dictionary ? 6 : 2, 4);
  return hv(i, t), C1(i, i.length - 4, e.d()), i;
}
function dv(n, t) {
  return av(n.subarray(fv(n, t), -4), { i: 2 }, t, t);
}
var pv = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), gv = 0;
try {
  pv.decode(A1, { stream: !0 }), gv = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Ae = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Ah() {
  Ae.console && typeof Ae.console.log == "function" && Ae.console.log.apply(Ae.console, arguments);
}
var an = { log: Ah, warn: function(n) {
  Ae.console && (typeof Ae.console.warn == "function" ? Ae.console.warn.apply(Ae.console, arguments) : Ah.call(null, arguments));
}, error: function(n) {
  Ae.console && (typeof Ae.console.error == "function" ? Ae.console.error.apply(Ae.console, arguments) : Ah(n));
} };
function Nh(n, t, e) {
  var i = new XMLHttpRequest();
  i.open("GET", n), i.responseType = "blob", i.onload = function() {
    lo(i.response, t, e);
  }, i.onerror = function() {
    an.error("could not download file");
  }, i.send();
}
function Vp(n) {
  var t = new XMLHttpRequest();
  t.open("HEAD", n, !1);
  try {
    t.send();
  } catch {
  }
  return t.status >= 200 && t.status <= 299;
}
function Nu(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var t = document.createEvent("MouseEvents");
    t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(t);
  }
}
var Sl, ff, lo = Ae.saveAs || ((typeof window > "u" ? "undefined" : en(window)) !== "object" || window !== Ae ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, t, e) {
  var i = Ae.URL || Ae.webkitURL, r = document.createElement("a");
  t = t || n.name || "download", r.download = t, r.rel = "noopener", typeof n == "string" ? (r.href = n, r.origin !== location.origin ? Vp(r.href) ? Nh(n, t, e) : Nu(r, r.target = "_blank") : Nu(r)) : (r.href = i.createObjectURL(n), setTimeout(function() {
    i.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Nu(r);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, t, e) {
  if (t = t || n.name || "download", typeof n == "string") if (Vp(n)) Nh(n, t, e);
  else {
    var i = document.createElement("a");
    i.href = n, i.target = "_blank", setTimeout(function() {
      Nu(i);
    });
  }
  else navigator.msSaveOrOpenBlob(function(r, s) {
    return s === void 0 ? s = { autoBom: !1 } : en(s) !== "object" && (an.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(r.type) ? new Blob(["\uFEFF", r], { type: r.type }) : r;
  }(n, e), t);
} : function(n, t, e, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof n == "string") return Nh(n, t, e);
  var r = n.type === "application/octet-stream", s = /constructor/i.test(Ae.HTMLElement) || Ae.safari, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || r && s) && (typeof FileReader > "u" ? "undefined" : en(FileReader)) === "object") {
    var a = new FileReader();
    a.onloadend = function() {
      var u = a.result;
      u = o ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = u : location = u, i = null;
    }, a.readAsDataURL(n);
  } else {
    var l = Ae.URL || Ae.webkitURL, h = l.createObjectURL(n);
    i ? i.location = h : location.href = h, i = null, setTimeout(function() {
      l.revokeObjectURL(h);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function P1(n) {
  var t;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var e = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(a) {
    return [parseInt(a[1]), parseInt(a[2]), parseInt(a[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(a) {
    return [parseInt(a[1], 16), parseInt(a[2], 16), parseInt(a[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(a) {
    return [parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16), parseInt(a[3] + a[3], 16)];
  } }], i = 0; i < e.length; i++) {
    var r = e[i].re, s = e[i].process, o = r.exec(n);
    o && (t = s(o), this.r = t[0], this.g = t[1], this.b = t[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var a = this.r.toString(16), l = this.g.toString(16), h = this.b.toString(16);
    return a.length == 1 && (a = "0" + a), l.length == 1 && (l = "0" + l), h.length == 1 && (h = "0" + h), "#" + a + l + h;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ch(n, t) {
  var e = n[0], i = n[1], r = n[2], s = n[3];
  e = ii(e, i, r, s, t[0], 7, -680876936), s = ii(s, e, i, r, t[1], 12, -389564586), r = ii(r, s, e, i, t[2], 17, 606105819), i = ii(i, r, s, e, t[3], 22, -1044525330), e = ii(e, i, r, s, t[4], 7, -176418897), s = ii(s, e, i, r, t[5], 12, 1200080426), r = ii(r, s, e, i, t[6], 17, -1473231341), i = ii(i, r, s, e, t[7], 22, -45705983), e = ii(e, i, r, s, t[8], 7, 1770035416), s = ii(s, e, i, r, t[9], 12, -1958414417), r = ii(r, s, e, i, t[10], 17, -42063), i = ii(i, r, s, e, t[11], 22, -1990404162), e = ii(e, i, r, s, t[12], 7, 1804603682), s = ii(s, e, i, r, t[13], 12, -40341101), r = ii(r, s, e, i, t[14], 17, -1502002290), e = ri(e, i = ii(i, r, s, e, t[15], 22, 1236535329), r, s, t[1], 5, -165796510), s = ri(s, e, i, r, t[6], 9, -1069501632), r = ri(r, s, e, i, t[11], 14, 643717713), i = ri(i, r, s, e, t[0], 20, -373897302), e = ri(e, i, r, s, t[5], 5, -701558691), s = ri(s, e, i, r, t[10], 9, 38016083), r = ri(r, s, e, i, t[15], 14, -660478335), i = ri(i, r, s, e, t[4], 20, -405537848), e = ri(e, i, r, s, t[9], 5, 568446438), s = ri(s, e, i, r, t[14], 9, -1019803690), r = ri(r, s, e, i, t[3], 14, -187363961), i = ri(i, r, s, e, t[8], 20, 1163531501), e = ri(e, i, r, s, t[13], 5, -1444681467), s = ri(s, e, i, r, t[2], 9, -51403784), r = ri(r, s, e, i, t[7], 14, 1735328473), e = si(e, i = ri(i, r, s, e, t[12], 20, -1926607734), r, s, t[5], 4, -378558), s = si(s, e, i, r, t[8], 11, -2022574463), r = si(r, s, e, i, t[11], 16, 1839030562), i = si(i, r, s, e, t[14], 23, -35309556), e = si(e, i, r, s, t[1], 4, -1530992060), s = si(s, e, i, r, t[4], 11, 1272893353), r = si(r, s, e, i, t[7], 16, -155497632), i = si(i, r, s, e, t[10], 23, -1094730640), e = si(e, i, r, s, t[13], 4, 681279174), s = si(s, e, i, r, t[0], 11, -358537222), r = si(r, s, e, i, t[3], 16, -722521979), i = si(i, r, s, e, t[6], 23, 76029189), e = si(e, i, r, s, t[9], 4, -640364487), s = si(s, e, i, r, t[12], 11, -421815835), r = si(r, s, e, i, t[15], 16, 530742520), e = oi(e, i = si(i, r, s, e, t[2], 23, -995338651), r, s, t[0], 6, -198630844), s = oi(s, e, i, r, t[7], 10, 1126891415), r = oi(r, s, e, i, t[14], 15, -1416354905), i = oi(i, r, s, e, t[5], 21, -57434055), e = oi(e, i, r, s, t[12], 6, 1700485571), s = oi(s, e, i, r, t[3], 10, -1894986606), r = oi(r, s, e, i, t[10], 15, -1051523), i = oi(i, r, s, e, t[1], 21, -2054922799), e = oi(e, i, r, s, t[8], 6, 1873313359), s = oi(s, e, i, r, t[15], 10, -30611744), r = oi(r, s, e, i, t[6], 15, -1560198380), i = oi(i, r, s, e, t[13], 21, 1309151649), e = oi(e, i, r, s, t[4], 6, -145523070), s = oi(s, e, i, r, t[11], 10, -1120210379), r = oi(r, s, e, i, t[2], 15, 718787259), i = oi(i, r, s, e, t[9], 21, -343485551), n[0] = Ms(e, n[0]), n[1] = Ms(i, n[1]), n[2] = Ms(r, n[2]), n[3] = Ms(s, n[3]);
}
function Rc(n, t, e, i, r, s) {
  return t = Ms(Ms(t, n), Ms(i, s)), Ms(t << r | t >>> 32 - r, e);
}
function ii(n, t, e, i, r, s, o) {
  return Rc(t & e | ~t & i, n, t, r, s, o);
}
function ri(n, t, e, i, r, s, o) {
  return Rc(t & i | e & ~i, n, t, r, s, o);
}
function si(n, t, e, i, r, s, o) {
  return Rc(t ^ e ^ i, n, t, r, s, o);
}
function oi(n, t, e, i, r, s, o) {
  return Rc(e ^ (t | ~i), n, t, r, s, o);
}
function L1(n) {
  var t, e = n.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (t = 64; t <= n.length; t += 64) Ch(i, mv(n.substring(t - 64, t)));
  n = n.substring(t - 64);
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (t = 0; t < n.length; t++) r[t >> 2] |= n.charCodeAt(t) << (t % 4 << 3);
  if (r[t >> 2] |= 128 << (t % 4 << 3), t > 55) for (Ch(i, r), t = 0; t < 16; t++) r[t] = 0;
  return r[14] = 8 * e, Ch(i, r), i;
}
function mv(n) {
  var t, e = [];
  for (t = 0; t < 64; t += 4) e[t >> 2] = n.charCodeAt(t) + (n.charCodeAt(t + 1) << 8) + (n.charCodeAt(t + 2) << 16) + (n.charCodeAt(t + 3) << 24);
  return e;
}
Sl = Ae.atob.bind(Ae), ff = Ae.btoa.bind(Ae);
var Yp = "0123456789abcdef".split("");
function yv(n) {
  for (var t = "", e = 0; e < 4; e++) t += Yp[n >> 8 * e + 4 & 15] + Yp[n >> 8 * e & 15];
  return t;
}
function bv(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function df(n) {
  return L1(n).map(bv).join("");
}
var vv = function(n) {
  for (var t = 0; t < n.length; t++) n[t] = yv(n[t]);
  return n.join("");
}(L1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Ms(n, t) {
  if (vv) {
    var e = (65535 & n) + (65535 & t);
    return (n >> 16) + (t >> 16) + (e >> 16) << 16 | 65535 & e;
  }
  return n + t & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function pf(n, t) {
  var e, i, r, s;
  if (n !== e) {
    for (var o = (r = n, s = 1 + (256 / n.length >> 0), new Array(s + 1).join(r)), a = [], l = 0; l < 256; l++) a[l] = l;
    var h = 0;
    for (l = 0; l < 256; l++) {
      var u = a[l];
      h = (h + u + o.charCodeAt(l)) % 256, a[l] = a[h], a[h] = u;
    }
    e = n, i = a;
  } else a = i;
  var d = t.length, p = 0, f = 0, g = "";
  for (l = 0; l < d; l++) f = (f + (u = a[p = (p + 1) % 256])) % 256, a[p] = a[f], a[f] = u, o = a[(a[p] + a[f]) % 256], g += String.fromCharCode(t.charCodeAt(l) ^ o);
  return g;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Kp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function fa(n, t, e, i) {
  this.v = 1, this.r = 2;
  var r = 192;
  n.forEach(function(a) {
    if (Kp.perm !== void 0) throw new Error("Invalid permission: " + a);
    r += Kp[a];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (t + this.padding).substr(0, 32), o = (e + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, o), this.P = -(1 + (255 ^ r)), this.encryptionKey = df(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = pf(this.encryptionKey, this.padding);
}
function da(n) {
  if (/[^\u0000-\u00ff]/.test(n)) throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var t = "", e = n.length, i = 0; i < e; i++) {
    var r = n.charCodeAt(i);
    r < 33 || r === 35 || r === 37 || r === 40 || r === 41 || r === 47 || r === 60 || r === 62 || r === 91 || r === 93 || r === 123 || r === 125 || r > 126 ? t += "#" + ("0" + r.toString(16)).slice(-2) : t += n[i];
  }
  return t;
}
function Xp(n) {
  if (en(n) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var t = {};
  this.subscribe = function(e, i, r) {
    if (r = r || !1, typeof e != "string" || typeof i != "function" || typeof r != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    t.hasOwnProperty(e) || (t[e] = {});
    var s = Math.random().toString(35);
    return t[e][s] = [i, !!r], s;
  }, this.unsubscribe = function(e) {
    for (var i in t) if (t[i][e]) return delete t[i][e], Object.keys(t[i]).length === 0 && delete t[i], !0;
    return !1;
  }, this.publish = function(e) {
    if (t.hasOwnProperty(e)) {
      var i = Array.prototype.slice.call(arguments, 1), r = [];
      for (var s in t[e]) {
        var o = t[e][s];
        try {
          o[0].apply(n, i);
        } catch (a) {
          Ae.console && an.error("jsPDF PubSub Error", a.message, a);
        }
        o[1] && r.push(s);
      }
      r.length && r.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return t;
  };
}
function Ll(n) {
  if (!(this instanceof Ll)) return new Ll(n);
  var t = "opacity,stroke-opacity".split(",");
  for (var e in n) n.hasOwnProperty(e) && t.indexOf(e) >= 0 && (this[e] = n[e]);
  this.id = "", this.objectNumber = -1;
}
function I1(n, t) {
  this.gState = n, this.matrix = t, this.id = "", this.objectNumber = -1;
}
function Ts(n, t, e, i, r) {
  if (!(this instanceof Ts)) return new Ts(n, t, e, i, r);
  this.type = n === "axial" ? 2 : 3, this.coords = t, this.colors = e, I1.call(this, i, r);
}
function po(n, t, e, i, r) {
  if (!(this instanceof po)) return new po(n, t, e, i, r);
  this.boundingBox = n, this.xStep = t, this.yStep = e, this.stream = "", this.cloneIndex = 0, I1.call(this, i, r);
}
function Se(n) {
  var t, e = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], r = arguments[2], s = arguments[3], o = [], a = 1, l = 16, h = "S", u = null;
  en(n = n || {}) === "object" && (e = n.orientation, i = n.unit || i, r = n.format || r, s = n.compress || n.compressPdf || s, (u = n.encryption || null) !== null && (u.userPassword = u.userPassword || "", u.ownerPassword = u.ownerPassword || "", u.userPermissions = u.userPermissions || []), a = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (t = n.precision), n.floatPrecision !== void 0 && (l = n.floatPrecision), h = n.defaultPathOperation || "S"), o = n.filters || (s === !0 ? ["FlateEncode"] : o), i = i || "mm", e = ("" + (e || "P")).toLowerCase();
  var d = n.putOnlyUsedFonts || !1, p = {}, f = { internal: {}, __private__: {} };
  f.__private__.PubSub = Xp;
  var g = "1.3", b = f.__private__.getPdfVersion = function() {
    return g;
  };
  f.__private__.setPdfVersion = function(w) {
    g = w;
  };
  var x = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  f.__private__.getPageFormats = function() {
    return x;
  };
  var y = f.__private__.getPageFormat = function(w) {
    return x[w];
  };
  r = r || "a4";
  var v = { COMPAT: "compat", ADVANCED: "advanced" }, k = v.COMPAT;
  function C() {
    this.saveGraphicsState(), $(new we(Xt, 0, 0, -Xt, 0, ms() * Xt).toString() + " cm"), this.setFontSize(this.getFontSize() / Xt), h = "n", k = v.ADVANCED;
  }
  function I() {
    this.restoreGraphicsState(), h = "S", k = v.COMPAT;
  }
  var D = f.__private__.combineFontStyleAndFontWeight = function(w, j) {
    if (w == "bold" && j == "normal" || w == "bold" && j == 400 || w == "normal" && j == "italic" || w == "bold" && j == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return j && (w = j == 400 || j === "normal" ? w === "italic" ? "italic" : "normal" : j != 700 && j !== "bold" || w !== "normal" ? (j == 700 ? "bold" : j) + "" + w : "bold"), w;
  };
  f.advancedAPI = function(w) {
    var j = k === v.COMPAT;
    return j && C.call(this), typeof w != "function" || (w(this), j && I.call(this)), this;
  }, f.compatAPI = function(w) {
    var j = k === v.ADVANCED;
    return j && I.call(this), typeof w != "function" || (w(this), j && C.call(this)), this;
  }, f.isAdvancedAPI = function() {
    return k === v.ADVANCED;
  };
  var E, O = function(w) {
    if (k !== v.ADVANCED) throw new Error(w + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, M = f.roundToPrecision = f.__private__.roundToPrecision = function(w, j) {
    var ut = t || j;
    if (isNaN(w) || isNaN(ut)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return w.toFixed(ut).replace(/0+$/, "");
  };
  E = f.hpf = f.__private__.hpf = typeof l == "number" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, l);
  } : l === "smart" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, w > -1 && w < 1 ? 16 : 5);
  } : function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, 16);
  };
  var q = f.f2 = f.__private__.f2 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f2");
    return M(w, 2);
  }, P = f.__private__.f3 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f3");
    return M(w, 3);
  }, A = f.scale = f.__private__.scale = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.scale");
    return k === v.COMPAT ? w * Xt : k === v.ADVANCED ? w : void 0;
  }, F = function(w) {
    return k === v.COMPAT ? ms() - w : k === v.ADVANCED ? w : void 0;
  }, _ = function(w) {
    return A(F(w));
  };
  f.__private__.setPrecision = f.setPrecision = function(w) {
    typeof parseInt(w, 10) == "number" && (t = parseInt(w, 10));
  };
  var J, V = "00000000000000000000000000000000", R = f.__private__.getFileId = function() {
    return V;
  }, tt = f.__private__.setFileId = function(w) {
    return V = w !== void 0 && /^[a-fA-F0-9]{32}$/.test(w) ? w.toUpperCase() : V.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), u !== null && (Re = new fa(u.userPermissions, u.userPassword, u.ownerPassword, V)), V;
  };
  f.setFileId = function(w) {
    return tt(w), this;
  }, f.getFileId = function() {
    return R();
  };
  var H = f.__private__.convertDateToPDFDate = function(w) {
    var j = w.getTimezoneOffset(), ut = j < 0 ? "+" : "-", pt = Math.floor(Math.abs(j / 60)), Ct = Math.abs(j % 60), Dt = [ut, G(pt), "'", G(Ct), "'"].join("");
    return ["D:", w.getFullYear(), G(w.getMonth() + 1), G(w.getDate()), G(w.getHours()), G(w.getMinutes()), G(w.getSeconds()), Dt].join("");
  }, ct = f.__private__.convertPDFDateToDate = function(w) {
    var j = parseInt(w.substr(2, 4), 10), ut = parseInt(w.substr(6, 2), 10) - 1, pt = parseInt(w.substr(8, 2), 10), Ct = parseInt(w.substr(10, 2), 10), Dt = parseInt(w.substr(12, 2), 10), Vt = parseInt(w.substr(14, 2), 10);
    return new Date(j, ut, pt, Ct, Dt, Vt, 0);
  }, it = f.__private__.setCreationDate = function(w) {
    var j;
    if (w === void 0 && (w = /* @__PURE__ */ new Date()), w instanceof Date) j = H(w);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(w)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      j = w;
    }
    return J = j;
  }, N = f.__private__.getCreationDate = function(w) {
    var j = J;
    return w === "jsDate" && (j = ct(J)), j;
  };
  f.setCreationDate = function(w) {
    return it(w), this;
  }, f.getCreationDate = function(w) {
    return N(w);
  };
  var z, G = f.__private__.padd2 = function(w) {
    return ("0" + parseInt(w)).slice(-2);
  }, Y = f.__private__.padd2Hex = function(w) {
    return ("00" + (w = w.toString())).substr(w.length);
  }, ot = 0, xt = [], gt = [], wt = 0, qt = [], Rt = [], Yt = !1, Kt = gt, T = function() {
    ot = 0, wt = 0, gt = [], xt = [], qt = [], tr = vn(), mi = vn();
  };
  f.__private__.setCustomOutputDestination = function(w) {
    Yt = !0, Kt = w;
  };
  var ht = function(w) {
    Yt || (Kt = w);
  };
  f.__private__.resetCustomOutputDestination = function() {
    Yt = !1, Kt = gt;
  };
  var $ = f.__private__.out = function(w) {
    return w = w.toString(), wt += w.length + 1, Kt.push(w), Kt;
  }, nt = f.__private__.write = function(w) {
    return $(arguments.length === 1 ? w.toString() : Array.prototype.join.call(arguments, " "));
  }, X = f.__private__.getArrayBuffer = function(w) {
    for (var j = w.length, ut = new ArrayBuffer(j), pt = new Uint8Array(ut); j--; ) pt[j] = w.charCodeAt(j);
    return ut;
  }, st = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  f.__private__.getStandardFonts = function() {
    return st;
  };
  var vt = n.fontSize || 16;
  f.__private__.setFontSize = f.setFontSize = function(w) {
    return vt = k === v.ADVANCED ? w / Xt : w, this;
  };
  var St, ft = f.__private__.getFontSize = f.getFontSize = function() {
    return k === v.COMPAT ? vt : vt * Xt;
  }, Et = n.R2L || !1;
  f.__private__.setR2L = f.setR2L = function(w) {
    return Et = w, this;
  }, f.__private__.getR2L = f.getR2L = function() {
    return Et;
  };
  var zt, Tt = f.__private__.setZoomMode = function(w) {
    var j = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(w)) St = w;
    else if (isNaN(w)) {
      if (j.indexOf(w) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + w + '" is not recognized.');
      St = w;
    } else St = parseInt(w, 10);
  };
  f.__private__.getZoomMode = function() {
    return St;
  };
  var $t, te = f.__private__.setPageMode = function(w) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(w) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + w + '" is not recognized.');
    zt = w;
  };
  f.__private__.getPageMode = function() {
    return zt;
  };
  var oe = f.__private__.setLayoutMode = function(w) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(w) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + w + '" is not recognized.');
    $t = w;
  };
  f.__private__.getLayoutMode = function() {
    return $t;
  }, f.__private__.setDisplayMode = f.setDisplayMode = function(w, j, ut) {
    return Tt(w), oe(j), te(ut), this;
  };
  var ae = { title: "", subject: "", author: "", keywords: "", creator: "" };
  f.__private__.getDocumentProperty = function(w) {
    if (Object.keys(ae).indexOf(w) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ae[w];
  }, f.__private__.getDocumentProperties = function() {
    return ae;
  }, f.__private__.setDocumentProperties = f.setProperties = f.setDocumentProperties = function(w) {
    for (var j in ae) ae.hasOwnProperty(j) && w[j] && (ae[j] = w[j]);
    return this;
  }, f.__private__.setDocumentProperty = function(w, j) {
    if (Object.keys(ae).indexOf(w) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ae[w] = j;
  };
  var xe, Xt, Nt, Ot, ie, Jt = {}, fe = {}, ne = [], de = {}, Ue = {}, Te = {}, Sn = {}, Mn = null, Ze = 0, Ce = [], qe = new Xp(f), Qi = n.hotfixes || [], yn = {}, Ri = {}, qn = [], we = function w(j, ut, pt, Ct, Dt, Vt) {
    if (!(this instanceof w)) return new w(j, ut, pt, Ct, Dt, Vt);
    isNaN(j) && (j = 1), isNaN(ut) && (ut = 0), isNaN(pt) && (pt = 0), isNaN(Ct) && (Ct = 1), isNaN(Dt) && (Dt = 0), isNaN(Vt) && (Vt = 0), this._matrix = [j, ut, pt, Ct, Dt, Vt];
  };
  Object.defineProperty(we.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(we.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(we.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(we.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(we.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(we.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(we.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(we.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(we.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(we.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(we.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(we.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(we.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(we.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(we.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(we.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), we.prototype.join = function(w) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(E).join(w);
  }, we.prototype.multiply = function(w) {
    var j = w.sx * this.sx + w.shy * this.shx, ut = w.sx * this.shy + w.shy * this.sy, pt = w.shx * this.sx + w.sy * this.shx, Ct = w.shx * this.shy + w.sy * this.sy, Dt = w.tx * this.sx + w.ty * this.shx + this.tx, Vt = w.tx * this.shy + w.ty * this.sy + this.ty;
    return new we(j, ut, pt, Ct, Dt, Vt);
  }, we.prototype.decompose = function() {
    var w = this.sx, j = this.shy, ut = this.shx, pt = this.sy, Ct = this.tx, Dt = this.ty, Vt = Math.sqrt(w * w + j * j), le = (w /= Vt) * ut + (j /= Vt) * pt;
    ut -= w * le, pt -= j * le;
    var ve = Math.sqrt(ut * ut + pt * pt);
    return le /= ve, w * (pt /= ve) < j * (ut /= ve) && (w = -w, j = -j, le = -le, Vt = -Vt), { scale: new we(Vt, 0, 0, ve, 0, 0), translate: new we(1, 0, 0, 1, Ct, Dt), rotate: new we(w, j, -j, w, 0, 0), skew: new we(1, 0, le, 1, 0, 0) };
  }, we.prototype.toString = function(w) {
    return this.join(" ");
  }, we.prototype.inversed = function() {
    var w = this.sx, j = this.shy, ut = this.shx, pt = this.sy, Ct = this.tx, Dt = this.ty, Vt = 1 / (w * pt - j * ut), le = pt * Vt, ve = -j * Vt, Ee = -ut * Vt, Le = w * Vt;
    return new we(le, ve, Ee, Le, -le * Ct - Ee * Dt, -ve * Ct - Le * Dt);
  }, we.prototype.applyToPoint = function(w) {
    var j = w.x * this.sx + w.y * this.shx + this.tx, ut = w.x * this.shy + w.y * this.sy + this.ty;
    return new qo(j, ut);
  }, we.prototype.applyToRectangle = function(w) {
    var j = this.applyToPoint(w), ut = this.applyToPoint(new qo(w.x + w.w, w.y + w.h));
    return new za(j.x, j.y, ut.x - j.x, ut.y - j.y);
  }, we.prototype.clone = function() {
    var w = this.sx, j = this.shy, ut = this.shx, pt = this.sy, Ct = this.tx, Dt = this.ty;
    return new we(w, j, ut, pt, Ct, Dt);
  }, f.Matrix = we;
  var Ai = f.matrixMult = function(w, j) {
    return j.multiply(w);
  }, Bi = new we(1, 0, 0, 1, 0, 0);
  f.unitMatrix = f.identityMatrix = Bi;
  var ti = function(w, j) {
    if (!Ue[w]) {
      var ut = (j instanceof Ts ? "Sh" : "P") + (Object.keys(de).length + 1).toString(10);
      j.id = ut, Ue[w] = ut, de[ut] = j, qe.publish("addPattern", j);
    }
  };
  f.ShadingPattern = Ts, f.TilingPattern = po, f.addShadingPattern = function(w, j) {
    return O("addShadingPattern()"), ti(w, j), this;
  }, f.beginTilingPattern = function(w) {
    O("beginTilingPattern()"), Kl(w.boundingBox[0], w.boundingBox[1], w.boundingBox[2] - w.boundingBox[0], w.boundingBox[3] - w.boundingBox[1], w.matrix);
  }, f.endTilingPattern = function(w, j) {
    O("endTilingPattern()"), j.stream = Rt[z].join(`
`), ti(w, j), qe.publish("endTilingPattern", j), qn.pop().restore();
  };
  var bn = f.__private__.newObject = function() {
    var w = vn();
    return ci(w, !0), w;
  }, vn = f.__private__.newObjectDeferred = function() {
    return ot++, xt[ot] = function() {
      return wt;
    }, ot;
  }, ci = function(w, j) {
    return j = typeof j == "boolean" && j, xt[w] = wt, j && $(w + " 0 obj"), w;
  }, rs = f.__private__.newAdditionalObject = function() {
    var w = { objId: vn(), content: "" };
    return qt.push(w), w;
  }, tr = vn(), mi = vn(), Ni = f.__private__.decodeColorString = function(w) {
    var j = w.split(" ");
    if (j.length !== 2 || j[1] !== "g" && j[1] !== "G")
      j.length === 5 && (j[4] === "k" || j[4] === "K") && (j = [(1 - j[0]) * (1 - j[3]), (1 - j[1]) * (1 - j[3]), (1 - j[2]) * (1 - j[3]), "r"]);
    else {
      var ut = parseFloat(j[0]);
      j = [ut, ut, ut, "r"];
    }
    for (var pt = "#", Ct = 0; Ct < 3; Ct++) pt += ("0" + Math.floor(255 * parseFloat(j[Ct])).toString(16)).slice(-2);
    return pt;
  }, Ci = f.__private__.encodeColorString = function(w) {
    var j;
    typeof w == "string" && (w = { ch1: w });
    var ut = w.ch1, pt = w.ch2, Ct = w.ch3, Dt = w.ch4, Vt = w.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ut == "string" && ut.charAt(0) !== "#") {
      var le = new P1(ut);
      if (le.ok) ut = le.toHex();
      else if (!/^\d*\.?\d*$/.test(ut)) throw new Error('Invalid color "' + ut + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof ut == "string" && /^#[0-9A-Fa-f]{3}$/.test(ut) && (ut = "#" + ut[1] + ut[1] + ut[2] + ut[2] + ut[3] + ut[3]), typeof ut == "string" && /^#[0-9A-Fa-f]{6}$/.test(ut)) {
      var ve = parseInt(ut.substr(1), 16);
      ut = ve >> 16 & 255, pt = ve >> 8 & 255, Ct = 255 & ve;
    }
    if (pt === void 0 || Dt === void 0 && ut === pt && pt === Ct) if (typeof ut == "string") j = ut + " " + Vt[0];
    else switch (w.precision) {
      case 2:
        j = q(ut / 255) + " " + Vt[0];
        break;
      case 3:
      default:
        j = P(ut / 255) + " " + Vt[0];
    }
    else if (Dt === void 0 || en(Dt) === "object") {
      if (Dt && !isNaN(Dt.a) && Dt.a === 0) return j = ["1.", "1.", "1.", Vt[1]].join(" ");
      if (typeof ut == "string") j = [ut, pt, Ct, Vt[1]].join(" ");
      else switch (w.precision) {
        case 2:
          j = [q(ut / 255), q(pt / 255), q(Ct / 255), Vt[1]].join(" ");
          break;
        default:
        case 3:
          j = [P(ut / 255), P(pt / 255), P(Ct / 255), Vt[1]].join(" ");
      }
    } else if (typeof ut == "string") j = [ut, pt, Ct, Dt, Vt[2]].join(" ");
    else switch (w.precision) {
      case 2:
        j = [q(ut), q(pt), q(Ct), q(Dt), Vt[2]].join(" ");
        break;
      case 3:
      default:
        j = [P(ut), P(pt), P(Ct), P(Dt), Vt[2]].join(" ");
    }
    return j;
  }, ji = f.__private__.getFilters = function() {
    return o;
  }, Pi = f.__private__.putStream = function(w) {
    var j = (w = w || {}).data || "", ut = w.filters || ji(), pt = w.alreadyAppliedFilters || [], Ct = w.addLength1 || !1, Dt = j.length, Vt = w.objectId, le = function(ni) {
      return ni;
    };
    if (u !== null && Vt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    u !== null && (le = Re.encryptor(Vt, 0));
    var ve = {};
    ut === !0 && (ut = ["FlateEncode"]);
    var Ee = w.additionalKeyValues || [], Le = (ve = Se.API.processDataByFilters !== void 0 ? Se.API.processDataByFilters(j, ut) : { data: j, reverseChain: [] }).reverseChain + (Array.isArray(pt) ? pt.join(" ") : pt.toString());
    if (ve.data.length !== 0 && (Ee.push({ key: "Length", value: ve.data.length }), Ct === !0 && Ee.push({ key: "Length1", value: Dt })), Le.length != 0) if (Le.split("/").length - 1 == 1) Ee.push({ key: "Filter", value: Le });
    else {
      Ee.push({ key: "Filter", value: "[" + Le + "]" });
      for (var $e = 0; $e < Ee.length; $e += 1) if (Ee[$e].key === "DecodeParms") {
        for (var gn = [], wn = 0; wn < ve.reverseChain.split("/").length - 1; wn += 1) gn.push("null");
        gn.push(Ee[$e].value), Ee[$e].value = "[" + gn.join(" ") + "]";
      }
    }
    $("<<");
    for (var En = 0; En < Ee.length; En++) $("/" + Ee[En].key + " " + Ee[En].value);
    $(">>"), ve.data.length !== 0 && ($("stream"), $(le(ve.data)), $("endstream"));
  }, qi = f.__private__.putPage = function(w) {
    var j = w.number, ut = w.data, pt = w.objId, Ct = w.contentsObjId;
    ci(pt, !0), $("<</Type /Page"), $("/Parent " + w.rootDictionaryObjId + " 0 R"), $("/Resources " + w.resourceDictionaryObjId + " 0 R"), $("/MediaBox [" + parseFloat(E(w.mediaBox.bottomLeftX)) + " " + parseFloat(E(w.mediaBox.bottomLeftY)) + " " + E(w.mediaBox.topRightX) + " " + E(w.mediaBox.topRightY) + "]"), w.cropBox !== null && $("/CropBox [" + E(w.cropBox.bottomLeftX) + " " + E(w.cropBox.bottomLeftY) + " " + E(w.cropBox.topRightX) + " " + E(w.cropBox.topRightY) + "]"), w.bleedBox !== null && $("/BleedBox [" + E(w.bleedBox.bottomLeftX) + " " + E(w.bleedBox.bottomLeftY) + " " + E(w.bleedBox.topRightX) + " " + E(w.bleedBox.topRightY) + "]"), w.trimBox !== null && $("/TrimBox [" + E(w.trimBox.bottomLeftX) + " " + E(w.trimBox.bottomLeftY) + " " + E(w.trimBox.topRightX) + " " + E(w.trimBox.topRightY) + "]"), w.artBox !== null && $("/ArtBox [" + E(w.artBox.bottomLeftX) + " " + E(w.artBox.bottomLeftY) + " " + E(w.artBox.topRightX) + " " + E(w.artBox.topRightY) + "]"), typeof w.userUnit == "number" && w.userUnit !== 1 && $("/UserUnit " + w.userUnit), qe.publish("putPage", { objId: pt, pageContext: Ce[j], pageNumber: j, page: ut }), $("/Contents " + Ct + " 0 R"), $(">>"), $("endobj");
    var Dt = ut.join(`
`);
    return k === v.ADVANCED && (Dt += `
Q`), ci(Ct, !0), Pi({ data: Dt, filters: ji(), objectId: Ct }), $("endobj"), pt;
  }, br = f.__private__.putPages = function() {
    var w, j, ut = [];
    for (w = 1; w <= Ze; w++) Ce[w].objId = vn(), Ce[w].contentsObjId = vn();
    for (w = 1; w <= Ze; w++) ut.push(qi({ number: w, data: Rt[w], objId: Ce[w].objId, contentsObjId: Ce[w].contentsObjId, mediaBox: Ce[w].mediaBox, cropBox: Ce[w].cropBox, bleedBox: Ce[w].bleedBox, trimBox: Ce[w].trimBox, artBox: Ce[w].artBox, userUnit: Ce[w].userUnit, rootDictionaryObjId: tr, resourceDictionaryObjId: mi }));
    ci(tr, !0), $("<</Type /Pages");
    var pt = "/Kids [";
    for (j = 0; j < Ze; j++) pt += ut[j] + " 0 R ";
    $(pt + "]"), $("/Count " + Ze), $(">>"), $("endobj"), qe.publish("postPutPages");
  }, Dr = function(w) {
    qe.publish("putFont", { font: w, out: $, newObject: bn, putStream: Pi }), w.isAlreadyPutted !== !0 && (w.objectNumber = bn(), $("<<"), $("/Type /Font"), $("/BaseFont /" + da(w.postScriptName)), $("/Subtype /Type1"), typeof w.encoding == "string" && $("/Encoding /" + w.encoding), $("/FirstChar 32"), $("/LastChar 255"), $(">>"), $("endobj"));
  }, er = function() {
    for (var w in Jt) Jt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && Dr(Jt[w]);
  }, Rr = function(w) {
    w.objectNumber = bn();
    var j = [];
    j.push({ key: "Type", value: "/XObject" }), j.push({ key: "Subtype", value: "/Form" }), j.push({ key: "BBox", value: "[" + [E(w.x), E(w.y), E(w.x + w.width), E(w.y + w.height)].join(" ") + "]" }), j.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" });
    var ut = w.pages[1].join(`
`);
    Pi({ data: ut, additionalKeyValues: j, objectId: w.objectNumber }), $("endobj");
  }, Br = function() {
    for (var w in yn) yn.hasOwnProperty(w) && Rr(yn[w]);
  }, jr = function(w, j) {
    var ut, pt = [], Ct = 1 / (j - 1);
    for (ut = 0; ut < 1; ut += Ct) pt.push(ut);
    if (pt.push(1), w[0].offset != 0) {
      var Dt = { offset: 0, color: w[0].color };
      w.unshift(Dt);
    }
    if (w[w.length - 1].offset != 1) {
      var Vt = { offset: 1, color: w[w.length - 1].color };
      w.push(Vt);
    }
    for (var le = "", ve = 0, Ee = 0; Ee < pt.length; Ee++) {
      for (ut = pt[Ee]; ut > w[ve + 1].offset; ) ve++;
      var Le = w[ve].offset, $e = (ut - Le) / (w[ve + 1].offset - Le), gn = w[ve].color, wn = w[ve + 1].color;
      le += Y(Math.round((1 - $e) * gn[0] + $e * wn[0]).toString(16)) + Y(Math.round((1 - $e) * gn[1] + $e * wn[1]).toString(16)) + Y(Math.round((1 - $e) * gn[2] + $e * wn[2]).toString(16));
    }
    return le.trim();
  }, ss = function(w, j) {
    j || (j = 21);
    var ut = bn(), pt = jr(w.colors, j), Ct = [];
    Ct.push({ key: "FunctionType", value: "0" }), Ct.push({ key: "Domain", value: "[0.0 1.0]" }), Ct.push({ key: "Size", value: "[" + j + "]" }), Ct.push({ key: "BitsPerSample", value: "8" }), Ct.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ct.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Pi({ data: pt, additionalKeyValues: Ct, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: ut }), $("endobj"), w.objectNumber = bn(), $("<< /ShadingType " + w.type), $("/ColorSpace /DeviceRGB");
    var Dt = "/Coords [" + E(parseFloat(w.coords[0])) + " " + E(parseFloat(w.coords[1])) + " ";
    w.type === 2 ? Dt += E(parseFloat(w.coords[2])) + " " + E(parseFloat(w.coords[3])) : Dt += E(parseFloat(w.coords[2])) + " " + E(parseFloat(w.coords[3])) + " " + E(parseFloat(w.coords[4])) + " " + E(parseFloat(w.coords[5])), $(Dt += "]"), w.matrix && $("/Matrix [" + w.matrix.toString() + "]"), $("/Function " + ut + " 0 R"), $("/Extend [true true]"), $(">>"), $("endobj");
  }, Fo = function(w, j) {
    var ut = vn(), pt = bn();
    j.push({ resourcesOid: ut, objectOid: pt }), w.objectNumber = pt;
    var Ct = [];
    Ct.push({ key: "Type", value: "/Pattern" }), Ct.push({ key: "PatternType", value: "1" }), Ct.push({ key: "PaintType", value: "1" }), Ct.push({ key: "TilingType", value: "1" }), Ct.push({ key: "BBox", value: "[" + w.boundingBox.map(E).join(" ") + "]" }), Ct.push({ key: "XStep", value: E(w.xStep) }), Ct.push({ key: "YStep", value: E(w.yStep) }), Ct.push({ key: "Resources", value: ut + " 0 R" }), w.matrix && Ct.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" }), Pi({ data: w.stream, additionalKeyValues: Ct, objectId: w.objectNumber }), $("endobj");
  }, os = function(w) {
    var j;
    for (j in de) de.hasOwnProperty(j) && (de[j] instanceof Ts ? ss(de[j]) : de[j] instanceof po && Fo(de[j], w));
  }, Mo = function(w) {
    for (var j in w.objectNumber = bn(), $("<<"), w) switch (j) {
      case "opacity":
        $("/ca " + q(w[j]));
        break;
      case "stroke-opacity":
        $("/CA " + q(w[j]));
    }
    $(">>"), $("endobj");
  }, as = function() {
    var w;
    for (w in Te) Te.hasOwnProperty(w) && Mo(Te[w]);
  }, Hs = function() {
    for (var w in $("/XObject <<"), yn) yn.hasOwnProperty(w) && yn[w].objectNumber >= 0 && $("/" + w + " " + yn[w].objectNumber + " 0 R");
    qe.publish("putXobjectDict"), $(">>");
  }, Ia = function() {
    Re.oid = bn(), $("<<"), $("/Filter /Standard"), $("/V " + Re.v), $("/R " + Re.r), $("/U <" + Re.toHexString(Re.U) + ">"), $("/O <" + Re.toHexString(Re.O) + ">"), $("/P " + Re.P), $(">>"), $("endobj");
  }, vr = function() {
    for (var w in $("/Font <<"), Jt) Jt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && $("/" + w + " " + Jt[w].objectNumber + " 0 R");
    $(">>");
  }, Ea = function() {
    if (Object.keys(de).length > 0) {
      for (var w in $("/Shading <<"), de) de.hasOwnProperty(w) && de[w] instanceof Ts && de[w].objectNumber >= 0 && $("/" + w + " " + de[w].objectNumber + " 0 R");
      qe.publish("putShadingPatternDict"), $(">>");
    }
  }, ls = function(w) {
    if (Object.keys(de).length > 0) {
      for (var j in $("/Pattern <<"), de) de.hasOwnProperty(j) && de[j] instanceof f.TilingPattern && de[j].objectNumber >= 0 && de[j].objectNumber < w && $("/" + j + " " + de[j].objectNumber + " 0 R");
      qe.publish("putTilingPatternDict"), $(">>");
    }
  }, Oa = function() {
    if (Object.keys(Te).length > 0) {
      var w;
      for (w in $("/ExtGState <<"), Te) Te.hasOwnProperty(w) && Te[w].objectNumber >= 0 && $("/" + w + " " + Te[w].objectNumber + " 0 R");
      qe.publish("putGStateDict"), $(">>");
    }
  }, dn = function(w) {
    ci(w.resourcesOid, !0), $("<<"), $("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), vr(), Ea(), ls(w.objectOid), Oa(), Hs(), $(">>"), $("endobj");
  }, Gs = function() {
    var w = [];
    er(), as(), Br(), os(w), qe.publish("putResources"), w.forEach(dn), dn({ resourcesOid: mi, objectOid: Number.MAX_SAFE_INTEGER }), qe.publish("postPutResources");
  }, Do = function() {
    qe.publish("putAdditionalObjects");
    for (var w = 0; w < qt.length; w++) {
      var j = qt[w];
      ci(j.objId, !0), $(j.content), $("endobj");
    }
    qe.publish("postPutAdditionalObjects");
  }, Vs = function(w) {
    fe[w.fontName] = fe[w.fontName] || {}, fe[w.fontName][w.fontStyle] = w.id;
  }, Ys = function(w, j, ut, pt, Ct) {
    var Dt = { id: "F" + (Object.keys(Jt).length + 1).toString(10), postScriptName: w, fontName: j, fontStyle: ut, encoding: pt, isStandardFont: Ct || !1, metadata: {} };
    return qe.publish("addFont", { font: Dt, instance: this }), Jt[Dt.id] = Dt, Vs(Dt), Dt.id;
  }, Ta = function(w) {
    for (var j = 0, ut = st.length; j < ut; j++) {
      var pt = Ys.call(this, w[j][0], w[j][1], w[j][2], st[j][3], !0);
      d === !1 && (p[pt] = !0);
      var Ct = w[j][0].split("-");
      Vs({ id: pt, fontName: Ct[0], fontStyle: Ct[1] || "" });
    }
    qe.publish("addFonts", { fonts: Jt, dictionary: fe });
  }, In = function(w) {
    return w.foo = function() {
      try {
        return w.apply(this, arguments);
      } catch (pt) {
        var j = pt.stack || "";
        ~j.indexOf(" at ") && (j = j.split(" at ")[1]);
        var ut = "Error in function " + j.split(`
`)[0].split("<")[0] + ": " + pt.message;
        if (!Ae.console) throw new Error(ut);
        Ae.console.error(ut, pt), Ae.alert && alert(ut);
      }
    }, w.foo.bar = w, w.foo;
  }, us = function(w, j) {
    var ut, pt, Ct, Dt, Vt, le, ve, Ee, Le;
    if (Ct = (j = j || {}).sourceEncoding || "Unicode", Vt = j.outputEncoding, (j.autoencode || Vt) && Jt[xe].metadata && Jt[xe].metadata[Ct] && Jt[xe].metadata[Ct].encoding && (Dt = Jt[xe].metadata[Ct].encoding, !Vt && Jt[xe].encoding && (Vt = Jt[xe].encoding), !Vt && Dt.codePages && (Vt = Dt.codePages[0]), typeof Vt == "string" && (Vt = Dt[Vt]), Vt)) {
      for (ve = !1, le = [], ut = 0, pt = w.length; ut < pt; ut++) (Ee = Vt[w.charCodeAt(ut)]) ? le.push(String.fromCharCode(Ee)) : le.push(w[ut]), le[ut].charCodeAt(0) >> 8 && (ve = !0);
      w = le.join("");
    }
    for (ut = w.length; ve === void 0 && ut !== 0; ) w.charCodeAt(ut - 1) >> 8 && (ve = !0), ut--;
    if (!ve) return w;
    for (le = j.noBOM ? [] : [254, 255], ut = 0, pt = w.length; ut < pt; ut++) {
      if ((Le = (Ee = w.charCodeAt(ut)) >> 8) >> 8) throw new Error("Character at position " + ut + " of string '" + w + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      le.push(Le), le.push(Ee - (Le << 8));
    }
    return String.fromCharCode.apply(void 0, le);
  }, ei = f.__private__.pdfEscape = f.pdfEscape = function(w, j) {
    return us(w, j).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, cs = f.__private__.beginPage = function(w) {
    Rt[++Ze] = [], Ce[Ze] = { objId: 0, contentsObjId: 0, userUnit: Number(a), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(w[0]), topRightY: Number(w[1]) } }, Xs(Ze), ht(Rt[z]);
  }, Ks = function(w, j) {
    var ut, pt, Ct;
    switch (e = j || e, typeof w == "string" && (ut = y(w.toLowerCase()), Array.isArray(ut) && (pt = ut[0], Ct = ut[1])), Array.isArray(w) && (pt = w[0] * Xt, Ct = w[1] * Xt), isNaN(pt) && (pt = r[0], Ct = r[1]), (pt > 14400 || Ct > 14400) && (an.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), pt = Math.min(14400, pt), Ct = Math.min(14400, Ct)), r = [pt, Ct], e.substr(0, 1)) {
      case "l":
        Ct > pt && (r = [Ct, pt]);
        break;
      case "p":
        pt > Ct && (r = [Ct, pt]);
    }
    cs(r), Wl(Ra), $(nr), ja !== 0 && $(ja + " J"), qa !== 0 && $(qa + " j"), qe.publish("addPage", { pageNumber: Ze });
  }, hs = function(w) {
    w > 0 && w <= Ze && (Rt.splice(w, 1), Ce.splice(w, 1), Ze--, z > Ze && (z = Ze), this.setPage(z));
  }, Xs = function(w) {
    w > 0 && w <= Ze && (z = w);
  }, Fa = f.__private__.getNumberOfPages = f.getNumberOfPages = function() {
    return Rt.length - 1;
  }, Ro = function(w, j, ut) {
    var pt, Ct = void 0;
    return ut = ut || {}, w = w !== void 0 ? w : Jt[xe].fontName, j = j !== void 0 ? j : Jt[xe].fontStyle, pt = w.toLowerCase(), fe[pt] !== void 0 && fe[pt][j] !== void 0 ? Ct = fe[pt][j] : fe[w] !== void 0 && fe[w][j] !== void 0 ? Ct = fe[w][j] : ut.disableWarning === !1 && an.warn("Unable to look up font label for font '" + w + "', '" + j + "'. Refer to getFontList() for available fonts."), Ct || ut.noFallback || (Ct = fe.times[j]) == null && (Ct = fe.times.normal), Ct;
  }, Ma = f.__private__.putInfo = function() {
    var w = bn(), j = function(pt) {
      return pt;
    };
    for (var ut in u !== null && (j = Re.encryptor(w, 0)), $("<<"), $("/Producer (" + ei(j("jsPDF " + Se.version)) + ")"), ae) ae.hasOwnProperty(ut) && ae[ut] && $("/" + ut.substr(0, 1).toUpperCase() + ut.substr(1) + " (" + ei(j(ae[ut])) + ")");
    $("/CreationDate (" + ei(j(J)) + ")"), $(">>"), $("endobj");
  }, Q = f.__private__.putCatalog = function(w) {
    var j = (w = w || {}).rootDictionaryObjId || tr;
    switch (bn(), $("<<"), $("/Type /Catalog"), $("/Pages " + j + " 0 R"), St || (St = "fullwidth"), St) {
      case "fullwidth":
        $("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        $("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        $("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        $("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var ut = "" + St;
        ut.substr(ut.length - 1) === "%" && (St = parseInt(St) / 100), typeof St == "number" && $("/OpenAction [3 0 R /XYZ null null " + q(St) + "]");
    }
    switch ($t || ($t = "continuous"), $t) {
      case "continuous":
        $("/PageLayout /OneColumn");
        break;
      case "single":
        $("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        $("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        $("/PageLayout /TwoColumnRight");
    }
    zt && $("/PageMode /" + zt), qe.publish("putCatalog"), $(">>"), $("endobj");
  }, mt = f.__private__.putTrailer = function() {
    $("trailer"), $("<<"), $("/Size " + (ot + 1)), $("/Root " + ot + " 0 R"), $("/Info " + (ot - 1) + " 0 R"), u !== null && $("/Encrypt " + Re.oid + " 0 R"), $("/ID [ <" + V + "> <" + V + "> ]"), $(">>");
  }, dt = f.__private__.putHeader = function() {
    $("%PDF-" + g), $("%ºß¬à");
  }, Bt = f.__private__.putXRef = function() {
    var w = "0000000000";
    $("xref"), $("0 " + (ot + 1)), $("0000000000 65535 f ");
    for (var j = 1; j <= ot; j++)
      typeof xt[j] == "function" ? $((w + xt[j]()).slice(-10) + " 00000 n ") : xt[j] !== void 0 ? $((w + xt[j]).slice(-10) + " 00000 n ") : $("0000000000 00000 n ");
  }, Ft = f.__private__.buildDocument = function() {
    T(), ht(gt), qe.publish("buildDocument"), dt(), br(), Do(), Gs(), u !== null && Ia(), Ma(), Q();
    var w = wt;
    return Bt(), mt(), $("startxref"), $("" + w), $("%%EOF"), ht(Rt[z]), gt.join(`
`);
  }, me = f.__private__.getBlob = function(w) {
    return new Blob([X(w)], { type: "application/pdf" });
  }, ge = f.output = f.__private__.output = In(function(w, j) {
    switch (typeof (j = j || {}) == "string" ? j = { filename: j } : j.filename = j.filename || "generated.pdf", w) {
      case void 0:
        return Ft();
      case "save":
        f.save(j.filename);
        break;
      case "arraybuffer":
        return X(Ft());
      case "blob":
        return me(Ft());
      case "bloburi":
      case "bloburl":
        if (Ae.URL !== void 0 && typeof Ae.URL.createObjectURL == "function") return Ae.URL && Ae.URL.createObjectURL(me(Ft())) || void 0;
        an.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var ut = "", pt = Ft();
        try {
          ut = ff(pt);
        } catch {
          ut = ff(unescape(encodeURIComponent(pt)));
        }
        return "data:application/pdf;filename=" + j.filename + ";base64," + ut;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Ae) === "[object Window]") {
          var Ct = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Dt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          j.pdfObjectUrl && (Ct = j.pdfObjectUrl, Dt = "");
          var Vt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ct + '"' + Dt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(j) + ");<\/script></body></html>", le = Ae.open();
          return le !== null && le.document.write(Vt), le;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Ae) === "[object Window]") {
          var ve = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (j.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + j.filename + '" width="500px" height="400px" /></body></html>', Ee = Ae.open();
          if (Ee !== null) {
            Ee.document.write(ve);
            var Le = this;
            Ee.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Ee.document.title = j.filename, Ee.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Le.output("bloburl"));
            };
          }
          return Ee;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Ae) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var $e = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", j) + '"></iframe></body></html>', gn = Ae.open();
        if (gn !== null && (gn.document.write($e), gn.document.title = j.filename), gn || typeof safari > "u") return gn;
        break;
      case "datauri":
      case "dataurl":
        return Ae.document.location.href = this.output("datauristring", j);
      default:
        return null;
    }
  }), Fe = function(w) {
    return Array.isArray(Qi) === !0 && Qi.indexOf(w) > -1;
  };
  switch (i) {
    case "pt":
      Xt = 1;
      break;
    case "mm":
      Xt = 72 / 25.4;
      break;
    case "cm":
      Xt = 72 / 2.54;
      break;
    case "in":
      Xt = 72;
      break;
    case "px":
      Xt = Fe("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Xt = 12;
      break;
    case "ex":
      Xt = 6;
      break;
    default:
      if (typeof i != "number") throw new Error("Invalid unit: " + i);
      Xt = i;
  }
  var Re = null;
  it(), tt();
  var pn = function(w) {
    return u !== null ? Re.encryptor(w, 0) : function(j) {
      return j;
    };
  }, Pe = f.__private__.getPageInfo = f.getPageInfo = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Ce[w].objId, pageNumber: w, pageContext: Ce[w] };
  }, se = f.__private__.getPageInfoByObjId = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var j in Ce) if (Ce[j].objId === w) break;
    return Pe(j);
  }, be = f.__private__.getCurrentPageInfo = f.getCurrentPageInfo = function() {
    return { objId: Ce[z].objId, pageNumber: z, pageContext: Ce[z] };
  };
  f.addPage = function() {
    return Ks.apply(this, arguments), this;
  }, f.setPage = function() {
    return Xs.apply(this, arguments), ht.call(this, Rt[z]), this;
  }, f.insertPage = function(w) {
    return this.addPage(), this.movePage(z, w), this;
  }, f.movePage = function(w, j) {
    var ut, pt;
    if (w > j) {
      ut = Rt[w], pt = Ce[w];
      for (var Ct = w; Ct > j; Ct--) Rt[Ct] = Rt[Ct - 1], Ce[Ct] = Ce[Ct - 1];
      Rt[j] = ut, Ce[j] = pt, this.setPage(j);
    } else if (w < j) {
      ut = Rt[w], pt = Ce[w];
      for (var Dt = w; Dt < j; Dt++) Rt[Dt] = Rt[Dt + 1], Ce[Dt] = Ce[Dt + 1];
      Rt[j] = ut, Ce[j] = pt, this.setPage(j);
    }
    return this;
  }, f.deletePage = function() {
    return hs.apply(this, arguments), this;
  }, f.__private__.text = f.text = function(w, j, ut, pt, Ct) {
    var Dt, Vt, le, ve, Ee, Le, $e, gn, wn, En = (pt = pt || {}).scope || this;
    if (typeof w == "number" && typeof j == "number" && (typeof ut == "string" || Array.isArray(ut))) {
      var ni = ut;
      ut = j, j = w, w = ni;
    }
    if (arguments[3] instanceof we ? (O("The transform parameter of text() with a Matrix value"), wn = Ct) : (le = arguments[4], ve = arguments[5], en($e = arguments[3]) === "object" && $e !== null || (typeof le == "string" && (ve = le, le = null), typeof $e == "string" && (ve = $e, $e = null), typeof $e == "number" && (le = $e, $e = null), pt = { flags: $e, angle: le, align: ve })), isNaN(j) || isNaN(ut) || w == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (w.length === 0) return En;
    var zn = "", ir = !1, Ii = typeof pt.lineHeightFactor == "number" ? pt.lineHeightFactor : Zs, xr = En.internal.scaleFactor;
    function Xl(ln) {
      return ln = ln.split("	").join(Array(pt.TabLen || 9).join(" ")), ei(ln, $e);
    }
    function Ha(ln) {
      for (var un, An = ln.concat(), Dn = [], Gr = An.length; Gr--; ) typeof (un = An.shift()) == "string" ? Dn.push(un) : Array.isArray(ln) && (un.length === 1 || un[1] === void 0 && un[2] === void 0) ? Dn.push(un[0]) : Dn.push([un[0], un[1], un[2]]);
      return Dn;
    }
    function Ga(ln, un) {
      var An;
      if (typeof ln == "string") An = un(ln)[0];
      else if (Array.isArray(ln)) {
        for (var Dn, Gr, tl = ln.concat(), Jo = [], eu = tl.length; eu--; ) typeof (Dn = tl.shift()) == "string" ? Jo.push(un(Dn)[0]) : Array.isArray(Dn) && typeof Dn[0] == "string" && (Gr = un(Dn[0], Dn[1], Dn[2]), Jo.push([Gr[0], Gr[1], Gr[2]]));
        An = Jo;
      }
      return An;
    }
    var $o = !1, Va = !0;
    if (typeof w == "string") $o = !0;
    else if (Array.isArray(w)) {
      var Ya = w.concat();
      Vt = [];
      for (var Uo, Vn = Ya.length; Vn--; ) (typeof (Uo = Ya.shift()) != "string" || Array.isArray(Uo) && typeof Uo[0] != "string") && (Va = !1);
      $o = Va;
    }
    if ($o === !1) throw new Error('Type of text must be string or Array. "' + w + '" is not recognized.');
    typeof w == "string" && (w = w.match(/[\r?\n]/) ? w.split(/\r\n|\r|\n/g) : [w]);
    var Wo = vt / En.internal.scaleFactor, Ho = Wo * (Ii - 1);
    switch (pt.baseline) {
      case "bottom":
        ut -= Ho;
        break;
      case "top":
        ut += Wo - Ho;
        break;
      case "hanging":
        ut += Wo - 2 * Ho;
        break;
      case "middle":
        ut += Wo / 2 - Ho;
    }
    if ((Le = pt.maxWidth || 0) > 0 && (typeof w == "string" ? w = En.splitTextToSize(w, Le) : Object.prototype.toString.call(w) === "[object Array]" && (w = w.reduce(function(ln, un) {
      return ln.concat(En.splitTextToSize(un, Le));
    }, []))), Dt = { text: w, x: j, y: ut, options: pt, mutex: { pdfEscape: ei, activeFontKey: xe, fonts: Jt, activeFontSize: vt } }, qe.publish("preProcessText", Dt), w = Dt.text, le = (pt = Dt.options).angle, !(wn instanceof we) && le && typeof le == "number") {
      le *= Math.PI / 180, pt.rotationDirection === 0 && (le = -le), k === v.ADVANCED && (le = -le);
      var Go = Math.cos(le), Ka = Math.sin(le);
      wn = new we(Go, Ka, -Ka, Go, 0, 0);
    } else le && le instanceof we && (wn = le);
    k !== v.ADVANCED || wn || (wn = Bi), (Ee = pt.charSpace || jo) !== void 0 && (zn += E(A(Ee)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (gn = pt.horizontalScale) !== void 0 && (zn += E(100 * gn) + ` Tz
`), pt.lang;
    var yi = -1, Zc = pt.renderingMode !== void 0 ? pt.renderingMode : pt.stroke, Xa = En.internal.getCurrentPageInfo().pageContext;
    switch (Zc) {
      case 0:
      case !1:
      case "fill":
        yi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        yi = 1;
        break;
      case 2:
      case "fillThenStroke":
        yi = 2;
        break;
      case 3:
      case "invisible":
        yi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        yi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        yi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        yi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        yi = 7;
    }
    var Jl = Xa.usedRenderingMode !== void 0 ? Xa.usedRenderingMode : -1;
    yi !== -1 ? zn += yi + ` Tr
` : Jl !== -1 && (zn += `0 Tr
`), yi !== -1 && (Xa.usedRenderingMode = yi), ve = pt.align || "left";
    var $i, Vo = vt * Ii, Zl = En.internal.pageSize.getWidth(), Ql = Jt[xe];
    Ee = pt.charSpace || jo, Le = pt.maxWidth || 0, $e = Object.assign({ autoencode: !0, noBOM: !0 }, pt.flags);
    var ys = [], eo = function(ln) {
      return En.getStringUnitWidth(ln, { font: Ql, charSpace: Ee, fontSize: vt, doKerning: !1 }) * vt / xr;
    };
    if (Object.prototype.toString.call(w) === "[object Array]") {
      var bi;
      Vt = Ha(w), ve !== "left" && ($i = Vt.map(eo));
      var hi, bs = 0;
      if (ve === "right") {
        j -= $i[0], w = [], Vn = Vt.length;
        for (var Ur = 0; Ur < Vn; Ur++) Ur === 0 ? (hi = wr(j), bi = $r(ut)) : (hi = A(bs - $i[Ur]), bi = -Vo), w.push([Vt[Ur], hi, bi]), bs = $i[Ur];
      } else if (ve === "center") {
        j -= $i[0] / 2, w = [], Vn = Vt.length;
        for (var Wr = 0; Wr < Vn; Wr++) Wr === 0 ? (hi = wr(j), bi = $r(ut)) : (hi = A((bs - $i[Wr]) / 2), bi = -Vo), w.push([Vt[Wr], hi, bi]), bs = $i[Wr];
      } else if (ve === "left") {
        w = [], Vn = Vt.length;
        for (var Yo = 0; Yo < Vn; Yo++) w.push(Vt[Yo]);
      } else if (ve === "justify" && Ql.encoding === "Identity-H") {
        w = [], Vn = Vt.length, Le = Le !== 0 ? Le : Zl;
        for (var Hr = 0, kn = 0; kn < Vn; kn++) if (bi = kn === 0 ? $r(ut) : -Vo, hi = kn === 0 ? wr(j) : Hr, kn < Vn - 1) {
          var Ja = A((Le - $i[kn]) / (Vt[kn].split(" ").length - 1)), fi = Vt[kn].split(" ");
          w.push([fi[0] + " ", hi, bi]), Hr = 0;
          for (var Ui = 1; Ui < fi.length; Ui++) {
            var Ko = (eo(fi[Ui - 1] + " " + fi[Ui]) - eo(fi[Ui])) * xr + Ja;
            Ui == fi.length - 1 ? w.push([fi[Ui], Ko, 0]) : w.push([fi[Ui] + " ", Ko, 0]), Hr -= Ko;
          }
        } else w.push([Vt[kn], hi, bi]);
        w.push(["", Hr, 0]);
      } else {
        if (ve !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (w = [], Vn = Vt.length, Le = Le !== 0 ? Le : Zl, kn = 0; kn < Vn; kn++) bi = kn === 0 ? $r(ut) : -Vo, hi = kn === 0 ? wr(j) : 0, kn < Vn - 1 ? ys.push(E(A((Le - $i[kn]) / (Vt[kn].split(" ").length - 1)))) : ys.push(0), w.push([Vt[kn], hi, bi]);
      }
    }
    var tu = typeof pt.R2L == "boolean" ? pt.R2L : Et;
    tu === !0 && (w = Ga(w, function(ln, un, An) {
      return [ln.split("").reverse().join(""), un, An];
    })), Dt = { text: w, x: j, y: ut, options: pt, mutex: { pdfEscape: ei, activeFontKey: xe, fonts: Jt, activeFontSize: vt } }, qe.publish("postProcessText", Dt), w = Dt.text, ir = Dt.mutex.isHex || !1;
    var Za = Jt[xe].encoding;
    Za !== "WinAnsiEncoding" && Za !== "StandardEncoding" || (w = Ga(w, function(ln, un, An) {
      return [Xl(ln), un, An];
    })), Vt = Ha(w), w = [];
    for (var no, io, vs, ro = 0, Xo = 1, so = Array.isArray(Vt[0]) ? Xo : ro, ws = "", Qa = function(ln, un, An) {
      var Dn = "";
      return An instanceof we ? (An = typeof pt.angle == "number" ? Ai(An, new we(1, 0, 0, 1, ln, un)) : Ai(new we(1, 0, 0, 1, ln, un), An), k === v.ADVANCED && (An = Ai(new we(1, 0, 0, -1, 0, 0), An)), Dn = An.join(" ") + ` Tm
`) : Dn = E(ln) + " " + E(un) + ` Td
`, Dn;
    }, Wi = 0; Wi < Vt.length; Wi++) {
      switch (ws = "", so) {
        case Xo:
          vs = (ir ? "<" : "(") + Vt[Wi][0] + (ir ? ">" : ")"), no = parseFloat(Vt[Wi][1]), io = parseFloat(Vt[Wi][2]);
          break;
        case ro:
          vs = (ir ? "<" : "(") + Vt[Wi] + (ir ? ">" : ")"), no = wr(j), io = $r(ut);
      }
      ys !== void 0 && ys[Wi] !== void 0 && (ws = ys[Wi] + ` Tw
`), Wi === 0 ? w.push(ws + Qa(no, io, wn) + vs) : so === ro ? w.push(ws + vs) : so === Xo && w.push(ws + Qa(no, io, wn) + vs);
    }
    w = so === ro ? w.join(` Tj
T* `) : w.join(` Tj
`), w += ` Tj
`;
    var Hi = `BT
/`;
    return Hi += xe + " " + vt + ` Tf
`, Hi += E(vt * Ii) + ` TL
`, Hi += Qs + `
`, Hi += zn, Hi += w, $(Hi += "ET"), p[xe] = !0, En;
  };
  var Li = f.__private__.clip = f.clip = function(w) {
    return $(w === "evenodd" ? "W*" : "W"), this;
  };
  f.clipEvenOdd = function() {
    return Li("evenodd");
  }, f.__private__.discardPath = f.discardPath = function() {
    return $("n"), this;
  };
  var zi = f.__private__.isValidStyle = function(w) {
    var j = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(w) !== -1 && (j = !0), j;
  };
  f.__private__.setDefaultPathOperation = f.setDefaultPathOperation = function(w) {
    return zi(w) && (h = w), this;
  };
  var qr = f.__private__.getStyle = f.getStyle = function(w) {
    var j = h;
    switch (w) {
      case "D":
      case "S":
        j = "S";
        break;
      case "F":
        j = "f";
        break;
      case "FD":
      case "DF":
        j = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        j = w;
    }
    return j;
  }, fs = f.close = function() {
    return $("h"), this;
  };
  f.stroke = function() {
    return $("S"), this;
  }, f.fill = function(w) {
    return zr("f", w), this;
  }, f.fillEvenOdd = function(w) {
    return zr("f*", w), this;
  }, f.fillStroke = function(w) {
    return zr("B", w), this;
  }, f.fillStrokeEvenOdd = function(w) {
    return zr("B*", w), this;
  };
  var zr = function(w, j) {
    en(j) === "object" ? Hc(j, w) : $(w);
  }, ds = function(w) {
    w === null || k === v.ADVANCED && w === void 0 || (w = qr(w), $(w));
  };
  function Wc(w, j, ut, pt, Ct) {
    var Dt = new po(j || this.boundingBox, ut || this.xStep, pt || this.yStep, this.gState, Ct || this.matrix);
    Dt.stream = this.stream;
    var Vt = w + "$$" + this.cloneIndex++ + "$$";
    return ti(Vt, Dt), Dt;
  }
  var Hc = function(w, j) {
    var ut = Ue[w.key], pt = de[ut];
    if (pt instanceof Ts) $("q"), $(Gc(j)), pt.gState && f.setGState(pt.gState), $(w.matrix.toString() + " cm"), $("/" + ut + " sh"), $("Q");
    else if (pt instanceof po) {
      var Ct = new we(1, 0, 0, -1, 0, ms());
      w.matrix && (Ct = Ct.multiply(w.matrix || Bi), ut = Wc.call(pt, w.key, w.boundingBox, w.xStep, w.yStep, Ct).id), $("q"), $("/Pattern cs"), $("/" + ut + " scn"), pt.gState && f.setGState(pt.gState), $(j), $("Q");
    }
  }, Gc = function(w) {
    switch (w) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Da = f.moveTo = function(w, j) {
    return $(E(A(w)) + " " + E(_(j)) + " m"), this;
  }, Js = f.lineTo = function(w, j) {
    return $(E(A(w)) + " " + E(_(j)) + " l"), this;
  }, ps = f.curveTo = function(w, j, ut, pt, Ct, Dt) {
    return $([E(A(w)), E(_(j)), E(A(ut)), E(_(pt)), E(A(Ct)), E(_(Dt)), "c"].join(" ")), this;
  };
  f.__private__.line = f.line = function(w, j, ut, pt, Ct) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || !zi(Ct)) throw new Error("Invalid arguments passed to jsPDF.line");
    return k === v.COMPAT ? this.lines([[ut - w, pt - j]], w, j, [1, 1], Ct || "S") : this.lines([[ut - w, pt - j]], w, j, [1, 1]).stroke();
  }, f.__private__.lines = f.lines = function(w, j, ut, pt, Ct, Dt) {
    var Vt, le, ve, Ee, Le, $e, gn, wn, En, ni, zn, ir;
    if (typeof w == "number" && (ir = ut, ut = j, j = w, w = ir), pt = pt || [1, 1], Dt = Dt || !1, isNaN(j) || isNaN(ut) || !Array.isArray(w) || !Array.isArray(pt) || !zi(Ct) || typeof Dt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Da(j, ut), Vt = pt[0], le = pt[1], Ee = w.length, ni = j, zn = ut, ve = 0; ve < Ee; ve++) (Le = w[ve]).length === 2 ? (ni = Le[0] * Vt + ni, zn = Le[1] * le + zn, Js(ni, zn)) : ($e = Le[0] * Vt + ni, gn = Le[1] * le + zn, wn = Le[2] * Vt + ni, En = Le[3] * le + zn, ni = Le[4] * Vt + ni, zn = Le[5] * le + zn, ps($e, gn, wn, En, ni, zn));
    return Dt && fs(), ds(Ct), this;
  }, f.path = function(w) {
    for (var j = 0; j < w.length; j++) {
      var ut = w[j], pt = ut.c;
      switch (ut.op) {
        case "m":
          Da(pt[0], pt[1]);
          break;
        case "l":
          Js(pt[0], pt[1]);
          break;
        case "c":
          ps.apply(this, pt);
          break;
        case "h":
          fs();
      }
    }
    return this;
  }, f.__private__.rect = f.rect = function(w, j, ut, pt, Ct) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || !zi(Ct)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return k === v.COMPAT && (pt = -pt), $([E(A(w)), E(_(j)), E(A(ut)), E(A(pt)), "re"].join(" ")), ds(Ct), this;
  }, f.__private__.triangle = f.triangle = function(w, j, ut, pt, Ct, Dt, Vt) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || isNaN(Ct) || isNaN(Dt) || !zi(Vt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[ut - w, pt - j], [Ct - ut, Dt - pt], [w - Ct, j - Dt]], w, j, [1, 1], Vt, !0), this;
  }, f.__private__.roundedRect = f.roundedRect = function(w, j, ut, pt, Ct, Dt, Vt) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || isNaN(Ct) || isNaN(Dt) || !zi(Vt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var le = 4 / 3 * (Math.SQRT2 - 1);
    return Ct = Math.min(Ct, 0.5 * ut), Dt = Math.min(Dt, 0.5 * pt), this.lines([[ut - 2 * Ct, 0], [Ct * le, 0, Ct, Dt - Dt * le, Ct, Dt], [0, pt - 2 * Dt], [0, Dt * le, -Ct * le, Dt, -Ct, Dt], [2 * Ct - ut, 0], [-Ct * le, 0, -Ct, -Dt * le, -Ct, -Dt], [0, 2 * Dt - pt], [0, -Dt * le, Ct * le, -Dt, Ct, -Dt]], w + Ct, j, [1, 1], Vt, !0), this;
  }, f.__private__.ellipse = f.ellipse = function(w, j, ut, pt, Ct) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || !zi(Ct)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Dt = 4 / 3 * (Math.SQRT2 - 1) * ut, Vt = 4 / 3 * (Math.SQRT2 - 1) * pt;
    return Da(w + ut, j), ps(w + ut, j - Vt, w + Dt, j - pt, w, j - pt), ps(w - Dt, j - pt, w - ut, j - Vt, w - ut, j), ps(w - ut, j + Vt, w - Dt, j + pt, w, j + pt), ps(w + Dt, j + pt, w + ut, j + Vt, w + ut, j), ds(Ct), this;
  }, f.__private__.circle = f.circle = function(w, j, ut, pt) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || !zi(pt)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(w, j, ut, ut, pt);
  }, f.setFont = function(w, j, ut) {
    return ut && (j = D(j, ut)), xe = Ro(w, j, { disableWarning: !1 }), this;
  };
  var Vc = f.__private__.getFont = f.getFont = function() {
    return Jt[Ro.apply(f, arguments)];
  };
  f.__private__.getFontList = f.getFontList = function() {
    var w, j, ut = {};
    for (w in fe) if (fe.hasOwnProperty(w)) for (j in ut[w] = [], fe[w]) fe[w].hasOwnProperty(j) && ut[w].push(j);
    return ut;
  }, f.addFont = function(w, j, ut, pt, Ct) {
    var Dt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Dt.indexOf(arguments[3]) !== -1 ? Ct = arguments[3] : arguments[3] && Dt.indexOf(arguments[3]) == -1 && (ut = D(ut, pt)), Ct = Ct || "Identity-H", Ys.call(this, w, j, ut, Ct);
  };
  var Zs, Ra = n.lineWidth || 0.200025, Bo = f.__private__.getLineWidth = f.getLineWidth = function() {
    return Ra;
  }, Wl = f.__private__.setLineWidth = f.setLineWidth = function(w) {
    return Ra = w, $(E(A(w)) + " w"), this;
  };
  f.__private__.setLineDash = Se.API.setLineDash = Se.API.setLineDashPattern = function(w, j) {
    if (w = w || [], j = j || 0, isNaN(j) || !Array.isArray(w)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return w = w.map(function(ut) {
      return E(A(ut));
    }).join(" "), j = E(A(j)), $("[" + w + "] " + j + " d"), this;
  };
  var Hl = f.__private__.getLineHeight = f.getLineHeight = function() {
    return vt * Zs;
  };
  f.__private__.getLineHeight = f.getLineHeight = function() {
    return vt * Zs;
  };
  var Gl = f.__private__.setLineHeightFactor = f.setLineHeightFactor = function(w) {
    return typeof (w = w || 1.15) == "number" && (Zs = w), this;
  }, Vl = f.__private__.getLineHeightFactor = f.getLineHeightFactor = function() {
    return Zs;
  };
  Gl(n.lineHeight);
  var wr = f.__private__.getHorizontalCoordinate = function(w) {
    return A(w);
  }, $r = f.__private__.getVerticalCoordinate = function(w) {
    return k === v.ADVANCED ? w : Ce[z].mediaBox.topRightY - Ce[z].mediaBox.bottomLeftY - A(w);
  }, Yc = f.__private__.getHorizontalCoordinateString = f.getHorizontalCoordinateString = function(w) {
    return E(wr(w));
  }, gs = f.__private__.getVerticalCoordinateString = f.getVerticalCoordinateString = function(w) {
    return E($r(w));
  }, nr = n.strokeColor || "0 G";
  f.__private__.getStrokeColor = f.getDrawColor = function() {
    return Ni(nr);
  }, f.__private__.setStrokeColor = f.setDrawColor = function(w, j, ut, pt) {
    return nr = Ci({ ch1: w, ch2: j, ch3: ut, ch4: pt, pdfColorType: "draw", precision: 2 }), $(nr), this;
  };
  var Ba = n.fillColor || "0 g";
  f.__private__.getFillColor = f.getFillColor = function() {
    return Ni(Ba);
  }, f.__private__.setFillColor = f.setFillColor = function(w, j, ut, pt) {
    return Ba = Ci({ ch1: w, ch2: j, ch3: ut, ch4: pt, pdfColorType: "fill", precision: 2 }), $(Ba), this;
  };
  var Qs = n.textColor || "0 g", Kc = f.__private__.getTextColor = f.getTextColor = function() {
    return Ni(Qs);
  };
  f.__private__.setTextColor = f.setTextColor = function(w, j, ut, pt) {
    return Qs = Ci({ ch1: w, ch2: j, ch3: ut, ch4: pt, pdfColorType: "text", precision: 3 }), this;
  };
  var jo = n.charSpace, Xc = f.__private__.getCharSpace = f.getCharSpace = function() {
    return parseFloat(jo || 0);
  };
  f.__private__.setCharSpace = f.setCharSpace = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return jo = w, this;
  };
  var ja = 0;
  f.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, f.__private__.setLineCap = f.setLineCap = function(w) {
    var j = f.CapJoinStyles[w];
    if (j === void 0) throw new Error("Line cap style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return ja = j, $(j + " J"), this;
  };
  var qa = 0;
  f.__private__.setLineJoin = f.setLineJoin = function(w) {
    var j = f.CapJoinStyles[w];
    if (j === void 0) throw new Error("Line join style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return qa = j, $(j + " j"), this;
  }, f.__private__.setLineMiterLimit = f.__private__.setMiterLimit = f.setLineMiterLimit = f.setMiterLimit = function(w) {
    if (w = w || 0, isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return $(E(A(w)) + " M"), this;
  }, f.GState = Ll, f.setGState = function(w) {
    (w = typeof w == "string" ? Te[Sn[w]] : Yl(null, w)).equals(Mn) || ($("/" + w.id + " gs"), Mn = w);
  };
  var Yl = function(w, j) {
    if (!w || !Sn[w]) {
      var ut = !1;
      for (var pt in Te) if (Te.hasOwnProperty(pt) && Te[pt].equals(j)) {
        ut = !0;
        break;
      }
      if (ut) j = Te[pt];
      else {
        var Ct = "GS" + (Object.keys(Te).length + 1).toString(10);
        Te[Ct] = j, j.id = Ct;
      }
      return w && (Sn[w] = j.id), qe.publish("addGState", j), j;
    }
  };
  f.addGState = function(w, j) {
    return Yl(w, j), this;
  }, f.saveGraphicsState = function() {
    return $("q"), ne.push({ key: xe, size: vt, color: Qs }), this;
  }, f.restoreGraphicsState = function() {
    $("Q");
    var w = ne.pop();
    return xe = w.key, vt = w.size, Qs = w.color, Mn = null, this;
  }, f.setCurrentTransformationMatrix = function(w) {
    return $(w.toString() + " cm"), this;
  }, f.comment = function(w) {
    return $("#" + w), this;
  };
  var qo = function(w, j) {
    var ut = w || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return ut;
    }, set: function(Dt) {
      isNaN(Dt) || (ut = parseFloat(Dt));
    } });
    var pt = j || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return pt;
    }, set: function(Dt) {
      isNaN(Dt) || (pt = parseFloat(Dt));
    } });
    var Ct = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Dt) {
      Ct = Dt.toString();
    } }), this;
  }, za = function(w, j, ut, pt) {
    qo.call(this, w, j), this.type = "rect";
    var Ct = ut || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Vt) {
      isNaN(Vt) || (Ct = parseFloat(Vt));
    } });
    var Dt = pt || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Dt;
    }, set: function(Vt) {
      isNaN(Vt) || (Dt = parseFloat(Vt));
    } }), this;
  }, $a = function() {
    this.page = Ze, this.currentPage = z, this.pages = Rt.slice(0), this.pagesContext = Ce.slice(0), this.x = Nt, this.y = Ot, this.matrix = ie, this.width = to(z), this.height = ms(z), this.outputDestination = Kt, this.id = "", this.objectNumber = -1;
  };
  $a.prototype.restore = function() {
    Ze = this.page, z = this.currentPage, Ce = this.pagesContext, Rt = this.pages, Nt = this.x, Ot = this.y, ie = this.matrix, Ua(z, this.width), Wa(z, this.height), Kt = this.outputDestination;
  };
  var Kl = function(w, j, ut, pt, Ct) {
    qn.push(new $a()), Ze = z = 0, Rt = [], Nt = w, Ot = j, ie = Ct, cs([ut, pt]);
  }, Jc = function(w) {
    if (Ri[w]) qn.pop().restore();
    else {
      var j = new $a(), ut = "Xo" + (Object.keys(yn).length + 1).toString(10);
      j.id = ut, Ri[w] = ut, yn[ut] = j, qe.publish("addFormObject", j), qn.pop().restore();
    }
  };
  for (var zo in f.beginFormObject = function(w, j, ut, pt, Ct) {
    return Kl(w, j, ut, pt, Ct), this;
  }, f.endFormObject = function(w) {
    return Jc(w), this;
  }, f.doFormObject = function(w, j) {
    var ut = yn[Ri[w]];
    return $("q"), $(j.toString() + " cm"), $("/" + ut.id + " Do"), $("Q"), this;
  }, f.getFormObject = function(w) {
    var j = yn[Ri[w]];
    return { x: j.x, y: j.y, width: j.width, height: j.height, matrix: j.matrix };
  }, f.save = function(w, j) {
    return w = w || "generated.pdf", (j = j || {}).returnPromise = j.returnPromise || !1, j.returnPromise === !1 ? (lo(me(Ft()), w), typeof lo.unload == "function" && Ae.setTimeout && setTimeout(lo.unload, 911), this) : new Promise(function(ut, pt) {
      try {
        var Ct = lo(me(Ft()), w);
        typeof lo.unload == "function" && Ae.setTimeout && setTimeout(lo.unload, 911), ut(Ct);
      } catch (Dt) {
        pt(Dt.message);
      }
    });
  }, Se.API) Se.API.hasOwnProperty(zo) && (zo === "events" && Se.API.events.length ? function(w, j) {
    var ut, pt, Ct;
    for (Ct = j.length - 1; Ct !== -1; Ct--) ut = j[Ct][0], pt = j[Ct][1], w.subscribe.apply(w, [ut].concat(typeof pt == "function" ? [pt] : pt));
  }(qe, Se.API.events) : f[zo] = Se.API[zo]);
  var to = f.getPageWidth = function(w) {
    return (Ce[w = w || z].mediaBox.topRightX - Ce[w].mediaBox.bottomLeftX) / Xt;
  }, Ua = f.setPageWidth = function(w, j) {
    Ce[w].mediaBox.topRightX = j * Xt + Ce[w].mediaBox.bottomLeftX;
  }, ms = f.getPageHeight = function(w) {
    return (Ce[w = w || z].mediaBox.topRightY - Ce[w].mediaBox.bottomLeftY) / Xt;
  }, Wa = f.setPageHeight = function(w, j) {
    Ce[w].mediaBox.topRightY = j * Xt + Ce[w].mediaBox.bottomLeftY;
  };
  return f.internal = { pdfEscape: ei, getStyle: qr, getFont: Vc, getFontSize: ft, getCharSpace: Xc, getTextColor: Kc, getLineHeight: Hl, getLineHeightFactor: Vl, getLineWidth: Bo, write: nt, getHorizontalCoordinate: wr, getVerticalCoordinate: $r, getCoordinateString: Yc, getVerticalCoordinateString: gs, collections: {}, newObject: bn, newAdditionalObject: rs, newObjectDeferred: vn, newObjectDeferredBegin: ci, getFilters: ji, putStream: Pi, events: qe, scaleFactor: Xt, pageSize: { getWidth: function() {
    return to(z);
  }, setWidth: function(w) {
    Ua(z, w);
  }, getHeight: function() {
    return ms(z);
  }, setHeight: function(w) {
    Wa(z, w);
  } }, encryptionOptions: u, encryption: Re, getEncryptor: pn, output: ge, getNumberOfPages: Fa, pages: Rt, out: $, f2: q, f3: P, getPageInfo: Pe, getPageInfoByObjId: se, getCurrentPageInfo: be, getPDFVersion: b, Point: qo, Rectangle: za, Matrix: we, hasHotfix: Fe }, Object.defineProperty(f.internal.pageSize, "width", { get: function() {
    return to(z);
  }, set: function(w) {
    Ua(z, w);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(f.internal.pageSize, "height", { get: function() {
    return ms(z);
  }, set: function(w) {
    Wa(z, w);
  }, enumerable: !0, configurable: !0 }), Ta.call(f, st), xe = "F1", Ks(r, e), qe.publish("initialized"), f;
}
fa.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, fa.prototype.toHexString = function(n) {
  return n.split("").map(function(t) {
    return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, fa.prototype.hexToBytes = function(n) {
  for (var t = [], e = 0; e < n.length; e += 2) t.push(String.fromCharCode(parseInt(n.substr(e, 2), 16)));
  return t.join("");
}, fa.prototype.processOwnerPassword = function(n, t) {
  return pf(df(t).substr(0, 5), n);
}, fa.prototype.encryptor = function(n, t) {
  var e = df(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & t, t >> 8 & 255)).substr(0, 10);
  return function(i) {
    return pf(e, i);
  };
}, Ll.prototype.equals = function(n) {
  var t, e = "id,objectNumber,equals";
  if (!n || en(n) !== en(this)) return !1;
  var i = 0;
  for (t in this) if (!(e.indexOf(t) >= 0)) {
    if (this.hasOwnProperty(t) && !n.hasOwnProperty(t) || this[t] !== n[t]) return !1;
    i++;
  }
  for (t in n) n.hasOwnProperty(t) && e.indexOf(t) < 0 && i--;
  return i === 0;
}, Se.API = { events: [] }, Se.version = "2.5.2";
var _n = Se.API, kd = 1, Oo = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, na = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Ie = function(n) {
  return n.toFixed(2);
}, Is = function(n) {
  return n.toFixed(5);
};
_n.__acroform__ = {};
var ki = function(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n;
}, Jp = function(n) {
  return n * kd;
}, Ar = function(n) {
  var t = new O1(), e = he.internal.getHeight(n) || 0, i = he.internal.getWidth(n) || 0;
  return t.BBox = [0, 0, Number(Ie(i)), Number(Ie(e))], t;
}, wv = _n.__acroform__.setBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << t;
}, xv = _n.__acroform__.clearBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << t);
}, _v = _n.__acroform__.getBit = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << t ? 1 : 0;
}, Cn = _n.__acroform__.getBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return _v(n, t - 1);
}, Pn = _n.__acroform__.setBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return wv(n, t - 1);
}, Ln = _n.__acroform__.clearBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return xv(n, t - 1);
}, Sv = _n.__acroform__.calculateCoordinates = function(n, t) {
  var e = t.internal.getHorizontalCoordinate, i = t.internal.getVerticalCoordinate, r = n[0], s = n[1], o = n[2], a = n[3], l = {};
  return l.lowerLeft_X = e(r) || 0, l.lowerLeft_Y = i(s + a) || 0, l.upperRight_X = e(r + o) || 0, l.upperRight_Y = i(s) || 0, [Number(Ie(l.lowerLeft_X)), Number(Ie(l.lowerLeft_Y)), Number(Ie(l.upperRight_X)), Number(Ie(l.upperRight_Y))];
}, kv = function(n) {
  if (n.appearanceStreamContent) return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var t = [], e = n._V || n.DV, i = gf(n, e), r = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    t.push("/Tx BMC"), t.push("q"), t.push("BT"), t.push(n.scope.__private__.encodeColorString(n.color)), t.push("/" + r + " " + Ie(i.fontSize) + " Tf"), t.push("1 0 0 1 0 0 Tm"), t.push(i.text), t.push("ET"), t.push("Q"), t.push("EMC");
    var s = Ar(n);
    return s.scope = n.scope, s.stream = t.join(`
`), s;
  }
}, gf = function(n, t) {
  var e = n.fontSize === 0 ? n.maxFontSize : n.fontSize, i = { text: "", fontSize: "" }, r = (t = (t = t.substr(0, 1) == "(" ? t.substr(1) : t).substr(t.length - 1) == ")" ? t.substr(0, t.length - 1) : t).split(" ");
  r = n.multiline ? r.map(function(P) {
    return P.split(`
`);
  }) : r.map(function(P) {
    return [P];
  });
  var s = e, o = he.internal.getHeight(n) || 0;
  o = o < 0 ? -o : o;
  var a = he.internal.getWidth(n) || 0;
  a = a < 0 ? -a : a;
  var l = function(P, A, F) {
    if (P + 1 < r.length) {
      var _ = A + " " + r[P + 1][0];
      return Cu(_, n, F).width <= a - 4;
    }
    return !1;
  };
  s++;
  t: for (; s > 0; ) {
    t = "", s--;
    var h, u, d = Cu("3", n, s).height, p = n.multiline ? o - s : (o - d) / 2, f = p += 2, g = 0, b = 0, x = 0;
    if (s <= 0) {
      t = `(...) Tj
`, t += "% Width of Text: " + Cu(t, n, s = 12).width + ", FieldWidth:" + a + `
`;
      break;
    }
    for (var y = "", v = 0, k = 0; k < r.length; k++) if (r.hasOwnProperty(k)) {
      var C = !1;
      if (r[k].length !== 1 && x !== r[k].length - 1) {
        if ((d + 2) * (v + 2) + 2 > o) continue t;
        y += r[k][x], C = !0, b = k, k--;
      } else {
        y = (y += r[k][x] + " ").substr(y.length - 1) == " " ? y.substr(0, y.length - 1) : y;
        var I = parseInt(k), D = l(I, y, s), E = k >= r.length - 1;
        if (D && !E) {
          y += " ", x = 0;
          continue;
        }
        if (D || E) {
          if (E) b = I;
          else if (n.multiline && (d + 2) * (v + 2) + 2 > o) continue t;
        } else {
          if (!n.multiline || (d + 2) * (v + 2) + 2 > o) continue t;
          b = I;
        }
      }
      for (var O = "", M = g; M <= b; M++) {
        var q = r[M];
        if (n.multiline) {
          if (M === b) {
            O += q[x] + " ", x = (x + 1) % q.length;
            continue;
          }
          if (M === g) {
            O += q[q.length - 1] + " ";
            continue;
          }
        }
        O += q[0] + " ";
      }
      switch (O = O.substr(O.length - 1) == " " ? O.substr(0, O.length - 1) : O, u = Cu(O, n, s).width, n.textAlign) {
        case "right":
          h = a - u - 2;
          break;
        case "center":
          h = (a - u) / 2;
          break;
        case "left":
        default:
          h = 2;
      }
      t += Ie(h) + " " + Ie(f) + ` Td
`, t += "(" + Oo(O) + `) Tj
`, t += -Ie(h) + ` 0 Td
`, f = -(s + 2), u = 0, g = C ? b : b + 1, v++, y = "";
    }
    break;
  }
  return i.text = t, i.fontSize = s, i;
}, Cu = function(n, t, e) {
  var i = t.scope.internal.getFont(t.fontName, t.fontStyle), r = t.scope.getStringUnitWidth(n, { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e);
  return { height: t.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e) * 1.5, width: r };
}, Av = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Nv = function(n, t) {
  var e = { type: "reference", object: n };
  t.internal.getPageInfo(n.page).pageContext.annotations.find(function(i) {
    return i.type === e.type && i.object === e.object;
  }) === void 0 && t.internal.getPageInfo(n.page).pageContext.annotations.push(e);
}, Cv = function(n, t) {
  for (var e in n) if (n.hasOwnProperty(e)) {
    var i = e, r = n[e];
    t.internal.newObjectDeferredBegin(r.objId, !0), en(r) === "object" && typeof r.putStream == "function" && r.putStream(), delete n[i];
  }
}, Pv = function(n, t) {
  if (t.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (mr.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(Av)), n.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    kd = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new T1(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(e) {
        e.internal.events.unsubscribe(e.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete e.internal.acroformPlugin.acroFormDictionaryRoot._eventID, e.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(e) {
        e.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = e.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r in i) if (i.hasOwnProperty(r)) {
          var s = i[r];
          s.objId = void 0, s.hasAnnotation && Nv(s, e);
        }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(e) {
        if (e.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        e.internal.write("/AcroForm " + e.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(e) {
      (function(i, r) {
        var s = !i;
        for (var o in i || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (i.hasOwnProperty(o)) {
          var a = i[o], l = [], h = a.Rect;
          if (a.Rect && (a.Rect = Sv(a.Rect, r)), r.internal.newObjectDeferredBegin(a.objId, !0), a.DA = he.createDefaultAppearanceStream(a), en(a) === "object" && typeof a.getKeyValueListForStream == "function" && (l = a.getKeyValueListForStream()), a.Rect = h, a.hasAppearanceStream && !a.appearanceStreamContent) {
            var u = kv(a);
            l.push({ key: "AP", value: "<</N " + u + ">>" }), r.internal.acroformPlugin.xForms.push(u);
          }
          if (a.appearanceStreamContent) {
            var d = "";
            for (var p in a.appearanceStreamContent) if (a.appearanceStreamContent.hasOwnProperty(p)) {
              var f = a.appearanceStreamContent[p];
              if (d += "/" + p + " ", d += "<<", Object.keys(f).length >= 1 || Array.isArray(f)) {
                for (var o in f) if (f.hasOwnProperty(o)) {
                  var g = f[o];
                  typeof g == "function" && (g = g.call(r, a)), d += "/" + o + " " + g + " ", r.internal.acroformPlugin.xForms.indexOf(g) >= 0 || r.internal.acroformPlugin.xForms.push(g);
                }
              } else typeof (g = f) == "function" && (g = g.call(r, a)), d += "/" + o + " " + g, r.internal.acroformPlugin.xForms.indexOf(g) >= 0 || r.internal.acroformPlugin.xForms.push(g);
              d += ">>";
            }
            l.push({ key: "AP", value: `<<
` + d + ">>" });
          }
          r.internal.putStream({ additionalKeyValues: l, objectId: a.objId }), r.internal.out("endobj");
        }
        s && Cv(r.internal.acroformPlugin.xForms, r);
      })(e, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, E1 = _n.__acroform__.arrayToPdfArray = function(n, t, e) {
  var i = function(o) {
    return o;
  };
  if (Array.isArray(n)) {
    for (var r = "[", s = 0; s < n.length; s++) switch (s !== 0 && (r += " "), en(n[s])) {
      case "boolean":
      case "number":
      case "object":
        r += n[s].toString();
        break;
      case "string":
        n[s].substr(0, 1) !== "/" ? (t !== void 0 && e && (i = e.internal.getEncryptor(t)), r += "(" + Oo(i(n[s].toString())) + ")") : r += n[s].toString();
    }
    return r += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Ph = function(n, t, e) {
  var i = function(r) {
    return r;
  };
  return t !== void 0 && e && (i = e.internal.getEncryptor(t)), (n = n || "").toString(), n = "(" + Oo(i(n)) + ")";
}, Lr = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Lr.prototype.toString = function() {
  return this.objId + " 0 R";
}, Lr.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, Lr.prototype.getKeyValueListForStream = function() {
  var n = [], t = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var e in t) if (Object.getOwnPropertyDescriptor(this, t[e]).configurable === !1) {
    var i = t[e], r = this[i];
    r && (Array.isArray(r) ? n.push({ key: i, value: E1(r, this.objId, this.scope) }) : r instanceof Lr ? (r.scope = this.scope, n.push({ key: i, value: r.objId + " 0 R" })) : typeof r != "function" && n.push({ key: i, value: r }));
  }
  return n;
};
var O1 = function() {
  Lr.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, t = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return t;
  }, set: function(e) {
    t = e;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(e) {
    n = e.trim();
  }, get: function() {
    return n || null;
  } });
};
ki(O1, Lr);
var T1 = function() {
  Lr.call(this);
  var n, t = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return t.length > 0 ? t : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return t;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var e = function(i) {
        return i;
      };
      return this.scope && (e = this.scope.internal.getEncryptor(this.objId)), "(" + Oo(e(n)) + ")";
    }
  }, set: function(e) {
    n = e;
  } });
};
ki(T1, Lr);
var mr = function n() {
  Lr.call(this);
  var t = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(y) {
    if (isNaN(y)) throw new Error('Invalid value "' + y + '" for attribute F supplied.');
    t = y;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(t, 3);
  }, set: function(y) {
    y ? this.F = Pn(t, 3) : this.F = Ln(t, 3);
  } });
  var e = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(y) {
    if (isNaN(y)) throw new Error('Invalid value "' + y + '" for attribute Ff supplied.');
    e = y;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0) return i;
  }, set: function(y) {
    i = y !== void 0 ? y : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(y) {
    i[0] = y;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(y) {
    i[1] = y;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(y) {
    i[2] = y;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(y) {
    i[3] = y;
  } });
  var r = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(y) {
    switch (y) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        r = y;
        break;
      default:
        throw new Error('Invalid value "' + y + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof lc) return;
      s = "FieldObject" + n.FieldNum++;
    }
    var y = function(v) {
      return v;
    };
    return this.scope && (y = this.scope.internal.getEncryptor(this.objId)), "(" + Oo(y(s)) + ")";
  }, set: function(y) {
    s = y.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(y) {
    s = y;
  } });
  var o = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(y) {
    o = y;
  } });
  var a = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(y) {
    a = y;
  } });
  var l = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(y) {
    l = y;
  } });
  var h = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return h === void 0 ? 50 / kd : h;
  }, set: function(y) {
    h = y;
  } });
  var u = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return u;
  }, set: function(y) {
    u = y;
  } });
  var d = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!d || this instanceof lc || this instanceof js)) return Ph(d, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), d = y;
  } });
  var p = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (p) return this instanceof jn ? p : Ph(p, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), p = this instanceof jn ? y : y.substr(0, 1) === "(" ? na(y.substr(1, y.length - 2)) : na(y);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof jn ? na(p.substr(1, p.length - 1)) : p;
  }, set: function(y) {
    y = y.toString(), p = this instanceof jn ? "/" + y : y;
  } });
  var f = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return f;
  }, set: function(y) {
    this.V = y;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return this instanceof jn ? f : Ph(f, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), f = this instanceof jn ? y : y.substr(0, 1) === "(" ? na(y.substr(1, y.length - 2)) : na(y);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof jn ? na(f.substr(1, f.length - 1)) : f;
  }, set: function(y) {
    y = y.toString(), f = this instanceof jn ? "/" + y : y;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var g, b = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(y) {
    y = !!y, b = y;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (g) return g;
  }, set: function(y) {
    g = y;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 1);
  }, set: function(y) {
    y ? this.Ff = Pn(this.Ff, 1) : this.Ff = Ln(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 2);
  }, set: function(y) {
    y ? this.Ff = Pn(this.Ff, 2) : this.Ff = Ln(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 3);
  }, set: function(y) {
    y ? this.Ff = Pn(this.Ff, 3) : this.Ff = Ln(this.Ff, 3);
  } });
  var x = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (x !== null) return x;
  }, set: function(y) {
    if ([0, 1, 2].indexOf(y) === -1) throw new Error('Invalid value "' + y + '" for attribute Q supplied.');
    x = y;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var y;
    switch (x) {
      case 0:
      default:
        y = "left";
        break;
      case 1:
        y = "center";
        break;
      case 2:
        y = "right";
    }
    return y;
  }, configurable: !0, enumerable: !0, set: function(y) {
    switch (y) {
      case "right":
      case 2:
        x = 2;
        break;
      case "center":
      case 1:
        x = 1;
        break;
      case "left":
      case 0:
      default:
        x = 0;
    }
  } });
};
ki(mr, Lr);
var bo = function() {
  mr.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } });
  var t = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return E1(t, this.objId, this.scope);
  }, set: function(e) {
    var i, r;
    r = [], typeof (i = e) == "string" && (r = function(s, o, a) {
      a || (a = 1);
      for (var l, h = []; l = o.exec(s); ) h.push(l[a]);
      return h;
    }(i, /\((.*?)\)/g)), t = r;
  } }), this.getOptions = function() {
    return t;
  }, this.setOptions = function(e) {
    t = e, this.sort && t.sort();
  }, this.addOption = function(e) {
    e = (e = e || "").toString(), t.push(e), this.sort && t.sort();
  }, this.removeOption = function(e, i) {
    for (i = i || !1, e = (e = e || "").toString(); t.indexOf(e) !== -1 && (t.splice(t.indexOf(e), 1), i !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 18);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 18) : this.Ff = Ln(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 19);
  }, set: function(e) {
    this.combo === !0 && (e ? this.Ff = Pn(this.Ff, 19) : this.Ff = Ln(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 20);
  }, set: function(e) {
    e ? (this.Ff = Pn(this.Ff, 20), t.sort()) : this.Ff = Ln(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 22);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 22) : this.Ff = Ln(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 23) : this.Ff = Ln(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 27);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 27) : this.Ff = Ln(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
ki(bo, mr);
var vo = function() {
  bo.call(this), this.fontName = "helvetica", this.combo = !1;
};
ki(vo, bo);
var wo = function() {
  vo.call(this), this.combo = !0;
};
ki(wo, vo);
var kl = function() {
  wo.call(this), this.edit = !0;
};
ki(kl, wo);
var jn = function() {
  mr.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 15);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 15) : this.Ff = Ln(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 16);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 16) : this.Ff = Ln(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 17);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 17) : this.Ff = Ln(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Pn(this.Ff, 26) : this.Ff = Ln(this.Ff, 26);
  } });
  var n, t = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var e = function(s) {
      return s;
    };
    if (this.scope && (e = this.scope.internal.getEncryptor(this.objId)), Object.keys(t).length !== 0) {
      var i, r = [];
      for (i in r.push("<<"), t) r.push("/" + i + " (" + Oo(e(t[i])) + ")");
      return r.push(">>"), r.join(`
`);
    }
  }, set: function(e) {
    en(e) === "object" && (t = e);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return t.CA || "";
  }, set: function(e) {
    typeof e == "string" && (t.CA = e);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(e) {
    n = "/" + e;
  } });
};
ki(jn, mr);
var Al = function() {
  jn.call(this), this.pushButton = !0;
};
ki(Al, jn);
var xo = function() {
  jn.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t !== void 0 ? t : [];
  } });
};
ki(xo, jn);
var lc = function() {
  var n, t;
  mr.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(r) {
    n = r;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return t;
  }, set: function(r) {
    t = r;
  } });
  var e, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var r = function(a) {
      return a;
    };
    this.scope && (r = this.scope.internal.getEncryptor(this.objId));
    var s, o = [];
    for (s in o.push("<<"), i) o.push("/" + s + " (" + Oo(r(i[s])) + ")");
    return o.push(">>"), o.join(`
`);
  }, set: function(r) {
    en(r) === "object" && (i = r);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(r) {
    typeof r == "string" && (i.CA = r);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(r) {
    e = r;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(r) {
    e = "/" + r;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = he.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
ki(lc, mr), xo.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var t in this.Kids) if (this.Kids.hasOwnProperty(t)) {
    var e = this.Kids[t];
    e.appearanceStreamContent = n.createAppearanceStream(e.optionName), e.caption = n.getCA();
  }
}, xo.prototype.createOption = function(n) {
  var t = new lc();
  return t.Parent = this, t.optionName = n, this.Kids.push(t), Lv.call(this.scope, t), t;
};
var Nl = function() {
  jn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = he.CheckBox.createAppearanceStream();
};
ki(Nl, jn);
var js = function() {
  mr.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 13);
  }, set: function(t) {
    t ? this.Ff = Pn(this.Ff, 13) : this.Ff = Ln(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 21);
  }, set: function(t) {
    t ? this.Ff = Pn(this.Ff, 21) : this.Ff = Ln(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Pn(this.Ff, 23) : this.Ff = Ln(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 24);
  }, set: function(t) {
    t ? this.Ff = Pn(this.Ff, 24) : this.Ff = Ln(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 25);
  }, set: function(t) {
    t ? this.Ff = Pn(this.Ff, 25) : this.Ff = Ln(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Pn(this.Ff, 26) : this.Ff = Ln(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    Number.isInteger(t) && (n = t);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
ki(js, mr);
var Cl = function() {
  js.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Cn(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = Pn(this.Ff, 14) : this.Ff = Ln(this.Ff, 14);
  } }), this.password = !0;
};
ki(Cl, js);
var he = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: he.CheckBox.YesNormal }, D: { On: he.CheckBox.YesPushDown, Off: he.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [], i = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), s = gf(n, n.caption);
  return e.push("0.749023 g"), e.push("0 0 " + Ie(he.internal.getWidth(n)) + " " + Ie(he.internal.getHeight(n)) + " re"), e.push("f"), e.push("BMC"), e.push("q"), e.push("0 0 1 rg"), e.push("/" + i + " " + Ie(s.fontSize) + " Tf " + r), e.push("BT"), e.push(s.text), e.push("ET"), e.push("Q"), e.push("EMC"), t.stream = e.join(`
`), t;
}, YesNormal: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), r = [], s = he.internal.getHeight(n), o = he.internal.getWidth(n), a = gf(n, n.caption);
  return r.push("1 g"), r.push("0 0 " + Ie(o) + " " + Ie(s) + " re"), r.push("f"), r.push("q"), r.push("0 0 1 rg"), r.push("0 0 " + Ie(o - 1) + " " + Ie(s - 1) + " re"), r.push("W"), r.push("n"), r.push("0 g"), r.push("BT"), r.push("/" + e + " " + Ie(a.fontSize) + " Tf " + i), r.push(a.text), r.push("ET"), r.push("Q"), t.stream = r.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Ie(he.internal.getWidth(n)) + " " + Ie(he.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var t = { D: { Off: he.RadioButton.Circle.OffPushDown }, N: {} };
  return t.N[n] = he.RadioButton.Circle.YesNormal, t.D[n] = he.RadioButton.Circle.YesPushDown, t;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [], i = he.internal.getWidth(n) <= he.internal.getHeight(n) ? he.internal.getWidth(n) / 4 : he.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = he.internal.Bezier_C, s = Number((i * r).toFixed(5));
  return e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), e.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), e.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), e.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [], i = he.internal.getWidth(n) <= he.internal.getHeight(n) ? he.internal.getWidth(n) / 4 : he.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * he.internal.Bezier_C).toFixed(5)), o = Number((i * he.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), e.push("0 g"), e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), e.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), e.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), e.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [], i = he.internal.getWidth(n) <= he.internal.getHeight(n) ? he.internal.getWidth(n) / 4 : he.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * he.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
} }, Cross: { createAppearanceStream: function(n) {
  var t = { D: { Off: he.RadioButton.Cross.OffPushDown }, N: {} };
  return t.N[n] = he.RadioButton.Cross.YesNormal, t.D[n] = he.RadioButton.Cross.YesPushDown, t;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [], i = he.internal.calculateCross(n);
  return e.push("q"), e.push("1 1 " + Ie(he.internal.getWidth(n) - 2) + " " + Ie(he.internal.getHeight(n) - 2) + " re"), e.push("W"), e.push("n"), e.push(Ie(i.x1.x) + " " + Ie(i.x1.y) + " m"), e.push(Ie(i.x2.x) + " " + Ie(i.x2.y) + " l"), e.push(Ie(i.x4.x) + " " + Ie(i.x4.y) + " m"), e.push(Ie(i.x3.x) + " " + Ie(i.x3.y) + " l"), e.push("s"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = he.internal.calculateCross(n), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + Ie(he.internal.getWidth(n)) + " " + Ie(he.internal.getHeight(n)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + Ie(he.internal.getWidth(n) - 2) + " " + Ie(he.internal.getHeight(n) - 2) + " re"), i.push("W"), i.push("n"), i.push(Ie(e.x1.x) + " " + Ie(e.x1.y) + " m"), i.push(Ie(e.x2.x) + " " + Ie(e.x2.y) + " l"), i.push(Ie(e.x4.x) + " " + Ie(e.x4.y) + " m"), i.push(Ie(e.x3.x) + " " + Ie(e.x3.y) + " l"), i.push("s"), i.push("Q"), t.stream = i.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Ar(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Ie(he.internal.getWidth(n)) + " " + Ie(he.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} } }, createDefaultAppearanceStream: function(n) {
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, e = n.scope.__private__.encodeColorString(n.color);
  return "/" + t + " " + n.fontSize + " Tf " + e;
} };
he.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var t = he.internal.getWidth(n), e = he.internal.getHeight(n), i = Math.min(t, e);
  return { x1: { x: (t - i) / 2, y: (e - i) / 2 + i }, x2: { x: (t - i) / 2 + i, y: (e - i) / 2 }, x3: { x: (t - i) / 2, y: (e - i) / 2 }, x4: { x: (t - i) / 2 + i, y: (e - i) / 2 + i } };
} }, he.internal.getWidth = function(n) {
  var t = 0;
  return en(n) === "object" && (t = Jp(n.Rect[2])), t;
}, he.internal.getHeight = function(n) {
  var t = 0;
  return en(n) === "object" && (t = Jp(n.Rect[3])), t;
};
var Lv = _n.addField = function(n) {
  if (Pv(this, n), !(n instanceof mr)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var t;
  return (t = n).scope.internal.acroformPlugin.printedOut && (t.scope.internal.acroformPlugin.printedOut = !1, t.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), t.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
_n.AcroFormChoiceField = bo, _n.AcroFormListBox = vo, _n.AcroFormComboBox = wo, _n.AcroFormEditBox = kl, _n.AcroFormButton = jn, _n.AcroFormPushButton = Al, _n.AcroFormRadioButton = xo, _n.AcroFormCheckBox = Nl, _n.AcroFormTextField = js, _n.AcroFormPasswordField = Cl, _n.AcroFormAppearance = he, _n.AcroForm = { ChoiceField: bo, ListBox: vo, ComboBox: wo, EditBox: kl, Button: jn, PushButton: Al, RadioButton: xo, CheckBox: Nl, TextField: js, PasswordField: Cl, Appearance: he }, Se.AcroForm = { ChoiceField: bo, ListBox: vo, ComboBox: wo, EditBox: kl, Button: jn, PushButton: Al, RadioButton: xo, CheckBox: Nl, TextField: js, PasswordField: Cl, Appearance: he };
var Iv = Se.AcroForm;
function F1(n) {
  return n.reduce(function(t, e, i) {
    return t[e] = i, t;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var t = "UNKNOWN", e = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = n.__addimage__.getImageFileTypeByImageData = function(P, A) {
    var F, _, J, V, R, tt = t;
    if ((A = A || t) === "RGBA" || P.data !== void 0 && P.data instanceof Uint8ClampedArray && "height" in P && "width" in P) return "RGBA";
    if (D(P)) for (R in e) for (J = e[R], F = 0; F < J.length; F += 1) {
      for (V = !0, _ = 0; _ < J[F].length; _ += 1) if (J[F][_] !== void 0 && J[F][_] !== P[_]) {
        V = !1;
        break;
      }
      if (V === !0) {
        tt = R;
        break;
      }
    }
    else for (R in e) for (J = e[R], F = 0; F < J.length; F += 1) {
      for (V = !0, _ = 0; _ < J[F].length; _ += 1) if (J[F][_] !== void 0 && J[F][_] !== P.charCodeAt(_)) {
        V = !1;
        break;
      }
      if (V === !0) {
        tt = R;
        break;
      }
    }
    return tt === t && A !== t && (tt = A), tt;
  }, r = function P(A) {
    for (var F = this.internal.write, _ = this.internal.putStream, J = (0, this.internal.getFilters)(); J.indexOf("FlateEncode") !== -1; ) J.splice(J.indexOf("FlateEncode"), 1);
    A.objectId = this.internal.newObject();
    var V = [];
    if (V.push({ key: "Type", value: "/XObject" }), V.push({ key: "Subtype", value: "/Image" }), V.push({ key: "Width", value: A.width }), V.push({ key: "Height", value: A.height }), A.colorSpace === x.INDEXED ? V.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (A.palette.length / 3 - 1) + " " + ("sMask" in A && A.sMask !== void 0 ? A.objectId + 2 : A.objectId + 1) + " 0 R]" }) : (V.push({ key: "ColorSpace", value: "/" + A.colorSpace }), A.colorSpace === x.DEVICE_CMYK && V.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), V.push({ key: "BitsPerComponent", value: A.bitsPerComponent }), "decodeParameters" in A && A.decodeParameters !== void 0 && V.push({ key: "DecodeParms", value: "<<" + A.decodeParameters + ">>" }), "transparency" in A && Array.isArray(A.transparency)) {
      for (var R = "", tt = 0, H = A.transparency.length; tt < H; tt++) R += A.transparency[tt] + " " + A.transparency[tt] + " ";
      V.push({ key: "Mask", value: "[" + R + "]" });
    }
    A.sMask !== void 0 && V.push({ key: "SMask", value: A.objectId + 1 + " 0 R" });
    var ct = A.filter !== void 0 ? ["/" + A.filter] : void 0;
    if (_({ data: A.data, additionalKeyValues: V, alreadyAppliedFilters: ct, objectId: A.objectId }), F("endobj"), "sMask" in A && A.sMask !== void 0) {
      var it = "/Predictor " + A.predictor + " /Colors 1 /BitsPerComponent " + A.bitsPerComponent + " /Columns " + A.width, N = { width: A.width, height: A.height, colorSpace: "DeviceGray", bitsPerComponent: A.bitsPerComponent, decodeParameters: it, data: A.sMask };
      "filter" in A && (N.filter = A.filter), P.call(this, N);
    }
    if (A.colorSpace === x.INDEXED) {
      var z = this.internal.newObject();
      _({ data: O(new Uint8Array(A.palette)), objectId: z }), F("endobj");
    }
  }, s = function() {
    var P = this.internal.collections.addImage_images;
    for (var A in P) r.call(this, P[A]);
  }, o = function() {
    var P, A = this.internal.collections.addImage_images, F = this.internal.write;
    for (var _ in A) F("/I" + (P = A[_]).index, P.objectId, "0", "R");
  }, a = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", o));
  }, l = function() {
    var P = this.internal.collections.addImage_images;
    return a.call(this), P;
  }, h = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, u = function(P) {
    return typeof n["process" + P.toUpperCase()] == "function";
  }, d = function(P) {
    return en(P) === "object" && P.nodeType === 1;
  }, p = function(P, A) {
    if (P.nodeName === "IMG" && P.hasAttribute("src")) {
      var F = "" + P.getAttribute("src");
      if (F.indexOf("data:image/") === 0) return Sl(unescape(F).split("base64,").pop());
      var _ = n.loadFile(F, !0);
      if (_ !== void 0) return _;
    }
    if (P.nodeName === "CANVAS") {
      if (P.width === 0 || P.height === 0) throw new Error("Given canvas must have data. Canvas width: " + P.width + ", height: " + P.height);
      var J;
      switch (A) {
        case "PNG":
          J = "image/png";
          break;
        case "WEBP":
          J = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          J = "image/jpeg";
      }
      return Sl(P.toDataURL(J, 1).split("base64,").pop());
    }
  }, f = function(P) {
    var A = this.internal.collections.addImage_images;
    if (A) {
      for (var F in A) if (P === A[F].alias) return A[F];
    }
  }, g = function(P, A, F) {
    return P || A || (P = -96, A = -96), P < 0 && (P = -1 * F.width * 72 / P / this.internal.scaleFactor), A < 0 && (A = -1 * F.height * 72 / A / this.internal.scaleFactor), P === 0 && (P = A * F.width / F.height), A === 0 && (A = P * F.height / F.width), [P, A];
  }, b = function(P, A, F, _, J, V) {
    var R = g.call(this, F, _, J), tt = this.internal.getCoordinateString, H = this.internal.getVerticalCoordinateString, ct = l.call(this);
    if (F = R[0], _ = R[1], ct[J.index] = J, V) {
      V *= Math.PI / 180;
      var it = Math.cos(V), N = Math.sin(V), z = function(Y) {
        return Y.toFixed(4);
      }, G = [z(it), z(N), z(-1 * N), z(it), 0, 0, "cm"];
    }
    this.internal.write("q"), V ? (this.internal.write([1, "0", "0", 1, tt(P), H(A + _), "cm"].join(" ")), this.internal.write(G.join(" ")), this.internal.write([tt(F), "0", "0", tt(_), "0", "0", "cm"].join(" "))) : this.internal.write([tt(F), "0", "0", tt(_), tt(P), H(A + _), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + J.index + " Do"), this.internal.write("Q");
  }, x = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, v = n.__addimage__.sHashCode = function(P) {
    var A, F, _ = 0;
    if (typeof P == "string") for (F = P.length, A = 0; A < F; A++) _ = (_ << 5) - _ + P.charCodeAt(A), _ |= 0;
    else if (D(P)) for (F = P.byteLength / 2, A = 0; A < F; A++) _ = (_ << 5) - _ + P[A], _ |= 0;
    return _;
  }, k = n.__addimage__.validateStringAsBase64 = function(P) {
    (P = P || "").toString().trim();
    var A = !0;
    return P.length === 0 && (A = !1), P.length % 4 != 0 && (A = !1), /^[A-Za-z0-9+/]+$/.test(P.substr(0, P.length - 2)) === !1 && (A = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(P.substr(-2)) === !1 && (A = !1), A;
  }, C = n.__addimage__.extractImageFromDataUrl = function(P) {
    var A = (P = P || "").split("base64,"), F = null;
    if (A.length === 2) {
      var _ = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(A[0]);
      Array.isArray(_) && (F = { mimeType: _[1], charset: _[2], data: A[1] });
    }
    return F;
  }, I = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(P) {
    return I() && P instanceof ArrayBuffer;
  };
  var D = n.__addimage__.isArrayBufferView = function(P) {
    return I() && typeof Uint32Array < "u" && (P instanceof Int8Array || P instanceof Uint8Array || typeof Uint8ClampedArray < "u" && P instanceof Uint8ClampedArray || P instanceof Int16Array || P instanceof Uint16Array || P instanceof Int32Array || P instanceof Uint32Array || P instanceof Float32Array || P instanceof Float64Array);
  }, E = n.__addimage__.binaryStringToUint8Array = function(P) {
    for (var A = P.length, F = new Uint8Array(A), _ = 0; _ < A; _++) F[_] = P.charCodeAt(_);
    return F;
  }, O = n.__addimage__.arrayBufferToBinaryString = function(P) {
    for (var A = "", F = D(P) ? P : new Uint8Array(P), _ = 0; _ < F.length; _ += 8192) A += String.fromCharCode.apply(null, F.subarray(_, _ + 8192));
    return A;
  };
  n.addImage = function() {
    var P, A, F, _, J, V, R, tt, H;
    if (typeof arguments[1] == "number" ? (A = t, F = arguments[1], _ = arguments[2], J = arguments[3], V = arguments[4], R = arguments[5], tt = arguments[6], H = arguments[7]) : (A = arguments[1], F = arguments[2], _ = arguments[3], J = arguments[4], V = arguments[5], R = arguments[6], tt = arguments[7], H = arguments[8]), en(P = arguments[0]) === "object" && !d(P) && "imageData" in P) {
      var ct = P;
      P = ct.imageData, A = ct.format || A || t, F = ct.x || F || 0, _ = ct.y || _ || 0, J = ct.w || ct.width || J, V = ct.h || ct.height || V, R = ct.alias || R, tt = ct.compression || tt, H = ct.rotation || ct.angle || H;
    }
    var it = this.internal.getFilters();
    if (tt === void 0 && it.indexOf("FlateEncode") !== -1 && (tt = "SLOW"), isNaN(F) || isNaN(_)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    a.call(this);
    var N = M.call(this, P, A, R, tt);
    return b.call(this, F, _, J, V, N, H), this;
  };
  var M = function(P, A, F, _) {
    var J, V, R;
    if (typeof P == "string" && i(P) === t) {
      P = unescape(P);
      var tt = q(P, !1);
      (tt !== "" || (tt = n.loadFile(P, !0)) !== void 0) && (P = tt);
    }
    if (d(P) && (P = p(P, A)), A = i(P, A), !u(A)) throw new Error("addImage does not support files of type '" + A + "', please ensure that a plugin for '" + A + "' support is added.");
    if (((R = F) == null || R.length === 0) && (F = function(H) {
      return typeof H == "string" || D(H) ? v(H) : D(H.data) ? v(H.data) : null;
    }(P)), (J = f.call(this, F)) || (I() && (P instanceof Uint8Array || A === "RGBA" || (V = P, P = E(P))), J = this["process" + A.toUpperCase()](P, h.call(this), F, function(H) {
      return H && typeof H == "string" && (H = H.toUpperCase()), H in n.image_compression ? H : y.NONE;
    }(_), V)), !J) throw new Error("An unknown error occurred whilst processing the image.");
    return J;
  }, q = n.__addimage__.convertBase64ToBinaryString = function(P, A) {
    var F;
    A = typeof A != "boolean" || A;
    var _, J = "";
    if (typeof P == "string") {
      _ = (F = C(P)) !== null ? F.data : P;
      try {
        J = Sl(_);
      } catch (V) {
        if (A) throw k(_) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + V.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return J;
  };
  n.getImageProperties = function(P) {
    var A, F, _ = "";
    if (d(P) && (P = p(P)), typeof P == "string" && i(P) === t && ((_ = q(P, !1)) === "" && (_ = n.loadFile(P) || ""), P = _), F = i(P), !u(F)) throw new Error("addImage does not support files of type '" + F + "', please ensure that a plugin for '" + F + "' support is added.");
    if (!I() || P instanceof Uint8Array || (P = E(P)), !(A = this["process" + F.toUpperCase()](P))) throw new Error("An unknown error occurred whilst processing the image");
    return A.fileType = F, A;
  };
})(Se.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    if (e !== void 0 && e != "") return !0;
  };
  Se.API.events.push(["addPage", function(e) {
    this.internal.getPageInfo(e.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(e) {
    for (var i, r, s, o = this.internal.getCoordinateString, a = this.internal.getVerticalCoordinateString, l = this.internal.getPageInfoByObjId(e.objId), h = e.pageContext.annotations, u = !1, d = 0; d < h.length && !u; d++) switch ((i = h[d]).type) {
      case "link":
        (t(i.options.url) || t(i.options.pageNumber)) && (u = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        u = !0;
    }
    if (u != 0) {
      this.internal.write("/Annots [");
      for (var p = 0; p < h.length; p++) {
        i = h[p];
        var f = this.internal.pdfEscape, g = this.internal.getEncryptor(e.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var b = this.internal.newAdditionalObject(), x = this.internal.newAdditionalObject(), y = this.internal.getEncryptor(b.objId), v = i.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y) + "] ") + "/Contents (" + f(y(i.contents)) + ")", s += " /Popup " + x.objId + " 0 R", s += " /P " + l.objId + " 0 R", s += " /T (" + f(y(v)) + ") >>", b.content = s;
            var k = b.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + o(i.bounds.x + 30) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w + 30) + " " + a(i.bounds.y) + "] ") + " /Parent " + k, i.open && (s += " /Open true"), s += " >>", x.content = s, this.internal.write(b.objId, "0 R", x.objId, "0 R");
            break;
          case "freetext":
            r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y + i.bounds.h) + "] ";
            var C = i.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + f(g(i.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + C + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (i.options.name) {
              var I = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = I.page, i.options.top = I.y;
            } else i.options.top || (i.options.top = 0);
            if (r = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", s = "", i.options.url) s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + f(g(i.options.url)) + ") >>";
            else if (i.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + i.options.top + "]";
                  break;
                case "FitV":
                  i.options.left = i.options.left || 0, s += " /FitV " + i.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var D = a(i.options.top);
                  i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), s += " /XYZ " + i.options.left + " " + D + " " + i.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(e) {
    var i = this.internal.getCurrentPageInfo();
    switch (e.type) {
      case "link":
        this.link(e.bounds.x, e.bounds.y, e.bounds.w, e.bounds.h, e);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(e);
    }
  }, n.link = function(e, i, r, s, o) {
    var a = this.internal.getCurrentPageInfo(), l = this.internal.getCoordinateString, h = this.internal.getVerticalCoordinateString;
    a.pageContext.annotations.push({ finalBounds: { x: l(e), y: h(i), w: l(e + r), h: h(i + s) }, options: o, type: "link" });
  }, n.textWithLink = function(e, i, r, s) {
    var o, a, l = this.getTextWidth(e), h = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      a = s.maxWidth;
      var u = this.splitTextToSize(e, a).length;
      o = Math.ceil(h * u);
    } else a = l, o = h;
    return this.text(e, i, r, s), r += 0.2 * h, s.align === "center" && (i -= l / 2), s.align === "right" && (i -= l), this.link(i, r - h, a, o, s), l;
  }, n.getTextWidth = function(e) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(e) * i / this.internal.scaleFactor;
  };
}(Se.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, e = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, r = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var s = n.__arabicParser__.isInArabicSubstitutionA = function(b) {
    return t[b.charCodeAt(0)] !== void 0;
  }, o = n.__arabicParser__.isArabicLetter = function(b) {
    return typeof b == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(b);
  }, a = n.__arabicParser__.isArabicEndLetter = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length <= 2;
  }, l = n.__arabicParser__.isArabicAlfLetter = function(b) {
    return o(b) && r.indexOf(b.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 1;
  };
  var h = n.__arabicParser__.arabicLetterHasFinalForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 3;
  };
  var u = n.__arabicParser__.arabicLetterHasMedialForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length == 4;
  }, d = n.__arabicParser__.resolveLigatures = function(b) {
    var x = 0, y = e, v = "", k = 0;
    for (x = 0; x < b.length; x += 1) y[b.charCodeAt(x)] !== void 0 ? (k++, typeof (y = y[b.charCodeAt(x)]) == "number" && (v += String.fromCharCode(y), y = e, k = 0), x === b.length - 1 && (y = e, v += b.charAt(x - (k - 1)), x -= k - 1, k = 0)) : (y = e, v += b.charAt(x - k), x -= k, k = 0);
    return v;
  };
  n.__arabicParser__.isArabicDiacritic = function(b) {
    return b !== void 0 && i[b.charCodeAt(0)] !== void 0;
  };
  var p = n.__arabicParser__.getCorrectForm = function(b, x, y) {
    return o(b) ? s(b) === !1 ? -1 : !h(b) || !o(x) && !o(y) || !o(y) && a(x) || a(b) && !o(x) || a(b) && l(x) || a(b) && a(x) ? 0 : u(b) && o(x) && !a(x) && o(y) && h(y) ? 3 : a(b) || !o(y) ? 1 : 2 : -1;
  }, f = function(b) {
    var x = 0, y = 0, v = 0, k = "", C = "", I = "", D = (b = b || "").split("\\s+"), E = [];
    for (x = 0; x < D.length; x += 1) {
      for (E.push(""), y = 0; y < D[x].length; y += 1) k = D[x][y], C = D[x][y - 1], I = D[x][y + 1], o(k) ? (v = p(k, C, I), E[x] += v !== -1 ? String.fromCharCode(t[k.charCodeAt(0)][v]) : k) : E[x] += k;
      E[x] = d(E[x]);
    }
    return E.join(" ");
  }, g = n.__arabicParser__.processArabic = n.processArabic = function() {
    var b, x = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, y = [];
    if (Array.isArray(x)) {
      var v = 0;
      for (y = [], v = 0; v < x.length; v += 1) Array.isArray(x[v]) ? y.push([f(x[v][0]), x[v][1], x[v][2]]) : y.push([f(x[v])]);
      b = y;
    } else b = f(x);
    return typeof arguments[0] == "string" ? b : (arguments[0].text = b, arguments[0]);
  };
  n.events.push(["preProcessText", g]);
}(Se.API), Se.API.autoPrint = function(n) {
  var t;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        t = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + t + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    var e = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return e;
    }, set: function(a) {
      e = a;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(a) {
      i = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 150 : a, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(a) {
      r = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 300 : a, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(a) {
      s = a;
    } });
    var o = {};
    Object.defineProperty(this, "style", { get: function() {
      return o;
    }, set: function(a) {
      o = a;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  t.prototype.getContext = function(e, i) {
    var r;
    if ((e = e || "2d") !== "2d") return null;
    for (r in i) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = i[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, t.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new t(), this.canvas.pdf = this;
  }]);
}(Se.API), function(n) {
  var t = { left: 0, top: 0, bottom: 0, right: 0 }, e = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, t), this.internal.__cell__.margins.width = this.getPageWidth(), r.call(this));
  }, r = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var l = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return l;
    }, set: function(b) {
      l = b;
    } });
    var h = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return h;
    }, set: function(b) {
      h = b;
    } });
    var u = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return u;
    }, set: function(b) {
      u = b;
    } });
    var d = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return d;
    }, set: function(b) {
      d = b;
    } });
    var p = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return p;
    }, set: function(b) {
      p = b;
    } });
    var f = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return f;
    }, set: function(b) {
      f = b;
    } });
    var g = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return g;
    }, set: function(b) {
      g = b;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(l) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof l == "function" ? l : void 0, this;
  }, n.getTextDimensions = function(l, h) {
    i.call(this);
    var u = (h = h || {}).fontSize || this.getFontSize(), d = h.font || this.getFont(), p = h.scaleFactor || this.internal.scaleFactor, f = 0, g = 0, b = 0, x = this;
    if (!Array.isArray(l) && typeof l != "string") {
      if (typeof l != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      l = String(l);
    }
    var y = h.maxWidth;
    y > 0 ? typeof l == "string" ? l = this.splitTextToSize(l, y) : Object.prototype.toString.call(l) === "[object Array]" && (l = l.reduce(function(k, C) {
      return k.concat(x.splitTextToSize(C, y));
    }, [])) : l = Array.isArray(l) ? l : [l];
    for (var v = 0; v < l.length; v++) f < (b = this.getStringUnitWidth(l[v], { font: d }) * u) && (f = b);
    return f !== 0 && (g = l.length), { w: f /= p, h: Math.max((g * u * this.getLineHeightFactor() - u * (this.getLineHeightFactor() - 1)) / p, 0) };
  }, n.cellAddPage = function() {
    i.call(this), this.addPage();
    var l = this.internal.__cell__.margins || t;
    return this.internal.__cell__.lastCell = new s(l.left, l.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var o = n.cell = function() {
    var l;
    l = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var h = this.internal.__cell__.lastCell, u = this.internal.__cell__.padding, d = this.internal.__cell__.margins || t, p = this.internal.__cell__.tableHeaderRow, f = this.internal.__cell__.printHeaders;
    return h.lineNumber !== void 0 && (h.lineNumber === l.lineNumber ? (l.x = (h.x || 0) + (h.width || 0), l.y = h.y || 0) : h.y + h.height + l.height + d.bottom > this.getPageHeight() ? (this.cellAddPage(), l.y = d.top, f && p && (this.printHeaderRow(l.lineNumber, !0), l.y += p[0].height)) : l.y = h.y + h.height || l.y), l.text[0] !== void 0 && (this.rect(l.x, l.y, l.width, l.height, e === !0 ? "FD" : void 0), l.align === "right" ? this.text(l.text, l.x + l.width - u, l.y + u, { align: "right", baseline: "top" }) : l.align === "center" ? this.text(l.text, l.x + l.width / 2, l.y + u, { align: "center", baseline: "top", maxWidth: l.width - u - u }) : this.text(l.text, l.x + u, l.y + u, { align: "left", baseline: "top", maxWidth: l.width - u - u })), this.internal.__cell__.lastCell = l, this;
  };
  n.table = function(l, h, u, d, p) {
    if (i.call(this), !u) throw new Error("No data for PDF table.");
    var f, g, b, x, y = [], v = [], k = [], C = {}, I = {}, D = [], E = [], O = (p = p || {}).autoSize || !1, M = p.printHeaders !== !1, q = p.css && p.css["font-size"] !== void 0 ? 16 * p.css["font-size"] : p.fontSize || 12, P = p.margins || Object.assign({ width: this.getPageWidth() }, t), A = typeof p.padding == "number" ? p.padding : 3, F = p.headerBackgroundColor || "#c8c8c8", _ = p.headerTextColor || "#000";
    if (r.call(this), this.internal.__cell__.printHeaders = M, this.internal.__cell__.margins = P, this.internal.__cell__.table_font_size = q, this.internal.__cell__.padding = A, this.internal.__cell__.headerBackgroundColor = F, this.internal.__cell__.headerTextColor = _, this.setFontSize(q), d == null) v = y = Object.keys(u[0]), k = y.map(function() {
      return "left";
    });
    else if (Array.isArray(d) && en(d[0]) === "object") for (y = d.map(function(ct) {
      return ct.name;
    }), v = d.map(function(ct) {
      return ct.prompt || ct.name || "";
    }), k = d.map(function(ct) {
      return ct.align || "left";
    }), f = 0; f < d.length; f += 1) I[d[f].name] = d[f].width * (19.049976 / 25.4);
    else Array.isArray(d) && typeof d[0] == "string" && (v = y = d, k = y.map(function() {
      return "left";
    }));
    if (O || Array.isArray(d) && typeof d[0] == "string") for (f = 0; f < y.length; f += 1) {
      for (C[x = y[f]] = u.map(function(ct) {
        return ct[x];
      }), this.setFont(void 0, "bold"), D.push(this.getTextDimensions(v[f], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), g = C[x], this.setFont(void 0, "normal"), b = 0; b < g.length; b += 1) D.push(this.getTextDimensions(g[b], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      I[x] = Math.max.apply(null, D) + A + A, D = [];
    }
    if (M) {
      var J = {};
      for (f = 0; f < y.length; f += 1) J[y[f]] = {}, J[y[f]].text = v[f], J[y[f]].align = k[f];
      var V = a.call(this, J, I);
      E = y.map(function(ct) {
        return new s(l, h, I[ct], V, J[ct].text, void 0, J[ct].align);
      }), this.setTableHeaderRow(E), this.printHeaderRow(1, !1);
    }
    var R = d.reduce(function(ct, it) {
      return ct[it.name] = it.align, ct;
    }, {});
    for (f = 0; f < u.length; f += 1) {
      "rowStart" in p && p.rowStart instanceof Function && p.rowStart({ row: f, data: u[f] }, this);
      var tt = a.call(this, u[f], I);
      for (b = 0; b < y.length; b += 1) {
        var H = u[f][y[b]];
        "cellStart" in p && p.cellStart instanceof Function && p.cellStart({ row: f, col: b, data: H }, this), o.call(this, new s(l, h, I[y[b]], tt, H, f + 2, R[y[b]]));
      }
    }
    return this.internal.__cell__.table_x = l, this.internal.__cell__.table_y = h, this;
  };
  var a = function(l, h) {
    var u = this.internal.__cell__.padding, d = this.internal.__cell__.table_font_size, p = this.internal.scaleFactor;
    return Object.keys(l).map(function(f) {
      var g = l[f];
      return this.splitTextToSize(g.hasOwnProperty("text") ? g.text : g, h[f] - u - u);
    }, this).map(function(f) {
      return this.getLineHeightFactor() * f.length * d / p + u + u;
    }, this).reduce(function(f, g) {
      return Math.max(f, g);
    }, 0);
  };
  n.setTableHeaderRow = function(l) {
    i.call(this), this.internal.__cell__.tableHeaderRow = l;
  }, n.printHeaderRow = function(l, h) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var u;
    if (e = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var d = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(d[0], d[1], d[2], d[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var p = [], f = 0; f < this.internal.__cell__.tableHeaderRow.length; f += 1) {
      u = this.internal.__cell__.tableHeaderRow[f].clone(), h && (u.y = this.internal.__cell__.margins.top || 0, p.push(u)), u.lineNumber = l;
      var g = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), o.call(this, u), this.setTextColor(g);
    }
    p.length > 0 && this.setTableHeaderRow(p), this.setFont(void 0, "normal"), e = !1;
  };
}(Se.API);
var M1 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, D1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], mf = F1(D1), R1 = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ev = F1(R1);
function yf(n) {
  var t = n.family.replace(/"|'/g, "").toLowerCase(), e = function(s) {
    return M1[s = s || "normal"] ? s : "normal";
  }(n.style), i = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), r = function(s) {
    return typeof mf[s = s || "normal"] == "number" ? s : "normal";
  }(n.stretch);
  return { family: t, style: e, weight: i, stretch: r, src: n.src || [], ref: n.ref || { name: t, style: [r, e, i].join(" ") } };
}
function Zp(n, t, e, i) {
  var r;
  for (r = e; r >= 0 && r < t.length; r += i) if (n[t[r]]) return n[t[r]];
  for (r = e; r >= 0 && r < t.length; r -= i) if (n[t[r]]) return n[t[r]];
}
var Ov = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Qp = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function tg(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function Tv(n, t, e) {
  for (var i = (e = e || {}).defaultFontFamily || "times", r = Object.assign({}, Ov, e.genericFontFamilies || {}), s = null, o = null, a = 0; a < t.length; ++a) if (r[(s = yf(t[a])).family] && (s.family = r[s.family]), n.hasOwnProperty(s.family)) {
    o = n[s.family];
    break;
  }
  if (!(o = o || n[i])) throw new Error("Could not find a font-family for the rule '" + tg(s) + "' and default family '" + i + "'.");
  if (o = function(l, h) {
    if (h[l]) return h[l];
    var u = mf[l], d = u <= mf.normal ? -1 : 1, p = Zp(h, D1, u, d);
    if (!p) throw new Error("Could not find a matching font-stretch value for " + l);
    return p;
  }(s.stretch, o), o = function(l, h) {
    if (h[l]) return h[l];
    for (var u = M1[l], d = 0; d < u.length; ++d) if (h[u[d]]) return h[u[d]];
    throw new Error("Could not find a matching font-style for " + l);
  }(s.style, o), !(o = function(l, h) {
    if (h[l]) return h[l];
    if (l === 400 && h[500]) return h[500];
    if (l === 500 && h[400]) return h[400];
    var u = Ev[l], d = Zp(h, R1, u, l < 400 ? -1 : 1);
    if (!d) throw new Error("Could not find a matching font-weight for value " + l);
    return d;
  }(s.weight, o))) throw new Error("Failed to resolve a font for the rule '" + tg(s) + "'.");
  return o;
}
function eg(n) {
  return n.trimLeft();
}
function Fv(n, t) {
  for (var e = 0; e < n.length; ) {
    if (n.charAt(e) === t) return [n.substring(0, e), n.substring(e + 1)];
    e += 1;
  }
  return null;
}
function Mv(n) {
  var t = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return t === null ? null : [t[0], n.substring(t[0].length)];
}
var Pu, ng, ig, Lh = ["times"];
(function(n) {
  var t, e, i, r, s, o, a, l, h, u = function(N) {
    return N = N || {}, this.isStrokeTransparent = N.isStrokeTransparent || !1, this.strokeOpacity = N.strokeOpacity || 1, this.strokeStyle = N.strokeStyle || "#000000", this.fillStyle = N.fillStyle || "#000000", this.isFillTransparent = N.isFillTransparent || !1, this.fillOpacity = N.fillOpacity || 1, this.font = N.font || "10px sans-serif", this.textBaseline = N.textBaseline || "alphabetic", this.textAlign = N.textAlign || "left", this.lineWidth = N.lineWidth || 1, this.lineJoin = N.lineJoin || "miter", this.lineCap = N.lineCap || "butt", this.path = N.path || [], this.transform = N.transform !== void 0 ? N.transform.clone() : new l(), this.globalCompositeOperation = N.globalCompositeOperation || "normal", this.globalAlpha = N.globalAlpha || 1, this.clip_path = N.clip_path || [], this.currentPoint = N.currentPoint || new o(), this.miterLimit = N.miterLimit || 10, this.lastPoint = N.lastPoint || new o(), this.lineDashOffset = N.lineDashOffset || 0, this.lineDash = N.lineDash || [], this.margin = N.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = N.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof N.ignoreClearRect != "boolean" || N.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new d(this), t = this.internal.f2, e = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, r = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, o = this.internal.Point, a = this.internal.Rectangle, l = this.internal.Matrix, h = new u();
  }]);
  var d = function(N) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var z = N;
    Object.defineProperty(this, "pdf", { get: function() {
      return z;
    } });
    var G = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return G;
    }, set: function(ht) {
      G = !!ht;
    } });
    var Y = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Y;
    }, set: function(ht) {
      Y = !!ht;
    } });
    var ot = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ot;
    }, set: function(ht) {
      isNaN(ht) || (ot = ht);
    } });
    var xt = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return xt;
    }, set: function(ht) {
      isNaN(ht) || (xt = ht);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return h.margin;
    }, set: function(ht) {
      var $;
      typeof ht == "number" ? $ = [ht, ht, ht, ht] : (($ = new Array(4))[0] = ht[0], $[1] = ht.length >= 2 ? ht[1] : $[0], $[2] = ht.length >= 3 ? ht[2] : $[0], $[3] = ht.length >= 4 ? ht[3] : $[1]), h.margin = $;
    } });
    var gt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return gt;
    }, set: function(ht) {
      gt = ht;
    } });
    var wt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return wt;
    }, set: function(ht) {
      wt = ht;
    } });
    var qt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return qt;
    }, set: function(ht) {
      qt = ht;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return h;
    }, set: function(ht) {
      ht instanceof u && (h = ht);
    } }), Object.defineProperty(this, "path", { get: function() {
      return h.path;
    }, set: function(ht) {
      h.path = ht;
    } });
    var Rt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Rt;
    }, set: function(ht) {
      Rt = ht;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ht) {
      var $;
      $ = p(ht), this.ctx.fillStyle = $.style, this.ctx.isFillTransparent = $.a === 0, this.ctx.fillOpacity = $.a, this.pdf.setFillColor($.r, $.g, $.b, { a: $.a }), this.pdf.setTextColor($.r, $.g, $.b, { a: $.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ht) {
      var $ = p(ht);
      this.ctx.strokeStyle = $.style, this.ctx.isStrokeTransparent = $.a === 0, this.ctx.strokeOpacity = $.a, $.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : ($.a, this.pdf.setDrawColor($.r, $.g, $.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ht) {
      ["butt", "round", "square"].indexOf(ht) !== -1 && (this.ctx.lineCap = ht, this.pdf.setLineCap(ht));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ht) {
      isNaN(ht) || (this.ctx.lineWidth = ht, this.pdf.setLineWidth(ht));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ht) {
      ["bevel", "round", "miter"].indexOf(ht) !== -1 && (this.ctx.lineJoin = ht, this.pdf.setLineJoin(ht));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ht) {
      isNaN(ht) || (this.ctx.miterLimit = ht, this.pdf.setMiterLimit(ht));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ht) {
      this.ctx.textBaseline = ht;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ht) {
      ["right", "end", "center", "left", "start"].indexOf(ht) !== -1 && (this.ctx.textAlign = ht);
    } });
    var Yt = null;
    function Kt(ht, $) {
      if (Yt === null) {
        var nt = function(X) {
          var st = [];
          return Object.keys(X).forEach(function(vt) {
            X[vt].forEach(function(St) {
              var ft = null;
              switch (St) {
                case "bold":
                  ft = { family: vt, weight: "bold" };
                  break;
                case "italic":
                  ft = { family: vt, style: "italic" };
                  break;
                case "bolditalic":
                  ft = { family: vt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  ft = { family: vt };
              }
              ft !== null && (ft.ref = { name: vt, style: St }, st.push(ft));
            });
          }), st;
        }(ht.getFontList());
        Yt = function(X) {
          for (var st = {}, vt = 0; vt < X.length; ++vt) {
            var St = yf(X[vt]), ft = St.family, Et = St.stretch, zt = St.style, Tt = St.weight;
            st[ft] = st[ft] || {}, st[ft][Et] = st[ft][Et] || {}, st[ft][Et][zt] = st[ft][Et][zt] || {}, st[ft][Et][zt][Tt] = St;
          }
          return st;
        }(nt.concat($));
      }
      return Yt;
    }
    var T = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return T;
    }, set: function(ht) {
      Yt = null, T = ht;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ht) {
      var $;
      if (this.ctx.font = ht, ($ = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ht)) !== null) {
        var nt = $[1], X = ($[2], $[3]), st = $[4], vt = ($[5], $[6]), St = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(st)[2];
        st = Math.floor(St === "px" ? parseFloat(st) * this.pdf.internal.scaleFactor : St === "em" ? parseFloat(st) * this.pdf.getFontSize() : parseFloat(st) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(st);
        var ft = function(ae) {
          var xe, Xt, Nt = [], Ot = ae.trim();
          if (Ot === "") return Lh;
          if (Ot in Qp) return [Qp[Ot]];
          for (; Ot !== ""; ) {
            switch (Xt = null, xe = (Ot = eg(Ot)).charAt(0)) {
              case '"':
              case "'":
                Xt = Fv(Ot.substring(1), xe);
                break;
              default:
                Xt = Mv(Ot);
            }
            if (Xt === null || (Nt.push(Xt[0]), (Ot = eg(Xt[1])) !== "" && Ot.charAt(0) !== ",")) return Lh;
            Ot = Ot.replace(/^,/, "");
          }
          return Nt;
        }(vt);
        if (this.fontFaces) {
          var Et = Tv(Kt(this.pdf, this.fontFaces), ft.map(function(ae) {
            return { family: ae, stretch: "normal", weight: X, style: nt };
          }));
          this.pdf.setFont(Et.ref.name, Et.ref.style);
        } else {
          var zt = "";
          (X === "bold" || parseInt(X, 10) >= 700 || nt === "bold") && (zt = "bold"), nt === "italic" && (zt += "italic"), zt.length === 0 && (zt = "normal");
          for (var Tt = "", $t = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, te = 0; te < ft.length; te++) {
            if (this.pdf.internal.getFont(ft[te], zt, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Tt = ft[te];
              break;
            }
            if (zt === "bolditalic" && this.pdf.internal.getFont(ft[te], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Tt = ft[te], zt = "bold";
            else if (this.pdf.internal.getFont(ft[te], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Tt = ft[te], zt = "normal";
              break;
            }
          }
          if (Tt === "") {
            for (var oe = 0; oe < ft.length; oe++) if ($t[ft[oe]]) {
              Tt = $t[ft[oe]];
              break;
            }
          }
          Tt = Tt === "" ? "Times" : Tt, this.pdf.setFont(Tt, zt);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ht) {
      this.ctx.globalCompositeOperation = ht;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ht) {
      this.ctx.globalAlpha = ht;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ht) {
      this.ctx.lineDashOffset = ht, it.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ht) {
      this.ctx.lineDash = ht, it.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ht) {
      this.ctx.ignoreClearRect = !!ht;
    } });
  };
  d.prototype.setLineDash = function(N) {
    this.lineDash = N;
  }, d.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, d.prototype.fill = function() {
    C.call(this, "fill", !1);
  }, d.prototype.stroke = function() {
    C.call(this, "stroke", !1);
  }, d.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, d.prototype.moveTo = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var G = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "mt", x: G.x, y: G.y }), this.ctx.lastPoint = new o(N, z);
  }, d.prototype.closePath = function() {
    var N = new o(0, 0), z = 0;
    for (z = this.path.length - 1; z !== -1; z--) if (this.path[z].type === "begin" && en(this.path[z + 1]) === "object" && typeof this.path[z + 1].x == "number") {
      N = new o(this.path[z + 1].x, this.path[z + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new o(N.x, N.y);
  }, d.prototype.lineTo = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var G = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "lt", x: G.x, y: G.y }), this.ctx.lastPoint = new o(G.x, G.y);
  }, d.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), C.call(this, null, !0);
  }, d.prototype.quadraticCurveTo = function(N, z, G, Y) {
    if (isNaN(G) || isNaN(Y) || isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ot = this.ctx.transform.applyToPoint(new o(G, Y)), xt = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "qct", x1: xt.x, y1: xt.y, x: ot.x, y: ot.y }), this.ctx.lastPoint = new o(ot.x, ot.y);
  }, d.prototype.bezierCurveTo = function(N, z, G, Y, ot, xt) {
    if (isNaN(ot) || isNaN(xt) || isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var gt = this.ctx.transform.applyToPoint(new o(ot, xt)), wt = this.ctx.transform.applyToPoint(new o(N, z)), qt = this.ctx.transform.applyToPoint(new o(G, Y));
    this.path.push({ type: "bct", x1: wt.x, y1: wt.y, x2: qt.x, y2: qt.y, x: gt.x, y: gt.y }), this.ctx.lastPoint = new o(gt.x, gt.y);
  }, d.prototype.arc = function(N, z, G, Y, ot, xt) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y) || isNaN(ot)) throw an.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (xt = !!xt, !this.ctx.transform.isIdentity) {
      var gt = this.ctx.transform.applyToPoint(new o(N, z));
      N = gt.x, z = gt.y;
      var wt = this.ctx.transform.applyToPoint(new o(0, G)), qt = this.ctx.transform.applyToPoint(new o(0, 0));
      G = Math.sqrt(Math.pow(wt.x - qt.x, 2) + Math.pow(wt.y - qt.y, 2));
    }
    Math.abs(ot - Y) >= 2 * Math.PI && (Y = 0, ot = 2 * Math.PI), this.path.push({ type: "arc", x: N, y: z, radius: G, startAngle: Y, endAngle: ot, counterclockwise: xt });
  }, d.prototype.arcTo = function(N, z, G, Y, ot) {
    throw new Error("arcTo not implemented.");
  }, d.prototype.rect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(N, z), this.lineTo(N + G, z), this.lineTo(N + G, z + Y), this.lineTo(N, z + Y), this.lineTo(N, z), this.lineTo(N + G, z), this.lineTo(N, z);
  }, d.prototype.fillRect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!f.call(this)) {
      var ot = {};
      this.lineCap !== "butt" && (ot.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ot.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(N, z, G, Y), this.fill(), ot.hasOwnProperty("lineCap") && (this.lineCap = ot.lineCap), ot.hasOwnProperty("lineJoin") && (this.lineJoin = ot.lineJoin);
    }
  }, d.prototype.strokeRect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    g.call(this) || (this.beginPath(), this.rect(N, z, G, Y), this.stroke());
  }, d.prototype.clearRect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(N, z, G, Y));
  }, d.prototype.save = function(N) {
    N = typeof N != "boolean" || N;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(z), N) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Y = new u(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Y;
    }
  }, d.prototype.restore = function(N) {
    N = typeof N != "boolean" || N;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(z), N && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, d.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var p = function(N) {
    var z, G, Y, ot;
    if (N.isCanvasGradient === !0 && (N = N.getColor()), !N) return { r: 0, g: 0, b: 0, a: 0, style: N };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(N)) z = 0, G = 0, Y = 0, ot = 0;
    else {
      var xt = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(N);
      if (xt !== null) z = parseInt(xt[1]), G = parseInt(xt[2]), Y = parseInt(xt[3]), ot = 1;
      else if ((xt = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(N)) !== null) z = parseInt(xt[1]), G = parseInt(xt[2]), Y = parseInt(xt[3]), ot = parseFloat(xt[4]);
      else {
        if (ot = 1, typeof N == "string" && N.charAt(0) !== "#") {
          var gt = new P1(N);
          N = gt.ok ? gt.toHex() : "#000000";
        }
        N.length === 4 ? (z = N.substring(1, 2), z += z, G = N.substring(2, 3), G += G, Y = N.substring(3, 4), Y += Y) : (z = N.substring(1, 3), G = N.substring(3, 5), Y = N.substring(5, 7)), z = parseInt(z, 16), G = parseInt(G, 16), Y = parseInt(Y, 16);
      }
    }
    return { r: z, g: G, b: Y, a: ot, style: N };
  }, f = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, g = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  d.prototype.fillText = function(N, z, G, Y) {
    if (isNaN(z) || isNaN(G) || typeof N != "string") throw an.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Y = isNaN(Y) ? void 0 : Y, !f.call(this)) {
      var ot = tt(this.ctx.transform.rotation), xt = this.ctx.transform.scaleX;
      A.call(this, { text: N, x: z, y: G, scale: xt, angle: ot, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.strokeText = function(N, z, G, Y) {
    if (isNaN(z) || isNaN(G) || typeof N != "string") throw an.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!g.call(this)) {
      Y = isNaN(Y) ? void 0 : Y;
      var ot = tt(this.ctx.transform.rotation), xt = this.ctx.transform.scaleX;
      A.call(this, { text: N, x: z, y: G, scale: xt, renderingMode: "stroke", angle: ot, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.measureText = function(N) {
    if (typeof N != "string") throw an.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var z = this.pdf, G = this.pdf.internal.scaleFactor, Y = z.internal.getFontSize(), ot = z.getStringUnitWidth(N) * Y / z.internal.scaleFactor, xt = function(gt) {
      var wt = (gt = gt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return wt;
      } }), this;
    };
    return new xt({ width: ot *= Math.round(96 * G / 72 * 1e4) / 1e4 });
  }, d.prototype.scale = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var G = new l(N, 0, 0, z, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, d.prototype.rotate = function(N) {
    if (isNaN(N)) throw an.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var z = new l(Math.cos(N), Math.sin(N), -Math.sin(N), Math.cos(N), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(z);
  }, d.prototype.translate = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var G = new l(1, 0, 0, 1, N, z);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, d.prototype.transform = function(N, z, G, Y, ot, xt) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y) || isNaN(ot) || isNaN(xt)) throw an.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var gt = new l(N, z, G, Y, ot, xt);
    this.ctx.transform = this.ctx.transform.multiply(gt);
  }, d.prototype.setTransform = function(N, z, G, Y, ot, xt) {
    N = isNaN(N) ? 1 : N, z = isNaN(z) ? 0 : z, G = isNaN(G) ? 0 : G, Y = isNaN(Y) ? 1 : Y, ot = isNaN(ot) ? 0 : ot, xt = isNaN(xt) ? 0 : xt, this.ctx.transform = new l(N, z, G, Y, ot, xt);
  };
  var b = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  d.prototype.drawImage = function(N, z, G, Y, ot, xt, gt, wt, qt) {
    var Rt = this.pdf.getImageProperties(N), Yt = 1, Kt = 1, T = 1, ht = 1;
    Y !== void 0 && wt !== void 0 && (T = wt / Y, ht = qt / ot, Yt = Rt.width / Y * wt / Y, Kt = Rt.height / ot * qt / ot), xt === void 0 && (xt = z, gt = G, z = 0, G = 0), Y !== void 0 && wt === void 0 && (wt = Y, qt = ot), Y === void 0 && wt === void 0 && (wt = Rt.width, qt = Rt.height);
    for (var $, nt = this.ctx.transform.decompose(), X = tt(nt.rotate.shx), st = new l(), vt = (st = (st = (st = st.multiply(nt.translate)).multiply(nt.skew)).multiply(nt.scale)).applyToRectangle(new a(xt - z * T, gt - G * ht, Y * Yt, ot * Kt)), St = x.call(this, vt), ft = [], Et = 0; Et < St.length; Et += 1) ft.indexOf(St[Et]) === -1 && ft.push(St[Et]);
    if (k(ft), this.autoPaging) for (var zt = ft[0], Tt = ft[ft.length - 1], $t = zt; $t < Tt + 1; $t++) {
      this.pdf.setPage($t);
      var te = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], oe = $t === 1 ? this.posY + this.margin[0] : this.margin[0], ae = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], xe = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Xt = $t === 1 ? 0 : ae + ($t - 2) * xe;
      if (this.ctx.clip_path.length !== 0) {
        var Nt = this.path;
        $ = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v($, this.posX + this.margin[3], -Xt + oe + this.ctx.prevPageLastElemOffset), I.call(this, "fill", !0), this.path = Nt;
      }
      var Ot = JSON.parse(JSON.stringify(vt));
      Ot = v([Ot], this.posX + this.margin[3], -Xt + oe + this.ctx.prevPageLastElemOffset)[0];
      var ie = ($t > zt || $t < Tt) && b.call(this);
      ie && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], te, xe, null).clip().discardPath()), this.pdf.addImage(N, "JPEG", Ot.x, Ot.y, Ot.w, Ot.h, null, null, X), ie && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(N, "JPEG", vt.x, vt.y, vt.w, vt.h, null, null, X);
  };
  var x = function(N, z, G) {
    var Y = [];
    z = z || this.pdf.internal.pageSize.width, G = G || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ot = this.posY + this.ctx.prevPageLastElemOffset;
    switch (N.type) {
      default:
      case "mt":
      case "lt":
        Y.push(Math.floor((N.y + ot) / G) + 1);
        break;
      case "arc":
        Y.push(Math.floor((N.y + ot - N.radius) / G) + 1), Y.push(Math.floor((N.y + ot + N.radius) / G) + 1);
        break;
      case "qct":
        var xt = H(this.ctx.lastPoint.x, this.ctx.lastPoint.y, N.x1, N.y1, N.x, N.y);
        Y.push(Math.floor((xt.y + ot) / G) + 1), Y.push(Math.floor((xt.y + xt.h + ot) / G) + 1);
        break;
      case "bct":
        var gt = ct(this.ctx.lastPoint.x, this.ctx.lastPoint.y, N.x1, N.y1, N.x2, N.y2, N.x, N.y);
        Y.push(Math.floor((gt.y + ot) / G) + 1), Y.push(Math.floor((gt.y + gt.h + ot) / G) + 1);
        break;
      case "rect":
        Y.push(Math.floor((N.y + ot) / G) + 1), Y.push(Math.floor((N.y + N.h + ot) / G) + 1);
    }
    for (var wt = 0; wt < Y.length; wt += 1) for (; this.pdf.internal.getNumberOfPages() < Y[wt]; ) y.call(this);
    return Y;
  }, y = function() {
    var N = this.fillStyle, z = this.strokeStyle, G = this.font, Y = this.lineCap, ot = this.lineWidth, xt = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = N, this.strokeStyle = z, this.font = G, this.lineCap = Y, this.lineWidth = ot, this.lineJoin = xt;
  }, v = function(N, z, G) {
    for (var Y = 0; Y < N.length; Y++) switch (N[Y].type) {
      case "bct":
        N[Y].x2 += z, N[Y].y2 += G;
      case "qct":
        N[Y].x1 += z, N[Y].y1 += G;
      case "mt":
      case "lt":
      case "arc":
      default:
        N[Y].x += z, N[Y].y += G;
    }
    return N;
  }, k = function(N) {
    return N.sort(function(z, G) {
      return z - G;
    });
  }, C = function(N, z) {
    for (var G, Y, ot = this.fillStyle, xt = this.strokeStyle, gt = this.lineCap, wt = this.lineWidth, qt = Math.abs(wt * this.ctx.transform.scaleX), Rt = this.lineJoin, Yt = JSON.parse(JSON.stringify(this.path)), Kt = JSON.parse(JSON.stringify(this.path)), T = [], ht = 0; ht < Kt.length; ht++) if (Kt[ht].x !== void 0) for (var $ = x.call(this, Kt[ht]), nt = 0; nt < $.length; nt += 1) T.indexOf($[nt]) === -1 && T.push($[nt]);
    for (var X = 0; X < T.length; X++) for (; this.pdf.internal.getNumberOfPages() < T[X]; ) y.call(this);
    if (k(T), this.autoPaging) for (var st = T[0], vt = T[T.length - 1], St = st; St < vt + 1; St++) {
      this.pdf.setPage(St), this.fillStyle = ot, this.strokeStyle = xt, this.lineCap = gt, this.lineWidth = qt, this.lineJoin = Rt;
      var ft = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Et = St === 1 ? this.posY + this.margin[0] : this.margin[0], zt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Tt = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], $t = St === 1 ? 0 : zt + (St - 2) * Tt;
      if (this.ctx.clip_path.length !== 0) {
        var te = this.path;
        G = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(G, this.posX + this.margin[3], -$t + Et + this.ctx.prevPageLastElemOffset), I.call(this, N, !0), this.path = te;
      }
      if (Y = JSON.parse(JSON.stringify(Yt)), this.path = v(Y, this.posX + this.margin[3], -$t + Et + this.ctx.prevPageLastElemOffset), z === !1 || St === 0) {
        var oe = (St > st || St < vt) && b.call(this);
        oe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ft, Tt, null).clip().discardPath()), I.call(this, N, z), oe && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = wt;
    }
    else this.lineWidth = qt, I.call(this, N, z), this.lineWidth = wt;
    this.path = Yt;
  }, I = function(N, z) {
    if ((N !== "stroke" || z || !g.call(this)) && (N === "stroke" || z || !f.call(this))) {
      for (var G, Y, ot = [], xt = this.path, gt = 0; gt < xt.length; gt++) {
        var wt = xt[gt];
        switch (wt.type) {
          case "begin":
            ot.push({ begin: !0 });
            break;
          case "close":
            ot.push({ close: !0 });
            break;
          case "mt":
            ot.push({ start: wt, deltas: [], abs: [] });
            break;
          case "lt":
            var qt = ot.length;
            if (xt[gt - 1] && !isNaN(xt[gt - 1].x) && (G = [wt.x - xt[gt - 1].x, wt.y - xt[gt - 1].y], qt > 0)) {
              for (; qt >= 0; qt--) if (ot[qt - 1].close !== !0 && ot[qt - 1].begin !== !0) {
                ot[qt - 1].deltas.push(G), ot[qt - 1].abs.push(wt);
                break;
              }
            }
            break;
          case "bct":
            G = [wt.x1 - xt[gt - 1].x, wt.y1 - xt[gt - 1].y, wt.x2 - xt[gt - 1].x, wt.y2 - xt[gt - 1].y, wt.x - xt[gt - 1].x, wt.y - xt[gt - 1].y], ot[ot.length - 1].deltas.push(G);
            break;
          case "qct":
            var Rt = xt[gt - 1].x + 2 / 3 * (wt.x1 - xt[gt - 1].x), Yt = xt[gt - 1].y + 2 / 3 * (wt.y1 - xt[gt - 1].y), Kt = wt.x + 2 / 3 * (wt.x1 - wt.x), T = wt.y + 2 / 3 * (wt.y1 - wt.y), ht = wt.x, $ = wt.y;
            G = [Rt - xt[gt - 1].x, Yt - xt[gt - 1].y, Kt - xt[gt - 1].x, T - xt[gt - 1].y, ht - xt[gt - 1].x, $ - xt[gt - 1].y], ot[ot.length - 1].deltas.push(G);
            break;
          case "arc":
            ot.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ot[ot.length - 1].abs) && ot[ot.length - 1].abs.push(wt);
        }
      }
      Y = z ? null : N === "stroke" ? "stroke" : "fill";
      for (var nt = !1, X = 0; X < ot.length; X++) if (ot[X].arc) for (var st = ot[X].abs, vt = 0; vt < st.length; vt++) {
        var St = st[vt];
        St.type === "arc" ? O.call(this, St.x, St.y, St.radius, St.startAngle, St.endAngle, St.counterclockwise, void 0, z, !nt) : F.call(this, St.x, St.y), nt = !0;
      }
      else if (ot[X].close === !0) this.pdf.internal.out("h"), nt = !1;
      else if (ot[X].begin !== !0) {
        var ft = ot[X].start.x, Et = ot[X].start.y;
        _.call(this, ot[X].deltas, ft, Et), nt = !0;
      }
      Y && M.call(this, Y), z && q.call(this);
    }
  }, D = function(N) {
    var z = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, G = z * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return N - G;
      case "top":
        return N + z - G;
      case "hanging":
        return N + z - 2 * G;
      case "middle":
        return N + z / 2 - G;
      case "ideographic":
        return N;
      case "alphabetic":
      default:
        return N;
    }
  }, E = function(N) {
    return N + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  d.prototype.createLinearGradient = function() {
    var N = function() {
    };
    return N.colorStops = [], N.addColorStop = function(z, G) {
      this.colorStops.push([z, G]);
    }, N.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, N.isCanvasGradient = !0, N;
  }, d.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, d.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var O = function(N, z, G, Y, ot, xt, gt, wt, qt) {
    for (var Rt = V.call(this, G, Y, ot, xt), Yt = 0; Yt < Rt.length; Yt++) {
      var Kt = Rt[Yt];
      Yt === 0 && (qt ? P.call(this, Kt.x1 + N, Kt.y1 + z) : F.call(this, Kt.x1 + N, Kt.y1 + z)), J.call(this, N, z, Kt.x2, Kt.y2, Kt.x3, Kt.y3, Kt.x4, Kt.y4);
    }
    wt ? q.call(this) : M.call(this, gt);
  }, M = function(N) {
    switch (N) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, q = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, P = function(N, z) {
    this.pdf.internal.out(e(N) + " " + i(z) + " m");
  }, A = function(N) {
    var z;
    switch (N.align) {
      case "right":
      case "end":
        z = "right";
        break;
      case "center":
        z = "center";
        break;
      case "left":
      case "start":
      default:
        z = "left";
    }
    var G = this.pdf.getTextDimensions(N.text), Y = D.call(this, N.y), ot = E.call(this, Y) - G.h, xt = this.ctx.transform.applyToPoint(new o(N.x, Y)), gt = this.ctx.transform.decompose(), wt = new l();
    wt = (wt = (wt = wt.multiply(gt.translate)).multiply(gt.skew)).multiply(gt.scale);
    for (var qt, Rt, Yt, Kt = this.ctx.transform.applyToRectangle(new a(N.x, Y, G.w, G.h)), T = wt.applyToRectangle(new a(N.x, ot, G.w, G.h)), ht = x.call(this, T), $ = [], nt = 0; nt < ht.length; nt += 1) $.indexOf(ht[nt]) === -1 && $.push(ht[nt]);
    if (k($), this.autoPaging) for (var X = $[0], st = $[$.length - 1], vt = X; vt < st + 1; vt++) {
      this.pdf.setPage(vt);
      var St = vt === 1 ? this.posY + this.margin[0] : this.margin[0], ft = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Et = this.pdf.internal.pageSize.height - this.margin[2], zt = Et - this.margin[0], Tt = this.pdf.internal.pageSize.width - this.margin[1], $t = Tt - this.margin[3], te = vt === 1 ? 0 : ft + (vt - 2) * zt;
      if (this.ctx.clip_path.length !== 0) {
        var oe = this.path;
        qt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(qt, this.posX + this.margin[3], -1 * te + St), I.call(this, "fill", !0), this.path = oe;
      }
      var ae = v([JSON.parse(JSON.stringify(T))], this.posX + this.margin[3], -te + St + this.ctx.prevPageLastElemOffset)[0];
      N.scale >= 0.01 && (Rt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Rt * N.scale), Yt = this.lineWidth, this.lineWidth = Yt * N.scale);
      var xe = this.autoPaging !== "text";
      if (xe || ae.y + ae.h <= Et) {
        if (xe || ae.y >= St && ae.x <= Tt) {
          var Xt = xe ? N.text : this.pdf.splitTextToSize(N.text, N.maxWidth || Tt - ae.x)[0], Nt = v([JSON.parse(JSON.stringify(Kt))], this.posX + this.margin[3], -te + St + this.ctx.prevPageLastElemOffset)[0], Ot = xe && (vt > X || vt < st) && b.call(this);
          Ot && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], $t, zt, null).clip().discardPath()), this.pdf.text(Xt, Nt.x, Nt.y, { angle: N.angle, align: z, renderingMode: N.renderingMode }), Ot && this.pdf.restoreGraphicsState();
        }
      } else ae.y < Et && (this.ctx.prevPageLastElemOffset += Et - ae.y);
      N.scale >= 0.01 && (this.pdf.setFontSize(Rt), this.lineWidth = Yt);
    }
    else N.scale >= 0.01 && (Rt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Rt * N.scale), Yt = this.lineWidth, this.lineWidth = Yt * N.scale), this.pdf.text(N.text, xt.x + this.posX, xt.y + this.posY, { angle: N.angle, align: z, renderingMode: N.renderingMode, maxWidth: N.maxWidth }), N.scale >= 0.01 && (this.pdf.setFontSize(Rt), this.lineWidth = Yt);
  }, F = function(N, z, G, Y) {
    G = G || 0, Y = Y || 0, this.pdf.internal.out(e(N + G) + " " + i(z + Y) + " l");
  }, _ = function(N, z, G) {
    return this.pdf.lines(N, z, G, null, null);
  }, J = function(N, z, G, Y, ot, xt, gt, wt) {
    this.pdf.internal.out([t(r(G + N)), t(s(Y + z)), t(r(ot + N)), t(s(xt + z)), t(r(gt + N)), t(s(wt + z)), "c"].join(" "));
  }, V = function(N, z, G, Y) {
    for (var ot = 2 * Math.PI, xt = Math.PI / 2; z > G; ) z -= ot;
    var gt = Math.abs(G - z);
    gt < ot && Y && (gt = ot - gt);
    for (var wt = [], qt = Y ? -1 : 1, Rt = z; gt > 1e-5; ) {
      var Yt = Rt + qt * Math.min(gt, xt);
      wt.push(R.call(this, N, Rt, Yt)), gt -= Math.abs(Yt - Rt), Rt = Yt;
    }
    return wt;
  }, R = function(N, z, G) {
    var Y = (G - z) / 2, ot = N * Math.cos(Y), xt = N * Math.sin(Y), gt = ot, wt = -xt, qt = gt * gt + wt * wt, Rt = qt + gt * ot + wt * xt, Yt = 4 / 3 * (Math.sqrt(2 * qt * Rt) - Rt) / (gt * xt - wt * ot), Kt = gt - Yt * wt, T = wt + Yt * gt, ht = Kt, $ = -T, nt = Y + z, X = Math.cos(nt), st = Math.sin(nt);
    return { x1: N * Math.cos(z), y1: N * Math.sin(z), x2: Kt * X - T * st, y2: Kt * st + T * X, x3: ht * X - $ * st, y3: ht * st + $ * X, x4: N * Math.cos(G), y4: N * Math.sin(G) };
  }, tt = function(N) {
    return 180 * N / Math.PI;
  }, H = function(N, z, G, Y, ot, xt) {
    var gt = N + 0.5 * (G - N), wt = z + 0.5 * (Y - z), qt = ot + 0.5 * (G - ot), Rt = xt + 0.5 * (Y - xt), Yt = Math.min(N, ot, gt, qt), Kt = Math.max(N, ot, gt, qt), T = Math.min(z, xt, wt, Rt), ht = Math.max(z, xt, wt, Rt);
    return new a(Yt, T, Kt - Yt, ht - T);
  }, ct = function(N, z, G, Y, ot, xt, gt, wt) {
    var qt, Rt, Yt, Kt, T, ht, $, nt, X, st, vt, St, ft, Et, zt = G - N, Tt = Y - z, $t = ot - G, te = xt - Y, oe = gt - ot, ae = wt - xt;
    for (Rt = 0; Rt < 41; Rt++) X = ($ = (Yt = N + (qt = Rt / 40) * zt) + qt * ((T = G + qt * $t) - Yt)) + qt * (T + qt * (ot + qt * oe - T) - $), st = (nt = (Kt = z + qt * Tt) + qt * ((ht = Y + qt * te) - Kt)) + qt * (ht + qt * (xt + qt * ae - ht) - nt), Rt == 0 ? (vt = X, St = st, ft = X, Et = st) : (vt = Math.min(vt, X), St = Math.min(St, st), ft = Math.max(ft, X), Et = Math.max(Et, st));
    return new a(Math.round(vt), Math.round(St), Math.round(ft - vt), Math.round(Et - St));
  }, it = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var N, z, G = (N = this.ctx.lineDash, z = this.ctx.lineDashOffset, JSON.stringify({ lineDash: N, lineDashOffset: z }));
      this.prevLineDash !== G && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = G);
    }
  };
})(Se.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(s) {
    var o, a, l, h, u, d, p, f, g, b;
    for (a = [], l = 0, h = (s += o = "\0\0\0\0".slice(s.length % 4 || 4)).length; h > l; l += 4) (u = (s.charCodeAt(l) << 24) + (s.charCodeAt(l + 1) << 16) + (s.charCodeAt(l + 2) << 8) + s.charCodeAt(l + 3)) !== 0 ? (d = (u = ((u = ((u = ((u = (u - (b = u % 85)) / 85) - (g = u % 85)) / 85) - (f = u % 85)) / 85) - (p = u % 85)) / 85) % 85, a.push(d + 33, p + 33, f + 33, g + 33, b + 33)) : a.push(122);
    return function(x, y) {
      for (var v = y; v > 0; v--) x.pop();
    }(a, o.length), String.fromCharCode.apply(String, a) + "~>";
  }, e = function(s) {
    var o, a, l, h, u, d = String, p = "length", f = 255, g = "charCodeAt", b = "slice", x = "replace";
    for (s[b](-2), s = s[b](0, -2)[x](/\s/g, "")[x]("z", "!!!!!"), l = [], h = 0, u = (s += o = "uuuuu"[b](s[p] % 5 || 5))[p]; u > h; h += 5) a = 52200625 * (s[g](h) - 33) + 614125 * (s[g](h + 1) - 33) + 7225 * (s[g](h + 2) - 33) + 85 * (s[g](h + 3) - 33) + (s[g](h + 4) - 33), l.push(f & a >> 24, f & a >> 16, f & a >> 8, f & a);
    return function(y, v) {
      for (var k = v; k > 0; k--) y.pop();
    }(l, o[p]), d.fromCharCode.apply(d, l);
  }, i = function(s) {
    var o = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), o.test(s) === !1) return "";
    for (var a = "", l = 0; l < s.length; l += 2) a += String.fromCharCode("0x" + (s[l] + s[l + 1]));
    return a;
  }, r = function(s) {
    for (var o = new Uint8Array(s.length), a = s.length; a--; ) o[a] = s.charCodeAt(a);
    return s = (o = hf(o)).reduce(function(l, h) {
      return l + String.fromCharCode(h);
    }, "");
  };
  n.processDataByFilters = function(s, o) {
    var a = 0, l = s || "", h = [];
    for (typeof (o = o || []) == "string" && (o = [o]), a = 0; a < o.length; a += 1) switch (o[a]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        l = e(l), h.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        l = t(l), h.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        l = i(l), h.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        l = l.split("").map(function(u) {
          return ("0" + u.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", h.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        l = r(l), h.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + o[a] + '" is not implemented');
    }
    return { data: l, reverseChain: h.reverse().join(" ") };
  };
}(Se.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.loadFile = function(t, e, i) {
    return function(r, s, o) {
      s = s !== !1, o = typeof o == "function" ? o : function() {
      };
      var a = void 0;
      try {
        a = function(l, h, u) {
          var d = new XMLHttpRequest(), p = 0, f = function(g) {
            var b = g.length, x = [], y = String.fromCharCode;
            for (p = 0; p < b; p += 1) x.push(y(255 & g.charCodeAt(p)));
            return x.join("");
          };
          if (d.open("GET", l, !h), d.overrideMimeType("text/plain; charset=x-user-defined"), h === !1 && (d.onload = function() {
            d.status === 200 ? u(f(this.responseText)) : u(void 0);
          }), d.send(null), h && d.status === 200) return f(d.responseText);
        }(r, s, o);
      } catch {
      }
      return a;
    }(t, e, i);
  }, n.loadImageFile = n.loadFile;
}(Se.API), function(n) {
  function t() {
    return (Ae.html2canvas ? Promise.resolve(Ae.html2canvas) : import("./html2canvas.esm-d2sM-0Wm.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load html2canvas: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  function e() {
    return (Ae.DOMPurify ? Promise.resolve(Ae.DOMPurify) : import("./purify.es-DD-6ZaCo.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load dompurify: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  var i = function(o) {
    var a = en(o);
    return a === "undefined" ? "undefined" : a === "string" || o instanceof String ? "string" : a === "number" || o instanceof Number ? "number" : a === "function" || o instanceof Function ? "function" : o && o.constructor === Array ? "array" : o && o.nodeType === 1 ? "element" : a === "object" ? "object" : "unknown";
  }, r = function(o, a) {
    var l = document.createElement(o);
    for (var h in a.className && (l.className = a.className), a.innerHTML && a.dompurify && (l.innerHTML = a.dompurify.sanitize(a.innerHTML)), a.style) l.style[h] = a.style[h];
    return l;
  }, s = function o(a) {
    var l = Object.assign(o.convert(Promise.resolve()), JSON.parse(JSON.stringify(o.template))), h = o.convert(Promise.resolve(), l);
    return h = (h = h.setProgress(1, o, 1, [o])).set(a);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(o, a) {
    return o.__proto__ = a || s.prototype, o;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(o, a) {
    return this.then(function() {
      switch (a = a || function(l) {
        switch (i(l)) {
          case "string":
            return "string";
          case "element":
            return l.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(o)) {
        case "string":
          return this.then(e).then(function(l) {
            return this.set({ src: r("div", { innerHTML: o, dompurify: l }) });
          });
        case "element":
          return this.set({ src: o });
        case "canvas":
          return this.set({ canvas: o });
        case "img":
          return this.set({ img: o });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(o) {
    switch (o) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var o = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, a = function l(h, u) {
        for (var d = h.nodeType === 3 ? document.createTextNode(h.nodeValue) : h.cloneNode(!1), p = h.firstChild; p; p = p.nextSibling) u !== !0 && p.nodeType === 1 && p.nodeName === "SCRIPT" || d.appendChild(l(p, u));
        return h.nodeType === 1 && (h.nodeName === "CANVAS" ? (d.width = h.width, d.height = h.height, d.getContext("2d").drawImage(h, 0, 0)) : h.nodeName !== "TEXTAREA" && h.nodeName !== "SELECT" || (d.value = h.value), d.addEventListener("load", function() {
          d.scrollTop = h.scrollTop, d.scrollLeft = h.scrollLeft;
        }, !0)), d;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      a.tagName === "BODY" && (o.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = r("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = r("div", { className: "html2pdf__container", style: o }), this.prop.container.appendChild(a), this.prop.container.firstChild.appendChild(r("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = Object.assign({}, this.opt.html2canvas);
      return delete l.onrendered, a(this.prop.container, l);
    }).then(function(a) {
      (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = this.opt.jsPDF, h = this.opt.fontFaces, u = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, d = Object.assign({ async: !0, allowTaint: !0, scale: u, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete d.onrendered, l.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, l.context2d.posX = this.opt.x, l.context2d.posY = this.opt.y, l.context2d.margin = this.opt.margin, l.context2d.fontFaces = h, h) for (var p = 0; p < h.length; ++p) {
        var f = h[p], g = f.src.find(function(b) {
          return b.format === "truetype";
        });
        g && l.addFont(g.url, f.ref.name, f.ref.style);
      }
      return d.windowHeight = d.windowHeight || 0, d.windowHeight = d.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : d.windowHeight, l.context2d.save(!0), a(this.prop.container, d);
    }).then(function(a) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var o = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = o;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(o, a, l) {
    return (l = l || "pdf").toLowerCase() === "img" || l.toLowerCase() === "image" ? this.outputImg(o, a) : this.outputPdf(o, a);
  }, s.prototype.outputPdf = function(o, a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(o, a);
    });
  }, s.prototype.outputImg = function(o) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (o) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + o + '" is not supported.';
      }
    });
  }, s.prototype.save = function(o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(o ? { filename: o } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(o) {
    if (i(o) !== "object") return this;
    var a = Object.keys(o || {}).map(function(l) {
      if (l in s.template.prop) return function() {
        this.prop[l] = o[l];
      };
      switch (l) {
        case "margin":
          return this.setMargin.bind(this, o.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = o.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, o.pageSize);
        default:
          return function() {
            this.opt[l] = o[l];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(a);
    });
  }, s.prototype.get = function(o, a) {
    return this.then(function() {
      var l = o in s.template.prop ? this.prop[o] : this.opt[o];
      return a ? a(l) : l;
    });
  }, s.prototype.setMargin = function(o) {
    return this.then(function() {
      switch (i(o)) {
        case "number":
          o = [o, o, o, o];
        case "array":
          if (o.length === 2 && (o = [o[0], o[1], o[0], o[1]]), o.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = o;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(o) {
    function a(l, h) {
      return Math.floor(l * h / 72 * 96);
    }
    return this.then(function() {
      (o = o || Se.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (o.inner = { width: o.width - this.opt.margin[1] - this.opt.margin[3], height: o.height - this.opt.margin[0] - this.opt.margin[2] }, o.inner.px = { width: a(o.inner.width, o.k), height: a(o.inner.height, o.k) }, o.inner.ratio = o.inner.height / o.inner.width), this.prop.pageSize = o;
    });
  }, s.prototype.setProgress = function(o, a, l, h) {
    return o != null && (this.progress.val = o), a != null && (this.progress.state = a), l != null && (this.progress.n = l), h != null && (this.progress.stack = h), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(o, a, l, h) {
    return this.setProgress(o ? this.progress.val + o : null, a || null, l ? this.progress.n + l : null, h ? this.progress.stack.concat(h) : null);
  }, s.prototype.then = function(o, a) {
    var l = this;
    return this.thenCore(o, a, function(h, u) {
      return l.updateProgress(null, null, 1, [h]), Promise.prototype.then.call(this, function(d) {
        return l.updateProgress(null, h), d;
      }).then(h, u).then(function(d) {
        return l.updateProgress(1), d;
      });
    });
  }, s.prototype.thenCore = function(o, a, l) {
    l = l || Promise.prototype.then, o && (o = o.bind(this)), a && (a = a.bind(this));
    var h = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), u = l.call(h, o, a);
    return s.convert(u, this.__proto__);
  }, s.prototype.thenExternal = function(o, a) {
    return Promise.prototype.then.call(this, o, a);
  }, s.prototype.thenList = function(o) {
    var a = this;
    return o.forEach(function(l) {
      a = a.thenCore(l);
    }), a;
  }, s.prototype.catch = function(o) {
    o && (o = o.bind(this));
    var a = Promise.prototype.catch.call(this, o);
    return s.convert(a, this);
  }, s.prototype.catchExternal = function(o) {
    return Promise.prototype.catch.call(this, o);
  }, s.prototype.error = function(o) {
    return this.then(function() {
      throw new Error(o);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Se.getPageSize = function(o, a, l) {
    if (en(o) === "object") {
      var h = o;
      o = h.orientation, a = h.unit || a, l = h.format || l;
    }
    a = a || "mm", l = l || "a4", o = ("" + (o || "P")).toLowerCase();
    var u, d = ("" + l).toLowerCase(), p = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (a) {
      case "pt":
        u = 1;
        break;
      case "mm":
        u = 72 / 25.4;
        break;
      case "cm":
        u = 72 / 2.54;
        break;
      case "in":
        u = 72;
        break;
      case "px":
        u = 0.75;
        break;
      case "pc":
      case "em":
        u = 12;
        break;
      case "ex":
        u = 6;
        break;
      default:
        throw "Invalid unit: " + a;
    }
    var f, g = 0, b = 0;
    if (p.hasOwnProperty(d)) g = p[d][1] / u, b = p[d][0] / u;
    else try {
      g = l[1], b = l[0];
    } catch {
      throw new Error("Invalid format: " + l);
    }
    if (o === "p" || o === "portrait") o = "p", b > g && (f = b, b = g, g = f);
    else {
      if (o !== "l" && o !== "landscape") throw "Invalid orientation: " + o;
      o = "l", g > b && (f = b, b = g, g = f);
    }
    return { width: b, height: g, unit: a, k: u, orientation: o };
  }, n.html = function(o, a) {
    (a = a || {}).callback = a.callback || function() {
    }, a.html2canvas = a.html2canvas || {}, a.html2canvas.canvas = a.html2canvas.canvas || this.canvas, a.jsPDF = a.jsPDF || this, a.fontFaces = a.fontFaces ? a.fontFaces.map(yf) : null;
    var l = new s(a);
    return a.worker ? l : l.from(o).doCallback();
  };
}(Se.API), Se.API.addJS = function(n) {
  return ig = n, this.internal.events.subscribe("postPutResources", function() {
    Pu = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Pu + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), ng = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + ig + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Pu !== void 0 && ng !== void 0 && this.internal.out("/Names <</JavaScript " + Pu + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t;
  n.events.push(["postPutResources", function() {
    var e = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var r = e.outline.render().split(/\r\n/), s = 0; s < r.length; s++) {
      var o = r[s], a = i.exec(o);
      if (a != null) {
        var l = a[1];
        e.internal.newObjectDeferredBegin(l, !1);
      }
      e.internal.write(o);
    }
    if (this.outline.createNamedDestinations) {
      var h = this.internal.pages.length, u = [];
      for (s = 0; s < h; s++) {
        var d = e.internal.newObject();
        u.push(d);
        var p = e.internal.getPageInfo(s + 1);
        e.internal.write("<< /D[" + p.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f = e.internal.newObject();
      for (e.internal.write("<< /Names [ "), s = 0; s < u.length; s++) e.internal.write("(page_" + (s + 1) + ")" + u[s] + " 0 R");
      e.internal.write(" ] >>", "endobj"), t = e.internal.newObject(), e.internal.write("<< /Dests " + f + " 0 R"), e.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + t + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var e = this;
    e.outline = { createNamedDestinations: !1, root: { children: [] } }, e.outline.add = function(i, r, s) {
      var o = { title: r, options: s, children: [] };
      return i == null && (i = this.root), i.children.push(o), o;
    }, e.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = e, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, e.outline.genIds_r = function(i) {
      i.id = e.internal.newObjectDeferred();
      for (var r = 0; r < i.children.length; r++) this.genIds_r(i.children[r]);
    }, e.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, e.outline.renderItems = function(i) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < i.children.length; s++) {
        var o = i.children[s];
        this.objStart(o), this.line("/Title " + this.makeString(o.title)), this.line("/Parent " + this.makeRef(i)), s > 0 && this.line("/Prev " + this.makeRef(i.children[s - 1])), s < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[s + 1])), o.children.length > 0 && (this.line("/First " + this.makeRef(o.children[0])), this.line("/Last " + this.makeRef(o.children[o.children.length - 1])));
        var a = this.count = this.count_r({ count: 0 }, o);
        if (a > 0 && this.line("/Count " + a), o.options && o.options.pageNumber) {
          var l = e.internal.getPageInfo(o.options.pageNumber);
          this.line("/Dest [" + l.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var h = 0; h < i.children.length; h++) this.renderItems(i.children[h]);
    }, e.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, e.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, e.outline.makeString = function(i) {
      return "(" + e.internal.pdfEscape(i) + ")";
    }, e.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, e.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, e.outline.count_r = function(i, r) {
      for (var s = 0; s < r.children.length; s++) i.count++, this.count_r(i, r.children[s]);
      return i.count;
    };
  }]);
}(Se.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(e, i, r, s, o, a) {
    var l, h = this.decode.DCT_DECODE, u = null;
    if (typeof e == "string" || this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) {
      switch (e = o || e, e = this.__addimage__.isArrayBuffer(e) ? new Uint8Array(e) : e, (l = function(d) {
        for (var p, f = 256 * d.charCodeAt(4) + d.charCodeAt(5), g = d.length, b = { width: 0, height: 0, numcomponents: 1 }, x = 4; x < g; x += 2) {
          if (x += f, t.indexOf(d.charCodeAt(x + 1)) !== -1) {
            p = 256 * d.charCodeAt(x + 5) + d.charCodeAt(x + 6), b = { width: 256 * d.charCodeAt(x + 7) + d.charCodeAt(x + 8), height: p, numcomponents: d.charCodeAt(x + 9) };
            break;
          }
          f = 256 * d.charCodeAt(x + 2) + d.charCodeAt(x + 3);
        }
        return b;
      }(e = this.__addimage__.isArrayBufferView(e) ? this.__addimage__.arrayBufferToBinaryString(e) : e)).numcomponents) {
        case 1:
          a = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          a = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          a = this.color_spaces.DEVICE_RGB;
      }
      u = { data: e, width: l.width, height: l.height, colorSpace: a, bitsPerComponent: 8, filter: h, index: i, alias: r };
    }
    return u;
  };
}(Se.API);
var ia, Lu, rg, sg, og, Dv = function() {
  var n, t, e;
  function i(s) {
    var o, a, l, h, u, d, p, f, g, b, x, y, v, k;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, d = null; ; ) {
      switch (o = this.readUInt32(), g = (function() {
        var C, I;
        for (I = [], C = 0; C < 4; ++C) I.push(String.fromCharCode(this.data[this.pos++]));
        return I;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(o);
          break;
        case "fcTL":
          d && this.animation.frames.push(d), this.pos += 4, d = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, u = this.readUInt16(), h = this.readUInt16() || 100, d.delay = 1e3 * u / h, d.disposeOp = this.data[this.pos++], d.blendOp = this.data[this.pos++], d.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (g === "fdAT" && (this.pos += 4, o -= 4), s = (d != null ? d.data : void 0) || this.imgData, y = 0; 0 <= o ? y < o : y > o; 0 <= o ? ++y : --y) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (l = this.palette.length / 3, this.transparency.indexed = this.read(o), this.transparency.indexed.length > l) throw new Error("More transparent colors than palette size");
              if ((b = l - this.transparency.indexed.length) > 0) for (v = 0; 0 <= b ? v < b : v > b; 0 <= b ? ++v : --v) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(o)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(o);
          }
          break;
        case "tEXt":
          p = (x = this.read(o)).indexOf(0), f = String.fromCharCode.apply(String, x.slice(0, p)), this.text[f] = String.fromCharCode.apply(String, x.slice(p + 1));
          break;
        case "IEND":
          return d && this.animation.frames.push(d), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (k = this.colorType) === 4 || k === 6, a = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += o;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  i.prototype.read = function(s) {
    var o, a;
    for (a = [], o = 0; 0 <= s ? o < s : o > s; 0 <= s ? ++o : --o) a.push(this.data[this.pos++]);
    return a;
  }, i.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.decodePixels = function(s) {
    var o = this.pixelBitlength / 8, a = new Uint8Array(this.width * this.height * o), l = 0, h = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function u(d, p, f, g) {
      var b, x, y, v, k, C, I, D, E, O, M, q, P, A, F, _, J, V, R, tt, H, ct = Math.ceil((h.width - d) / f), it = Math.ceil((h.height - p) / g), N = h.width == ct && h.height == it;
      for (A = o * ct, q = N ? a : new Uint8Array(A * it), C = s.length, P = 0, x = 0; P < it && l < C; ) {
        switch (s[l++]) {
          case 0:
            for (v = J = 0; J < A; v = J += 1) q[x++] = s[l++];
            break;
          case 1:
            for (v = V = 0; V < A; v = V += 1) b = s[l++], k = v < o ? 0 : q[x - o], q[x++] = (b + k) % 256;
            break;
          case 2:
            for (v = R = 0; R < A; v = R += 1) b = s[l++], y = (v - v % o) / o, F = P && q[(P - 1) * A + y * o + v % o], q[x++] = (F + b) % 256;
            break;
          case 3:
            for (v = tt = 0; tt < A; v = tt += 1) b = s[l++], y = (v - v % o) / o, k = v < o ? 0 : q[x - o], F = P && q[(P - 1) * A + y * o + v % o], q[x++] = (b + Math.floor((k + F) / 2)) % 256;
            break;
          case 4:
            for (v = H = 0; H < A; v = H += 1) b = s[l++], y = (v - v % o) / o, k = v < o ? 0 : q[x - o], P === 0 ? F = _ = 0 : (F = q[(P - 1) * A + y * o + v % o], _ = y && q[(P - 1) * A + (y - 1) * o + v % o]), I = k + F - _, D = Math.abs(I - k), O = Math.abs(I - F), M = Math.abs(I - _), E = D <= O && D <= M ? k : O <= M ? F : _, q[x++] = (b + E) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[l - 1]);
        }
        if (!N) {
          var z = ((p + P * g) * h.width + d) * o, G = P * A;
          for (v = 0; v < ct; v += 1) {
            for (var Y = 0; Y < o; Y += 1) a[z++] = q[G++];
            z += (f - 1) * o;
          }
        }
        P++;
      }
    }
    return s = dv(s), h.interlaceMethod == 1 ? (u(0, 0, 8, 8), u(4, 0, 8, 8), u(0, 4, 4, 8), u(2, 0, 4, 4), u(0, 2, 2, 4), u(1, 0, 2, 2), u(0, 1, 1, 2)) : u(0, 0, 1, 1), a;
  }, i.prototype.decodePalette = function() {
    var s, o, a, l, h, u, d, p, f;
    for (a = this.palette, u = this.transparency.indexed || [], h = new Uint8Array((u.length || 0) + a.length), l = 0, s = 0, o = d = 0, p = a.length; d < p; o = d += 3) h[l++] = a[o], h[l++] = a[o + 1], h[l++] = a[o + 2], h[l++] = (f = u[s++]) != null ? f : 255;
    return h;
  }, i.prototype.copyToImageData = function(s, o) {
    var a, l, h, u, d, p, f, g, b, x, y;
    if (l = this.colors, b = null, a = this.hasAlphaChannel, this.palette.length && (b = (y = this._decodedPalette) != null ? y : this._decodedPalette = this.decodePalette(), l = 4, a = !0), g = (h = s.data || s).length, d = b || o, u = p = 0, l === 1) for (; u < g; ) f = b ? 4 * o[u / 4] : p, x = d[f++], h[u++] = x, h[u++] = x, h[u++] = x, h[u++] = a ? d[f++] : 255, p = f;
    else for (; u < g; ) f = b ? 4 * o[u / 4] : p, h[u++] = d[f++], h[u++] = d[f++], h[u++] = d[f++], h[u++] = a ? d[f++] : 255, p = f;
  }, i.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var r = function() {
    if (Object.prototype.toString.call(Ae) === "[object Window]") {
      try {
        t = Ae.document.createElement("canvas"), e = t.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return r(), n = function(s) {
    var o;
    if (r() === !0) return e.width = s.width, e.height = s.height, e.clearRect(0, 0, s.width, s.height), e.putImageData(s, 0, 0), (o = new Image()).src = t.toDataURL(), o;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, i.prototype.decodeFrames = function(s) {
    var o, a, l, h, u, d, p, f;
    if (this.animation) {
      for (f = [], a = u = 0, d = (p = this.animation.frames).length; u < d; a = ++u) o = p[a], l = s.createImageData(o.width, o.height), h = this.decodePixels(new Uint8Array(o.data)), this.copyToImageData(l, h), o.imageData = l, f.push(o.image = n(l));
      return f;
    }
  }, i.prototype.renderFrame = function(s, o) {
    var a, l, h;
    return a = (l = this.animation.frames)[o], h = l[o - 1], o === 0 && s.clearRect(0, 0, this.width, this.height), (h != null ? h.disposeOp : void 0) === 1 ? s.clearRect(h.xOffset, h.yOffset, h.width, h.height) : (h != null ? h.disposeOp : void 0) === 2 && s.putImageData(h.imageData, h.xOffset, h.yOffset), a.blendOp === 0 && s.clearRect(a.xOffset, a.yOffset, a.width, a.height), s.drawImage(a.image, a.xOffset, a.yOffset);
  }, i.prototype.animate = function(s) {
    var o, a, l, h, u, d, p = this;
    return a = 0, d = this.animation, h = d.numFrames, l = d.frames, u = d.numPlays, (o = function() {
      var f, g;
      if (f = a++ % h, g = l[f], p.renderFrame(s, f), h > 1 && a / h < u) return p.animation._timeout = setTimeout(o, g.delay);
    })();
  }, i.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, i.prototype.render = function(s) {
    var o, a;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, o = s.getContext("2d"), this.animation ? (this.decodeFrames(o), this.animate(o)) : (a = o.createImageData(this.width, this.height), this.copyToImageData(a, this.decodePixels()), o.putImageData(a, 0, 0));
  }, i;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Rv(n) {
  var t = 0;
  if (n[t++] !== 71 || n[t++] !== 73 || n[t++] !== 70 || n[t++] !== 56 || (n[t++] + 1 & 253) != 56 || n[t++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var e = n[t++] | n[t++] << 8, i = n[t++] | n[t++] << 8, r = n[t++], s = r >> 7, o = 1 << (7 & r) + 1;
  n[t++], n[t++];
  var a = null, l = null;
  s && (a = t, l = o, t += 3 * o);
  var h = !0, u = [], d = 0, p = null, f = 0, g = null;
  for (this.width = e, this.height = i; h && t < n.length; ) switch (n[t++]) {
    case 33:
      switch (n[t++]) {
        case 255:
          if (n[t] !== 11 || n[t + 1] == 78 && n[t + 2] == 69 && n[t + 3] == 84 && n[t + 4] == 83 && n[t + 5] == 67 && n[t + 6] == 65 && n[t + 7] == 80 && n[t + 8] == 69 && n[t + 9] == 50 && n[t + 10] == 46 && n[t + 11] == 48 && n[t + 12] == 3 && n[t + 13] == 1 && n[t + 16] == 0) t += 14, g = n[t++] | n[t++] << 8, t++;
          else for (t += 12; ; ) {
            if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
            if (P === 0) break;
            t += P;
          }
          break;
        case 249:
          if (n[t++] !== 4 || n[t + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var b = n[t++];
          d = n[t++] | n[t++] << 8, p = n[t++], !(1 & b) && (p = null), f = b >> 2 & 7, t++;
          break;
        case 254:
          for (; ; ) {
            if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
            if (P === 0) break;
            t += P;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + n[t - 1].toString(16));
      }
      break;
    case 44:
      var x = n[t++] | n[t++] << 8, y = n[t++] | n[t++] << 8, v = n[t++] | n[t++] << 8, k = n[t++] | n[t++] << 8, C = n[t++], I = C >> 6 & 1, D = 1 << (7 & C) + 1, E = a, O = l, M = !1;
      C >> 7 && (M = !0, E = t, O = D, t += 3 * D);
      var q = t;
      for (t++; ; ) {
        var P;
        if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
        if (P === 0) break;
        t += P;
      }
      u.push({ x, y, width: v, height: k, has_local_palette: M, palette_offset: E, palette_size: O, data_offset: q, data_length: t - q, transparent_index: p, interlaced: !!I, delay: d, disposal: f });
      break;
    case 59:
      h = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + n[t - 1].toString(16));
  }
  this.numFrames = function() {
    return u.length;
  }, this.loopCount = function() {
    return g;
  }, this.frameInfo = function(A) {
    if (A < 0 || A >= u.length) throw new Error("Frame index out of range.");
    return u[A];
  }, this.decodeAndBlitFrameBGRA = function(A, F) {
    var _ = this.frameInfo(A), J = _.width * _.height, V = new Uint8Array(J);
    ag(n, _.data_offset, V, J);
    var R = _.palette_offset, tt = _.transparent_index;
    tt === null && (tt = 256);
    var H = _.width, ct = e - H, it = H, N = 4 * (_.y * e + _.x), z = 4 * ((_.y + _.height) * e + _.x), G = N, Y = 4 * ct;
    _.interlaced === !0 && (Y += 4 * e * 7);
    for (var ot = 8, xt = 0, gt = V.length; xt < gt; ++xt) {
      var wt = V[xt];
      if (it === 0 && (it = H, (G += Y) >= z && (Y = 4 * ct + 4 * e * (ot - 1), G = N + (H + ct) * (ot << 1), ot >>= 1)), wt === tt) G += 4;
      else {
        var qt = n[R + 3 * wt], Rt = n[R + 3 * wt + 1], Yt = n[R + 3 * wt + 2];
        F[G++] = Yt, F[G++] = Rt, F[G++] = qt, F[G++] = 255;
      }
      --it;
    }
  }, this.decodeAndBlitFrameRGBA = function(A, F) {
    var _ = this.frameInfo(A), J = _.width * _.height, V = new Uint8Array(J);
    ag(n, _.data_offset, V, J);
    var R = _.palette_offset, tt = _.transparent_index;
    tt === null && (tt = 256);
    var H = _.width, ct = e - H, it = H, N = 4 * (_.y * e + _.x), z = 4 * ((_.y + _.height) * e + _.x), G = N, Y = 4 * ct;
    _.interlaced === !0 && (Y += 4 * e * 7);
    for (var ot = 8, xt = 0, gt = V.length; xt < gt; ++xt) {
      var wt = V[xt];
      if (it === 0 && (it = H, (G += Y) >= z && (Y = 4 * ct + 4 * e * (ot - 1), G = N + (H + ct) * (ot << 1), ot >>= 1)), wt === tt) G += 4;
      else {
        var qt = n[R + 3 * wt], Rt = n[R + 3 * wt + 1], Yt = n[R + 3 * wt + 2];
        F[G++] = qt, F[G++] = Rt, F[G++] = Yt, F[G++] = 255;
      }
      --it;
    }
  };
}
function ag(n, t, e, i) {
  for (var r = n[t++], s = 1 << r, o = s + 1, a = o + 1, l = r + 1, h = (1 << l) - 1, u = 0, d = 0, p = 0, f = n[t++], g = new Int32Array(4096), b = null; ; ) {
    for (; u < 16 && f !== 0; ) d |= n[t++] << u, u += 8, f === 1 ? f = n[t++] : --f;
    if (u < l) break;
    var x = d & h;
    if (d >>= l, u -= l, x !== s) {
      if (x === o) break;
      for (var y = x < a ? x : b, v = 0, k = y; k > s; ) k = g[k] >> 8, ++v;
      var C = k;
      if (p + v + (y !== x ? 1 : 0) > i) return void an.log("Warning, gif stream longer than expected.");
      e[p++] = C;
      var I = p += v;
      for (y !== x && (e[p++] = C), k = y; v--; ) k = g[k], e[--I] = 255 & k, k >>= 8;
      b !== null && a < 4096 && (g[a++] = b << 8 | C, a >= h + 1 && l < 12 && (++l, h = h << 1 | 1)), b = x;
    } else a = o + 1, h = (1 << (l = r + 1)) - 1, b = null;
  }
  return p !== i && an.log("Warning, gif stream shorter than expected."), e;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ih(n) {
  var t, e, i, r, s, o = Math.floor, a = new Array(64), l = new Array(64), h = new Array(64), u = new Array(64), d = new Array(65535), p = new Array(65535), f = new Array(64), g = new Array(64), b = [], x = 0, y = 7, v = new Array(64), k = new Array(64), C = new Array(64), I = new Array(256), D = new Array(2048), E = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], O = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], q = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], A = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], F = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _ = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], J = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function V(N, z) {
    for (var G = 0, Y = 0, ot = new Array(), xt = 1; xt <= 16; xt++) {
      for (var gt = 1; gt <= N[xt]; gt++) ot[z[Y]] = [], ot[z[Y]][0] = G, ot[z[Y]][1] = xt, Y++, G++;
      G *= 2;
    }
    return ot;
  }
  function R(N) {
    for (var z = N[0], G = N[1] - 1; G >= 0; ) z & 1 << G && (x |= 1 << y), G--, --y < 0 && (x == 255 ? (tt(255), tt(0)) : tt(x), y = 7, x = 0);
  }
  function tt(N) {
    b.push(N);
  }
  function H(N) {
    tt(N >> 8 & 255), tt(255 & N);
  }
  function ct(N, z, G, Y, ot) {
    for (var xt, gt = ot[0], wt = ot[240], qt = function(st, vt) {
      var St, ft, Et, zt, Tt, $t, te, oe, ae, xe, Xt = 0;
      for (ae = 0; ae < 8; ++ae) {
        St = st[Xt], ft = st[Xt + 1], Et = st[Xt + 2], zt = st[Xt + 3], Tt = st[Xt + 4], $t = st[Xt + 5], te = st[Xt + 6];
        var Nt = St + (oe = st[Xt + 7]), Ot = St - oe, ie = ft + te, Jt = ft - te, fe = Et + $t, ne = Et - $t, de = zt + Tt, Ue = zt - Tt, Te = Nt + de, Sn = Nt - de, Mn = ie + fe, Ze = ie - fe;
        st[Xt] = Te + Mn, st[Xt + 4] = Te - Mn;
        var Ce = 0.707106781 * (Ze + Sn);
        st[Xt + 2] = Sn + Ce, st[Xt + 6] = Sn - Ce;
        var qe = 0.382683433 * ((Te = Ue + ne) - (Ze = Jt + Ot)), Qi = 0.5411961 * Te + qe, yn = 1.306562965 * Ze + qe, Ri = 0.707106781 * (Mn = ne + Jt), qn = Ot + Ri, we = Ot - Ri;
        st[Xt + 5] = we + Qi, st[Xt + 3] = we - Qi, st[Xt + 1] = qn + yn, st[Xt + 7] = qn - yn, Xt += 8;
      }
      for (Xt = 0, ae = 0; ae < 8; ++ae) {
        St = st[Xt], ft = st[Xt + 8], Et = st[Xt + 16], zt = st[Xt + 24], Tt = st[Xt + 32], $t = st[Xt + 40], te = st[Xt + 48];
        var Ai = St + (oe = st[Xt + 56]), Bi = St - oe, ti = ft + te, bn = ft - te, vn = Et + $t, ci = Et - $t, rs = zt + Tt, tr = zt - Tt, mi = Ai + rs, Ni = Ai - rs, Ci = ti + vn, ji = ti - vn;
        st[Xt] = mi + Ci, st[Xt + 32] = mi - Ci;
        var Pi = 0.707106781 * (ji + Ni);
        st[Xt + 16] = Ni + Pi, st[Xt + 48] = Ni - Pi;
        var qi = 0.382683433 * ((mi = tr + ci) - (ji = bn + Bi)), br = 0.5411961 * mi + qi, Dr = 1.306562965 * ji + qi, er = 0.707106781 * (Ci = ci + bn), Rr = Bi + er, Br = Bi - er;
        st[Xt + 40] = Br + br, st[Xt + 24] = Br - br, st[Xt + 8] = Rr + Dr, st[Xt + 56] = Rr - Dr, Xt++;
      }
      for (ae = 0; ae < 64; ++ae) xe = st[ae] * vt[ae], f[ae] = xe > 0 ? xe + 0.5 | 0 : xe - 0.5 | 0;
      return f;
    }(N, z), Rt = 0; Rt < 64; ++Rt) g[E[Rt]] = qt[Rt];
    var Yt = g[0] - G;
    G = g[0], Yt == 0 ? R(Y[0]) : (R(Y[p[xt = 32767 + Yt]]), R(d[xt]));
    for (var Kt = 63; Kt > 0 && g[Kt] == 0; ) Kt--;
    if (Kt == 0) return R(gt), G;
    for (var T, ht = 1; ht <= Kt; ) {
      for (var $ = ht; g[ht] == 0 && ht <= Kt; ) ++ht;
      var nt = ht - $;
      if (nt >= 16) {
        T = nt >> 4;
        for (var X = 1; X <= T; ++X) R(wt);
        nt &= 15;
      }
      xt = 32767 + g[ht], R(ot[(nt << 4) + p[xt]]), R(d[xt]), ht++;
    }
    return Kt != 63 && R(gt), G;
  }
  function it(N) {
    N = Math.min(Math.max(N, 1), 100), s != N && (function(z) {
      for (var G = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Y = 0; Y < 64; Y++) {
        var ot = o((G[Y] * z + 50) / 100);
        ot = Math.min(Math.max(ot, 1), 255), a[E[Y]] = ot;
      }
      for (var xt = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], gt = 0; gt < 64; gt++) {
        var wt = o((xt[gt] * z + 50) / 100);
        wt = Math.min(Math.max(wt, 1), 255), l[E[gt]] = wt;
      }
      for (var qt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Rt = 0, Yt = 0; Yt < 8; Yt++) for (var Kt = 0; Kt < 8; Kt++) h[Rt] = 1 / (a[E[Rt]] * qt[Yt] * qt[Kt] * 8), u[Rt] = 1 / (l[E[Rt]] * qt[Yt] * qt[Kt] * 8), Rt++;
    }(N < 50 ? Math.floor(5e3 / N) : Math.floor(200 - 2 * N)), s = N);
  }
  this.encode = function(N, z) {
    z && it(z), b = new Array(), x = 0, y = 7, H(65496), H(65504), H(16), tt(74), tt(70), tt(73), tt(70), tt(0), tt(1), tt(1), tt(0), H(1), H(1), tt(0), tt(0), function() {
      H(65499), H(132), tt(0);
      for (var ft = 0; ft < 64; ft++) tt(a[ft]);
      tt(1);
      for (var Et = 0; Et < 64; Et++) tt(l[Et]);
    }(), function(ft, Et) {
      H(65472), H(17), tt(8), H(Et), H(ft), tt(3), tt(1), tt(17), tt(0), tt(2), tt(17), tt(1), tt(3), tt(17), tt(1);
    }(N.width, N.height), function() {
      H(65476), H(418), tt(0);
      for (var ft = 0; ft < 16; ft++) tt(O[ft + 1]);
      for (var Et = 0; Et <= 11; Et++) tt(M[Et]);
      tt(16);
      for (var zt = 0; zt < 16; zt++) tt(q[zt + 1]);
      for (var Tt = 0; Tt <= 161; Tt++) tt(P[Tt]);
      tt(1);
      for (var $t = 0; $t < 16; $t++) tt(A[$t + 1]);
      for (var te = 0; te <= 11; te++) tt(F[te]);
      tt(17);
      for (var oe = 0; oe < 16; oe++) tt(_[oe + 1]);
      for (var ae = 0; ae <= 161; ae++) tt(J[ae]);
    }(), H(65498), H(12), tt(3), tt(1), tt(0), tt(2), tt(17), tt(3), tt(17), tt(0), tt(63), tt(0);
    var G = 0, Y = 0, ot = 0;
    x = 0, y = 7, this.encode.displayName = "_encode_";
    for (var xt, gt, wt, qt, Rt, Yt, Kt, T, ht, $ = N.data, nt = N.width, X = N.height, st = 4 * nt, vt = 0; vt < X; ) {
      for (xt = 0; xt < st; ) {
        for (Rt = st * vt + xt, Kt = -1, T = 0, ht = 0; ht < 64; ht++) Yt = Rt + (T = ht >> 3) * st + (Kt = 4 * (7 & ht)), vt + T >= X && (Yt -= st * (vt + 1 + T - X)), xt + Kt >= st && (Yt -= xt + Kt - st + 4), gt = $[Yt++], wt = $[Yt++], qt = $[Yt++], v[ht] = (D[gt] + D[wt + 256 >> 0] + D[qt + 512 >> 0] >> 16) - 128, k[ht] = (D[gt + 768 >> 0] + D[wt + 1024 >> 0] + D[qt + 1280 >> 0] >> 16) - 128, C[ht] = (D[gt + 1280 >> 0] + D[wt + 1536 >> 0] + D[qt + 1792 >> 0] >> 16) - 128;
        G = ct(v, h, G, t, i), Y = ct(k, u, Y, e, r), ot = ct(C, u, ot, e, r), xt += 32;
      }
      vt += 8;
    }
    if (y >= 0) {
      var St = [];
      St[1] = y + 1, St[0] = (1 << y + 1) - 1, R(St);
    }
    return H(65497), new Uint8Array(b);
  }, n = n || 50, function() {
    for (var N = String.fromCharCode, z = 0; z < 256; z++) I[z] = N(z);
  }(), t = V(O, M), e = V(A, F), i = V(q, P), r = V(_, J), function() {
    for (var N = 1, z = 2, G = 1; G <= 15; G++) {
      for (var Y = N; Y < z; Y++) p[32767 + Y] = G, d[32767 + Y] = [], d[32767 + Y][1] = G, d[32767 + Y][0] = Y;
      for (var ot = -(z - 1); ot <= -N; ot++) p[32767 + ot] = G, d[32767 + ot] = [], d[32767 + ot][1] = G, d[32767 + ot][0] = z - 1 + ot;
      N <<= 1, z <<= 1;
    }
  }(), function() {
    for (var N = 0; N < 256; N++) D[N] = 19595 * N, D[N + 256 >> 0] = 38470 * N, D[N + 512 >> 0] = 7471 * N + 32768, D[N + 768 >> 0] = -11059 * N, D[N + 1024 >> 0] = -21709 * N, D[N + 1280 >> 0] = 32768 * N + 8421375, D[N + 1536 >> 0] = -27439 * N, D[N + 1792 >> 0] = -5329 * N;
  }(), it(n);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function ar(n, t) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!t, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function lg(n) {
  function t(O) {
    if (!O) throw Error("assert :P");
  }
  function e(O, M, q) {
    for (var P = 0; 4 > P; P++) if (O[M + P] != q.charCodeAt(P)) return !0;
    return !1;
  }
  function i(O, M, q, P, A) {
    for (var F = 0; F < A; F++) O[M + F] = q[P + F];
  }
  function r(O, M, q, P) {
    for (var A = 0; A < P; A++) O[M + A] = q;
  }
  function s(O) {
    return new Int32Array(O);
  }
  function o(O, M) {
    for (var q = [], P = 0; P < O; P++) q.push(new M());
    return q;
  }
  function a(O, M) {
    var q = [];
    return function P(A, F, _) {
      for (var J = _[F], V = 0; V < J && (A.push(_.length > F + 1 ? [] : new M()), !(_.length < F + 1)); V++) P(A[V], F + 1, _);
    }(q, 0, O), q;
  }
  var l = function() {
    var O = this;
    function M(c, m) {
      for (var S = 1 << m - 1 >>> 0; c & S; ) S >>>= 1;
      return S ? (c & S - 1) + S : c;
    }
    function q(c, m, S, L, B) {
      t(!(L % S));
      do
        c[m + (L -= S)] = B;
      while (0 < L);
    }
    function P(c, m, S, L, B) {
      if (t(2328 >= B), 512 >= B) var U = s(512);
      else if ((U = s(B)) == null) return 0;
      return function(W, K, Z, rt, yt, Pt) {
        var Lt, At, Ht = K, Mt = 1 << Z, bt = s(16), _t = s(16);
        for (t(yt != 0), t(rt != null), t(W != null), t(0 < Z), At = 0; At < yt; ++At) {
          if (15 < rt[At]) return 0;
          ++bt[rt[At]];
        }
        if (bt[0] == yt) return 0;
        for (_t[1] = 0, Lt = 1; 15 > Lt; ++Lt) {
          if (bt[Lt] > 1 << Lt) return 0;
          _t[Lt + 1] = _t[Lt] + bt[Lt];
        }
        for (At = 0; At < yt; ++At) Lt = rt[At], 0 < rt[At] && (Pt[_t[Lt]++] = At);
        if (_t[15] == 1) return (rt = new A()).g = 0, rt.value = Pt[0], q(W, Ht, 1, Mt, rt), Mt;
        var Ut, Gt = -1, Wt = Mt - 1, ue = 0, ee = 1, _e = 1, re = 1 << Z;
        for (At = 0, Lt = 1, yt = 2; Lt <= Z; ++Lt, yt <<= 1) {
          if (ee += _e <<= 1, 0 > (_e -= bt[Lt])) return 0;
          for (; 0 < bt[Lt]; --bt[Lt]) (rt = new A()).g = Lt, rt.value = Pt[At++], q(W, Ht + ue, yt, re, rt), ue = M(ue, Lt);
        }
        for (Lt = Z + 1, yt = 2; 15 >= Lt; ++Lt, yt <<= 1) {
          if (ee += _e <<= 1, 0 > (_e -= bt[Lt])) return 0;
          for (; 0 < bt[Lt]; --bt[Lt]) {
            if (rt = new A(), (ue & Wt) != Gt) {
              for (Ht += re, Ut = 1 << (Gt = Lt) - Z; 15 > Gt && !(0 >= (Ut -= bt[Gt])); ) ++Gt, Ut <<= 1;
              Mt += re = 1 << (Ut = Gt - Z), W[K + (Gt = ue & Wt)].g = Ut + Z, W[K + Gt].value = Ht - K - Gt;
            }
            rt.g = Lt - Z, rt.value = Pt[At++], q(W, Ht + (ue >> Z), yt, re, rt), ue = M(ue, Lt);
          }
        }
        return ee != 2 * _t[15] - 1 ? 0 : Mt;
      }(c, m, S, L, B, U);
    }
    function A() {
      this.value = this.g = 0;
    }
    function F() {
      this.value = this.g = 0;
    }
    function _() {
      this.G = o(5, A), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o(Vn, F);
    }
    function J(c, m, S, L) {
      t(c != null), t(m != null), t(2147483648 > L), c.Ca = 254, c.I = 0, c.b = -8, c.Ka = 0, c.oa = m, c.pa = S, c.Jd = m, c.Yc = S + L, c.Zc = 4 <= L ? S + L - 4 + 1 : S, xt(c);
    }
    function V(c, m) {
      for (var S = 0; 0 < m--; ) S |= wt(c, 128) << m;
      return S;
    }
    function R(c, m) {
      var S = V(c, m);
      return gt(c) ? -S : S;
    }
    function tt(c, m, S, L) {
      var B, U = 0;
      for (t(c != null), t(m != null), t(4294967288 > L), c.Sb = L, c.Ra = 0, c.u = 0, c.h = 0, 4 < L && (L = 4), B = 0; B < L; ++B) U += m[S + B] << 8 * B;
      c.Ra = U, c.bb = L, c.oa = m, c.pa = S;
    }
    function H(c) {
      for (; 8 <= c.u && c.bb < c.Sb; ) c.Ra >>>= 8, c.Ra += c.oa[c.pa + c.bb] << Go - 8 >>> 0, ++c.bb, c.u -= 8;
      G(c) && (c.h = 1, c.u = 0);
    }
    function ct(c, m) {
      if (t(0 <= m), !c.h && m <= Ho) {
        var S = z(c) & Wo[m];
        return c.u += m, H(c), S;
      }
      return c.h = 1, c.u = 0;
    }
    function it() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function z(c) {
      return c.Ra >>> (c.u & Go - 1) >>> 0;
    }
    function G(c) {
      return t(c.bb <= c.Sb), c.h || c.bb == c.Sb && c.u > Go;
    }
    function Y(c, m) {
      c.u = m, c.h = G(c);
    }
    function ot(c) {
      c.u >= Ka && (t(c.u >= Ka), H(c));
    }
    function xt(c) {
      t(c != null && c.oa != null), c.pa < c.Zc ? (c.I = (c.oa[c.pa++] | c.I << 8) >>> 0, c.b += 8) : (t(c != null && c.oa != null), c.pa < c.Yc ? (c.b += 8, c.I = c.oa[c.pa++] | c.I << 8) : c.Ka ? c.b = 0 : (c.I <<= 8, c.b += 8, c.Ka = 1));
    }
    function gt(c) {
      return V(c, 1);
    }
    function wt(c, m) {
      var S = c.Ca;
      0 > c.b && xt(c);
      var L = c.b, B = S * m >>> 8, U = (c.I >>> L > B) + 0;
      for (U ? (S -= B, c.I -= B + 1 << L >>> 0) : S = B + 1, L = S, B = 0; 256 <= L; ) B += 8, L >>= 8;
      return L = 7 ^ B + yi[L], c.b -= L, c.Ca = (S << L) - 1, U;
    }
    function qt(c, m, S) {
      c[m + 0] = S >> 24 & 255, c[m + 1] = S >> 16 & 255, c[m + 2] = S >> 8 & 255, c[m + 3] = S >> 0 & 255;
    }
    function Rt(c, m) {
      return c[m + 0] << 0 | c[m + 1] << 8;
    }
    function Yt(c, m) {
      return Rt(c, m) | c[m + 2] << 16;
    }
    function Kt(c, m) {
      return Rt(c, m) | Rt(c, m + 2) << 16;
    }
    function T(c, m) {
      var S = 1 << m;
      return t(c != null), t(0 < m), c.X = s(S), c.X == null ? 0 : (c.Mb = 32 - m, c.Xa = m, 1);
    }
    function ht(c, m) {
      t(c != null), t(m != null), t(c.Xa == m.Xa), i(m.X, 0, c.X, 0, 1 << m.Xa);
    }
    function $() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function nt(c, m, S, L) {
      t(S != null), t(L != null);
      var B = S[0], U = L[0];
      return B == 0 && (B = (c * U + m / 2) / m), U == 0 && (U = (m * B + c / 2) / c), 0 >= B || 0 >= U ? 0 : (S[0] = B, L[0] = U, 1);
    }
    function X(c, m) {
      return c + (1 << m) - 1 >>> m;
    }
    function st(c, m) {
      return ((4278255360 & c) + (4278255360 & m) >>> 0 & 4278255360) + ((16711935 & c) + (16711935 & m) >>> 0 & 16711935) >>> 0;
    }
    function vt(c, m) {
      O[m] = function(S, L, B, U, W, K, Z) {
        var rt;
        for (rt = 0; rt < W; ++rt) {
          var yt = O[c](K[Z + rt - 1], B, U + rt);
          K[Z + rt] = st(S[L + rt], yt);
        }
      };
    }
    function St() {
      this.ud = this.hd = this.jd = 0;
    }
    function ft(c, m) {
      return ((4278124286 & (c ^ m)) >>> 1) + (c & m) >>> 0;
    }
    function Et(c) {
      return 0 <= c && 256 > c ? c : 0 > c ? 0 : 255 < c ? 255 : void 0;
    }
    function zt(c, m) {
      return Et(c + (c - m + 0.5 >> 1));
    }
    function Tt(c, m, S) {
      return Math.abs(m - S) - Math.abs(c - S);
    }
    function $t(c, m, S, L, B, U, W) {
      for (L = U[W - 1], S = 0; S < B; ++S) U[W + S] = L = st(c[m + S], L);
    }
    function te(c, m, S, L, B) {
      var U;
      for (U = 0; U < S; ++U) {
        var W = c[m + U], K = W >> 8 & 255, Z = 16711935 & (Z = (Z = 16711935 & W) + ((K << 16) + K));
        L[B + U] = (4278255360 & W) + Z >>> 0;
      }
    }
    function oe(c, m) {
      m.jd = c >> 0 & 255, m.hd = c >> 8 & 255, m.ud = c >> 16 & 255;
    }
    function ae(c, m, S, L, B, U) {
      var W;
      for (W = 0; W < L; ++W) {
        var K = m[S + W], Z = K >>> 8, rt = K, yt = 255 & (yt = (yt = K >>> 16) + ((c.jd << 24 >> 24) * (Z << 24 >> 24) >>> 5));
        rt = 255 & (rt = (rt = rt + ((c.hd << 24 >> 24) * (Z << 24 >> 24) >>> 5)) + ((c.ud << 24 >> 24) * (yt << 24 >> 24) >>> 5)), B[U + W] = (4278255360 & K) + (yt << 16) + rt;
      }
    }
    function xe(c, m, S, L, B) {
      O[m] = function(U, W, K, Z, rt, yt, Pt, Lt, At) {
        for (Z = Pt; Z < Lt; ++Z) for (Pt = 0; Pt < At; ++Pt) rt[yt++] = B(K[L(U[W++])]);
      }, O[c] = function(U, W, K, Z, rt, yt, Pt) {
        var Lt = 8 >> U.b, At = U.Ea, Ht = U.K[0], Mt = U.w;
        if (8 > Lt) for (U = (1 << U.b) - 1, Mt = (1 << Lt) - 1; W < K; ++W) {
          var bt, _t = 0;
          for (bt = 0; bt < At; ++bt) bt & U || (_t = L(Z[rt++])), yt[Pt++] = B(Ht[_t & Mt]), _t >>= Lt;
        }
        else O["VP8LMapColor" + S](Z, rt, Ht, Mt, yt, Pt, W, K, At);
      };
    }
    function Xt(c, m, S, L, B) {
      for (S = m + S; m < S; ) {
        var U = c[m++];
        L[B++] = U >> 16 & 255, L[B++] = U >> 8 & 255, L[B++] = U >> 0 & 255;
      }
    }
    function Nt(c, m, S, L, B) {
      for (S = m + S; m < S; ) {
        var U = c[m++];
        L[B++] = U >> 16 & 255, L[B++] = U >> 8 & 255, L[B++] = U >> 0 & 255, L[B++] = U >> 24 & 255;
      }
    }
    function Ot(c, m, S, L, B) {
      for (S = m + S; m < S; ) {
        var U = (W = c[m++]) >> 16 & 240 | W >> 12 & 15, W = W >> 0 & 240 | W >> 28 & 15;
        L[B++] = U, L[B++] = W;
      }
    }
    function ie(c, m, S, L, B) {
      for (S = m + S; m < S; ) {
        var U = (W = c[m++]) >> 16 & 248 | W >> 13 & 7, W = W >> 5 & 224 | W >> 3 & 31;
        L[B++] = U, L[B++] = W;
      }
    }
    function Jt(c, m, S, L, B) {
      for (S = m + S; m < S; ) {
        var U = c[m++];
        L[B++] = U >> 0 & 255, L[B++] = U >> 8 & 255, L[B++] = U >> 16 & 255;
      }
    }
    function fe(c, m, S, L, B, U) {
      if (U == 0) for (S = m + S; m < S; ) qt(L, ((U = c[m++])[0] >> 24 | U[1] >> 8 & 65280 | U[2] << 8 & 16711680 | U[3] << 24) >>> 0), B += 32;
      else i(L, B, c, m, S);
    }
    function ne(c, m) {
      O[m][0] = O[c + "0"], O[m][1] = O[c + "1"], O[m][2] = O[c + "2"], O[m][3] = O[c + "3"], O[m][4] = O[c + "4"], O[m][5] = O[c + "5"], O[m][6] = O[c + "6"], O[m][7] = O[c + "7"], O[m][8] = O[c + "8"], O[m][9] = O[c + "9"], O[m][10] = O[c + "10"], O[m][11] = O[c + "11"], O[m][12] = O[c + "12"], O[m][13] = O[c + "13"], O[m][14] = O[c + "0"], O[m][15] = O[c + "0"];
    }
    function de(c) {
      return c == eh || c == nh || c == au || c == ih;
    }
    function Ue() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Te() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Sn() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Ue(), this.f.kb = new Te(), this.sd = null;
    }
    function Mn() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Ze() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function Ce(c) {
      return alert("todo:WebPSamplerProcessPlane"), c.T;
    }
    function qe(c, m) {
      var S = c.T, L = m.ba.f.RGBA, B = L.eb, U = L.fb + c.ka * L.A, W = Vi[m.ba.S], K = c.y, Z = c.O, rt = c.f, yt = c.N, Pt = c.ea, Lt = c.W, At = m.cc, Ht = m.dc, Mt = m.Mc, bt = m.Nc, _t = c.ka, Ut = c.ka + c.T, Gt = c.U, Wt = Gt + 1 >> 1;
      for (_t == 0 ? W(K, Z, null, null, rt, yt, Pt, Lt, rt, yt, Pt, Lt, B, U, null, null, Gt) : (W(m.ec, m.fc, K, Z, At, Ht, Mt, bt, rt, yt, Pt, Lt, B, U - L.A, B, U, Gt), ++S); _t + 2 < Ut; _t += 2) At = rt, Ht = yt, Mt = Pt, bt = Lt, yt += c.Rc, Lt += c.Rc, U += 2 * L.A, W(K, (Z += 2 * c.fa) - c.fa, K, Z, At, Ht, Mt, bt, rt, yt, Pt, Lt, B, U - L.A, B, U, Gt);
      return Z += c.fa, c.j + Ut < c.o ? (i(m.ec, m.fc, K, Z, Gt), i(m.cc, m.dc, rt, yt, Wt), i(m.Mc, m.Nc, Pt, Lt, Wt), S--) : 1 & Ut || W(K, Z, null, null, rt, yt, Pt, Lt, rt, yt, Pt, Lt, B, U + L.A, null, null, Gt), S;
    }
    function Qi(c, m, S) {
      var L = c.F, B = [c.J];
      if (L != null) {
        var U = c.U, W = m.ba.S, K = W == ou || W == au;
        m = m.ba.f.RGBA;
        var Z = [0], rt = c.ka;
        Z[0] = c.T, c.Kb && (rt == 0 ? --Z[0] : (--rt, B[0] -= c.width), c.j + c.ka + c.T == c.o && (Z[0] = c.o - c.j - rt));
        var yt = m.eb;
        rt = m.fb + rt * m.A, c = un(L, B[0], c.width, U, Z, yt, rt + (K ? 0 : 3), m.A), t(S == Z), c && de(W) && Hi(yt, rt, K, U, Z, m.A);
      }
      return 0;
    }
    function yn(c) {
      var m = c.ma, S = m.ba.S, L = 11 > S, B = S == ru || S == su || S == ou || S == th || S == 12 || de(S);
      if (m.memory = null, m.Ib = null, m.Jb = null, m.Nd = null, !Va(m.Oa, c, B ? 11 : 12)) return 0;
      if (B && de(S) && Vt(), c.da) alert("todo:use_scaling");
      else {
        if (L) {
          if (m.Ib = Ce, c.Kb) {
            if (S = c.U + 1 >> 1, m.memory = s(c.U + 2 * S), m.memory == null) return 0;
            m.ec = m.memory, m.fc = 0, m.cc = m.ec, m.dc = m.fc + c.U, m.Mc = m.cc, m.Nc = m.dc + S, m.Ib = qe, Vt();
          }
        } else alert("todo:EmitYUV");
        B && (m.Jb = Qi, L && Ct());
      }
      if (L && !tp) {
        for (c = 0; 256 > c; ++c) s2[c] = 89858 * (c - 128) + uu >> lu, l2[c] = -22014 * (c - 128) + uu, a2[c] = -45773 * (c - 128), o2[c] = 113618 * (c - 128) + uu >> lu;
        for (c = nl; c < oh; ++c) m = 76283 * (c - 16) + uu >> lu, u2[c - nl] = Ii(m, 255), c2[c - nl] = Ii(m + 8 >> 4, 15);
        tp = 1;
      }
      return 1;
    }
    function Ri(c) {
      var m = c.ma, S = c.U, L = c.T;
      return t(!(1 & c.ka)), 0 >= S || 0 >= L ? 0 : (S = m.Ib(c, m), m.Jb != null && m.Jb(c, m, S), m.Dc += S, 1);
    }
    function qn(c) {
      c.ma.memory = null;
    }
    function we(c, m, S, L) {
      return ct(c, 8) != 47 ? 0 : (m[0] = ct(c, 14) + 1, S[0] = ct(c, 14) + 1, L[0] = ct(c, 1), ct(c, 3) != 0 ? 0 : !c.h);
    }
    function Ai(c, m) {
      if (4 > c) return c + 1;
      var S = c - 2 >> 1;
      return (2 + (1 & c) << S) + ct(m, S) + 1;
    }
    function Bi(c, m) {
      return 120 < m ? m - 120 : 1 <= (S = ((S = Hm[m - 1]) >> 4) * c + (8 - (15 & S))) ? S : 1;
      var S;
    }
    function ti(c, m, S) {
      var L = z(S), B = c[m += 255 & L].g - 8;
      return 0 < B && (Y(S, S.u + 8), L = z(S), m += c[m].value, m += L & (1 << B) - 1), Y(S, S.u + c[m].g), c[m].value;
    }
    function bn(c, m, S) {
      return S.g += c.g, S.value += c.value << m >>> 0, t(8 >= S.g), c.g;
    }
    function vn(c, m, S) {
      var L = c.xc;
      return t((m = L == 0 ? 0 : c.vc[c.md * (S >> L) + (m >> L)]) < c.Wb), c.Ya[m];
    }
    function ci(c, m, S, L) {
      var B = c.ab, U = c.c * m, W = c.C;
      m = W + m;
      var K = S, Z = L;
      for (L = c.Ta, S = c.Ua; 0 < B--; ) {
        var rt = c.gc[B], yt = W, Pt = m, Lt = K, At = Z, Ht = (Z = L, K = S, rt.Ea);
        switch (t(yt < Pt), t(Pt <= rt.nc), rt.hc) {
          case 2:
            Jl(Lt, At, (Pt - yt) * Ht, Z, K);
            break;
          case 0:
            var Mt = yt, bt = Pt, _t = Z, Ut = K, Gt = (re = rt).Ea;
            Mt == 0 && (Zc(Lt, At, null, null, 1, _t, Ut), $t(Lt, At + 1, 0, 0, Gt - 1, _t, Ut + 1), At += Gt, Ut += Gt, ++Mt);
            for (var Wt = 1 << re.b, ue = Wt - 1, ee = X(Gt, re.b), _e = re.K, re = re.w + (Mt >> re.b) * ee; Mt < bt; ) {
              var Ke = _e, Qe = re, We = 1;
              for (Xa(Lt, At, _t, Ut - Gt, 1, _t, Ut); We < Gt; ) {
                var je = (We & ~ue) + Wt;
                je > Gt && (je = Gt), (0, ys[Ke[Qe++] >> 8 & 15])(Lt, At + +We, _t, Ut + We - Gt, je - We, _t, Ut + We), We = je;
              }
              At += Gt, Ut += Gt, ++Mt & ue || (re += ee);
            }
            Pt != rt.nc && i(Z, K - Ht, Z, K + (Pt - yt - 1) * Ht, Ht);
            break;
          case 1:
            for (Ht = Lt, bt = At, Gt = (Lt = rt.Ea) - (Ut = Lt & ~(_t = (At = 1 << rt.b) - 1)), Mt = X(Lt, rt.b), Wt = rt.K, rt = rt.w + (yt >> rt.b) * Mt; yt < Pt; ) {
              for (ue = Wt, ee = rt, _e = new St(), re = bt + Ut, Ke = bt + Lt; bt < re; ) oe(ue[ee++], _e), eo(_e, Ht, bt, At, Z, K), bt += At, K += At;
              bt < Ke && (oe(ue[ee++], _e), eo(_e, Ht, bt, Gt, Z, K), bt += Gt, K += Gt), ++yt & _t || (rt += Mt);
            }
            break;
          case 3:
            if (Lt == Z && At == K && 0 < rt.b) {
              for (bt = Z, Lt = Ht = K + (Pt - yt) * Ht - (Ut = (Pt - yt) * X(rt.Ea, rt.b)), At = Z, _t = K, Mt = [], Ut = (Gt = Ut) - 1; 0 <= Ut; --Ut) Mt[Ut] = At[_t + Ut];
              for (Ut = Gt - 1; 0 <= Ut; --Ut) bt[Lt + Ut] = Mt[Ut];
              $i(rt, yt, Pt, Z, Ht, Z, K);
            } else $i(rt, yt, Pt, Lt, At, Z, K);
        }
        K = L, Z = S;
      }
      Z != S && i(L, S, K, Z, U);
    }
    function rs(c, m) {
      var S = c.V, L = c.Ba + c.c * c.C, B = m - c.C;
      if (t(m <= c.l.o), t(16 >= B), 0 < B) {
        var U = c.l, W = c.Ta, K = c.Ua, Z = U.width;
        if (ci(c, B, S, L), B = K = [K], t((S = c.C) < (L = m)), t(U.v < U.va), L > U.o && (L = U.o), S < U.j) {
          var rt = U.j - S;
          S = U.j, B[0] += rt * Z;
        }
        if (S >= L ? S = 0 : (B[0] += 4 * U.v, U.ka = S - U.j, U.U = U.va - U.v, U.T = L - S, S = 1), S) {
          if (K = K[0], 11 > (S = c.ca).S) {
            var yt = S.f.RGBA, Pt = (L = S.S, B = U.U, U = U.T, rt = yt.eb, yt.A), Lt = U;
            for (yt = yt.fb + c.Ma * yt.A; 0 < Lt--; ) {
              var At = W, Ht = K, Mt = B, bt = rt, _t = yt;
              switch (L) {
                case iu:
                  bi(At, Ht, Mt, bt, _t);
                  break;
                case ru:
                  hi(At, Ht, Mt, bt, _t);
                  break;
                case eh:
                  hi(At, Ht, Mt, bt, _t), Hi(bt, _t, 0, Mt, 1, 0);
                  break;
                case Wd:
                  Wr(At, Ht, Mt, bt, _t);
                  break;
                case su:
                  fe(At, Ht, Mt, bt, _t, 1);
                  break;
                case nh:
                  fe(At, Ht, Mt, bt, _t, 1), Hi(bt, _t, 0, Mt, 1, 0);
                  break;
                case ou:
                  fe(At, Ht, Mt, bt, _t, 0);
                  break;
                case au:
                  fe(At, Ht, Mt, bt, _t, 0), Hi(bt, _t, 1, Mt, 1, 0);
                  break;
                case th:
                  bs(At, Ht, Mt, bt, _t);
                  break;
                case ih:
                  bs(At, Ht, Mt, bt, _t), ln(bt, _t, Mt, 1, 0);
                  break;
                case Hd:
                  Ur(At, Ht, Mt, bt, _t);
                  break;
                default:
                  t(0);
              }
              K += Z, yt += Pt;
            }
            c.Ma += U;
          } else alert("todo:EmitRescaledRowsYUVA");
          t(c.Ma <= S.height);
        }
      }
      c.C = m, t(c.C <= c.i);
    }
    function tr(c) {
      var m;
      if (0 < c.ua) return 0;
      for (m = 0; m < c.Wb; ++m) {
        var S = c.Ya[m].G, L = c.Ya[m].H;
        if (0 < S[1][L[1] + 0].g || 0 < S[2][L[2] + 0].g || 0 < S[3][L[3] + 0].g) return 0;
      }
      return 1;
    }
    function mi(c, m, S, L, B, U) {
      if (c.Z != 0) {
        var W = c.qd, K = c.rd;
        for (t(_s[c.Z] != null); m < S; ++m) _s[c.Z](W, K, L, B, L, B, U), W = L, K = B, B += U;
        c.qd = W, c.rd = K;
      }
    }
    function Ni(c, m) {
      var S = c.l.ma, L = S.Z == 0 || S.Z == 1 ? c.l.j : c.C;
      if (L = c.C < L ? L : c.C, t(m <= c.l.o), m > L) {
        var B = c.l.width, U = S.ca, W = S.tb + B * L, K = c.V, Z = c.Ba + c.c * L, rt = c.gc;
        t(c.ab == 1), t(rt[0].hc == 3), Zl(rt[0], L, m, K, Z, U, W), mi(S, L, m, U, W, B);
      }
      c.C = c.Ma = m;
    }
    function Ci(c, m, S, L, B, U, W) {
      var K = c.$ / L, Z = c.$ % L, rt = c.m, yt = c.s, Pt = S + c.$, Lt = Pt;
      B = S + L * B;
      var At = S + L * U, Ht = 280 + yt.ua, Mt = c.Pb ? K : 16777216, bt = 0 < yt.ua ? yt.Wa : null, _t = yt.wc, Ut = Pt < At ? vn(yt, Z, K) : null;
      t(c.C < U), t(At <= B);
      var Gt = !1;
      t: for (; ; ) {
        for (; Gt || Pt < At; ) {
          var Wt = 0;
          if (K >= Mt) {
            var ue = Pt - S;
            t((Mt = c).Pb), Mt.wd = Mt.m, Mt.xd = ue, 0 < Mt.s.ua && ht(Mt.s.Wa, Mt.s.vb), Mt = K + Vm;
          }
          if (Z & _t || (Ut = vn(yt, Z, K)), t(Ut != null), Ut.Qb && (m[Pt] = Ut.qb, Gt = !0), !Gt) if (ot(rt), Ut.jc) {
            Wt = rt, ue = m;
            var ee = Pt, _e = Ut.pd[z(Wt) & Vn - 1];
            t(Ut.jc), 256 > _e.g ? (Y(Wt, Wt.u + _e.g), ue[ee] = _e.value, Wt = 0) : (Y(Wt, Wt.u + _e.g - 256), t(256 <= _e.value), Wt = _e.value), Wt == 0 && (Gt = !0);
          } else Wt = ti(Ut.G[0], Ut.H[0], rt);
          if (rt.h) break;
          if (Gt || 256 > Wt) {
            if (!Gt) if (Ut.nd) m[Pt] = (Ut.qb | Wt << 8) >>> 0;
            else {
              if (ot(rt), Gt = ti(Ut.G[1], Ut.H[1], rt), ot(rt), ue = ti(Ut.G[2], Ut.H[2], rt), ee = ti(Ut.G[3], Ut.H[3], rt), rt.h) break;
              m[Pt] = (ee << 24 | Gt << 16 | Wt << 8 | ue) >>> 0;
            }
            if (Gt = !1, ++Pt, ++Z >= L && (Z = 0, ++K, W != null && K <= U && !(K % 16) && W(c, K), bt != null)) for (; Lt < Pt; ) Wt = m[Lt++], bt.X[(506832829 * Wt & 4294967295) >>> bt.Mb] = Wt;
          } else if (280 > Wt) {
            if (Wt = Ai(Wt - 256, rt), ue = ti(Ut.G[4], Ut.H[4], rt), ot(rt), ue = Bi(L, ue = Ai(ue, rt)), rt.h) break;
            if (Pt - S < ue || B - Pt < Wt) break t;
            for (ee = 0; ee < Wt; ++ee) m[Pt + ee] = m[Pt + ee - ue];
            for (Pt += Wt, Z += Wt; Z >= L; ) Z -= L, ++K, W != null && K <= U && !(K % 16) && W(c, K);
            if (t(Pt <= B), Z & _t && (Ut = vn(yt, Z, K)), bt != null) for (; Lt < Pt; ) Wt = m[Lt++], bt.X[(506832829 * Wt & 4294967295) >>> bt.Mb] = Wt;
          } else {
            if (!(Wt < Ht)) break t;
            for (Gt = Wt - 280, t(bt != null); Lt < Pt; ) Wt = m[Lt++], bt.X[(506832829 * Wt & 4294967295) >>> bt.Mb] = Wt;
            Wt = Pt, t(!(Gt >>> (ue = bt).Xa)), m[Wt] = ue.X[Gt], Gt = !0;
          }
          Gt || t(rt.h == G(rt));
        }
        if (c.Pb && rt.h && Pt < B) t(c.m.h), c.a = 5, c.m = c.wd, c.$ = c.xd, 0 < c.s.ua && ht(c.s.vb, c.s.Wa);
        else {
          if (rt.h) break t;
          W != null && W(c, K > U ? U : K), c.a = 0, c.$ = Pt - S;
        }
        return 1;
      }
      return c.a = 3, 0;
    }
    function ji(c) {
      t(c != null), c.vc = null, c.yc = null, c.Ya = null;
      var m = c.Wa;
      m != null && (m.X = null), c.vb = null, t(c != null);
    }
    function Pi() {
      var c = new Jc();
      return c == null ? null : (c.a = 0, c.xb = Yd, ne("Predictor", "VP8LPredictors"), ne("Predictor", "VP8LPredictors_C"), ne("PredictorAdd", "VP8LPredictorsAdd"), ne("PredictorAdd", "VP8LPredictorsAdd_C"), Jl = te, eo = ae, bi = Xt, hi = Nt, bs = Ot, Ur = ie, Wr = Jt, O.VP8LMapColor32b = Vo, O.VP8LMapColor8b = Ql, c);
    }
    function qi(c, m, S, L, B) {
      var U = 1, W = [c], K = [m], Z = L.m, rt = L.s, yt = null, Pt = 0;
      t: for (; ; ) {
        if (S) for (; U && ct(Z, 1); ) {
          var Lt = W, At = K, Ht = L, Mt = 1, bt = Ht.m, _t = Ht.gc[Ht.ab], Ut = ct(bt, 2);
          if (Ht.Oc & 1 << Ut) U = 0;
          else {
            switch (Ht.Oc |= 1 << Ut, _t.hc = Ut, _t.Ea = Lt[0], _t.nc = At[0], _t.K = [null], ++Ht.ab, t(4 >= Ht.ab), Ut) {
              case 0:
              case 1:
                _t.b = ct(bt, 3) + 2, Mt = qi(X(_t.Ea, _t.b), X(_t.nc, _t.b), 0, Ht, _t.K), _t.K = _t.K[0];
                break;
              case 3:
                var Gt, Wt = ct(bt, 8) + 1, ue = 16 < Wt ? 0 : 4 < Wt ? 1 : 2 < Wt ? 2 : 3;
                if (Lt[0] = X(_t.Ea, ue), _t.b = ue, Gt = Mt = qi(Wt, 1, 0, Ht, _t.K)) {
                  var ee, _e = Wt, re = _t, Ke = 1 << (8 >> re.b), Qe = s(Ke);
                  if (Qe == null) Gt = 0;
                  else {
                    var We = re.K[0], je = re.w;
                    for (Qe[0] = re.K[0][0], ee = 1; ee < 1 * _e; ++ee) Qe[ee] = st(We[je + ee], Qe[ee - 1]);
                    for (; ee < 4 * Ke; ++ee) Qe[ee] = 0;
                    re.K[0] = null, re.K[0] = Qe, Gt = 1;
                  }
                }
                Mt = Gt;
                break;
              case 2:
                break;
              default:
                t(0);
            }
            U = Mt;
          }
        }
        if (W = W[0], K = K[0], U && ct(Z, 1) && !(U = 1 <= (Pt = ct(Z, 4)) && 11 >= Pt)) {
          L.a = 3;
          break t;
        }
        var on;
        if (on = U) e: {
          var nn, Me, On, vi = L, Tn = W, wi = K, tn = Pt, Oi = S, Ti = vi.m, $n = vi.s, Yn = [null], di = 1, Yi = 0, _r = Gm[tn];
          n: for (; ; ) {
            if (Oi && ct(Ti, 1)) {
              var Un = ct(Ti, 3) + 2, Yr = X(Tn, Un), oo = X(wi, Un), Zo = Yr * oo;
              if (!qi(Yr, oo, 0, vi, Yn)) break n;
              for (Yn = Yn[0], $n.xc = Un, nn = 0; nn < Zo; ++nn) {
                var Ss = Yn[nn] >> 8 & 65535;
                Yn[nn] = Ss, Ss >= di && (di = Ss + 1);
              }
            }
            if (Ti.h) break n;
            for (Me = 0; 5 > Me; ++Me) {
              var xn = Gd[Me];
              !Me && 0 < tn && (xn += 1 << tn), Yi < xn && (Yi = xn);
            }
            var ah = o(di * _r, A), ip = di, rp = o(ip, _);
            if (rp == null) var hu = null;
            else t(65536 >= ip), hu = rp;
            var il = s(Yi);
            if (hu == null || il == null || ah == null) {
              vi.a = 1;
              break n;
            }
            var fu = ah;
            for (nn = On = 0; nn < di; ++nn) {
              var sr = hu[nn], Qo = sr.G, ta = sr.H, sp = 0, du = 1, op = 0;
              for (Me = 0; 5 > Me; ++Me) {
                xn = Gd[Me], Qo[Me] = fu, ta[Me] = On, !Me && 0 < tn && (xn += 1 << tn);
                r: {
                  var pu, lh = xn, gu = vi, rl = il, d2 = fu, p2 = On, uh = 0, ks = gu.m, g2 = ct(ks, 1);
                  if (r(rl, 0, 0, lh), g2) {
                    var m2 = ct(ks, 1) + 1, y2 = ct(ks, 1), ap = ct(ks, y2 == 0 ? 1 : 8);
                    rl[ap] = 1, m2 == 2 && (rl[ap = ct(ks, 8)] = 1);
                    var mu = 1;
                  } else {
                    var lp = s(19), up = ct(ks, 4) + 4;
                    if (19 < up) {
                      gu.a = 3;
                      var yu = 0;
                      break r;
                    }
                    for (pu = 0; pu < up; ++pu) lp[Wm[pu]] = ct(ks, 3);
                    var ch = void 0, sl = void 0, cp = gu, b2 = lp, bu = lh, hp = rl, hh = 0, As = cp.m, fp = 8, dp = o(128, A);
                    i: for (; P(dp, 0, 7, b2, 19); ) {
                      if (ct(As, 1)) {
                        var v2 = 2 + 2 * ct(As, 3);
                        if ((ch = 2 + ct(As, v2)) > bu) break i;
                      } else ch = bu;
                      for (sl = 0; sl < bu && ch--; ) {
                        ot(As);
                        var pp = dp[0 + (127 & z(As))];
                        Y(As, As.u + pp.g);
                        var ea = pp.value;
                        if (16 > ea) hp[sl++] = ea, ea != 0 && (fp = ea);
                        else {
                          var w2 = ea == 16, gp = ea - 16, x2 = $m[gp], mp = ct(As, zm[gp]) + x2;
                          if (sl + mp > bu) break i;
                          for (var _2 = w2 ? fp : 0; 0 < mp--; ) hp[sl++] = _2;
                        }
                      }
                      hh = 1;
                      break i;
                    }
                    hh || (cp.a = 3), mu = hh;
                  }
                  (mu = mu && !ks.h) && (uh = P(d2, p2, 8, rl, lh)), mu && uh != 0 ? yu = uh : (gu.a = 3, yu = 0);
                }
                if (yu == 0) break n;
                if (du && Um[Me] == 1 && (du = fu[On].g == 0), sp += fu[On].g, On += yu, 3 >= Me) {
                  var ol, fh = il[0];
                  for (ol = 1; ol < xn; ++ol) il[ol] > fh && (fh = il[ol]);
                  op += fh;
                }
              }
              if (sr.nd = du, sr.Qb = 0, du && (sr.qb = (Qo[3][ta[3] + 0].value << 24 | Qo[1][ta[1] + 0].value << 16 | Qo[2][ta[2] + 0].value) >>> 0, sp == 0 && 256 > Qo[0][ta[0] + 0].value && (sr.Qb = 1, sr.qb += Qo[0][ta[0] + 0].value << 8)), sr.jc = !sr.Qb && 6 > op, sr.jc) {
                var vu, Kr = sr;
                for (vu = 0; vu < Vn; ++vu) {
                  var Ns = vu, Cs = Kr.pd[Ns], wu = Kr.G[0][Kr.H[0] + Ns];
                  256 <= wu.value ? (Cs.g = wu.g + 256, Cs.value = wu.value) : (Cs.g = 0, Cs.value = 0, Ns >>= bn(wu, 8, Cs), Ns >>= bn(Kr.G[1][Kr.H[1] + Ns], 16, Cs), Ns >>= bn(Kr.G[2][Kr.H[2] + Ns], 0, Cs), bn(Kr.G[3][Kr.H[3] + Ns], 24, Cs));
                }
              }
            }
            $n.vc = Yn, $n.Wb = di, $n.Ya = hu, $n.yc = ah, on = 1;
            break e;
          }
          on = 0;
        }
        if (!(U = on)) {
          L.a = 3;
          break t;
        }
        if (0 < Pt) {
          if (rt.ua = 1 << Pt, !T(rt.Wa, Pt)) {
            L.a = 1, U = 0;
            break t;
          }
        } else rt.ua = 0;
        var dh = L, yp = W, S2 = K, ph = dh.s, gh = ph.xc;
        if (dh.c = yp, dh.i = S2, ph.md = X(yp, gh), ph.wc = gh == 0 ? -1 : (1 << gh) - 1, S) {
          L.xb = t2;
          break t;
        }
        if ((yt = s(W * K)) == null) {
          L.a = 1, U = 0;
          break t;
        }
        U = (U = Ci(L, yt, 0, W, K, K, null)) && !Z.h;
        break t;
      }
      return U ? (B != null ? B[0] = yt : (t(yt == null), t(S)), L.$ = 0, S || ji(rt)) : ji(rt), U;
    }
    function br(c, m) {
      var S = c.c * c.i, L = S + m + 16 * m;
      return t(c.c <= m), c.V = s(L), c.V == null ? (c.Ta = null, c.Ua = 0, c.a = 1, 0) : (c.Ta = c.V, c.Ua = c.Ba + S + m, 1);
    }
    function Dr(c, m) {
      var S = c.C, L = m - S, B = c.V, U = c.Ba + c.c * S;
      for (t(m <= c.l.o); 0 < L; ) {
        var W = 16 < L ? 16 : L, K = c.l.ma, Z = c.l.width, rt = Z * W, yt = K.ca, Pt = K.tb + Z * S, Lt = c.Ta, At = c.Ua;
        ci(c, W, B, U), An(Lt, At, yt, Pt, rt), mi(K, S, S + W, yt, Pt, Z), L -= W, B += W * c.c, S += W;
      }
      t(S == m), c.C = c.Ma = m;
    }
    function er() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Rr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Br() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function jr() {
      this.Yb = function() {
        var c = [];
        return function m(S, L, B) {
          for (var U = B[L], W = 0; W < U && (S.push(B.length > L + 1 ? [] : 0), !(B.length < L + 1)); W++) m(S[W], L + 1, B);
        }(c, 0, [3, 11]), c;
      }();
    }
    function ss() {
      this.jb = s(3), this.Wc = a([4, 8], jr), this.Xc = a([4, 17], jr);
    }
    function Fo() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function os() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Mo() {
      this.Na = this.la = 0;
    }
    function as() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Hs() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ia() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new os()), this.Y = 0, this.ya = Array(new Hs()), this.aa = 0, this.l = new ls();
    }
    function vr() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Ea() {
      this.cb = this.a = 0, this.sc = "", this.m = new it(), this.Od = new er(), this.Kc = new Rr(), this.ed = new Fo(), this.Qa = new Br(), this.Ic = this.$c = this.Aa = 0, this.D = new Ia(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o(8, it), this.ia = 0, this.pb = o(4, as), this.Pa = new ss(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new vr()), this.Hd = 0, this.rb = Array(new Mo()), this.sb = 0, this.wa = Array(new os()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Hs()), this.L = this.aa = 0, this.gd = a([4, 2], os), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function ls() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Oa() {
      var c = new Ea();
      return c != null && (c.a = 0, c.sc = "OK", c.cb = 0, c.Xb = 0, el || (el = Vs)), c;
    }
    function dn(c, m, S) {
      return c.a == 0 && (c.a = m, c.sc = S, c.cb = 0), 0;
    }
    function Gs(c, m, S) {
      return 3 <= S && c[m + 0] == 157 && c[m + 1] == 1 && c[m + 2] == 42;
    }
    function Do(c, m) {
      if (c == null) return 0;
      if (c.a = 0, c.sc = "OK", m == null) return dn(c, 2, "null VP8Io passed to VP8GetHeaders()");
      var S = m.data, L = m.w, B = m.ha;
      if (4 > B) return dn(c, 7, "Truncated header.");
      var U = S[L + 0] | S[L + 1] << 8 | S[L + 2] << 16, W = c.Od;
      if (W.Rb = !(1 & U), W.td = U >> 1 & 7, W.yd = U >> 4 & 1, W.ub = U >> 5, 3 < W.td) return dn(c, 3, "Incorrect keyframe parameters.");
      if (!W.yd) return dn(c, 4, "Frame not displayable.");
      L += 3, B -= 3;
      var K = c.Kc;
      if (W.Rb) {
        if (7 > B) return dn(c, 7, "cannot parse picture header");
        if (!Gs(S, L, B)) return dn(c, 3, "Bad code word");
        K.c = 16383 & (S[L + 4] << 8 | S[L + 3]), K.Td = S[L + 4] >> 6, K.i = 16383 & (S[L + 6] << 8 | S[L + 5]), K.Ud = S[L + 6] >> 6, L += 7, B -= 7, c.za = K.c + 15 >> 4, c.Ub = K.i + 15 >> 4, m.width = K.c, m.height = K.i, m.Da = 0, m.j = 0, m.v = 0, m.va = m.width, m.o = m.height, m.da = 0, m.ib = m.width, m.hb = m.height, m.U = m.width, m.T = m.height, r((U = c.Pa).jb, 0, 255, U.jb.length), t((U = c.Qa) != null), U.Cb = 0, U.Bb = 0, U.Fb = 1, r(U.Zb, 0, 0, U.Zb.length), r(U.Lb, 0, 0, U.Lb);
      }
      if (W.ub > B) return dn(c, 7, "bad partition length");
      J(U = c.m, S, L, W.ub), L += W.ub, B -= W.ub, W.Rb && (K.Ld = gt(U), K.Kd = gt(U)), K = c.Qa;
      var Z, rt = c.Pa;
      if (t(U != null), t(K != null), K.Cb = gt(U), K.Cb) {
        if (K.Bb = gt(U), gt(U)) {
          for (K.Fb = gt(U), Z = 0; 4 > Z; ++Z) K.Zb[Z] = gt(U) ? R(U, 7) : 0;
          for (Z = 0; 4 > Z; ++Z) K.Lb[Z] = gt(U) ? R(U, 6) : 0;
        }
        if (K.Bb) for (Z = 0; 3 > Z; ++Z) rt.jb[Z] = gt(U) ? V(U, 8) : 255;
      } else K.Bb = 0;
      if (U.Ka) return dn(c, 3, "cannot parse segment header");
      if ((K = c.ed).zd = gt(U), K.Tb = V(U, 6), K.wb = V(U, 3), K.Pc = gt(U), K.Pc && gt(U)) {
        for (rt = 0; 4 > rt; ++rt) gt(U) && (K.vd[rt] = R(U, 6));
        for (rt = 0; 4 > rt; ++rt) gt(U) && (K.od[rt] = R(U, 6));
      }
      if (c.L = K.Tb == 0 ? 0 : K.zd ? 1 : 2, U.Ka) return dn(c, 3, "cannot parse filter header");
      var yt = B;
      if (B = Z = L, L = Z + yt, K = yt, c.Xb = (1 << V(c.m, 2)) - 1, yt < 3 * (rt = c.Xb)) S = 7;
      else {
        for (Z += 3 * rt, K -= 3 * rt, yt = 0; yt < rt; ++yt) {
          var Pt = S[B + 0] | S[B + 1] << 8 | S[B + 2] << 16;
          Pt > K && (Pt = K), J(c.Jc[+yt], S, Z, Pt), Z += Pt, K -= Pt, B += 3;
        }
        J(c.Jc[+rt], S, Z, K), S = Z < L ? 0 : 5;
      }
      if (S != 0) return dn(c, S, "cannot parse partitions");
      for (S = V(Z = c.m, 7), B = gt(Z) ? R(Z, 4) : 0, L = gt(Z) ? R(Z, 4) : 0, K = gt(Z) ? R(Z, 4) : 0, rt = gt(Z) ? R(Z, 4) : 0, Z = gt(Z) ? R(Z, 4) : 0, yt = c.Qa, Pt = 0; 4 > Pt; ++Pt) {
        if (yt.Cb) {
          var Lt = yt.Zb[Pt];
          yt.Fb || (Lt += S);
        } else {
          if (0 < Pt) {
            c.pb[Pt] = c.pb[0];
            continue;
          }
          Lt = S;
        }
        var At = c.pb[Pt];
        At.Sc[0] = rh[Ii(Lt + B, 127)], At.Sc[1] = sh[Ii(Lt + 0, 127)], At.Eb[0] = 2 * rh[Ii(Lt + L, 127)], At.Eb[1] = 101581 * sh[Ii(Lt + K, 127)] >> 16, 8 > At.Eb[1] && (At.Eb[1] = 8), At.Qc[0] = rh[Ii(Lt + rt, 117)], At.Qc[1] = sh[Ii(Lt + Z, 127)], At.lc = Lt + Z;
      }
      if (!W.Rb) return dn(c, 4, "Not a key frame.");
      for (gt(U), W = c.Pa, S = 0; 4 > S; ++S) {
        for (B = 0; 8 > B; ++B) for (L = 0; 3 > L; ++L) for (K = 0; 11 > K; ++K) rt = wt(U, Zm[S][B][L][K]) ? V(U, 8) : Xm[S][B][L][K], W.Wc[S][B].Yb[L][K] = rt;
        for (B = 0; 17 > B; ++B) W.Xc[S][B] = W.Wc[S][Qm[B]];
      }
      return c.kc = gt(U), c.kc && (c.Bd = V(U, 8)), c.cb = 1;
    }
    function Vs(c, m, S, L, B, U, W) {
      var K = m[B].Yb[S];
      for (S = 0; 16 > B; ++B) {
        if (!wt(c, K[S + 0])) return B;
        for (; !wt(c, K[S + 1]); ) if (K = m[++B].Yb[0], S = 0, B == 16) return 16;
        var Z = m[B + 1].Yb;
        if (wt(c, K[S + 2])) {
          var rt = c, yt = 0;
          if (wt(rt, (Lt = K)[(Pt = S) + 3])) if (wt(rt, Lt[Pt + 6])) {
            for (K = 0, Pt = 2 * (yt = wt(rt, Lt[Pt + 8])) + (Lt = wt(rt, Lt[Pt + 9 + yt])), yt = 0, Lt = Ym[Pt]; Lt[K]; ++K) yt += yt + wt(rt, Lt[K]);
            yt += 3 + (8 << Pt);
          } else wt(rt, Lt[Pt + 7]) ? (yt = 7 + 2 * wt(rt, 165), yt += wt(rt, 145)) : yt = 5 + wt(rt, 159);
          else yt = wt(rt, Lt[Pt + 4]) ? 3 + wt(rt, Lt[Pt + 5]) : 2;
          K = Z[2];
        } else yt = 1, K = Z[1];
        Z = W + Km[B], 0 > (rt = c).b && xt(rt);
        var Pt, Lt = rt.b, At = (Pt = rt.Ca >> 1) - (rt.I >> Lt) >> 31;
        --rt.b, rt.Ca += At, rt.Ca |= 1, rt.I -= (Pt + 1 & At) << Lt, U[Z] = ((yt ^ At) - At) * L[(0 < B) + 0];
      }
      return 16;
    }
    function Ys(c) {
      var m = c.rb[c.sb - 1];
      m.la = 0, m.Na = 0, r(c.zc, 0, 0, c.zc.length), c.ja = 0;
    }
    function Ta(c, m) {
      if (c == null) return 0;
      if (m == null) return dn(c, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!c.cb && !Do(c, m)) return 0;
      if (t(c.cb), m.ac == null || m.ac(m)) {
        m.ob && (c.L = 0);
        var S = cu[c.L];
        if (c.L == 2 ? (c.yb = 0, c.zb = 0) : (c.yb = m.v - S >> 4, c.zb = m.j - S >> 4, 0 > c.yb && (c.yb = 0), 0 > c.zb && (c.zb = 0)), c.Va = m.o + 15 + S >> 4, c.Hb = m.va + 15 + S >> 4, c.Hb > c.za && (c.Hb = c.za), c.Va > c.Ub && (c.Va = c.Ub), 0 < c.L) {
          var L = c.ed;
          for (S = 0; 4 > S; ++S) {
            var B;
            if (c.Qa.Cb) {
              var U = c.Qa.Lb[S];
              c.Qa.Fb || (U += L.Tb);
            } else U = L.Tb;
            for (B = 0; 1 >= B; ++B) {
              var W = c.gd[S][B], K = U;
              if (L.Pc && (K += L.vd[0], B && (K += L.od[0])), 0 < (K = 0 > K ? 0 : 63 < K ? 63 : K)) {
                var Z = K;
                0 < L.wb && (Z = 4 < L.wb ? Z >> 2 : Z >> 1) > 9 - L.wb && (Z = 9 - L.wb), 1 > Z && (Z = 1), W.dd = Z, W.tc = 2 * K + Z, W.ld = 40 <= K ? 2 : 15 <= K ? 1 : 0;
              } else W.tc = 0;
              W.La = B;
            }
          }
        }
        S = 0;
      } else dn(c, 6, "Frame setup failed"), S = c.a;
      if (S = S == 0) {
        if (S) {
          c.$c = 0, 0 < c.Aa || (c.Ic = f2);
          t: {
            S = c.Ic, L = 4 * (Z = c.za);
            var rt = 32 * Z, yt = Z + 1, Pt = 0 < c.L ? Z * (0 < c.Aa ? 2 : 1) : 0, Lt = (c.Aa == 2 ? 2 : 1) * Z;
            if ((W = L + 832 + (B = 3 * (16 * S + cu[c.L]) / 2 * rt) + (U = c.Fa != null && 0 < c.Fa.length ? c.Kc.c * c.Kc.i : 0)) != W) S = 0;
            else {
              if (W > c.Vb) {
                if (c.Vb = 0, c.Ec = s(W), c.Fc = 0, c.Ec == null) {
                  S = dn(c, 1, "no memory during frame initialization.");
                  break t;
                }
                c.Vb = W;
              }
              W = c.Ec, K = c.Fc, c.Ac = W, c.Bc = K, K += L, c.Gd = o(rt, vr), c.Hd = 0, c.rb = o(yt + 1, Mo), c.sb = 1, c.wa = Pt ? o(Pt, os) : null, c.Y = 0, c.D.Nb = 0, c.D.wa = c.wa, c.D.Y = c.Y, 0 < c.Aa && (c.D.Y += Z), t(!0), c.oc = W, c.pc = K, K += 832, c.ya = o(Lt, Hs), c.aa = 0, c.D.ya = c.ya, c.D.aa = c.aa, c.Aa == 2 && (c.D.aa += Z), c.R = 16 * Z, c.B = 8 * Z, Z = (rt = cu[c.L]) * c.R, rt = rt / 2 * c.B, c.sa = W, c.ta = K + Z, c.qa = c.sa, c.ra = c.ta + 16 * S * c.R + rt, c.Ha = c.qa, c.Ia = c.ra + 8 * S * c.B + rt, c.$c = 0, K += B, c.mb = U ? W : null, c.nb = U ? K : null, t(K + U <= c.Fc + c.Vb), Ys(c), r(c.Ac, c.Bc, 0, L), S = 1;
            }
          }
          if (S) {
            if (m.ka = 0, m.y = c.sa, m.O = c.ta, m.f = c.qa, m.N = c.ra, m.ea = c.Ha, m.Vd = c.Ia, m.fa = c.R, m.Rc = c.B, m.F = null, m.J = 0, !eu) {
              for (S = -255; 255 >= S; ++S) Dn[255 + S] = 0 > S ? -S : S;
              for (S = -1020; 1020 >= S; ++S) Gr[1020 + S] = -128 > S ? -128 : 127 < S ? 127 : S;
              for (S = -112; 112 >= S; ++S) tl[112 + S] = -16 > S ? -16 : 15 < S ? 15 : S;
              for (S = -255; 510 >= S; ++S) Jo[255 + S] = 0 > S ? 0 : 255 < S ? 255 : S;
              eu = 1;
            }
            Yo = Ma, Hr = hs, Ja = Xs, fi = Fa, Ui = Ro, kn = Ks, Ko = Ba, tu = Qs, Za = Xc, no = ja, io = Kc, vs = jo, ro = qa, Xo = Yl, so = Vl, ws = wr, Qa = $r, Wi = Yc, rr[0] = zi, rr[1] = mt, rr[2] = be, rr[3] = Li, rr[4] = qr, rr[5] = zr, rr[6] = fs, rr[7] = ds, rr[8] = Hc, rr[9] = Wc, xs[0] = Fe, xs[1] = Bt, xs[2] = Ft, xs[3] = me, xs[4] = Re, xs[5] = pn, xs[6] = Pe, Vr[0] = ps, Vr[1] = dt, Vr[2] = Gc, Vr[3] = Da, Vr[4] = Zs, Vr[5] = Vc, Vr[6] = Ra, S = 1;
          } else S = 0;
        }
        S && (S = function(At, Ht) {
          for (At.M = 0; At.M < At.Va; ++At.M) {
            var Mt, bt = At.Jc[At.M & At.Xb], _t = At.m, Ut = At;
            for (Mt = 0; Mt < Ut.za; ++Mt) {
              var Gt = _t, Wt = Ut, ue = Wt.Ac, ee = Wt.Bc + 4 * Mt, _e = Wt.zc, re = Wt.ya[Wt.aa + Mt];
              if (Wt.Qa.Bb ? re.$b = wt(Gt, Wt.Pa.jb[0]) ? 2 + wt(Gt, Wt.Pa.jb[2]) : wt(Gt, Wt.Pa.jb[1]) : re.$b = 0, Wt.kc && (re.Ad = wt(Gt, Wt.Bd)), re.Za = !wt(Gt, 145) + 0, re.Za) {
                var Ke = re.Ob, Qe = 0;
                for (Wt = 0; 4 > Wt; ++Wt) {
                  var We, je = _e[0 + Wt];
                  for (We = 0; 4 > We; ++We) {
                    je = Jm[ue[ee + We]][je];
                    for (var on = Vd[wt(Gt, je[0])]; 0 < on; ) on = Vd[2 * on + wt(Gt, je[on])];
                    je = -on, ue[ee + We] = je;
                  }
                  i(Ke, Qe, ue, ee, 4), Qe += 4, _e[0 + Wt] = je;
                }
              } else je = wt(Gt, 156) ? wt(Gt, 128) ? 1 : 3 : wt(Gt, 163) ? 2 : 0, re.Ob[0] = je, r(ue, ee, je, 4), r(_e, 0, je, 4);
              re.Dd = wt(Gt, 142) ? wt(Gt, 114) ? wt(Gt, 183) ? 1 : 3 : 2 : 0;
            }
            if (Ut.m.Ka) return dn(At, 7, "Premature end-of-partition0 encountered.");
            for (; At.ja < At.za; ++At.ja) {
              if (Ut = bt, Gt = (_t = At).rb[_t.sb - 1], ue = _t.rb[_t.sb + _t.ja], Mt = _t.ya[_t.aa + _t.ja], ee = _t.kc ? Mt.Ad : 0) Gt.la = ue.la = 0, Mt.Za || (Gt.Na = ue.Na = 0), Mt.Hc = 0, Mt.Gc = 0, Mt.ia = 0;
              else {
                var nn, Me;
                if (Gt = ue, ue = Ut, ee = _t.Pa.Xc, _e = _t.ya[_t.aa + _t.ja], re = _t.pb[_e.$b], Wt = _e.ad, Ke = 0, Qe = _t.rb[_t.sb - 1], je = We = 0, r(Wt, Ke, 0, 384), _e.Za) var On = 0, vi = ee[3];
                else {
                  on = s(16);
                  var Tn = Gt.Na + Qe.Na;
                  if (Tn = el(ue, ee[1], Tn, re.Eb, 0, on, 0), Gt.Na = Qe.Na = (0 < Tn) + 0, 1 < Tn) Yo(on, 0, Wt, Ke);
                  else {
                    var wi = on[0] + 3 >> 3;
                    for (on = 0; 256 > on; on += 16) Wt[Ke + on] = wi;
                  }
                  On = 1, vi = ee[0];
                }
                var tn = 15 & Gt.la, Oi = 15 & Qe.la;
                for (on = 0; 4 > on; ++on) {
                  var Ti = 1 & Oi;
                  for (wi = Me = 0; 4 > wi; ++wi) tn = tn >> 1 | (Ti = (Tn = el(ue, vi, Tn = Ti + (1 & tn), re.Sc, On, Wt, Ke)) > On) << 7, Me = Me << 2 | (3 < Tn ? 3 : 1 < Tn ? 2 : Wt[Ke + 0] != 0), Ke += 16;
                  tn >>= 4, Oi = Oi >> 1 | Ti << 7, We = (We << 8 | Me) >>> 0;
                }
                for (vi = tn, On = Oi >> 4, nn = 0; 4 > nn; nn += 2) {
                  for (Me = 0, tn = Gt.la >> 4 + nn, Oi = Qe.la >> 4 + nn, on = 0; 2 > on; ++on) {
                    for (Ti = 1 & Oi, wi = 0; 2 > wi; ++wi) Tn = Ti + (1 & tn), tn = tn >> 1 | (Ti = 0 < (Tn = el(ue, ee[2], Tn, re.Qc, 0, Wt, Ke))) << 3, Me = Me << 2 | (3 < Tn ? 3 : 1 < Tn ? 2 : Wt[Ke + 0] != 0), Ke += 16;
                    tn >>= 2, Oi = Oi >> 1 | Ti << 5;
                  }
                  je |= Me << 4 * nn, vi |= tn << 4 << nn, On |= (240 & Oi) << nn;
                }
                Gt.la = vi, Qe.la = On, _e.Hc = We, _e.Gc = je, _e.ia = 43690 & je ? 0 : re.ia, ee = !(We | je);
              }
              if (0 < _t.L && (_t.wa[_t.Y + _t.ja] = _t.gd[Mt.$b][Mt.Za], _t.wa[_t.Y + _t.ja].La |= !ee), Ut.Ka) return dn(At, 7, "Premature end-of-file encountered.");
            }
            if (Ys(At), _t = Ht, Ut = 1, Mt = (bt = At).D, Gt = 0 < bt.L && bt.M >= bt.zb && bt.M <= bt.Va, bt.Aa == 0) t: {
              if (Mt.M = bt.M, Mt.uc = Gt, Ga(bt, Mt), Ut = 1, Mt = (Me = bt.D).Nb, Gt = (je = cu[bt.L]) * bt.R, ue = je / 2 * bt.B, on = 16 * Mt * bt.R, wi = 8 * Mt * bt.B, ee = bt.sa, _e = bt.ta - Gt + on, re = bt.qa, Wt = bt.ra - ue + wi, Ke = bt.Ha, Qe = bt.Ia - ue + wi, Oi = (tn = Me.M) == 0, We = tn >= bt.Va - 1, bt.Aa == 2 && Ga(bt, Me), Me.uc) for (Ti = (Tn = bt).D.M, t(Tn.D.uc), Me = Tn.yb; Me < Tn.Hb; ++Me) {
                On = Me, vi = Ti;
                var $n = (Yn = (xn = Tn).D).Nb;
                nn = xn.R;
                var Yn = Yn.wa[Yn.Y + On], di = xn.sa, Yi = xn.ta + 16 * $n * nn + 16 * On, _r = Yn.dd, Un = Yn.tc;
                if (Un != 0) if (t(3 <= Un), xn.L == 1) 0 < On && ws(di, Yi, nn, Un + 4), Yn.La && Wi(di, Yi, nn, Un), 0 < vi && so(di, Yi, nn, Un + 4), Yn.La && Qa(di, Yi, nn, Un);
                else {
                  var Yr = xn.B, oo = xn.qa, Zo = xn.ra + 8 * $n * Yr + 8 * On, Ss = xn.Ha, xn = xn.Ia + 8 * $n * Yr + 8 * On;
                  $n = Yn.ld, 0 < On && (tu(di, Yi, nn, Un + 4, _r, $n), no(oo, Zo, Ss, xn, Yr, Un + 4, _r, $n)), Yn.La && (vs(di, Yi, nn, Un, _r, $n), Xo(oo, Zo, Ss, xn, Yr, Un, _r, $n)), 0 < vi && (Ko(di, Yi, nn, Un + 4, _r, $n), Za(oo, Zo, Ss, xn, Yr, Un + 4, _r, $n)), Yn.La && (io(di, Yi, nn, Un, _r, $n), ro(oo, Zo, Ss, xn, Yr, Un, _r, $n));
                }
              }
              if (bt.ia && alert("todo:DitherRow"), _t.put != null) {
                if (Me = 16 * tn, tn = 16 * (tn + 1), Oi ? (_t.y = bt.sa, _t.O = bt.ta + on, _t.f = bt.qa, _t.N = bt.ra + wi, _t.ea = bt.Ha, _t.W = bt.Ia + wi) : (Me -= je, _t.y = ee, _t.O = _e, _t.f = re, _t.N = Wt, _t.ea = Ke, _t.W = Qe), We || (tn -= je), tn > _t.o && (tn = _t.o), _t.F = null, _t.J = null, bt.Fa != null && 0 < bt.Fa.length && Me < tn && (_t.J = Wa(bt, _t, Me, tn - Me), _t.F = bt.mb, _t.F == null && _t.F.length == 0)) {
                  Ut = dn(bt, 3, "Could not decode alpha data.");
                  break t;
                }
                Me < _t.j && (je = _t.j - Me, Me = _t.j, t(!(1 & je)), _t.O += bt.R * je, _t.N += bt.B * (je >> 1), _t.W += bt.B * (je >> 1), _t.F != null && (_t.J += _t.width * je)), Me < tn && (_t.O += _t.v, _t.N += _t.v >> 1, _t.W += _t.v >> 1, _t.F != null && (_t.J += _t.v), _t.ka = Me - _t.j, _t.U = _t.va - _t.v, _t.T = tn - Me, Ut = _t.put(_t));
              }
              Mt + 1 != bt.Ic || We || (i(bt.sa, bt.ta - Gt, ee, _e + 16 * bt.R, Gt), i(bt.qa, bt.ra - ue, re, Wt + 8 * bt.B, ue), i(bt.Ha, bt.Ia - ue, Ke, Qe + 8 * bt.B, ue));
            }
            if (!Ut) return dn(At, 6, "Output aborted.");
          }
          return 1;
        }(c, m)), m.bc != null && m.bc(m), S &= 1;
      }
      return S ? (c.cb = 0, S) : 0;
    }
    function In(c, m, S, L, B) {
      B = c[m + S + 32 * L] + (B >> 3), c[m + S + 32 * L] = -256 & B ? 0 > B ? 0 : 255 : B;
    }
    function us(c, m, S, L, B, U) {
      In(c, m, 0, S, L + B), In(c, m, 1, S, L + U), In(c, m, 2, S, L - U), In(c, m, 3, S, L - B);
    }
    function ei(c) {
      return (20091 * c >> 16) + c;
    }
    function cs(c, m, S, L) {
      var B, U = 0, W = s(16);
      for (B = 0; 4 > B; ++B) {
        var K = c[m + 0] + c[m + 8], Z = c[m + 0] - c[m + 8], rt = (35468 * c[m + 4] >> 16) - ei(c[m + 12]), yt = ei(c[m + 4]) + (35468 * c[m + 12] >> 16);
        W[U + 0] = K + yt, W[U + 1] = Z + rt, W[U + 2] = Z - rt, W[U + 3] = K - yt, U += 4, m++;
      }
      for (B = U = 0; 4 > B; ++B) K = (c = W[U + 0] + 4) + W[U + 8], Z = c - W[U + 8], rt = (35468 * W[U + 4] >> 16) - ei(W[U + 12]), In(S, L, 0, 0, K + (yt = ei(W[U + 4]) + (35468 * W[U + 12] >> 16))), In(S, L, 1, 0, Z + rt), In(S, L, 2, 0, Z - rt), In(S, L, 3, 0, K - yt), U++, L += 32;
    }
    function Ks(c, m, S, L) {
      var B = c[m + 0] + 4, U = 35468 * c[m + 4] >> 16, W = ei(c[m + 4]), K = 35468 * c[m + 1] >> 16;
      us(S, L, 0, B + W, c = ei(c[m + 1]), K), us(S, L, 1, B + U, c, K), us(S, L, 2, B - U, c, K), us(S, L, 3, B - W, c, K);
    }
    function hs(c, m, S, L, B) {
      cs(c, m, S, L), B && cs(c, m + 16, S, L + 4);
    }
    function Xs(c, m, S, L) {
      Hr(c, m + 0, S, L, 1), Hr(c, m + 32, S, L + 128, 1);
    }
    function Fa(c, m, S, L) {
      var B;
      for (c = c[m + 0] + 4, B = 0; 4 > B; ++B) for (m = 0; 4 > m; ++m) In(S, L, m, B, c);
    }
    function Ro(c, m, S, L) {
      c[m + 0] && fi(c, m + 0, S, L), c[m + 16] && fi(c, m + 16, S, L + 4), c[m + 32] && fi(c, m + 32, S, L + 128), c[m + 48] && fi(c, m + 48, S, L + 128 + 4);
    }
    function Ma(c, m, S, L) {
      var B, U = s(16);
      for (B = 0; 4 > B; ++B) {
        var W = c[m + 0 + B] + c[m + 12 + B], K = c[m + 4 + B] + c[m + 8 + B], Z = c[m + 4 + B] - c[m + 8 + B], rt = c[m + 0 + B] - c[m + 12 + B];
        U[0 + B] = W + K, U[8 + B] = W - K, U[4 + B] = rt + Z, U[12 + B] = rt - Z;
      }
      for (B = 0; 4 > B; ++B) W = (c = U[0 + 4 * B] + 3) + U[3 + 4 * B], K = U[1 + 4 * B] + U[2 + 4 * B], Z = U[1 + 4 * B] - U[2 + 4 * B], rt = c - U[3 + 4 * B], S[L + 0] = W + K >> 3, S[L + 16] = rt + Z >> 3, S[L + 32] = W - K >> 3, S[L + 48] = rt - Z >> 3, L += 64;
    }
    function Q(c, m, S) {
      var L, B = m - 32, U = Ei, W = 255 - c[B - 1];
      for (L = 0; L < S; ++L) {
        var K, Z = U, rt = W + c[m - 1];
        for (K = 0; K < S; ++K) c[m + K] = Z[rt + c[B + K]];
        m += 32;
      }
    }
    function mt(c, m) {
      Q(c, m, 4);
    }
    function dt(c, m) {
      Q(c, m, 8);
    }
    function Bt(c, m) {
      Q(c, m, 16);
    }
    function Ft(c, m) {
      var S;
      for (S = 0; 16 > S; ++S) i(c, m + 32 * S, c, m - 32, 16);
    }
    function me(c, m) {
      var S;
      for (S = 16; 0 < S; --S) r(c, m, c[m - 1], 16), m += 32;
    }
    function ge(c, m, S) {
      var L;
      for (L = 0; 16 > L; ++L) r(m, S + 32 * L, c, 16);
    }
    function Fe(c, m) {
      var S, L = 16;
      for (S = 0; 16 > S; ++S) L += c[m - 1 + 32 * S] + c[m + S - 32];
      ge(L >> 5, c, m);
    }
    function Re(c, m) {
      var S, L = 8;
      for (S = 0; 16 > S; ++S) L += c[m - 1 + 32 * S];
      ge(L >> 4, c, m);
    }
    function pn(c, m) {
      var S, L = 8;
      for (S = 0; 16 > S; ++S) L += c[m + S - 32];
      ge(L >> 4, c, m);
    }
    function Pe(c, m) {
      ge(128, c, m);
    }
    function se(c, m, S) {
      return c + 2 * m + S + 2 >> 2;
    }
    function be(c, m) {
      var S, L = m - 32;
      for (L = new Uint8Array([se(c[L - 1], c[L + 0], c[L + 1]), se(c[L + 0], c[L + 1], c[L + 2]), se(c[L + 1], c[L + 2], c[L + 3]), se(c[L + 2], c[L + 3], c[L + 4])]), S = 0; 4 > S; ++S) i(c, m + 32 * S, L, 0, L.length);
    }
    function Li(c, m) {
      var S = c[m - 1], L = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 + 96];
      qt(c, m + 0, 16843009 * se(c[m - 1 - 32], S, L)), qt(c, m + 32, 16843009 * se(S, L, B)), qt(c, m + 64, 16843009 * se(L, B, U)), qt(c, m + 96, 16843009 * se(B, U, U));
    }
    function zi(c, m) {
      var S, L = 4;
      for (S = 0; 4 > S; ++S) L += c[m + S - 32] + c[m - 1 + 32 * S];
      for (L >>= 3, S = 0; 4 > S; ++S) r(c, m + 32 * S, L, 4);
    }
    function qr(c, m) {
      var S = c[m - 1 + 0], L = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 - 32], W = c[m + 0 - 32], K = c[m + 1 - 32], Z = c[m + 2 - 32], rt = c[m + 3 - 32];
      c[m + 0 + 96] = se(L, B, c[m - 1 + 96]), c[m + 1 + 96] = c[m + 0 + 64] = se(S, L, B), c[m + 2 + 96] = c[m + 1 + 64] = c[m + 0 + 32] = se(U, S, L), c[m + 3 + 96] = c[m + 2 + 64] = c[m + 1 + 32] = c[m + 0 + 0] = se(W, U, S), c[m + 3 + 64] = c[m + 2 + 32] = c[m + 1 + 0] = se(K, W, U), c[m + 3 + 32] = c[m + 2 + 0] = se(Z, K, W), c[m + 3 + 0] = se(rt, Z, K);
    }
    function fs(c, m) {
      var S = c[m + 1 - 32], L = c[m + 2 - 32], B = c[m + 3 - 32], U = c[m + 4 - 32], W = c[m + 5 - 32], K = c[m + 6 - 32], Z = c[m + 7 - 32];
      c[m + 0 + 0] = se(c[m + 0 - 32], S, L), c[m + 1 + 0] = c[m + 0 + 32] = se(S, L, B), c[m + 2 + 0] = c[m + 1 + 32] = c[m + 0 + 64] = se(L, B, U), c[m + 3 + 0] = c[m + 2 + 32] = c[m + 1 + 64] = c[m + 0 + 96] = se(B, U, W), c[m + 3 + 32] = c[m + 2 + 64] = c[m + 1 + 96] = se(U, W, K), c[m + 3 + 64] = c[m + 2 + 96] = se(W, K, Z), c[m + 3 + 96] = se(K, Z, Z);
    }
    function zr(c, m) {
      var S = c[m - 1 + 0], L = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 - 32], W = c[m + 0 - 32], K = c[m + 1 - 32], Z = c[m + 2 - 32], rt = c[m + 3 - 32];
      c[m + 0 + 0] = c[m + 1 + 64] = U + W + 1 >> 1, c[m + 1 + 0] = c[m + 2 + 64] = W + K + 1 >> 1, c[m + 2 + 0] = c[m + 3 + 64] = K + Z + 1 >> 1, c[m + 3 + 0] = Z + rt + 1 >> 1, c[m + 0 + 96] = se(B, L, S), c[m + 0 + 64] = se(L, S, U), c[m + 0 + 32] = c[m + 1 + 96] = se(S, U, W), c[m + 1 + 32] = c[m + 2 + 96] = se(U, W, K), c[m + 2 + 32] = c[m + 3 + 96] = se(W, K, Z), c[m + 3 + 32] = se(K, Z, rt);
    }
    function ds(c, m) {
      var S = c[m + 0 - 32], L = c[m + 1 - 32], B = c[m + 2 - 32], U = c[m + 3 - 32], W = c[m + 4 - 32], K = c[m + 5 - 32], Z = c[m + 6 - 32], rt = c[m + 7 - 32];
      c[m + 0 + 0] = S + L + 1 >> 1, c[m + 1 + 0] = c[m + 0 + 64] = L + B + 1 >> 1, c[m + 2 + 0] = c[m + 1 + 64] = B + U + 1 >> 1, c[m + 3 + 0] = c[m + 2 + 64] = U + W + 1 >> 1, c[m + 0 + 32] = se(S, L, B), c[m + 1 + 32] = c[m + 0 + 96] = se(L, B, U), c[m + 2 + 32] = c[m + 1 + 96] = se(B, U, W), c[m + 3 + 32] = c[m + 2 + 96] = se(U, W, K), c[m + 3 + 64] = se(W, K, Z), c[m + 3 + 96] = se(K, Z, rt);
    }
    function Wc(c, m) {
      var S = c[m - 1 + 0], L = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 + 96];
      c[m + 0 + 0] = S + L + 1 >> 1, c[m + 2 + 0] = c[m + 0 + 32] = L + B + 1 >> 1, c[m + 2 + 32] = c[m + 0 + 64] = B + U + 1 >> 1, c[m + 1 + 0] = se(S, L, B), c[m + 3 + 0] = c[m + 1 + 32] = se(L, B, U), c[m + 3 + 32] = c[m + 1 + 64] = se(B, U, U), c[m + 3 + 64] = c[m + 2 + 64] = c[m + 0 + 96] = c[m + 1 + 96] = c[m + 2 + 96] = c[m + 3 + 96] = U;
    }
    function Hc(c, m) {
      var S = c[m - 1 + 0], L = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 + 96], W = c[m - 1 - 32], K = c[m + 0 - 32], Z = c[m + 1 - 32], rt = c[m + 2 - 32];
      c[m + 0 + 0] = c[m + 2 + 32] = S + W + 1 >> 1, c[m + 0 + 32] = c[m + 2 + 64] = L + S + 1 >> 1, c[m + 0 + 64] = c[m + 2 + 96] = B + L + 1 >> 1, c[m + 0 + 96] = U + B + 1 >> 1, c[m + 3 + 0] = se(K, Z, rt), c[m + 2 + 0] = se(W, K, Z), c[m + 1 + 0] = c[m + 3 + 32] = se(S, W, K), c[m + 1 + 32] = c[m + 3 + 64] = se(L, S, W), c[m + 1 + 64] = c[m + 3 + 96] = se(B, L, S), c[m + 1 + 96] = se(U, B, L);
    }
    function Gc(c, m) {
      var S;
      for (S = 0; 8 > S; ++S) i(c, m + 32 * S, c, m - 32, 8);
    }
    function Da(c, m) {
      var S;
      for (S = 0; 8 > S; ++S) r(c, m, c[m - 1], 8), m += 32;
    }
    function Js(c, m, S) {
      var L;
      for (L = 0; 8 > L; ++L) r(m, S + 32 * L, c, 8);
    }
    function ps(c, m) {
      var S, L = 8;
      for (S = 0; 8 > S; ++S) L += c[m + S - 32] + c[m - 1 + 32 * S];
      Js(L >> 4, c, m);
    }
    function Vc(c, m) {
      var S, L = 4;
      for (S = 0; 8 > S; ++S) L += c[m + S - 32];
      Js(L >> 3, c, m);
    }
    function Zs(c, m) {
      var S, L = 4;
      for (S = 0; 8 > S; ++S) L += c[m - 1 + 32 * S];
      Js(L >> 3, c, m);
    }
    function Ra(c, m) {
      Js(128, c, m);
    }
    function Bo(c, m, S) {
      var L = c[m - S], B = c[m + 0], U = 3 * (B - L) + Qc[1020 + c[m - 2 * S] - c[m + S]], W = nu[112 + (U + 4 >> 3)];
      c[m - S] = Ei[255 + L + nu[112 + (U + 3 >> 3)]], c[m + 0] = Ei[255 + B - W];
    }
    function Wl(c, m, S, L) {
      var B = c[m + 0], U = c[m + S];
      return Gi[255 + c[m - 2 * S] - c[m - S]] > L || Gi[255 + U - B] > L;
    }
    function Hl(c, m, S, L) {
      return 4 * Gi[255 + c[m - S] - c[m + 0]] + Gi[255 + c[m - 2 * S] - c[m + S]] <= L;
    }
    function Gl(c, m, S, L, B) {
      var U = c[m - 3 * S], W = c[m - 2 * S], K = c[m - S], Z = c[m + 0], rt = c[m + S], yt = c[m + 2 * S], Pt = c[m + 3 * S];
      return 4 * Gi[255 + K - Z] + Gi[255 + W - rt] > L ? 0 : Gi[255 + c[m - 4 * S] - U] <= B && Gi[255 + U - W] <= B && Gi[255 + W - K] <= B && Gi[255 + Pt - yt] <= B && Gi[255 + yt - rt] <= B && Gi[255 + rt - Z] <= B;
    }
    function Vl(c, m, S, L) {
      var B = 2 * L + 1;
      for (L = 0; 16 > L; ++L) Hl(c, m + L, S, B) && Bo(c, m + L, S);
    }
    function wr(c, m, S, L) {
      var B = 2 * L + 1;
      for (L = 0; 16 > L; ++L) Hl(c, m + L * S, 1, B) && Bo(c, m + L * S, 1);
    }
    function $r(c, m, S, L) {
      var B;
      for (B = 3; 0 < B; --B) Vl(c, m += 4 * S, S, L);
    }
    function Yc(c, m, S, L) {
      var B;
      for (B = 3; 0 < B; --B) wr(c, m += 4, S, L);
    }
    function gs(c, m, S, L, B, U, W, K) {
      for (U = 2 * U + 1; 0 < B--; ) {
        if (Gl(c, m, S, U, W)) if (Wl(c, m, S, K)) Bo(c, m, S);
        else {
          var Z = c, rt = m, yt = S, Pt = Z[rt - 2 * yt], Lt = Z[rt - yt], At = Z[rt + 0], Ht = Z[rt + yt], Mt = Z[rt + 2 * yt], bt = 27 * (Ut = Qc[1020 + 3 * (At - Lt) + Qc[1020 + Pt - Ht]]) + 63 >> 7, _t = 18 * Ut + 63 >> 7, Ut = 9 * Ut + 63 >> 7;
          Z[rt - 3 * yt] = Ei[255 + Z[rt - 3 * yt] + Ut], Z[rt - 2 * yt] = Ei[255 + Pt + _t], Z[rt - yt] = Ei[255 + Lt + bt], Z[rt + 0] = Ei[255 + At - bt], Z[rt + yt] = Ei[255 + Ht - _t], Z[rt + 2 * yt] = Ei[255 + Mt - Ut];
        }
        m += L;
      }
    }
    function nr(c, m, S, L, B, U, W, K) {
      for (U = 2 * U + 1; 0 < B--; ) {
        if (Gl(c, m, S, U, W)) if (Wl(c, m, S, K)) Bo(c, m, S);
        else {
          var Z = c, rt = m, yt = S, Pt = Z[rt - yt], Lt = Z[rt + 0], At = Z[rt + yt], Ht = nu[112 + ((Mt = 3 * (Lt - Pt)) + 4 >> 3)], Mt = nu[112 + (Mt + 3 >> 3)], bt = Ht + 1 >> 1;
          Z[rt - 2 * yt] = Ei[255 + Z[rt - 2 * yt] + bt], Z[rt - yt] = Ei[255 + Pt + Mt], Z[rt + 0] = Ei[255 + Lt - Ht], Z[rt + yt] = Ei[255 + At - bt];
        }
        m += L;
      }
    }
    function Ba(c, m, S, L, B, U) {
      gs(c, m, S, 1, 16, L, B, U);
    }
    function Qs(c, m, S, L, B, U) {
      gs(c, m, 1, S, 16, L, B, U);
    }
    function Kc(c, m, S, L, B, U) {
      var W;
      for (W = 3; 0 < W; --W) nr(c, m += 4 * S, S, 1, 16, L, B, U);
    }
    function jo(c, m, S, L, B, U) {
      var W;
      for (W = 3; 0 < W; --W) nr(c, m += 4, 1, S, 16, L, B, U);
    }
    function Xc(c, m, S, L, B, U, W, K) {
      gs(c, m, B, 1, 8, U, W, K), gs(S, L, B, 1, 8, U, W, K);
    }
    function ja(c, m, S, L, B, U, W, K) {
      gs(c, m, 1, B, 8, U, W, K), gs(S, L, 1, B, 8, U, W, K);
    }
    function qa(c, m, S, L, B, U, W, K) {
      nr(c, m + 4 * B, B, 1, 8, U, W, K), nr(S, L + 4 * B, B, 1, 8, U, W, K);
    }
    function Yl(c, m, S, L, B, U, W, K) {
      nr(c, m + 4, 1, B, 8, U, W, K), nr(S, L + 4, 1, B, 8, U, W, K);
    }
    function qo() {
      this.ba = new Sn(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Ze(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function za() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function $a() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Kl() {
      this.ua = 0, this.Wa = new $(), this.vb = new $(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new _(), this.yc = new A();
    }
    function Jc() {
      this.xb = this.a = 0, this.l = new ls(), this.ca = new Sn(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N(), this.Pb = 0, this.wd = new N(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Kl(), this.ab = 0, this.gc = o(4, $a), this.Oc = 0;
    }
    function zo() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new ls(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function to(c, m, S, L, B, U, W) {
      for (c = c == null ? 0 : c[m + 0], m = 0; m < W; ++m) B[U + m] = c + S[L + m] & 255, c = B[U + m];
    }
    function Ua(c, m, S, L, B, U, W) {
      var K;
      if (c == null) to(null, null, S, L, B, U, W);
      else for (K = 0; K < W; ++K) B[U + K] = c[m + K] + S[L + K] & 255;
    }
    function ms(c, m, S, L, B, U, W) {
      if (c == null) to(null, null, S, L, B, U, W);
      else {
        var K, Z = c[m + 0], rt = Z, yt = Z;
        for (K = 0; K < W; ++K) rt = yt + (Z = c[m + K]) - rt, yt = S[L + K] + (-256 & rt ? 0 > rt ? 0 : 255 : rt) & 255, rt = Z, B[U + K] = yt;
      }
    }
    function Wa(c, m, S, L) {
      var B = m.width, U = m.o;
      if (t(c != null && m != null), 0 > S || 0 >= L || S + L > U) return null;
      if (!c.Cc) {
        if (c.ga == null) {
          var W;
          if (c.ga = new zo(), (W = c.ga == null) || (W = m.width * m.o, t(c.Gb.length == 0), c.Gb = s(W), c.Uc = 0, c.Gb == null ? W = 0 : (c.mb = c.Gb, c.nb = c.Uc, c.rc = null, W = 1), W = !W), !W) {
            W = c.ga;
            var K = c.Fa, Z = c.P, rt = c.qc, yt = c.mb, Pt = c.nb, Lt = Z + 1, At = rt - 1, Ht = W.l;
            if (t(K != null && yt != null && m != null), _s[0] = null, _s[1] = to, _s[2] = Ua, _s[3] = ms, W.ca = yt, W.tb = Pt, W.c = m.width, W.i = m.height, t(0 < W.c && 0 < W.i), 1 >= rt) m = 0;
            else if (W.$a = K[Z + 0] >> 0 & 3, W.Z = K[Z + 0] >> 2 & 3, W.Lc = K[Z + 0] >> 4 & 3, Z = K[Z + 0] >> 6 & 3, 0 > W.$a || 1 < W.$a || 4 <= W.Z || 1 < W.Lc || Z) m = 0;
            else if (Ht.put = Ri, Ht.ac = yn, Ht.bc = qn, Ht.ma = W, Ht.width = m.width, Ht.height = m.height, Ht.Da = m.Da, Ht.v = m.v, Ht.va = m.va, Ht.j = m.j, Ht.o = m.o, W.$a) t: {
              t(W.$a == 1), m = Pi();
              e: for (; ; ) {
                if (m == null) {
                  m = 0;
                  break t;
                }
                if (t(W != null), W.mc = m, m.c = W.c, m.i = W.i, m.l = W.l, m.l.ma = W, m.l.width = W.c, m.l.height = W.i, m.a = 0, tt(m.m, K, Lt, At), !qi(W.c, W.i, 1, m, null) || (m.ab == 1 && m.gc[0].hc == 3 && tr(m.s) ? (W.ic = 1, K = m.c * m.i, m.Ta = null, m.Ua = 0, m.V = s(K), m.Ba = 0, m.V == null ? (m.a = 1, m = 0) : m = 1) : (W.ic = 0, m = br(m, W.c)), !m)) break e;
                m = 1;
                break t;
              }
              W.mc = null, m = 0;
            }
            else m = At >= W.c * W.i;
            W = !m;
          }
          if (W) return null;
          c.ga.Lc != 1 ? c.Ga = 0 : L = U - S;
        }
        t(c.ga != null), t(S + L <= U);
        t: {
          if (m = (K = c.ga).c, U = K.l.o, K.$a == 0) {
            if (Lt = c.rc, At = c.Vc, Ht = c.Fa, Z = c.P + 1 + S * m, rt = c.mb, yt = c.nb + S * m, t(Z <= c.P + c.qc), K.Z != 0) for (t(_s[K.Z] != null), W = 0; W < L; ++W) _s[K.Z](Lt, At, Ht, Z, rt, yt, m), Lt = rt, At = yt, yt += m, Z += m;
            else for (W = 0; W < L; ++W) i(rt, yt, Ht, Z, m), Lt = rt, At = yt, yt += m, Z += m;
            c.rc = Lt, c.Vc = At;
          } else {
            if (t(K.mc != null), m = S + L, t((W = K.mc) != null), t(m <= W.i), W.C >= m) m = 1;
            else if (K.ic || Ct(), K.ic) {
              K = W.V, Lt = W.Ba, At = W.c;
              var Mt = W.i, bt = (Ht = 1, Z = W.$ / At, rt = W.$ % At, yt = W.m, Pt = W.s, W.$), _t = At * Mt, Ut = At * m, Gt = Pt.wc, Wt = bt < Ut ? vn(Pt, rt, Z) : null;
              t(bt <= _t), t(m <= Mt), t(tr(Pt));
              e: for (; ; ) {
                for (; !yt.h && bt < Ut; ) {
                  if (rt & Gt || (Wt = vn(Pt, rt, Z)), t(Wt != null), ot(yt), 256 > (Mt = ti(Wt.G[0], Wt.H[0], yt))) K[Lt + bt] = Mt, ++bt, ++rt >= At && (rt = 0, ++Z <= m && !(Z % 16) && Ni(W, Z));
                  else {
                    if (!(280 > Mt)) {
                      Ht = 0;
                      break e;
                    }
                    Mt = Ai(Mt - 256, yt);
                    var ue, ee = ti(Wt.G[4], Wt.H[4], yt);
                    if (ot(yt), !(bt >= (ee = Bi(At, ee = Ai(ee, yt))) && _t - bt >= Mt)) {
                      Ht = 0;
                      break e;
                    }
                    for (ue = 0; ue < Mt; ++ue) K[Lt + bt + ue] = K[Lt + bt + ue - ee];
                    for (bt += Mt, rt += Mt; rt >= At; ) rt -= At, ++Z <= m && !(Z % 16) && Ni(W, Z);
                    bt < Ut && rt & Gt && (Wt = vn(Pt, rt, Z));
                  }
                  t(yt.h == G(yt));
                }
                Ni(W, Z > m ? m : Z);
                break e;
              }
              !Ht || yt.h && bt < _t ? (Ht = 0, W.a = yt.h ? 5 : 3) : W.$ = bt, m = Ht;
            } else m = Ci(W, W.V, W.Ba, W.c, W.i, m, Dr);
            if (!m) {
              L = 0;
              break t;
            }
          }
          S + L >= U && (c.Cc = 1), L = 1;
        }
        if (!L) return null;
        if (c.Cc && ((L = c.ga) != null && (L.mc = null), c.ga = null, 0 < c.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return c.nb + S * B;
    }
    function w(c, m, S, L, B, U) {
      for (; 0 < B--; ) {
        var W, K = c, Z = m + (S ? 1 : 0), rt = c, yt = m + (S ? 0 : 3);
        for (W = 0; W < L; ++W) {
          var Pt = rt[yt + 4 * W];
          Pt != 255 && (Pt *= 32897, K[Z + 4 * W + 0] = K[Z + 4 * W + 0] * Pt >> 23, K[Z + 4 * W + 1] = K[Z + 4 * W + 1] * Pt >> 23, K[Z + 4 * W + 2] = K[Z + 4 * W + 2] * Pt >> 23);
        }
        m += U;
      }
    }
    function j(c, m, S, L, B) {
      for (; 0 < L--; ) {
        var U;
        for (U = 0; U < S; ++U) {
          var W = c[m + 2 * U + 0], K = 15 & (rt = c[m + 2 * U + 1]), Z = 4369 * K, rt = (240 & rt | rt >> 4) * Z >> 16;
          c[m + 2 * U + 0] = (240 & W | W >> 4) * Z >> 16 & 240 | (15 & W | W << 4) * Z >> 16 >> 4 & 15, c[m + 2 * U + 1] = 240 & rt | K;
        }
        m += B;
      }
    }
    function ut(c, m, S, L, B, U, W, K) {
      var Z, rt, yt = 255;
      for (rt = 0; rt < B; ++rt) {
        for (Z = 0; Z < L; ++Z) {
          var Pt = c[m + Z];
          U[W + 4 * Z] = Pt, yt &= Pt;
        }
        m += S, W += K;
      }
      return yt != 255;
    }
    function pt(c, m, S, L, B) {
      var U;
      for (U = 0; U < B; ++U) S[L + U] = c[m + U] >> 8;
    }
    function Ct() {
      Hi = w, ln = j, un = ut, An = pt;
    }
    function Dt(c, m, S) {
      O[c] = function(L, B, U, W, K, Z, rt, yt, Pt, Lt, At, Ht, Mt, bt, _t, Ut, Gt) {
        var Wt, ue = Gt - 1 >> 1, ee = K[Z + 0] | rt[yt + 0] << 16, _e = Pt[Lt + 0] | At[Ht + 0] << 16;
        t(L != null);
        var re = 3 * ee + _e + 131074 >> 2;
        for (m(L[B + 0], 255 & re, re >> 16, Mt, bt), U != null && (re = 3 * _e + ee + 131074 >> 2, m(U[W + 0], 255 & re, re >> 16, _t, Ut)), Wt = 1; Wt <= ue; ++Wt) {
          var Ke = K[Z + Wt] | rt[yt + Wt] << 16, Qe = Pt[Lt + Wt] | At[Ht + Wt] << 16, We = ee + Ke + _e + Qe + 524296, je = We + 2 * (Ke + _e) >> 3;
          re = je + ee >> 1, ee = (We = We + 2 * (ee + Qe) >> 3) + Ke >> 1, m(L[B + 2 * Wt - 1], 255 & re, re >> 16, Mt, bt + (2 * Wt - 1) * S), m(L[B + 2 * Wt - 0], 255 & ee, ee >> 16, Mt, bt + (2 * Wt - 0) * S), U != null && (re = We + _e >> 1, ee = je + Qe >> 1, m(U[W + 2 * Wt - 1], 255 & re, re >> 16, _t, Ut + (2 * Wt - 1) * S), m(U[W + 2 * Wt + 0], 255 & ee, ee >> 16, _t, Ut + (2 * Wt + 0) * S)), ee = Ke, _e = Qe;
        }
        1 & Gt || (re = 3 * ee + _e + 131074 >> 2, m(L[B + Gt - 1], 255 & re, re >> 16, Mt, bt + (Gt - 1) * S), U != null && (re = 3 * _e + ee + 131074 >> 2, m(U[W + Gt - 1], 255 & re, re >> 16, _t, Ut + (Gt - 1) * S)));
      };
    }
    function Vt() {
      Vi[iu] = e2, Vi[ru] = Kd, Vi[Wd] = n2, Vi[su] = Xd, Vi[ou] = Jd, Vi[th] = Zd, Vi[Hd] = i2, Vi[eh] = Kd, Vi[nh] = Xd, Vi[au] = Jd, Vi[ih] = Zd;
    }
    function le(c) {
      return c & ~r2 ? 0 > c ? 0 : 255 : c >> Qd;
    }
    function ve(c, m) {
      return le((19077 * c >> 8) + (26149 * m >> 8) - 14234);
    }
    function Ee(c, m, S) {
      return le((19077 * c >> 8) - (6419 * m >> 8) - (13320 * S >> 8) + 8708);
    }
    function Le(c, m) {
      return le((19077 * c >> 8) + (33050 * m >> 8) - 17685);
    }
    function $e(c, m, S, L, B) {
      L[B + 0] = ve(c, S), L[B + 1] = Ee(c, m, S), L[B + 2] = Le(c, m);
    }
    function gn(c, m, S, L, B) {
      L[B + 0] = Le(c, m), L[B + 1] = Ee(c, m, S), L[B + 2] = ve(c, S);
    }
    function wn(c, m, S, L, B) {
      var U = Ee(c, m, S);
      m = U << 3 & 224 | Le(c, m) >> 3, L[B + 0] = 248 & ve(c, S) | U >> 5, L[B + 1] = m;
    }
    function En(c, m, S, L, B) {
      var U = 240 & Le(c, m) | 15;
      L[B + 0] = 240 & ve(c, S) | Ee(c, m, S) >> 4, L[B + 1] = U;
    }
    function ni(c, m, S, L, B) {
      L[B + 0] = 255, $e(c, m, S, L, B + 1);
    }
    function zn(c, m, S, L, B) {
      gn(c, m, S, L, B), L[B + 3] = 255;
    }
    function ir(c, m, S, L, B) {
      $e(c, m, S, L, B), L[B + 3] = 255;
    }
    function Ii(c, m) {
      return 0 > c ? 0 : c > m ? m : c;
    }
    function xr(c, m, S) {
      O[c] = function(L, B, U, W, K, Z, rt, yt, Pt) {
        for (var Lt = yt + (-2 & Pt) * S; yt != Lt; ) m(L[B + 0], U[W + 0], K[Z + 0], rt, yt), m(L[B + 1], U[W + 0], K[Z + 0], rt, yt + S), B += 2, ++W, ++Z, yt += 2 * S;
        1 & Pt && m(L[B + 0], U[W + 0], K[Z + 0], rt, yt);
      };
    }
    function Xl(c, m, S) {
      return S == 0 ? c == 0 ? m == 0 ? 6 : 5 : m == 0 ? 4 : 0 : S;
    }
    function Ha(c, m, S, L, B) {
      switch (c >>> 30) {
        case 3:
          Hr(m, S, L, B, 0);
          break;
        case 2:
          kn(m, S, L, B);
          break;
        case 1:
          fi(m, S, L, B);
      }
    }
    function Ga(c, m) {
      var S, L, B = m.M, U = m.Nb, W = c.oc, K = c.pc + 40, Z = c.oc, rt = c.pc + 584, yt = c.oc, Pt = c.pc + 600;
      for (S = 0; 16 > S; ++S) W[K + 32 * S - 1] = 129;
      for (S = 0; 8 > S; ++S) Z[rt + 32 * S - 1] = 129, yt[Pt + 32 * S - 1] = 129;
      for (0 < B ? W[K - 1 - 32] = Z[rt - 1 - 32] = yt[Pt - 1 - 32] = 129 : (r(W, K - 32 - 1, 127, 21), r(Z, rt - 32 - 1, 127, 9), r(yt, Pt - 32 - 1, 127, 9)), L = 0; L < c.za; ++L) {
        var Lt = m.ya[m.aa + L];
        if (0 < L) {
          for (S = -1; 16 > S; ++S) i(W, K + 32 * S - 4, W, K + 32 * S + 12, 4);
          for (S = -1; 8 > S; ++S) i(Z, rt + 32 * S - 4, Z, rt + 32 * S + 4, 4), i(yt, Pt + 32 * S - 4, yt, Pt + 32 * S + 4, 4);
        }
        var At = c.Gd, Ht = c.Hd + L, Mt = Lt.ad, bt = Lt.Hc;
        if (0 < B && (i(W, K - 32, At[Ht].y, 0, 16), i(Z, rt - 32, At[Ht].f, 0, 8), i(yt, Pt - 32, At[Ht].ea, 0, 8)), Lt.Za) {
          var _t = W, Ut = K - 32 + 16;
          for (0 < B && (L >= c.za - 1 ? r(_t, Ut, At[Ht].y[15], 4) : i(_t, Ut, At[Ht + 1].y, 0, 4)), S = 0; 4 > S; S++) _t[Ut + 128 + S] = _t[Ut + 256 + S] = _t[Ut + 384 + S] = _t[Ut + 0 + S];
          for (S = 0; 16 > S; ++S, bt <<= 2) _t = W, Ut = K + ep[S], rr[Lt.Ob[S]](_t, Ut), Ha(bt, Mt, 16 * +S, _t, Ut);
        } else if (_t = Xl(L, B, Lt.Ob[0]), xs[_t](W, K), bt != 0) for (S = 0; 16 > S; ++S, bt <<= 2) Ha(bt, Mt, 16 * +S, W, K + ep[S]);
        for (S = Lt.Gc, _t = Xl(L, B, Lt.Dd), Vr[_t](Z, rt), Vr[_t](yt, Pt), bt = Mt, _t = Z, Ut = rt, 255 & (Lt = S >> 0) && (170 & Lt ? Ja(bt, 256, _t, Ut) : Ui(bt, 256, _t, Ut)), Lt = yt, bt = Pt, 255 & (S >>= 8) && (170 & S ? Ja(Mt, 320, Lt, bt) : Ui(Mt, 320, Lt, bt)), B < c.Ub - 1 && (i(At[Ht].y, 0, W, K + 480, 16), i(At[Ht].f, 0, Z, rt + 224, 8), i(At[Ht].ea, 0, yt, Pt + 224, 8)), S = 8 * U * c.B, At = c.sa, Ht = c.ta + 16 * L + 16 * U * c.R, Mt = c.qa, Lt = c.ra + 8 * L + S, bt = c.Ha, _t = c.Ia + 8 * L + S, S = 0; 16 > S; ++S) i(At, Ht + S * c.R, W, K + 32 * S, 16);
        for (S = 0; 8 > S; ++S) i(Mt, Lt + S * c.B, Z, rt + 32 * S, 8), i(bt, _t + S * c.B, yt, Pt + 32 * S, 8);
      }
    }
    function $o(c, m, S, L, B, U, W, K, Z) {
      var rt = [0], yt = [0], Pt = 0, Lt = Z != null ? Z.kd : 0, At = Z ?? new za();
      if (c == null || 12 > S) return 7;
      At.data = c, At.w = m, At.ha = S, m = [m], S = [S], At.gb = [At.gb];
      t: {
        var Ht = m, Mt = S, bt = At.gb;
        if (t(c != null), t(Mt != null), t(bt != null), bt[0] = 0, 12 <= Mt[0] && !e(c, Ht[0], "RIFF")) {
          if (e(c, Ht[0] + 8, "WEBP")) {
            bt = 3;
            break t;
          }
          var _t = Kt(c, Ht[0] + 4);
          if (12 > _t || 4294967286 < _t) {
            bt = 3;
            break t;
          }
          if (Lt && _t > Mt[0] - 8) {
            bt = 7;
            break t;
          }
          bt[0] = _t, Ht[0] += 12, Mt[0] -= 12;
        }
        bt = 0;
      }
      if (bt != 0) return bt;
      for (_t = 0 < At.gb[0], S = S[0]; ; ) {
        t: {
          var Ut = c;
          Mt = m, bt = S;
          var Gt = rt, Wt = yt, ue = Ht = [0];
          if ((re = Pt = [Pt])[0] = 0, 8 > bt[0]) bt = 7;
          else {
            if (!e(Ut, Mt[0], "VP8X")) {
              if (Kt(Ut, Mt[0] + 4) != 10) {
                bt = 3;
                break t;
              }
              if (18 > bt[0]) {
                bt = 7;
                break t;
              }
              var ee = Kt(Ut, Mt[0] + 8), _e = 1 + Yt(Ut, Mt[0] + 12);
              if (2147483648 <= _e * (Ut = 1 + Yt(Ut, Mt[0] + 15))) {
                bt = 3;
                break t;
              }
              ue != null && (ue[0] = ee), Gt != null && (Gt[0] = _e), Wt != null && (Wt[0] = Ut), Mt[0] += 18, bt[0] -= 18, re[0] = 1;
            }
            bt = 0;
          }
        }
        if (Pt = Pt[0], Ht = Ht[0], bt != 0) return bt;
        if (Mt = !!(2 & Ht), !_t && Pt) return 3;
        if (U != null && (U[0] = !!(16 & Ht)), W != null && (W[0] = Mt), K != null && (K[0] = 0), W = rt[0], Ht = yt[0], Pt && Mt && Z == null) {
          bt = 0;
          break;
        }
        if (4 > S) {
          bt = 7;
          break;
        }
        if (_t && Pt || !_t && !Pt && !e(c, m[0], "ALPH")) {
          S = [S], At.na = [At.na], At.P = [At.P], At.Sa = [At.Sa];
          t: {
            ee = c, bt = m, _t = S;
            var re = At.gb;
            Gt = At.na, Wt = At.P, ue = At.Sa, _e = 22, t(ee != null), t(_t != null), Ut = bt[0];
            var Ke = _t[0];
            for (t(Gt != null), t(ue != null), Gt[0] = null, Wt[0] = null, ue[0] = 0; ; ) {
              if (bt[0] = Ut, _t[0] = Ke, 8 > Ke) {
                bt = 7;
                break t;
              }
              var Qe = Kt(ee, Ut + 4);
              if (4294967286 < Qe) {
                bt = 3;
                break t;
              }
              var We = 8 + Qe + 1 & -2;
              if (_e += We, 0 < re && _e > re) {
                bt = 3;
                break t;
              }
              if (!e(ee, Ut, "VP8 ") || !e(ee, Ut, "VP8L")) {
                bt = 0;
                break t;
              }
              if (Ke[0] < We) {
                bt = 7;
                break t;
              }
              e(ee, Ut, "ALPH") || (Gt[0] = ee, Wt[0] = Ut + 8, ue[0] = Qe), Ut += We, Ke -= We;
            }
          }
          if (S = S[0], At.na = At.na[0], At.P = At.P[0], At.Sa = At.Sa[0], bt != 0) break;
        }
        S = [S], At.Ja = [At.Ja], At.xa = [At.xa];
        t: if (re = c, bt = m, _t = S, Gt = At.gb[0], Wt = At.Ja, ue = At.xa, ee = bt[0], Ut = !e(re, ee, "VP8 "), _e = !e(re, ee, "VP8L"), t(re != null), t(_t != null), t(Wt != null), t(ue != null), 8 > _t[0]) bt = 7;
        else {
          if (Ut || _e) {
            if (re = Kt(re, ee + 4), 12 <= Gt && re > Gt - 12) {
              bt = 3;
              break t;
            }
            if (Lt && re > _t[0] - 8) {
              bt = 7;
              break t;
            }
            Wt[0] = re, bt[0] += 8, _t[0] -= 8, ue[0] = _e;
          } else ue[0] = 5 <= _t[0] && re[ee + 0] == 47 && !(re[ee + 4] >> 5), Wt[0] = _t[0];
          bt = 0;
        }
        if (S = S[0], At.Ja = At.Ja[0], At.xa = At.xa[0], m = m[0], bt != 0) break;
        if (4294967286 < At.Ja) return 3;
        if (K == null || Mt || (K[0] = At.xa ? 2 : 1), W = [W], Ht = [Ht], At.xa) {
          if (5 > S) {
            bt = 7;
            break;
          }
          K = W, Lt = Ht, Mt = U, c == null || 5 > S ? c = 0 : 5 <= S && c[m + 0] == 47 && !(c[m + 4] >> 5) ? (_t = [0], re = [0], Gt = [0], tt(Wt = new N(), c, m, S), we(Wt, _t, re, Gt) ? (K != null && (K[0] = _t[0]), Lt != null && (Lt[0] = re[0]), Mt != null && (Mt[0] = Gt[0]), c = 1) : c = 0) : c = 0;
        } else {
          if (10 > S) {
            bt = 7;
            break;
          }
          K = Ht, c == null || 10 > S || !Gs(c, m + 3, S - 3) ? c = 0 : (Lt = c[m + 0] | c[m + 1] << 8 | c[m + 2] << 16, Mt = 16383 & (c[m + 7] << 8 | c[m + 6]), c = 16383 & (c[m + 9] << 8 | c[m + 8]), 1 & Lt || 3 < (Lt >> 1 & 7) || !(Lt >> 4 & 1) || Lt >> 5 >= At.Ja || !Mt || !c ? c = 0 : (W && (W[0] = Mt), K && (K[0] = c), c = 1));
        }
        if (!c || (W = W[0], Ht = Ht[0], Pt && (rt[0] != W || yt[0] != Ht))) return 3;
        Z != null && (Z[0] = At, Z.offset = m - Z.w, t(4294967286 > m - Z.w), t(Z.offset == Z.ha - S));
        break;
      }
      return bt == 0 || bt == 7 && Pt && Z == null ? (U != null && (U[0] |= At.na != null && 0 < At.na.length), L != null && (L[0] = W), B != null && (B[0] = Ht), 0) : bt;
    }
    function Va(c, m, S) {
      var L = m.width, B = m.height, U = 0, W = 0, K = L, Z = B;
      if (m.Da = c != null && 0 < c.Da, m.Da && (K = c.cd, Z = c.bd, U = c.v, W = c.j, 11 > S || (U &= -2, W &= -2), 0 > U || 0 > W || 0 >= K || 0 >= Z || U + K > L || W + Z > B)) return 0;
      if (m.v = U, m.j = W, m.va = U + K, m.o = W + Z, m.U = K, m.T = Z, m.da = c != null && 0 < c.da, m.da) {
        if (!nt(K, Z, S = [c.ib], U = [c.hb])) return 0;
        m.ib = S[0], m.hb = U[0];
      }
      return m.ob = c != null && c.ob, m.Kb = c == null || !c.Sd, m.da && (m.ob = m.ib < 3 * L / 4 && m.hb < 3 * B / 4, m.Kb = 0), 1;
    }
    function Ya(c) {
      if (c == null) return 2;
      if (11 > c.S) {
        var m = c.f.RGBA;
        m.fb += (c.height - 1) * m.A, m.A = -m.A;
      } else m = c.f.kb, c = c.height, m.O += (c - 1) * m.fa, m.fa = -m.fa, m.N += (c - 1 >> 1) * m.Ab, m.Ab = -m.Ab, m.W += (c - 1 >> 1) * m.Db, m.Db = -m.Db, m.F != null && (m.J += (c - 1) * m.lb, m.lb = -m.lb);
      return 0;
    }
    function Uo(c, m, S, L) {
      if (L == null || 0 >= c || 0 >= m) return 2;
      if (S != null) {
        if (S.Da) {
          var B = S.cd, U = S.bd, W = -2 & S.v, K = -2 & S.j;
          if (0 > W || 0 > K || 0 >= B || 0 >= U || W + B > c || K + U > m) return 2;
          c = B, m = U;
        }
        if (S.da) {
          if (!nt(c, m, B = [S.ib], U = [S.hb])) return 2;
          c = B[0], m = U[0];
        }
      }
      L.width = c, L.height = m;
      t: {
        var Z = L.width, rt = L.height;
        if (c = L.S, 0 >= Z || 0 >= rt || !(c >= iu && 13 > c)) c = 2;
        else {
          if (0 >= L.Rd && L.sd == null) {
            W = U = B = m = 0;
            var yt = (K = Z * np[c]) * rt;
            if (11 > c || (U = (rt + 1) / 2 * (m = (Z + 1) / 2), c == 12 && (W = (B = Z) * rt)), (rt = s(yt + 2 * U + W)) == null) {
              c = 1;
              break t;
            }
            L.sd = rt, 11 > c ? ((Z = L.f.RGBA).eb = rt, Z.fb = 0, Z.A = K, Z.size = yt) : ((Z = L.f.kb).y = rt, Z.O = 0, Z.fa = K, Z.Fd = yt, Z.f = rt, Z.N = 0 + yt, Z.Ab = m, Z.Cd = U, Z.ea = rt, Z.W = 0 + yt + U, Z.Db = m, Z.Ed = U, c == 12 && (Z.F = rt, Z.J = 0 + yt + 2 * U), Z.Tc = W, Z.lb = B);
          }
          if (m = 1, B = L.S, U = L.width, W = L.height, B >= iu && 13 > B) if (11 > B) c = L.f.RGBA, m &= (K = Math.abs(c.A)) * (W - 1) + U <= c.size, m &= K >= U * np[B], m &= c.eb != null;
          else {
            c = L.f.kb, K = (U + 1) / 2, yt = (W + 1) / 2, Z = Math.abs(c.fa), rt = Math.abs(c.Ab);
            var Pt = Math.abs(c.Db), Lt = Math.abs(c.lb), At = Lt * (W - 1) + U;
            m &= Z * (W - 1) + U <= c.Fd, m &= rt * (yt - 1) + K <= c.Cd, m = (m &= Pt * (yt - 1) + K <= c.Ed) & Z >= U & rt >= K & Pt >= K, m &= c.y != null, m &= c.f != null, m &= c.ea != null, B == 12 && (m &= Lt >= U, m &= At <= c.Tc, m &= c.F != null);
          }
          else m = 0;
          c = m ? 0 : 2;
        }
      }
      return c != 0 || S != null && S.fd && (c = Ya(L)), c;
    }
    var Vn = 64, Wo = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Ho = 24, Go = 32, Ka = 8, yi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    vt("Predictor0", "PredictorAdd0"), O.Predictor0 = function() {
      return 4278190080;
    }, O.Predictor1 = function(c) {
      return c;
    }, O.Predictor2 = function(c, m, S) {
      return m[S + 0];
    }, O.Predictor3 = function(c, m, S) {
      return m[S + 1];
    }, O.Predictor4 = function(c, m, S) {
      return m[S - 1];
    }, O.Predictor5 = function(c, m, S) {
      return ft(ft(c, m[S + 1]), m[S + 0]);
    }, O.Predictor6 = function(c, m, S) {
      return ft(c, m[S - 1]);
    }, O.Predictor7 = function(c, m, S) {
      return ft(c, m[S + 0]);
    }, O.Predictor8 = function(c, m, S) {
      return ft(m[S - 1], m[S + 0]);
    }, O.Predictor9 = function(c, m, S) {
      return ft(m[S + 0], m[S + 1]);
    }, O.Predictor10 = function(c, m, S) {
      return ft(ft(c, m[S - 1]), ft(m[S + 0], m[S + 1]));
    }, O.Predictor11 = function(c, m, S) {
      var L = m[S + 0];
      return 0 >= Tt(L >> 24 & 255, c >> 24 & 255, (m = m[S - 1]) >> 24 & 255) + Tt(L >> 16 & 255, c >> 16 & 255, m >> 16 & 255) + Tt(L >> 8 & 255, c >> 8 & 255, m >> 8 & 255) + Tt(255 & L, 255 & c, 255 & m) ? L : c;
    }, O.Predictor12 = function(c, m, S) {
      var L = m[S + 0];
      return (Et((c >> 24 & 255) + (L >> 24 & 255) - ((m = m[S - 1]) >> 24 & 255)) << 24 | Et((c >> 16 & 255) + (L >> 16 & 255) - (m >> 16 & 255)) << 16 | Et((c >> 8 & 255) + (L >> 8 & 255) - (m >> 8 & 255)) << 8 | Et((255 & c) + (255 & L) - (255 & m))) >>> 0;
    }, O.Predictor13 = function(c, m, S) {
      var L = m[S - 1];
      return (zt((c = ft(c, m[S + 0])) >> 24 & 255, L >> 24 & 255) << 24 | zt(c >> 16 & 255, L >> 16 & 255) << 16 | zt(c >> 8 & 255, L >> 8 & 255) << 8 | zt(c >> 0 & 255, L >> 0 & 255)) >>> 0;
    };
    var Zc = O.PredictorAdd0;
    O.PredictorAdd1 = $t, vt("Predictor2", "PredictorAdd2"), vt("Predictor3", "PredictorAdd3"), vt("Predictor4", "PredictorAdd4"), vt("Predictor5", "PredictorAdd5"), vt("Predictor6", "PredictorAdd6"), vt("Predictor7", "PredictorAdd7"), vt("Predictor8", "PredictorAdd8"), vt("Predictor9", "PredictorAdd9"), vt("Predictor10", "PredictorAdd10"), vt("Predictor11", "PredictorAdd11"), vt("Predictor12", "PredictorAdd12"), vt("Predictor13", "PredictorAdd13");
    var Xa = O.PredictorAdd2;
    xe("ColorIndexInverseTransform", "MapARGB", "32b", function(c) {
      return c >> 8 & 255;
    }, function(c) {
      return c;
    }), xe("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(c) {
      return c;
    }, function(c) {
      return c >> 8 & 255;
    });
    var Jl, $i = O.ColorIndexInverseTransform, Vo = O.MapARGB, Zl = O.VP8LColorIndexInverseTransformAlpha, Ql = O.MapAlpha, ys = O.VP8LPredictorsAdd = [];
    ys.length = 16, (O.VP8LPredictors = []).length = 16, (O.VP8LPredictorsAdd_C = []).length = 16, (O.VP8LPredictors_C = []).length = 16;
    var eo, bi, hi, bs, Ur, Wr, Yo, Hr, kn, Ja, fi, Ui, Ko, tu, Za, no, io, vs, ro, Xo, so, ws, Qa, Wi, Hi, ln, un, An, Dn = s(511), Gr = s(2041), tl = s(225), Jo = s(767), eu = 0, Qc = Gr, nu = tl, Ei = Jo, Gi = Dn, iu = 0, ru = 1, Wd = 2, su = 3, ou = 4, th = 5, Hd = 6, eh = 7, nh = 8, au = 9, ih = 10, zm = [2, 3, 7], $m = [3, 3, 11], Gd = [280, 256, 256, 256, 40], Um = [0, 1, 1, 1, 0], Wm = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Hm = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Gm = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Vm = 8, rh = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], sh = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], el = null, Ym = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Km = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Vd = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Xm = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Jm = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Zm = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Qm = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], xs = [], rr = [], Vr = [], t2 = 1, Yd = 2, _s = [], Vi = [];
    Dt("UpsampleRgbLinePair", $e, 3), Dt("UpsampleBgrLinePair", gn, 3), Dt("UpsampleRgbaLinePair", ir, 4), Dt("UpsampleBgraLinePair", zn, 4), Dt("UpsampleArgbLinePair", ni, 4), Dt("UpsampleRgba4444LinePair", En, 2), Dt("UpsampleRgb565LinePair", wn, 2);
    var e2 = O.UpsampleRgbLinePair, n2 = O.UpsampleBgrLinePair, Kd = O.UpsampleRgbaLinePair, Xd = O.UpsampleBgraLinePair, Jd = O.UpsampleArgbLinePair, Zd = O.UpsampleRgba4444LinePair, i2 = O.UpsampleRgb565LinePair, lu = 16, uu = 1 << lu - 1, nl = -227, oh = 482, Qd = 6, r2 = (256 << Qd) - 1, tp = 0, s2 = s(256), o2 = s(256), a2 = s(256), l2 = s(256), u2 = s(oh - nl), c2 = s(oh - nl);
    xr("YuvToRgbRow", $e, 3), xr("YuvToBgrRow", gn, 3), xr("YuvToRgbaRow", ir, 4), xr("YuvToBgraRow", zn, 4), xr("YuvToArgbRow", ni, 4), xr("YuvToRgba4444Row", En, 2), xr("YuvToRgb565Row", wn, 2);
    var ep = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], cu = [0, 2, 8], h2 = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], f2 = 1;
    this.WebPDecodeRGBA = function(c, m, S, L, B) {
      var U = ru, W = new qo(), K = new Sn();
      W.ba = K, K.S = U, K.width = [K.width], K.height = [K.height];
      var Z = K.width, rt = K.height, yt = new Mn();
      if (yt == null || c == null) var Pt = 2;
      else t(yt != null), Pt = $o(c, m, S, yt.width, yt.height, yt.Pd, yt.Qd, yt.format, null);
      if (Pt != 0 ? Z = 0 : (Z != null && (Z[0] = yt.width[0]), rt != null && (rt[0] = yt.height[0]), Z = 1), Z) {
        K.width = K.width[0], K.height = K.height[0], L != null && (L[0] = K.width), B != null && (B[0] = K.height);
        t: {
          if (L = new ls(), (B = new za()).data = c, B.w = m, B.ha = S, B.kd = 1, m = [0], t(B != null), ((c = $o(B.data, B.w, B.ha, null, null, null, m, null, B)) == 0 || c == 7) && m[0] && (c = 4), (m = c) == 0) {
            if (t(W != null), L.data = B.data, L.w = B.w + B.offset, L.ha = B.ha - B.offset, L.put = Ri, L.ac = yn, L.bc = qn, L.ma = W, B.xa) {
              if ((c = Pi()) == null) {
                W = 1;
                break t;
              }
              if (function(Lt, At) {
                var Ht = [0], Mt = [0], bt = [0];
                e: for (; ; ) {
                  if (Lt == null) return 0;
                  if (At == null) return Lt.a = 2, 0;
                  if (Lt.l = At, Lt.a = 0, tt(Lt.m, At.data, At.w, At.ha), !we(Lt.m, Ht, Mt, bt)) {
                    Lt.a = 3;
                    break e;
                  }
                  if (Lt.xb = Yd, At.width = Ht[0], At.height = Mt[0], !qi(Ht[0], Mt[0], 1, Lt, null)) break e;
                  return 1;
                }
                return t(Lt.a != 0), 0;
              }(c, L)) {
                if (L = (m = Uo(L.width, L.height, W.Oa, W.ba)) == 0) {
                  e: {
                    L = c;
                    n: for (; ; ) {
                      if (L == null) {
                        L = 0;
                        break e;
                      }
                      if (t(L.s.yc != null), t(L.s.Ya != null), t(0 < L.s.Wb), t((S = L.l) != null), t((B = S.ma) != null), L.xb != 0) {
                        if (L.ca = B.ba, L.tb = B.tb, t(L.ca != null), !Va(B.Oa, S, su)) {
                          L.a = 2;
                          break n;
                        }
                        if (!br(L, S.width) || S.da) break n;
                        if ((S.da || de(L.ca.S)) && Ct(), 11 > L.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), L.ca.f.kb.F != null && Ct()), L.Pb && 0 < L.s.ua && L.s.vb.X == null && !T(L.s.vb, L.s.Wa.Xa)) {
                          L.a = 1;
                          break n;
                        }
                        L.xb = 0;
                      }
                      if (!Ci(L, L.V, L.Ba, L.c, L.i, S.o, rs)) break n;
                      B.Dc = L.Ma, L = 1;
                      break e;
                    }
                    t(L.a != 0), L = 0;
                  }
                  L = !L;
                }
                L && (m = c.a);
              } else m = c.a;
            } else {
              if ((c = new Oa()) == null) {
                W = 1;
                break t;
              }
              if (c.Fa = B.na, c.P = B.P, c.qc = B.Sa, Do(c, L)) {
                if ((m = Uo(L.width, L.height, W.Oa, W.ba)) == 0) {
                  if (c.Aa = 0, S = W.Oa, t((B = c) != null), S != null) {
                    if (0 < (Z = 0 > (Z = S.Md) ? 0 : 100 < Z ? 255 : 255 * Z / 100)) {
                      for (rt = yt = 0; 4 > rt; ++rt) 12 > (Pt = B.pb[rt]).lc && (Pt.ia = Z * h2[0 > Pt.lc ? 0 : Pt.lc] >> 3), yt |= Pt.ia;
                      yt && (alert("todo:VP8InitRandom"), B.ia = 1);
                    }
                    B.Ga = S.Id, 100 < B.Ga ? B.Ga = 100 : 0 > B.Ga && (B.Ga = 0);
                  }
                  Ta(c, L) || (m = c.a);
                }
              } else m = c.a;
            }
            m == 0 && W.Oa != null && W.Oa.fd && (m = Ya(W.ba));
          }
          W = m;
        }
        U = W != 0 ? null : 11 > U ? K.f.RGBA.eb : K.f.kb.y;
      } else U = null;
      return U;
    };
    var np = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function h(O, M) {
    for (var q = "", P = 0; P < 4; P++) q += String.fromCharCode(O[M++]);
    return q;
  }
  function u(O, M) {
    return (O[M + 0] << 0 | O[M + 1] << 8 | O[M + 2] << 16) >>> 0;
  }
  function d(O, M) {
    return (O[M + 0] << 0 | O[M + 1] << 8 | O[M + 2] << 16 | O[M + 3] << 24) >>> 0;
  }
  new l();
  var p = [0], f = [0], g = [], b = new l(), x = n, y = function(O, M) {
    var q = {}, P = 0, A = !1, F = 0, _ = 0;
    if (q.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(z, G, Y, ot) {
      for (var xt = 0; xt < ot; xt++) if (z[G + xt] != Y.charCodeAt(xt)) return !0;
      return !1;
    }(O, M, "RIFF", 4)) {
      var J, V;
      for (d(O, M += 4), M += 8; M < O.length; ) {
        var R = h(O, M), tt = d(O, M += 4);
        M += 4;
        var H = tt + (1 & tt);
        switch (R) {
          case "VP8 ":
          case "VP8L":
            q.frames[P] === void 0 && (q.frames[P] = {}), (N = q.frames[P]).src_off = A ? _ : M - 8, N.src_size = F + tt + 8, P++, A && (A = !1, F = 0, _ = 0);
            break;
          case "VP8X":
            (N = q.header = {}).feature_flags = O[M];
            var ct = M + 4;
            N.canvas_width = 1 + u(O, ct), ct += 3, N.canvas_height = 1 + u(O, ct), ct += 3;
            break;
          case "ALPH":
            A = !0, F = H + 8, _ = M - 8;
            break;
          case "ANIM":
            (N = q.header).bgcolor = d(O, M), ct = M + 4, N.loop_count = (J = O)[(V = ct) + 0] << 0 | J[V + 1] << 8, ct += 2;
            break;
          case "ANMF":
            var it, N;
            (N = q.frames[P] = {}).offset_x = 2 * u(O, M), M += 3, N.offset_y = 2 * u(O, M), M += 3, N.width = 1 + u(O, M), M += 3, N.height = 1 + u(O, M), M += 3, N.duration = u(O, M), M += 3, it = O[M++], N.dispose = 1 & it, N.blend = it >> 1 & 1;
        }
        R != "ANMF" && (M += H);
      }
      return q;
    }
  }(x, 0);
  y.response = x, y.rgbaoutput = !0, y.dataurl = !1;
  var v = y.header ? y.header : null, k = y.frames ? y.frames : null;
  if (v) {
    v.loop_counter = v.loop_count, p = [v.canvas_height], f = [v.canvas_width];
    for (var C = 0; C < k.length && k[C].blend != 0; C++) ;
  }
  var I = k[0], D = b.WebPDecodeRGBA(x, I.src_off, I.src_size, f, p);
  I.rgba = D, I.imgwidth = f[0], I.imgheight = p[0];
  for (var E = 0; E < f[0] * p[0] * 4; E++) g[E] = D[E];
  return this.width = f, this.height = p, this.data = g, this;
}
(function(n) {
  var t = function() {
    return typeof hf == "function";
  }, e = function(p, f, g, b) {
    var x = 4, y = o;
    switch (b) {
      case n.image_compression.FAST:
        x = 1, y = s;
        break;
      case n.image_compression.MEDIUM:
        x = 6, y = a;
        break;
      case n.image_compression.SLOW:
        x = 9, y = l;
    }
    p = i(p, f, g, y);
    var v = hf(p, { level: x });
    return n.__addimage__.arrayBufferToBinaryString(v);
  }, i = function(p, f, g, b) {
    for (var x, y, v, k = p.length / f, C = new Uint8Array(p.length + k), I = u(), D = 0; D < k; D += 1) {
      if (v = D * f, x = p.subarray(v, v + f), b) C.set(b(x, g, y), v + D);
      else {
        for (var E, O = I.length, M = []; E < O; E += 1) M[E] = I[E](x, g, y);
        var q = d(M.concat());
        C.set(M[q], v + D);
      }
      y = x;
    }
    return C;
  }, r = function(p) {
    var f = Array.apply([], p);
    return f.unshift(0), f;
  }, s = function(p, f) {
    var g, b = [], x = p.length;
    b[0] = 1;
    for (var y = 0; y < x; y += 1) g = p[y - f] || 0, b[y + 1] = p[y] - g + 256 & 255;
    return b;
  }, o = function(p, f, g) {
    var b, x = [], y = p.length;
    x[0] = 2;
    for (var v = 0; v < y; v += 1) b = g && g[v] || 0, x[v + 1] = p[v] - b + 256 & 255;
    return x;
  }, a = function(p, f, g) {
    var b, x, y = [], v = p.length;
    y[0] = 3;
    for (var k = 0; k < v; k += 1) b = p[k - f] || 0, x = g && g[k] || 0, y[k + 1] = p[k] + 256 - (b + x >>> 1) & 255;
    return y;
  }, l = function(p, f, g) {
    var b, x, y, v, k = [], C = p.length;
    k[0] = 4;
    for (var I = 0; I < C; I += 1) b = p[I - f] || 0, x = g && g[I] || 0, y = g && g[I - f] || 0, v = h(b, x, y), k[I + 1] = p[I] - v + 256 & 255;
    return k;
  }, h = function(p, f, g) {
    if (p === f && f === g) return p;
    var b = Math.abs(f - g), x = Math.abs(p - g), y = Math.abs(p + f - g - g);
    return b <= x && b <= y ? p : x <= y ? f : g;
  }, u = function() {
    return [r, s, o, a, l];
  }, d = function(p) {
    var f = p.map(function(g) {
      return g.reduce(function(b, x) {
        return b + Math.abs(x);
      }, 0);
    });
    return f.indexOf(Math.min.apply(null, f));
  };
  n.processPNG = function(p, f, g, b) {
    var x, y, v, k, C, I, D, E, O, M, q, P, A, F, _, J = this.decode.FLATE_DECODE, V = "";
    if (this.__addimage__.isArrayBuffer(p) && (p = new Uint8Array(p)), this.__addimage__.isArrayBufferView(p)) {
      if (p = (v = new Dv(p)).imgData, y = v.bits, x = v.colorSpace, C = v.colors, [4, 6].indexOf(v.colorType) !== -1) {
        if (v.bits === 8) {
          O = (E = v.pixelBitlength == 32 ? new Uint32Array(v.decodePixels().buffer) : v.pixelBitlength == 16 ? new Uint16Array(v.decodePixels().buffer) : new Uint8Array(v.decodePixels().buffer)).length, q = new Uint8Array(O * v.colors), M = new Uint8Array(O);
          var R, tt = v.pixelBitlength - v.bits;
          for (F = 0, _ = 0; F < O; F++) {
            for (A = E[F], R = 0; R < tt; ) q[_++] = A >>> R & 255, R += v.bits;
            M[F] = A >>> R & 255;
          }
        }
        if (v.bits === 16) {
          O = (E = new Uint32Array(v.decodePixels().buffer)).length, q = new Uint8Array(O * (32 / v.pixelBitlength) * v.colors), M = new Uint8Array(O * (32 / v.pixelBitlength)), P = v.colors > 1, F = 0, _ = 0;
          for (var H = 0; F < O; ) A = E[F++], q[_++] = A >>> 0 & 255, P && (q[_++] = A >>> 16 & 255, A = E[F++], q[_++] = A >>> 0 & 255), M[H++] = A >>> 16 & 255;
          y = 8;
        }
        b !== n.image_compression.NONE && t() ? (p = e(q, v.width * v.colors, v.colors, b), D = e(M, v.width, 1, b)) : (p = q, D = M, J = void 0);
      }
      if (v.colorType === 3 && (x = this.color_spaces.INDEXED, I = v.palette, v.transparency.indexed)) {
        var ct = v.transparency.indexed, it = 0;
        for (F = 0, O = ct.length; F < O; ++F) it += ct[F];
        if ((it /= 255) === O - 1 && ct.indexOf(0) !== -1) k = [ct.indexOf(0)];
        else if (it !== O) {
          for (E = v.decodePixels(), M = new Uint8Array(E.length), F = 0, O = E.length; F < O; F++) M[F] = ct[E[F]];
          D = e(M, v.width, 1);
        }
      }
      var N = function(z) {
        var G;
        switch (z) {
          case n.image_compression.FAST:
            G = 11;
            break;
          case n.image_compression.MEDIUM:
            G = 13;
            break;
          case n.image_compression.SLOW:
            G = 14;
            break;
          default:
            G = 12;
        }
        return G;
      }(b);
      return J === this.decode.FLATE_DECODE && (V = "/Predictor " + N + " "), V += "/Colors " + C + " /BitsPerComponent " + y + " /Columns " + v.width, (this.__addimage__.isArrayBuffer(p) || this.__addimage__.isArrayBufferView(p)) && (p = this.__addimage__.arrayBufferToBinaryString(p)), (D && this.__addimage__.isArrayBuffer(D) || this.__addimage__.isArrayBufferView(D)) && (D = this.__addimage__.arrayBufferToBinaryString(D)), { alias: g, data: p, index: f, filter: J, decodeParameters: V, transparency: k, palette: I, sMask: D, predictor: N, width: v.width, height: v.height, bitsPerComponent: y, colorSpace: x };
    }
  };
})(Se.API), function(n) {
  n.processGIF89A = function(t, e, i, r) {
    var s = new Rv(t), o = s.width, a = s.height, l = [];
    s.decodeAndBlitFrameRGBA(0, l);
    var h = { data: l, width: o, height: a }, u = new Ih(100).encode(h, 100);
    return n.processJPEG.call(this, u, e, i, r);
  }, n.processGIF87A = n.processGIF89A;
}(Se.API), ar.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var t = 0; t < n; t++) {
      var e = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[t] = { red: r, green: i, blue: e, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, ar.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, t = this.width * this.height * 4;
    this.data = new Uint8Array(t), this[n]();
  } catch (e) {
    an.log("bit decode error:" + e);
  }
}, ar.prototype.bit1 = function() {
  var n, t = Math.ceil(this.width / 8), e = t % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, r = 0; r < t; r++) for (var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 8 * r * 4, a = 0; a < 8 && 8 * r + a < this.width; a++) {
      var l = this.palette[s >> 7 - a & 1];
      this.data[o + 4 * a] = l.blue, this.data[o + 4 * a + 1] = l.green, this.data[o + 4 * a + 2] = l.red, this.data[o + 4 * a + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, ar.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), t = n % 4, e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < n; r++) {
      var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 2 * r * 4, a = s >> 4, l = 15 & s, h = this.palette[a];
      if (this.data[o] = h.blue, this.data[o + 1] = h.green, this.data[o + 2] = h.red, this.data[o + 3] = 255, 2 * r + 1 >= this.width) break;
      h = this.palette[l], this.data[o + 4] = h.blue, this.data[o + 4 + 1] = h.green, this.data[o + 4 + 2] = h.red, this.data[o + 4 + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, ar.prototype.bit8 = function() {
  for (var n = this.width % 4, t = this.height - 1; t >= 0; t--) {
    for (var e = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var r = this.datav.getUint8(this.pos++, !0), s = e * this.width * 4 + 4 * i;
      if (r < this.palette.length) {
        var o = this.palette[r];
        this.data[s] = o.red, this.data[s + 1] = o.green, this.data[s + 2] = o.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, ar.prototype.bit15 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (s & t) / t * 255 | 0, a = (s >> 5 & t) / t * 255 | 0, l = (s >> 10 & t) / t * 255 | 0, h = s >> 15 ? 255 : 0, u = i * this.width * 4 + 4 * r;
      this.data[u] = l, this.data[u + 1] = a, this.data[u + 2] = o, this.data[u + 3] = h;
    }
    this.pos += n;
  }
}, ar.prototype.bit16 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, s = 0; s < this.width; s++) {
      var o = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (o & t) / t * 255 | 0, l = (o >> 5 & e) / e * 255 | 0, h = (o >> 11) / t * 255 | 0, u = r * this.width * 4 + 4 * s;
      this.data[u] = h, this.data[u + 1] = l, this.data[u + 2] = a, this.data[u + 3] = 255;
    }
    this.pos += n;
  }
}, ar.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = t * this.width * 4 + 4 * e;
      this.data[o] = s, this.data[o + 1] = r, this.data[o + 2] = i, this.data[o + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ar.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--) for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
    var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), a = t * this.width * 4 + 4 * e;
    this.data[a] = s, this.data[a + 1] = r, this.data[a + 2] = i, this.data[a + 3] = o;
  }
}, ar.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processBMP = function(t, e, i, r) {
    var s = new ar(t, !1), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Ih(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(Se.API), lg.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processWEBP = function(t, e, i, r) {
    var s = new lg(t), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Ih(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(Se.API), Se.API.processRGBA = function(n, t, e) {
  for (var i = n.data, r = i.length, s = new Uint8Array(r / 4 * 3), o = new Uint8Array(r / 4), a = 0, l = 0, h = 0; h < r; h += 4) {
    var u = i[h], d = i[h + 1], p = i[h + 2], f = i[h + 3];
    s[a++] = u, s[a++] = d, s[a++] = p, o[l++] = f;
  }
  var g = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o), data: g, index: t, alias: e, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, Se.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, ia = Se.API, Lu = ia.getCharWidthsArray = function(n, t) {
  var e, i, r = (t = t || {}).font || this.internal.getFont(), s = t.fontSize || this.internal.getFontSize(), o = t.charSpace || this.internal.getCharSpace(), a = t.widths ? t.widths : r.metadata.Unicode.widths, l = a.fof ? a.fof : 1, h = t.kerning ? t.kerning : r.metadata.Unicode.kerning, u = h.fof ? h.fof : 1, d = t.doKerning !== !1, p = 0, f = n.length, g = 0, b = a[0] || l, x = [];
  for (e = 0; e < f; e++) i = n.charCodeAt(e), typeof r.metadata.widthOfString == "function" ? x.push((r.metadata.widthOfGlyph(r.metadata.characterToGlyph(i)) + o * (1e3 / s) || 0) / 1e3) : (p = d && en(h[i]) === "object" && !isNaN(parseInt(h[i][g], 10)) ? h[i][g] / u : 0, x.push((a[i] || b) / l + p)), g = i;
  return x;
}, rg = ia.getStringUnitWidth = function(n, t) {
  var e = (t = t || {}).fontSize || this.internal.getFontSize(), i = t.font || this.internal.getFont(), r = t.charSpace || this.internal.getCharSpace();
  return ia.processArabic && (n = ia.processArabic(n)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(n, e, r) / e : Lu.apply(this, arguments).reduce(function(s, o) {
    return s + o;
  }, 0);
}, sg = function(n, t, e, i) {
  for (var r = [], s = 0, o = n.length, a = 0; s !== o && a + t[s] < e; ) a += t[s], s++;
  r.push(n.slice(0, s));
  var l = s;
  for (a = 0; s !== o; ) a + t[s] > i && (r.push(n.slice(l, s)), a = 0, l = s), a += t[s], s++;
  return l !== s && r.push(n.slice(l, s)), r;
}, og = function(n, t, e) {
  e || (e = {});
  var i, r, s, o, a, l, h, u = [], d = [u], p = e.textIndent || 0, f = 0, g = 0, b = n.split(" "), x = Lu.apply(this, [" ", e])[0];
  if (l = e.lineIndent === -1 ? b[0].length + 2 : e.lineIndent || 0) {
    var y = Array(l).join(" "), v = [];
    b.map(function(C) {
      (C = C.split(/\s*\n/)).length > 1 ? v = v.concat(C.map(function(I, D) {
        return (D && I.length ? `
` : "") + I;
      })) : v.push(C[0]);
    }), b = v, l = rg.apply(this, [y, e]);
  }
  for (s = 0, o = b.length; s < o; s++) {
    var k = 0;
    if (i = b[s], l && i[0] == `
` && (i = i.substr(1), k = 1), p + f + (g = (r = Lu.apply(this, [i, e])).reduce(function(C, I) {
      return C + I;
    }, 0)) > t || k) {
      if (g > t) {
        for (a = sg.apply(this, [i, r, t - (p + f), t]), u.push(a.shift()), u = [a.pop()]; a.length; ) d.push([a.shift()]);
        g = r.slice(i.length - (u[0] ? u[0].length : 0)).reduce(function(C, I) {
          return C + I;
        }, 0);
      } else u = [i];
      d.push(u), p = g + l, f = x;
    } else u.push(i), p += f + g, f = x;
  }
  return h = l ? function(C, I) {
    return (I ? y : "") + C.join(" ");
  } : function(C) {
    return C.join(" ");
  }, d.map(h);
}, ia.splitTextToSize = function(n, t, e) {
  var i, r = (e = e || {}).fontSize || this.internal.getFontSize(), s = (function(u) {
    if (u.widths && u.kerning) return { widths: u.widths, kerning: u.kerning };
    var d = this.internal.getFont(u.fontName, u.fontStyle);
    return d.metadata.Unicode ? { widths: d.metadata.Unicode.widths || { 0: 1 }, kerning: d.metadata.Unicode.kerning || {} } : { font: d.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, e);
  i = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var o = 1 * this.internal.scaleFactor * t / r;
  s.textIndent = e.textIndent ? 1 * e.textIndent * this.internal.scaleFactor / r : 0, s.lineIndent = e.lineIndent;
  var a, l, h = [];
  for (a = 0, l = i.length; a < l; a++) h = h.concat(og.apply(this, [i[a], o, s]));
  return h;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var t = "klmnopqrstuvwxyz", e = {}, i = {}, r = 0; r < t.length; r++) e[t[r]] = "0123456789abcdef"[r], i["0123456789abcdef"[r]] = t[r];
  var s = function(d) {
    return "0x" + parseInt(d, 10).toString(16);
  }, o = n.__fontmetrics__.compress = function(d) {
    var p, f, g, b, x = ["{"];
    for (var y in d) {
      if (p = d[y], isNaN(parseInt(y, 10)) ? f = "'" + y + "'" : (y = parseInt(y, 10), f = (f = s(y).slice(2)).slice(0, -1) + i[f.slice(-1)]), typeof p == "number") p < 0 ? (g = s(p).slice(3), b = "-") : (g = s(p).slice(2), b = ""), g = b + g.slice(0, -1) + i[g.slice(-1)];
      else {
        if (en(p) !== "object") throw new Error("Don't know what to do with value type " + en(p) + ".");
        g = o(p);
      }
      x.push(f + g);
    }
    return x.push("}"), x.join("");
  }, a = n.__fontmetrics__.uncompress = function(d) {
    if (typeof d != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var p, f, g, b, x = {}, y = 1, v = x, k = [], C = "", I = "", D = d.length - 1, E = 1; E < D; E += 1) (b = d[E]) == "'" ? p ? (g = p.join(""), p = void 0) : p = [] : p ? p.push(b) : b == "{" ? (k.push([v, g]), v = {}, g = void 0) : b == "}" ? ((f = k.pop())[0][f[1]] = v, g = void 0, v = f[0]) : b == "-" ? y = -1 : g === void 0 ? e.hasOwnProperty(b) ? (C += e[b], g = parseInt(C, 16) * y, y = 1, C = "") : C += b : e.hasOwnProperty(b) ? (I += e[b], v[g] = parseInt(I, 16) * y, y = 1, g = void 0, I = "") : I += b;
    return x;
  }, l = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: a("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h = { Unicode: { Courier: l, "Courier-Bold": l, "Courier-BoldOblique": l, "Courier-Oblique": l, Helvetica: l, "Helvetica-Bold": l, "Helvetica-BoldOblique": l, "Helvetica-Oblique": l, "Times-Roman": l, "Times-Bold": l, "Times-BoldItalic": l, "Times-Italic": l } }, u = { Unicode: { "Courier-Oblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": a("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": a("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: a("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: a("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": a("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": a("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(d) {
    var p = d.font, f = u.Unicode[p.postScriptName];
    f && (p.metadata.Unicode = {}, p.metadata.Unicode.widths = f.widths, p.metadata.Unicode.kerning = f.kerning);
    var g = h.Unicode[p.postScriptName];
    g && (p.metadata.Unicode.encoding = g, p.encoding = g.codePages[0]);
  }]);
}(Se.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    for (var i = e.length, r = new Uint8Array(i), s = 0; s < i; s++) r[s] = e.charCodeAt(s);
    return r;
  };
  n.API.events.push(["addFont", function(e) {
    var i = void 0, r = e.font, s = e.instance;
    if (!r.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      if (typeof (i = s.existsFileInVFS(r.postScriptName) === !1 ? s.loadFile(r.postScriptName) : s.getFileFromVFS(r.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      (function(o, a) {
        a = /^\x00\x01\x00\x00/.test(a) ? t(a) : t(Sl(a)), o.metadata = n.API.TTFFont.open(a), o.metadata.Unicode = o.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, o.metadata.glyIdsUsed = [0];
      })(r, i);
    }
  }]);
}(Se), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  function t() {
    return (Ae.canvg ? Promise.resolve(Ae.canvg) : import("./index.es-cQrfTWkA.js")).catch(function(e) {
      return Promise.reject(new Error("Could not load canvg: " + e));
    }).then(function(e) {
      return e.default ? e.default : e;
    });
  }
  Se.API.addSvgAsImage = function(e, i, r, s, o, a, l, h) {
    if (isNaN(i) || isNaN(r)) throw an.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(o)) throw an.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var u = document.createElement("canvas");
    u.width = s, u.height = o;
    var d = u.getContext("2d");
    d.fillStyle = "#fff", d.fillRect(0, 0, u.width, u.height);
    var p = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, f = this;
    return t().then(function(g) {
      return g.fromString(d, e, p);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(g) {
      return g.render(p);
    }).then(function() {
      f.addImage(u.toDataURL("image/jpeg", 1), i, r, s, o, l, h);
    });
  };
}(), Se.API.putTotalPages = function(n) {
  var t, e = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (t = new RegExp(n, "g"), e = this.internal.getNumberOfPages()) : (t = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), e = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++) for (var r = 0; r < this.internal.pages[i].length; r++) this.internal.pages[i][r] = this.internal.pages[i][r].replace(t, e);
  return this;
}, Se.API.viewerPreferences = function(n, t) {
  var e;
  n = n || {}, t = t || !1;
  var i, r, s, o = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, a = Object.keys(o), l = [], h = 0, u = 0, d = 0;
  function p(g, b) {
    var x, y = !1;
    for (x = 0; x < g.length; x += 1) g[x] === b && (y = !0);
    return y;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(o)), this.internal.viewerpreferences.isSubscribed = !1), e = this.internal.viewerpreferences.configuration, n === "reset" || t === !0) {
    var f = a.length;
    for (d = 0; d < f; d += 1) e[a[d]].value = e[a[d]].defaultValue, e[a[d]].explicitSet = !1;
  }
  if (en(n) === "object") {
    for (r in n) if (s = n[r], p(a, r) && s !== void 0) {
      if (e[r].type === "boolean" && typeof s == "boolean") e[r].value = s;
      else if (e[r].type === "name" && p(e[r].valueSet, s)) e[r].value = s;
      else if (e[r].type === "integer" && Number.isInteger(s)) e[r].value = s;
      else if (e[r].type === "array") {
        for (h = 0; h < s.length; h += 1) if (i = !0, s[h].length === 1 && typeof s[h][0] == "number") l.push(String(s[h] - 1));
        else if (s[h].length > 1) {
          for (u = 0; u < s[h].length; u += 1) typeof s[h][u] != "number" && (i = !1);
          i === !0 && l.push([s[h][0] - 1, s[h][1] - 1].join(" "));
        }
        e[r].value = "[" + l.join(" ") + "]";
      } else e[r].value = e[r].defaultValue;
      e[r].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var g, b = [];
    for (g in e) e[g].explicitSet === !0 && (e[g].type === "name" ? b.push("/" + g + " /" + e[g].value) : b.push("/" + g + " " + e[g].value));
    b.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + b.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = e, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  var t = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', r = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(i)), o = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), a = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), l = unescape(encodeURIComponent("</x:xmpmeta>")), h = s.length + o.length + a.length + r.length + l.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + h + " >>"), this.internal.write("stream"), this.internal.write(r + s + o + a + l), this.internal.write("endstream"), this.internal.write("endobj");
  }, e = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(i, r) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", e), this.internal.events.subscribe("postPutResources", t)), this;
  };
}(Se.API), function(n) {
  var t = n.API, e = t.pdfEscape16 = function(s, o) {
    for (var a, l = o.metadata.Unicode.widths, h = ["", "0", "00", "000", "0000"], u = [""], d = 0, p = s.length; d < p; ++d) {
      if (a = o.metadata.characterToGlyph(s.charCodeAt(d)), o.metadata.glyIdsUsed.push(a), o.metadata.toUnicode[a] = s.charCodeAt(d), l.indexOf(a) == -1 && (l.push(a), l.push([parseInt(o.metadata.widthOfGlyph(a), 10)])), a == "0") return u.join("");
      a = a.toString(16), u.push(h[4 - a.length], a);
    }
    return u.join("");
  }, i = function(s) {
    var o, a, l, h, u, d, p;
    for (u = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, l = [], d = 0, p = (a = Object.keys(s).sort(function(f, g) {
      return f - g;
    })).length; d < p; d++) o = a[d], l.length >= 100 && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar`, l = []), s[o] !== void 0 && s[o] !== null && typeof s[o].toString == "function" && (h = ("0000" + s[o].toString(16)).slice(-4), o = ("0000" + (+o).toString(16)).slice(-4), l.push("<" + o + "><" + h + ">"));
    return l.length && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar
`), u += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "Identity-H") {
        for (var d = a.metadata.Unicode.widths, p = a.metadata.subset.encode(a.metadata.glyIdsUsed, 1), f = "", g = 0; g < p.length; g++) f += String.fromCharCode(p[g]);
        var b = h();
        u({ data: f, addLength1: !0, objectId: b }), l("endobj");
        var x = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: x }), l("endobj");
        var y = h();
        l("<<"), l("/Type /FontDescriptor"), l("/FontName /" + da(a.fontName)), l("/FontFile2 " + b + " 0 R"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/Flags " + a.metadata.flags), l("/StemV " + a.metadata.stemV), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l(">>"), l("endobj");
        var v = h();
        l("<<"), l("/Type /Font"), l("/BaseFont /" + da(a.fontName)), l("/FontDescriptor " + y + " 0 R"), l("/W " + n.API.PDFObject.convert(d)), l("/CIDToGIDMap /Identity"), l("/DW 1000"), l("/Subtype /CIDFontType2"), l("/CIDSystemInfo"), l("<<"), l("/Supplement 0"), l("/Registry (Adobe)"), l("/Ordering (" + a.encoding + ")"), l(">>"), l(">>"), l("endobj"), a.objectNumber = h(), l("<<"), l("/Type /Font"), l("/Subtype /Type0"), l("/ToUnicode " + x + " 0 R"), l("/BaseFont /" + da(a.fontName)), l("/Encoding /" + a.encoding), l("/DescendantFonts [" + v + " 0 R]"), l(">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]), t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "WinAnsiEncoding") {
        for (var d = a.metadata.rawData, p = "", f = 0; f < d.length; f++) p += String.fromCharCode(d[f]);
        var g = h();
        u({ data: p, addLength1: !0, objectId: g }), l("endobj");
        var b = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: b }), l("endobj");
        var x = h();
        l("<<"), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l("/StemV " + a.metadata.stemV), l("/Type /FontDescriptor"), l("/FontFile2 " + g + " 0 R"), l("/Flags 96"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/FontName /" + da(a.fontName)), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l(">>"), l("endobj"), a.objectNumber = h();
        for (var y = 0; y < a.metadata.hmtx.widths.length; y++) a.metadata.hmtx.widths[y] = parseInt(a.metadata.hmtx.widths[y] * (1e3 / a.metadata.head.unitsPerEm));
        l("<</Subtype/TrueType/Type/Font/ToUnicode " + b + " 0 R/BaseFont/" + da(a.fontName) + "/FontDescriptor " + x + " 0 R/Encoding/" + a.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(a.metadata.hmtx.widths) + ">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var r = function(s) {
    var o, a = s.text || "", l = s.x, h = s.y, u = s.options || {}, d = s.mutex || {}, p = d.pdfEscape, f = d.activeFontKey, g = d.fonts, b = f, x = "", y = 0, v = "", k = g[b].encoding;
    if (g[b].encoding !== "Identity-H") return { text: a, x: l, y: h, options: u, mutex: d };
    for (v = a, b = f, Array.isArray(a) && (v = a[0]), y = 0; y < v.length; y += 1) g[b].metadata.hasOwnProperty("cmap") && (o = g[b].metadata.cmap.unicode.codeMap[v[y].charCodeAt(0)]), o || v[y].charCodeAt(0) < 256 && g[b].metadata.hasOwnProperty("Unicode") ? x += v[y] : x += "";
    var C = "";
    return parseInt(b.slice(1)) < 14 || k === "WinAnsiEncoding" ? C = p(x, b).split("").map(function(I) {
      return I.charCodeAt(0).toString(16);
    }).join("") : k === "Identity-H" && (C = e(x, g[b])), d.isHex = !0, { text: C, x: l, y: h, options: u, mutex: d };
  };
  t.events.push(["postProcessText", function(s) {
    var o = s.text || "", a = [], l = { text: o, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(o)) {
      var h = 0;
      for (h = 0; h < o.length; h += 1) Array.isArray(o[h]) && o[h].length === 3 ? a.push([r(Object.assign({}, l, { text: o[h][0] })).text, o[h][1], o[h][2]]) : a.push(r(Object.assign({}, l, { text: o[h] })).text);
      s.text = a;
    } else s.text = r(Object.assign({}, l, { text: o })).text;
  }]);
}(Se), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0;
  }, n.addFileToVFS = function(e, i) {
    return t.call(this), this.internal.vFS[e] = i, this;
  }, n.getFileFromVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0 ? this.internal.vFS[e] : null;
  };
}(Se.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(i) {
    var r, s, o, a, l, h, u, d = t, p = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], f = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], g = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, b = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, x = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], y = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), v = !1, k = 0;
    this.__bidiEngine__ = {};
    var C = function(P) {
      var A = P.charCodeAt(), F = A >> 8, _ = b[F];
      return _ !== void 0 ? d[256 * _ + (255 & A)] : F === 252 || F === 253 ? "AL" : y.test(F) ? "L" : F === 8 ? "R" : "N";
    }, I = function(P) {
      for (var A, F = 0; F < P.length; F++) {
        if ((A = C(P.charAt(F))) === "L") return !1;
        if (A === "R") return !0;
      }
      return !1;
    }, D = function(P, A, F, _) {
      var J, V, R, tt, H = A[_];
      switch (H) {
        case "L":
        case "R":
          v = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          v && (H = "AN");
          break;
        case "AL":
          v = !0, H = "R";
          break;
        case "WS":
          H = "N";
          break;
        case "CS":
          _ < 1 || _ + 1 >= A.length || (J = F[_ - 1]) !== "EN" && J !== "AN" || (V = A[_ + 1]) !== "EN" && V !== "AN" ? H = "N" : v && (V = "AN"), H = V === J ? V : "N";
          break;
        case "ES":
          H = (J = _ > 0 ? F[_ - 1] : "B") === "EN" && _ + 1 < A.length && A[_ + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (_ > 0 && F[_ - 1] === "EN") {
            H = "EN";
            break;
          }
          if (v) {
            H = "N";
            break;
          }
          for (R = _ + 1, tt = A.length; R < tt && A[R] === "ET"; ) R++;
          H = R < tt && A[R] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (o && !a) {
            for (tt = A.length, R = _ + 1; R < tt && A[R] === "NSM"; ) R++;
            if (R < tt) {
              var ct = P[_], it = ct >= 1425 && ct <= 2303 || ct === 64286;
              if (J = A[R], it && (J === "R" || J === "AL")) {
                H = "R";
                break;
              }
            }
          }
          H = _ < 1 || (J = A[_ - 1]) === "B" ? "N" : F[_ - 1];
          break;
        case "B":
          v = !1, r = !0, H = k;
          break;
        case "S":
          s = !0, H = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          v = !1;
          break;
        case "BN":
          H = "N";
      }
      return H;
    }, E = function(P, A, F) {
      var _ = P.split("");
      return F && O(_, F, { hiLevel: k }), _.reverse(), A && A.reverse(), _.join("");
    }, O = function(P, A, F) {
      var _, J, V, R, tt, H = -1, ct = P.length, it = 0, N = [], z = k ? f : p, G = [];
      for (v = !1, r = !1, s = !1, J = 0; J < ct; J++) G[J] = C(P[J]);
      for (V = 0; V < ct; V++) {
        if (tt = it, N[V] = D(P, G, N, V), _ = 240 & (it = z[tt][g[N[V]]]), it &= 15, A[V] = R = z[it][5], _ > 0) if (_ === 16) {
          for (J = H; J < V; J++) A[J] = 1;
          H = -1;
        } else H = -1;
        if (z[it][6]) H === -1 && (H = V);
        else if (H > -1) {
          for (J = H; J < V; J++) A[J] = R;
          H = -1;
        }
        G[V] === "B" && (A[V] = 0), F.hiLevel |= R;
      }
      s && function(Y, ot, xt) {
        for (var gt = 0; gt < xt; gt++) if (Y[gt] === "S") {
          ot[gt] = k;
          for (var wt = gt - 1; wt >= 0 && Y[wt] === "WS"; wt--) ot[wt] = k;
        }
      }(G, A, ct);
    }, M = function(P, A, F, _, J) {
      if (!(J.hiLevel < P)) {
        if (P === 1 && k === 1 && !r) return A.reverse(), void (F && F.reverse());
        for (var V, R, tt, H, ct = A.length, it = 0; it < ct; ) {
          if (_[it] >= P) {
            for (tt = it + 1; tt < ct && _[tt] >= P; ) tt++;
            for (H = it, R = tt - 1; H < R; H++, R--) V = A[H], A[H] = A[R], A[R] = V, F && (V = F[H], F[H] = F[R], F[R] = V);
            it = tt;
          }
          it++;
        }
      }
    }, q = function(P, A, F) {
      var _ = P.split(""), J = { hiLevel: k };
      return F || (F = []), O(_, F, J), function(V, R, tt) {
        if (tt.hiLevel !== 0 && u) for (var H, ct = 0; ct < V.length; ct++) R[ct] === 1 && (H = x.indexOf(V[ct])) >= 0 && (V[ct] = x[H + 1]);
      }(_, F, J), M(2, _, A, F, J), M(1, _, A, F, J), _.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(P, A, F) {
      if (function(J, V) {
        if (V) for (var R = 0; R < J.length; R++) V[R] = R;
        a === void 0 && (a = I(J)), h === void 0 && (h = I(J));
      }(P, A), o || !l || h) if (o && l && a ^ h) k = a ? 1 : 0, P = E(P, A, F);
      else if (!o && l && h) k = a ? 1 : 0, P = q(P, A, F), P = E(P, A);
      else if (!o || a || l || h) {
        if (o && !l && a ^ h) P = E(P, A), a ? (k = 0, P = q(P, A, F)) : (k = 1, P = q(P, A, F), P = E(P, A));
        else if (o && a && !l && h) k = 1, P = q(P, A, F), P = E(P, A);
        else if (!o && !l && a ^ h) {
          var _ = u;
          a ? (k = 1, P = q(P, A, F), k = 0, u = !1, P = q(P, A, F), u = _) : (k = 0, P = q(P, A, F), P = E(P, A), k = 1, u = !1, P = q(P, A, F), u = _, P = E(P, A));
        }
      } else k = 0, P = q(P, A, F);
      else k = a ? 1 : 0, P = q(P, A, F);
      return P;
    }, this.__bidiEngine__.setOptions = function(P) {
      P && (o = P.isInputVisual, l = P.isOutputVisual, a = P.isInputRtl, h = P.isOutputRtl, u = P.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var t = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], e = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(i) {
    var r = i.text, s = (i.x, i.y, i.options || {}), o = (i.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, e.setOptions(s), Object.prototype.toString.call(r) === "[object Array]") {
      var a = 0;
      for (o = [], a = 0; a < r.length; a += 1) Object.prototype.toString.call(r[a]) === "[object Array]" ? o.push([e.doBidiReorder(r[a][0]), r[a][1], r[a][2]]) : o.push([e.doBidiReorder(r[a])]);
      i.text = o;
    } else i.text = e.doBidiReorder(r);
    e.setOptions({ isInputVisual: !0 });
  }]);
}(Se), Se.API.TTFFont = function() {
  function n(t) {
    var e;
    if (this.rawData = t, e = this.contents = new Us(t), this.contents.pos = 4, e.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Zv(this), this.registerTTF();
  }
  return n.open = function(t) {
    return new n(t);
  }, n.prototype.parse = function() {
    return this.directory = new Bv(this.contents), this.head = new qv(this), this.name = new Hv(this), this.cmap = new B1(this), this.toUnicode = {}, this.hhea = new zv(this), this.maxp = new Gv(this), this.hmtx = new Vv(this), this.post = new Uv(this), this.os2 = new $v(this), this.loca = new Jv(this), this.glyf = new Yv(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var t, e, i, r, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var o, a, l, h;
      for (h = [], o = 0, a = (l = this.bbox).length; o < a; o++) t = l[o], h.push(Math.round(t * this.scaleFactor));
      return h;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (r = this.post.italic_angle), 32768 & (e = r >> 16) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(t) {
    var e;
    return ((e = this.cmap.unicode) != null ? e.codeMap[t] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(t) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * e;
  }, n.prototype.widthOfString = function(t, e, i) {
    var r, s, o, a;
    for (o = 0, s = 0, a = (t = "" + t).length; 0 <= a ? s < a : s > a; s = 0 <= a ? ++s : --s) r = t.charCodeAt(s), o += this.widthOfGlyph(this.characterToGlyph(r)) + i * (1e3 / e) || 0;
    return o * (e / 1e3);
  }, n.prototype.lineHeight = function(t, e) {
    var i;
    return e == null && (e = !1), i = e ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * t;
  }, n;
}();
var yr, Us = function() {
  function n(t) {
    this.data = t ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(t) {
    return this.data[this.pos++] = t;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(t) {
    return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt32 = function() {
    var t;
    return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t;
  }, n.prototype.writeInt32 = function(t) {
    return t < 0 && (t += 4294967296), this.writeUInt32(t);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(t) {
    return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt16 = function() {
    var t;
    return (t = this.readUInt16()) >= 32768 ? t - 65536 : t;
  }, n.prototype.writeInt16 = function(t) {
    return t < 0 && (t += 65536), this.writeUInt16(t);
  }, n.prototype.readString = function(t) {
    var e, i;
    for (i = [], e = 0; 0 <= t ? e < t : e > t; e = 0 <= t ? ++e : --e) i[e] = String.fromCharCode(this.readByte());
    return i.join("");
  }, n.prototype.writeString = function(t) {
    var e, i, r;
    for (r = [], e = 0, i = t.length; 0 <= i ? e < i : e > i; e = 0 <= i ? ++e : --e) r.push(this.writeByte(t.charCodeAt(e)));
    return r;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(t) {
    return this.writeInt16(t);
  }, n.prototype.readLongLong = function() {
    var t, e, i, r, s, o, a, l;
    return t = this.readByte(), e = this.readByte(), i = this.readByte(), r = this.readByte(), s = this.readByte(), o = this.readByte(), a = this.readByte(), l = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ s) + 65536 * (255 ^ o) + 256 * (255 ^ a) + (255 ^ l) + 1) : 72057594037927940 * t + 281474976710656 * e + 1099511627776 * i + 4294967296 * r + 16777216 * s + 65536 * o + 256 * a + l;
  }, n.prototype.writeLongLong = function(t) {
    var e, i;
    return e = Math.floor(t / 4294967296), i = 4294967295 & t, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(t) {
    return this.writeInt32(t);
  }, n.prototype.read = function(t) {
    var e, i;
    for (e = [], i = 0; 0 <= t ? i < t : i > t; i = 0 <= t ? ++i : --i) e.push(this.readByte());
    return e;
  }, n.prototype.write = function(t) {
    var e, i, r, s;
    for (s = [], i = 0, r = t.length; i < r; i++) e = t[i], s.push(this.writeByte(e));
    return s;
  }, n;
}(), Bv = function() {
  var n;
  function t(e) {
    var i, r, s;
    for (this.scalarType = e.readInt(), this.tableCount = e.readShort(), this.searchRange = e.readShort(), this.entrySelector = e.readShort(), this.rangeShift = e.readShort(), this.tables = {}, r = 0, s = this.tableCount; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = { tag: e.readString(4), checksum: e.readInt(), offset: e.readInt(), length: e.readInt() }, this.tables[i.tag] = i;
  }
  return t.prototype.encode = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, b;
    for (b in f = Object.keys(e).length, l = Math.log(2), d = 16 * Math.floor(Math.log(f) / l), o = Math.floor(d / l), u = 16 * f - d, (r = new Us()).writeInt(this.scalarType), r.writeShort(f), r.writeShort(d), r.writeShort(o), r.writeShort(u), s = 16 * f, h = r.pos + s, a = null, g = [], e) for (p = e[b], r.writeString(b), r.writeInt(n(p)), r.writeInt(h), r.writeInt(p.length), g = g.concat(p), b === "head" && (a = h), h += p.length; h % 4; ) g.push(0), h++;
    return r.write(g), i = 2981146554 - n(r.data), r.pos = a + 8, r.writeUInt32(i), r.data;
  }, n = function(e) {
    var i, r, s, o;
    for (e = j1.call(e); e.length % 4; ) e.push(0);
    for (s = new Us(e), r = 0, i = 0, o = e.length; i < o; i = i += 4) r += s.readUInt32();
    return 4294967295 & r;
  }, t;
}(), jv = {}.hasOwnProperty, Mr = function(n, t) {
  for (var e in t) jv.call(t, e) && (n[e] = t[e]);
  function i() {
    this.constructor = n;
  }
  return i.prototype = t.prototype, n.prototype = new i(), n.__super__ = t.prototype, n;
};
yr = function() {
  function n(t) {
    var e;
    this.file = t, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var qv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "head", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.revision = e.readInt(), this.checkSumAdjustment = e.readInt(), this.magicNumber = e.readInt(), this.flags = e.readShort(), this.unitsPerEm = e.readShort(), this.created = e.readLongLong(), this.modified = e.readLongLong(), this.xMin = e.readShort(), this.yMin = e.readShort(), this.xMax = e.readShort(), this.yMax = e.readShort(), this.macStyle = e.readShort(), this.lowestRecPPEM = e.readShort(), this.fontDirectionHint = e.readShort(), this.indexToLocFormat = e.readShort(), this.glyphDataFormat = e.readShort();
  }, t.prototype.encode = function(e) {
    var i;
    return (i = new Us()).writeInt(this.version), i.writeInt(this.revision), i.writeInt(this.checkSumAdjustment), i.writeInt(this.magicNumber), i.writeShort(this.flags), i.writeShort(this.unitsPerEm), i.writeLongLong(this.created), i.writeLongLong(this.modified), i.writeShort(this.xMin), i.writeShort(this.yMin), i.writeShort(this.xMax), i.writeShort(this.yMax), i.writeShort(this.macStyle), i.writeShort(this.lowestRecPPEM), i.writeShort(this.fontDirectionHint), i.writeShort(e), i.writeShort(this.glyphDataFormat), i.data;
  }, t;
}(), ug = function() {
  function n(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, b, x, y, v, k;
    switch (this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = e + t.readInt(), d = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (l = 0; l < 256; ++l) this.codeMap[l] = t.readByte();
        break;
      case 4:
        for (f = t.readUInt16(), p = f / 2, t.pos += 6, s = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), t.pos += 2, b = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), h = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), u = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), r = (this.length - t.pos + this.offset) / 2, a = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= r ? C < r : C > r; l = 0 <= r ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), l = y = 0, k = s.length; y < k; l = ++y) for (x = s[l], i = v = g = b[l]; g <= x ? v <= x : v >= x; i = g <= x ? ++v : --v) u[l] === 0 ? o = i + h[l] : (o = a[u[l] / 2 + (i - g) - (p - l)] || 0) !== 0 && (o += h[l]), this.codeMap[i] = 65535 & o;
    }
    t.pos = d;
  }
  return n.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, b, x, y, v, k, C, I, D, E, O, M, q, P, A, F, _, J, V, R, tt, H, ct, it, N, z, G, Y, ot, xt, gt, wt, qt, Rt, Yt;
    switch (_ = new Us(), o = Object.keys(t).sort(function(Kt, T) {
      return Kt - T;
    }), e) {
      case "macroman":
        for (b = 0, x = function() {
          var Kt = [];
          for (g = 0; g < 256; ++g) Kt.push(0);
          return Kt;
        }(), v = { 0: 0 }, s = {}, J = 0, H = o.length; J < H; J++) v[wt = t[r = o[J]]] == null && (v[wt] = ++b), s[r] = { old: t[r], new: v[t[r]] }, x[r] = v[t[r]];
        return _.writeUInt16(1), _.writeUInt16(0), _.writeUInt32(12), _.writeUInt16(0), _.writeUInt16(262), _.writeUInt16(0), _.write(x), { charMap: s, subtable: _.data, maxGlyphID: b + 1 };
      case "unicode":
        for (A = [], d = [], k = 0, v = {}, i = {}, y = h = null, V = 0, ct = o.length; V < ct; V++) v[I = t[r = o[V]]] == null && (v[I] = ++k), i[r] = { old: I, new: v[I] }, a = v[I] - r, y != null && a === h || (y && d.push(y), A.push(r), h = a), y = r;
        for (y && d.push(y), d.push(65535), A.push(65535), q = 2 * (M = A.length), O = 2 * Math.pow(Math.log(M) / Math.LN2, 2), p = Math.log(O / 2) / Math.LN2, E = 2 * M - O, l = [], D = [], f = [], g = R = 0, it = A.length; R < it; g = ++R) {
          if (P = A[g], u = d[g], P === 65535) {
            l.push(0), D.push(0);
            break;
          }
          if (P - (F = i[P].new) >= 32768) for (l.push(0), D.push(2 * (f.length + M - g)), r = tt = P; P <= u ? tt <= u : tt >= u; r = P <= u ? ++tt : --tt) f.push(i[r].new);
          else l.push(F - P), D.push(0);
        }
        for (_.writeUInt16(3), _.writeUInt16(1), _.writeUInt32(12), _.writeUInt16(4), _.writeUInt16(16 + 8 * M + 2 * f.length), _.writeUInt16(0), _.writeUInt16(q), _.writeUInt16(O), _.writeUInt16(p), _.writeUInt16(E), xt = 0, N = d.length; xt < N; xt++) r = d[xt], _.writeUInt16(r);
        for (_.writeUInt16(0), gt = 0, z = A.length; gt < z; gt++) r = A[gt], _.writeUInt16(r);
        for (qt = 0, G = l.length; qt < G; qt++) a = l[qt], _.writeUInt16(a);
        for (Rt = 0, Y = D.length; Rt < Y; Rt++) C = D[Rt], _.writeUInt16(C);
        for (Yt = 0, ot = f.length; Yt < ot; Yt++) b = f[Yt], _.writeUInt16(b);
        return { charMap: i, subtable: _.data, maxGlyphID: k + 1 };
    }
  }, n;
}(), B1 = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "cmap", t.prototype.parse = function(e) {
    var i, r, s;
    for (e.pos = this.offset, this.version = e.readUInt16(), s = e.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = new ug(e, this.offset), this.tables.push(i), i.isUnicode && this.unicode == null && (this.unicode = i);
    return !0;
  }, t.encode = function(e, i) {
    var r, s;
    return i == null && (i = "macroman"), r = ug.encode(e, i), (s = new Us()).writeUInt16(0), s.writeUInt16(1), r.table = s.data.concat(r.subtable), r;
  }, t;
}(), zv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "hhea", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.ascender = e.readShort(), this.decender = e.readShort(), this.lineGap = e.readShort(), this.advanceWidthMax = e.readShort(), this.minLeftSideBearing = e.readShort(), this.minRightSideBearing = e.readShort(), this.xMaxExtent = e.readShort(), this.caretSlopeRise = e.readShort(), this.caretSlopeRun = e.readShort(), this.caretOffset = e.readShort(), e.pos += 8, this.metricDataFormat = e.readShort(), this.numberOfMetrics = e.readUInt16();
  }, t;
}(), $v = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "OS/2", t.prototype.parse = function(e) {
    if (e.pos = this.offset, this.version = e.readUInt16(), this.averageCharWidth = e.readShort(), this.weightClass = e.readUInt16(), this.widthClass = e.readUInt16(), this.type = e.readShort(), this.ySubscriptXSize = e.readShort(), this.ySubscriptYSize = e.readShort(), this.ySubscriptXOffset = e.readShort(), this.ySubscriptYOffset = e.readShort(), this.ySuperscriptXSize = e.readShort(), this.ySuperscriptYSize = e.readShort(), this.ySuperscriptXOffset = e.readShort(), this.ySuperscriptYOffset = e.readShort(), this.yStrikeoutSize = e.readShort(), this.yStrikeoutPosition = e.readShort(), this.familyClass = e.readShort(), this.panose = function() {
      var i, r;
      for (r = [], i = 0; i < 10; ++i) r.push(e.readByte());
      return r;
    }(), this.charRange = function() {
      var i, r;
      for (r = [], i = 0; i < 4; ++i) r.push(e.readInt());
      return r;
    }(), this.vendorID = e.readString(4), this.selection = e.readShort(), this.firstCharIndex = e.readShort(), this.lastCharIndex = e.readShort(), this.version > 0 && (this.ascent = e.readShort(), this.descent = e.readShort(), this.lineGap = e.readShort(), this.winAscent = e.readShort(), this.winDescent = e.readShort(), this.codePageRange = function() {
      var i, r;
      for (r = [], i = 0; i < 2; i = ++i) r.push(e.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = e.readShort(), this.capHeight = e.readShort(), this.defaultChar = e.readShort(), this.breakChar = e.readShort(), this.maxContext = e.readShort();
  }, t;
}(), Uv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "post", t.prototype.parse = function(e) {
    var i, r, s;
    switch (e.pos = this.offset, this.format = e.readInt(), this.italicAngle = e.readInt(), this.underlinePosition = e.readShort(), this.underlineThickness = e.readShort(), this.isFixedPitch = e.readInt(), this.minMemType42 = e.readInt(), this.maxMemType42 = e.readInt(), this.minMemType1 = e.readInt(), this.maxMemType1 = e.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var o;
        for (r = e.readUInt16(), this.glyphNameIndex = [], o = 0; 0 <= r ? o < r : o > r; o = 0 <= r ? ++o : --o) this.glyphNameIndex.push(e.readUInt16());
        for (this.names = [], s = []; e.pos < this.offset + this.length; ) i = e.readByte(), s.push(this.names.push(e.readString(i)));
        return s;
      case 151552:
        return r = e.readUInt16(), this.offsets = e.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var a, l, h;
          for (h = [], o = a = 0, l = this.file.maxp.numGlyphs; 0 <= l ? a < l : a > l; o = 0 <= l ? ++a : --a) h.push(e.readUInt32());
          return h;
        }).call(this);
    }
  }, t;
}(), Wv = function(n, t) {
  this.raw = n, this.length = n.length, this.platformID = t.platformID, this.encodingID = t.encodingID, this.languageID = t.languageID;
}, Hv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "name", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f;
    for (e.pos = this.offset, e.readShort(), i = e.readShort(), l = e.readShort(), r = [], o = 0; 0 <= i ? o < i : o > i; o = 0 <= i ? ++o : --o) r.push({ platformID: e.readShort(), encodingID: e.readShort(), languageID: e.readShort(), nameID: e.readShort(), length: e.readShort(), offset: this.offset + l + e.readShort() });
    for (h = {}, o = d = 0, p = r.length; d < p; o = ++d) s = r[o], e.pos = s.offset, u = e.readString(s.length), a = new Wv(u, s), h[f = s.nameID] == null && (h[f] = []), h[s.nameID].push(a);
    this.strings = h, this.copyright = h[0], this.fontFamily = h[1], this.fontSubfamily = h[2], this.uniqueSubfamily = h[3], this.fontName = h[4], this.version = h[5];
    try {
      this.postscriptName = h[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = h[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = h[7], this.manufacturer = h[8], this.designer = h[9], this.description = h[10], this.vendorUrl = h[11], this.designerUrl = h[12], this.license = h[13], this.licenseUrl = h[14], this.preferredFamily = h[15], this.preferredSubfamily = h[17], this.compatibleFull = h[18], this.sampleText = h[19];
  }, t;
}(), Gv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "maxp", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.numGlyphs = e.readUInt16(), this.maxPoints = e.readUInt16(), this.maxContours = e.readUInt16(), this.maxCompositePoints = e.readUInt16(), this.maxComponentContours = e.readUInt16(), this.maxZones = e.readUInt16(), this.maxTwilightPoints = e.readUInt16(), this.maxStorage = e.readUInt16(), this.maxFunctionDefs = e.readUInt16(), this.maxInstructionDefs = e.readUInt16(), this.maxStackElements = e.readUInt16(), this.maxSizeOfInstructions = e.readUInt16(), this.maxComponentElements = e.readUInt16(), this.maxComponentDepth = e.readUInt16();
  }, t;
}(), Vv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "hmtx", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h;
    for (e.pos = this.offset, this.metrics = [], i = 0, l = this.file.hhea.numberOfMetrics; 0 <= l ? i < l : i > l; i = 0 <= l ? ++i : --i) this.metrics.push({ advance: e.readUInt16(), lsb: e.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var u, d;
      for (d = [], i = u = 0; 0 <= s ? u < s : u > s; i = 0 <= s ? ++u : --u) d.push(e.readInt16());
      return d;
    }(), this.widths = (function() {
      var u, d, p, f;
      for (f = [], u = 0, d = (p = this.metrics).length; u < d; u++) o = p[u], f.push(o.advance);
      return f;
    }).call(this), r = this.widths[this.widths.length - 1], h = [], i = a = 0; 0 <= s ? a < s : a > s; i = 0 <= s ? ++a : --a) h.push(this.widths.push(r));
    return h;
  }, t.prototype.forGlyph = function(e) {
    return e in this.metrics ? this.metrics[e] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[e - this.metrics.length] };
  }, t;
}(), j1 = [].slice, Yv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "glyf", t.prototype.parse = function() {
    return this.cache = {};
  }, t.prototype.glyphFor = function(e) {
    var i, r, s, o, a, l, h, u, d, p;
    return e in this.cache ? this.cache[e] : (o = this.file.loca, i = this.file.contents, r = o.indexOf(e), (s = o.lengthOf(e)) === 0 ? this.cache[e] = null : (i.pos = this.offset + r, a = (l = new Us(i.read(s))).readShort(), u = l.readShort(), p = l.readShort(), h = l.readShort(), d = l.readShort(), this.cache[e] = a === -1 ? new Xv(l, u, p, h, d) : new Kv(l, a, u, p, h, d), this.cache[e]));
  }, t.prototype.encode = function(e, i, r) {
    var s, o, a, l, h;
    for (a = [], o = [], l = 0, h = i.length; l < h; l++) s = e[i[l]], o.push(a.length), s && (a = a.concat(s.encode(r)));
    return o.push(a.length), { table: a, offsets: o };
  }, t;
}(), Kv = function() {
  function n(t, e, i, r, s, o) {
    this.raw = t, this.numberOfContours = e, this.xMin = i, this.yMin = r, this.xMax = s, this.yMax = o, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), Xv = function() {
  function n(t, e, i, r, s) {
    var o, a;
    for (this.raw = t, this.xMin = e, this.yMin = i, this.xMax = r, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], o = this.raw; a = o.readShort(), this.glyphOffsets.push(o.pos), this.glyphIDs.push(o.readUInt16()), 32 & a; ) o.pos += 1 & a ? 4 : 2, 128 & a ? o.pos += 8 : 64 & a ? o.pos += 4 : 8 & a && (o.pos += 2);
  }
  return n.prototype.encode = function() {
    var t, e, i;
    for (e = new Us(j1.call(this.raw.data)), t = 0, i = this.glyphIDs.length; t < i; ++t) e.pos = this.glyphOffsets[t];
    return e.data;
  }, n;
}(), Jv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Mr(t, yr), t.prototype.tag = "loca", t.prototype.parse = function(e) {
    var i, r;
    return e.pos = this.offset, i = this.file.head.indexToLocFormat, this.offsets = i === 0 ? (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 2) o.push(2 * e.readUInt16());
      return o;
    }).call(this) : (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 4) o.push(e.readUInt32());
      return o;
    }).call(this);
  }, t.prototype.indexOf = function(e) {
    return this.offsets[e];
  }, t.prototype.lengthOf = function(e) {
    return this.offsets[e + 1] - this.offsets[e];
  }, t.prototype.encode = function(e, i) {
    for (var r = new Uint32Array(this.offsets.length), s = 0, o = 0, a = 0; a < r.length; ++a) if (r[a] = s, o < i.length && i[o] == a) {
      ++o, r[a] = s;
      var l = this.offsets[a], h = this.offsets[a + 1] - l;
      h > 0 && (s += h);
    }
    for (var u = new Array(4 * r.length), d = 0; d < r.length; ++d) u[4 * d + 3] = 255 & r[d], u[4 * d + 2] = (65280 & r[d]) >> 8, u[4 * d + 1] = (16711680 & r[d]) >> 16, u[4 * d] = (4278190080 & r[d]) >> 24;
    return u;
  }, t;
}(), Zv = function() {
  function n(t) {
    this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var t, e, i, r, s;
    for (e in r = this.font.cmap.tables[0].codeMap, t = {}, s = this.subset) i = s[e], t[e] = r[i];
    return t;
  }, n.prototype.glyphsFor = function(t) {
    var e, i, r, s, o, a, l;
    for (r = {}, o = 0, a = t.length; o < a; o++) r[s = t[o]] = this.font.glyf.glyphFor(s);
    for (s in e = [], r) (i = r[s]) != null && i.compound && e.push.apply(e, i.glyphIDs);
    if (e.length > 0) for (s in l = this.glyphsFor(e)) i = l[s], r[s] = i;
    return r;
  }, n.prototype.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, b, x, y;
    for (r in i = B1.encode(this.generateCmap(), "unicode"), o = this.glyphsFor(t), f = { 0: 0 }, y = i.charMap) f[(l = y[r]).old] = l.new;
    for (g in p = i.maxGlyphID, o) g in f || (f[g] = p++);
    return u = function(v) {
      var k, C;
      for (k in C = {}, v) C[v[k]] = k;
      return C;
    }(f), d = Object.keys(u).sort(function(v, k) {
      return v - k;
    }), b = function() {
      var v, k, C;
      for (C = [], v = 0, k = d.length; v < k; v++) a = d[v], C.push(u[a]);
      return C;
    }(), s = this.font.glyf.encode(o, b, f), h = this.font.loca.encode(s.offsets, b), x = { cmap: this.font.cmap.raw(), glyf: s.table, loca: h, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (x["OS/2"] = this.font.os2.raw()), this.font.directory.encode(x);
  }, n;
}();
Se.API.PDFObject = function() {
  var n;
  function t() {
  }
  return n = function(e, i) {
    return (Array(i + 1).join("0") + e).slice(-i);
  }, t.convert = function(e) {
    var i, r, s, o;
    if (Array.isArray(e)) return "[" + function() {
      var a, l, h;
      for (h = [], a = 0, l = e.length; a < l; a++) i = e[a], h.push(t.convert(i));
      return h;
    }().join(" ") + "]";
    if (typeof e == "string") return "/" + e;
    if (e != null && e.isString) return "(" + e + ")";
    if (e instanceof Date) return "(D:" + n(e.getUTCFullYear(), 4) + n(e.getUTCMonth(), 2) + n(e.getUTCDate(), 2) + n(e.getUTCHours(), 2) + n(e.getUTCMinutes(), 2) + n(e.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(e) === "[object Object]") {
      for (r in s = ["<<"], e) o = e[r], s.push("/" + r + " " + t.convert(o));
      return s.push(">>"), s.join(`
`);
    }
    return "" + e;
  }, t;
}();
const Qv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, AcroForm: Iv, AcroFormAppearance: he, AcroFormButton: jn, AcroFormCheckBox: Nl, AcroFormChoiceField: bo, AcroFormComboBox: wo, AcroFormEditBox: kl, AcroFormListBox: vo, AcroFormPasswordField: Cl, AcroFormPushButton: Al, AcroFormRadioButton: xo, AcroFormTextField: js, GState: Ll, ShadingPattern: Ts, TilingPattern: po, default: Se, jsPDF: Se }, Symbol.toStringTag, { value: "Module" }));
var q1 = { exports: {} };
const tw = /* @__PURE__ */ xy(Qv);
/*!
* 
*               jsPDF AutoTable plugin v3.8.4
*
*               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
*               Licensed under the MIT License.
*               http://opensource.org/licenses/mit-license
*
*/
(function(n, t) {
  (function(i, r) {
    n.exports = r(function() {
      try {
        return tw;
      } catch {
      }
    }());
  })(typeof globalThis < "u" ? globalThis : typeof ho < "u" ? ho : typeof window < "u" ? window : typeof self < "u" ? self : ho, function(e) {
    return (
      /******/
      function() {
        var i = {
          /***/
          172: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var p = function(f, g) {
                  return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b, x) {
                    b.__proto__ = x;
                  } || function(b, x) {
                    for (var y in x) Object.prototype.hasOwnProperty.call(x, y) && (b[y] = x[y]);
                  }, p(f, g);
                };
                return function(f, g) {
                  if (typeof g != "function" && g !== null)
                    throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                  p(f, g);
                  function b() {
                    this.constructor = f;
                  }
                  f.prototype = g === null ? Object.create(g) : (b.prototype = g.prototype, new b());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.CellHookData = l.HookData = void 0;
              var u = (
                /** @class */
                /* @__PURE__ */ function() {
                  function p(f, g, b) {
                    this.table = g, this.pageNumber = g.pageNumber, this.pageCount = this.pageNumber, this.settings = g.settings, this.cursor = b, this.doc = f.getDocument();
                  }
                  return p;
                }()
              );
              l.HookData = u;
              var d = (
                /** @class */
                function(p) {
                  h(f, p);
                  function f(g, b, x, y, v, k) {
                    var C = p.call(this, g, b, k) || this;
                    return C.cell = x, C.row = y, C.column = v, C.section = y.section, C;
                  }
                  return f;
                }(u)
              );
              l.CellHookData = d;
            }
          ),
          /***/
          340: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              var u = h(4), d = h(136), p = h(744), f = h(776), g = h(664), b = h(972);
              function x(y) {
                y.API.autoTable = function() {
                  for (var v = [], k = 0; k < arguments.length; k++)
                    v[k] = arguments[k];
                  var C;
                  v.length === 1 ? C = v[0] : (console.error("Use of deprecated autoTable initiation"), C = v[2] || {}, C.columns = v[0], C.body = v[1]);
                  var I = (0, f.parseInput)(this, C), D = (0, b.createTable)(this, I);
                  return (0, g.drawTable)(this, D), this;
                }, y.API.lastAutoTable = !1, y.API.previousAutoTable = !1, y.API.autoTable.previous = !1, y.API.autoTableText = function(v, k, C, I) {
                  (0, d.default)(v, k, C, I, this);
                }, y.API.autoTableSetDefaults = function(v) {
                  return p.DocHandler.setDefaults(v, this), this;
                }, y.autoTableSetDefaults = function(v, k) {
                  p.DocHandler.setDefaults(v, k);
                }, y.API.autoTableHtmlToJson = function(v, k) {
                  var C;
                  if (k === void 0 && (k = !1), typeof window > "u")
                    return console.error("Cannot run autoTableHtmlToJson in non browser environment"), null;
                  var I = new p.DocHandler(this), D = (0, u.parseHtml)(I, v, window, k, !1), E = D.head, O = D.body, M = ((C = E[0]) === null || C === void 0 ? void 0 : C.map(function(q) {
                    return q.content;
                  })) || [];
                  return { columns: M, rows: O, data: O };
                }, y.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var v = this.lastAutoTable;
                  return v && v.finalY ? v.finalY : 0;
                }, y.API.autoTableAddPageContent = function(v) {
                  return console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead."), y.API.autoTable.globalDefaults || (y.API.autoTable.globalDefaults = {}), y.API.autoTable.globalDefaults.addPageContent = v, this;
                }, y.API.autoTableAddPage = function() {
                  return console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()"), this.addPage(), this;
                };
              }
              l.default = x;
            }
          ),
          /***/
          136: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(u, d, p, f, g) {
                f = f || {};
                var b = 1.15, x = g.internal.scaleFactor, y = g.internal.getFontSize() / x, v = g.getLineHeightFactor ? g.getLineHeightFactor() : b, k = y * v, C = /\r\n|\r|\n/g, I = "", D = 1;
                if ((f.valign === "middle" || f.valign === "bottom" || f.halign === "center" || f.halign === "right") && (I = typeof u == "string" ? u.split(C) : u, D = I.length || 1), p += y * (2 - b), f.valign === "middle" ? p -= D / 2 * k : f.valign === "bottom" && (p -= D * k), f.halign === "center" || f.halign === "right") {
                  var E = y;
                  if (f.halign === "center" && (E *= 0.5), I && D >= 1) {
                    for (var O = 0; O < I.length; O++)
                      g.text(I[O], d - g.getStringUnitWidth(I[O]) * E, p), p += k;
                    return g;
                  }
                  d -= g.getStringUnitWidth(u) * E;
                }
                return f.halign === "justify" ? g.text(u, d, p, {
                  maxWidth: f.maxWidth || 100,
                  align: "justify"
                }) : g.text(u, d, p), g;
              }
              l.default = h;
            }
          ),
          /***/
          420: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getPageAvailableWidth = l.parseSpacing = l.getFillStyle = l.addTableBorder = l.getStringWidth = void 0;
              function h(g, b, x) {
                x.applyStyles(b, !0);
                var y = Array.isArray(g) ? g : [g], v = y.map(function(k) {
                  return x.getTextWidth(k);
                }).reduce(function(k, C) {
                  return Math.max(k, C);
                }, 0);
                return v;
              }
              l.getStringWidth = h;
              function u(g, b, x, y) {
                var v = b.settings.tableLineWidth, k = b.settings.tableLineColor;
                g.applyStyles({ lineWidth: v, lineColor: k });
                var C = d(v, !1);
                C && g.rect(x.x, x.y, b.getWidth(g.pageSize().width), y.y - x.y, C);
              }
              l.addTableBorder = u;
              function d(g, b) {
                var x = g > 0, y = b || b === 0;
                return x && y ? "DF" : x ? "S" : y ? "F" : null;
              }
              l.getFillStyle = d;
              function p(g, b) {
                var x, y, v, k;
                if (g = g || b, Array.isArray(g)) {
                  if (g.length >= 4)
                    return {
                      top: g[0],
                      right: g[1],
                      bottom: g[2],
                      left: g[3]
                    };
                  if (g.length === 3)
                    return {
                      top: g[0],
                      right: g[1],
                      bottom: g[2],
                      left: g[1]
                    };
                  if (g.length === 2)
                    return {
                      top: g[0],
                      right: g[1],
                      bottom: g[0],
                      left: g[1]
                    };
                  g.length === 1 ? g = g[0] : g = b;
                }
                return typeof g == "object" ? (typeof g.vertical == "number" && (g.top = g.vertical, g.bottom = g.vertical), typeof g.horizontal == "number" && (g.right = g.horizontal, g.left = g.horizontal), {
                  left: (x = g.left) !== null && x !== void 0 ? x : b,
                  top: (y = g.top) !== null && y !== void 0 ? y : b,
                  right: (v = g.right) !== null && v !== void 0 ? v : b,
                  bottom: (k = g.bottom) !== null && k !== void 0 ? k : b
                }) : (typeof g != "number" && (g = b), { top: g, right: g, bottom: g, left: g });
              }
              l.parseSpacing = p;
              function f(g, b) {
                var x = p(b.settings.margin, 0);
                return g.pageSize().width - (x.left + x.right);
              }
              l.getPageAvailableWidth = f;
            }
          ),
          /***/
          796: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var f = function(g, b) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(x, y) {
                    x.__proto__ = y;
                  } || function(x, y) {
                    for (var v in y) Object.prototype.hasOwnProperty.call(y, v) && (x[v] = y[v]);
                  }, f(g, b);
                };
                return function(g, b) {
                  if (typeof b != "function" && b !== null)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                  f(g, b);
                  function x() {
                    this.constructor = g;
                  }
                  g.prototype = b === null ? Object.create(b) : (x.prototype = b.prototype, new x());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getTheme = l.defaultStyles = l.HtmlRowInput = void 0;
              var u = (
                /** @class */
                function(f) {
                  h(g, f);
                  function g(b) {
                    var x = f.call(this) || this;
                    return x._element = b, x;
                  }
                  return g;
                }(Array)
              );
              l.HtmlRowInput = u;
              function d(f) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: !1,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / f,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              l.defaultStyles = d;
              function p(f) {
                var g = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return g[f];
              }
              l.getTheme = p;
            }
          ),
          /***/
          903: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseCss = void 0;
              var u = h(420);
              function d(x, y, v, k, C) {
                var I = {}, D = 1.3333333333333333, E = f(y, function(H) {
                  return C.getComputedStyle(H).backgroundColor;
                });
                E != null && (I.fillColor = E);
                var O = f(y, function(H) {
                  return C.getComputedStyle(H).color;
                });
                O != null && (I.textColor = O);
                var M = b(k, v);
                M && (I.cellPadding = M);
                var q = "borderTopColor", P = D * v, A = k.borderTopWidth;
                if (k.borderBottomWidth === A && k.borderRightWidth === A && k.borderLeftWidth === A) {
                  var F = (parseFloat(A) || 0) / P;
                  F && (I.lineWidth = F);
                } else
                  I.lineWidth = {
                    top: (parseFloat(k.borderTopWidth) || 0) / P,
                    right: (parseFloat(k.borderRightWidth) || 0) / P,
                    bottom: (parseFloat(k.borderBottomWidth) || 0) / P,
                    left: (parseFloat(k.borderLeftWidth) || 0) / P
                  }, I.lineWidth.top || (I.lineWidth.right ? q = "borderRightColor" : I.lineWidth.bottom ? q = "borderBottomColor" : I.lineWidth.left && (q = "borderLeftColor"));
                var _ = f(y, function(H) {
                  return C.getComputedStyle(H)[q];
                });
                _ != null && (I.lineColor = _);
                var J = ["left", "right", "center", "justify"];
                J.indexOf(k.textAlign) !== -1 && (I.halign = k.textAlign), J = ["middle", "bottom", "top"], J.indexOf(k.verticalAlign) !== -1 && (I.valign = k.verticalAlign);
                var V = parseInt(k.fontSize || "");
                isNaN(V) || (I.fontSize = V / D);
                var R = p(k);
                R && (I.fontStyle = R);
                var tt = (k.fontFamily || "").toLowerCase();
                return x.indexOf(tt) !== -1 && (I.font = tt), I;
              }
              l.parseCss = d;
              function p(x) {
                var y = "";
                return (x.fontWeight === "bold" || x.fontWeight === "bolder" || parseInt(x.fontWeight) >= 700) && (y = "bold"), (x.fontStyle === "italic" || x.fontStyle === "oblique") && (y += "italic"), y;
              }
              function f(x, y) {
                var v = g(x, y);
                if (!v)
                  return null;
                var k = v.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!k || !Array.isArray(k))
                  return null;
                var C = [
                  parseInt(k[1]),
                  parseInt(k[2]),
                  parseInt(k[3])
                ], I = parseInt(k[4]);
                return I === 0 || isNaN(C[0]) || isNaN(C[1]) || isNaN(C[2]) ? null : C;
              }
              function g(x, y) {
                var v = y(x);
                return v === "rgba(0, 0, 0, 0)" || v === "transparent" || v === "initial" || v === "inherit" ? x.parentElement == null ? null : g(x.parentElement, y) : v;
              }
              function b(x, y) {
                var v = [
                  x.paddingTop,
                  x.paddingRight,
                  x.paddingBottom,
                  x.paddingLeft
                ], k = 96 / (72 / y), C = (parseInt(x.lineHeight) - parseInt(x.fontSize)) / y / 2, I = v.map(function(E) {
                  return parseInt(E || "0") / k;
                }), D = (0, u.parseSpacing)(I, 0);
                return C > D.top && (D.top = C), C > D.bottom && (D.bottom = C), D;
              }
            }
          ),
          /***/
          744: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.DocHandler = void 0;
              var h = {}, u = (
                /** @class */
                function() {
                  function d(p) {
                    this.jsPDFDocument = p, this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: p.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: p.internal.getFontSize(),
                      fontStyle: p.internal.getFont().fontStyle,
                      font: p.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: p.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: p.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  return d.setDefaults = function(p, f) {
                    f === void 0 && (f = null), f ? f.__autoTableDocumentDefaults = p : h = p;
                  }, d.unifyColor = function(p) {
                    return Array.isArray(p) ? p : typeof p == "number" ? [p, p, p] : typeof p == "string" ? [p] : null;
                  }, d.prototype.applyStyles = function(p, f) {
                    var g, b, x;
                    f === void 0 && (f = !1), p.fontStyle && this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(p.fontStyle);
                    var y = this.jsPDFDocument.internal.getFont(), v = y.fontStyle, k = y.fontName;
                    if (p.font && (k = p.font), p.fontStyle) {
                      v = p.fontStyle;
                      var C = this.getFontList()[k];
                      C && C.indexOf(v) === -1 && (this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(C[0]), v = C[0]);
                    }
                    if (this.jsPDFDocument.setFont(k, v), p.fontSize && this.jsPDFDocument.setFontSize(p.fontSize), !f) {
                      var I = d.unifyColor(p.fillColor);
                      I && (g = this.jsPDFDocument).setFillColor.apply(g, I), I = d.unifyColor(p.textColor), I && (b = this.jsPDFDocument).setTextColor.apply(b, I), I = d.unifyColor(p.lineColor), I && (x = this.jsPDFDocument).setDrawColor.apply(x, I), typeof p.lineWidth == "number" && this.jsPDFDocument.setLineWidth(p.lineWidth);
                    }
                  }, d.prototype.splitTextToSize = function(p, f, g) {
                    return this.jsPDFDocument.splitTextToSize(p, f, g);
                  }, d.prototype.rect = function(p, f, g, b, x) {
                    return this.jsPDFDocument.rect(p, f, g, b, x);
                  }, d.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  }, d.prototype.getTextWidth = function(p) {
                    return this.jsPDFDocument.getTextWidth(p);
                  }, d.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  }, d.prototype.setPage = function(p) {
                    this.jsPDFDocument.setPage(p);
                  }, d.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  }, d.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  }, d.prototype.getGlobalOptions = function() {
                    return h || {};
                  }, d.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  }, d.prototype.pageSize = function() {
                    var p = this.jsPDFDocument.internal.pageSize;
                    return p.width == null && (p = {
                      width: p.getWidth(),
                      height: p.getHeight()
                    }), p;
                  }, d.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  }, d.prototype.getLineHeightFactor = function() {
                    var p = this.jsPDFDocument;
                    return p.getLineHeightFactor ? p.getLineHeightFactor() : 1.15;
                  }, d.prototype.getLineHeight = function(p) {
                    return p / this.scaleFactor() * this.getLineHeightFactor();
                  }, d.prototype.pageNumber = function() {
                    var p = this.jsPDFDocument.internal.getCurrentPageInfo();
                    return p ? p.pageNumber : this.jsPDFDocument.internal.getNumberOfPages();
                  }, d;
                }()
              );
              l.DocHandler = u;
            }
          ),
          /***/
          4: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseHtml = void 0;
              var u = h(903), d = h(796);
              function p(b, x, y, v, k) {
                var C, I;
                v === void 0 && (v = !1), k === void 0 && (k = !1);
                var D;
                typeof x == "string" ? D = y.document.querySelector(x) : D = x;
                var E = Object.keys(b.getFontList()), O = b.scaleFactor(), M = [], q = [], P = [];
                if (!D)
                  return console.error("Html table could not be found with input: ", x), { head: M, body: q, foot: P };
                for (var A = 0; A < D.rows.length; A++) {
                  var F = D.rows[A], _ = (I = (C = F == null ? void 0 : F.parentElement) === null || C === void 0 ? void 0 : C.tagName) === null || I === void 0 ? void 0 : I.toLowerCase(), J = f(E, O, y, F, v, k);
                  J && (_ === "thead" ? M.push(J) : _ === "tfoot" ? P.push(J) : q.push(J));
                }
                return { head: M, body: q, foot: P };
              }
              l.parseHtml = p;
              function f(b, x, y, v, k, C) {
                for (var I = new d.HtmlRowInput(v), D = 0; D < v.cells.length; D++) {
                  var E = v.cells[D], O = y.getComputedStyle(E);
                  if (k || O.display !== "none") {
                    var M = void 0;
                    C && (M = (0, u.parseCss)(b, E, x, O, y)), I.push({
                      rowSpan: E.rowSpan,
                      colSpan: E.colSpan,
                      styles: M,
                      _element: E,
                      content: g(E)
                    });
                  }
                }
                var q = y.getComputedStyle(v);
                if (I.length > 0 && (k || q.display !== "none"))
                  return I;
              }
              function g(b) {
                var x = b.cloneNode(!0);
                return x.innerHTML = x.innerHTML.replace(/\n/g, "").replace(/ +/g, " "), x.innerHTML = x.innerHTML.split(/<br.*?>/).map(function(y) {
                  return y.trim();
                }).join(`
`), x.innerText || x.textContent || "";
              }
            }
          ),
          /***/
          776: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseInput = void 0;
              var u = h(4), d = h(356), p = h(420), f = h(744), g = h(792);
              function b(D, E) {
                var O = new f.DocHandler(D), M = O.getDocumentOptions(), q = O.getGlobalOptions();
                (0, g.default)(O, q, M, E);
                var P = (0, d.assign)({}, q, M, E), A;
                typeof window < "u" && (A = window);
                var F = x(q, M, E), _ = y(q, M, E), J = v(O, P), V = C(O, P, A);
                return {
                  id: E.tableId,
                  content: V,
                  hooks: _,
                  styles: F,
                  settings: J
                };
              }
              l.parseInput = b;
              function x(D, E, O) {
                for (var M = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                }, q = function(_) {
                  if (_ === "columnStyles") {
                    var J = D[_], V = E[_], R = O[_];
                    M.columnStyles = (0, d.assign)({}, J, V, R);
                  } else {
                    var tt = [D, E, O], H = tt.map(function(ct) {
                      return ct[_] || {};
                    });
                    M[_] = (0, d.assign)({}, H[0], H[1], H[2]);
                  }
                }, P = 0, A = Object.keys(M); P < A.length; P++) {
                  var F = A[P];
                  q(F);
                }
                return M;
              }
              function y(D, E, O) {
                for (var M = [D, E, O], q = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                }, P = 0, A = M; P < A.length; P++) {
                  var F = A[P];
                  F.didParseCell && q.didParseCell.push(F.didParseCell), F.willDrawCell && q.willDrawCell.push(F.willDrawCell), F.didDrawCell && q.didDrawCell.push(F.didDrawCell), F.willDrawPage && q.willDrawPage.push(F.willDrawPage), F.didDrawPage && q.didDrawPage.push(F.didDrawPage);
                }
                return q;
              }
              function v(D, E) {
                var O, M, q, P, A, F, _, J, V, R, tt, H, ct = (0, p.parseSpacing)(E.margin, 40 / D.scaleFactor()), it = (O = k(D, E.startY)) !== null && O !== void 0 ? O : ct.top, N;
                E.showFoot === !0 ? N = "everyPage" : E.showFoot === !1 ? N = "never" : N = (M = E.showFoot) !== null && M !== void 0 ? M : "everyPage";
                var z;
                E.showHead === !0 ? z = "everyPage" : E.showHead === !1 ? z = "never" : z = (q = E.showHead) !== null && q !== void 0 ? q : "everyPage";
                var G = (P = E.useCss) !== null && P !== void 0 ? P : !1, Y = E.theme || (G ? "plain" : "striped"), ot = !!E.horizontalPageBreak, xt = (A = E.horizontalPageBreakRepeat) !== null && A !== void 0 ? A : null;
                return {
                  includeHiddenHtml: (F = E.includeHiddenHtml) !== null && F !== void 0 ? F : !1,
                  useCss: G,
                  theme: Y,
                  startY: it,
                  margin: ct,
                  pageBreak: (_ = E.pageBreak) !== null && _ !== void 0 ? _ : "auto",
                  rowPageBreak: (J = E.rowPageBreak) !== null && J !== void 0 ? J : "auto",
                  tableWidth: (V = E.tableWidth) !== null && V !== void 0 ? V : "auto",
                  showHead: z,
                  showFoot: N,
                  tableLineWidth: (R = E.tableLineWidth) !== null && R !== void 0 ? R : 0,
                  tableLineColor: (tt = E.tableLineColor) !== null && tt !== void 0 ? tt : 200,
                  horizontalPageBreak: ot,
                  horizontalPageBreakRepeat: xt,
                  horizontalPageBreakBehaviour: (H = E.horizontalPageBreakBehaviour) !== null && H !== void 0 ? H : "afterAllRows"
                };
              }
              function k(D, E) {
                var O = D.getLastAutoTable(), M = D.scaleFactor(), q = D.pageNumber(), P = !1;
                if (O && O.startPageNumber) {
                  var A = O.startPageNumber + O.pageNumber - 1;
                  P = A === q;
                }
                return typeof E == "number" ? E : (E == null || E === !1) && P && (O == null ? void 0 : O.finalY) != null ? O.finalY + 20 / M : null;
              }
              function C(D, E, O) {
                var M = E.head || [], q = E.body || [], P = E.foot || [];
                if (E.html) {
                  var A = E.includeHiddenHtml;
                  if (O) {
                    var F = (0, u.parseHtml)(D, E.html, O, A, E.useCss) || {};
                    M = F.head || M, q = F.body || M, P = F.foot || M;
                  } else
                    console.error("Cannot parse html in non browser environment");
                }
                var _ = E.columns || I(M, q, P);
                return {
                  columns: _,
                  head: M,
                  body: q,
                  foot: P
                };
              }
              function I(D, E, O) {
                var M = D[0] || E[0] || O[0] || [], q = [];
                return Object.keys(M).filter(function(P) {
                  return P !== "_element";
                }).forEach(function(P) {
                  var A = 1, F;
                  Array.isArray(M) ? F = M[parseInt(P)] : F = M[P], typeof F == "object" && !Array.isArray(F) && (A = (F == null ? void 0 : F.colSpan) || 1);
                  for (var _ = 0; _ < A; _++) {
                    var J = void 0;
                    Array.isArray(M) ? J = q.length : J = P + (_ > 0 ? "_".concat(_) : "");
                    var V = { dataKey: J };
                    q.push(V);
                  }
                }), q;
              }
            }
          ),
          /***/
          792: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(d, p, f, g) {
                for (var b = function(k) {
                  k && typeof k != "object" && console.error("The options parameter should be of type object, is: " + typeof k), typeof k.extendWidth < "u" && (k.tableWidth = k.extendWidth ? "auto" : "wrap", console.error("Use of deprecated option: extendWidth, use tableWidth instead.")), typeof k.margins < "u" && (typeof k.margin > "u" && (k.margin = k.margins), console.error("Use of deprecated option: margins, use margin instead.")), k.startY && typeof k.startY != "number" && (console.error("Invalid value for startY option", k.startY), delete k.startY), !k.didDrawPage && (k.afterPageContent || k.beforePageContent || k.afterPageAdd) && (console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead"), k.didDrawPage = function(P) {
                    d.applyStyles(d.userStyles), k.beforePageContent && k.beforePageContent(P), d.applyStyles(d.userStyles), k.afterPageContent && k.afterPageContent(P), d.applyStyles(d.userStyles), k.afterPageAdd && P.pageNumber > 1 && P.afterPageAdd(P), d.applyStyles(d.userStyles);
                  }), [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(P) {
                    k[P] && console.error('The "'.concat(P, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                  }), [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(P) {
                    var A = P[0], F = P[1];
                    k[F] && (console.error("Use of deprecated option ".concat(F, ". Use ").concat(A, " instead")), k[A] = k[F]);
                  }), [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(P) {
                    var A = typeof P == "string" ? P : P[0], F = typeof P == "string" ? P : P[1];
                    typeof k[A] < "u" && (typeof k.styles[F] > "u" && (k.styles[F] = k[A]), console.error("Use of deprecated option: " + A + ", use the style " + F + " instead."));
                  });
                  for (var C = 0, I = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; C < I.length; C++) {
                    var D = I[C];
                    u(k[D] || {});
                  }
                  for (var E = k.columnStyles || {}, O = 0, M = Object.keys(E); O < M.length; O++) {
                    var q = M[O];
                    u(E[q] || {});
                  }
                }, x = 0, y = [p, f, g]; x < y.length; x++) {
                  var v = y[x];
                  b(v);
                }
              }
              l.default = h;
              function u(d) {
                d.rowHeight ? (console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight."), d.minCellHeight || (d.minCellHeight = d.rowHeight)) : d.columnWidth && (console.error("Use of deprecated style columnWidth. It is renamed to cellWidth."), d.cellWidth || (d.cellWidth = d.columnWidth));
              }
            }
          ),
          /***/
          260: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.Column = l.Cell = l.Row = l.Table = void 0;
              var u = h(796), d = h(172), p = h(420), f = (
                /** @class */
                function() {
                  function y(v, k) {
                    this.pageNumber = 1, this.pageCount = 1, this.id = v.id, this.settings = v.settings, this.styles = v.styles, this.hooks = v.hooks, this.columns = k.columns, this.head = k.head, this.body = k.body, this.foot = k.foot;
                  }
                  return y.prototype.getHeadHeight = function(v) {
                    return this.head.reduce(function(k, C) {
                      return k + C.getMaxCellHeight(v);
                    }, 0);
                  }, y.prototype.getFootHeight = function(v) {
                    return this.foot.reduce(function(k, C) {
                      return k + C.getMaxCellHeight(v);
                    }, 0);
                  }, y.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  }, y.prototype.callCellHooks = function(v, k, C, I, D, E) {
                    for (var O = 0, M = k; O < M.length; O++) {
                      var q = M[O], P = new d.CellHookData(v, this, C, I, D, E), A = q(P) === !1;
                      if (C.text = Array.isArray(C.text) ? C.text : [C.text], A)
                        return !1;
                    }
                    return !0;
                  }, y.prototype.callEndPageHooks = function(v, k) {
                    v.applyStyles(v.userStyles);
                    for (var C = 0, I = this.hooks.didDrawPage; C < I.length; C++) {
                      var D = I[C];
                      D(new d.HookData(v, this, k));
                    }
                  }, y.prototype.callWillDrawPageHooks = function(v, k) {
                    for (var C = 0, I = this.hooks.willDrawPage; C < I.length; C++) {
                      var D = I[C];
                      D(new d.HookData(v, this, k));
                    }
                  }, y.prototype.getWidth = function(v) {
                    if (typeof this.settings.tableWidth == "number")
                      return this.settings.tableWidth;
                    if (this.settings.tableWidth === "wrap") {
                      var k = this.columns.reduce(function(I, D) {
                        return I + D.wrappedWidth;
                      }, 0);
                      return k;
                    } else {
                      var C = this.settings.margin;
                      return v - C.left - C.right;
                    }
                  }, y;
                }()
              );
              l.Table = f;
              var g = (
                /** @class */
                function() {
                  function y(v, k, C, I, D) {
                    D === void 0 && (D = !1), this.height = 0, this.raw = v, v instanceof u.HtmlRowInput && (this.raw = v._element, this.element = v._element), this.index = k, this.section = C, this.cells = I, this.spansMultiplePages = D;
                  }
                  return y.prototype.getMaxCellHeight = function(v) {
                    var k = this;
                    return v.reduce(function(C, I) {
                      var D;
                      return Math.max(C, ((D = k.cells[I.index]) === null || D === void 0 ? void 0 : D.height) || 0);
                    }, 0);
                  }, y.prototype.hasRowSpan = function(v) {
                    var k = this;
                    return v.filter(function(C) {
                      var I = k.cells[C.index];
                      return I ? I.rowSpan > 1 : !1;
                    }).length > 0;
                  }, y.prototype.canEntireRowFit = function(v, k) {
                    return this.getMaxCellHeight(k) <= v;
                  }, y.prototype.getMinimumRowHeight = function(v, k) {
                    var C = this;
                    return v.reduce(function(I, D) {
                      var E = C.cells[D.index];
                      if (!E)
                        return 0;
                      var O = k.getLineHeight(E.styles.fontSize), M = E.padding("vertical"), q = M + O;
                      return q > I ? q : I;
                    }, 0);
                  }, y;
                }()
              );
              l.Row = g;
              var b = (
                /** @class */
                function() {
                  function y(v, k, C) {
                    var I, D;
                    this.contentHeight = 0, this.contentWidth = 0, this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.height = 0, this.x = 0, this.y = 0, this.styles = k, this.section = C, this.raw = v;
                    var E = v;
                    v != null && typeof v == "object" && !Array.isArray(v) ? (this.rowSpan = v.rowSpan || 1, this.colSpan = v.colSpan || 1, E = (D = (I = v.content) !== null && I !== void 0 ? I : v.title) !== null && D !== void 0 ? D : v, v._element && (this.raw = v._element)) : (this.rowSpan = 1, this.colSpan = 1);
                    var O = E != null ? "" + E : "", M = /\r\n|\r|\n/g;
                    this.text = O.split(M);
                  }
                  return y.prototype.getTextPos = function() {
                    var v;
                    if (this.styles.valign === "top")
                      v = this.y + this.padding("top");
                    else if (this.styles.valign === "bottom")
                      v = this.y + this.height - this.padding("bottom");
                    else {
                      var k = this.height - this.padding("vertical");
                      v = this.y + k / 2 + this.padding("top");
                    }
                    var C;
                    if (this.styles.halign === "right")
                      C = this.x + this.width - this.padding("right");
                    else if (this.styles.halign === "center") {
                      var I = this.width - this.padding("horizontal");
                      C = this.x + I / 2 + this.padding("left");
                    } else
                      C = this.x + this.padding("left");
                    return { x: C, y: v };
                  }, y.prototype.getContentHeight = function(v, k) {
                    k === void 0 && (k = 1.15);
                    var C = Array.isArray(this.text) ? this.text.length : 1, I = this.styles.fontSize / v * k, D = C * I + this.padding("vertical");
                    return Math.max(D, this.styles.minCellHeight);
                  }, y.prototype.padding = function(v) {
                    var k = (0, p.parseSpacing)(this.styles.cellPadding, 0);
                    return v === "vertical" ? k.top + k.bottom : v === "horizontal" ? k.left + k.right : k[v];
                  }, y;
                }()
              );
              l.Cell = b;
              var x = (
                /** @class */
                function() {
                  function y(v, k, C) {
                    this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.dataKey = v, this.raw = k, this.index = C;
                  }
                  return y.prototype.getMaxCustomCellWidth = function(v) {
                    for (var k = 0, C = 0, I = v.allRows(); C < I.length; C++) {
                      var D = I[C], E = D.cells[this.index];
                      E && typeof E.styles.cellWidth == "number" && (k = Math.max(k, E.styles.cellWidth));
                    }
                    return k;
                  }, y;
                }()
              );
              l.Column = x;
            }
          ),
          /***/
          356: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.assign = void 0;
              function h(u, d, p, f, g) {
                if (u == null)
                  throw new TypeError("Cannot convert undefined or null to object");
                for (var b = Object(u), x = 1; x < arguments.length; x++) {
                  var y = arguments[x];
                  if (y != null)
                    for (var v in y)
                      Object.prototype.hasOwnProperty.call(y, v) && (b[v] = y[v]);
                }
                return b;
              }
              l.assign = h;
            }
          ),
          /***/
          972: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.createTable = void 0;
              var u = h(744), d = h(260), p = h(324), f = h(796), g = h(356);
              function b(D, E) {
                var O = new u.DocHandler(D), M = x(E, O.scaleFactor()), q = new d.Table(E, M);
                return (0, p.calculateWidths)(O, q), O.applyStyles(O.userStyles), q;
              }
              l.createTable = b;
              function x(D, E) {
                var O = D.content, M = C(O.columns);
                if (O.head.length === 0) {
                  var q = v(M, "head");
                  q && O.head.push(q);
                }
                if (O.foot.length === 0) {
                  var q = v(M, "foot");
                  q && O.foot.push(q);
                }
                var P = D.settings.theme, A = D.styles;
                return {
                  columns: M,
                  head: y("head", O.head, M, A, P, E),
                  body: y("body", O.body, M, A, P, E),
                  foot: y("foot", O.foot, M, A, P, E)
                };
              }
              function y(D, E, O, M, q, P) {
                var A = {}, F = E.map(function(_, J) {
                  for (var V = 0, R = {}, tt = 0, H = 0, ct = 0, it = O; ct < it.length; ct++) {
                    var N = it[ct];
                    if (A[N.index] == null || A[N.index].left === 0)
                      if (H === 0) {
                        var z = void 0;
                        Array.isArray(_) ? z = _[N.index - tt - V] : z = _[N.dataKey];
                        var G = {};
                        typeof z == "object" && !Array.isArray(z) && (G = (z == null ? void 0 : z.styles) || {});
                        var Y = I(D, N, J, q, M, P, G), ot = new d.Cell(z, Y, D);
                        R[N.dataKey] = ot, R[N.index] = ot, H = ot.colSpan - 1, A[N.index] = {
                          left: ot.rowSpan - 1,
                          times: H
                        };
                      } else
                        H--, tt++;
                    else
                      A[N.index].left--, H = A[N.index].times, V++;
                  }
                  return new d.Row(_, J, D, R);
                });
                return F;
              }
              function v(D, E) {
                var O = {};
                return D.forEach(function(M) {
                  if (M.raw != null) {
                    var q = k(E, M.raw);
                    q != null && (O[M.dataKey] = q);
                  }
                }), Object.keys(O).length > 0 ? O : null;
              }
              function k(D, E) {
                if (D === "head") {
                  if (typeof E == "object")
                    return E.header || E.title || null;
                  if (typeof E == "string" || typeof E == "number")
                    return E;
                } else if (D === "foot" && typeof E == "object")
                  return E.footer;
                return null;
              }
              function C(D) {
                return D.map(function(E, O) {
                  var M, q, P;
                  return typeof E == "object" ? P = (q = (M = E.dataKey) !== null && M !== void 0 ? M : E.key) !== null && q !== void 0 ? q : O : P = O, new d.Column(P, E, O);
                });
              }
              function I(D, E, O, M, q, P, A) {
                var F = (0, f.getTheme)(M), _;
                D === "head" ? _ = q.headStyles : D === "body" ? _ = q.bodyStyles : D === "foot" && (_ = q.footStyles);
                var J = (0, g.assign)({}, F.table, F[D], q.styles, _), V = q.columnStyles[E.dataKey] || q.columnStyles[E.index] || {}, R = D === "body" ? V : {}, tt = D === "body" && O % 2 === 0 ? (0, g.assign)({}, F.alternateRow, q.alternateRowStyles) : {}, H = (0, f.defaultStyles)(P), ct = (0, g.assign)({}, H, J, tt, R);
                return (0, g.assign)(ct, A);
              }
            }
          ),
          /***/
          664: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.addPage = l.drawTable = void 0;
              var u = h(420), d = h(260), p = h(744), f = h(356), g = h(136), b = h(224);
              function x(V, R) {
                var tt = R.settings, H = tt.startY, ct = tt.margin, it = {
                  x: ct.left,
                  y: H
                }, N = R.getHeadHeight(R.columns) + R.getFootHeight(R.columns), z = H + ct.bottom + N;
                if (tt.pageBreak === "avoid") {
                  var G = R.body, Y = G.reduce(function(gt, wt) {
                    return gt + wt.height;
                  }, 0);
                  z += Y;
                }
                var ot = new p.DocHandler(V);
                (tt.pageBreak === "always" || tt.startY != null && z > ot.pageSize().height) && (J(ot), it.y = ct.top), R.callWillDrawPageHooks(ot, it);
                var xt = (0, f.assign)({}, it);
                R.startPageNumber = ot.pageNumber(), tt.horizontalPageBreak ? y(ot, R, xt, it) : (ot.applyStyles(ot.userStyles), (tt.showHead === "firstPage" || tt.showHead === "everyPage") && R.head.forEach(function(gt) {
                  return q(ot, R, gt, it, R.columns);
                }), ot.applyStyles(ot.userStyles), R.body.forEach(function(gt, wt) {
                  var qt = wt === R.body.length - 1;
                  M(ot, R, gt, qt, xt, it, R.columns);
                }), ot.applyStyles(ot.userStyles), (tt.showFoot === "lastPage" || tt.showFoot === "everyPage") && R.foot.forEach(function(gt) {
                  return q(ot, R, gt, it, R.columns);
                })), (0, u.addTableBorder)(ot, R, xt, it), R.callEndPageHooks(ot, it), R.finalY = it.y, V.lastAutoTable = R, V.previousAutoTable = R, V.autoTable && (V.autoTable.previous = R), ot.applyStyles(ot.userStyles);
              }
              l.drawTable = x;
              function y(V, R, tt, H) {
                var ct = (0, b.calculateAllColumnsCanFitInPage)(V, R), it = R.settings;
                if (it.horizontalPageBreakBehaviour === "afterAllRows")
                  ct.forEach(function(Y, ot) {
                    V.applyStyles(V.userStyles), ot > 0 ? _(V, R, tt, H, Y.columns, !0) : v(V, R, H, Y.columns), k(V, R, tt, H, Y.columns), I(V, R, H, Y.columns);
                  });
                else
                  for (var N = -1, z = ct[0], G = function() {
                    var Y = N;
                    if (z) {
                      V.applyStyles(V.userStyles);
                      var ot = z.columns;
                      N >= 0 ? _(V, R, tt, H, ot, !0) : v(V, R, H, ot), Y = C(V, R, N + 1, H, ot), I(V, R, H, ot);
                    }
                    var xt = Y - N;
                    ct.slice(1).forEach(function(gt) {
                      V.applyStyles(V.userStyles), _(V, R, tt, H, gt.columns, !0), C(V, R, N + 1, H, gt.columns, xt), I(V, R, H, gt.columns);
                    }), N = Y;
                  }; N < R.body.length - 1; )
                    G();
              }
              function v(V, R, tt, H) {
                var ct = R.settings;
                V.applyStyles(V.userStyles), (ct.showHead === "firstPage" || ct.showHead === "everyPage") && R.head.forEach(function(it) {
                  return q(V, R, it, tt, H);
                });
              }
              function k(V, R, tt, H, ct) {
                V.applyStyles(V.userStyles), R.body.forEach(function(it, N) {
                  var z = N === R.body.length - 1;
                  M(V, R, it, z, tt, H, ct);
                });
              }
              function C(V, R, tt, H, ct, it) {
                V.applyStyles(V.userStyles), it = it ?? R.body.length;
                var N = Math.min(tt + it, R.body.length), z = -1;
                return R.body.slice(tt, N).forEach(function(G, Y) {
                  var ot = tt + Y === R.body.length - 1, xt = F(V, R, ot, H);
                  G.canEntireRowFit(xt, ct) && (q(V, R, G, H, ct), z = tt + Y);
                }), z;
              }
              function I(V, R, tt, H) {
                var ct = R.settings;
                V.applyStyles(V.userStyles), (ct.showFoot === "lastPage" || ct.showFoot === "everyPage") && R.foot.forEach(function(it) {
                  return q(V, R, it, tt, H);
                });
              }
              function D(V, R, tt) {
                var H = tt.getLineHeight(V.styles.fontSize), ct = V.padding("vertical"), it = Math.floor((R - ct) / H);
                return Math.max(0, it);
              }
              function E(V, R, tt, H) {
                var ct = {};
                V.spansMultiplePages = !0, V.height = 0;
                for (var it = 0, N = 0, z = tt.columns; N < z.length; N++) {
                  var G = z[N], Y = V.cells[G.index];
                  if (Y) {
                    Array.isArray(Y.text) || (Y.text = [Y.text]);
                    var ot = new d.Cell(Y.raw, Y.styles, Y.section);
                    ot = (0, f.assign)(ot, Y), ot.text = [];
                    var xt = D(Y, R, H);
                    Y.text.length > xt && (ot.text = Y.text.splice(xt, Y.text.length));
                    var gt = H.scaleFactor(), wt = H.getLineHeightFactor();
                    Y.contentHeight = Y.getContentHeight(gt, wt), Y.contentHeight >= R && (Y.contentHeight = R, ot.styles.minCellHeight -= R), Y.contentHeight > V.height && (V.height = Y.contentHeight), ot.contentHeight = ot.getContentHeight(gt, wt), ot.contentHeight > it && (it = ot.contentHeight), ct[G.index] = ot;
                  }
                }
                var qt = new d.Row(V.raw, -1, V.section, ct, !0);
                qt.height = it;
                for (var Rt = 0, Yt = tt.columns; Rt < Yt.length; Rt++) {
                  var G = Yt[Rt], ot = qt.cells[G.index];
                  ot && (ot.height = qt.height);
                  var Y = V.cells[G.index];
                  Y && (Y.height = V.height);
                }
                return qt;
              }
              function O(V, R, tt, H) {
                var ct = V.pageSize().height, it = H.settings.margin, N = it.top + it.bottom, z = ct - N;
                R.section === "body" && (z -= H.getHeadHeight(H.columns) + H.getFootHeight(H.columns));
                var G = R.getMinimumRowHeight(H.columns, V), Y = G < tt;
                if (G > z)
                  return console.error("Will not be able to print row ".concat(R.index, " correctly since it's minimum height is larger than page height")), !0;
                if (!Y)
                  return !1;
                var ot = R.hasRowSpan(H.columns), xt = R.getMaxCellHeight(H.columns) > z;
                return xt ? (ot && console.error("The content of row ".concat(R.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.")), !0) : !(ot || H.settings.rowPageBreak === "avoid");
              }
              function M(V, R, tt, H, ct, it, N) {
                var z = F(V, R, H, it);
                if (tt.canEntireRowFit(z, N))
                  q(V, R, tt, it, N);
                else if (O(V, tt, z, R)) {
                  var G = E(tt, z, R, V);
                  q(V, R, tt, it, N), _(V, R, ct, it, N), M(V, R, G, H, ct, it, N);
                } else
                  _(V, R, ct, it, N), M(V, R, tt, H, ct, it, N);
              }
              function q(V, R, tt, H, ct) {
                H.x = R.settings.margin.left;
                for (var it = 0, N = ct; it < N.length; it++) {
                  var z = N[it], G = tt.cells[z.index];
                  if (!G) {
                    H.x += z.width;
                    continue;
                  }
                  V.applyStyles(G.styles), G.x = H.x, G.y = H.y;
                  var Y = R.callCellHooks(V, R.hooks.willDrawCell, G, tt, z, H);
                  if (Y === !1) {
                    H.x += z.width;
                    continue;
                  }
                  P(V, G, H);
                  var ot = G.getTextPos();
                  (0, g.default)(G.text, ot.x, ot.y, {
                    halign: G.styles.halign,
                    valign: G.styles.valign,
                    maxWidth: Math.ceil(G.width - G.padding("left") - G.padding("right"))
                  }, V.getDocument()), R.callCellHooks(V, R.hooks.didDrawCell, G, tt, z, H), H.x += z.width;
                }
                H.y += tt.height;
              }
              function P(V, R, tt) {
                var H = R.styles;
                if (V.getDocument().setFillColor(V.getDocument().getFillColor()), typeof H.lineWidth == "number") {
                  var ct = (0, u.getFillStyle)(H.lineWidth, H.fillColor);
                  ct && V.rect(R.x, tt.y, R.width, R.height, ct);
                } else typeof H.lineWidth == "object" && (H.fillColor && V.rect(R.x, tt.y, R.width, R.height, "F"), A(V, R, tt, H.lineWidth));
              }
              function A(V, R, tt, H) {
                var ct, it, N, z;
                H.top && (ct = tt.x, it = tt.y, N = tt.x + R.width, z = tt.y, H.right && (N += 0.5 * H.right), H.left && (ct -= 0.5 * H.left), G(H.top, ct, it, N, z)), H.bottom && (ct = tt.x, it = tt.y + R.height, N = tt.x + R.width, z = tt.y + R.height, H.right && (N += 0.5 * H.right), H.left && (ct -= 0.5 * H.left), G(H.bottom, ct, it, N, z)), H.left && (ct = tt.x, it = tt.y, N = tt.x, z = tt.y + R.height, H.top && (it -= 0.5 * H.top), H.bottom && (z += 0.5 * H.bottom), G(H.left, ct, it, N, z)), H.right && (ct = tt.x + R.width, it = tt.y, N = tt.x + R.width, z = tt.y + R.height, H.top && (it -= 0.5 * H.top), H.bottom && (z += 0.5 * H.bottom), G(H.right, ct, it, N, z));
                function G(Y, ot, xt, gt, wt) {
                  V.getDocument().setLineWidth(Y), V.getDocument().line(ot, xt, gt, wt, "S");
                }
              }
              function F(V, R, tt, H) {
                var ct = R.settings.margin.bottom, it = R.settings.showFoot;
                return (it === "everyPage" || it === "lastPage" && tt) && (ct += R.getFootHeight(R.columns)), V.pageSize().height - H.y - ct;
              }
              function _(V, R, tt, H, ct, it) {
                ct === void 0 && (ct = []), it === void 0 && (it = !1), V.applyStyles(V.userStyles), R.settings.showFoot === "everyPage" && !it && R.foot.forEach(function(z) {
                  return q(V, R, z, H, ct);
                }), R.callEndPageHooks(V, H);
                var N = R.settings.margin;
                (0, u.addTableBorder)(V, R, tt, H), J(V), R.pageNumber++, R.pageCount++, H.x = N.left, H.y = N.top, tt.y = N.top, R.callWillDrawPageHooks(V, H), R.settings.showHead === "everyPage" && (R.head.forEach(function(z) {
                  return q(V, R, z, H, ct);
                }), V.applyStyles(V.userStyles));
              }
              l.addPage = _;
              function J(V) {
                var R = V.pageNumber();
                V.setPage(R + 1);
                var tt = V.pageNumber();
                return tt === R ? (V.addPage(), !0) : !1;
              }
            }
          ),
          /***/
          224: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.calculateAllColumnsCanFitInPage = void 0;
              var u = h(420);
              function d(f, g, b) {
                var x;
                b === void 0 && (b = {});
                var y = (0, u.getPageAvailableWidth)(f, g), v = /* @__PURE__ */ new Map(), k = [], C = [], I = [];
                g.settings.horizontalPageBreakRepeat, Array.isArray(g.settings.horizontalPageBreakRepeat) ? I = g.settings.horizontalPageBreakRepeat : (typeof g.settings.horizontalPageBreakRepeat == "string" || typeof g.settings.horizontalPageBreakRepeat == "number") && (I = [g.settings.horizontalPageBreakRepeat]), I.forEach(function(M) {
                  var q = g.columns.find(function(P) {
                    return P.dataKey === M || P.index === M;
                  });
                  q && !v.has(q.index) && (v.set(q.index, !0), k.push(q.index), C.push(g.columns[q.index]), y -= q.wrappedWidth);
                });
                for (var D = !0, E = (x = b == null ? void 0 : b.start) !== null && x !== void 0 ? x : 0; E < g.columns.length; ) {
                  if (v.has(E)) {
                    E++;
                    continue;
                  }
                  var O = g.columns[E].wrappedWidth;
                  if (D || y >= O)
                    D = !1, k.push(E), C.push(g.columns[E]), y -= O;
                  else
                    break;
                  E++;
                }
                return { colIndexes: k, columns: C, lastIndex: E - 1 };
              }
              function p(f, g) {
                for (var b = [], x = 0; x < g.columns.length; x++) {
                  var y = d(f, g, { start: x });
                  y.columns.length && (b.push(y), x = y.lastIndex);
                }
                return b;
              }
              l.calculateAllColumnsCanFitInPage = p;
            }
          ),
          /***/
          324: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.ellipsize = l.resizeColumns = l.calculateWidths = void 0;
              var u = h(420);
              function d(k, C) {
                p(k, C);
                var I = [], D = 0;
                C.columns.forEach(function(O) {
                  var M = O.getMaxCustomCellWidth(C);
                  M ? O.width = M : (O.width = O.wrappedWidth, I.push(O)), D += O.width;
                });
                var E = C.getWidth(k.pageSize().width) - D;
                E && (E = f(I, E, function(O) {
                  return Math.max(O.minReadableWidth, O.minWidth);
                })), E && (E = f(I, E, function(O) {
                  return O.minWidth;
                })), E = Math.abs(E), !C.settings.horizontalPageBreak && E > 0.1 / k.scaleFactor() && (E = E < 1 ? E : Math.round(E), console.warn("Of the table content, ".concat(E, " units width could not fit page"))), b(C), x(C, k), g(C);
              }
              l.calculateWidths = d;
              function p(k, C) {
                var I = k.scaleFactor(), D = C.settings.horizontalPageBreak, E = (0, u.getPageAvailableWidth)(k, C);
                C.allRows().forEach(function(O) {
                  for (var M = 0, q = C.columns; M < q.length; M++) {
                    var P = q[M], A = O.cells[P.index];
                    if (A) {
                      var F = C.hooks.didParseCell;
                      C.callCellHooks(k, F, A, O, P, null);
                      var _ = A.padding("horizontal");
                      A.contentWidth = (0, u.getStringWidth)(A.text, A.styles, k) + _;
                      var J = (0, u.getStringWidth)(A.text.join(" ").split(/[^\S\u00A0]+/), A.styles, k);
                      if (A.minReadableWidth = J + A.padding("horizontal"), typeof A.styles.cellWidth == "number")
                        A.minWidth = A.styles.cellWidth, A.wrappedWidth = A.styles.cellWidth;
                      else if (A.styles.cellWidth === "wrap" || D === !0)
                        A.contentWidth > E ? (A.minWidth = E, A.wrappedWidth = E) : (A.minWidth = A.contentWidth, A.wrappedWidth = A.contentWidth);
                      else {
                        var V = 10 / I;
                        A.minWidth = A.styles.minCellWidth || V, A.wrappedWidth = A.contentWidth, A.minWidth > A.wrappedWidth && (A.wrappedWidth = A.minWidth);
                      }
                    }
                  }
                }), C.allRows().forEach(function(O) {
                  for (var M = 0, q = C.columns; M < q.length; M++) {
                    var P = q[M], A = O.cells[P.index];
                    if (A && A.colSpan === 1)
                      P.wrappedWidth = Math.max(P.wrappedWidth, A.wrappedWidth), P.minWidth = Math.max(P.minWidth, A.minWidth), P.minReadableWidth = Math.max(P.minReadableWidth, A.minReadableWidth);
                    else {
                      var F = C.styles.columnStyles[P.dataKey] || C.styles.columnStyles[P.index] || {}, _ = F.cellWidth || F.minCellWidth;
                      _ && typeof _ == "number" && (P.minWidth = _, P.wrappedWidth = _);
                    }
                    A && (A.colSpan > 1 && !P.minWidth && (P.minWidth = A.minWidth), A.colSpan > 1 && !P.wrappedWidth && (P.wrappedWidth = A.minWidth));
                  }
                });
              }
              function f(k, C, I) {
                for (var D = C, E = k.reduce(function(V, R) {
                  return V + R.wrappedWidth;
                }, 0), O = 0; O < k.length; O++) {
                  var M = k[O], q = M.wrappedWidth / E, P = D * q, A = M.width + P, F = I(M), _ = A < F ? F : A;
                  C -= _ - M.width, M.width = _;
                }
                if (C = Math.round(C * 1e10) / 1e10, C) {
                  var J = k.filter(function(V) {
                    return C < 0 ? V.width > I(V) : !0;
                  });
                  J.length && (C = f(J, C, I));
                }
                return C;
              }
              l.resizeColumns = f;
              function g(k) {
                for (var C = {}, I = 1, D = k.allRows(), E = 0; E < D.length; E++)
                  for (var O = D[E], M = 0, q = k.columns; M < q.length; M++) {
                    var P = q[M], A = C[P.index];
                    if (I > 1)
                      I--, delete O.cells[P.index];
                    else if (A)
                      A.cell.height += O.height, I = A.cell.colSpan, delete O.cells[P.index], A.left--, A.left <= 1 && delete C[P.index];
                    else {
                      var F = O.cells[P.index];
                      if (!F)
                        continue;
                      if (F.height = O.height, F.rowSpan > 1) {
                        var _ = D.length - E, J = F.rowSpan > _ ? _ : F.rowSpan;
                        C[P.index] = { cell: F, left: J, row: O };
                      }
                    }
                  }
              }
              function b(k) {
                for (var C = k.allRows(), I = 0; I < C.length; I++)
                  for (var D = C[I], E = null, O = 0, M = 0, q = 0; q < k.columns.length; q++) {
                    var P = k.columns[q];
                    if (M -= 1, M > 1 && k.columns[q + 1])
                      O += P.width, delete D.cells[P.index];
                    else if (E) {
                      var A = E;
                      delete D.cells[P.index], E = null, A.width = P.width + O;
                    } else {
                      var A = D.cells[P.index];
                      if (!A)
                        continue;
                      if (M = A.colSpan, O = 0, A.colSpan > 1) {
                        E = A, O += P.width;
                        continue;
                      }
                      A.width = P.width + O;
                    }
                  }
              }
              function x(k, C) {
                for (var I = { count: 0, height: 0 }, D = 0, E = k.allRows(); D < E.length; D++) {
                  for (var O = E[D], M = 0, q = k.columns; M < q.length; M++) {
                    var P = q[M], A = O.cells[P.index];
                    if (A) {
                      C.applyStyles(A.styles, !0);
                      var F = A.width - A.padding("horizontal");
                      if (A.styles.overflow === "linebreak")
                        A.text = C.splitTextToSize(A.text, F + 1 / C.scaleFactor(), { fontSize: A.styles.fontSize });
                      else if (A.styles.overflow === "ellipsize")
                        A.text = y(A.text, F, A.styles, C, "...");
                      else if (A.styles.overflow === "hidden")
                        A.text = y(A.text, F, A.styles, C, "");
                      else if (typeof A.styles.overflow == "function") {
                        var _ = A.styles.overflow(A.text, F);
                        typeof _ == "string" ? A.text = [_] : A.text = _;
                      }
                      A.contentHeight = A.getContentHeight(C.scaleFactor(), C.getLineHeightFactor());
                      var J = A.contentHeight / A.rowSpan;
                      A.rowSpan > 1 && I.count * I.height < J * A.rowSpan ? I = { height: J, count: A.rowSpan } : I && I.count > 0 && I.height > J && (J = I.height), J > O.height && (O.height = J);
                    }
                  }
                  I.count--;
                }
              }
              function y(k, C, I, D, E) {
                return k.map(function(O) {
                  return v(O, C, I, D, E);
                });
              }
              l.ellipsize = y;
              function v(k, C, I, D, E) {
                var O = 1e4 * D.scaleFactor();
                if (C = Math.ceil(C * O) / O, C >= (0, u.getStringWidth)(k, I, D))
                  return k;
                for (; C < (0, u.getStringWidth)(k + E, I, D) && !(k.length <= 1); )
                  k = k.substring(0, k.length - 1);
                return k.trim() + E;
              }
            }
          ),
          /***/
          964: (
            /***/
            function(a) {
              if (typeof e > "u") {
                var l = new Error("Cannot find module 'undefined'");
                throw l.code = "MODULE_NOT_FOUND", l;
              }
              a.exports = e;
            }
          )
          /******/
        }, r = {};
        function s(a) {
          var l = r[a];
          if (l !== void 0)
            return l.exports;
          var h = r[a] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return i[a].call(h.exports, h, h.exports, s), h.exports;
        }
        var o = {};
        return function() {
          var a = o;
          Object.defineProperty(a, "__esModule", { value: !0 }), a.Cell = a.Column = a.Row = a.Table = a.CellHookData = a.__drawTable = a.__createTable = a.applyPlugin = void 0;
          var l = s(340), h = s(776), u = s(664), d = s(972), p = s(260);
          Object.defineProperty(a, "Table", { enumerable: !0, get: function() {
            return p.Table;
          } });
          var f = s(172);
          Object.defineProperty(a, "CellHookData", { enumerable: !0, get: function() {
            return f.CellHookData;
          } });
          var g = s(260);
          Object.defineProperty(a, "Cell", { enumerable: !0, get: function() {
            return g.Cell;
          } }), Object.defineProperty(a, "Column", { enumerable: !0, get: function() {
            return g.Column;
          } }), Object.defineProperty(a, "Row", { enumerable: !0, get: function() {
            return g.Row;
          } });
          function b(C) {
            (0, l.default)(C);
          }
          a.applyPlugin = b;
          function x(C, I) {
            var D = (0, h.parseInput)(C, I), E = (0, d.createTable)(C, D);
            (0, u.drawTable)(C, E);
          }
          function y(C, I) {
            var D = (0, h.parseInput)(C, I);
            return (0, d.createTable)(C, D);
          }
          a.__createTable = y;
          function v(C, I) {
            (0, u.drawTable)(C, I);
          }
          a.__drawTable = v;
          try {
            var k = s(964);
            k.jsPDF && (k = k.jsPDF), b(k);
          } catch {
          }
          a.default = x;
        }(), o;
      }()
    );
  });
})(q1);
var ew = q1.exports;
const ra = /* @__PURE__ */ Oc(ew), sa = 5, fl = 10, Iu = ",", oa = {
  fillColor: [7, 59, 76],
  fontStyle: "normal"
}, aa = {
  fontSize: 9
}, la = { left: 10 };
let ua = [];
const nw = (n, t, e = (i) => i.toString()) => {
  var h;
  const { t: i } = N2.global, r = new Se({ orientation: "landscape" });
  let s = 10;
  r.setFontSize(20), r.text(i("pdf.orderSummary"), 10, s), s += 15, r.setFontSize(14), r.text("Your parts", 10, s), s += sa, ua = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity"),
    i("name"),
    `Banding (${dr.join(Iu)})`,
    `Finish (${hr.join(Iu)})`
  ];
  const o = n.parts.map((u) => {
    var f;
    const d = dr.map((g) => u.banding[g] || "-").join(Iu), p = hr.map((g) => u.banding[g] || "-").join(Iu);
    return [
      e(u.l),
      e(u.w),
      e(u.t) || "-",
      ((f = u == null ? void 0 : u.material) == null ? void 0 : f.toUpperCase()) || "-",
      e(u.q),
      u.name || "-",
      d,
      p
    ];
  });
  ra(r, {
    startY: s,
    head: [ua],
    body: o,
    margin: la,
    headStyles: oa,
    styles: aa
  }), s = r.autoTable.previous.finalY + fl, r.setFontSize(14), r.text(i("pdf.stockRequirements"), 10, s), s += sa, ua = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity")
    // 'Cost'
  ];
  const a = n.stock.map((u) => {
    var d;
    return [
      e(u.l),
      e(u.w),
      e(u.t) || "-",
      ((d = u == null ? void 0 : u.material) == null ? void 0 : d.toUpperCase()) || "-",
      e(u.q)
      // stock.cost
    ];
  });
  if (ra(r, {
    startY: s,
    head: [ua],
    body: a,
    margin: la,
    headStyles: oa,
    styles: aa
  }), s = r.autoTable.previous.finalY + fl, n.metadata.totalRollLength > 0) {
    r.setFontSize(14), r.text(i("pdf.rollRequirements"), 10, s), s += sa, ua = [
      i("name"),
      i("material"),
      i("length")
    ];
    const u = n.stock.map((d) => {
      var p, f;
      return [
        ((p = d == null ? void 0 : d.name) == null ? void 0 : p.toUpperCase()) || "-",
        ((f = d == null ? void 0 : d.material) == null ? void 0 : f.toUpperCase()) || "-",
        e(d.analysis.rollLength)
      ];
    });
    ra(r, {
      startY: s,
      head: [ua],
      body: u,
      margin: la,
      headStyles: oa,
      styles: aa
    }), s = r.autoTable.previous.finalY + fl;
  }
  if (t && Object.values(t)) {
    r.setFontSize(14), r.text("Hardware", 10, s), s += sa;
    const u = Object.values(t).map((d) => [
      d.name.toUpperCase(),
      e(d.q)
      // item.totalCost.toFixed( 2 )
    ]);
    ra(r, {
      startY: s,
      head: [[i("pdf.item"), i("quantity")]],
      body: u,
      margin: la,
      headStyles: oa,
      styles: aa
    }), s = r.autoTable.previous.finalY + fl;
  }
  r.setFontSize(14), r.text(i("pdf.totals"), 10, s), s += sa;
  const l = [
    [i("pdf.totalParts"), e(n.metadata.totalPartsProduced)],
    [i("pdf.partArea"), e(n.metadata.totalPartArea)],
    [i("pdf.totalStockRequired"), e(n.metadata.totalUsedStock)],
    [i("pdf.totalBandingLength"), e(n.metadata.totalBandingLength)],
    [i("pdf.totalFinishArea"), e(n.metadata.totalFinishArea)],
    [i("pdf.totalRollLength"), e(n.metadata.totalRollLength)]
  ];
  if (ra(r, {
    startY: s,
    body: l,
    margin: la,
    headStyles: oa,
    styles: aa
  }), s = r.autoTable.previous.finalY + fl, (h = window == null ? void 0 : window.smartcutImages) != null && h.length) {
    r.addPage();
    let u = 10;
    r.setFontSize(14), r.text(i("pdf.images"), 10, u), u += sa;
    const d = window.smartcutImages.flatMap((p, f) => p.metadata.map((g) => [
      f + 1,
      g.newName
    ]));
    ra(r, {
      startY: u,
      body: d,
      head: [[i("pdf.partIndex"), i("pdf.fileName")]],
      margin: la,
      headStyles: oa,
      styles: aa
    });
  }
  return r.output("datauristring");
};
function iw(n) {
  return P2() ? (L2(n), !0) : !1;
}
function Ad(n) {
  return typeof n == "function" ? n() : Oe(n);
}
const rw = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const sw = Object.prototype.toString, ow = (n) => sw.call(n) === "[object Object]", aw = () => {
};
function lw(n, t) {
  function e(...i) {
    return new Promise((r, s) => {
      Promise.resolve(n(() => t.apply(this, i), { fn: t, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return e;
}
const z1 = (n) => n();
function uw(n = z1) {
  const t = Ne(!0);
  function e() {
    t.value = !1;
  }
  function i() {
    t.value = !0;
  }
  const r = (...s) => {
    t.value && n(...s);
  };
  return { isActive: C2(t), pause: e, resume: i, eventFilter: r };
}
function cw(n) {
  return I2();
}
function hw(n, t, e = {}) {
  const {
    eventFilter: i = z1,
    ...r
  } = e;
  return cr(
    n,
    lw(
      i,
      t
    ),
    r
  );
}
function fw(n, t, e = {}) {
  const {
    eventFilter: i,
    ...r
  } = e, { eventFilter: s, pause: o, resume: a, isActive: l } = uw(i);
  return { stop: hw(
    n,
    t,
    {
      ...r,
      eventFilter: s
    }
  ), pause: o, resume: a, isActive: l };
}
function dw(n, t = !0, e) {
  cw() ? Io(n, e) : t ? n() : Es(n);
}
function pw(n) {
  var t;
  const e = Ad(n);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const uc = rw ? window : void 0;
function cg(...n) {
  let t, e, i, r;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([e, i, r] = n, t = uc) : [t, e, i, r] = n, !t)
    return aw;
  Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
  const s = [], o = () => {
    s.forEach((u) => u()), s.length = 0;
  }, a = (u, d, p, f) => (u.addEventListener(d, p, f), () => u.removeEventListener(d, p, f)), l = cr(
    () => [pw(t), Ad(r)],
    ([u, d]) => {
      if (o(), !u)
        return;
      const p = ow(d) ? { ...d } : d;
      s.push(
        ...e.flatMap((f) => i.map((g) => a(u, f, g, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), h = () => {
    l(), o();
  };
  return iw(h), h;
}
const Eu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ou = "__vueuse_ssr_handlers__", gw = /* @__PURE__ */ mw();
function mw() {
  return Ou in Eu || (Eu[Ou] = Eu[Ou] || {}), Eu[Ou];
}
function yw(n, t) {
  return gw[n] || t;
}
function bw(n) {
  return n == null ? "any" : n instanceof Set ? "set" : n instanceof Map ? "map" : n instanceof Date ? "date" : typeof n == "boolean" ? "boolean" : typeof n == "string" ? "string" : typeof n == "object" ? "object" : Number.isNaN(n) ? "any" : "number";
}
const vw = {
  boolean: {
    read: (n) => n === "true",
    write: (n) => String(n)
  },
  object: {
    read: (n) => JSON.parse(n),
    write: (n) => JSON.stringify(n)
  },
  number: {
    read: (n) => Number.parseFloat(n),
    write: (n) => String(n)
  },
  any: {
    read: (n) => n,
    write: (n) => String(n)
  },
  string: {
    read: (n) => n,
    write: (n) => String(n)
  },
  map: {
    read: (n) => new Map(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n.entries()))
  },
  set: {
    read: (n) => new Set(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n))
  },
  date: {
    read: (n) => new Date(n),
    write: (n) => n.toISOString()
  }
}, hg = "vueuse-storage";
function ww(n, t, e, i = {}) {
  var r;
  const {
    flush: s = "pre",
    deep: o = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: h = !1,
    shallow: u,
    window: d = uc,
    eventFilter: p,
    onError: f = (q) => {
      console.error(q);
    },
    initOnMounted: g
  } = i, b = (u ? co : Ne)(typeof t == "function" ? t() : t);
  if (!e)
    try {
      e = yw("getDefaultStorage", () => {
        var q;
        return (q = uc) == null ? void 0 : q.localStorage;
      })();
    } catch (q) {
      f(q);
    }
  if (!e)
    return b;
  const x = Ad(t), y = bw(x), v = (r = i.serializer) != null ? r : vw[y], { pause: k, resume: C } = fw(
    b,
    () => D(b.value),
    { flush: s, deep: o, eventFilter: p }
  );
  d && a && dw(() => {
    cg(d, "storage", O), cg(d, hg, M), g && O();
  }), g || O();
  function I(q, P) {
    d && d.dispatchEvent(new CustomEvent(hg, {
      detail: {
        key: n,
        oldValue: q,
        newValue: P,
        storageArea: e
      }
    }));
  }
  function D(q) {
    try {
      const P = e.getItem(n);
      if (q == null)
        I(P, null), e.removeItem(n);
      else {
        const A = v.write(q);
        P !== A && (e.setItem(n, A), I(P, A));
      }
    } catch (P) {
      f(P);
    }
  }
  function E(q) {
    const P = q ? q.newValue : e.getItem(n);
    if (P == null)
      return l && x != null && e.setItem(n, v.write(x)), x;
    if (!q && h) {
      const A = v.read(P);
      return typeof h == "function" ? h(A, x) : y === "object" && !Array.isArray(A) ? { ...x, ...A } : A;
    } else return typeof P != "string" ? P : v.read(P);
  }
  function O(q) {
    if (!(q && q.storageArea !== e)) {
      if (q && q.key == null) {
        b.value = x;
        return;
      }
      if (!(q && q.key !== n)) {
        k();
        try {
          (q == null ? void 0 : q.newValue) !== v.write(b.value) && (b.value = E(q));
        } catch (P) {
          f(P);
        } finally {
          q ? Es(C) : C();
        }
      }
    }
  }
  function M(q) {
    O(q.detail);
  }
  return b;
}
function fg(n, t, e = {}) {
  const { window: i = uc } = e;
  return ww(n, t, i == null ? void 0 : i.localStorage, e);
}
const Xn = [];
for (let n = 0; n < 256; ++n)
  Xn.push((n + 256).toString(16).slice(1));
function xw(n, t = 0) {
  return (Xn[n[t + 0]] + Xn[n[t + 1]] + Xn[n[t + 2]] + Xn[n[t + 3]] + "-" + Xn[n[t + 4]] + Xn[n[t + 5]] + "-" + Xn[n[t + 6]] + Xn[n[t + 7]] + "-" + Xn[n[t + 8]] + Xn[n[t + 9]] + "-" + Xn[n[t + 10]] + Xn[n[t + 11]] + Xn[n[t + 12]] + Xn[n[t + 13]] + Xn[n[t + 14]] + Xn[n[t + 15]]).toLowerCase();
}
let Eh;
const _w = new Uint8Array(16);
function Sw() {
  if (!Eh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Eh = crypto.getRandomValues.bind(crypto);
  }
  return Eh(_w);
}
const kw = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), dg = { randomUUID: kw };
function Aw(n, t, e) {
  if (dg.randomUUID && !t && !n)
    return dg.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || Sw)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, xw(i);
}
const Fr = /* @__PURE__ */ Object.create(null);
Fr.open = "0";
Fr.close = "1";
Fr.ping = "2";
Fr.pong = "3";
Fr.message = "4";
Fr.upgrade = "5";
Fr.noop = "6";
const Wu = /* @__PURE__ */ Object.create(null);
Object.keys(Fr).forEach((n) => {
  Wu[Fr[n]] = n;
});
const bf = { type: "error", data: "parser error" }, $1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", U1 = typeof ArrayBuffer == "function", W1 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, Nd = ({ type: n, data: t }, e, i) => $1 && t instanceof Blob ? e ? i(t) : pg(t, i) : U1 && (t instanceof ArrayBuffer || W1(t)) ? e ? i(t) : pg(new Blob([t]), i) : i(Fr[n] + (t || "")), pg = (n, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const i = e.result.split(",")[1];
    t("b" + (i || ""));
  }, e.readAsDataURL(n);
};
function gg(n) {
  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
}
let Oh;
function Nw(n, t) {
  if ($1 && n.data instanceof Blob)
    return n.data.arrayBuffer().then(gg).then(t);
  if (U1 && (n.data instanceof ArrayBuffer || W1(n.data)))
    return t(gg(n.data));
  Nd(n, !1, (e) => {
    Oh || (Oh = new TextEncoder()), t(Oh.encode(e));
  });
}
const mg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bl = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < mg.length; n++)
  bl[mg.charCodeAt(n)] = n;
const Cw = (n) => {
  let t = n.length * 0.75, e = n.length, i, r = 0, s, o, a, l;
  n[n.length - 1] === "=" && (t--, n[n.length - 2] === "=" && t--);
  const h = new ArrayBuffer(t), u = new Uint8Array(h);
  for (i = 0; i < e; i += 4)
    s = bl[n.charCodeAt(i)], o = bl[n.charCodeAt(i + 1)], a = bl[n.charCodeAt(i + 2)], l = bl[n.charCodeAt(i + 3)], u[r++] = s << 2 | o >> 4, u[r++] = (o & 15) << 4 | a >> 2, u[r++] = (a & 3) << 6 | l & 63;
  return h;
}, Pw = typeof ArrayBuffer == "function", Cd = (n, t) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: H1(n, t)
    };
  const e = n.charAt(0);
  return e === "b" ? {
    type: "message",
    data: Lw(n.substring(1), t)
  } : Wu[e] ? n.length > 1 ? {
    type: Wu[e],
    data: n.substring(1)
  } : {
    type: Wu[e]
  } : bf;
}, Lw = (n, t) => {
  if (Pw) {
    const e = Cw(n);
    return H1(e, t);
  } else
    return { base64: !0, data: n };
}, H1 = (n, t) => {
  switch (t) {
    case "blob":
      return n instanceof Blob ? n : new Blob([n]);
    case "arraybuffer":
    default:
      return n instanceof ArrayBuffer ? n : n.buffer;
  }
}, G1 = "", Iw = (n, t) => {
  const e = n.length, i = new Array(e);
  let r = 0;
  n.forEach((s, o) => {
    Nd(s, !1, (a) => {
      i[o] = a, ++r === e && t(i.join(G1));
    });
  });
}, Ew = (n, t) => {
  const e = n.split(G1), i = [];
  for (let r = 0; r < e.length; r++) {
    const s = Cd(e[r], t);
    if (i.push(s), s.type === "error")
      break;
  }
  return i;
};
function Ow() {
  return new TransformStream({
    transform(n, t) {
      Nw(n, (e) => {
        const i = e.length;
        let r;
        if (i < 126)
          r = new Uint8Array(1), new DataView(r.buffer).setUint8(0, i);
        else if (i < 65536) {
          r = new Uint8Array(3);
          const s = new DataView(r.buffer);
          s.setUint8(0, 126), s.setUint16(1, i);
        } else {
          r = new Uint8Array(9);
          const s = new DataView(r.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(i));
        }
        n.data && typeof n.data != "string" && (r[0] |= 128), t.enqueue(r), t.enqueue(e);
      });
    }
  });
}
let Th;
function Tu(n) {
  return n.reduce((t, e) => t + e.length, 0);
}
function Fu(n, t) {
  if (n[0].length === t)
    return n.shift();
  const e = new Uint8Array(t);
  let i = 0;
  for (let r = 0; r < t; r++)
    e[r] = n[0][i++], i === n[0].length && (n.shift(), i = 0);
  return n.length && i < n[0].length && (n[0] = n[0].slice(i)), e;
}
function Tw(n, t) {
  Th || (Th = new TextDecoder());
  const e = [];
  let i = 0, r = -1, s = !1;
  return new TransformStream({
    transform(o, a) {
      for (e.push(o); ; ) {
        if (i === 0) {
          if (Tu(e) < 1)
            break;
          const l = Fu(e, 1);
          s = (l[0] & 128) === 128, r = l[0] & 127, r < 126 ? i = 3 : r === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (Tu(e) < 2)
            break;
          const l = Fu(e, 2);
          r = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (Tu(e) < 8)
            break;
          const l = Fu(e, 8), h = new DataView(l.buffer, l.byteOffset, l.length), u = h.getUint32(0);
          if (u > Math.pow(2, 21) - 1) {
            a.enqueue(bf);
            break;
          }
          r = u * Math.pow(2, 32) + h.getUint32(4), i = 3;
        } else {
          if (Tu(e) < r)
            break;
          const l = Fu(e, r);
          a.enqueue(Cd(s ? l : Th.decode(l), t)), i = 0;
        }
        if (r === 0 || r > n) {
          a.enqueue(bf);
          break;
        }
      }
    }
  });
}
const V1 = 4;
function Fn(n) {
  if (n) return Fw(n);
}
function Fw(n) {
  for (var t in Fn.prototype)
    n[t] = Fn.prototype[t];
  return n;
}
Fn.prototype.on = Fn.prototype.addEventListener = function(n, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(t), this;
};
Fn.prototype.once = function(n, t) {
  function e() {
    this.off(n, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(n, e), this;
};
Fn.prototype.off = Fn.prototype.removeListener = Fn.prototype.removeAllListeners = Fn.prototype.removeEventListener = function(n, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + n];
  if (!e) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var i, r = 0; r < e.length; r++)
    if (i = e[r], i === t || i.fn === t) {
      e.splice(r, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + n], this;
};
Fn.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + n], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (e) {
    e = e.slice(0);
    for (var i = 0, r = e.length; i < r; ++i)
      e[i].apply(this, t);
  }
  return this;
};
Fn.prototype.emitReserved = Fn.prototype.emit;
Fn.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Fn.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const Bc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0), Xi = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), Mw = "arraybuffer";
function Y1(n, ...t) {
  return t.reduce((e, i) => (n.hasOwnProperty(i) && (e[i] = n[i]), e), {});
}
const Dw = Xi.setTimeout, Rw = Xi.clearTimeout;
function jc(n, t) {
  t.useNativeTimers ? (n.setTimeoutFn = Dw.bind(Xi), n.clearTimeoutFn = Rw.bind(Xi)) : (n.setTimeoutFn = Xi.setTimeout.bind(Xi), n.clearTimeoutFn = Xi.clearTimeout.bind(Xi));
}
const Bw = 1.33;
function jw(n) {
  return typeof n == "string" ? qw(n) : Math.ceil((n.byteLength || n.size) * Bw);
}
function qw(n) {
  let t = 0, e = 0;
  for (let i = 0, r = n.length; i < r; i++)
    t = n.charCodeAt(i), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (i++, e += 4);
  return e;
}
function K1() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function zw(n) {
  let t = "";
  for (let e in n)
    n.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(n[e]));
  return t;
}
function $w(n) {
  let t = {}, e = n.split("&");
  for (let i = 0, r = e.length; i < r; i++) {
    let s = e[i].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
class Uw extends Error {
  constructor(t, e, i) {
    super(t), this.description = e, this.context = i, this.type = "TransportError";
  }
}
class Pd extends Fn {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, jc(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, i) {
    return super.emitReserved("error", new Uw(t, e, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = Cd(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, e = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(e);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const e = zw(t);
    return e.length ? "?" + e : "";
  }
}
class Ww extends Pd {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || e();
      })), this.writable || (i++, this.once("drain", function() {
        --i || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    Ew(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, Iw(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", e = this.query || {};
    return this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = K1()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.createUri(t, e);
  }
}
let X1 = !1;
try {
  X1 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Hw = X1;
function Gw() {
}
class Vw extends Ww {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const e = location.protocol === "https:";
      let i = location.port;
      i || (i = e ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", e), i.on("error", (r, s) => {
      this.onError("xhr post error", r, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, i) => {
      this.onError("xhr poll error", e, i);
    }), this.pollXhr = t;
  }
}
class Or extends Fn {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e, i) {
    super(), this.createRequest = t, jc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = e, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const e = Y1(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(e);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let r in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(r) && i.setRequestHeader(r, this._opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var r;
        i.readyState === 3 && ((r = this._opts.cookieJar) === null || r === void 0 || r.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this._onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Or.requestsCount++, Or.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = Gw, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Or.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Or.requestsCount = 0;
Or.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", yg);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in Xi ? "pagehide" : "unload";
    addEventListener(n, yg, !1);
  }
}
function yg() {
  for (let n in Or.requests)
    Or.requests.hasOwnProperty(n) && Or.requests[n].abort();
}
const Yw = function() {
  const n = J1({
    xdomain: !1
  });
  return n && n.responseType !== null;
}();
class Kw extends Vw {
  constructor(t) {
    super(t);
    const e = t && t.forceBase64;
    this.supportsBinary = Yw && !e;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new Or(J1, this.uri(), t);
  }
}
function J1(n) {
  const t = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || Hw))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new Xi[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Z1 = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Xw extends Pd {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), e = this.opts.protocols, i = Z1 ? {} : Y1(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, e, i);
    } catch (r) {
      return this.emitReserved("error", r);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      Nd(i, this.supportsBinary, (s) => {
        try {
          this.doWrite(i, s);
        } catch {
        }
        r && Bc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", e = this.query || {};
    return this.opts.timestampRequests && (e[this.opts.timestampParam] = K1()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e);
  }
}
const Fh = Xi.WebSocket || Xi.MozWebSocket;
class Jw extends Xw {
  createSocket(t, e, i) {
    return Z1 ? new Fh(t, e, i) : e ? new Fh(t, e) : new Fh(t);
  }
  doWrite(t, e) {
    this.ws.send(e);
  }
}
class Zw extends Pd {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const e = Tw(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(e).getReader(), r = Ow();
        r.readable.pipeTo(t.writable), this._writer = r.writable.getWriter();
        const s = () => {
          i.read().then(({ done: a, value: l }) => {
            a || (this.onPacket(l), s());
          }).catch((a) => {
          });
        };
        s();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      this._writer.write(i).then(() => {
        r && Bc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const Qw = {
  websocket: Jw,
  webtransport: Zw,
  polling: Kw
}, t3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, e3 = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function vf(n) {
  if (n.length > 8e3)
    throw "URI too long";
  const t = n, e = n.indexOf("["), i = n.indexOf("]");
  e != -1 && i != -1 && (n = n.substring(0, e) + n.substring(e, i).replace(/:/g, ";") + n.substring(i, n.length));
  let r = t3.exec(n || ""), s = {}, o = 14;
  for (; o--; )
    s[e3[o]] = r[o] || "";
  return e != -1 && i != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = n3(s, s.path), s.queryKey = i3(s, s.query), s;
}
function n3(n, t) {
  const e = /\/{2,9}/g, i = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function i3(n, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, r, s) {
    r && (e[r] = s);
  }), e;
}
const wf = typeof addEventListener == "function" && typeof removeEventListener == "function", Hu = [];
wf && addEventListener("offline", () => {
  Hu.forEach((n) => n());
}, !1);
class qs extends Fn {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e) {
    if (super(), this.binaryType = Mw, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (e = t, t = null), t) {
      const i = vf(t);
      e.hostname = i.host, e.secure = i.protocol === "https" || i.protocol === "wss", e.port = i.port, i.query && (e.query = i.query);
    } else e.host && (e.hostname = vf(e.host).host);
    jc(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, e.transports.forEach((i) => {
      const r = i.prototype.name;
      this.transports.push(r), this._transportsByName[r] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = $w(this.opts.query)), wf && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, Hu.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = V1, e.transport = t, this.id && (e.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && qs.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const e = this.createTransport(t);
    e.open(), this.setTransport(e);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (e) => this._onClose("transport close", e));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", qs.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this._onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const r = this.writeBuffer[i].data;
      if (r && (e += jw(r)), i > 0 && e > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, Bc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, e, i, r) {
    if (typeof e == "function" && (r = e, e = void 0), typeof i == "function" && (r = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: i
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), r && this.once("flush", r), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, i = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (qs.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), wf && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = Hu.indexOf(this._offlineEventListener);
        i !== -1 && Hu.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
qs.protocol = V1;
class r3 extends qs {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let e = this.createTransport(t), i = !1;
    qs.priorWebsocketSuccess = !1;
    const r = () => {
      i || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (d) => {
        if (!i)
          if (d.type === "pong" && d.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            qs.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (u(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const p = new Error("probe error");
            p.transport = e.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function s() {
      i || (i = !0, u(), e.close(), e = null);
    }
    const o = (d) => {
      const p = new Error("probe error: " + d);
      p.transport = e.name, s(), this.emitReserved("upgradeError", p);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function h(d) {
      e && d.name !== e.name && s();
    }
    const u = () => {
      e.removeListener("open", r), e.removeListener("error", o), e.removeListener("close", a), this.off("close", l), this.off("upgrading", h);
    };
    e.once("open", r), e.once("error", o), e.once("close", a), this.once("close", l), this.once("upgrading", h), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      i || e.open();
    }, 200) : e.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const e = [];
    for (let i = 0; i < t.length; i++)
      ~this.transports.indexOf(t[i]) && e.push(t[i]);
    return e;
  }
}
let s3 = class extends r3 {
  constructor(t, e = {}) {
    const i = typeof t == "object" ? t : e;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((r) => Qw[r]).filter((r) => !!r)), super(t, i);
  }
};
function o3(n, t = "", e) {
  let i = n;
  e = e || typeof location < "u" && location, n == null && (n = e.protocol + "//" + e.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = e.protocol + n : n = e.host + n), /^(https?|wss?):\/\//.test(n) || (typeof e < "u" ? n = e.protocol + "//" + n : n = "https://" + n), i = vf(n)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + s + ":" + i.port + t, i.href = i.protocol + "://" + s + (e && e.port === i.port ? "" : ":" + i.port), i;
}
const a3 = typeof ArrayBuffer == "function", l3 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Q1 = Object.prototype.toString, u3 = typeof Blob == "function" || typeof Blob < "u" && Q1.call(Blob) === "[object BlobConstructor]", c3 = typeof File == "function" || typeof File < "u" && Q1.call(File) === "[object FileConstructor]";
function Ld(n) {
  return a3 && (n instanceof ArrayBuffer || l3(n)) || u3 && n instanceof Blob || c3 && n instanceof File;
}
function Gu(n, t) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let e = 0, i = n.length; e < i; e++)
      if (Gu(n[e]))
        return !0;
    return !1;
  }
  if (Ld(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return Gu(n.toJSON(), !0);
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e) && Gu(n[e]))
      return !0;
  return !1;
}
function h3(n) {
  const t = [], e = n.data, i = n;
  return i.data = xf(e, t), i.attachments = t.length, { packet: i, buffers: t };
}
function xf(n, t) {
  if (!n)
    return n;
  if (Ld(n)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(n), e;
  } else if (Array.isArray(n)) {
    const e = new Array(n.length);
    for (let i = 0; i < n.length; i++)
      e[i] = xf(n[i], t);
    return e;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const e = {};
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = xf(n[i], t));
    return e;
  }
  return n;
}
function f3(n, t) {
  return n.data = _f(n.data, t), delete n.attachments, n;
}
function _f(n, t) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < t.length)
      return t[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let e = 0; e < n.length; e++)
      n[e] = _f(n[e], t);
  else if (typeof n == "object")
    for (const e in n)
      Object.prototype.hasOwnProperty.call(n, e) && (n[e] = _f(n[e], t));
  return n;
}
const d3 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], p3 = 5;
var ze;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(ze || (ze = {}));
class g3 {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === ze.EVENT || t.type === ze.ACK) && Gu(t) ? this.encodeAsBinary({
      type: t.type === ze.EVENT ? ze.BINARY_EVENT : ze.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === ze.BINARY_EVENT || t.type === ze.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = h3(t), i = this.encodeAsString(e.packet), r = e.buffers;
    return r.unshift(i), r;
  }
}
function bg(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
class Id extends Fn {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const i = e.type === ze.BINARY_EVENT;
      i || e.type === ze.BINARY_ACK ? (e.type = i ? ze.EVENT : ze.ACK, this.reconstructor = new m3(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (Ld(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (ze[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === ze.BINARY_EVENT || i.type === ze.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const o = t.substring(s, e);
      if (o != Number(o) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(o);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      i.nsp = t.substring(s, e);
    } else
      i.nsp = "/";
    const r = t.charAt(e + 1);
    if (r !== "" && Number(r) == r) {
      const s = e + 1;
      for (; ++e; ) {
        const o = t.charAt(e);
        if (o == null || Number(o) != o) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      i.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (Id.isPayloadValid(i.type, s))
        i.data = s;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case ze.CONNECT:
        return bg(e);
      case ze.DISCONNECT:
        return e === void 0;
      case ze.CONNECT_ERROR:
        return typeof e == "string" || bg(e);
      case ze.EVENT:
      case ze.BINARY_EVENT:
        return Array.isArray(e) && (typeof e[0] == "number" || typeof e[0] == "string" && d3.indexOf(e[0]) === -1);
      case ze.ACK:
      case ze.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class m3 {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = f3(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const y3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Decoder: Id, Encoder: g3, get PacketType() {
  return ze;
}, protocol: p3 }, Symbol.toStringTag, { value: "Module" }));
function ur(n, t, e) {
  return n.on(t, e), function() {
    n.off(t, e);
  };
}
const b3 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class tm extends Fn {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      ur(t, "open", this.onopen.bind(this)),
      ur(t, "packet", this.onpacket.bind(this)),
      ur(t, "error", this.onerror.bind(this)),
      ur(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    var i, r, s;
    if (b3.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const o = {
      type: ze.EVENT,
      data: e
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const u = this.ids++, d = e.pop();
      this._registerAckCallback(u, d), o.id = u;
    }
    const a = (r = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || r === void 0 ? void 0 : r.writable, l = this.connected && !(!((s = this.io.engine) === null || s === void 0) && s._hasPingExpired());
    return this.flags.volatile && !a || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var i;
    const r = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (r === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      e.call(this, new Error("operation has timed out"));
    }, r), o = (...a) => {
      this.io.clearTimeoutFn(s), e.apply(this, a);
    };
    o.withError = !0, this.acks[t] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    return new Promise((i, r) => {
      const s = (o, a) => o ? r(o) : i(a);
      s.withError = !0, e.push(s), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((r, ...s) => i !== this._queue[0] ? void 0 : (r !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(r)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: ze.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((i) => String(i.id) === t)) {
        const i = this.acks[t];
        delete this.acks[t], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case ze.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case ze.EVENT:
        case ze.BINARY_EVENT:
          this.onevent(t);
          break;
        case ze.ACK:
        case ze.BINARY_ACK:
          this.onack(t);
          break;
        case ze.DISCONNECT:
          this.ondisconnect();
          break;
        case ze.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const i of e)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let i = !1;
    return function(...r) {
      i || (i = !0, e.packet({
        type: ze.ACK,
        id: t,
        data: r
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (delete this.acks[t.id], e.withError && t.data.unshift(null), e.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: ze.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const i of e)
        i.apply(this, t.data);
    }
  }
}
function Ca(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
Ca.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * n);
    n = Math.floor(t * 10) & 1 ? n + e : n - e;
  }
  return Math.min(n, this.max) | 0;
};
Ca.prototype.reset = function() {
  this.attempts = 0;
};
Ca.prototype.setMin = function(n) {
  this.ms = n;
};
Ca.prototype.setMax = function(n) {
  this.max = n;
};
Ca.prototype.setJitter = function(n) {
  this.jitter = n;
};
class Sf extends Fn {
  constructor(t, e) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, jc(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((i = e.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Ca({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const r = e.parser || y3;
    this.encoder = new r.Encoder(), this.decoder = new r.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new s3(this.uri, this.opts);
    const e = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const r = ur(e, "open", function() {
      i.onopen(), t && t();
    }), s = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), t ? t(a) : this.maybeReconnectOnOpen();
    }, o = ur(e, "error", s);
    if (this._timeout !== !1) {
      const a = this._timeout, l = this.setTimeoutFn(() => {
        r(), s(new Error("timeout")), e.close();
      }, a);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(r), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      ur(t, "ping", this.onping.bind(this)),
      ur(t, "data", this.ondata.bind(this)),
      ur(t, "error", this.onerror.bind(this)),
      ur(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      ur(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    Bc(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new tm(this, t, e), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const i of e)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let i = 0; i < e.length; i++)
      this.engine.write(e[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, e) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((r) => {
          r ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", r)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const dl = {};
function Vu(n, t) {
  typeof n == "object" && (t = n, n = void 0), t = t || {};
  const e = o3(n, t.path || "/socket.io"), i = e.source, r = e.id, s = e.path, o = dl[r] && s in dl[r].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
  let l;
  return a ? l = new Sf(i, t) : (dl[r] || (dl[r] = new Sf(i, t)), l = dl[r]), e.query && !t.query && (t.query = e.queryKey), l.socket(e.path, t);
}
Object.assign(Vu, {
  Manager: Sf,
  Socket: tm,
  io: Vu,
  connect: Vu
});
var v3 = typeof global == "object" && global && global.Object === Object && global, w3 = typeof self == "object" && self && self.Object === Object && self, Ed = v3 || w3 || Function("return this")(), _a = Ed.Symbol, em = Object.prototype, x3 = em.hasOwnProperty, _3 = em.toString, pl = _a ? _a.toStringTag : void 0;
function S3(n) {
  var t = x3.call(n, pl), e = n[pl];
  try {
    n[pl] = void 0;
    var i = !0;
  } catch {
  }
  var r = _3.call(n);
  return i && (t ? n[pl] = e : delete n[pl]), r;
}
var k3 = Object.prototype, A3 = k3.toString;
function N3(n) {
  return A3.call(n);
}
var C3 = "[object Null]", P3 = "[object Undefined]", vg = _a ? _a.toStringTag : void 0;
function nm(n) {
  return n == null ? n === void 0 ? P3 : C3 : vg && vg in Object(n) ? S3(n) : N3(n);
}
function L3(n) {
  return n != null && typeof n == "object";
}
var I3 = "[object Symbol]";
function Od(n) {
  return typeof n == "symbol" || L3(n) && nm(n) == I3;
}
function E3(n, t) {
  for (var e = -1, i = n == null ? 0 : n.length, r = Array(i); ++e < i; )
    r[e] = t(n[e], e, n);
  return r;
}
var Td = Array.isArray, O3 = 1 / 0, wg = _a ? _a.prototype : void 0, xg = wg ? wg.toString : void 0;
function im(n) {
  if (typeof n == "string")
    return n;
  if (Td(n))
    return E3(n, im) + "";
  if (Od(n))
    return xg ? xg.call(n) : "";
  var t = n + "";
  return t == "0" && 1 / n == -O3 ? "-0" : t;
}
function cc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
var T3 = "[object AsyncFunction]", F3 = "[object Function]", M3 = "[object GeneratorFunction]", D3 = "[object Proxy]";
function R3(n) {
  if (!cc(n))
    return !1;
  var t = nm(n);
  return t == F3 || t == M3 || t == T3 || t == D3;
}
var Mh = Ed["__core-js_shared__"], _g = function() {
  var n = /[^.]+$/.exec(Mh && Mh.keys && Mh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function B3(n) {
  return !!_g && _g in n;
}
var j3 = Function.prototype, q3 = j3.toString;
function z3(n) {
  if (n != null) {
    try {
      return q3.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var $3 = /[\\^$.*+?()[\]{}|]/g, U3 = /^\[object .+?Constructor\]$/, W3 = Function.prototype, H3 = Object.prototype, G3 = W3.toString, V3 = H3.hasOwnProperty, Y3 = RegExp(
  "^" + G3.call(V3).replace($3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function K3(n) {
  if (!cc(n) || B3(n))
    return !1;
  var t = R3(n) ? Y3 : U3;
  return t.test(z3(n));
}
function X3(n, t) {
  return n == null ? void 0 : n[t];
}
function Fd(n, t) {
  var e = X3(n, t);
  return K3(e) ? e : void 0;
}
var Sg = function() {
  try {
    var n = Fd(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), J3 = 9007199254740991, Z3 = /^(?:0|[1-9]\d*)$/;
function Q3(n, t) {
  var e = typeof n;
  return t = t ?? J3, !!t && (e == "number" || e != "symbol" && Z3.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function tx(n, t, e) {
  t == "__proto__" && Sg ? Sg(n, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : n[t] = e;
}
function rm(n, t) {
  return n === t || n !== n && t !== t;
}
var ex = Object.prototype, nx = ex.hasOwnProperty;
function ix(n, t, e) {
  var i = n[t];
  (!(nx.call(n, t) && rm(i, e)) || e === void 0 && !(t in n)) && tx(n, t, e);
}
var rx = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, sx = /^\w*$/;
function ox(n, t) {
  if (Td(n))
    return !1;
  var e = typeof n;
  return e == "number" || e == "symbol" || e == "boolean" || n == null || Od(n) ? !0 : sx.test(n) || !rx.test(n) || t != null && n in Object(t);
}
var Il = Fd(Object, "create");
function ax() {
  this.__data__ = Il ? Il(null) : {}, this.size = 0;
}
function lx(n) {
  var t = this.has(n) && delete this.__data__[n];
  return this.size -= t ? 1 : 0, t;
}
var ux = "__lodash_hash_undefined__", cx = Object.prototype, hx = cx.hasOwnProperty;
function fx(n) {
  var t = this.__data__;
  if (Il) {
    var e = t[n];
    return e === ux ? void 0 : e;
  }
  return hx.call(t, n) ? t[n] : void 0;
}
var dx = Object.prototype, px = dx.hasOwnProperty;
function gx(n) {
  var t = this.__data__;
  return Il ? t[n] !== void 0 : px.call(t, n);
}
var mx = "__lodash_hash_undefined__";
function yx(n, t) {
  var e = this.__data__;
  return this.size += this.has(n) ? 0 : 1, e[n] = Il && t === void 0 ? mx : t, this;
}
function Lo(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Lo.prototype.clear = ax;
Lo.prototype.delete = lx;
Lo.prototype.get = fx;
Lo.prototype.has = gx;
Lo.prototype.set = yx;
function bx() {
  this.__data__ = [], this.size = 0;
}
function qc(n, t) {
  for (var e = n.length; e--; )
    if (rm(n[e][0], t))
      return e;
  return -1;
}
var vx = Array.prototype, wx = vx.splice;
function xx(n) {
  var t = this.__data__, e = qc(t, n);
  if (e < 0)
    return !1;
  var i = t.length - 1;
  return e == i ? t.pop() : wx.call(t, e, 1), --this.size, !0;
}
function _x(n) {
  var t = this.__data__, e = qc(t, n);
  return e < 0 ? void 0 : t[e][1];
}
function Sx(n) {
  return qc(this.__data__, n) > -1;
}
function kx(n, t) {
  var e = this.__data__, i = qc(e, n);
  return i < 0 ? (++this.size, e.push([n, t])) : e[i][1] = t, this;
}
function Pa(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Pa.prototype.clear = bx;
Pa.prototype.delete = xx;
Pa.prototype.get = _x;
Pa.prototype.has = Sx;
Pa.prototype.set = kx;
var Ax = Fd(Ed, "Map");
function Nx() {
  this.size = 0, this.__data__ = {
    hash: new Lo(),
    map: new (Ax || Pa)(),
    string: new Lo()
  };
}
function Cx(n) {
  var t = typeof n;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? n !== "__proto__" : n === null;
}
function zc(n, t) {
  var e = n.__data__;
  return Cx(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function Px(n) {
  var t = zc(this, n).delete(n);
  return this.size -= t ? 1 : 0, t;
}
function Lx(n) {
  return zc(this, n).get(n);
}
function Ix(n) {
  return zc(this, n).has(n);
}
function Ex(n, t) {
  var e = zc(this, n), i = e.size;
  return e.set(n, t), this.size += e.size == i ? 0 : 1, this;
}
function To(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
To.prototype.clear = Nx;
To.prototype.delete = Px;
To.prototype.get = Lx;
To.prototype.has = Ix;
To.prototype.set = Ex;
var Ox = "Expected a function";
function Md(n, t) {
  if (typeof n != "function" || t != null && typeof t != "function")
    throw new TypeError(Ox);
  var e = function() {
    var i = arguments, r = t ? t.apply(this, i) : i[0], s = e.cache;
    if (s.has(r))
      return s.get(r);
    var o = n.apply(this, i);
    return e.cache = s.set(r, o) || s, o;
  };
  return e.cache = new (Md.Cache || To)(), e;
}
Md.Cache = To;
var Tx = 500;
function Fx(n) {
  var t = Md(n, function(i) {
    return e.size === Tx && e.clear(), i;
  }), e = t.cache;
  return t;
}
var Mx = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Dx = /\\(\\)?/g, Rx = Fx(function(n) {
  var t = [];
  return n.charCodeAt(0) === 46 && t.push(""), n.replace(Mx, function(e, i, r, s) {
    t.push(r ? s.replace(Dx, "$1") : i || e);
  }), t;
});
function Bx(n) {
  return n == null ? "" : im(n);
}
function sm(n, t) {
  return Td(n) ? n : ox(n, t) ? [n] : Rx(Bx(n));
}
var jx = 1 / 0;
function om(n) {
  if (typeof n == "string" || Od(n))
    return n;
  var t = n + "";
  return t == "0" && 1 / n == -jx ? "-0" : t;
}
function qx(n, t) {
  t = sm(t, n);
  for (var e = 0, i = t.length; n != null && e < i; )
    n = n[om(t[e++])];
  return e && e == i ? n : void 0;
}
function _o(n, t, e) {
  var i = n == null ? void 0 : qx(n, t);
  return i === void 0 ? e : i;
}
function zx(n, t, e, i) {
  if (!cc(n))
    return n;
  t = sm(t, n);
  for (var r = -1, s = t.length, o = s - 1, a = n; a != null && ++r < s; ) {
    var l = om(t[r]), h = e;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return n;
    if (r != o) {
      var u = a[l];
      h = void 0, h === void 0 && (h = cc(u) ? u : Q3(t[r + 1]) ? [] : {});
    }
    ix(a, l, h), a = a[l];
  }
  return n;
}
function kg(n, t, e) {
  return n == null ? n : zx(n, t, e);
}
var kf = "http://www.w3.org/1999/xhtml";
const Ag = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: kf,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function am(n) {
  var t = n += "", e = t.indexOf(":");
  return e >= 0 && (t = n.slice(0, e)) !== "xmlns" && (n = n.slice(e + 1)), Ag.hasOwnProperty(t) ? { space: Ag[t], local: n } : n;
}
function $x(n) {
  return function() {
    var t = this.ownerDocument, e = this.namespaceURI;
    return e === kf && t.documentElement.namespaceURI === kf ? t.createElement(n) : t.createElementNS(e, n);
  };
}
function Ux(n) {
  return function() {
    return this.ownerDocument.createElementNS(n.space, n.local);
  };
}
function lm(n) {
  var t = am(n);
  return (t.local ? Ux : $x)(t);
}
function Wx() {
}
function um(n) {
  return n == null ? Wx : function() {
    return this.querySelector(n);
  };
}
function Hx(n) {
  typeof n != "function" && (n = um(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = new Array(o), l, h, u = 0; u < o; ++u)
      (l = s[u]) && (h = n.call(l, l.__data__, u, s)) && ("__data__" in l && (h.__data__ = l.__data__), a[u] = h);
  return new Si(i, this._parents);
}
function cm(n) {
  return n == null ? [] : Array.isArray(n) ? n : Array.from(n);
}
function Gx() {
  return [];
}
function Vx(n) {
  return n == null ? Gx : function() {
    return this.querySelectorAll(n);
  };
}
function Yx(n) {
  return function() {
    return cm(n.apply(this, arguments));
  };
}
function Kx(n) {
  typeof n == "function" ? n = Yx(n) : n = Vx(n);
  for (var t = this._groups, e = t.length, i = [], r = [], s = 0; s < e; ++s)
    for (var o = t[s], a = o.length, l, h = 0; h < a; ++h)
      (l = o[h]) && (i.push(n.call(l, l.__data__, h, o)), r.push(l));
  return new Si(i, r);
}
function Xx(n) {
  return function() {
    return this.matches(n);
  };
}
function hm(n) {
  return function(t) {
    return t.matches(n);
  };
}
var Jx = Array.prototype.find;
function Zx(n) {
  return function() {
    return Jx.call(this.children, n);
  };
}
function Qx() {
  return this.firstElementChild;
}
function t4(n) {
  return this.select(n == null ? Qx : Zx(typeof n == "function" ? n : hm(n)));
}
var e4 = Array.prototype.filter;
function n4() {
  return Array.from(this.children);
}
function i4(n) {
  return function() {
    return e4.call(this.children, n);
  };
}
function r4(n) {
  return this.selectAll(n == null ? n4 : i4(typeof n == "function" ? n : hm(n)));
}
function s4(n) {
  typeof n != "function" && (n = Xx(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = [], l, h = 0; h < o; ++h)
      (l = s[h]) && n.call(l, l.__data__, h, s) && a.push(l);
  return new Si(i, this._parents);
}
function fm(n) {
  return new Array(n.length);
}
function o4() {
  return new Si(this._enter || this._groups.map(fm), this._parents);
}
function hc(n, t) {
  this.ownerDocument = n.ownerDocument, this.namespaceURI = n.namespaceURI, this._next = null, this._parent = n, this.__data__ = t;
}
hc.prototype = {
  constructor: hc,
  appendChild: function(n) {
    return this._parent.insertBefore(n, this._next);
  },
  insertBefore: function(n, t) {
    return this._parent.insertBefore(n, t);
  },
  querySelector: function(n) {
    return this._parent.querySelector(n);
  },
  querySelectorAll: function(n) {
    return this._parent.querySelectorAll(n);
  }
};
function a4(n) {
  return function() {
    return n;
  };
}
function l4(n, t, e, i, r, s) {
  for (var o = 0, a, l = t.length, h = s.length; o < h; ++o)
    (a = t[o]) ? (a.__data__ = s[o], i[o] = a) : e[o] = new hc(n, s[o]);
  for (; o < l; ++o)
    (a = t[o]) && (r[o] = a);
}
function u4(n, t, e, i, r, s, o) {
  var a, l, h = /* @__PURE__ */ new Map(), u = t.length, d = s.length, p = new Array(u), f;
  for (a = 0; a < u; ++a)
    (l = t[a]) && (p[a] = f = o.call(l, l.__data__, a, t) + "", h.has(f) ? r[a] = l : h.set(f, l));
  for (a = 0; a < d; ++a)
    f = o.call(n, s[a], a, s) + "", (l = h.get(f)) ? (i[a] = l, l.__data__ = s[a], h.delete(f)) : e[a] = new hc(n, s[a]);
  for (a = 0; a < u; ++a)
    (l = t[a]) && h.get(p[a]) === l && (r[a] = l);
}
function c4(n) {
  return n.__data__;
}
function h4(n, t) {
  if (!arguments.length) return Array.from(this, c4);
  var e = t ? u4 : l4, i = this._parents, r = this._groups;
  typeof n != "function" && (n = a4(n));
  for (var s = r.length, o = new Array(s), a = new Array(s), l = new Array(s), h = 0; h < s; ++h) {
    var u = i[h], d = r[h], p = d.length, f = f4(n.call(u, u && u.__data__, h, i)), g = f.length, b = a[h] = new Array(g), x = o[h] = new Array(g), y = l[h] = new Array(p);
    e(u, d, b, x, y, f, t);
    for (var v = 0, k = 0, C, I; v < g; ++v)
      if (C = b[v]) {
        for (v >= k && (k = v + 1); !(I = x[k]) && ++k < g; ) ;
        C._next = I || null;
      }
  }
  return o = new Si(o, i), o._enter = a, o._exit = l, o;
}
function f4(n) {
  return typeof n == "object" && "length" in n ? n : Array.from(n);
}
function d4() {
  return new Si(this._exit || this._groups.map(fm), this._parents);
}
function p4(n, t, e) {
  var i = this.enter(), r = this, s = this.exit();
  return typeof n == "function" ? (i = n(i), i && (i = i.selection())) : i = i.append(n + ""), t != null && (r = t(r), r && (r = r.selection())), e == null ? s.remove() : e(s), i && r ? i.merge(r).order() : r;
}
function g4(n) {
  for (var t = n.selection ? n.selection() : n, e = this._groups, i = t._groups, r = e.length, s = i.length, o = Math.min(r, s), a = new Array(r), l = 0; l < o; ++l)
    for (var h = e[l], u = i[l], d = h.length, p = a[l] = new Array(d), f, g = 0; g < d; ++g)
      (f = h[g] || u[g]) && (p[g] = f);
  for (; l < r; ++l)
    a[l] = e[l];
  return new Si(a, this._parents);
}
function m4() {
  for (var n = this._groups, t = -1, e = n.length; ++t < e; )
    for (var i = n[t], r = i.length - 1, s = i[r], o; --r >= 0; )
      (o = i[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function y4(n) {
  n || (n = b4);
  function t(d, p) {
    return d && p ? n(d.__data__, p.__data__) : !d - !p;
  }
  for (var e = this._groups, i = e.length, r = new Array(i), s = 0; s < i; ++s) {
    for (var o = e[s], a = o.length, l = r[s] = new Array(a), h, u = 0; u < a; ++u)
      (h = o[u]) && (l[u] = h);
    l.sort(t);
  }
  return new Si(r, this._parents).order();
}
function b4(n, t) {
  return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function v4() {
  var n = arguments[0];
  return arguments[0] = this, n.apply(null, arguments), this;
}
function w4() {
  return Array.from(this);
}
function x4() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length; r < s; ++r) {
      var o = i[r];
      if (o) return o;
    }
  return null;
}
function _4() {
  let n = 0;
  for (const t of this) ++n;
  return n;
}
function S4() {
  return !this.node();
}
function k4(n) {
  for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
    for (var r = t[e], s = 0, o = r.length, a; s < o; ++s)
      (a = r[s]) && n.call(a, a.__data__, s, r);
  return this;
}
function A4(n) {
  return function() {
    this.removeAttribute(n);
  };
}
function N4(n) {
  return function() {
    this.removeAttributeNS(n.space, n.local);
  };
}
function C4(n, t) {
  return function() {
    this.setAttribute(n, t);
  };
}
function P4(n, t) {
  return function() {
    this.setAttributeNS(n.space, n.local, t);
  };
}
function L4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttribute(n) : this.setAttribute(n, e);
  };
}
function I4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e);
  };
}
function E4(n, t) {
  var e = am(n);
  if (arguments.length < 2) {
    var i = this.node();
    return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e);
  }
  return this.each((t == null ? e.local ? N4 : A4 : typeof t == "function" ? e.local ? I4 : L4 : e.local ? P4 : C4)(e, t));
}
function dm(n) {
  return n.ownerDocument && n.ownerDocument.defaultView || n.document && n || n.defaultView;
}
function O4(n) {
  return function() {
    this.style.removeProperty(n);
  };
}
function T4(n, t, e) {
  return function() {
    this.style.setProperty(n, t, e);
  };
}
function F4(n, t, e) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.style.removeProperty(n) : this.style.setProperty(n, i, e);
  };
}
function M4(n, t, e) {
  return arguments.length > 1 ? this.each((t == null ? O4 : typeof t == "function" ? F4 : T4)(n, t, e ?? "")) : D4(this.node(), n);
}
function D4(n, t) {
  return n.style.getPropertyValue(t) || dm(n).getComputedStyle(n, null).getPropertyValue(t);
}
function R4(n) {
  return function() {
    delete this[n];
  };
}
function B4(n, t) {
  return function() {
    this[n] = t;
  };
}
function j4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? delete this[n] : this[n] = e;
  };
}
function q4(n, t) {
  return arguments.length > 1 ? this.each((t == null ? R4 : typeof t == "function" ? j4 : B4)(n, t)) : this.node()[n];
}
function pm(n) {
  return n.trim().split(/^|\s+/);
}
function Dd(n) {
  return n.classList || new gm(n);
}
function gm(n) {
  this._node = n, this._names = pm(n.getAttribute("class") || "");
}
gm.prototype = {
  add: function(n) {
    var t = this._names.indexOf(n);
    t < 0 && (this._names.push(n), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(n) {
    var t = this._names.indexOf(n);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(n) {
    return this._names.indexOf(n) >= 0;
  }
};
function mm(n, t) {
  for (var e = Dd(n), i = -1, r = t.length; ++i < r; ) e.add(t[i]);
}
function ym(n, t) {
  for (var e = Dd(n), i = -1, r = t.length; ++i < r; ) e.remove(t[i]);
}
function z4(n) {
  return function() {
    mm(this, n);
  };
}
function $4(n) {
  return function() {
    ym(this, n);
  };
}
function U4(n, t) {
  return function() {
    (t.apply(this, arguments) ? mm : ym)(this, n);
  };
}
function W4(n, t) {
  var e = pm(n + "");
  if (arguments.length < 2) {
    for (var i = Dd(this.node()), r = -1, s = e.length; ++r < s; ) if (!i.contains(e[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? U4 : t ? z4 : $4)(e, t));
}
function H4() {
  this.textContent = "";
}
function G4(n) {
  return function() {
    this.textContent = n;
  };
}
function V4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Y4(n) {
  return arguments.length ? this.each(n == null ? H4 : (typeof n == "function" ? V4 : G4)(n)) : this.node().textContent;
}
function K4() {
  this.innerHTML = "";
}
function X4(n) {
  return function() {
    this.innerHTML = n;
  };
}
function J4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Z4(n) {
  return arguments.length ? this.each(n == null ? K4 : (typeof n == "function" ? J4 : X4)(n)) : this.node().innerHTML;
}
function Q4() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function t_() {
  return this.each(Q4);
}
function e_() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function n_() {
  return this.each(e_);
}
function i_(n) {
  var t = typeof n == "function" ? n : lm(n);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function r_() {
  return null;
}
function s_(n, t) {
  var e = typeof n == "function" ? n : lm(n), i = t == null ? r_ : typeof t == "function" ? t : um(t);
  return this.select(function() {
    return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null);
  });
}
function o_() {
  var n = this.parentNode;
  n && n.removeChild(this);
}
function a_() {
  return this.each(o_);
}
function l_() {
  var n = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function u_() {
  var n = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function c_(n) {
  return this.select(n ? u_ : l_);
}
function h_(n) {
  return arguments.length ? this.property("__data__", n) : this.node().__data__;
}
function f_(n) {
  return function(t) {
    n.call(this, t, this.__data__);
  };
}
function d_(n) {
  return n.trim().split(/^|\s+/).map(function(t) {
    var e = "", i = t.indexOf(".");
    return i >= 0 && (e = t.slice(i + 1), t = t.slice(0, i)), { type: t, name: e };
  });
}
function p_(n) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var e = 0, i = -1, r = t.length, s; e < r; ++e)
        s = t[e], (!n.type || s.type === n.type) && s.name === n.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++i] = s;
      ++i ? t.length = i : delete this.__on;
    }
  };
}
function g_(n, t, e) {
  return function() {
    var i = this.__on, r, s = f_(t);
    if (i) {
      for (var o = 0, a = i.length; o < a; ++o)
        if ((r = i[o]).type === n.type && r.name === n.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = e), r.value = t;
          return;
        }
    }
    this.addEventListener(n.type, s, e), r = { type: n.type, name: n.name, value: t, listener: s, options: e }, i ? i.push(r) : this.__on = [r];
  };
}
function m_(n, t, e) {
  var i = d_(n + ""), r, s = i.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, h = a.length, u; l < h; ++l)
        for (r = 0, u = a[l]; r < s; ++r)
          if ((o = i[r]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (a = t ? g_ : p_, r = 0; r < s; ++r) this.each(a(i[r], t, e));
  return this;
}
function bm(n, t, e) {
  var i = dm(n), r = i.CustomEvent;
  typeof r == "function" ? r = new r(t, e) : (r = i.document.createEvent("Event"), e ? (r.initEvent(t, e.bubbles, e.cancelable), r.detail = e.detail) : r.initEvent(t, !1, !1)), n.dispatchEvent(r);
}
function y_(n, t) {
  return function() {
    return bm(this, n, t);
  };
}
function b_(n, t) {
  return function() {
    return bm(this, n, t.apply(this, arguments));
  };
}
function v_(n, t) {
  return this.each((typeof t == "function" ? b_ : y_)(n, t));
}
function* w_() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length, o; r < s; ++r)
      (o = i[r]) && (yield o);
}
var vm = [null];
function Si(n, t) {
  this._groups = n, this._parents = t;
}
function x_() {
  return this;
}
Si.prototype = {
  constructor: Si,
  select: Hx,
  selectAll: Kx,
  selectChild: t4,
  selectChildren: r4,
  filter: s4,
  data: h4,
  enter: o4,
  exit: d4,
  join: p4,
  merge: g4,
  selection: x_,
  order: m4,
  sort: y4,
  call: v4,
  nodes: w4,
  node: x4,
  size: _4,
  empty: S4,
  each: k4,
  attr: E4,
  style: M4,
  property: q4,
  classed: W4,
  text: Y4,
  html: Z4,
  raise: t_,
  lower: n_,
  append: i_,
  insert: s_,
  remove: a_,
  clone: c_,
  datum: h_,
  on: m_,
  dispatch: v_,
  [Symbol.iterator]: w_
};
function __(n) {
  return typeof n == "string" ? new Si([[document.querySelector(n)]], [document.documentElement]) : new Si([[n]], vm);
}
function S_(n) {
  return typeof n == "string" ? new Si([document.querySelectorAll(n)], [document.documentElement]) : new Si([cm(n)], vm);
}
function Yu(n, t) {
  return n == null || t == null ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function k_(n, t) {
  return n == null || t == null ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
}
function wm(n) {
  let t, e, i;
  n.length !== 2 ? (t = Yu, e = (a, l) => Yu(n(a), l), i = (a, l) => n(a) - l) : (t = n === Yu || n === k_ ? n : A_, e = n, i = n);
  function r(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) < 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function s(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) <= 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function o(a, l, h = 0, u = a.length) {
    const d = r(a, l, h, u - 1);
    return d > h && i(a[d - 1], l) > -i(a[d], l) ? d - 1 : d;
  }
  return { left: r, center: o, right: s };
}
function A_() {
  return 0;
}
function N_(n) {
  return n === null ? NaN : +n;
}
const C_ = wm(Yu), P_ = C_.right;
wm(N_).center;
const L_ = Math.sqrt(50), I_ = Math.sqrt(10), E_ = Math.sqrt(2);
function fc(n, t, e) {
  const i = (t - n) / Math.max(0, e), r = Math.floor(Math.log10(i)), s = i / Math.pow(10, r), o = s >= L_ ? 10 : s >= I_ ? 5 : s >= E_ ? 2 : 1;
  let a, l, h;
  return r < 0 ? (h = Math.pow(10, -r) / o, a = Math.round(n * h), l = Math.round(t * h), a / h < n && ++a, l / h > t && --l, h = -h) : (h = Math.pow(10, r) * o, a = Math.round(n / h), l = Math.round(t / h), a * h < n && ++a, l * h > t && --l), l < a && 0.5 <= e && e < 2 ? fc(n, t, e * 2) : [a, l, h];
}
function O_(n, t, e) {
  if (t = +t, n = +n, e = +e, !(e > 0)) return [];
  if (n === t) return [n];
  const i = t < n, [r, s, o] = i ? fc(t, n, e) : fc(n, t, e);
  if (!(s >= r)) return [];
  const a = s - r + 1, l = new Array(a);
  if (i)
    if (o < 0) for (let h = 0; h < a; ++h) l[h] = (s - h) / -o;
    else for (let h = 0; h < a; ++h) l[h] = (s - h) * o;
  else if (o < 0) for (let h = 0; h < a; ++h) l[h] = (r + h) / -o;
  else for (let h = 0; h < a; ++h) l[h] = (r + h) * o;
  return l;
}
function Af(n, t, e) {
  return t = +t, n = +n, e = +e, fc(n, t, e)[2];
}
function T_(n, t, e) {
  t = +t, n = +n, e = +e;
  const i = t < n, r = i ? Af(t, n, e) : Af(n, t, e);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function F_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(n);
      break;
    default:
      this.range(t).domain(n);
      break;
  }
  return this;
}
function M_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof n == "function" ? this.interpolator(n) : this.range(n);
      break;
    }
    default: {
      this.domain(n), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
function Rd(n, t, e) {
  n.prototype = t.prototype = e, e.constructor = n;
}
function xm(n, t) {
  var e = Object.create(n.prototype);
  for (var i in t) e[i] = t[i];
  return e;
}
function Ul() {
}
var El = 0.7, dc = 1 / El, ba = "\\s*([+-]?\\d+)\\s*", Ol = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Tr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", D_ = /^#([0-9a-f]{3,8})$/, R_ = new RegExp(`^rgb\\(${ba},${ba},${ba}\\)$`), B_ = new RegExp(`^rgb\\(${Tr},${Tr},${Tr}\\)$`), j_ = new RegExp(`^rgba\\(${ba},${ba},${ba},${Ol}\\)$`), q_ = new RegExp(`^rgba\\(${Tr},${Tr},${Tr},${Ol}\\)$`), z_ = new RegExp(`^hsl\\(${Ol},${Tr},${Tr}\\)$`), $_ = new RegExp(`^hsla\\(${Ol},${Tr},${Tr},${Ol}\\)$`), Ng = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Rd(Ul, Sa, {
  copy(n) {
    return Object.assign(new this.constructor(), this, n);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Cg,
  // Deprecated! Use color.formatHex.
  formatHex: Cg,
  formatHex8: U_,
  formatHsl: W_,
  formatRgb: Pg,
  toString: Pg
});
function Cg() {
  return this.rgb().formatHex();
}
function U_() {
  return this.rgb().formatHex8();
}
function W_() {
  return _m(this).formatHsl();
}
function Pg() {
  return this.rgb().formatRgb();
}
function Sa(n) {
  var t, e;
  return n = (n + "").trim().toLowerCase(), (t = D_.exec(n)) ? (e = t[1].length, t = parseInt(t[1], 16), e === 6 ? Lg(t) : e === 3 ? new _i(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : e === 8 ? Mu(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : e === 4 ? Mu(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = R_.exec(n)) ? new _i(t[1], t[2], t[3], 1) : (t = B_.exec(n)) ? new _i(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = j_.exec(n)) ? Mu(t[1], t[2], t[3], t[4]) : (t = q_.exec(n)) ? Mu(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = z_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, 1) : (t = $_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, t[4]) : Ng.hasOwnProperty(n) ? Lg(Ng[n]) : n === "transparent" ? new _i(NaN, NaN, NaN, 0) : null;
}
function Lg(n) {
  return new _i(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function Mu(n, t, e, i) {
  return i <= 0 && (n = t = e = NaN), new _i(n, t, e, i);
}
function H_(n) {
  return n instanceof Ul || (n = Sa(n)), n ? (n = n.rgb(), new _i(n.r, n.g, n.b, n.opacity)) : new _i();
}
function Nn(n, t, e, i) {
  return arguments.length === 1 ? H_(n) : new _i(n, t, e, i ?? 1);
}
function _i(n, t, e, i) {
  this.r = +n, this.g = +t, this.b = +e, this.opacity = +i;
}
Rd(_i, Nn, xm(Ul, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new _i(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? El : Math.pow(El, n), new _i(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new _i(So(this.r), So(this.g), So(this.b), pc(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ig,
  // Deprecated! Use color.formatHex.
  formatHex: Ig,
  formatHex8: G_,
  formatRgb: Eg,
  toString: Eg
}));
function Ig() {
  return `#${go(this.r)}${go(this.g)}${go(this.b)}`;
}
function G_() {
  return `#${go(this.r)}${go(this.g)}${go(this.b)}${go((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Eg() {
  const n = pc(this.opacity);
  return `${n === 1 ? "rgb(" : "rgba("}${So(this.r)}, ${So(this.g)}, ${So(this.b)}${n === 1 ? ")" : `, ${n})`}`;
}
function pc(n) {
  return isNaN(n) ? 1 : Math.max(0, Math.min(1, n));
}
function So(n) {
  return Math.max(0, Math.min(255, Math.round(n) || 0));
}
function go(n) {
  return n = So(n), (n < 16 ? "0" : "") + n.toString(16);
}
function Og(n, t, e, i) {
  return i <= 0 ? n = t = e = NaN : e <= 0 || e >= 1 ? n = t = NaN : t <= 0 && (n = NaN), new fr(n, t, e, i);
}
function _m(n) {
  if (n instanceof fr) return new fr(n.h, n.s, n.l, n.opacity);
  if (n instanceof Ul || (n = Sa(n)), !n) return new fr();
  if (n instanceof fr) return n;
  n = n.rgb();
  var t = n.r / 255, e = n.g / 255, i = n.b / 255, r = Math.min(t, e, i), s = Math.max(t, e, i), o = NaN, a = s - r, l = (s + r) / 2;
  return a ? (t === s ? o = (e - i) / a + (e < i) * 6 : e === s ? o = (i - t) / a + 2 : o = (t - e) / a + 4, a /= l < 0.5 ? s + r : 2 - s - r, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new fr(o, a, l, n.opacity);
}
function V_(n, t, e, i) {
  return arguments.length === 1 ? _m(n) : new fr(n, t, e, i ?? 1);
}
function fr(n, t, e, i) {
  this.h = +n, this.s = +t, this.l = +e, this.opacity = +i;
}
Rd(fr, V_, xm(Ul, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new fr(this.h, this.s, this.l * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? El : Math.pow(El, n), new fr(this.h, this.s, this.l * n, this.opacity);
  },
  rgb() {
    var n = this.h % 360 + (this.h < 0) * 360, t = isNaN(n) || isNaN(this.s) ? 0 : this.s, e = this.l, i = e + (e < 0.5 ? e : 1 - e) * t, r = 2 * e - i;
    return new _i(
      Dh(n >= 240 ? n - 240 : n + 120, r, i),
      Dh(n, r, i),
      Dh(n < 120 ? n + 240 : n - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new fr(Tg(this.h), Du(this.s), Du(this.l), pc(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const n = pc(this.opacity);
    return `${n === 1 ? "hsl(" : "hsla("}${Tg(this.h)}, ${Du(this.s) * 100}%, ${Du(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`;
  }
}));
function Tg(n) {
  return n = (n || 0) % 360, n < 0 ? n + 360 : n;
}
function Du(n) {
  return Math.max(0, Math.min(1, n || 0));
}
function Dh(n, t, e) {
  return (n < 60 ? t + (e - t) * n / 60 : n < 180 ? e : n < 240 ? t + (e - t) * (240 - n) / 60 : t) * 255;
}
const Bd = (n) => () => n;
function Y_(n, t) {
  return function(e) {
    return n + e * t;
  };
}
function K_(n, t, e) {
  return n = Math.pow(n, e), t = Math.pow(t, e) - n, e = 1 / e, function(i) {
    return Math.pow(n + i * t, e);
  };
}
function X_(n) {
  return (n = +n) == 1 ? Sm : function(t, e) {
    return e - t ? K_(t, e, n) : Bd(isNaN(t) ? e : t);
  };
}
function Sm(n, t) {
  var e = t - n;
  return e ? Y_(n, e) : Bd(isNaN(n) ? t : n);
}
const Fg = function n(t) {
  var e = X_(t);
  function i(r, s) {
    var o = e((r = Nn(r)).r, (s = Nn(s)).r), a = e(r.g, s.g), l = e(r.b, s.b), h = Sm(r.opacity, s.opacity);
    return function(u) {
      return r.r = o(u), r.g = a(u), r.b = l(u), r.opacity = h(u), r + "";
    };
  }
  return i.gamma = n, i;
}(1);
function J_(n, t) {
  t || (t = []);
  var e = n ? Math.min(t.length, n.length) : 0, i = t.slice(), r;
  return function(s) {
    for (r = 0; r < e; ++r) i[r] = n[r] * (1 - s) + t[r] * s;
    return i;
  };
}
function Z_(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function Q_(n, t) {
  var e = t ? t.length : 0, i = n ? Math.min(e, n.length) : 0, r = new Array(i), s = new Array(e), o;
  for (o = 0; o < i; ++o) r[o] = $c(n[o], t[o]);
  for (; o < e; ++o) s[o] = t[o];
  return function(a) {
    for (o = 0; o < i; ++o) s[o] = r[o](a);
    return s;
  };
}
function tS(n, t) {
  var e = /* @__PURE__ */ new Date();
  return n = +n, t = +t, function(i) {
    return e.setTime(n * (1 - i) + t * i), e;
  };
}
function gc(n, t) {
  return n = +n, t = +t, function(e) {
    return n * (1 - e) + t * e;
  };
}
function eS(n, t) {
  var e = {}, i = {}, r;
  (n === null || typeof n != "object") && (n = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in n ? e[r] = $c(n[r], t[r]) : i[r] = t[r];
  return function(s) {
    for (r in e) i[r] = e[r](s);
    return i;
  };
}
var Nf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Rh = new RegExp(Nf.source, "g");
function nS(n) {
  return function() {
    return n;
  };
}
function iS(n) {
  return function(t) {
    return n(t) + "";
  };
}
function rS(n, t) {
  var e = Nf.lastIndex = Rh.lastIndex = 0, i, r, s, o = -1, a = [], l = [];
  for (n = n + "", t = t + ""; (i = Nf.exec(n)) && (r = Rh.exec(t)); )
    (s = r.index) > e && (s = t.slice(e, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, l.push({ i: o, x: gc(i, r) })), e = Rh.lastIndex;
  return e < t.length && (s = t.slice(e), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? iS(l[0].x) : nS(t) : (t = l.length, function(h) {
    for (var u = 0, d; u < t; ++u) a[(d = l[u]).i] = d.x(h);
    return a.join("");
  });
}
function $c(n, t) {
  var e = typeof t, i;
  return t == null || e === "boolean" ? Bd(t) : (e === "number" ? gc : e === "string" ? (i = Sa(t)) ? (t = i, Fg) : rS : t instanceof Sa ? Fg : t instanceof Date ? tS : Z_(t) ? J_ : Array.isArray(t) ? Q_ : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? eS : gc)(n, t);
}
function km(n, t) {
  return n = +n, t = +t, function(e) {
    return Math.round(n * (1 - e) + t * e);
  };
}
function sS(n) {
  return function() {
    return n;
  };
}
function oS(n) {
  return +n;
}
var Mg = [0, 1];
function Ds(n) {
  return n;
}
function Cf(n, t) {
  return (t -= n = +n) ? function(e) {
    return (e - n) / t;
  } : sS(isNaN(t) ? NaN : 0.5);
}
function aS(n, t) {
  var e;
  return n > t && (e = n, n = t, t = e), function(i) {
    return Math.max(n, Math.min(t, i));
  };
}
function lS(n, t, e) {
  var i = n[0], r = n[1], s = t[0], o = t[1];
  return r < i ? (i = Cf(r, i), s = e(o, s)) : (i = Cf(i, r), s = e(s, o)), function(a) {
    return s(i(a));
  };
}
function uS(n, t, e) {
  var i = Math.min(n.length, t.length) - 1, r = new Array(i), s = new Array(i), o = -1;
  for (n[i] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o < i; )
    r[o] = Cf(n[o], n[o + 1]), s[o] = e(t[o], t[o + 1]);
  return function(a) {
    var l = P_(n, a, 1, i) - 1;
    return s[l](r[l](a));
  };
}
function cS(n, t) {
  return t.domain(n.domain()).range(n.range()).interpolate(n.interpolate()).clamp(n.clamp()).unknown(n.unknown());
}
function hS() {
  var n = Mg, t = Mg, e = $c, i, r, s, o = Ds, a, l, h;
  function u() {
    var p = Math.min(n.length, t.length);
    return o !== Ds && (o = aS(n[0], n[p - 1])), a = p > 2 ? uS : lS, l = h = null, d;
  }
  function d(p) {
    return p == null || isNaN(p = +p) ? s : (l || (l = a(n.map(i), t, e)))(i(o(p)));
  }
  return d.invert = function(p) {
    return o(r((h || (h = a(t, n.map(i), gc)))(p)));
  }, d.domain = function(p) {
    return arguments.length ? (n = Array.from(p, oS), u()) : n.slice();
  }, d.range = function(p) {
    return arguments.length ? (t = Array.from(p), u()) : t.slice();
  }, d.rangeRound = function(p) {
    return t = Array.from(p), e = km, u();
  }, d.clamp = function(p) {
    return arguments.length ? (o = p ? !0 : Ds, u()) : o !== Ds;
  }, d.interpolate = function(p) {
    return arguments.length ? (e = p, u()) : e;
  }, d.unknown = function(p) {
    return arguments.length ? (s = p, d) : s;
  }, function(p, f) {
    return i = p, r = f, u();
  };
}
function fS() {
  return hS()(Ds, Ds);
}
function dS(n) {
  return Math.abs(n = Math.round(n)) >= 1e21 ? n.toLocaleString("en").replace(/,/g, "") : n.toString(10);
}
function mc(n, t) {
  if ((e = (n = t ? n.toExponential(t - 1) : n.toExponential()).indexOf("e")) < 0) return null;
  var e, i = n.slice(0, e);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +n.slice(e + 1)
  ];
}
function ka(n) {
  return n = mc(Math.abs(n)), n ? n[1] : NaN;
}
function pS(n, t) {
  return function(e, i) {
    for (var r = e.length, s = [], o = 0, a = n[0], l = 0; r > 0 && a > 0 && (l + a + 1 > i && (a = Math.max(1, i - l)), s.push(e.substring(r -= a, r + a)), !((l += a + 1) > i)); )
      a = n[o = (o + 1) % n.length];
    return s.reverse().join(t);
  };
}
function gS(n) {
  return function(t) {
    return t.replace(/[0-9]/g, function(e) {
      return n[+e];
    });
  };
}
var mS = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function yc(n) {
  if (!(t = mS.exec(n))) throw new Error("invalid format: " + n);
  var t;
  return new jd({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
yc.prototype = jd.prototype;
function jd(n) {
  this.fill = n.fill === void 0 ? " " : n.fill + "", this.align = n.align === void 0 ? ">" : n.align + "", this.sign = n.sign === void 0 ? "-" : n.sign + "", this.symbol = n.symbol === void 0 ? "" : n.symbol + "", this.zero = !!n.zero, this.width = n.width === void 0 ? void 0 : +n.width, this.comma = !!n.comma, this.precision = n.precision === void 0 ? void 0 : +n.precision, this.trim = !!n.trim, this.type = n.type === void 0 ? "" : n.type + "";
}
jd.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function yS(n) {
  t: for (var t = n.length, e = 1, i = -1, r; e < t; ++e)
    switch (n[e]) {
      case ".":
        i = r = e;
        break;
      case "0":
        i === 0 && (i = e), r = e;
        break;
      default:
        if (!+n[e]) break t;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? n.slice(0, i) + n.slice(r + 1) : n;
}
var Am;
function bS(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1], s = r - (Am = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = i.length;
  return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + mc(n, Math.max(0, t + s - 1))[0];
}
function Dg(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const Rg = {
  "%": (n, t) => (n * 100).toFixed(t),
  b: (n) => Math.round(n).toString(2),
  c: (n) => n + "",
  d: dS,
  e: (n, t) => n.toExponential(t),
  f: (n, t) => n.toFixed(t),
  g: (n, t) => n.toPrecision(t),
  o: (n) => Math.round(n).toString(8),
  p: (n, t) => Dg(n * 100, t),
  r: Dg,
  s: bS,
  X: (n) => Math.round(n).toString(16).toUpperCase(),
  x: (n) => Math.round(n).toString(16)
};
function Bg(n) {
  return n;
}
var jg = Array.prototype.map, qg = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function vS(n) {
  var t = n.grouping === void 0 || n.thousands === void 0 ? Bg : pS(jg.call(n.grouping, Number), n.thousands + ""), e = n.currency === void 0 ? "" : n.currency[0] + "", i = n.currency === void 0 ? "" : n.currency[1] + "", r = n.decimal === void 0 ? "." : n.decimal + "", s = n.numerals === void 0 ? Bg : gS(jg.call(n.numerals, String)), o = n.percent === void 0 ? "%" : n.percent + "", a = n.minus === void 0 ? "−" : n.minus + "", l = n.nan === void 0 ? "NaN" : n.nan + "";
  function h(d) {
    d = yc(d);
    var p = d.fill, f = d.align, g = d.sign, b = d.symbol, x = d.zero, y = d.width, v = d.comma, k = d.precision, C = d.trim, I = d.type;
    I === "n" ? (v = !0, I = "g") : Rg[I] || (k === void 0 && (k = 12), C = !0, I = "g"), (x || p === "0" && f === "=") && (x = !0, p = "0", f = "=");
    var D = b === "$" ? e : b === "#" && /[boxX]/.test(I) ? "0" + I.toLowerCase() : "", E = b === "$" ? i : /[%p]/.test(I) ? o : "", O = Rg[I], M = /[defgprs%]/.test(I);
    k = k === void 0 ? 6 : /[gprs]/.test(I) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function q(P) {
      var A = D, F = E, _, J, V;
      if (I === "c")
        F = O(P) + F, P = "";
      else {
        P = +P;
        var R = P < 0 || 1 / P < 0;
        if (P = isNaN(P) ? l : O(Math.abs(P), k), C && (P = yS(P)), R && +P == 0 && g !== "+" && (R = !1), A = (R ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + A, F = (I === "s" ? qg[8 + Am / 3] : "") + F + (R && g === "(" ? ")" : ""), M) {
          for (_ = -1, J = P.length; ++_ < J; )
            if (V = P.charCodeAt(_), 48 > V || V > 57) {
              F = (V === 46 ? r + P.slice(_ + 1) : P.slice(_)) + F, P = P.slice(0, _);
              break;
            }
        }
      }
      v && !x && (P = t(P, 1 / 0));
      var tt = A.length + P.length + F.length, H = tt < y ? new Array(y - tt + 1).join(p) : "";
      switch (v && x && (P = t(H + P, H.length ? y - F.length : 1 / 0), H = ""), f) {
        case "<":
          P = A + P + F + H;
          break;
        case "=":
          P = A + H + P + F;
          break;
        case "^":
          P = H.slice(0, tt = H.length >> 1) + A + P + F + H.slice(tt);
          break;
        default:
          P = H + A + P + F;
          break;
      }
      return s(P);
    }
    return q.toString = function() {
      return d + "";
    }, q;
  }
  function u(d, p) {
    var f = h((d = yc(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(ka(p) / 3))) * 3, b = Math.pow(10, -g), x = qg[8 + g / 3];
    return function(y) {
      return f(b * y) + x;
    };
  }
  return {
    format: h,
    formatPrefix: u
  };
}
var Ru, qd, Nm;
wS({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function wS(n) {
  return Ru = vS(n), qd = Ru.format, Nm = Ru.formatPrefix, Ru;
}
function Cm(n) {
  return Math.max(0, -ka(Math.abs(n)));
}
function xS(n, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(ka(t) / 3))) * 3 - ka(Math.abs(n)));
}
function _S(n, t) {
  return n = Math.abs(n), t = Math.abs(t) - n, Math.max(0, ka(t) - ka(n)) + 1;
}
function SS(n, t, e, i) {
  var r = T_(n, t, e), s;
  switch (i = yc(i ?? ",f"), i.type) {
    case "s": {
      var o = Math.max(Math.abs(n), Math.abs(t));
      return i.precision == null && !isNaN(s = xS(r, o)) && (i.precision = s), Nm(i, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(s = _S(r, Math.max(Math.abs(n), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(s = Cm(r)) && (i.precision = s - (i.type === "%") * 2);
      break;
    }
  }
  return qd(i);
}
function Pm(n) {
  var t = n.domain;
  return n.ticks = function(e) {
    var i = t();
    return O_(i[0], i[i.length - 1], e ?? 10);
  }, n.tickFormat = function(e, i) {
    var r = t();
    return SS(r[0], r[r.length - 1], e ?? 10, i);
  }, n.nice = function(e) {
    e == null && (e = 10);
    var i = t(), r = 0, s = i.length - 1, o = i[r], a = i[s], l, h, u = 10;
    for (a < o && (h = o, o = a, a = h, h = r, r = s, s = h); u-- > 0; ) {
      if (h = Af(o, a, e), h === l)
        return i[r] = o, i[s] = a, t(i);
      if (h > 0)
        o = Math.floor(o / h) * h, a = Math.ceil(a / h) * h;
      else if (h < 0)
        o = Math.ceil(o * h) / h, a = Math.floor(a * h) / h;
      else
        break;
      l = h;
    }
    return n;
  }, n;
}
function Lm() {
  var n = fS();
  return n.copy = function() {
    return cS(n, Lm());
  }, F_.apply(n, arguments), Pm(n);
}
function kS() {
  var n = 0, t = 1, e, i, r, s, o = Ds, a = !1, l;
  function h(d) {
    return d == null || isNaN(d = +d) ? l : o(r === 0 ? 0.5 : (d = (s(d) - e) * r, a ? Math.max(0, Math.min(1, d)) : d));
  }
  h.domain = function(d) {
    return arguments.length ? ([n, t] = d, e = s(n = +n), i = s(t = +t), r = e === i ? 0 : 1 / (i - e), h) : [n, t];
  }, h.clamp = function(d) {
    return arguments.length ? (a = !!d, h) : a;
  }, h.interpolator = function(d) {
    return arguments.length ? (o = d, h) : o;
  };
  function u(d) {
    return function(p) {
      var f, g;
      return arguments.length ? ([f, g] = p, o = d(f, g), h) : [o(0), o(1)];
    };
  }
  return h.range = u($c), h.rangeRound = u(km), h.unknown = function(d) {
    return arguments.length ? (l = d, h) : l;
  }, function(d) {
    return s = d, e = d(n), i = d(t), r = e === i ? 0 : 1 / (i - e), h;
  };
}
function AS(n, t) {
  return t.domain(n.domain()).interpolator(n.interpolator()).clamp(n.clamp()).unknown(n.unknown());
}
function Im() {
  var n = Pm(kS()(Ds));
  return n.copy = function() {
    return AS(n, Im());
  }, M_.apply(n, arguments);
}
function NS(n) {
  return n;
}
var Ku = 1, Xu = 2, Pf = 3, vl = 4, zg = 1e-6;
function CS(n) {
  return "translate(" + n + ",0)";
}
function PS(n) {
  return "translate(0," + n + ")";
}
function LS(n) {
  return (t) => +n(t);
}
function IS(n, t) {
  return t = Math.max(0, n.bandwidth() - t * 2) / 2, n.round() && (t = Math.round(t)), (e) => +n(e) + t;
}
function ES() {
  return !this.__axis;
}
function Uc(n, t) {
  var e = [], i = null, r = null, s = 6, o = 6, a = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, h = n === Ku || n === vl ? -1 : 1, u = n === vl || n === Xu ? "x" : "y", d = n === Ku || n === Pf ? CS : PS;
  function p(f) {
    var g = i ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), b = r ?? (t.tickFormat ? t.tickFormat.apply(t, e) : NS), x = Math.max(s, 0) + a, y = t.range(), v = +y[0] + l, k = +y[y.length - 1] + l, C = (t.bandwidth ? IS : LS)(t.copy(), l), I = f.selection ? f.selection() : f, D = I.selectAll(".domain").data([null]), E = I.selectAll(".tick").data(g, t).order(), O = E.exit(), M = E.enter().append("g").attr("class", "tick"), q = E.select("line"), P = E.select("text");
    D = D.merge(D.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), E = E.merge(M), q = q.merge(M.append("line").attr("stroke", "currentColor").attr(u + "2", h * s)), P = P.merge(M.append("text").attr("fill", "currentColor").attr(u, h * x).attr("dy", n === Ku ? "0em" : n === Pf ? "0.71em" : "0.32em")), f !== I && (D = D.transition(f), E = E.transition(f), q = q.transition(f), P = P.transition(f), O = O.transition(f).attr("opacity", zg).attr("transform", function(A) {
      return isFinite(A = C(A)) ? d(A + l) : this.getAttribute("transform");
    }), M.attr("opacity", zg).attr("transform", function(A) {
      var F = this.parentNode.__axis;
      return d((F && isFinite(F = F(A)) ? F : C(A)) + l);
    })), O.remove(), D.attr("d", n === vl || n === Xu ? o ? "M" + h * o + "," + v + "H" + l + "V" + k + "H" + h * o : "M" + l + "," + v + "V" + k : o ? "M" + v + "," + h * o + "V" + l + "H" + k + "V" + h * o : "M" + v + "," + l + "H" + k), E.attr("opacity", 1).attr("transform", function(A) {
      return d(C(A) + l);
    }), q.attr(u + "2", h * s), P.attr(u, h * x).text(b), I.filter(ES).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", n === Xu ? "start" : n === vl ? "end" : "middle"), I.each(function() {
      this.__axis = C;
    });
  }
  return p.scale = function(f) {
    return arguments.length ? (t = f, p) : t;
  }, p.ticks = function() {
    return e = Array.from(arguments), p;
  }, p.tickArguments = function(f) {
    return arguments.length ? (e = f == null ? [] : Array.from(f), p) : e.slice();
  }, p.tickValues = function(f) {
    return arguments.length ? (i = f == null ? null : Array.from(f), p) : i && i.slice();
  }, p.tickFormat = function(f) {
    return arguments.length ? (r = f, p) : r;
  }, p.tickSize = function(f) {
    return arguments.length ? (s = o = +f, p) : s;
  }, p.tickSizeInner = function(f) {
    return arguments.length ? (s = +f, p) : s;
  }, p.tickSizeOuter = function(f) {
    return arguments.length ? (o = +f, p) : o;
  }, p.tickPadding = function(f) {
    return arguments.length ? (a = +f, p) : a;
  }, p.offset = function(f) {
    return arguments.length ? (l = +f, p) : l;
  }, p;
}
function OS(n) {
  return Uc(Ku, n);
}
function TS(n) {
  return Uc(Xu, n);
}
function FS(n) {
  return Uc(Pf, n);
}
function MS(n) {
  return Uc(vl, n);
}
const Lf = Math.PI, If = 2 * Lf, uo = 1e-6, DS = If - uo;
function Em(n) {
  this._ += n[0];
  for (let t = 1, e = n.length; t < e; ++t)
    this._ += arguments[t] + n[t];
}
function RS(n) {
  let t = Math.floor(n);
  if (!(t >= 0)) throw new Error(`invalid digits: ${n}`);
  if (t > 15) return Em;
  const e = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, s = i.length; r < s; ++r)
      this._ += Math.round(arguments[r] * e) / e + i[r];
  };
}
class zd {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Em : RS(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, i, r) {
    this._append`Q${+t},${+e},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, e, i, r, s, o) {
    this._append`C${+t},${+e},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, e, i, r, s) {
    if (t = +t, e = +e, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = i - t, h = r - e, u = o - t, d = a - e, p = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (p > uo) if (!(Math.abs(d * l - h * u) > uo) || !s)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let f = i - o, g = r - a, b = l * l + h * h, x = f * f + g * g, y = Math.sqrt(b), v = Math.sqrt(p), k = s * Math.tan((Lf - Math.acos((b + p - x) / (2 * y * v))) / 2), C = k / v, I = k / y;
      Math.abs(C - 1) > uo && this._append`L${t + C * u},${e + C * d}`, this._append`A${s},${s},0,0,${+(d * f > u * g)},${this._x1 = t + I * l},${this._y1 = e + I * h}`;
    }
  }
  arc(t, e, i, r, s, o) {
    if (t = +t, e = +e, i = +i, o = !!o, i < 0) throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(r), l = i * Math.sin(r), h = t + a, u = e + l, d = 1 ^ o, p = o ? r - s : s - r;
    this._x1 === null ? this._append`M${h},${u}` : (Math.abs(this._x1 - h) > uo || Math.abs(this._y1 - u) > uo) && this._append`L${h},${u}`, i && (p < 0 && (p = p % If + If), p > DS ? this._append`A${i},${i},0,1,${d},${t - a},${e - l}A${i},${i},0,1,${d},${this._x1 = h},${this._y1 = u}` : p > uo && this._append`A${i},${i},0,${+(p >= Lf)},${d},${this._x1 = t + i * Math.cos(s)},${this._y1 = e + i * Math.sin(s)}`);
  }
  rect(t, e, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
}
function Om() {
  return new zd();
}
Om.prototype = zd.prototype;
function Ki(n) {
  return function() {
    return n;
  };
}
const $g = Math.abs, ai = Math.atan2, ao = Math.cos, BS = Math.max, Bh = Math.min, Sr = Math.sin, Ir = Math.sqrt, xi = 1e-12, Aa = Math.PI, bc = Aa / 2, Tm = 2 * Aa;
function jS(n) {
  return n > 1 ? 0 : n < -1 ? Aa : Math.acos(n);
}
function Ug(n) {
  return n >= 1 ? bc : n <= -1 ? -bc : Math.asin(n);
}
function Fm(n) {
  let t = 3;
  return n.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const i = Math.floor(e);
      if (!(i >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = i;
    }
    return n;
  }, () => new zd(t);
}
function qS(n) {
  return n.innerRadius;
}
function zS(n) {
  return n.outerRadius;
}
function $S(n) {
  return n.startAngle;
}
function US(n) {
  return n.endAngle;
}
function WS(n) {
  return n && n.padAngle;
}
function HS(n, t, e, i, r, s, o, a) {
  var l = e - n, h = i - t, u = o - r, d = a - s, p = d * l - u * h;
  if (!(p * p < xi))
    return p = (u * (t - s) - d * (n - r)) / p, [n + p * l, t + p * h];
}
function Bu(n, t, e, i, r, s, o) {
  var a = n - e, l = t - i, h = (o ? s : -s) / Ir(a * a + l * l), u = h * l, d = -h * a, p = n + u, f = t + d, g = e + u, b = i + d, x = (p + g) / 2, y = (f + b) / 2, v = g - p, k = b - f, C = v * v + k * k, I = r - s, D = p * b - g * f, E = (k < 0 ? -1 : 1) * Ir(BS(0, I * I * C - D * D)), O = (D * k - v * E) / C, M = (-D * v - k * E) / C, q = (D * k + v * E) / C, P = (-D * v + k * E) / C, A = O - x, F = M - y, _ = q - x, J = P - y;
  return A * A + F * F > _ * _ + J * J && (O = q, M = P), {
    cx: O,
    cy: M,
    x01: -u,
    y01: -d,
    x11: O * (r / I - 1),
    y11: M * (r / I - 1)
  };
}
function GS() {
  var n = qS, t = zS, e = Ki(0), i = null, r = $S, s = US, o = WS, a = null, l = Fm(h);
  function h() {
    var u, d, p = +n.apply(this, arguments), f = +t.apply(this, arguments), g = r.apply(this, arguments) - bc, b = s.apply(this, arguments) - bc, x = $g(b - g), y = b > g;
    if (a || (a = u = l()), f < p && (d = f, f = p, p = d), !(f > xi)) a.moveTo(0, 0);
    else if (x > Tm - xi)
      a.moveTo(f * ao(g), f * Sr(g)), a.arc(0, 0, f, g, b, !y), p > xi && (a.moveTo(p * ao(b), p * Sr(b)), a.arc(0, 0, p, b, g, y));
    else {
      var v = g, k = b, C = g, I = b, D = x, E = x, O = o.apply(this, arguments) / 2, M = O > xi && (i ? +i.apply(this, arguments) : Ir(p * p + f * f)), q = Bh($g(f - p) / 2, +e.apply(this, arguments)), P = q, A = q, F, _;
      if (M > xi) {
        var J = Ug(M / p * Sr(O)), V = Ug(M / f * Sr(O));
        (D -= J * 2) > xi ? (J *= y ? 1 : -1, C += J, I -= J) : (D = 0, C = I = (g + b) / 2), (E -= V * 2) > xi ? (V *= y ? 1 : -1, v += V, k -= V) : (E = 0, v = k = (g + b) / 2);
      }
      var R = f * ao(v), tt = f * Sr(v), H = p * ao(I), ct = p * Sr(I);
      if (q > xi) {
        var it = f * ao(k), N = f * Sr(k), z = p * ao(C), G = p * Sr(C), Y;
        if (x < Aa)
          if (Y = HS(R, tt, z, G, it, N, H, ct)) {
            var ot = R - Y[0], xt = tt - Y[1], gt = it - Y[0], wt = N - Y[1], qt = 1 / Sr(jS((ot * gt + xt * wt) / (Ir(ot * ot + xt * xt) * Ir(gt * gt + wt * wt))) / 2), Rt = Ir(Y[0] * Y[0] + Y[1] * Y[1]);
            P = Bh(q, (p - Rt) / (qt - 1)), A = Bh(q, (f - Rt) / (qt + 1));
          } else
            P = A = 0;
      }
      E > xi ? A > xi ? (F = Bu(z, G, R, tt, f, A, y), _ = Bu(it, N, H, ct, f, A, y), a.moveTo(F.cx + F.x01, F.cy + F.y01), A < q ? a.arc(F.cx, F.cy, A, ai(F.y01, F.x01), ai(_.y01, _.x01), !y) : (a.arc(F.cx, F.cy, A, ai(F.y01, F.x01), ai(F.y11, F.x11), !y), a.arc(0, 0, f, ai(F.cy + F.y11, F.cx + F.x11), ai(_.cy + _.y11, _.cx + _.x11), !y), a.arc(_.cx, _.cy, A, ai(_.y11, _.x11), ai(_.y01, _.x01), !y))) : (a.moveTo(R, tt), a.arc(0, 0, f, v, k, !y)) : a.moveTo(R, tt), !(p > xi) || !(D > xi) ? a.lineTo(H, ct) : P > xi ? (F = Bu(H, ct, it, N, p, -P, y), _ = Bu(R, tt, z, G, p, -P, y), a.lineTo(F.cx + F.x01, F.cy + F.y01), P < q ? a.arc(F.cx, F.cy, P, ai(F.y01, F.x01), ai(_.y01, _.x01), !y) : (a.arc(F.cx, F.cy, P, ai(F.y01, F.x01), ai(F.y11, F.x11), !y), a.arc(0, 0, p, ai(F.cy + F.y11, F.cx + F.x11), ai(_.cy + _.y11, _.cx + _.x11), y), a.arc(_.cx, _.cy, P, ai(_.y11, _.x11), ai(_.y01, _.x01), !y))) : a.arc(0, 0, p, I, C, y);
    }
    if (a.closePath(), u) return a = null, u + "" || null;
  }
  return h.centroid = function() {
    var u = (+n.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Aa / 2;
    return [ao(d) * u, Sr(d) * u];
  }, h.innerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Ki(+u), h) : n;
  }, h.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Ki(+u), h) : t;
  }, h.cornerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Ki(+u), h) : e;
  }, h.padRadius = function(u) {
    return arguments.length ? (i = u == null ? null : typeof u == "function" ? u : Ki(+u), h) : i;
  }, h.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ki(+u), h) : r;
  }, h.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : Ki(+u), h) : s;
  }, h.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Ki(+u), h) : o;
  }, h.context = function(u) {
    return arguments.length ? (a = u ?? null, h) : a;
  }, h;
}
const VS = {
  draw(n, t) {
    const e = Ir(t / Aa);
    n.moveTo(e, 0), n.arc(0, 0, e, 0, Tm);
  }
}, YS = {
  draw(n, t) {
    const e = Ir(t), i = -e / 2;
    n.rect(i, i, e, e);
  }
}, jh = Ir(3), KS = {
  draw(n, t) {
    const e = -Ir(t / (jh * 3));
    n.moveTo(0, e * 2), n.lineTo(-jh * e, -e), n.lineTo(jh * e, -e), n.closePath();
  }
};
function XS(n, t) {
  let e = null, i = Fm(r);
  n = typeof n == "function" ? n : Ki(n || VS), t = typeof t == "function" ? t : Ki(t === void 0 ? 64 : +t);
  function r() {
    let s;
    if (e || (e = s = i()), n.apply(this, arguments).draw(e, +t.apply(this, arguments)), s) return e = null, s + "" || null;
  }
  return r.type = function(s) {
    return arguments.length ? (n = typeof s == "function" ? s : Ki(s), r) : n;
  }, r.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Ki(+s), r) : t;
  }, r.context = function(s) {
    return arguments.length ? (e = s ?? null, r) : e;
  }, r;
}
const Be = {
  precisionFixed: Cm,
  format: qd,
  select: __,
  selectAll: S_,
  scaleLinear: Lm,
  scaleSequential: Im,
  axisTop: OS,
  axisBottom: FS,
  axisRight: TS,
  axisLeft: MS,
  symbol: XS,
  path: Om,
  arc: GS,
  symbolTriangle: KS,
  symbolSquare: YS
};
function ca(n) {
  return typeof n == "string" && n.length === 6 && !isNaN(+("0x" + n.replace("#", "")));
}
class JS {
  constructor({
    elementID: t,
    env: e = "production",
    main: i = !0,
    units: r = "decimal",
    decimalPlaces: s = 2,
    fractionRoundTo: o = 0,
    saw: a = null,
    app: l = !1,
    embed: h = !1,
    height: u = 0,
    width: d = 0,
    flipY: p = !1,
    flipX: f = !1,
    colors: g = {
      partA: "#1d9bc4",
      partB: "#127da1",
      partHover: "#29c778",
      partSelected: "#1bc319",
      stock: "#ffd166",
      text: "#ffffff"
    },
    options: b = {
      disableClick: !1,
      enableStretch: !0
    },
    vueComponent: x
  }) {
    et(this, "env");
    et(this, "main");
    //is this the main vis or not
    et(this, "units", "decimal");
    et(this, "decimalPlaces");
    et(this, "fractionRoundTo");
    et(this, "formatNumber", (t) => Qt(
      t,
      this.units,
      this.decimalPlaces ?? 2,
      !1,
      this.fractionRoundTo ?? 0
    ).toString());
    et(this, "saw");
    et(this, "stockType");
    et(this, "numUniqueShapes");
    et(this, "app");
    et(this, "embed");
    et(this, "height");
    et(this, "width");
    et(this, "device");
    et(this, "vueComponent");
    et(this, "elWidth");
    et(this, "elHeight");
    et(this, "w");
    et(this, "h");
    et(this, "padding");
    et(this, "mobileBreakpoint");
    //scales
    et(this, "xScale", Be.scaleLinear());
    et(this, "yScale", Be.scaleLinear());
    et(this, "yPositionScale", Be.scaleLinear());
    et(this, "xPositionScale", Be.scaleLinear());
    et(this, "yAxisScale", Be.scaleLinear());
    et(this, "measurementScale", Be.scaleLinear());
    et(this, "xAxis");
    et(this, "yAxis");
    et(this, "stretched");
    et(this, "shapeXAxis");
    et(this, "shapeYAxis");
    et(this, "cutMeasurementXAxes");
    et(this, "cutMeasurementYAxes");
    et(this, "axisSpacing");
    et(this, "flipY");
    et(this, "flipX");
    et(this, "colors");
    et(this, "options");
    et(this, "moveMode");
    et(this, "moveRotation");
    et(this, "moving");
    et(this, "shape");
    et(this, "shapeColorScale");
    et(this, "scoreColorScale");
    et(this, "hasTouch");
    et(this, "highlightguillotine");
    et(this, "debug", "");
    //groups | guillotine | positions
    et(this, "elementID");
    //the id of the element to draw the vis in
    et(this, "el");
    et(this, "htmlEl");
    et(this, "svgCanvas");
    et(this, "axisGroup");
    et(this, "stockGroup");
    et(this, "stockWrappers");
    et(this, "stock");
    et(this, "shapeGroup");
    et(this, "shapeWrappers");
    et(this, "shapes");
    et(this, "shapeIDText");
    et(this, "shapeNameText");
    et(this, "shapeLengthText");
    et(this, "shapeWidthText");
    et(this, "groupGroup");
    et(this, "groups");
    et(this, "bandingGroup");
    et(this, "bandingWrappers");
    et(this, "banding");
    et(this, "segmentGroup");
    et(this, "segments");
    et(this, "segment");
    et(this, "positionGroup");
    et(this, "position");
    et(this, "dotGroup");
    et(this, "placementPositionGroup");
    et(this, "dot");
    et(this, "cutGroup");
    et(this, "cuts");
    et(this, "cut");
    if (!t) throw new Error("elementID is required");
    if (this.el = Be.select(t), this.el === null) return;
    const y = this.el.node();
    if (y !== null) {
      this.htmlEl = y, this.vueComponent = x, this.env = Ve.call(this.vueComponent, ["env"]) === "development" ? "development" : "production", this.debug = this.env === "development" ? "groups" : "", this.app = l || !1, this.embed = h || !1, this.height = u, this.width = d, this.device = l ? "app" : "desktop", this.stretched = !1, this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.w = 0, this.h = 0, this.padding = 0, this.mobileBreakpoint = 450, this.main = i, this.saw = a, this.cutMeasurementXAxes = [], this.cutMeasurementYAxes = [], this.axisSpacing = 16, this.flipY = p, this.flipX = f, g = {
        ...g
      };
      for (const [v, k] of Object.entries(g))
        k && (g[v] = k.replace("#", ""));
      this.colors = {
        partA: ca(g == null ? void 0 : g.partA) ? Nn("#" + g.partA) : Nn("#1d9bc4"),
        partB: ca(g == null ? void 0 : g.partB) ? Nn("#" + g.partB) : Nn("#127da1"),
        partHover: ca(g == null ? void 0 : g.partHover) ? Nn("#" + g.partHover) : Nn("#29c778"),
        partSelected: ca(g == null ? void 0 : g.partSelected) ? Nn("#" + g.partSelected) : Nn("#1bc319"),
        stock: ca(g == null ? void 0 : g.stock) ? Nn("#" + g.stock) : Nn("#ffd166"),
        text: ca(g == null ? void 0 : g.text) ? Nn("#" + g.text) : Nn("#ffffff")
      }, this.shapeColorScale = Be.scaleSequential([
        this.colors.partA,
        this.colors.partB
      ]), this.env = e, this.moveMode = !1, this.moving = !1, this.moveRotation = !1, this.units = r, this.decimalPlaces = s, this.fractionRoundTo = o, this.hasTouch = !1, this.options = b, this.init();
    }
  }
  /**
      * sets up the various wrappers - only needs to be called once
      * the z index is set by the order drawn
      */
  init() {
    if (!this.el) return !1;
    if ((this.decimalPlaces === null || this.decimalPlaces === void 0 || isNaN(this.decimalPlaces)) && (this.decimalPlaces = 2), (this.fractionRoundTo === null || this.fractionRoundTo === void 0 || isNaN(this.fractionRoundTo)) && (this.fractionRoundTo = 0), !this.svgCanvas) {
      if (this.htmlEl.querySelector("svg") === null) {
        const e = this.el.append("svg").attr("class", "vis");
        if (e === null) return;
        e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").attr("id", "stripes").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(90)").attr("id", "grain-l").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("id", "grain-w").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), this.svgCanvas = e;
      }
      this.axisGroup = this.svgCanvas.append("g").attr("class", "axis-group"), this.stockGroup = this.svgCanvas.append("g").attr("class", "stock-group"), this.shapeGroup = this.svgCanvas.append("g").attr("class", "shapes"), this.bandingGroup = this.svgCanvas.append("g").attr("class", "banding-group"), this.segmentGroup = this.svgCanvas.append("g").attr("class", "segments").attr("display", "none"), this.groupGroup = this.svgCanvas.append("g").attr("class", "groups").attr("display", "none"), this.positionGroup = this.svgCanvas.append("g").attr("class", "positions"), this.dotGroup = this.svgCanvas.append("g").attr("class", "dots"), this.env === "development" && (this.placementPositionGroup = this.svgCanvas.append("g").attr("class", "placements")), this.cutGroup = this.svgCanvas.append("g").attr("class", "cuts");
    }
    this.elWidth > 0 && this.updateSize(!0), this.hasTouch = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
  updateUnits(t, e, i) {
    t && (this.units = t), e && (this.decimalPlaces = e), i && (this.fractionRoundTo = i), this.refreshShapes(), this.refreshStock();
  }
  trimNameToFit(t, e) {
    function i(r, s, o) {
      const a = o[s], l = Be.select(a);
      l.text(r.name);
      let h = l.text();
      const u = l.node();
      if (!u) return;
      let d = u.getComputedTextLength();
      const p = this.getWidthAttribute(r) - 20;
      for (; d > p && h.length > 0; )
        h = h.slice(0, -1), l.text(h.length ? h + "..." : ""), d = l.node().getComputedTextLength();
    }
    t.each(i.bind(e));
  }
  getShapeColor(t) {
    var e;
    if (this.env === "development")
      switch (this.debug) {
        case "guillotine":
          if (t.guillotineData.firstShape)
            return Nn(252, 3, 182);
          if (t.addedAsGroup)
            return Nn(43, 156, 16);
          if (typeof t.guillotineData.myPhase == "number") {
            const i = [0, 115, 255], r = [176, 255, 231];
            return `rgb(${i.map((o, a) => Math.round(o + t.guillotineData.myPhase / 5 * (r[a] - o))).join(",")})`;
          }
          break;
        case "groups":
          if (t.addedAsGroup !== !1)
            return Nn(43, 156, 16);
          break;
        case "priorityShapes":
          if (t != null && t.priority && ((e = t.priority) != null && e[t.stock.parentID]))
            return Nn(139, 171, 46);
          break;
        case "score":
          return this.scoreColorScale(t.bestScore.total);
      }
    return this.shapeColorScale(t.parentID - 1);
  }
  setDevice() {
    if (!(!this.htmlEl || this.htmlEl.style.display === "none") && this.htmlEl.offsetWidth) {
      if (this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.elWidth === 0) return !1;
      this.main ? this.elWidth <= this.mobileBreakpoint || this.app ? (this.device = "mobile", this.padding = 0) : (this.device = "desktop", this.padding = 50) : this.padding = 0, this.w = this.elWidth;
    }
  }
  //find the largest dimensions of all the stock (not just the active one)
  findLargestStockDimensions() {
    const t = Ve.call(this.vueComponent, ["stockList"]).filter((r) => r.used);
    if (!(t != null && t.length)) return [null, null];
    const e = t.reduce((r, s) => r.l > s.l ? r : s), i = t.reduce((r, s) => r.w > s.w ? r : s);
    return [e, i];
  }
  debounce(t, e, i = !1) {
    let r;
    return (...s) => new Promise((o) => {
      const a = () => {
        r = null, i || o(t.apply(this, s));
      };
      clearTimeout(r), i && !r && o(t.apply(this, s)), r = setTimeout(a, e);
    });
  }
  updateSize(t = !1) {
    return this.debounce(this._updateSize.bind(this), 10, t)();
  }
  requiresStretch(t, e = null) {
    return t ? (e === null && (e = t.w / t.l), e < 0.15) : !1;
  }
  setAspectRatio(t) {
    if (t) {
      this.w = this.elWidth;
      const e = t.w / t.l;
      this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.requiresStretch(t, e) && this.options.enableStretch ? (this.h = this.htmlEl.clientWidth * 0.15 + this.padding * 2, this.stretched = !0) : (this.h = this.xScale(t.getShortSide()) + this.padding, this.stretched = !1), this.yScale.domain([0, t.w]).range([this.padding, this.h - this.padding]), this.yAxisScale.domain(this.flipY ? [0, t.w] : [t.w, 0]).range([this.padding, this.h - this.padding]), this.yPositionScale.domain([0, t.w]).range(this.flipY ? [this.padding, this.h - this.padding] : [this.h - this.padding, this.padding]), e > 2 && (this.w = this.htmlEl.clientWidth / e + this.padding * 2, this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.h = this.xScale(t.getShortSide()) + this.padding), this.xPositionScale.domain([0, t.l]).range(this.flipX ? [this.w - this.padding, this.padding] : [this.padding, this.w - this.padding]), this.measurementScale.domain([0, t.l]).range([0, this.w - this.padding * 2]), this.w > 0 && this.h > 0 && (e > 2 ? this.el.style("width", this.w + "px") : this.el.style("width", ""), this.el.style("height", this.h + "px"));
    }
  }
  _updateSize() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    this.vueComponent && "suppressResizeObserver" in this.vueComponent && (this.vueComponent.suppressResizeObserver = !0);
    const t = Ve.call(this.vueComponent, ["stockList"]), e = Ve.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length) || !(e != null && e.length)) return !1;
    this.setDevice(), this.refreshStock(), this.refreshShapes(), this.env === "development" && this.refreshPlacementPositions();
  }
  refreshCuts() {
    const t = Ve.call(this.vueComponent, ["activeCuts"]);
    this.resetSegments(), this.initCuts(t);
  }
  refreshStock() {
    const t = Ve.call(this.vueComponent, ["stockList"]);
    if (!(t != null && t.length)) return !1;
    const e = Ve.call(this.vueComponent, ["activeStock"]);
    this.initStock(e), this.refreshCuts();
    const i = Ve.call(this.vueComponent, ["activeSegments"]);
    this.initSegments(i), this.resetPositions(), typeof this.vueComponent.toggleSegments == "function" && this.vueComponent.toggleSegments(!1);
  }
  refreshShapes() {
    const t = Ve.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length)) return !1;
    this.resetPositions();
    const e = Ve.call(this.vueComponent, ["activeShapes"]);
    this.initShapes(e, t);
  }
  refreshPlacementPositions() {
    const t = Ve.call(this.vueComponent, ["placementPositions"]);
    if (!(t != null && t.length)) return !1;
    this.resetPlacementPositions();
    const e = t.filter((i) => i.stockID === Ve.call(this.vueComponent, ["activeStock"]).id);
    this.initPlacementPositions(e);
  }
  recreateUerGroups(t) {
    t.filter((r) => r.inUserGroup);
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r].addedAsGroup, a = t.filter((l) => l.addedAsGroup === o);
      e.push(a), r += a.length;
    }
    const i = [];
    e.forEach((r) => {
      const s = Math.min(...r.map((u) => u.x)), o = Math.min(...r.map((u) => u.y)), a = Math.max(...r.map((u) => u.x + u.l)) - s, l = Math.max(...r.map((u) => u.y + u.w)) - o, h = {
        x: s,
        y: o,
        l: a,
        w: l,
        shapes: r
      };
      i.push(h);
    }), this.initGroups(i);
  }
  //init or update the stock
  initStock(t) {
    if (this.resetStock(), this.setAspectRatio(t), !t || !(t != null && t.w) || !(t != null && t.l) || !this.elWidth)
      return !1;
    this.stockType = t.type;
    let e;
    if (typeof t == "object" && (e = [t]), this.device === "desktop" && this.main) {
      this.xAxis = this.axisGroup.append("g").attr("transform", `translate(0, ${this.padding})`).attr("class", "axis stock x").call(Be.axisTop(this.xScale).ticks(5).tickSize(5)).selectAll("text").attr("dy", -5);
      const i = this.requiresStretch(t);
      (!i || i && this.stretched) && (this.yAxis = this.axisGroup.append("g").attr(
        "transform",
        `translate(${this.w - this.padding}, 0)`
      ).attr("class", "axis stock y").call(Be.axisRight(this.yAxisScale).ticks(5).tickSize(5)).selectAll("text").attr("dx", 5));
    }
    this.stockGroup.data(e).attr(
      "transform",
      () => `translate(${this.padding},${this.padding})`
    ), this.stockGroup.append("rect").attr("class", "background stock").style("fill", this.colors.stock).attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr("x", (i) => {
      i.x = 0;
      const r = i.x;
      i.x = 0;
      const s = this.getRectangleCoordinate(i, "x") - this.padding;
      return i.x = r, s;
    }).attr("y", (i) => {
      i.y = 0;
      const r = i.y;
      i.y = 0;
      const s = this.getRectangleCoordinate(i, "y") - this.padding;
      return i.y = r, s;
    }), this.stock = this.stockGroup.append("rect").attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr(
      "x",
      (i) => this.getRectangleCoordinate(i, "x") - this.padding
    ).attr(
      "y",
      (i) => this.getRectangleCoordinate(i, "y") - this.padding
    ).attr("class", "stock-pattern").style("fill", (i) => i != null && i.grain ? `url(#grain-${i.grain.toLowerCase()})` : "url(#stripes)");
  }
  getWidthAttribute(t) {
    return this.xScale(t.l) - this.padding;
  }
  getHeightAttribute(t) {
    return this.yScale(t.w) - this.padding;
  }
  //init or update the shapes
  initShapes(t, e) {
    var i, r, s;
    if (this.resetShapes(), !(!t || !t.length || !this.elWidth)) {
      if (this.numUniqueShapes = e.filter((o) => !o.duplicate).length, this.shapeColorScale.domain([0, this.numUniqueShapes]), (i = this == null ? void 0 : this.vueComponent) != null && i.gs) {
        Xe.call(this.vueComponent, ["shapeColors"], {});
        for (let o = t.length; o--; ) {
          const a = t[o];
          a.parentID && Ve.call(this.vueComponent, ["shapeColors", a.parentID]) || a.parentID && Xe.call(this.vueComponent, ["shapeColors", a.parentID], Sa(this.shapeColorScale(parseInt(a.parentID) - 1)).formatHex());
        }
      }
      if (this.env === "development") {
        let o = 1 / 0, a = -1 / 0;
        for (const u of t) {
          const d = (r = u == null ? void 0 : u.bestScore) == null ? void 0 : r.total;
          if (d !== 0 && d !== null && d !== void 0) {
            o = d, a = d;
            break;
          }
        }
        const l = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p === 0 || p === null || p === void 0 ? u : p < u ? p : u;
        }, o), h = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p == null ? u : p > u ? p : u;
        }, a);
        this.scoreColorScale = Be.scaleSequential([Nn(251, 224, 255), Nn(122, 0, 138)]).domain([l, h]);
      }
      if (!t || !t.length || (this.shapeWrappers = this.shapeGroup.selectAll("g").data(t).join("g").attr("class", "shape-group"), !this.shapeWrappers.size())) return !1;
      if (this.shapes = this.shapeWrappers.append("rect").attr("class", "shape").attr("fill", (o) => this.getShapeColor(o)).attr("stroke-width", () => this.env === "development" ? 3 : 0).attr("width", (o) => this.getWidthAttribute(o)).attr("height", (o) => this.getHeightAttribute(o)), this.main) {
        const o = [];
        t.forEach((a) => {
          if (a != null && a._banding)
            for (const [l, h] of Object.entries(a._banding)) {
              if (!h || ["a", "b", "c", "d"].includes(l)) continue;
              let u = l;
              if (a.rot)
                switch (l) {
                  case "x1":
                    u = "y1";
                    break;
                  case "x2":
                    u = "y2";
                    break;
                  case "y1":
                    u = "x2";
                    break;
                  case "y2":
                    u = "x1";
                    break;
                }
              switch (u) {
                case "x1":
                  o.push({
                    x1: a.x,
                    x2: a.x,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x1"
                  });
                  break;
                case "x2":
                  o.push({
                    x1: a.x + a.l,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x2"
                  });
                  break;
                case "y1":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y,
                    type: "y1"
                  });
                  break;
                case "y2":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y + a.w,
                    y2: a.y + a.w,
                    type: "y2"
                  });
                  break;
              }
            }
        }), this.bandingWrappers = this.bandingGroup.selectAll("g").data(o).join("line").attr("class", "banding").attr(
          "x1",
          (a) => this.xPositionScale(a.x1) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "x2",
          (a) => this.xPositionScale(a.x2) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "y1",
          (a) => this.yPositionScale(a.y1) + this.getBandingAdjustment(a.type, "y")
        ).attr(
          "y2",
          (a) => this.yPositionScale(a.y2) + this.getBandingAdjustment(a.type, "y")
        ).attr("stroke-width", 2).attr("stroke", "white"), this.shapeIDText = this.shapeWrappers.append("text").attr("class", "shape-text id").text((a) => {
          var l, h;
          if (this.env === "development")
            switch (this.debug) {
              case "guillotine": {
                const u = a.guillotineData.myStripDirection, d = a.addedAsGroup;
                let p = "";
                return u === "l" ? p = `→ ${a.parentID}` : u === "w" && (p = `↑ ${a.parentID}`), (h = a == null ? void 0 : a.priotity) != null && h[(l = a == null ? void 0 : a.stock) == null ? void 0 : l.parentID] && (p += "P"), d && (p += "G"), p.length ? p : this.shapeNameText;
              }
              case "groups":
                {
                  const u = a.addedAsGroup;
                  if (u) return u.split(".")[0].toUpperCase();
                }
                break;
              case "positions":
                return a.id;
            }
          return a.parentID ? a.parentID : a.getParentID();
        }).classed("hidden", (a, l, h) => {
          const u = h[l].getBBox();
          return u.width >= this.measurementScale(a.l) || u.height >= this.yScale(a.w) - this.padding;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeNameText = this.shapeWrappers.append("text").attr("class", "shape-text name").text((a) => !(a != null && a.name) || typeof (a == null ? void 0 : a.name) != "string" ? null : a.name.toUpperCase().trim()).call(this.trimNameToFit, this).classed("hidden", (a, l, h) => h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 40).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeLengthText = this.shapeWrappers.append("text").attr("class", "shape-text length").text((a) => this.debug === "guillotine" ? "" : Qt(
          a.l,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          var d;
          return this.app ? this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50 : ((d = a == null ? void 0 : a.stock) == null ? void 0 : d.type) === "linear" ? !1 : h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 30;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeWidthText = this.shapeWrappers.append("text").attr("class", "shape-text width").text((a) => this.debug === "guillotine" ? "" : Qt(
          a.w,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          if (this.app)
            return this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50;
          const u = h[l].getBBox();
          return this.measurementScale(a.l) < 30 || u.height >= this.measurementScale(a.w);
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      }
      (this.main || this.app) && !((s = this == null ? void 0 : this.options) != null && s.disableClick) && (this.shapes.on("mousedown", (o, a) => {
        var l, h, u, d, p;
        if (this.moving) return !1;
        if (this.env === "development") {
          if (console.clear(), a) {
            let f = ["id", "placementOrder", "priority", "addedAsGroup"];
            this.debug === "guillotine" ? f = [
              "id",
              "placementOrder",
              "priority",
              "guillotineData.myPhase",
              "guillotineData.myStripDirection",
              "guillotineData.myStripParent",
              "guillotineData.firstShape",
              "addedAsGroup"
            ] : this.debug === "groups" && (f = [
              "id",
              "addedAsGroup"
            ]), console.table(f.reduce((g, b) => {
              const x = Wg(a, b);
              return g[b] = Array.isArray(x) ? x.join(", ") : x, g;
            }, {}));
          }
          if (this.debug === "guillotine") {
            this.shapeWrappers.selectAll(".highlight-a").classed("highlight-a", !1), this.shapeWrappers.selectAll(".highlight-b").classed("highlight-b", !1), this.shapeWrappers.selectAll(".highlight-c").classed("highlight-c", !1);
            const f = (l = a.guillotineData) == null ? void 0 : l.myStripParent, g = (u = (h = t.find((b) => b.id === f)) == null ? void 0 : h.guillotineData) == null ? void 0 : u.myStripParent;
            f && this.shapeWrappers.filter((y) => y.id === f || y.addedAsGroup === f).select("rect").classed("highlight-a", !0), g && this.shapeWrappers.filter((y) => y.id === g || y.addedAsGroup === f).select("rect").classed("highlight-b", !0);
          }
        }
        if (this.app || this.embed) {
          const f = {
            name: a.name,
            id: a.id,
            x: a.x,
            y: a.y,
            l: a.l,
            w: a.w,
            banding: a != null && a.banding && typeof a.banding == "object" ? a.banding : null,
            rot: a.rot,
            stock: (d = a == null ? void 0 : a.stock) == null ? void 0 : d.id,
            color: (p = this.getShapeColor(a)) == null ? void 0 : p.toString(),
            notes: a == null ? void 0 : a.notes
          }, g = new CustomEvent("partClick", {
            detail: f
          });
          if (this.env === "development" && console.log(f), this.htmlEl.dispatchEvent(g), this.app) return !1;
        }
        if (this.device === "desktop" && (this.resetCutMeasurementAxes(), this.addShapeAxes(a)), this.moveMode) {
          const f = va.call(this.vueComponent, "partsBin");
          f && f.addToPartBin(a);
        } else
          this.findShape(a.id);
      }), !this.app && !this.hasTouch && this.shapes.on(
        "mouseover",
        (o) => {
          this != null && this.moveMode && this.moving || (Be.select(o.target).classed("hover", !0), Be.select(o.target).classed("selected") || Be.select(o.target).style(
            "fill",
            this.colors.partHover.toString()
          ));
        },
        {
          passive: !0
        }
      ).on(
        "mouseout",
        (o, a) => {
          var l;
          Be.select(o.target).classed("hover", !1), Be.select(o.target).classed("selected") || Be.select(o.target).style(
            "fill",
            (l = this.getShapeColor(a)) == null ? void 0 : l.toString()
          );
        },
        {
          passive: !0
        }
      )), this.setShapePosition();
    }
  }
  findShapeElement(t) {
    const e = this.shapeWrappers.filter((i) => i.id === t);
    return e.empty() ? null : e.node();
  }
  findShape(t) {
    const e = this.findShapeElement(t), i = Ve.call(this.vueComponent, ["shapeList"]).find((r) => r.id === t);
    e && this.selectShape(e, i);
  }
  selectShape(t, e) {
    Xe.call(this.vueComponent, ["examineShape"], e), this.shapes.classed("selected", !1), this.shapes.style("fill", (r) => this.getShapeColor(r));
    const i = Be.select(t).select("rect");
    i && (i.classed("selected", !0), i.style("fill", this.colors.partSelected.toString()));
  }
  /**
      * update SHAPE visibility - used for replay
      * @param {Number} number
      */
  updateShapeVisibility(t) {
    var e;
    (e = this == null ? void 0 : this.shapeWrappers) == null || e.style("visibility", (i) => (i == null ? void 0 : i.placementOrder) >= t ? "hidden" : "visible");
  }
  isCutComplete(t, e, i) {
    return t.guillotineData.parentSegmentID === e && i && t.guillotineData.segmentCutOrder < i;
  }
  isCutInsideSegment(t, e) {
    var i;
    return ((i = t.guillotineData) == null ? void 0 : i.parentSegmentID) !== null && !(t != null && t.isTrim) ? t.guillotineData.parentSegmentID === e : !1;
  }
  //update CUT visibility
  updateCutVisibility(t, e = null, i = "") {
    var h, u, d, p, f, g, b, x, y;
    if (e === null || t == null || this != null && this.cuts.empty()) return;
    this.resetShapeAxes(), this.resetCutMeasurementAxes(), Be.select(this.cuts.nodes()[e].parentNode).raise();
    const r = (h = t.guillotineData) == null ? void 0 : h.parentSegmentID, s = this.getHalfBladeWidth(t.stock), o = t.dimension === "l" ? "y" : "x", a = (u = t == null ? void 0 : t.stock) == null ? void 0 : u.trim, l = i === "ptx" ? "ptxOrder" : "order";
    if ((((d = t == null ? void 0 : t.stock) == null ? void 0 : d.cutType) === "guillotine" || ((p = t == null ? void 0 : t.stock) == null ? void 0 : p.cutType) === "beam") && r !== null && typeof r < "u") {
      if (this.cuts.style("visibility", (v) => typeof t.guillotineData[l] == "number" && v.guillotineData[l] <= t.guillotineData[l] || !i && v.guillotineData.parentSegmentID === r ? "visible" : "hidden"), this.cuts.classed("highlight", (v) => t.stock.cutType === "guillotine" && v.isTrim ? v.type === t.type : v.guillotineData[l] === t.guillotineData[l]), this.cuts.classed("ptx-dummy", (v) => v.guillotineData.ptxDummyCut), !i) {
        const v = (f = t == null ? void 0 : t.guillotineData) == null ? void 0 : f.segmentCutOrder;
        if (v == null)
          return;
        this.cuts.classed("completed", (E) => this.isCutComplete(E, r, v)), this.cuts.classed("inside-segment", (E) => this.isCutInsideSegment(E, r));
        let k, C;
        const I = this.getCutSegments(t);
        if (I === !1) return;
        const D = (b = I == null ? void 0 : I.siblings) == null ? void 0 : b[(g = I.main) != null && g.hasBeamTrim ? v - 1 : v];
        D && ((t == null ? void 0 : t.dimension) === "l" ? k = [
          [
            D.y,
            D.y + D.w
          ],
          [
            t.y1 + s,
            (I == null ? void 0 : I.main.y) + (I == null ? void 0 : I.main.w)
          ]
        ] : (t == null ? void 0 : t.dimension) === "w" && (k = [
          [
            D.x,
            D.x + D.l
          ],
          [
            t.x1 + s,
            (I == null ? void 0 : I.main.x) + (I == null ? void 0 : I.main.l)
          ]
        ]), (t == null ? void 0 : t.dimension) === "l" ? C = [(x = t == null ? void 0 : t.distances) == null ? void 0 : x.bottom, t == null ? void 0 : t.distances.top] : (t == null ? void 0 : t.dimension) === "w" && (C = [t == null ? void 0 : t.distances.left, (y = t == null ? void 0 : t.distances) == null ? void 0 : y.right]), this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(k, C, o));
      }
    } else {
      this.cuts.style("visibility", (k, C) => C <= e ? "visible" : "hidden");
      let v;
      if ((t == null ? void 0 : t.dimension) === "l" ? v = [
        [0 + (a.y1 ?? 0), t.y1 - s],
        [
          t.y1 + s,
          t.stock.w - (a != null && a.y2 ? a.y2 : 0)
        ]
      ] : (t == null ? void 0 : t.dimension) === "w" && (v = [
        [0 + (a.x1 ?? 0), t.x1 - s],
        [
          t.x1 + s,
          t.stock.l - (a != null && a.x2 ? a.x2 : 0)
        ]
      ]), v != null && v.length) {
        const k = [
          v[0][1] - v[0][0],
          v[1][1] - v[1][0]
        ];
        this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(v, k, o);
      }
      this.cuts.classed(
        "highlight",
        (k, C) => C === e
      );
    }
    this.cuts.attr("stroke-width", (v, k) => {
      var D;
      let C = Math.ceil(this.measurementScale(this.getBladeWidth(v.stock)));
      const I = (D = t == null ? void 0 : t.guillotineData) == null ? void 0 : D.segmentCutOrder;
      return (this.isCutComplete(v, r, I) || this.isCutInsideSegment(v, r)) && (C += 1), k === e && Math.ceil(this.measurementScale(this.getBladeWidth(v.stock))) < 5 && (C = 5), C;
    });
  }
  //highlight a specific cut (by order or index), segments and related measurements
  showCut(t, e = null, i = "") {
    var h;
    if (e === null) return !1;
    if (this.updateCutVisibility(t, e, i), i === "ptx") {
      this.resetSegments();
      return;
    }
    const r = this.getCutSegments(t);
    if (r === !1) return;
    const { main: s, siblings: o } = r;
    if (!((h = t == null ? void 0 : t.guillotineData) != null && h.parentSegmentID))
      return this.initSegments([s]);
    const a = o == null ? void 0 : o.length;
    let l = [];
    if (a) {
      for (let d = a; d--; )
        o[d] && (o[d].completed = !1);
      if (t.guillotineData.segmentCutOrder === void 0 || t.guillotineData.segmentCutOrder === null)
        return;
      const u = t.guillotineData.segmentCutOrder;
      for (let d = 0; d < a; d++)
        d < u && (o[d].completed = !0);
      l.push(...o), l = l.filter((d) => d);
    }
    l.length && (this.resetSegments(), this.initSegments(l));
  }
  /**
      * toggle the visibility of the shapes
      * @param {Boolean} show
      */
  toggleShapes(t = !1) {
    t ? (this.shapeGroup.attr("display", "block"), this.bandingGroup.attr("display", "block")) : (this.shapeGroup.attr("display", "none"), this.bandingGroup.attr("display", "none"));
  }
  /**
      * add measurements to an axis
      * @param {Array} measurements array of arrays
      * @param {Array} values array of values
      * @param {String} axis x | y
      */
  addCutMeasurementAxes(t, e, i) {
    !i || !(t != null && t.length) || t.forEach((r, s) => {
      const o = r[0], a = r[1];
      if (i === "x") {
        const l = Be.scaleLinear().domain([o, a]).range([
          this.xPositionScale(o),
          this.xPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(0, ${this.h - this.padding + this.axisSpacing})`
        ).attr("class", "axis measurement x").call(Be.axisBottom(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ), this.cutMeasurementXAxes.push(u);
      } else {
        const l = Be.scaleLinear().domain([o, a]).range([
          this.yPositionScale(o),
          this.yPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(${this.padding - this.axisSpacing}, 0)`
        ).attr("class", "axis measurement y").call(Be.axisLeft(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ).attr(
          "dx",
          (d, p, f) => f[p].getBBox().width / 4
        ).attr(
          "transform",
          (d, p, f) => "rotate(90) translate(" + f[p].getBBox().width / 4 + ")"
        ), this.cutMeasurementYAxes.push(u);
      }
    });
  }
  /**
      * add the shape axes
      * @param {Shape} shape
      */
  addShapeAxes(t) {
    var l;
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
    const e = t.x, i = t.x + t.l, r = Be.scaleLinear().domain([e, i]).range([this.xPositionScale(e), this.xPositionScale(i)]), s = t.y, o = t.y + t.w, a = Be.scaleLinear().domain([s, o]).range([this.yPositionScale(s), this.yPositionScale(o)]);
    this.shapeXAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(0, ${this.h - this.padding + this.axisSpacing})`
    ).attr("class", "axis shape x").call(Be.axisBottom(r).tickValues(r.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeXAxis.selectAll("text").attr("dx", (h, u, d) => {
      const p = d[u];
      if (p === null) return;
      const f = p.getBBox();
      return u === 0 ? -f.width / 2 : f.width / 2;
    }), ((l = t == null ? void 0 : t.stock) == null ? void 0 : l.type) !== "linear" && (this.shapeYAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(${this.padding - this.axisSpacing}, 0)`
    ).attr("class", "axis shape y").call(Be.axisLeft(a).tickValues(a.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeYAxis.selectAll("text").attr("x", 0).attr("y", 0).attr(
      "dy",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.height) + 2;
      }
    ).attr(
      "dx",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2;
      }
    ).attr("transform", (h, u, d) => {
      var p, f, g, b, x, y, v, k;
      return this.flipY ? u === 0 ? "rotate(90) translate(-" + ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2 + ")" : "rotate(90) translate(" + ((b = (g = d[u]) == null ? void 0 : g.getBBox()) == null ? void 0 : b.width) / 2 + ")" : u === 0 ? "rotate(90) translate(" + ((y = (x = d[u]) == null ? void 0 : x.getBBox()) == null ? void 0 : y.width) / 2 + ")" : "rotate(90) translate(-" + ((k = (v = d[u]) == null ? void 0 : v.getBBox()) == null ? void 0 : k.width) / 2 + ")";
    }));
  }
  getBandingAdjustment(t, e) {
    switch (t) {
      case "y1":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? 1 : -1;
        break;
      case "y2":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? -1 : 1;
        break;
      case "x1":
        if (e === "x") return this.flipX ? -1 : 1;
        if (e === "y") return 0;
        break;
      case "x2":
        if (e === "x") return this.flipX ? 1 : -1;
        if (e === "y") return 0;
        break;
    }
    return 0;
  }
  getRectangleCoordinate(t, e, i, r) {
    let s;
    if (e === "x") {
      let o;
      switch (i) {
        case "center":
          o = this.xPositionScale(t.x + t.l / 2), r && (o += r);
          break;
        case "right":
          o = this.xPositionScale(t.x + t.l), r && (o -= r);
          break;
        case "left":
        default:
          o = this.xPositionScale(this.flipX ? t.x - t.l : t.x), r && (o -= r);
      }
      s = o;
    } else if (e === "y") {
      let o;
      switch (i) {
        case "center":
          o = this.yPositionScale(t.y + t.w / 2), r && (o += r);
          break;
        case "bottom":
          o = this.yPositionScale(this.flipY ? t.y + t.w : t.y), r && (o += r);
          break;
        case "top":
        default:
          o = this.yPositionScale(this.flipY ? t.y : t.y + t.w), r && (o -= r);
      }
      s = o;
    }
    return s;
  }
  getRotatedSide(t) {
    switch (t) {
      case "x1":
      case "l1":
        return "w1";
      case "x2":
      case "l2":
        return "w2";
      case "y1":
      case "w1":
        return "l2";
      case "y2":
      case "w2":
        return "l1";
    }
  }
  /**
      * update the position of the shapes and the content within
      */
  setShapePosition() {
    if (!this.shapes) return !1;
    this.shapes.attr("x", (t) => this.getRectangleCoordinate(t, "x")).attr("y", (t) => this.getRectangleCoordinate(t, "y")).attr("width", (t) => this.getWidthAttribute(t)).attr("height", (t) => this.getHeightAttribute(t)), this.main && (this.shapeIDText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t) => this.getRectangleCoordinate(t, "y", "center")).attr("dy", 1), this.shapeNameText && this.shapeNameText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "bottom",
      -(i[e].getBBox().height / 2 + 1)
    )), this.shapeLengthText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "top",
      -(i[e].getBBox().height / 2 + 2)
    )), this.shapeWidthText.attr(
      "transform",
      (t, e, i) => `translate(${this.getRectangleCoordinate(
        t,
        "x",
        "left",
        -(i[e].getBBox().height / 2 + 2)
      )},${this.getRectangleCoordinate(t, "y", "center")}) ${this.device === "mobile" ? "rotate(90)" : "rotate(-90)"}`
    ));
  }
  //init or update the cuts
  initCuts(t) {
    if (this.resetCuts(), !t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.cuts = this.cutGroup.selectAll("line").data(t).join("line").attr("class", "cut").attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    }).attr("x1", (e) => this.xPositionScale(e.getVisCoords("x1"))).attr("x2", (e) => this.xPositionScale(e.getVisCoords("x2"))).attr("y1", (e) => this.yPositionScale(e.getVisCoords("y1"))).attr("y2", (e) => this.yPositionScale(e.getVisCoords("y2"))).classed("trim", (e) => e.isTrim);
  }
  //init or update the segments
  initSegments(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetSegments(), this.segments = this.segmentGroup.selectAll("rect").data(t).join("rect").attr("class", "segment").style("opacity", (e) => {
      if ((e == null ? void 0 : e.offcut) === !0) return 0.5;
    }).classed("offcut", (e) => e.offcut).classed("merged", (e) => e.merged).classed("near", (e) => e.shapePosition === "near").classed("far", (e) => e.shapePosition === "far").classed("completed", (e) => e.completed).attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.segmentGroup.selectAll("text").data(t).join("text").attr("class", "segment-text").attr("x", (e) => this.getRectangleCoordinate(e, "x", "center")).attr("y", (e) => this.getRectangleCoordinate(e, "y", "center")).attr("text-anchor", "middle").text((e) => {
      if (this.env !== "development" || e.offcut) return null;
      if (e.cutDirection === "l")
        return this.env === "development" ? `→ ${e.id}` : "→";
      if (e.cutDirection === "w")
        return this.env === "development" ? `↑ ${e.id}` : "↑";
    }).attr("dominant-baseline", "middle"), !this.app && this.env === "development" && this.segments.on("mousedown", function(e, i) {
      const r = structuredClone(i);
      console.log([
        "id",
        "x",
        "y",
        "l",
        "w",
        "cutDirection",
        "cutPreference"
      ].reduce((o, a) => (o[a] = Wg(r, a), o), {}));
    });
  }
  initGroups(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetGroups(), this.groups = this.groupGroup.selectAll("rect").data(t).join("rect").attr("class", "group").attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.groupGroup.attr("display", "block");
  }
  //get relevant segments for a specific cut
  getCutSegments(t) {
    var o, a, l, h;
    const e = (o = t == null ? void 0 : t.guillotineData) == null ? void 0 : o.parentSegmentID, i = ((l = (a = this.vueComponent) == null ? void 0 : a.gs) == null ? void 0 : l.activeSegments) ?? ((h = this.vueComponent) == null ? void 0 : h.activeSegments);
    if (!i.length) return !1;
    let r;
    if (e ? r = i.find((u) => u.id === e) : r = i.find((u) => u.segmentType === "root"), r === void 0) return !1;
    const s = r == null ? void 0 : r.children;
    if (s != null && s.length) {
      const u = s.map((p) => {
        const f = i.find((g) => g.x === p.x && g.y === p.y && g.l === p.l && g.w === p.w);
        return f !== void 0 ? f : null;
      }).filter((p) => p !== null);
      return {
        main: r,
        siblings: u
      };
    }
    return !1;
  }
  /**
      * toggle the visibility of the segments
      * @param {Boolean} show
      */
  toggleSegments(t = !0) {
    t ? this.segmentGroup.attr("display", "block") : this.segmentGroup.attr("display", "none");
  }
  /**
      * show a list of possible movement positions
      */
  initPositions(t, e) {
    if (!e || !t || !this.main) return !1;
    let i;
    if (e.trimDimensions(), !t.willItFit(e, t.rot)) return !1;
    e.removeTrim();
    const r = Ve.call(this.vueComponent, ["shapeList"]).filter((l) => {
      var h;
      return l.added && ((h = l == null ? void 0 : l.stock) == null ? void 0 : h.id) === e.id;
    }), s = By(
      null,
      r,
      e
    );
    let o;
    if (e.cutType === "efficiency") {
      if (this.env === "development") {
        const l = Y0(r, e);
        this.positionGroup.selectAll("line").remove();
        const h = l.flatMap((u) => Object.values(u.rays));
        this.positionGroup.selectAll("line").data(h).enter().append("line").attr("x1", (u) => this.xPositionScale(u.x1)).attr("x2", (u) => this.xPositionScale(u.x2)).attr("y1", (u) => this.yPositionScale(u.y1)).attr("y2", (u) => this.yPositionScale(u.y2)).attr("stroke", "rgba(245, 66, 227, 0.5)").attr("stroke-width", 2).on("mousedown", (u, d) => console.log(d));
      }
      o = jy(
        e,
        r
      );
    }
    const a = new Eo();
    for (const l of s.toArray()) {
      const h = K0(t, l, e);
      h && a.addPoints(h.toArray());
    }
    if (o) {
      const l = o.toArray();
      for (const h of l) {
        const u = Dy(t, h, e);
        u && a.addPoints(u.toArray());
      }
    }
    e.cutType === "efficiency" ? ([
      new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Hn(
        e.l - t.l - (e.trim.x2 ?? 0),
        0 + (e.trim.y1 ?? 0)
      ),
      new Hn(
        0 + (e.trim.x1 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      ),
      new Hn(
        e.l - t.l - (e.trim.x2 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      )
    ].forEach((l) => a.addPoint(l)), i = a.toArray()) : (a.addPoint(new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0))), i = a.toArray());
    for (let l = i.length; l--; ) {
      const h = i[l];
      t.x = h.x, t.y = h.y;
      for (const u of r)
        if (this.collision(t, u, e)) {
          i.splice(l, 1);
          break;
        }
    }
    return this.positionGroup.selectAll("rect").data(i).join("rect").attr("data-id", (l, h) => h).attr("class", "shape ghost").attr("x", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("y", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y"))).attr("width", this.getWidthAttribute(t)).attr("height", this.getHeightAttribute(t)).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = va.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), this.hasTouch || this.positionGroup.selectAll("rect").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), Be.select(this).classed("hover", !0), Be.select(this).raise();
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), Be.select(this).classed("hover", !1);
      },
      {
        passive: !0
      }
    ), this.dotGroup.selectAll("circle").data(i).join("circle").attr("data-id", (l, h) => h).attr("class", "dot").classed("raycast", (l) => this.env !== "development" ? !1 : l.raycast).attr("cx", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("cy", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y", "bottom"))).attr("r", 8).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = va.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), t.x = 0, t.y = 0, this.hasTouch || this.dotGroup.selectAll("circle").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), Be.select(this).classed("hover", !0);
        const h = Be.select(this).attr("data-id"), u = Be.select(`.ghost[data-id="${h}"]`);
        u.raise(), u.classed("highlight", !0);
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), Be.select(this).classed("hover", !1);
        const h = Be.select(this).attr("data-id");
        Be.select(`.ghost[data-id="${h}"]`).classed(
          "highlight",
          !1
        );
      },
      {
        passive: !0
      }
    ), !!(i != null && i.length);
  }
  /**
      * show a list of placement positions
      */
  initPlacementPositions(t) {
    if (!(this.env !== "development" || this.debug !== "positions")) {
      if (!(t != null && t.length)) return !1;
      this.placementPositionGroup.selectAll("circle").data(t).join("circle").attr("data-id", (e, i) => i).attr("class", "dot").attr("cx", (e) => this.xPositionScale(e.x)).attr("cy", (e) => this.yPositionScale(e.y)).attr("r", 3).on("mousedown", (e) => {
        e.stopPropagation();
      });
    }
  }
  /**
      * toggle the visibility of the cuts
      * @param {Boolean} show
      */
  toggleCuts(t = !0) {
    t ? this.cutGroup.attr("display", "block") : this.cutGroup.attr("display", "none");
  }
  clearSelection() {
    var t;
    this != null && this.shapes && (this.shapes.classed("selected", !1), this.shapes.classed("hover", !1), this.shapes.style("fill", (e) => this.getShapeColor(e))), this != null && this.cuts && (this.cuts.classed("selected", !1), this.cuts.classed("highlight", !1), this.cuts.classed("inside-segment", !1), this.cuts.style("visibility", "visible"), this.cuts.attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    })), (t = this == null ? void 0 : this.shapes) != null && t.length && this.shapes.classed("selected", !1);
  }
  /**
      * add padding
      * this.padding will be 0 when necessary
      * @param {number} value
      */
  addPadding(t) {
    return t + this.padding;
  }
  /**
      * @param {Container} container
      * @returns {number} blade width
      */
  getBladeWidth(t = null) {
    var e, i;
    return jt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.bladeWidth) ? (i = this.saw) == null ? void 0 : i.bladeWidth : jt(t) && t !== null ? t.getBladeWidth() : 0;
  }
  getHalfBladeWidth(t = null) {
    const e = this.getBladeWidth(t);
    return e !== void 0 && e > 0 ? e / 2 : 0;
  }
  resetShapes() {
    this.shapeGroup && this.shapeGroup.selectAll("*").remove(), this.bandingGroup && this.bandingGroup.selectAll("*").remove(), this.resetShapeAxes();
  }
  resetShapeAxes() {
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
  }
  resetStock() {
    this.stockGroup && this.stockGroup.selectAll("*").remove(), this.axisGroup && this.axisGroup.selectAll("*").remove(), this.resetStockAxes();
  }
  resetStockAxes() {
    this.xAxis && this.xAxis.remove(), this.yAxis && this.yAxis.remove();
  }
  resetCuts() {
    this.cutGroup && this.cutGroup.selectAll("*").remove(), this.resetCutMeasurementAxes();
  }
  resetSegments() {
    this.segmentGroup && this.segmentGroup.selectAll("*").remove();
  }
  resetGroups() {
    this.groupGroup && this.groupGroup.selectAll("*").remove();
  }
  resetCutMeasurementAxes() {
    var t, e;
    (t = this.cutMeasurementXAxes) != null && t.length && (this.cutMeasurementXAxes.forEach((i) => i.remove()), this.cutMeasurementXAxes.length = 0), (e = this.cutMeasurementYAxes) != null && e.length && (this.cutMeasurementYAxes.forEach((i) => i.remove()), this.cutMeasurementYAxes.length = 0);
  }
  resetPositions() {
    this.positionGroup && this.positionGroup.selectAll("*").remove(), this.dotGroup && this.dotGroup.selectAll("*").remove();
  }
  resetPlacementPositions() {
    this.placementPositionGroup && this.dotGroup.selectAll("*").remove();
  }
  reset() {
    this.resetPositions(), this.resetPlacementPositions(), this.resetShapes(), this.resetStock(), this.resetCuts(), this.resetSegments();
  }
  /**
      * detect collision - required for move mode
      * @param {object} thisShape
      * @param {object} testShape
      * @param {object} container
      * @returns {boolean} true if collision
      */
  collision(t, e, i) {
    if (t.id === e.id)
      throw new Error("collision comparing to self");
    return (
      // 1 left
      t.x < e.x + e.l + this.getBladeWidth(i) && // 2 right
      t.x + t.l + this.getBladeWidth(i) > e.x && // 3 bottom
      t.y < e.y + e.w + this.getBladeWidth(i) && // 4 top
      t.y + t.w + this.getBladeWidth(i) > e.y
    );
  }
}
function Wg(n, t) {
  return t.split(".").reduce((e, i) => e[i], n);
}
function ZS(n = "issues", t, e, i = null) {
  var s;
  if (!t || !((s = t == null ? void 0 : t[n]) != null && s.length)) return !1;
  if (t[n].map((o) => o.field).flat().includes(e))
    return i ? t[n].map((a) => a.subField).flat().includes(i) : !0;
}
function QS(n) {
  if (!pa(n)) return !1;
  const t = Object.getOwnPropertyDescriptor(n, "value");
  return (t == null ? void 0 : t.configurable) === !1;
}
function Xe(n, t) {
  var l;
  if (!(n != null && n[0]) || !this) return !1;
  const e = (h) => pa(h) ? QS(h) ? "shallowRef" : "ref" : bp(h) ? "reactive" : !E2(h) && typeof h == "object" ? "raw" : "ref";
  let i, r, s;
  if ("gs" in this && typeof ((l = this.gs) == null ? void 0 : l[n[0]]) < "u")
    i = this.gs, r = _o(this.gs, n), s = n[n.length - 1];
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    i = this, r = _o(this, n), s = n[n.length - 1];
  else
    return !1;
  if (pa(r))
    return r.value = t, !0;
  const o = e(r || t);
  let a = t;
  switch (o) {
    case "shallowRef":
      a = co(t);
      break;
    case "raw":
      typeof t == "object" && t !== null && t.constructor !== Object && t.constructor !== Array ? a = gl(t) : Array.isArray(t) ? a = gl(t.map((h) => typeof h == "object" && h !== null && h.constructor !== Object ? h : JSON.parse(JSON.stringify(h)))) : a = typeof t == "object" ? gl(JSON.parse(JSON.stringify(t))) : gl(t);
      break;
    case "ref":
      pa(t) ? a = t : a = Ne(t);
      break;
    case "reactive":
      a = bp(t) ? t : Zr(t);
      break;
  }
  if (n.length > 1) {
    const h = n.slice(0, -1), u = _o(i, h);
    if (pa(u))
      return kg(u.value, s, a), !0;
  }
  return kg(i, n, a), !0;
}
function Ve(n) {
  var e;
  if (!(n != null && n[0]) || !this) return null;
  let t;
  if ("gs" in this && typeof ((e = this == null ? void 0 : this.gs) == null ? void 0 : e[n[0]]) < "u")
    t = _o(this.gs, n);
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    t = _o(this, n);
  else
    return console.warn("getData path not found", n), null;
  return pa(t) || t && typeof t == "object" && "value" in t ? t.value : t;
}
function eA(n) {
  var t;
  if (!(n != null && n[0])) return null;
  if ("optionsStore" in this && typeof ((t = this == null ? void 0 : this.optionsStore) == null ? void 0 : t[n[0]]) < "u")
    return _o(this.optionsStore, n);
  if (typeof (this == null ? void 0 : this[n[0]]) < "u") return _o(this, n);
}
function vc(n) {
  n.queue = 0, n.stockCount = 0, n.shapeCount = 0, n.resultCount = 0, n.complete = !1;
}
function t6(n, t) {
  return n != null && n.length ? n.find((e) => e.id === t) : null;
}
function e6(n, t, e = "") {
  if (!(n != null && n.length) || !t) return [];
  const i = n.filter((r) => {
    var s, o, a;
    if (e) {
      if (e === "ptx") return (((a = r == null ? void 0 : r.stock) == null ? void 0 : a.id) ?? (r == null ? void 0 : r.stockId)) === t.id;
    } else return (((s = r == null ? void 0 : r.stock) == null ? void 0 : s.id) ?? (r == null ? void 0 : r.stockId)) === t.id && !((o = r == null ? void 0 : r.guillotineData) != null && o.ptxDummyCut);
  });
  return i.sort((r, s) => {
    var o, a;
    return ((o = r == null ? void 0 : r.guillotineData) == null ? void 0 : o.order) - ((a = s == null ? void 0 : s.guillotineData) == null ? void 0 : a.order);
  }), i;
}
function n6(n) {
  return n != null && n.length ? n.filter((t) => t.used === !0) : [];
}
function i6(n = !1) {
  let t = Ve.call(this, ["inputStock"]);
  if (!(t != null && t.length)) return [{ message: "No stock input" }];
  const e = Ve.call(this, ["stockList"]);
  e && (e.length = 0);
  const i = [];
  n && (t = [t[0]]);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    !(s != null && s.q) && !s.autoAdd && !n || i.push(...this.createStock(s, r));
  }
  return i;
}
function r6() {
  const n = Ve.call(this, ["vis"]);
  if (!n) return;
  const t = Ve.call(this, ["shapeList"]);
  if (!(t != null && t.length)) return !1;
  n.resetPositions(), n.resetShapes();
  const e = Ve.call(this, ["activeShapes"]);
  n.initShapes(e, t);
  const i = va.call(this, "PartsBin");
  i && i.clear(!1);
}
function s6() {
  const n = Ve.call(this, ["vis"]);
  if (!n) return;
  const t = Ve.call(this, ["stockList"]);
  if (!(t != null && t.length)) return !1;
  const e = Ve.call(this, ["activeStock"]);
  n.initStock(e);
  const i = Ve.call(this, ["activeCuts"]);
  n.initCuts(i);
  const r = Ve.call(this, ["activeSegments"]);
  n.initSegments(r), n.resetPositions(), typeof this.toggleSegments == "function" && this.toggleSegments(!1), this != null && this.cutMode && (this == null || this.showCut(0));
}
function o6() {
  var t;
  const n = ((t = this == null ? void 0 : this.gs) == null ? void 0 : t.vis) ?? (this == null ? void 0 : this.vis);
  n && (n.clearSelection(), n.resetShapeAxes(), n.resetCutMeasurementAxes(), n.resetPositions());
}
function a6(n) {
  Ve.call(this, ["examineShape"]) && (this.examineShape = null), Xe.call(this, ["activeStockId"], n);
}
function Hg() {
  return this != null && this.$parent ? this.$parent : null;
}
function va(n, t = 0) {
  var r;
  let e = this;
  for (let s = 0; s < t; s++) {
    if (!Hg.call(e))
      return null;
    e = Hg.call(e);
  }
  const i = (r = e == null ? void 0 : e.$refs) == null ? void 0 : r[n];
  return i || null;
}
function l6(n = void 0) {
  return this.socket = Vu(n, {
    withCredentials: !0,
    //this is required to send passport user data
    autoConnect: !1
  }), this.socket.on("connect", () => {
    Xe.call(this, ["connected"], !0);
  }), this.socket.on("maintenance", () => {
    Xe.call(this, ["maintenanceMode"], !0), this.socket.disconnect(), this.env === "development" && console.log("SmartCut - maintenance mode flag received from server");
  }), this.socket.on("connect_error", (t) => {
    Xe.call(this, ["connected"], !1), console.warn(`SmartCut - socket connect_error: ${t.message}`), typeof alert < "u" && alert("We are having trouble connecting to the server. Please try again later."), this.socket.close();
  }), this.socket.on("message", (t) => console.log(t)), this.socket.on("user", (t) => {
    Xe.call(this, ["user"], t);
  }), this.socket.on("queued", () => {
    Xe.call(this, ["progress", "queue"], 1);
  }), this.socket.on("jobInProgess", (t) => (alert(`You already have a job in progress, please wait for it to finish

Job ID: ${t}`), !1)), this.socket.on("jobStart", () => Xe.call(this, ["progress", "queue"], 2)), this.socket.on("progress", (t) => {
    const e = t.data;
    if (typeof e.shapeCount < "u" && Xe.call(this, ["progress", "shapeCount"], e.shapeCount), typeof e.stockCount < "u" && Xe.call(this, ["progress", "stockCount"], e.stockCount), !e.stockCount && !e.shapeCount) {
      const i = Ve.call(this, ["progress", "resultCount"]);
      Xe.call(this, ["progress", "resultCount"], i + 1);
    }
  }), this.socket.on("upgrade", () => {
    "showUpgradeModal" in this && typeof this.showUpgradeModal == "function" && this.showUpgradeModal(), Xe.call(this, ["thinking"], !1);
  }), this.socket.on("error", (t) => {
    var i;
    Xe.call(this, ["thinking"], !1);
    const e = Ve.call(this, ["reset"]);
    typeof e == "function" && e(), console.error("SmartCut error:", t), (i = window == null ? void 0 : window.top) == null || i.postMessage(
      {
        type: "scError",
        message: t
      },
      "*"
    ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage(t), typeof this.showModalMessage == "function" && this.showModalMessage({
      heading: "Issue",
      main: t ? `<p>${t}</p>` : "<p>We are having trouble connecting to the server.</p><p>Please try again later and let us know.</p>"
    });
  }), this.socket.on("result", (t) => {
    var l, h, u, d, p, f, g, b, x, y;
    this.socket.disconnect();
    const e = t.result;
    if (Xe.call(this, ["metadata"], e.metadata ?? {}), Xe.call(this, ["unusableShapes"], e.unusableShapes ?? []), Xe.call(this, ["unavailableStock"], e.unavailableStock ?? []), !((l = e.shapeList) != null && l.length) || !((h = e.stockList) != null && h.length)) {
      const v = Ve.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let k = "<p>We did not manage to fit any parts.</p>";
        (u = e == null ? void 0 : e.unusableShapes) != null && u.length ? (k = "<p>No parts were usable.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "Parts unusable",
          main: k,
          buttonText: "Show me",
          buttonCallback: (C) => {
            C.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (k += "<p>Please double check your list.</p>", this.$nextTick(() => {
          this.showModalMessage({
            heading: "Parts unusable",
            main: k
          });
        }));
      }
      return (d = window == null ? void 0 : window.top) == null || d.postMessage(
        {
          type: "scError",
          message: "No parts were added - please double check your list."
        },
        "*"
      ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage("No parts were added - please double check your list."), Xe.call(this, ["thinking"], !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0), !1;
    }
    e.shapeList.find((v) => !v.added) && typeof this.showModalMessage == "function" && this.$nextTick(() => {
      this.showModalMessage({
        heading: "Parts not used",
        main: "<p>We did not use all your parts.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>",
        buttonText: "Show me",
        buttonCallback: (v) => {
          v.showInputPanel(
            "parts",
            "inputs-unusable-parts"
          );
        }
      });
    }), Xe.call(this, ["progress", "complete"], !0), Xe.call(this, ["jobId"], t == null ? void 0 : t.jobId), typeof this.toggleWidget == "function" && (this.toggleWidget("updateStock", !1), this.toggleWidget("options", !1), this.toggleWidget("offcuts", !1), this.toggleWidget("results", !1), this.toggleWidget("cutlist", !1), this.toggleWidget("export", !1), this.toggleWidget("labels", !1));
    let i;
    e != null && e.saw && (i = new zs(
      e == null ? void 0 : e.saw,
      ((p = e == null ? void 0 : e.saw) == null ? void 0 : p.stockType) ?? ((g = (f = e.stockList) == null ? void 0 : f[0]) == null ? void 0 : g.type)
    ), Xe.call(this, ["saw"], i));
    const r = jb({
      saw: i,
      stockList: e.stockList,
      removeScores: !0,
      preventAutoRotation: !0
    });
    Xe.call(this, ["stockList"], r);
    const s = Ve.call(this, ["usedStock"]);
    s.length && Xe.call(this, ["activeStockId"], s[0].id), Xe.call(
      this,
      ["shapeList"],
      qb({
        shapeList: e.shapeList,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.cutList && Xe.call(
      this,
      ["cutList"],
      zb({
        cutList: e.cutList,
        stockList: r
      })
    ), e != null && e.segmentList && Xe.call(
      this,
      ["segmentList"],
      $b({
        segmentList: e.segmentList,
        stockList: r
      })
    ), e != null && e.offcuts && Xe.call(
      this,
      ["offcuts"],
      Wb({
        offcuts: e.offcuts,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.metadata && Xe.call(this, ["metadata"], e.metadata), (b = e == null ? void 0 : e.evolutionVisData) != null && b.length ? Xe.call(this, ["evolutionVisData"], e.evolutionVisData) : typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "evolution", !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "workbench", !0), Xe.call(this, ["thinking"], !1);
    const o = va.call(this, "inputs");
    if (o && (o != null && o.success) && (o.success = !1), Ve.call(this, ["addedShapes"]).length === 0) {
      const v = Ve.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let k = "<p>We could not fit any parts.</p>";
        (x = e == null ? void 0 : e.unusableShapes) != null && x.length ? (k += "<p>Some parts were not usable - click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "No layouts",
          main: k,
          buttonText: "More info",
          buttonCallback: (C) => {
            C.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (k += "<p>Please double check your list.</p>", this.showModalMessage({
          heading: "No layouts",
          main: k
        }));
      }
      (y = window == null ? void 0 : window.top) == null || y.postMessage(
        {
          type: "scError",
          message: "No parts were added."
        },
        "*"
      ), console.warn("No parts were added."), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0);
    }
  }), this.socket;
}
function u6(n) {
  return !n || !Po(n, !0) ? "" : Object.values(n).filter((t) => t).join("|");
}
function $d(n, t, e = "Options") {
  if (!e && `${t}` in n && typeof n[t] == "object") return !0;
  const i = `${t}${e}`;
  return !!(e && i in n && typeof n[i] == "object");
}
function Ud(n) {
  return `${n}Options`;
}
function c6(n, t, e) {
  const i = Ud(t);
  for (const r in n[i]) {
    const s = Object.keys(n[i][r]);
    for (const o of s)
      e.includes(o) || o in n[i][r] && delete n[i][r][o];
    for (const o of e)
      (r === "all" || !(o in n[i][r])) && (n[i][r][o] = "");
  }
}
function h6(n, t, e = !0) {
  if (!$d(n, t, "Options")) return;
  const i = n[t], r = Object.keys(i);
  for (const s of r)
    Mm(n, t, s, e);
  e && Dm(n, t, "all");
}
function Mm(n, t, e, i = !0) {
  i && Dm(n, t, e), e !== "all" && $d(n, t) && (n[t][e] = !1);
}
function Dm(n, t, e) {
  if (!$d(n, t, "Options")) return;
  const r = n[`${t}Options`][e];
  if (typeof r != "object" || r === null) return;
  Object.keys(r).forEach((o) => r[o] = "");
}
function Rm(n, t, e, i, r, s) {
  var u;
  const o = t + "Options";
  if (!((u = n == null ? void 0 : n[o]) != null && u[e]) || !(i in n[o][e])) return;
  Tl(n, t, e, !1), n[o][e][i] = r;
  const a = n[o][e], l = Object.values(a || {}).filter((d) => d);
  if (!Array.isArray(l)) return;
  const h = wc(n, t, e, s);
  Tl(n, t, e, !!Jn(h));
}
function f6(n, t, e, i, r = [], s) {
  const o = t + "Options";
  if (!n[o] || typeof n[o] != "object") return;
  const a = Object.keys(n[o]);
  if (!a.length) return;
  const l = wc(n, t, "all", s), h = n[o][e], u = Object.values(h || {}).filter((d) => d);
  for (const d of a)
    d !== "all" && (r.includes(d) || (Rm(n, t, d, e, i, s), Array.isArray(u) || Tl(n, t, d, !1), Tl(n, t, d, !!Jn(l))));
}
function Tl(n, t, e, i) {
  var o;
  if (e === "all") return;
  const r = Ud(t), s = u6((o = n == null ? void 0 : n[r]) == null ? void 0 : o[e]);
  i ? n[t][e] = s || !0 : n[t][e] = !1;
}
function wc(n, t, e, i) {
  var l;
  const r = t + "Options";
  if (!((l = n == null ? void 0 : n[r]) != null && l[e])) return !1;
  const s = n[r][e], o = Object.values(s || {}).filter((h) => h);
  if (!Array.isArray(o) || !i || typeof i != "function")
    return !1;
  const a = i(t, o);
  return t === "banding" && p1(e) && Jn(a) ? Tb(n, e, a) / 1e3 : a;
}
function nA(n) {
  n != null && n.type && delete n.type, d6.call(this, n);
}
function d6(n) {
  if (!(n != null && n.banding) || typeof n.banding != "object") return;
  const t = Object.keys(n.banding);
  if (!t.length) return;
  const e = ["labels", "pricing"];
  if (!t.every((i) => e.includes(i)))
    console.warn("SmartCut - legacy banding data provided - please update to use { labels: string[], pricing: Record<string, number> }");
  else return;
  n.banding = {
    labels: Object.keys(n.banding),
    pricing: n.bandingPricing
  };
}
function p6(n) {
  if (n != null && n.enable) return;
  n.enable = {};
  const t = {
    showDiagram: { new: "diagram", map: "equal" },
    enableFocus: { new: "focus", map: "equal" },
    enableMachining: { new: "machining", map: "equal" },
    enableCSVImport: { new: "csvImport", map: "equal" },
    showProgressNumber: { new: "progressNumber", map: "equal" },
    disableBanding: { new: "banding", map: "reverse" },
    disableFinish: { new: "finish", map: "reverse" },
    disableOrientation: { new: "orientation", map: "reverse" },
    disableClick: { new: "click", map: "reverse" },
    disablePartName: { new: "partName", map: "reverse" }
  };
  for (const e of Object.keys(t))
    e in n && (n.enable[t[e].new] = t[e].map === "reverse" ? !n[e] : n[e], delete n[e]);
  console.log(n);
}
function Ef(n = 0, t, e = null, i = null, r = null) {
  if (!Cr(e) && !fo || i === "stock") return !1;
  let s, o;
  if (Cr(e) ? s = e.orientationLock : fo(e) ? s = e.direction : i === "shape" && (s = r), n === 0 || fo(e))
    switch (t) {
      case "n":
        o = s === "w" || r === "w";
        break;
      case "l":
      case "y":
        o = s === "w" || r === "w";
        break;
      case "w":
        o = s === "l" || r === "l";
        break;
      default:
        o = r === "w";
    }
  else if (n === 1)
    o = e.w > e.l;
  else if (n === 2)
    switch (t) {
      case "n":
        o = e.w > e.l;
        break;
      case "y":
      case "l":
        o = e.w > e.l;
        break;
      case "w":
        o = e.l >= e.w;
        break;
      default:
        o = !1;
    }
  return o;
}
function Gg(n, t, e = null, i = null, r = null) {
  if (!Cr(e) || i === "shape") return !1;
  let s;
  return n === 0 || n === 1 ? Ef(n, t, e, i, r) ? "cc" : !1 : n === 2 ? t === "w" ? e.l < e.w ? "c" : "cc" : !1 : s;
}
function g6(n) {
  n.banding && (n.banding = xc(n.banding, "cc")), n.trim && (n.trim = xc(n.trim, "cc"));
}
function m6(n, t = 0) {
  return t && (t === 1 || t === 2) && (n.preventAutoRotation = !0, t === 2 && n.l < n.w && g6(n)), n;
}
function xc(n, t = "cc", e = {
  x1: "y1",
  x2: "y2",
  y1: "x1",
  y2: "x2"
}, i = {
  a: "d",
  b: "a",
  c: "b",
  d: "c"
}) {
  const r = {
    x1: null,
    x2: null,
    y1: null,
    y2: null
  };
  if (t === "c") {
    for (const [s, o] of Object.entries(e))
      r[o] = n[s];
    for (const [s, o] of Object.entries(i))
      o in n && (r[o] = n[s]);
  } else if (t === "cc") {
    for (const [s, o] of Object.entries(e))
      r[s] = n[o];
    for (const [s, o] of Object.entries(i))
      o in n && (r[s] = n[o]);
  }
  return console.log(r), r;
}
const y6 = {
  name: "StockNavigation",
  props: {
    stockList: {
      type: Array,
      default: () => []
    },
    primaryColor: {
      type: String,
      default: ""
    },
    secondaryColor: {
      type: String,
      default: ""
    },
    activeStockId: {
      type: String,
      default: null
    }
  },
  emits: ["show-stock"],
  methods: {
    showStock(n) {
      this.$emit("show-stock", n);
    }
  }
}, La = (n, t) => {
  const e = n.__vccOpts || n;
  for (const [i, r] of t)
    e[i] = r;
  return e;
}, b6 = { id: "mini-stock-nav" }, v6 = ["onMousedown"], w6 = { class: "id" };
function x6(n, t, e, i, r, s) {
  return Zt(), ce("div", b6, [
    (Zt(!0), ce(Qn, null, Pr(e.stockList, (o, a) => (Zt(), ce("button", {
      key: a,
      class: pi(["nav-button", { selected: o.id === e.activeStockId }]),
      type: "button",
      style: Bn({
        backgroundColor: o.id === e.activeStockId ? "#" + e.secondaryColor : "#" + e.primaryColor
      }),
      onMousedown: (l) => s.showStock(o.id)
    }, [
      ye("div", w6, hn(a + 1), 1),
      Xg(ye("div", { class: "stack legibility" }, hn(o.stack), 513), [
        [Jg, typeof o.stack == "number" && o.stack > 1]
      ])
    ], 46, v6))), 128))
  ]);
}
const _6 = /* @__PURE__ */ La(y6, [["render", x6]]), S6 = {
  name: "Spinner",
  props: {
    size: {
      type: Number,
      default: 100
    },
    showNumber: {
      type: Boolean,
      default: !0
    },
    number: {
      type: Number,
      default: 0
    },
    complete: {
      type: Boolean,
      default: !1
    }
  }
}, k6 = { id: "spinner" }, A6 = ["width", "height"], N6 = {
  key: 2,
  id: "spinner-number",
  class: "stock-number"
};
function C6(n, t, e, i, r, s) {
  return Zt(), ce("div", k6, [
    e.complete ? ke("", !0) : (Zt(), ce("svg", {
      key: 0,
      class: "loading",
      style: Bn({ width: e.size + "px", height: e.size + "px" }),
      width: e.size,
      height: e.size,
      viewBox: "0 0 300 300"
    }, t[0] || (t[0] = [
      O2('<rect class="square s1" x="0" y="0"></rect><rect class="square s2" x="100" y="0"></rect><rect class="square s3" x="200" y="0"></rect><rect class="square s4" x="0" y="100"></rect><rect class="square s5" x="200" y="100"></rect><rect class="square s6" x="0" y="200"></rect><rect class="square s7" x="100" y="200"></rect>', 7)
    ]), 12, A6)),
    e.complete ? (Zt(), ce("svg", {
      key: 1,
      class: "complete",
      style: Bn({ width: e.size + "px", height: e.size + "px" }),
      viewBox: "0 0 448 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, t[1] || (t[1] = [
      ye("path", { d: "m203.3 331.3c-6.2 6.3-16.4 6.3-22.6 0l-64-64c-6.3-6.2-6.3-16.4 0-22.6 6.2-6.3 16.4-6.3 22.6 0l52.7 52.7 116.7-116.7c6.2-6.3 16.4-6.3 22.6 0 6.3 6.2 6.3 16.4 0 22.6zm-203.3-235.3c0-35.35 28.65-64 64-64h320c35.3 0 64 28.65 64 64v320c0 35.3-28.7 64-64 64h-320c-35.35 0-64-28.7-64-64zm32 0v320c0 17.7 14.33 32 32 32h320c17.7 0 32-14.3 32-32v-320c0-17.67-14.3-32-32-32h-320c-17.67 0-32 14.33-32 32z" }, null, -1)
    ]), 4)) : ke("", !0),
    e.showNumber ? (Zt(), ce("div", N6, hn(e.number), 1)) : ke("", !0)
  ]);
}
const Vg = /* @__PURE__ */ La(S6, [["render", C6]]);
function P6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "decimal" : "text" : n === "float" ? "decimal" : n === "integer" ? "numeric" : "text";
}
function L6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "number" : "text" : n === "checkbox" ? "checkbox" : n === "float" || n === "integer" ? "number" : "text";
}
function I6(n, t = null, e = "decimal") {
  switch (n) {
    case "float":
    case "integer":
    case "string":
      return n;
    case "unitDependent":
      return e === "decimal" ? "float" : "string";
    case "checkbox":
      return t || "boolean";
    case "select":
      return t || "string";
    default:
      return "string";
  }
}
function E6(n) {
  return !!n;
}
function O6(n, t) {
  return t ? t.split(".").reduce((i, r) => i && i[r] !== "undefined" ? i[r] : void 0, n) : null;
}
function T6(n, t, e, i = !0) {
  const r = t.split(".");
  let s = n;
  for (let o = 0; o < r.length - 1; o++)
    s[r[o]] || (s[r[o]] = {}), s = s[r[o]];
  (i || !jt(s[r[r.length - 1]])) && (s[r[r.length - 1]] = e);
}
function F6(n, t, e, i, r = !0) {
  var o;
  if (!n || !e || !i || !((o = n == null ? void 0 : n[t]) != null && o[e])) return;
  const s = n[t][e].find((a) => a.id === i);
  if (s)
    return r ? s.enabled = !0 : s.enabled = !1, !0;
}
function M6(n, t, e) {
  var i;
  return (i = n == null ? void 0 : n[t]) != null && i[e] ? n[t][e].filter((r) => r.enabled === !0).map((r) => r.id) : [];
}
function D6(n, t, e, i, r = []) {
  const s = M6(n, e, i);
  if (!s.length) return [];
  const o = t.filter((l) => s.includes(l.id) || l.custom === !0), a = o.filter((l) => (l == null ? void 0 : l.fieldMap) && !l.fieldMap.startsWith("customData."));
  if (s.length !== a.length) {
    const l = new Set(a.map((u) => u.id)), h = o.map((u) => u.id).filter((u) => !l.has(u)).map((u) => `'${u}'`);
    console.warn(`Inputs - these fields do not have a field definition - ${h.join()}`);
  }
  return r.length && o.sort((l, h) => {
    const u = r.indexOf(l.id), d = r.indexOf(h.id);
    return u === -1 ? 1 : d === -1 ? -1 : u - d;
  }), o;
}
const R6 = ["id"], B6 = {
  key: 0,
  class: "delete",
  viewBox: "0 0 512 512",
  xmlns: "http://www.w3.org/2000/svg"
}, j6 = /* @__PURE__ */ ns({
  __name: "OrientationButton",
  props: {
    id: { default: "" },
    orientationModel: { default: 0 },
    rectangleType: { default: null },
    rectangle: { default: () => null },
    shapeOrientation: { default: "" },
    stockGrain: { default: "n" },
    buttonBackground: { default: "#848484" },
    iconColor: { default: "#FFFFFF" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["updateOrientation"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = Ne(0), s = rn(() => {
      if (!e.rectangle) return ["l", "w"];
      if (fo(e.rectangle)) return ["l", "w"];
      let y = ["", "l", "w"];
      return e.rectangle.multiEdit && (y = [" ", "", "l", "w"]), o.value && (y = y.filter((v) => v !== "w")), y;
    }), o = rn(() => {
      var y, v, k, C;
      return Cr(e.rectangle) || Uu(e.rectangle) ? e.rectangle.isSquare() : e.rectangleType && ((y = e.rectangle) != null && y.l) && ((v = e.rectangle) != null && v.w) ? ((k = e.rectangle) == null ? void 0 : k.l) === ((C = e.rectangle) == null ? void 0 : C.w) : !1;
    }), a = () => {
      if (!Cr(e.rectangle)) return "";
      let y = "";
      switch (e.orientationModel) {
        case 0:
          y = f.value;
          break;
        case 1:
          e.stockGrain === "y" || e.stockGrain === "n" ? y = e.rectangle.l >= e.rectangle.w ? "l" : "w" : e.rectangle.l >= e.rectangle.w ? y = e.stockGrain : y = y = e.stockGrain === "l" ? "w" : "l";
          break;
        case 2:
          y = e.rectangle.l >= e.rectangle.w ? "l" : "w";
          break;
      }
      return console.log("calculatedOrientationLock", y), y;
    }, l = (y) => s.value.findIndex((k) => k === y), h = () => {
      if (e.disabled || s.value.length <= 1) return;
      let y = null;
      if ([1, 2].includes(e.orientationModel))
        if (f.value === "") {
          const v = a();
          y = s.value.findIndex((k) => k === v);
        } else
          y = s.value.findIndex((v) => v === "");
      else e.orientationModel === 0 && (y = l(f.value) + 1, y > s.value.length - 1 && (y = 0));
      r.value = y;
    }, u = (y) => {
      (y.key === "Enter" || y.key === " ") && h();
    }, d = (y) => {
      i("updateOrientation", y);
    }, p = () => {
      const y = f.value;
      switch (e.orientationModel) {
        case 0:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        case 1:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        case 2:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        default:
          return "default";
      }
    }, f = rn(() => {
      let y = "";
      return fo(e.rectangle) ? y = e.rectangle.direction : Cr(e.rectangle) ? y = e.rectangle.orientationLock : Uu(e.rectangle) && (y = e.rectangle.grain), y;
    }), g = rn(() => fo(e.rectangle) || !e.rectangle ? {
      l: null,
      w: null
    } : {
      l: e.rectangle.l,
      w: e.rectangle.w
    }), b = rn(() => Ef(
      e.orientationModel,
      e.stockGrain,
      e.rectangle,
      e.rectangleType,
      e.shapeOrientation
    )), x = rn(() => {
      var C;
      if (!e.rectangle)
        return e.shapeOrientation ? "noGrain" : "freeRotation";
      if (Uu(e.rectangle) || e.rectangleType === "stock")
        return {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom"
        }[e.rectangle.grain] || "noGrain";
      const y = {
        n: { " ": "delete", l: "leftRight", w: "leftRight", default: "freeRotation" },
        y: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        l: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        w: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        default: { " ": "delete", l: "leftRight", w: "topBottom", default: "freeRotation" }
      }, v = e.stockGrain || "default";
      let k = "default";
      return Cr(e.rectangle) || e.rectangleType === "shape" ? k = p() : fo(e.rectangle) && (k = e.rectangle.direction || "default"), ((C = y[v]) == null ? void 0 : C[k]) || y[v].default;
    });
    return cr(r, (y) => {
      d(s.value[y]);
    }, { immediate: !1 }), cr(g, () => {
      if (!e.rectangle || e.orientationModel === 0 || !Cr(e.rectangle)) return;
      const y = a();
      f.value && f.value !== y && d(y);
    }, { immediate: !1 }), Io(() => {
      document.addEventListener("keydown", u), r.value = l(f.value);
    }), Of(() => {
      document.removeEventListener("keydown", u);
    }), (y, v) => (Zt(), ce("div", {
      id: y.id,
      class: pi(["orientation-button", { rot: b.value, square: o.value, disabled: y.disabled, [x.value]: !0 }]),
      tabindex: "0",
      "aria-label": "Part orientation",
      style: Bn({
        backgroundColor: y.buttonBackground
      }),
      onClick: h
    }, [
      x.value === "delete" ? (Zt(), ce("svg", B6, v[0] || (v[0] = [
        ye("path", { d: "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z" }, null, -1)
      ]))) : ke("", !0),
      x.value === "freeRotation" ? (Zt(), ce("svg", {
        key: 1,
        class: "arrow",
        style: Bn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 67 63",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[1] || (v[1] = [
        ye("g", null, [
          ye("path", { d: "m9.296 31.378c0-3.305.67-6.455 1.88-9.322 3.642-8.621 12.179-14.678 22.12-14.678 10.63 0 19.656 6.927 22.806 16.509" }),
          ye("path", { d: "m57.296 31.378c0 13.246-10.754 24-24 24-10.631 0-19.656-6.926-22.806-16.508" }),
          ye("path", { d: "m61.183 5.408-4.622 17.851-18.347-1.838" }),
          ye("path", { d: "m5.408 57.349 4.622-17.851 18.348 1.838" })
        ], -1)
      ]), 4)) : ke("", !0),
      x.value === "leftRight" ? (Zt(), ce("svg", {
        key: 2,
        class: "arrow",
        style: Bn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 72 39",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[2] || (v[2] = [
        ye("g", null, [
          ye("path", { d: "m5.408 19.408h61.095" }),
          ye("g", null, [
            ye("path", { d: "m52.695 5.408 13.808 14-13.808 14" }),
            ye("path", { d: "m17.408 33.408-12-14 12-14" })
          ])
        ], -1)
      ]), 4)) : ke("", !0),
      x.value === "topBottom" ? (Zt(), ce("svg", {
        key: 3,
        class: "arrow",
        style: Bn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 39 72",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[3] || (v[3] = [
        ye("g", null, [
          ye("path", { d: "m19.408 66.503v-61.095" }),
          ye("g", null, [
            ye("path", { d: "m5.408 19.216 14-13.808 14 13.808" }),
            ye("path", { d: "m33.408 54.503-14 12-14-12" })
          ])
        ], -1)
      ]), 4)) : ke("", !0),
      x.value === "grainLeftRight" ? (Zt(), ce("svg", {
        key: 4,
        class: "grain",
        style: Bn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 106 64",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[4] || (v[4] = [
        ye("g", null, [
          ye("path", { d: "m3 3h99.887" }),
          ye("path", { d: "m3.113 32h99.887" }),
          ye("path", { d: "m3.113 61h99.887" })
        ], -1)
      ]), 4)) : ke("", !0),
      x.value === "grainTopBottom" ? (Zt(), ce("svg", {
        key: 5,
        class: "grain",
        style: Bn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 64 106",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[5] || (v[5] = [
        ye("g", null, [
          ye("path", { d: "m61 3v99.887" }),
          ye("path", { d: "m32 3.113v99.887" }),
          ye("path", { d: "m3 3.113v99.887" })
        ], -1)
      ]), 4)) : ke("", !0)
    ], 14, R6));
  }
}), q6 = ["id"], z6 = /* @__PURE__ */ ns({
  __name: "BandingButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    orientationModel: { default: 0 },
    stockGrain: { default: "n" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = Ne({
      x1: !1,
      x2: !1,
      y1: !1,
      y2: !1
    });
    cr(() => e.inputShape.orientationLock, () => {
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 }), cr([
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.banding;
      },
      () => e.orientationModel,
      () => e.stockGrain,
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.orientationLock;
      }
    ], () => {
      var u;
      if (!((u = e.inputShape) != null && u.banding)) return;
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 });
    const s = rn(() => r.value), o = (l) => {
      (l.key === "Enter" || l.key === " ") && a();
    }, a = () => {
      e.disabled || i("clicked");
    };
    return Io(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.addEventListener("keydown", o);
    }), Of(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.removeEventListener("keydown", o);
    }), (l, h) => (Zt(), ce("div", {
      id: l.id,
      class: pi(["banding-button", { open: l.open, disabled: l.disabled }]),
      tabindex: "0",
      onClick: a
    }, [
      ye("div", {
        class: pi(["outer", {
          x1: s.value.x1,
          x2: s.value.x2,
          y1: s.value.y1,
          y2: s.value.y2
        }])
      }, h[0] || (h[0] = [
        ye("div", { class: "inner" }, null, -1)
      ]), 2)
    ], 10, q6));
  }
}), $6 = ["unitDependent", "string", "integer", "float", "checkbox", "select"], U6 = {
  name: "CustomInput",
  props: {
    type: {
      type: String,
      default: "string",
      validator(n) {
        return $6.includes(n);
      }
    },
    value: {
      type: [String, Boolean, Number],
      default: null
    },
    //element id
    id: {
      type: String,
      default: ""
    },
    focus: {
      type: Boolean,
      default: !1
    },
    enableLabel: {
      type: Boolean,
      default: !0
    },
    labelPosition: {
      type: String,
      default: "first",
      validator(n) {
        return ["first", "last"].includes(n);
      }
    },
    //used for select / checkbox
    output: {
      type: String,
      default: "string",
      validator(n) {
        return ["string", "integer", "float", "boolean"].includes(n);
      }
    },
    options: {
      type: Array,
      default: () => []
    },
    selectFirstOptionDisabled: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: !0
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: !1
    },
    default: {
      type: [String, Number, Boolean],
      default: ""
    },
    units: {
      type: String,
      default: "decimal",
      validator(n) {
        return ["decimal", "fraction"].includes(n);
      }
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    custom: {
      type: Boolean,
      default: !1
    },
    multiEdit: {
      type: Boolean,
      default: !1
    },
    allowBlank: {
      type: Boolean,
      default: !1
    },
    text: {
      type: Object,
      default: () => ({
        select: "Select",
        delete: "Delete"
      })
    },
    issue: {
      type: Boolean,
      default: !1
    },
    warning: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update", "default"],
  computed: {
    thisId() {
      return this.custom ? "custom-" + this.id : this.id;
    },
    inputType() {
      return L6(this.type, this.units);
    },
    inputMode() {
      return P6(this.type, this.units);
    },
    outputType() {
      return I6(this.type, this.output, this.units);
    }
  },
  watch: {
    options: {
      handler() {
        this.value && (this.options.find((n) => n.value == this.value) || this.updateValue(""));
      },
      deep: !1,
      immediate: !1
    }
    /* value: {
    	handler( value )
    	{
    		console.log( 'value changed', value )
    	},
    	deep: false,
    	immediate: true
    } */
  },
  created() {
    this.setDefault();
  },
  mounted() {
    const n = va.call(this, "input");
    n && this.focus && this.$nextTick(() => n.focus());
  },
  methods: {
    getType() {
      return this.type === "unitDependent" ? this.units === "fraction" ? "string" : "float" : this.type;
    },
    handleInput(n) {
      let t = n.target.value;
      switch ((t === "" || t === null) && this.allowBlank && this.updateValue(null), this.getType()) {
        case "integer":
          t = t.replace(/[^0-9-]/g, ""), t = parseInt(t);
          break;
        case "float":
          t = t.replace(/[^0-9.-]/g, ""), t = parseFloat(t);
          break;
      }
      if ((this.getType() === "integer" || this.getType() === "float") && isNaN(t))
        return this.updateValue(null);
      typeof this.min == "number" && t < this.min && (t = this.min), typeof this.max == "number" && t > this.max && (t = this.max), this.updateValue(t);
    },
    updateValue(n, t = "update") {
      if (n === null) return this.$emit(t, n);
      if (this.type === "unitDependent" || this.output === "unitDependent") {
        if (this.units === "fraction")
          return n = n.replace(/[^0-9/ ]+/g, "").replace(/\s{2,}/g, " ").trim(), this.$emit(t, n);
        if (this.units === "decimal")
          return this.$emit(t, parseFloat(n));
      }
      switch (this.outputType) {
        case "string":
          return this.$emit(t, n);
        case "integer":
          return this.$emit(t, parseInt(n));
        case "float":
          return this.$emit(t, parseFloat(n));
        case "boolean":
          return this.$emit(t, E6(n));
        default:
          return this.$emit(t, n);
      }
    },
    setDefault() {
      !jt(this.value) && jt(this.default) && this.updateValue(this.default);
    }
  }
}, W6 = ["for"], H6 = ["id", "inputmode", "type", "value", "placeholder", "disabled", "readonly", "min", "max", "aria-label"], G6 = ["id", "disabled", "checked", "aria-label"], V6 = ["id", "value", "disabled", "aria-label"], Y6 = ["disabled", "selected"], K6 = {
  key: 0,
  value: " "
}, X6 = ["hidden", "value"], J6 = ["for"];
function Z6(n, t, e, i, r, s) {
  var o, a, l, h;
  return Zt(), ce(Qn, null, [
    e.label && e.enableLabel && e.labelPosition === "first" ? (Zt(), ce("label", {
      key: 0,
      for: s.thisId
    }, hn(e.label), 9, W6)) : ke("", !0),
    e.type === "string" || e.type === "integer" || e.type === "float" || e.type === "unitDependent" ? (Zt(), ce("input", {
      key: 1,
      id: s.thisId,
      ref: "input",
      inputmode: s.inputMode,
      type: s.inputType,
      value: e.value,
      placeholder: e.placeholder,
      disabled: e.disabled,
      readonly: e.readonly,
      class: pi({ issue: e.issue, warning: e.warning }),
      min: e.min,
      max: e.max,
      "aria-label": e.label,
      onChange: t[0] || (t[0] = (...u) => s.handleInput && s.handleInput(...u))
    }, null, 42, H6)) : ke("", !0),
    e.type === "checkbox" ? (Zt(), ce("input", {
      key: 2,
      id: s.thisId,
      ref: "input",
      type: "checkbox",
      disabled: e.readonly || e.disabled,
      checked: e.value === e.trueValue,
      "aria-label": e.label,
      class: pi({ issue: e.issue, warning: e.warning }),
      onChange: t[1] || (t[1] = (u) => s.updateValue(u.target.checked ? e.trueValue : e.falseValue))
    }, null, 42, G6)) : ke("", !0),
    e.type === "select" ? (Zt(), ce("select", {
      key: 3,
      id: s.thisId,
      ref: "input",
      value: e.value,
      disabled: e.readonly || e.disabled,
      "aria-label": e.label,
      class: pi({ issue: e.issue, warning: e.warning }),
      onChange: t[2] || (t[2] = (u) => s.updateValue(u.target.value))
    }, [
      ye("option", {
        value: "",
        disabled: e.selectFirstOptionDisabled,
        selected: !e.value
      }, hn(((a = (o = e.text) == null ? void 0 : o.select) == null ? void 0 : a.toUpperCase()) ?? "SELECT"), 9, Y6),
      e.multiEdit ? (Zt(), ce("option", K6, hn(((h = (l = e.text) == null ? void 0 : l.delete) == null ? void 0 : h.toUpperCase()) ?? "DELETE"), 1)) : ke("", !0),
      (Zt(!0), ce(Qn, null, Pr(e.options, (u) => {
        var d, p, f;
        return Zt(), ce("option", {
          key: u.value,
          hidden: u.hidden,
          value: u.value
        }, hn(((d = u == null ? void 0 : u.label) == null ? void 0 : d.toUpperCase()) ?? ((f = (p = u == null ? void 0 : u.value) == null ? void 0 : p.toString()) == null ? void 0 : f.toUpperCase())), 9, X6);
      }), 128))
    ], 42, V6)) : ke("", !0),
    e.label && e.enableLabel && e.labelPosition === "last" ? (Zt(), ce("label", {
      key: 4,
      for: e.id
    }, hn(e.label), 9, J6)) : ke("", !0)
  ], 64);
}
const wl = /* @__PURE__ */ La(U6, [["render", Z6]]), Q6 = {
  key: 0,
  class: "inputs"
}, tk = { class: "label" }, ek = { class: "label" }, nk = { class: "label" }, ik = ["onClick"], rk = { class: "price" }, sk = ["aria-label"], Yg = /* @__PURE__ */ ns({
  __name: "ExtrasInputs",
  props: {
    translate: { type: Boolean, default: !0 },
    shape: {},
    shapeIndex: { default: 0 },
    extraType: {},
    extraLabel: {},
    extraKeys: {},
    allOptions: {},
    pricing: { default: () => ({}) },
    labels: {},
    userFriendlyFieldMap: {},
    partColumns: {},
    orientationModel: { default: 0 },
    getPrice: {},
    formatPrice: {},
    getAvailablePricingOptions: {}
  },
  emits: ["update-all", "set"],
  setup(n, { emit: t }) {
    const e = n, i = t, { t: r } = Zg({
      inheritLocale: !0,
      useScope: "global"
    }), s = Ne(!1), o = rn(() => e.extraType + "Options"), a = rn(() => {
      var x;
      if (!((x = e.allOptions) != null && x.length)) return "auto";
      const g = e.allOptions.length;
      return g ? `repeat(${g + 3 - 1}, minmax(20px, max-content)) 1fr` : "auto";
    }), l = (g, b) => {
      i("update-all", e.shape, e.extraType, g, b);
    }, h = (g, b, x) => {
      i("set", e.shape, e.extraType, g, b, x);
    }, u = (g, b, x, y, v) => {
      var D;
      if (!g) return [];
      const k = (D = b == null ? void 0 : b[x]) == null ? void 0 : D[y];
      if (!k)
        return console.error(`ExtrasInputs: cannot find pricing options for ${x} > ${y}`), [];
      const C = Object.values(k);
      if (!C.length)
        return console.error(`ExtrasInputs: cannot find pricing options for ${x} > ${y}`), [];
      const I = C.filter((E) => typeof E == "string");
      return e.getAvailablePricingOptions ? e.getAvailablePricingOptions(g, I, v) : (console.error("ExtrasInputs: cannot find pricing function in parent"), []);
    }, d = (g) => {
      if (!e.pricing || !Object.values(e.pricing).length) return "";
      if (!e.getPrice)
        return console.error("ExtrasInputs: cannot find getExtrasPrice or formatPrice in parent"), "";
      const b = e.getPrice(e.shape, e.extraType, g);
      return b ? e.formatPrice(b) : "";
    }, p = () => {
      const g = [];
      e.extraType in e.shape || g.push({ message: `The extra type '${e.extraType}' does not exist in the shape.` }), o.value in e.shape || g.push({ message: `The options key '${o.value}' does not exist in the shape.` }), g.length && (s.value = !0, console.error("pre-flight issues found in ExtrasInputs: " + g.map((b) => b.message).join(" ")));
    }, f = (g) => Zb(g);
    return Io(() => p()), (g, b) => {
      var y, v, k, C, I, D, E, O;
      const x = Fl("font-awesome-icon");
      return s.value ? ke("", !0) : (Zt(), ce("div", {
        key: 0,
        class: pi(["extras group", [g.extraType]]),
        style: Bn({ "grid-column-end": "span " + (g.partColumns + 1) })
      }, [
        g.allOptions.length === 1 && g.allOptions[0].length === 1 ? (Zt(), ce("div", Q6, [
          ye("div", tk, hn(f((v = (y = g.allOptions) == null ? void 0 : y[0]) == null ? void 0 : v[0])), 1),
          (k = g.shape) != null && k[o.value] && "all" in g.shape[o.value] ? (Zt(), Wn(wl, {
            key: 0,
            id: `${g.extraType}-all-${g.shapeIndex}`,
            type: "checkbox",
            label: f(Oe(r)("all")),
            "true-value": (I = (C = g.allOptions) == null ? void 0 : C[0]) == null ? void 0 : I[0],
            "false-value": "",
            value: (E = g.shape[o.value].all) == null ? void 0 : E[(D = g.labels) == null ? void 0 : D[0]],
            onUpdate: b[0] || (b[0] = (M) => {
              var q, P;
              h("all", (q = g.labels) == null ? void 0 : q[0], M), l((P = g.labels) == null ? void 0 : P[0], M);
            })
          }, null, 8, ["id", "label", "true-value", "value"])) : ke("", !0),
          (Zt(!0), ce(Qn, null, Pr(g.extraKeys, (M) => {
            var q, P, A, F, _, J;
            return Zt(), ce(Qn, { key: M }, [
              (q = g.labels) != null && q[0] && ((A = (P = g.shape) == null ? void 0 : P[o.value]) != null && A[M]) && g.labels[0] in g.shape[o.value][M] ? (Zt(), Wn(wl, {
                key: 0,
                id: `${g.extraType}-${M}-${g.shapeIndex}`,
                type: "checkbox",
                label: f(Oe(r)((F = g.userFriendlyFieldMap) == null ? void 0 : F[M])),
                "true-value": (J = (_ = g.allOptions) == null ? void 0 : _[0]) == null ? void 0 : J[0],
                "false-value": "",
                value: g.shape[o.value][M][g.labels[0]],
                onUpdate: (V) => h(M, g.labels[0], V)
              }, null, 8, ["id", "label", "true-value", "value", "onUpdate"])) : ke("", !0)
            ], 64);
          }), 128))
        ])) : (Zt(), ce("div", {
          key: 1,
          class: "grid inputs",
          style: Bn({
            "grid-template-columns": a.value
          })
        }, [
          (O = g.shape) != null && O[o.value] && "all" in g.shape[o.value] ? (Zt(), ce(Qn, { key: 0 }, [
            ye("div", ek, hn(f(Oe(r)("all"))), 1),
            (Zt(!0), ce(Qn, null, Pr(g.allOptions, (M, q) => {
              var P, A;
              return Zt(), Wn(wl, {
                id: `${g.extraType}-all-${g.labels[q]}-${q}-${g.shapeIndex}`,
                key: `${g.extraType}-all-${g.labels[q]}-${q}-${g.shapeIndex}`,
                type: "select",
                disabled: u(g.pricing, g.shape, o.value, "all", q).length === 0,
                options: u(g.pricing, g.shape, o.value, "all", q).map((F) => ({ value: F, label: F })),
                text: { select: "✘" },
                "select-first-option-disabled": !1,
                value: (A = g.shape[o.value].all) == null ? void 0 : A[(P = g.labels) == null ? void 0 : P[q]],
                onUpdate: (F) => {
                  var _, J;
                  h("all", (_ = g.labels) == null ? void 0 : _[q], F), l((J = g.labels) == null ? void 0 : J[q], F);
                }
              }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
            }), 128)),
            b[2] || (b[2] = ye("div", null, null, -1)),
            b[3] || (b[3] = ye("div", null, null, -1))
          ], 64)) : ke("", !0),
          (Zt(!0), ce(Qn, null, Pr(g.extraKeys, (M) => {
            var q, P;
            return Zt(), ce(Qn, { key: M }, [
              (q = g.shape) != null && q[o.value] && M in g.shape[o.value] ? (Zt(), ce(Qn, { key: 0 }, [
                ye("div", nk, hn(f(Oe(r)((P = g.userFriendlyFieldMap) == null ? void 0 : P[M]))), 1),
                (Zt(!0), ce(Qn, null, Pr(g.allOptions, (A, F) => {
                  var _;
                  return Zt(), Wn(wl, {
                    id: `${g.extraType}-${M}-${g.labels[F]}-${F}-${g.shapeIndex}`,
                    key: `${g.extraType}-${M}-${g.labels[F]}-${F}-${g.shapeIndex}`,
                    type: "select",
                    disabled: u(g.pricing, g.shape, o.value, M, F).length === 0,
                    options: u(g.pricing, g.shape, o.value, M, F).map((J) => ({
                      value: J,
                      label: J
                    })),
                    text: { select: "✘" },
                    "select-first-option-disabled": !1,
                    value: g.shape[o.value][M][(_ = g.labels) == null ? void 0 : _[F]],
                    onUpdate: (J) => {
                      var V;
                      return h(M, (V = g.labels) == null ? void 0 : V[F], J);
                    }
                  }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
                }), 128))
              ], 64)) : ke("", !0),
              ye("div", {
                class: "delete",
                onClick: () => Oe(Mm)(g.shape, g.extraType, M)
              }, [
                Zn(x, { icon: ["fass", "trash"] })
              ], 8, ik),
              ye("div", rk, hn(d(M) || Oe(r)("N/A")), 1)
            ], 64);
          }), 128))
        ], 4)),
        ye("button", {
          type: "button",
          class: "delete icon-left",
          "aria-label": Oe(r)(`delete ${g.extraLabel}`),
          onClick: b[1] || (b[1] = () => Oe(h6)(g.shape, g.extraType, !0))
        }, [
          Zn(x, { icon: ["fass", "trash"] }),
          qu(" " + hn(Oe(r)(`delete ${g.extraLabel}`)), 1)
        ], 8, sk)
      ], 6));
    };
  }
}), ok = ["id", "disabled"], ak = { class: "icon" }, lk = /* @__PURE__ */ ns({
  __name: "FinishButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = () => {
      e.disabled || i("clicked");
    };
    return (s, o) => {
      var l, h, u, d;
      const a = Fl("font-awesome-icon");
      return Zt(), ce("button", {
        id: s.id,
        class: pi(["finish-button", {
          "face-a": (h = (l = s.inputShape) == null ? void 0 : l.finish) == null ? void 0 : h.a,
          "face-b": (d = (u = s.inputShape) == null ? void 0 : u.finish) == null ? void 0 : d.b,
          selected: s.open
        }]),
        type: "button",
        tabindex: "0",
        disabled: s.disabled,
        onClick: r
      }, [
        ye("div", ak, [
          Zn(a, { icon: ["fass", "spray-can"] })
        ]),
        o[0] || (o[0] = ye("div", { class: "indicator" }, null, -1))
      ], 10, ok);
    };
  }
}), uk = ns({
  name: "MachiningButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    },
    id: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["open"],
  computed: {
    hasMachining() {
      return d1(this.inputShape);
    },
    disabledOrReadonly() {
      var n;
      return this.disabled || !!((n = this.inputShape) != null && n.readonly);
    }
  },
  methods: {
    openMachining() {
      this.disabled || this.$emit("open");
    }
  }
}), ck = ["id", "disabled"];
function hk(n, t, e, i, r, s) {
  const o = Fl("font-awesome-icon");
  return Zt(), ce("button", {
    id: n.id,
    class: pi(["machining-button", { "has-machining": n.hasMachining }]),
    type: "button",
    disabled: n.disabled,
    onClick: t[0] || (t[0] = (...a) => n.openMachining && n.openMachining(...a))
  }, [
    Zn(o, { icon: ["fass", "hammer"] })
  ], 10, ck);
}
const fk = /* @__PURE__ */ La(uk, [["render", hk]]), dk = { id: "uploader" }, pk = {
  key: 0,
  class: "debug"
}, gk = {
  key: 1,
  class: "selected-files"
}, mk = ["src"], yk = ["onClick"], bk = /* @__PURE__ */ ns({
  __name: "ImageUpload",
  props: {
    shapeId: {
      type: String,
      required: !0
    },
    prefix: {
      type: String,
      required: !0
    },
    uniqueId: {
      type: String,
      required: !0
    },
    env: {
      type: String,
      required: !1,
      default: "production"
    },
    maxImages: {
      type: Number,
      required: !1,
      default: 5
    },
    images: {
      type: Array,
      required: !0
    }
  },
  emits: ["update", "remove"],
  setup(n, { emit: t }) {
    const e = mo(() => import("./ObjectViewer-DL0r1Qhs.js")), i = Ne(null), r = Ne(!0), s = Ne({
      shapeId: "",
      files: [],
      previewUrls: [],
      metadata: []
    }), o = n, a = t, l = (g) => ["image/jpeg", "image/jpg", "image/png"].includes(g.type), h = () => {
      var g;
      (g = i.value) == null || g.click();
    }, u = (g) => {
      const b = g.target, x = b.files;
      if (!x) return;
      const y = Array.from(x), v = y.filter((M) => !l(M));
      if (v.length > 0) {
        const M = v.map((q) => q.name).join(", ");
        alert(`Invalid file type(s): ${M}
Only JPG and PNG files are allowed.`), b.value = "";
        return;
      }
      const k = s.value.files || [];
      if (k.length + y.length > o.maxImages) {
        alert(`Maximum ${o.maxImages} images allowed per shape.`), b.value = "";
        return;
      }
      const I = [...k, ...y], D = d(I), E = I.map((M, q) => ({
        originalName: M.name,
        newName: `${o.prefix}-${q + 1}-${o.uniqueId}${p(M.name)}`
      })), O = {
        shapeId: o.shapeId,
        files: I,
        previewUrls: D,
        metadata: E
      };
      s.value = O, a("update", O), b.value = "";
    }, d = (g) => g.map((b) => URL.createObjectURL(b)), p = (g) => g.substring(g.lastIndexOf(".")), f = (g) => {
      URL.revokeObjectURL(s.value.previewUrls[g]);
      const b = [...s.value.files], x = [...s.value.previewUrls], y = [...s.value.metadata];
      if (b.splice(g, 1), x.splice(g, 1), y.splice(g, 1), b.length === 0)
        s.value = {
          shapeId: o.shapeId,
          files: [],
          previewUrls: [],
          metadata: []
        }, a("remove", o.shapeId);
      else {
        const v = {
          shapeId: o.shapeId,
          files: b,
          previewUrls: x,
          metadata: y
        };
        s.value = v, a("update", v);
      }
    };
    return T2(() => {
      var g;
      (g = s.value) != null && g.previewUrls && s.value.previewUrls.forEach((b) => URL.revokeObjectURL(b));
    }), Io(() => {
      s.value.shapeId = o.shapeId;
      const g = o.images.find((b) => b.shapeId === o.shapeId);
      if (g) {
        const b = d(g.files);
        s.value = {
          ...g,
          previewUrls: b
        };
      }
    }), (g, b) => {
      var y;
      const x = Fl("font-awesome-icon");
      return Zt(), ce("div", dk, [
        n.env === "development" && r.value ? (Zt(), ce("div", pk, [
          Zn(Oe(e), {
            data: [s.value],
            paths: ["imageData"]
          }, null, 8, ["data"])
        ])) : ke("", !0),
        ye("input", {
          ref_key: "fileInput",
          ref: i,
          type: "file",
          accept: ".jpg,.jpeg,.png",
          class: "hidden",
          multiple: "",
          onChange: u
        }, null, 544),
        ye("button", {
          type: "button",
          class: "upload-button",
          onClick: h
        }, [
          Zn(x, { icon: ["fass", "files"] })
        ]),
        (y = s.value.files) != null && y.length ? (Zt(), ce("div", gk, [
          (Zt(!0), ce(Qn, null, Pr(s.value.files, (v, k) => (Zt(), ce("div", {
            key: k,
            class: "selected-file"
          }, [
            ye("img", {
              src: s.value.previewUrls[k],
              alt: "Preview"
            }, null, 8, mk),
            ye("button", {
              class: "remove-file",
              type: "button",
              onClick: (C) => f(k)
            }, [
              Zn(x, { icon: ["fass", "trash"] })
            ], 8, yk)
          ]))), 128))
        ])) : ke("", !0)
      ]);
    };
  }
}), vk = /* @__PURE__ */ La(bk, [["__scopeId", "data-v-b59be53a"]]), wk = {
  key: 0,
  class: "debug"
}, xk = { key: 2 }, _k = {
  key: 0,
  class: "row table-heading"
}, Sk = {
  key: 0,
  class: "cell center"
}, kk = {
  key: 1,
  class: "cell delete"
}, Ak = { class: "cell" }, Nk = ["id", "disabled", "onClick"], Ck = {
  key: 0,
  class: "cell center"
}, Pk = ["onClick"], Lk = {
  key: 1,
  class: "cell"
}, Ik = ["disabled", "aria-label", "onClick"], Ek = { class: "button-wrapper main" }, Ok = ["aria-label"], Tk = ["aria-label", "disabled"], Fk = ["aria-label"], Mk = { id: "part-count" }, Dk = {
  key: 3,
  id: "messages"
}, Rk = {
  key: 0,
  class: "heading"
}, Bk = { class: "content" }, jk = {
  key: 4,
  id: "progress"
}, qk = {
  id: "diagram",
  class: "diagram production"
}, zk = {
  key: 0,
  id: "stack"
}, $k = !0, Bm = /* @__PURE__ */ ns({
  __name: "CheckoutCalculator",
  props: {
    debug: {
      type: Boolean,
      default: !1
    },
    units: {
      type: String,
      default: "decimal"
    },
    stock: {
      type: Array,
      default: () => []
    },
    findExtrasPrice: {
      type: Function,
      required: !0
    },
    formatPrice: {
      type: Function,
      required: !0
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["inputs-changed", "calculating", "result", "log", "error"],
  setup(n, { expose: t, emit: e }) {
    const i = mo(() => import("./Machining-CegiEWfo.js")), r = mo(() => import("./ImportCSV-C86oLQ1R.js")), s = mo(() => import("./ObjectViewer-DL0r1Qhs.js")), o = n, a = e, { t: l, locale: h } = Zg({
      locale: "en_US",
      useScope: "global"
    }), u = "production", d = window.location.hostname;
    let p = null, f = null;
    const g = Ne(!1), b = Ne(!1), x = Ne(!0), y = fg("Checkout/currentURL", window.location.href), v = Ne(window.innerWidth), k = Aw(), C = Ne([]), I = Ne(!1), D = Ne(!1), E = Ne(!1), O = Ne(!1), M = Ne(0), q = Ne(!1), P = Ne(!1), A = Ne(tv()), F = {
      enable: {
        diagram: !0,
        focus: !0,
        click: !0,
        partName: !0,
        progressNumber: !0,
        orientation: !0,
        banding: !1,
        finish: !1,
        machining: !1,
        csvImport: !1,
        imageUpload: !1
      },
      colors: {
        partA: "#118ab2",
        partB: null,
        partHover: null,
        partSelected: null,
        stock: "#ffd166",
        button: "#118ab2",
        buttonText: "#ffffff",
        text: "#ffffff"
      },
      decimalPlaces: 2,
      stackHeight: 100,
      maxParts: null,
      locale: "en_US",
      orientationModel: 0,
      customFields: [],
      fieldOrder: [],
      units: "decimal",
      minDimension: 0,
      stockSelection: null,
      cutPreference: null,
      bladeWidth: null,
      stockType: null,
      minSpacing: 0,
      stockGrain: null,
      partTrim: 0
    }, _ = Zr(F), J = Ne(null), V = Zr({
      bladeWidth: 1,
      cutPreference: "l",
      cutType: "guillotine",
      stockType: "sheet",
      stackHeight: 0,
      options: {
        stockSelection: "efficiency",
        minSpacing: 0
      }
    }), R = fg(
      "Checkout/inputShapes",
      [],
      {
        serializer: {
          read: (Q) => {
            if (!Q) return [];
            const mt = Q ? JSON.parse(Q) : [];
            return Bb(mt, o.units);
          },
          write: (Q) => JSON.stringify(Q)
        },
        listenToStorageChanges: !1
      }
    ), tt = Ne([]), H = co([]), ct = co([]), it = co([]), N = co([]), z = Ne(null), G = Ne(null), Y = Ne(null), ot = rn(() => ct.value.filter((Q) => Q.added)), xt = rn(() => ct.value.filter((Q) => Q.added && !Q.duplicate)), gt = rn(() => xt.value.filter((Q) => Q.added)), wt = rn(() => H.value.filter((Q) => Q.used && !Q.duplicate)), qt = rn(() => wt.value.filter((Q) => Q.used).map((Q) => (Q.q = wt.value.filter((mt) => mt.parentID === Q.parentID).reduce(
      (mt, dt) => mt + (typeof (dt == null ? void 0 : dt.stack) == "number" && dt.stack > 0 ? dt.stack : 1),
      0
    ), Q))), Rt = rn(() => n6(H.value)), Yt = rn(() => Y.value ? t6(H.value, Y.value) : null), Kt = rn(() => Qb(H.value)), T = rn(() => ct.value.filter((Q) => {
      var mt, dt;
      return Q.added && ((mt = Q == null ? void 0 : Q.stock) == null ? void 0 : mt.id) === ((dt = Yt.value) == null ? void 0 : dt.id);
    })), ht = rn(() => e6(it.value, Yt.value)), $ = rn(() => R.value.reduce((Q, mt) => Q + mt.q, 0)), nt = Ne(!1), X = Ne(""), st = Ne(""), vt = Zr({
      banding: null,
      finish: null,
      info: null,
      imageUpload: null
    }), St = Ne([]), ft = Ne([]), Et = Ne([]), zt = Ne(!1), Tt = Zr({
      units: "decimal",
      faces: { enabled: !0 },
      holes: { enabled: !1 },
      corners: {
        enabled: !1,
        types: []
      },
      banding: { enabled: !1 },
      hingeHoles: { enabled: !1 },
      shelfHoles: { enabled: !1 }
    }), $t = Zr({
      labels: [],
      pricing: {},
      options: {},
      keys: dr
    }), te = Zr({
      labels: [],
      pricing: {},
      options: {},
      keys: ["a", "b"]
    }), oe = Ne({
      queue: 0,
      stockCount: 0,
      shapeCount: 0,
      complete: !1
    });
    let ae = null;
    const xe = Ne(!1), Xt = Ne(!1), Nt = Zr({
      disableClick: !1,
      enableStretch: !0
    }), Ot = co(null), ie = Zr({
      parts: {
        sheet: [
          { id: "material", enabled: !1 },
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "t", enabled: !1 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "banding", enabled: !1 },
          { id: "finish", enabled: !1 },
          { id: "machining", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        linear: [
          { id: "l", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "finish", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        roll: [
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "imageUpload", enabled: !1 }
        ]
      }
    }), Jt = Ne([]), fe = rn(() => {
      var mt;
      return [...[
        {
          id: "material",
          fieldMap: "material",
          label: l("material"),
          w: "minmax(20px, max-content)",
          type: "select",
          output: "string",
          default: (mt = St.value[0]) == null ? void 0 : mt.name,
          options: St.value.map((dt) => ({
            value: dt.name,
            label: dt.name
          }))
        },
        {
          id: "t",
          fieldMap: "t",
          w: "minmax(20px, max-content)",
          type: "select",
          output: o.units === "decimal" ? "float" : "string",
          label: l("thickness")
        },
        {
          id: "l",
          fieldMap: "l",
          type: "unitDependent",
          label: l("length"),
          min: 0
        },
        {
          id: "w",
          fieldMap: "w",
          type: "unitDependent",
          label: l("width"),
          min: 0
        },
        {
          id: "q",
          fieldMap: "q",
          type: "integer",
          default: 1,
          label: l("quantity"),
          min: 0
        },
        {
          id: "name",
          fieldMap: "name",
          type: "string",
          label: l("name")
        },
        {
          id: "orientationLock",
          w: "32px",
          label: l("orientation"),
          fieldMap: "orientationLock"
        },
        {
          id: "banding",
          w: "32px",
          label: l("banding"),
          fieldMap: "bandingOptions"
        },
        {
          id: "finish",
          type: "checkbox",
          w: "32px",
          label: l("finish"),
          fieldMap: "finish"
        },
        {
          id: "machining",
          w: "32px",
          label: l("machining"),
          fieldMap: "machining"
        },
        {
          id: "imageUpload",
          w: "32px",
          label: l("image upload"),
          fieldMap: "imageUpload"
        }
      ], ...Jt.value];
    }), ne = rn(() => D6(
      ie,
      fe.value,
      "parts",
      V.stockType,
      _.fieldOrder
    )), de = rn(() => {
      let Q = ne.value.length;
      return R.value.length > 1 && Q++, Q;
    }), Ue = rn(() => {
      const Q = {
        id: "34px",
        del: "30px",
        info: "30px"
      }, mt = [];
      for (const dt of ne.value)
        dt.id !== "trim" && mt.push(dt.w ?? "minmax(20px, 1fr)");
      return mt.unshift(Q.id), R.value.length > 1 && mt.push(Q.del), mt.join(" ");
    }), Te = rn(() => ({
      fontSize: "11px",
      textAlign: "right",
      width: "100%",
      height: "auto",
      position: "relative",
      display: "flex",
      visibility: "visible",
      opacity: "1",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingRight: "10px",
      marginTop: "10px",
      marginBottom: "2px",
      userSelect: "none",
      alignItems: "center"
    })), Sn = rn(() => ({
      width: "auto",
      height: "auto",
      display: "inline-block",
      position: "relative",
      visibility: "visible",
      opacity: "1",
      color: "#4e4e4e"
    })), Mn = (Q, mt) => {
      let dt;
      return function(...Ft) {
        const me = () => {
          clearTimeout(dt), Q(...Ft);
        };
        clearTimeout(dt), dt = setTimeout(me, mt);
      };
    }, Ze = (Q, mt) => O6(Q, mt), Ce = (Q, mt, dt, Bt = !0) => {
      T6(Q, mt, dt, Bt);
    }, qe = {
      stockType: (Q) => {
        const mt = ["sheet", "linear", "roll"];
        mt.includes(Q) || console.warn(`${Q} is not a valid stockType, expected ${mt.join("|")}`), V.stockType = Q, Q === "linear" && (V.cutType = null, V.cutPreference = null);
      },
      stockSelection: (Q) => {
        const mt = ["efficiency", "smallest"];
        Q && !mt.includes(Q) ? console.warn(`${Q} is not a valid stockSelection, expected ${mt.join("|")}`) : V.options.stockSelection = Q;
      },
      minSpacing: (Q) => {
        V.options.minSpacing = Q;
      },
      stackHeight: (Q) => {
        V.stackHeight = Q;
      },
      cutPreference: (Q) => {
        const mt = ["efficiency", "length", "width", "beam"];
        if (mt.includes(Q)) {
          const { cutType: dt, cutPreference: Bt } = nf(Q);
          V.cutType = dt, V.cutPreference = Bt;
        } else
          console.warn(`SmartCut - ${Q} is not one of ${mt.join("|")}`);
      },
      bladeWidth: (Q) => {
        Q >= 0 ? V.bladeWidth = Q : console.warn(`SmartCut - you provided an incorrect blade width of: ${Q}`);
      },
      maxParts: (Q) => {
        _.maxParts = Q;
      },
      locale: (Q) => {
        h.value = Q;
      },
      enable: (Q) => {
        const mt = {
          banding: "banding",
          name: "partName",
          finish: "finish",
          orientationLock: "orientation",
          machining: "machining",
          imageUpload: "imageUpload"
        };
        for (const dt in F.enable)
          dt in Q && (_.enable[dt] = Q[dt]);
        for (const dt in mt)
          qn(dt, Rn(Q, [mt[dt]]) ?? F.enable[mt[dt]]);
        P.value = Rn(Q, ["csvImport"]) ?? F.enable.csvImport, Nt.disableClick = Rn(Q, ["click"]) ?? !F.enable.click;
      },
      colors: (Q) => {
        for (const mt in F.colors)
          mt in Q && (_.colors[mt] = Q[mt]);
      },
      customFields: (Q) => {
        if (!Array.isArray(Q) || !(Q != null && Q.length)) return;
        const mt = [];
        Q.forEach((dt, Bt) => {
          mt.push(dt), mt[Bt].custom = !0;
          const Ft = we(dt.id);
          mt[Bt].id = Ft, mt[Bt].fieldMap = "customData." + Ft, dt.type === "checkbox" && (mt[Bt].w = "32px"), dt.type === "select" && (mt[Bt].output = dt.output ?? "string", mt[Bt].options = dt.options);
        }), Jt.value = mt, R.value.forEach((dt) => {
          dt.customData = Q.reduce((Bt, Ft) => {
            const me = we(Ft.id);
            return Bt[me] = dt.customData[me] || Ft.default || "", Bt;
          }, {});
        });
      }
    }, Qi = (Q) => {
      if (o.debug && a("log", ["checkout init...", Q]), Q != null && Q.options) {
        const mt = Q.options;
        p6(mt), [
          "stockType",
          "cutPreference",
          "bladeWidth"
        ].forEach((Ft) => {
          Ft in mt || a("error", `${Ft} is a required option`);
        });
        const Bt = ["enable", "colors"];
        for (const Ft in mt)
          Bt.includes(Ft) || (_[Ft] = mt[Ft]), Ft in qe && qe[Ft](mt[Ft]);
      }
      Q.colors && "colors" in qe && qe.colors(Q.colors), Ks("banding", Q), Ks("finish", Q), Ai(Q), rs(Q), D.value = !0, Es(() => {
        xe.value || ei(), qi() || alert("The SmartCut credit seems to have been tampered with - this is against our terms of service. Please contact support.");
      }), window.smartcutCheckout = { init: Qi };
    }, yn = (Q) => {
      if (!tt.value.length) return "n";
      const mt = Q.material, dt = Q.t, Bt = tt.value.filter((Ft) => Ft.material === mt && Ft.t === dt);
      return Bt.length ? Vb(Bt) : "n";
    }, Ri = (Q, mt) => {
      Q.orientationLock = mt;
    }, qn = (Q, mt = !1) => {
      F6(ie, "parts", V.stockType, Q, mt);
    }, we = (Q) => Q ? $l(Q).toLowerCase() : null, Ai = (Q) => {
      var mt, dt, Bt, Ft, me;
      if (Rn(_, ["enable", "machining"]) && Q != null && Q.machining) {
        for (const ge in Tt)
          Q.machining[ge] && (Tt[ge] = Q.machining[ge]);
        if (["holes", "hingeHoles"].forEach((ge) => {
          var Fe, Re;
          (Fe = Q == null ? void 0 : Q.machining) != null && Fe[ge] && (Tt[ge].enabled = (Re = Q == null ? void 0 : Q.machining) == null ? void 0 : Re[ge].enabled);
        }), (Bt = (dt = (mt = Q == null ? void 0 : Q.machining) == null ? void 0 : mt.corners) == null ? void 0 : dt.types) != null && Bt.length && (Tt.corners.enabled = !0, Tt.corners.types = Q.machining.corners.types), Q.banding && ((me = (Ft = Q == null ? void 0 : Q.options) == null ? void 0 : Ft.enable) != null && me.banding)) {
          if (!$t) return;
          Tt.banding = {
            enabled: !0
          }, $t.options.length && (Tt.banding.options = $t.options), $t.labels.length && (Tt.banding.labels = $t.labels), Po($t.pricing) && (Tt.banding.pricing = $t.pricing);
        }
      }
    }, Bi = (Q = null) => {
      G.value = Q, Q && Q.l && Q.w ? zt.value = !0 : alert("Please enter dimensions first");
    }, ti = () => {
      zt.value = !1, document.exitFullscreen && document.exitFullscreen();
    }, bn = (Q = []) => {
      if (ft.value = [], Et.value = [], qn("t", !1), !!Q.length) {
        for (const mt of Q)
          if (mt != null && mt.t)
            if (typeof mt.t == "string" && mt.t.includes(",")) {
              const dt = mi(mt.t, !0);
              dt.length === 2 ? (tr(dt), qn("t", !0), mt.t = ft.value[0]) : a("error", "bonded thickness found which does not have 2 options");
            } else ft.value.includes(mt.t) || ft.value.push(mt.t);
        ft.value.length > 1 && qn("t", !0);
      }
    }, vn = (Q) => ci(Q).thicknesses.map((dt) => ({
      label: dt == null ? void 0 : dt.toString(),
      value: dt
    })), ci = (Q) => {
      var Ft;
      if (!Q) return { thicknesses: [], bondedThicknesses: [] };
      if (!((Ft = St.value) != null && Ft.length))
        return {
          thicknesses: ft.value,
          bondedThicknesses: []
        };
      if (!Q.material) return { thicknesses: [], bondedThicknesses: [] };
      const mt = St.value.find((me) => me.name === Q.material);
      if (!mt) return { thicknesses: [], bondedThicknesses: [] };
      const dt = [...mt.thicknesses], Bt = [];
      for (let me = 0; me < dt.length; me++) {
        const ge = dt[me], Fe = mi(ge), Re = [];
        if (Fe.length) {
          for (const pn of Fe)
            dt[me] = Qt(pn), Re.push(me);
          me++;
        }
        Re.length && Bt.push(Re);
      }
      return {
        thicknesses: dt,
        bondedThicknesses: Bt
      };
    }, rs = (Q) => {
      var mt;
      if ((mt = Q == null ? void 0 : Q.stock) != null && mt.some((dt) => dt == null ? void 0 : dt.material)) {
        St.value = [], ft.value = [], Et.value = [];
        const dt = /* @__PURE__ */ new Map();
        Q.stock.forEach((Bt) => {
          var me;
          if (!Bt.material) return;
          const Ft = Bt.material.toUpperCase();
          if (dt.has(Ft) || dt.set(Ft, /* @__PURE__ */ new Set()), Bt.t != null) {
            const ge = Number(Bt.t);
            isNaN(ge) || (me = dt.get(Ft)) == null || me.add(ge);
          }
        }), St.value = Array.from(dt.entries()).map(([Bt, Ft]) => ({
          name: Bt,
          thicknesses: Array.from(Ft).sort((ge, Fe) => ge - Fe)
        })), St.value.length > 1 && qn("material", !0);
      } else
        bn(Q.stock);
    }, tr = (Q, mt = null) => {
      if (!Array.isArray(Q)) {
        a("error", "addBondedThicknesses expects an array");
        return;
      }
      const dt = [];
      for (let Bt = 0; Bt < Q.length; Bt++) {
        let Ft = Q[Bt];
        o.units === "decimal" && (Ft = parseFloat(Ft)), ft.value.push(Ft), mt && mt.thicknesses.push(Ft), dt.push(ft.value.length - 1);
      }
      Et.value.push(dt);
    }, mi = (Q, mt = !1) => {
      if (typeof Q == "string" && Q.includes(",")) {
        const dt = Q.split(",");
        return mt ? dt.map((Bt) => Qt(Bt)) : dt;
      }
      return [];
    }, Ni = () => {
      Xt.value ? ji() : Ci();
    }, Ci = () => {
      document.getElementById("smartcut-checkout").requestFullscreen(), Xt.value = !0;
    }, ji = () => {
      document.exitFullscreen && document.exitFullscreen(), Xt.value = !1;
    };
    p = Mn(() => {
      v.value = window.innerWidth;
    }, 30);
    const qi = () => {
      var Bt, Ft;
      if ((Ft = (Bt = Ot.value) == null ? void 0 : Bt.api) != null && Ft.whiteLabel) return !0;
      let Q = !0;
      const mt = document.querySelector("#smartcut-app #credit"), dt = document.querySelector("#smartcut-app #credit a");
      return [mt, dt].forEach((me, ge) => {
        if (!me) return Q = !1;
        const Fe = window.getComputedStyle(me);
        if (Fe.display === "none" || Fe.display === "hidden" || Fe.opacity === "0" || Fe.color === "transparent" || Fe.position !== "relative" || ge === 1 && Fe.color !== "#4e4e4e" && Fe.color !== "rgb(78, 78, 78)")
          return Q = !1;
      }), x.value = Q, Q;
    }, br = (Q, mt, dt, Bt, Ft) => {
      Rm(
        Q,
        mt,
        dt,
        Bt,
        Ft,
        o.findExtrasPrice
      );
    }, Dr = (Q, mt, dt, Bt) => {
      f6(
        Q,
        mt,
        dt,
        Bt,
        mt === "banding" ? ql : [],
        o.findExtrasPrice
      );
    }, er = (Q, mt) => {
      const dt = mt === "banding" ? $t == null ? void 0 : $t.labels : te == null ? void 0 : te.labels;
      c6(Q, mt, dt);
      const Bt = Ud(mt);
      if (Q != null && Q[Bt])
        for (const Ft in Q[Bt]) {
          const me = wc(Q, mt, Ft, o.findExtrasPrice);
          Tl(Q, mt, Ft, !!me);
        }
    }, Rr = (Q) => {
      const mt = Object.keys(Q);
      return Math.max(...mt.map((Bt) => Bt.split("|").length));
    }, Br = (Q) => {
      const mt = [], dt = Object.keys(Q), Bt = Rr(Q);
      for (let Ft = Bt; Ft--; ) mt.push(/* @__PURE__ */ new Set());
      for (const Ft of dt)
        Ft.split("|").forEach((ge, Fe) => mt[Fe].add(ge));
      for (let Ft = 0; Ft < Bt; Ft++)
        mt[Ft] = Array.from(mt[Ft]);
      return mt;
    }, jr = (Q, mt = [], dt) => {
      if (!Q) return [];
      if (dt > 0 && !mt[dt - 1]) return [];
      const Bt = /* @__PURE__ */ new Set();
      for (const Ft of Object.keys(Q)) {
        const me = Ft.split("|");
        if (me.length > dt) {
          let ge = !0;
          for (let Fe = 0; Fe < dt; Fe++)
            if (mt[Fe] && me[Fe] !== mt[Fe]) {
              ge = !1;
              break;
            }
          ge && Bt.add(me[dt]);
        }
      }
      return Array.from(Bt);
    }, ss = (Q, mt, dt) => wc(
      Q,
      mt,
      dt,
      o.findExtrasPrice
    ), Fo = (Q = "issues", mt, dt) => ZS(Q, mt, dt), os = (Q) => {
      const mt = C.value.findIndex((dt) => dt.shapeId === Q.shapeId);
      mt !== -1 ? C.value[mt] = Q : C.value.push(Q), window.smartcutImages = C.value;
    }, Mo = (Q) => {
      C.value = C.value.filter((mt) => mt.shapeId !== Q), window.smartcutImages = C.value;
    }, as = (Q = 1) => {
      for (let mt = Q; mt--; ) {
        let dt;
        if (R.value.length > 0) {
          const Bt = R.value[R.value.length - 1];
          dt = vr({
            material: Bt.material,
            t: Bt.t
          });
        } else
          dt = vr();
        R.value.push(dt);
      }
    }, Hs = (Q) => {
      var dt;
      if (o.readonly || R.value.length === 1) return;
      const mt = R.value[Q].listId;
      R.value.splice(Q, 1), ((dt = G.value) == null ? void 0 : dt.listId) === mt && (G.value = null), vc(oe);
    }, Ia = (Q) => {
      const mt = yn(Q);
      return _.orientationModel !== 2 || mt === "n" ? "" : "l";
    }, vr = ({
      l: Q = null,
      w: mt = V.stockType === "linear" ? ((Li) => (Li = tt.value[0]) == null ? void 0 : Li.w)() : null,
      t: dt = ft.value.length ? ft.value[0] : null,
      q: Bt = 1,
      material: Ft = ((zi) => (zi = St.value) == null ? void 0 : zi.length)() === 1 ? St.value[0].name : "",
      name: me = null,
      orientationLock: ge = null,
      bandingOptions: Fe = null,
      finishOptions: Re = null,
      banding: pn = null,
      finish: Pe = null,
      customData: se = null,
      readonly: be = !1
    } = {}) => {
      var zr, ds;
      const qr = {
        id: (R.value.length + 1).toString(),
        units: o.units,
        l: Q,
        w: mt,
        t: dt,
        q: Bt,
        material: Ft,
        name: me,
        orientationLock: ge,
        banding: pn,
        bandingOptions: Fe,
        finish: Pe,
        finishOptions: Re,
        customData: se,
        readonly: be
      };
      qr.orientationLock = Ia(qr), console.log("new shape orientation lock", qr.orientationLock);
      const fs = new vd(qr);
      return (zr = $t == null ? void 0 : $t.labels) != null && zr.length && er(fs, "banding"), (ds = te == null ? void 0 : te.labels) != null && ds.length && er(fs, "finish"), fs;
    }, Ea = ({
      name: Q = "",
      l: mt = null,
      w: dt = null,
      t: Bt = null,
      material: Ft = "",
      q: me = 1,
      trim: ge = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      grain: Fe = "",
      cost: Re = 0,
      allowExactFitShapes: pn = !1,
      notes: Pe = ""
    }) => new m1({
      id: (tt.value.length + 1).toString(),
      name: Q,
      units: o.units,
      l: mt,
      w: dt,
      t: Bt,
      material: Ft,
      q: me,
      autoAdd: !0,
      trim: ge,
      grain: Fe,
      cost: Re,
      allowExactFitShapes: pn,
      notes: Pe
    }), ls = (Q, mt) => {
      const dt = Qt(Q.l), Bt = Qt(Q.w), Ft = Q.t ? Qt(Q.t) : null, me = new zs(V), ge = new ts({
        id: (mt + 1).toString() + ".0",
        name: Q != null && Q.name ? Q.name : `${dt}x${Bt}`,
        l: dt,
        w: Bt,
        t: Ft,
        saw: me,
        material: Q.material,
        grain: Q.grain,
        autoAdd: !0,
        cost: Q == null ? void 0 : Q.cost,
        trim: Q.trim,
        allowExactFitShapes: Q.allowExactFitShapes,
        type: V.stockType,
        notes: Q == null ? void 0 : Q.notes
      });
      return H.value.push(ge), ge.issues;
    }, Oa = () => {
      var mt, dt;
      const Q = [];
      for (let Bt = 0; Bt < R.value.length; Bt++) {
        const Ft = R.value[Bt];
        if (Qt(Ft.l) < Qt(_.minDimension) && Ft.issues.push({
          message: l("Part") + ` ${Bt + 1}: ` + l("Minimum dimension is") + ` ${_.minDimension}`,
          field: ["l"],
          index: Bt
        }), Qt(Ft.w) < Qt(_.minDimension) && Ft.issues.push({
          message: l("Part") + ` ${Bt + 1}: ` + l("Minimum dimension is") + ` ${_.minDimension}`,
          field: ["w"],
          index: Bt
        }), (mt = Ft == null ? void 0 : Ft.issues) != null && mt.length && Q.push(...Ft.issues.map((Fe) => (Fe.message = l("Part") + ` ${Bt + 1}: ${Fe.message}`, Fe))), !Ft.l || !Ft.w || !Ft.q) continue;
        Ft.applyPartTrim(
          _.partTrim,
          V.stockType
        );
        const me = {
          id: (Bt + 1).toString() + ".0",
          l: Qt(Ft == null ? void 0 : Ft.l),
          w: Qt(Ft == null ? void 0 : Ft.w),
          t: Ft != null && Ft.t ? Qt(Ft.t) : null,
          material: Ft != null && Ft.material ? Ft.material : null,
          q: typeof Ft.q != "number" ? parseInt(Ft.q) : Ft.q,
          name: Ft.name,
          orientationLock: Ft.orientationLock,
          banding: Ft.banding,
          finish: Ft.finish,
          machining: Ft.machining,
          customData: Ft.customData,
          trim: Ft.trim,
          units: o.units
        }, ge = new es(m6(me, _.orientationModel));
        ge.trimDimensions(), ct.value.push(ge), (dt = ge == null ? void 0 : ge.issues) != null && dt.length && Q.push(...ge.issues);
      }
      return Gs(), Q;
    }, dn = (Q) => {
      a6.call({ activeStockId: Y }, Q);
    }, Gs = () => {
      ft.value.length && ct.value.forEach((Q) => {
        if (!Q.t) return;
        const mt = ft.value.findIndex(
          (Ft) => Qt(Ft) === Q.t
        ), dt = Et.value.find((Ft) => Ft.includes(mt));
        if (!dt) return;
        const Bt = Math.min(
          ...dt.map((Ft) => ft.value[Ft])
        );
        Q.t > Bt && (Q.q = Q.q * (Q.t / Bt), Q.t = Bt);
      });
    }, Do = () => {
      s6.call({
        vis: ae,
        stockList: H,
        activeStock: Yt,
        activeCuts: ht
      }), r6.call({
        vis: ae,
        shapeList: ct,
        activeShapes: T
      }, xt.value.length);
    }, Vs = () => {
      vc(oe), H.value = [], ct.value = [], it.value = [], M.value = 0;
    }, Ys = () => {
      R.value.length = 0, as(1);
    }, Ta = () => {
      var Bt, Ft, me;
      if (us(), _.maxParts && $.value > _.maxParts) {
        In(l("The maximum number of parts is") + " " + _.maxParts);
        return;
      }
      if (a("calculating"), E.value) return !1;
      E.value = !0, O.value = !1;
      const Q = [];
      let mt = 0;
      for (const ge of R.value)
        Q.push(...ge.validate(
          tt.value,
          mt,
          V.stockType,
          null,
          !1
        )), mt++;
      if (Q.length) {
        console.warn(Q), In({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.map( i => i.message ).slice( 0, 5 )
        }), E.value = !1;
        return;
      }
      if (Vs(), Q.push(...i6.call({
        inputStock: tt,
        stockList: H,
        createStock: ls
      }, !1)), Q.length) {
        In({
          heading: `Stock issue${Q.length > 1 ? "s" : ""}`,
          main: `${Q.length} issue${Q.length > 1 ? "s" : ""} found with stock inputs`,
          list: Q.map((ge) => ge.message)
        }), E.value = !1;
        return;
      }
      if (Q.push(...Oa()), Q.length) {
        In({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.slice( 0, 5 )
        }), E.value = !1;
        return;
      }
      if (J.value = new zs(
        V,
        (V == null ? void 0 : V.stockType) ?? ((Bt = H.value) == null ? void 0 : Bt[0].type)
      ), J.value.issues.length) {
        In({
          heading: `Saw issue${J.value.issues.length > 1 ? "s" : ""}`,
          main: `${J.value.issues.length} issue${J.value.issues.length > 1 ? "s" : ""} found with saw inputs`
          // list: saw.value.issues.slice( 0, 5 )
        }), E.value = !1;
        return;
      }
      if (!((Ft = H.value) != null && Ft.length)) {
        In({
          heading: "No stock",
          main: "No stock items were found",
          list: []
        }), E.value = !1;
        return;
      }
      if (!((me = ct.value) != null && me.length)) {
        In({
          heading: "No parts",
          main: "No parts in list",
          list: []
        }), E.value = !1;
        return;
      }
      o.debug && console.log(
        "SmartCut - calculating",
        "stock",
        H.value.map((ge) => ge.dimensions()),
        "parts",
        ct.value.map((ge) => ge.dimensions())
      ), f.connect();
      const dt = {
        inputs: {
          parts: R.value,
          stock: tt.value,
          saw: J.value
        },
        saw: J.value,
        shapeList: ct.value,
        stockList: H.value,
        enableEvo: q.value,
        domain: d
      };
      f.compress(!0).emit("calculate", dt);
    }, In = (Q = {
      main: null,
      heading: null,
      list: []
    }) => {
      var mt;
      typeof Q == "object" ? (st.value = l(Q == null ? void 0 : Q.main), X.value = l(Q.heading), Q != null && Q.list && Array.isArray(Q.list) && ((mt = Q.list) != null && mt.length) && Q.list.forEach((dt) => {
        dt && (st.value += `

${l(dt)}`);
      })) : st.value = l(Q), nt.value = !0;
    }, us = () => {
      nt.value = !1, st.value = "", X.value = "";
    }, ei = () => {
      const Q = {
        elementID: "#diagram",
        env: u,
        main: !0,
        units: o.units,
        decimalPlaces: _.decimalPlaces,
        saw: V,
        app: !1,
        embed: !0,
        colors: _.colors,
        options: Nt,
        vueComponent: {
          env: u,
          stockList: H,
          shapeList: ct,
          activeStock: Yt,
          activeShapes: T,
          activeCuts: ht
        }
      };
      ae = new JS(Q), ae.initStock(Yt.value), ae.initShapes(T.value, ct.value), ae.initCuts(ht.value), xe.value = !0;
    }, cs = async (Q = !1) => {
      if (!ae) return !1;
      await ae.updateSize(Q), o6.call({ vis: ae });
    }, Ks = (Q, mt) => {
      var Pe;
      if (qn(Q, !1), !Q || !mt || !(mt != null && mt[Q]) || !Rn(_, ["enable", Q])) return;
      const dt = [Q, "pricing"];
      if (!ac(mt, dt)) {
        a("error", `${dt.join(".")} not found in sent data`);
        return;
      }
      const Bt = Rn(mt, dt);
      if (typeof Bt != "object") {
        a("error", `${dt.join(".")} data must be an object`);
        return;
      }
      if (!Po(Bt)) {
        a("error", `if provided, ${dt.join(".")} data must contain some values`);
        return;
      }
      const Ft = Object.keys(Bt), me = Object.values(Bt);
      if (!Ft.length) {
        a("error", `no ${dt.join(".")} pricing found`);
        return;
      }
      const ge = /,/;
      for (const se of Ft)
        if (ge.test(se)) {
          a("error", `${dt} keys must not contain commas and should only be separated by a pipe (|)`);
          return;
        }
      if (me.some((se) => isNaN(se))) {
        a("error", `${dt} values must be a number`);
        return;
      }
      const Fe = Rr(Bt), Re = [Q, "labels"];
      let pn = [];
      if (ac(mt, Re))
        pn = Rn(mt, Re);
      else {
        a("error", `${Re.join(".")} not found`);
        return;
      }
      if (!pn) {
        a("error", `${Re.join(".")} data not provided`);
        return;
      }
      if (!Array.isArray(pn)) {
        a("error", `${Re.join(".")} data must be an array`);
        return;
      }
      if (!(pn != null && pn.length)) {
        a("error", `if provided, ${Re.join(".")} data must contain values`);
        return;
      }
      if (pn.length !== Fe) {
        a("error", `${Re.join(".")} length (${pn.length}) must match the number of levels in ${dt.join(".")} (${Fe})`);
        return;
      }
      switch (Q) {
        case "banding":
          $t.labels = pn, $t.pricing = Bt, $t.options = Br(Bt);
          break;
        case "finish":
          te.labels = pn, te.pricing = Bt, te.options = Br(Bt);
          break;
      }
      if (qn(Q, !0), !!((Pe = R.value) != null && Pe.length))
        for (const se of R.value)
          er(se, Q);
    }, hs = (Q, mt) => {
      if (!mt) return;
      Q !== "info" && Object.keys(vt).forEach((Bt) => {
        Bt !== Q && Bt !== "info" && (vt[Bt] = null);
      });
      const dt = R.value.indexOf(mt);
      vt[Q] === dt ? (G.value = null, vt[Q] = null) : (G.value = mt, vt[Q] = dt);
    }, Xs = (Q) => {
      a("log", ["SmartCut - load event received"]), Fa(Q.detail);
    }, Fa = (Q) => {
      var dt, Bt, Ft;
      if (a("log", ["SmartCut - loading parts..."]), !Q || !((Bt = (dt = Q == null ? void 0 : Q.inputs) == null ? void 0 : dt.parts) != null && Bt.length)) return;
      R.value = [];
      let mt = 0;
      for (const me of Q.inputs.parts) {
        const ge = vr(me);
        ge ? (R.value.push(ge), (Ft = ge.issues) != null && Ft.length && a("log", [`SmartCut - issues found while importing part at index ${mt}`, ge.issues])) : a("log", [`SmartCut - error loading part at index ${mt}`, me]), mt++;
      }
      a("log", [`SmartCut - loaded ${R.value.length} parts`]);
    }, Ro = (Q) => {
      R.value.length = 0, Es(() => {
        var mt, dt;
        for (const Bt of Q)
          Bt.t = ((dt = (mt = tt.value) == null ? void 0 : mt[0]) == null ? void 0 : dt.t) ?? null, R.value.push(vr(Bt));
      });
    };
    cr(() => o.stock, (Q) => {
      if (Vs(), Array.isArray(Q) || console.warn("SmartCut - stock must be passed as an array"), !!(Q != null && Q.length)) {
        tt.value = [], St.value.length || bn(Q);
        for (const mt of Q) {
          mt.type = V.stockType;
          const dt = Ea(mt);
          tt.value.push(dt);
        }
        tt.value.length && (R.value.length ? Es(() => {
          R.value.forEach((mt) => {
            if (mt.material) {
              const dt = St.value.find((Bt) => Bt.name === mt.material);
              dt && (dt.thicknesses.includes(Qt(mt.t)) || (mt.t = dt.thicknesses[0]), mt.t == null && (mt.t = dt.thicknesses[0]));
            } else
              mt.t = tt.value[0].t;
          });
        }) : Es(() => as(1)));
      }
    }, { immediate: !0 }), cr(R, (Q) => {
      a("inputs-changed"), Q.forEach((mt) => {
        var Bt;
        V.stockType === "linear" && (mt.w = (Bt = tt.value[0]) == null ? void 0 : Bt.w);
        const dt = St.value.find((Ft) => Ft.name === mt.material);
        dt && (dt.thicknesses.includes(Qt(mt.t)) || (mt.t = dt.thicknesses[0]));
      });
    }, { deep: !0 }), cr(M, (Q) => {
      if (!Q) return;
      xe.value && cs(), z.value || a("error", "SmartCut - no metadata received from server"), Gs();
      const mt = {
        jobId: M.value,
        metadata: z.value,
        parts: gt.value.map((dt) => {
          var Bt, Ft, me;
          return {
            l: dt.l,
            w: dt.w,
            t: dt == null ? void 0 : dt.t,
            material: dt.material,
            orientationLock: dt.orientationLock,
            q: (Ft = (Bt = z.value) == null ? void 0 : Bt.addedPartTally) == null ? void 0 : Ft[dt.parentID],
            name: dt.name,
            banding: dt.banding,
            finish: dt.finish,
            customData: dt.customData,
            stockId: ((me = dt == null ? void 0 : dt.stock) == null ? void 0 : me.id) || (dt == null ? void 0 : dt.stockId)
          };
        }),
        stock: qt.value.map((dt) => {
          var Bt, Ft;
          return {
            id: dt.id,
            name: dt == null ? void 0 : dt.name,
            l: dt.l,
            w: dt.w,
            t: dt == null ? void 0 : dt.t,
            material: dt.material,
            q: (Ft = (Bt = z.value) == null ? void 0 : Bt.usedStockTally) == null ? void 0 : Ft[dt.parentID],
            trim: dt == null ? void 0 : dt.trim,
            cost: dt == null ? void 0 : dt.cost,
            analysis: dt == null ? void 0 : dt.analysis,
            type: dt == null ? void 0 : dt.type
          };
        }),
        offcuts: N.value.map((dt) => ({
          l: dt.l,
          w: dt.w,
          t: (dt == null ? void 0 : dt.t) ?? null,
          q: dt.q,
          stockId: dt.stockId
        })),
        inputs: {
          parts: R.value.map((dt) => {
            const Bt = { ...dt };
            return delete Bt.listId, Bt;
          })
        }
      };
      if (z.value.unplacedParts.length) {
        const dt = z.value.unplacedParts.map((Bt) => Bt.id).join();
        In(l("The following parts did not fit") + ": " + dt);
      }
      a("result", mt);
    }), cr(v, () => {
      xe.value && cs();
    }), cr(Y, () => {
      xe.value && Es(() => Do());
    });
    const Ma = () => {
      f && (f.disconnect(), f = null);
    };
    return Io(() => {
      if (I.value) return;
      const Q = new URL(window.location.href), mt = Q.searchParams.toString(), dt = Q.origin + Q.pathname + (mt ? `?${mt}` : "");
      y.value !== dt && (R.value.length = 0, as(1)), y.value = dt, h.value = _.locale;
      const Bt = {
        socket: null,
        connected: g,
        maintenanceMode: b,
        jobId: M,
        progress: oe,
        thinking: E,
        user: Ot,
        saw: J,
        stockList: H,
        shapeList: ct,
        cutList: it,
        offcuts: N,
        metadata: z,
        usedStock: Rt,
        addedShapes: ot,
        activeStockId: Y
      };
      f = l6.call(Bt, "https://api.cutlistevo.com/"), f.connect(), f.emit("getUserFromDomain"), window.addEventListener("resize", p, { passive: !0 }), window.addEventListener("smartcut/load", Xs), I.value = !0, o.debug && a("log", [
        "SmartCut - ready...",
        "fields:",
        ne.value.map((Ft) => Ft.id)
      ]), typeof window < "u" && (window.smartcutCheckout = { init: Qi });
    }), Of(() => {
      window.removeEventListener("resize", p), window.removeEventListener("smartcut/load", Xs), Ma(), delete window.smartcutCheckout;
    }), t({
      init: Qi,
      getAvailablePricingOptions: jr,
      getExtrasPrice: ss,
      formatPrice: o.formatPrice,
      findExtrasPrice: o.findExtrasPrice,
      inputShapes: R,
      initExtrasOptions: er,
      createShapeInput: vr
    }), (Q, mt) => {
      var Bt, Ft, me, ge, Fe, Re, pn;
      const dt = Fl("font-awesome-icon");
      return Zt(), ce(Qn, null, [
        Oe(u) === "development" && $k ? (Zt(), ce("div", wk, [
          mt[5] || (mt[5] = ye("div", null, "Developer information", -1)),
          Zn(Oe(s), {
            data: [_.enable],
            paths: ["options.enable"]
          }, null, 8, ["data"])
        ])) : ke("", !0),
        zt.value && ((Bt = G.value) != null && Bt.machining) ? (Zt(), Wn(Oe(i), {
          key: 1,
          shape: G.value,
          "onUpdate:shape": mt[0] || (mt[0] = (Pe) => G.value = Pe),
          translate: !0,
          options: Tt,
          env: Oe(u),
          "find-extras-price": n.findExtrasPrice,
          "get-extras-price": ss,
          "get-available-pricing-options": jr,
          "format-price": n.formatPrice,
          onClose: ti
        }, null, 8, ["shape", "options", "env", "find-extras-price", "format-price"])) : ke("", !0),
        D.value ? ke("", !0) : (Zt(), ce("div", xk, [
          Zn(Vg, {
            size: 50,
            "show-number": !1
          })
        ])),
        D.value ? (Zt(), ce("div", {
          key: 3,
          id: "smartcut-checkout",
          class: pi({ fullscreen: Xt.value })
        }, [
          A.value && !n.readonly ? (Zt(), ce("div", {
            key: 0,
            id: "smartcut-full-screen",
            class: "icon-left",
            onClick: mt[1] || (mt[1] = (Pe) => Ni())
          }, [
            Zn(dt, { icon: ["fasr", "expand"] }),
            qu(" " + hn(Oe(l)("full screen")), 1)
          ])) : ke("", !0),
          (me = (Ft = Ot.value) == null ? void 0 : Ft.api) != null && me.whiteLabel ? ke("", !0) : (Zt(), ce("div", {
            key: 1,
            id: "credit",
            style: Bn(Te.value)
          }, [
            ye("a", {
              title: "SmartCut | Cut list optimization software",
              style: Bn(Sn.value),
              target: "_blank",
              href: "https://smartcut.dev/"
            }, hn(Oe(l)("Powered by SmartCut")), 5)
          ], 4)),
          ye("div", {
            id: "part-input",
            class: "inputs no-margin-top grid-table",
            style: Bn({ "grid-template-columns": Ue.value })
          }, [
            Oe(R).length ? (Zt(), ce("div", _k, [
              mt[6] || (mt[6] = ye("div", { class: "cell id" }, null, -1)),
              (Zt(!0), ce(Qn, null, Pr(ne.value, (Pe) => (Zt(), ce("div", {
                key: Pe.id,
                class: pi(["cell", { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Pe.id) || Pe.type === "checkbox" }])
              }, hn(Pe.label), 3))), 128)),
              Oe(u) === "development" ? (Zt(), ce("div", Sk, " Info ")) : ke("", !0),
              Oe(R).length > 1 ? (Zt(), ce("div", kk)) : ke("", !0)
            ])) : ke("", !0),
            (Zt(!0), ce(Qn, null, Pr(Oe(R), (Pe, se) => (Zt(), ce("div", {
              key: se,
              class: "row inputs"
            }, [
              ye("div", Ak, [
                ye("div", {
                  class: "id",
                  style: Bn({
                    background: _.colors.partA,
                    color: _.colors.text
                  })
                }, hn(se + 1), 5)
              ]),
              (Zt(!0), ce(Qn, null, Pr(ne.value, (be) => (Zt(), ce("div", {
                key: be.fieldMap,
                class: pi(["cell", [`${be.id}`, { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(be.id) || be.type === "checkbox" }]])
              }, [
                ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(be.id) ? be.id === "orientationLock" ? (Zt(), Wn(j6, {
                  key: 1,
                  id: "orientation-" + se,
                  rectangle: Pe,
                  disabled: n.readonly,
                  "stock-grain": yn(Pe),
                  "button-background": _.colors.button,
                  "icon-color": _.colors.buttonText,
                  "orientation-model": _.orientationModel,
                  onUpdateOrientation: (Li) => Ri(Pe, Li)
                }, null, 8, ["id", "rectangle", "disabled", "stock-grain", "button-background", "icon-color", "orientation-model", "onUpdateOrientation"])) : be.id === "banding" ? (Zt(), Wn(z6, {
                  key: 2,
                  id: "banding-" + se,
                  "input-shape": Pe,
                  disabled: n.readonly,
                  "stock-grain": yn(Pe),
                  open: vt.banding === se,
                  "orientation-model": _.orientationModel,
                  onClicked: (Li) => hs("banding", Pe)
                }, null, 8, ["id", "input-shape", "disabled", "stock-grain", "open", "orientation-model", "onClicked"])) : be.id === "finish" ? (Zt(), Wn(lk, {
                  key: 3,
                  id: "finish-" + se,
                  "input-shape": Pe,
                  disabled: n.readonly,
                  open: vt.finish === se,
                  onClicked: (Li) => hs("finish", Pe)
                }, null, 8, ["id", "input-shape", "disabled", "open", "onClicked"])) : be.fieldMap === "machining" && A.value ? (Zt(), Wn(fk, {
                  key: 4,
                  id: "machining-" + se,
                  disabled: n.readonly,
                  "input-shape": Pe,
                  onOpen: (Li) => Bi(Pe)
                }, null, 8, ["id", "disabled", "input-shape", "onOpen"])) : be.fieldMap === "imageUpload" ? (Zt(), ce("button", {
                  key: 5,
                  id: "image-upload-" + se,
                  type: "button",
                  disabled: n.readonly,
                  class: pi({ selected: vt.info === se }),
                  onClick: (Li) => hs("imageUpload", Pe)
                }, [
                  Zn(dt, { icon: ["fass", "image"] })
                ], 10, Nk)) : ke("", !0) : (Zt(), Wn(wl, {
                  key: 0,
                  id: be.id + "-" + se,
                  focus: !n.readonly && _.enable.focus && se === Oe(R).length - 1 && be.id === "l",
                  warning: Fo("warnings", Pe, be.fieldMap),
                  issue: Fo("issues", Pe, be.fieldMap),
                  type: be.type,
                  output: be.output,
                  label: be.label,
                  units: n.units,
                  readonly: n.readonly,
                  placeholder: be == null ? void 0 : be.placeholder,
                  options: be.id === "t" ? vn(Pe) : be == null ? void 0 : be.options,
                  "true-value": be == null ? void 0 : be.trueValue,
                  "false-value": be == null ? void 0 : be.falseValue,
                  default: be == null ? void 0 : be.default,
                  min: typeof (be == null ? void 0 : be.min) == "number" ? be.min : null,
                  max: typeof (be == null ? void 0 : be.max) == "number" ? be.max : null,
                  custom: be == null ? void 0 : be.custom,
                  value: Ze(Pe, be == null ? void 0 : be.fieldMap),
                  text: {
                    delete: Oe(l)("delete"),
                    select: Oe(l)("select")
                  },
                  onUpdate: (Li) => {
                    be.fieldMap && Ce(Pe, be.fieldMap, Li);
                  }
                }, null, 8, ["id", "focus", "warning", "issue", "type", "output", "label", "units", "readonly", "placeholder", "options", "true-value", "false-value", "default", "min", "max", "custom", "value", "text", "onUpdate"]))
              ], 2))), 128)),
              Oe(u) === "development" ? (Zt(), ce("div", Ck, [
                ye("button", {
                  type: "button",
                  class: pi({ selected: vt.info === se }),
                  onClick: (be) => hs("info", Pe)
                }, " i ", 10, Pk)
              ])) : ke("", !0),
              Oe(R).length > 1 ? (Zt(), ce("div", Lk, [
                ye("button", {
                  type: "button",
                  disabled: n.readonly,
                  class: "delete",
                  "aria-label": Oe(l)("remove part"),
                  onClick: (be) => Hs(se)
                }, [
                  Zn(dt, { icon: ["fass", "trash"] })
                ], 8, Ik)
              ])) : ke("", !0),
              vt.banding === se && $t.options.length > 0 ? (Zt(), Wn(Yg, {
                key: 2,
                env: Oe(u),
                shape: Pe,
                "shape-index": se,
                "extra-type": "banding",
                "extra-label": "banding",
                "extra-keys": $t.keys,
                "all-options": $t.options,
                pricing: $t.pricing,
                labels: $t.labels,
                "user-friendly-field-map": Oe(sf),
                "part-columns": de.value,
                "get-price": ss,
                "format-price": n.formatPrice,
                "orientation-model": _.orientationModel,
                "get-available-pricing-options": jr,
                onUpdateAll: Dr,
                onSet: br
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : ke("", !0),
              vt.finish === se && te.options.length > 0 ? (Zt(), Wn(Yg, {
                key: 3,
                env: Oe(u),
                shape: Pe,
                "shape-index": se,
                "extra-type": "finish",
                "extra-label": "finish",
                "extra-keys": te.keys,
                "all-options": te.options,
                pricing: te.pricing,
                labels: te.labels,
                "user-friendly-field-map": Oe(sf),
                "part-columns": de.value,
                "get-price": ss,
                "format-price": n.formatPrice,
                "orientation-model": _.orientationModel,
                "get-available-pricing-options": jr,
                onUpdateAll: Dr,
                onSet: br
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : ke("", !0),
              vt.info === se ? (Zt(), ce("div", {
                key: 4,
                id: "shape-info",
                style: Bn({ "grid-column-end": "span " + (de.value + 1) })
              }, hn(yn(Pe)), 5)) : ke("", !0),
              vt.imageUpload === se ? (Zt(), Wn(vk, {
                key: 5,
                prefix: (se + 1).toString(),
                "unique-id": Oe(k),
                "shape-id": Pe.listId,
                env: Oe(u),
                style: Bn({ "grid-column-end": "span " + (de.value + 1) }),
                images: C.value,
                onUpdate: os,
                onRemove: Mo
              }, null, 8, ["prefix", "unique-id", "shape-id", "env", "style", "images"])) : ke("", !0)
            ]))), 128))
          ], 4),
          ye("div", Ek, [
            n.readonly ? ke("", !0) : (Zt(), ce("button", {
              key: 0,
              type: "button",
              "aria-label": Oe(l)("add part"),
              style: Bn({ background: _.colors.button, color: _.colors.buttonText }),
              class: "add c-btn icon-left",
              onClick: mt[2] || (mt[2] = (Pe) => as(1))
            }, [
              Zn(dt, { icon: ["fasr", "plus-large"] }),
              qu(" " + hn(Oe(l)("add part")), 1)
            ], 12, Ok)),
            ye("button", {
              id: "calculate-button",
              type: "button",
              class: "c-btn calculate icon-left",
              "aria-label": Oe(l)("calculate"),
              style: Bn({
                background: _.colors.button,
                color: _.colors.buttonText
              }),
              disabled: !((ge = tt.value) != null && ge.length) || E.value,
              onClick: mt[3] || (mt[3] = (Pe) => Ta())
            }, [
              Zn(dt, { icon: ["fass", "calculator"] }),
              qu(hn(Oe(l)("calculate")), 1)
            ], 12, Tk),
            n.readonly ? ke("", !0) : (Zt(), ce("button", {
              key: 1,
              type: "button",
              class: "c-btn clear",
              "aria-label": Oe(l)("clear"),
              onClick: mt[4] || (mt[4] = (Pe) => Ys())
            }, [
              Zn(dt, { icon: ["fass", "trash"] })
            ], 8, Fk)),
            ye("div", Mk, hn($.value) + hn(_ != null && _.maxParts ? "/" + _.maxParts : ""), 1)
          ]),
          P.value && !n.readonly ? (Zt(), Wn(Oe(r), {
            key: 2,
            ref: "import",
            units: n.units,
            "custom-fields": Jt.value,
            "banding-options": $t.options,
            "banding-labels": $t.labels,
            "finish-options": te.options,
            "finish-labels": te.labels,
            options: {
              locale: _.locale
            },
            onImport: Ro
          }, null, 8, ["units", "custom-fields", "banding-options", "banding-labels", "finish-options", "finish-labels", "options"])) : ke("", !0),
          nt.value ? (Zt(), ce("div", Dk, [
            X.value ? (Zt(), ce("div", Rk, hn(X.value), 1)) : ke("", !0),
            ye("pre", Bk, hn(st.value), 1)
          ])) : ke("", !0),
          (_.enable.diagram ? E.value && !oe.value.complete : E.value || oe.value.complete) ? (Zt(), ce("div", jk, [
            Zn(Vg, {
              size: 50,
              number: oe.value.shapeCount,
              complete: oe.value.complete,
              "show-number": _.enable.progressNumber
            }, null, 8, ["number", "complete", "show-number"])
          ])) : ke("", !0),
          Xg(ye("div", qk, [
            ((Fe = Yt.value) == null ? void 0 : Fe.type) !== "roll" ? (Zt(), ce("div", zk, hn((Re = Yt.value) != null && Re.stack ? (pn = Yt.value) == null ? void 0 : pn.stack : 1), 1)) : ke("", !0)
          ], 512), [
            [Jg, _.enable.diagram && M.value > 0]
          ]),
          _.enable.diagram && xe.value && Rt.value.length > 1 && M.value > 0 && oe.value.complete ? (Zt(), Wn(_6, {
            key: 5,
            ref: "stockNavigation",
            "active-stock-id": Y.value,
            "stock-list": Kt.value,
            "stock-count": H.value.length,
            "viewport-width": v.value,
            onShowStock: dn
          }, null, 8, ["active-stock-id", "stock-list", "stock-count", "viewport-width"])) : ke("", !0)
        ], 2)) : ke("", !0)
      ], 64);
    };
  }
});
function Kg(n) {
  const t = n;
  t.__i18n = t.__i18n || [], t.__i18n.push({
    locale: "",
    resource: {
      en_US: {
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Length" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Width" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Thickness" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "T" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Name" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantity" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Material" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machining" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grain" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add part" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Remove part" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calculate" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Full screen" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Banding" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete banding" } },
        finish: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Finish" } },
        "image upload": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image upload" } },
        "delete finish": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete finish" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Select" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "All" } },
        a: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        b: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "B" } },
        c: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        d: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "D" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Drop CSV file here" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Powered by SmartCut" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part issue" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue with part inputs" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts in list" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No quantity of parts found" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts were added - please double check your list." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The following parts did not fit" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The maximum number of parts is" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No valid parts found" } },
        Hardware: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware" } },
        "Hardware total": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware total" } },
        Panels: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Panels" } },
        pdf: {
          orderSummary: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Order summary" } },
          stockRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Stock requirements" } },
          rollRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Roll requirements" } },
          totals: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Totals" } },
          item: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Item" } },
          totalParts: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total parts" } },
          partArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part area" } },
          images: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Images" } },
          totalStockRequired: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total stock required" } },
          totalBandingLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total banding length" } },
          totalFinishArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total finish area" } },
          totalRollLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total roll length" } },
          partIndex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part index" } },
          fileName: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "File name" } },
          link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Link" } }
        }
      },
      ca: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Llarg" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ample" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gruix" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantitat" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanitzat" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gir" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Afegeix" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantell" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina cantell" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Neteja" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Peça" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les peces següents no encaixaven" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número màxim de peces és" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desenvolupat per SmartCut" } }
      },
      es_ES: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largo" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ancho" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grueso" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nombre" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantidad" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanizado" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Giro" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Añade" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Canto" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina canto" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Borra" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pieza" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Las siguientes piezas no encajaban" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número máximo de piezas es" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No se encontraron piezas válidas" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Carga el archivo CSV aquí" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desarrollado por SmartCut" } }
      },
      fr_FR: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Longueur" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largeur" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Epaisseur" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "ep" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantité" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Qt" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Matèriel" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machinage" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sens de fil" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ajouter pièce" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer pièce" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Optimiser" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Plein écran" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Chants" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer chants" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sélectionner" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Effacer" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tous" } },
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        "Powered by SmartCut": { t: 0, b: { static: "", t: 2, i: [] } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Télécharger CSV" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce erreur" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur avec l'importation de pièces" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce dans la liste" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune quantité trouvé pour certaines pièces" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce n'a été ajoutée - veuillez vérifier votre liste." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les pièces suivantes ne s'adaptent pas" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Le nombre maximum de pièces est" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce valide trouvée" } }
      }
    }
  });
}
typeof Kg == "function" && Kg(Bm);
const Uk = /* @__PURE__ */ La(Bm, [["__scopeId", "data-v-9a000016"]]), jm = ["banding", "finish", "cutLength", "perPart", "partArea", "offcutArea", "rollLength", "surcharge", "machining", "stock", "custom"], Wk = (n) => jm.includes(n);
function Hk(n, t) {
  const e = (u) => {
    var d;
    (d = t.log) == null || d.call(t, u);
  }, i = (u) => {
    var d;
    return (d = t.error) == null || d.call(t, u), { success: !1, error: u };
  }, r = () => {
    for (const u of jm) s(u, 0);
  }, s = (u, d) => {
    const { inputs: p, elements: f, setInputValue: g, formatPrice: b } = t;
    if (isNaN(d)) throw new Error("Price must be a number");
    if (!Wk(u)) return;
    const y = {
      custom: {
        visible: null,
        hidden: "smartcut-custom-price"
      },
      perPart: {
        hidden: "smartcut-per-part-price",
        visible: "per_part_price"
      },
      partArea: {
        hidden: null,
        visible: "part_area_price"
      },
      offcutArea: {
        hidden: null,
        visible: "offcut_area_price"
      },
      rollLength: {
        hidden: null,
        visible: "roll_length_price"
      },
      banding: {
        hidden: "smartcut-banding-price",
        visible: "banding_total_price"
      },
      finish: {
        hidden: "smartcut-finish-price",
        visible: "finish_total_price"
      },
      machining: {
        hidden: "smartcut-machining-price",
        visible: "machining_total_price"
      },
      surcharge: {
        hidden: "smartcut-cut-to-size-surcharge",
        visible: "surcharge_price"
      },
      cutLength: {
        hidden: "smartcut-cut-length-price",
        visible: "cut_length_price"
      },
      stock: {
        hidden: null,
        visible: "stock_total_price"
      }
    }[u];
    y != null && y.hidden && p[y.hidden] && g(y.hidden, d), y != null && y.visible && f[y.visible] && (f[y.visible].innerText = b(d));
  }, o = (u) => {
    var I;
    const { product: d, selectedVariation: p, isQuantityPricing: f, enableAddToCart: g, setCartQuantity: b } = t, x = parseFloat((d == null ? void 0 : d.price) || ((I = p.value) == null ? void 0 : I.display_price) || "0"), y = n.unit_system === "imperial" ? "feet" : "meters", k = {
      full_stock: (D) => (e(["calculating cost by full sheet"]), f() ? (b(D.metadata.totalUsedStock), 0) : D.metadata.totalStockCost),
      part_area: (D) => {
        e([`calculating cost by part area in square ${y}`]);
        const E = n.unit_system === "imperial" ? 144 : 1e6, O = D.metadata.totalPartArea / E, M = O * x;
        s("partArea", M), e([`part area in square ${y} is ${O} with price ${M}`]);
        let q = O;
        if (n != null && n.enable_offcut_pricing && (D != null && D.offcuts)) {
          const A = D == null ? void 0 : D.offcuts.reduce((_, J) => {
            const V = J.l >= J.w ? J.l : J.w, R = J.l >= J.w ? J.w : J.l;
            return V < n.offcut_min_length || R < n.offcut_min_width ? _ + V * R : _;
          }, 0), F = A / E * x;
          s("offcutArea", F), e([`calculated sellable offcut area as ${A}, with price ${F}`]), q += A / E;
        }
        const P = q * x;
        if (e([`calculated total price as ${P}, `]), f())
          e([`setting cart quantity to ${q}`]), b(q, 2);
        else
          return P;
        return 0;
      },
      cut_length: (D) => {
        e([`calculating cost by cut length in  ${y}`]);
        const E = n.unit_system === "imperial" ? 12 : 1e3, O = D.metadata.totalCutLength / E;
        return b(O, 2), 0;
      },
      full_stock_plus_cut_length: (D) => {
        e(["calculating cost by full sheet plus cut length"]);
        let E = 0;
        f() ? b(D.metadata.totalUsedStock) : E = D.metadata.totalStockCost;
        const O = n.unit_system === "imperial" ? 12 : 1e3, q = D.metadata.totalCutLength / O * n.cut_length_price;
        return s("cutLength", q), E + q;
      },
      full_stock_plus_num_parts: (D) => {
        e(["calculating cost by full sheet plus number of parts"]);
        let E = 0;
        if (f())
          b(D.metadata.totalUsedStock);
        else {
          const M = D.metadata.totalStockCost;
          s("stock", M), E = M;
        }
        const O = D.metadata.totalPartsProduced * n.per_part_price;
        return s("perPart", O), E + O;
      },
      roll_length: (D) => {
        e([`calculating cost by roll length in ${y}`]);
        const E = n.unit_system === "imperial" ? 12 : 1e3, O = D.stock.reduce((M, q) => M + q.analysis.rollLength / E * Qt(q.cost), 0);
        return s("rollLength", O), O;
      }
    }[n.pricing_strategy], C = k(u);
    return g(), C;
  }, a = (u, d) => {
    const {
      isExtraEnabled: p,
      isMachiningEnabled: f,
      isSurchargeEnabled: g,
      inputType: b,
      getTotalBandingPrice: x,
      getTotalFinishPrice: y,
      getTotalMachiningPrice: v,
      getInputValue: k
    } = t;
    let C = d;
    if (p("banding") && u.metadata.bandingLengthByType) {
      const I = x(u.metadata.bandingLengthByType);
      s("banding", I), C += I;
    }
    if (p("finish") && u.metadata.finishAreaByType) {
      const I = y(u.metadata.finishAreaByType);
      s("finish", I), C += I;
    }
    if (b.value === "formula") {
      const I = parseFloat(k("smartcut-hardware-price"));
      isNaN(I) || (C += I);
    }
    if (f()) {
      const I = v(u);
      s("machining", I), C += I;
    }
    if (g() && n.surcharge) {
      const I = n.surcharge_type === "per_sheet" ? parseFloat(n.surcharge.toString()) * u.metadata.totalUsedStock : parseFloat(n.surcharge.toString());
      s("surcharge", I), e(["added surcharge", I]), C += I;
    }
    return C;
  }, l = (u) => {
    const { getInputValue: d, setInputValue: p } = t, f = {
      "smartcut-job-id": u.jobId,
      "smartcut-dimensions": u.parts.map((g) => `${g.l}x${g.w} [${g.q}]`).join(", "),
      "smartcut-total-cut-length": u.metadata.totalCutLength,
      "smartcut-part-area": u.metadata.totalPartArea,
      "smartcut-total-cuts": u.metadata.totalCuts,
      "smartcut-total-parts": u.metadata.totalPartsProduced,
      "smartcut-machining": u.metadata.hasMachining
    };
    if (Object.entries(f).forEach(([g, b]) => {
      p(g, b);
    }), d("smartcut-stock-summary") !== void 0) {
      const g = u.stock.map((b) => `${b.l}x${b.w}${b.t ? "x" + b.t : ""} [${b.q}]`).join(", ");
      p("smartcut-stock-summary", g);
    }
  };
  return {
    calculatePrice: async (u) => {
      const { isQuantityPricing: d, selectedVariation: p, setVariationPrice: f, setCartQuantity: g } = t;
      if (!(u != null && u.jobId))
        return i("No job ID provided");
      d() || g(1);
      let b = o(u);
      if (!d()) {
        if (!u.metadata.totalStockCost)
          return i("Total stock cost not returned for a multiple size product");
        e([`total cost is ${b}`]), s("custom", b);
      }
      return b = a(u, b), p.value && f(b), l(u), { success: !0, totalPrice: b };
    },
    resetPricing: r
  };
}
function ju(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var qm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, r, s) {
      function o(h, u) {
        if (!r[h]) {
          if (!i[h]) {
            var d = typeof ju == "function" && ju;
            if (!u && d) return d(h, !0);
            if (a) return a(h, !0);
            var p = new Error("Cannot find module '" + h + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var f = r[h] = { exports: {} };
          i[h][0].call(f.exports, function(g) {
            var b = i[h][1][g];
            return o(b || g);
          }, f, f.exports, e, i, r, s);
        }
        return r[h].exports;
      }
      for (var a = typeof ju == "function" && ju, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ 1: [function(e, i, r) {
      var s = e("./utils"), o = e("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(l) {
        for (var h, u, d, p, f, g, b, x = [], y = 0, v = l.length, k = v, C = s.getTypeOf(l) !== "string"; y < l.length; ) k = v - y, d = C ? (h = l[y++], u = y < v ? l[y++] : 0, y < v ? l[y++] : 0) : (h = l.charCodeAt(y++), u = y < v ? l.charCodeAt(y++) : 0, y < v ? l.charCodeAt(y++) : 0), p = h >> 2, f = (3 & h) << 4 | u >> 4, g = 1 < k ? (15 & u) << 2 | d >> 6 : 64, b = 2 < k ? 63 & d : 64, x.push(a.charAt(p) + a.charAt(f) + a.charAt(g) + a.charAt(b));
        return x.join("");
      }, r.decode = function(l) {
        var h, u, d, p, f, g, b = 0, x = 0, y = "data:";
        if (l.substr(0, y.length) === y) throw new Error("Invalid base64 input, it looks like a data url.");
        var v, k = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && k--, l.charAt(l.length - 2) === a.charAt(64) && k--, k % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (v = o.uint8array ? new Uint8Array(0 | k) : new Array(0 | k); b < l.length; ) h = a.indexOf(l.charAt(b++)) << 2 | (p = a.indexOf(l.charAt(b++))) >> 4, u = (15 & p) << 4 | (f = a.indexOf(l.charAt(b++))) >> 2, d = (3 & f) << 6 | (g = a.indexOf(l.charAt(b++))), v[x++] = h, f !== 64 && (v[x++] = u), g !== 64 && (v[x++] = d);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, r) {
      var s = e("./external"), o = e("./stream/DataWorker"), a = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function h(u, d, p, f, g) {
        this.compressedSize = u, this.uncompressedSize = d, this.crc32 = p, this.compression = f, this.compressedContent = g;
      }
      h.prototype = { getContentWorker: function() {
        var u = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, h.createWorkerFrom = function(u, d, p) {
        return u.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, i.exports = h;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, r) {
      var s = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, r) {
      var s = e("./utils"), o = function() {
        for (var a, l = [], h = 0; h < 256; h++) {
          a = h;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[h] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? function(h, u, d, p) {
          var f = o, g = p + d;
          h ^= -1;
          for (var b = p; b < g; b++) h = h >>> 8 ^ f[255 & (h ^ u[b])];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : function(h, u, d, p) {
          var f = o, g = p + d;
          h ^= -1;
          for (var b = p; b < g; b++) h = h >>> 8 ^ f[255 & (h ^ u.charCodeAt(b))];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, r) {
      r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, i, r) {
      var s = null;
      s = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), a = e("./utils"), l = e("./stream/GenericWorker"), h = s ? "uint8array" : "array";
      function u(d, p) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = p, this.meta = {};
      }
      r.magic = "\b\0", a.inherits(u, l), u.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(h, d.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(p) {
          d.push({ data: p, meta: d.meta });
        };
      }, r.compressWorker = function(d) {
        return new u("Deflate", d);
      }, r.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, r) {
      function s(f, g) {
        var b, x = "";
        for (b = 0; b < g; b++) x += String.fromCharCode(255 & f), f >>>= 8;
        return x;
      }
      function o(f, g, b, x, y, v) {
        var k, C, I = f.file, D = f.compression, E = v !== h.utf8encode, O = a.transformTo("string", v(I.name)), M = a.transformTo("string", h.utf8encode(I.name)), q = I.comment, P = a.transformTo("string", v(q)), A = a.transformTo("string", h.utf8encode(q)), F = M.length !== I.name.length, _ = A.length !== q.length, J = "", V = "", R = "", tt = I.dir, H = I.date, ct = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !b || (ct.crc32 = f.crc32, ct.compressedSize = f.compressedSize, ct.uncompressedSize = f.uncompressedSize);
        var it = 0;
        g && (it |= 8), E || !F && !_ || (it |= 2048);
        var N = 0, z = 0;
        tt && (N |= 16), y === "UNIX" ? (z = 798, N |= function(Y, ot) {
          var xt = Y;
          return Y || (xt = ot ? 16893 : 33204), (65535 & xt) << 16;
        }(I.unixPermissions, tt)) : (z = 20, N |= function(Y) {
          return 63 & (Y || 0);
        }(I.dosPermissions)), k = H.getUTCHours(), k <<= 6, k |= H.getUTCMinutes(), k <<= 5, k |= H.getUTCSeconds() / 2, C = H.getUTCFullYear() - 1980, C <<= 4, C |= H.getUTCMonth() + 1, C <<= 5, C |= H.getUTCDate(), F && (V = s(1, 1) + s(u(O), 4) + M, J += "up" + s(V.length, 2) + V), _ && (R = s(1, 1) + s(u(P), 4) + A, J += "uc" + s(R.length, 2) + R);
        var G = "";
        return G += `
\0`, G += s(it, 2), G += D.magic, G += s(k, 2), G += s(C, 2), G += s(ct.crc32, 4), G += s(ct.compressedSize, 4), G += s(ct.uncompressedSize, 4), G += s(O.length, 2), G += s(J.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + G + O + J, dirRecord: d.CENTRAL_FILE_HEADER + s(z, 2) + G + s(P.length, 2) + "\0\0\0\0" + s(N, 4) + s(x, 4) + O + J + P };
      }
      var a = e("../utils"), l = e("../stream/GenericWorker"), h = e("../utf8"), u = e("../crc32"), d = e("../signature");
      function p(f, g, b, x) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = b, this.encodeFileName = x, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(p, l), p.prototype.push = function(f) {
        var g = f.meta.percent || 0, b = this.entriesCount, x = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, l.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: b ? (g + 100 * (b - x - 1)) / b : 100 } }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var g = this.streamFiles && !f.file.dir;
        if (g) {
          var b = o(f, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: b.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var g = this.streamFiles && !f.file.dir, b = o(f, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(b.dirRecord), g) this.push({ data: function(x) {
          return d.DATA_DESCRIPTOR + s(x.crc32, 4) + s(x.compressedSize, 4) + s(x.uncompressedSize, 4);
        }(f), meta: { percent: 100 } });
        else for (this.push({ data: b.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, g = 0; g < this.dirRecords.length; g++) this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var b = this.bytesWritten - f, x = function(y, v, k, C, I) {
          var D = a.transformTo("string", I(C));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(y, 2) + s(y, 2) + s(v, 4) + s(k, 4) + s(D.length, 2) + D;
        }(this.dirRecords.length, b, f, this.zipComment, this.encodeFileName);
        this.push({ data: x, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var g = this;
        return f.on("data", function(b) {
          g.processChunk(b);
        }), f.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), f.on("error", function(b) {
          g.error(b);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(f) {
        var g = this._sources;
        if (!l.prototype.error.call(this, f)) return !1;
        for (var b = 0; b < g.length; b++) try {
          g[b].error(f);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var f = this._sources, g = 0; g < f.length; g++) f[g].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, r) {
      var s = e("../compressions"), o = e("./ZipFileWorker");
      r.generateWorker = function(a, l, h) {
        var u = new o(l.streamFiles, h, l.platform, l.encodeFileName), d = 0;
        try {
          a.forEach(function(p, f) {
            d++;
            var g = function(v, k) {
              var C = v || k, I = s[C];
              if (!I) throw new Error(C + " is not a valid compression method !");
              return I;
            }(f.options.compression, l.compression), b = f.options.compressionOptions || l.compressionOptions || {}, x = f.dir, y = f.date;
            f._compressWorker(g, b).withStreamInfo("file", { name: p, dir: x, date: y, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(u);
          }), u.entriesCount = d;
        } catch (p) {
          u.error(p);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, r) {
      function s() {
        if (!(this instanceof s)) return new s();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this) typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (s.prototype = e("./object")).loadAsync = e("./load"), s.support = e("./support"), s.defaults = e("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = e("./external"), i.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, r) {
      var s = e("./utils"), o = e("./external"), a = e("./utf8"), l = e("./zipEntries"), h = e("./stream/Crc32Probe"), u = e("./nodejsUtils");
      function d(p) {
        return new o.Promise(function(f, g) {
          var b = p.decompressed.getContentWorker().pipe(new h());
          b.on("error", function(x) {
            g(x);
          }).on("end", function() {
            b.streamInfo.crc32 !== p.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      i.exports = function(p, f) {
        var g = this;
        return f = s.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), u.isNode && u.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", p, !0, f.optimizedBinaryString, f.base64).then(function(b) {
          var x = new l(f);
          return x.load(b), x;
        }).then(function(b) {
          var x = [o.Promise.resolve(b)], y = b.files;
          if (f.checkCRC32) for (var v = 0; v < y.length; v++) x.push(d(y[v]));
          return o.Promise.all(x);
        }).then(function(b) {
          for (var x = b.shift(), y = x.files, v = 0; v < y.length; v++) {
            var k = y[v], C = k.fileNameStr, I = s.resolve(k.fileNameStr);
            g.file(I, k.decompressed, { binary: !0, optimizedBinaryString: !0, date: k.date, dir: k.dir, comment: k.fileCommentStr.length ? k.fileCommentStr : null, unixPermissions: k.unixPermissions, dosPermissions: k.dosPermissions, createFolders: f.createFolders }), k.dir || (g.file(I).unsafeOriginalName = C);
          }
          return x.zipComment.length && (g.comment = x.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, r) {
      var s = e("../utils"), o = e("../stream/GenericWorker");
      function a(l, h) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(h);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var h = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          h.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          h.isPaused ? this.generatedError = u : h.error(u);
        }).on("end", function() {
          h.isPaused ? h._upstreamEnded = !0 : h.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, r) {
      var s = e("readable-stream").Readable;
      function o(a, l, h) {
        s.call(this, l), this._helper = a;
        var u = this;
        a.on("data", function(d, p) {
          u.push(d) || u._helper.pause(), h && h(p);
        }).on("error", function(d) {
          u.emit("error", d);
        }).on("end", function() {
          u.push(null);
        });
      }
      e("../utils").inherits(o, s), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, r) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, o);
        if (typeof s == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(s, o);
      }, allocBuffer: function(s) {
        if (Buffer.alloc) return Buffer.alloc(s);
        var o = new Buffer(s);
        return o.fill(0), o;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(e, i, r) {
      function s(I, D, E) {
        var O, M = a.getTypeOf(D), q = a.extend(E || {}, u);
        q.date = q.date || /* @__PURE__ */ new Date(), q.compression !== null && (q.compression = q.compression.toUpperCase()), typeof q.unixPermissions == "string" && (q.unixPermissions = parseInt(q.unixPermissions, 8)), q.unixPermissions && 16384 & q.unixPermissions && (q.dir = !0), q.dosPermissions && 16 & q.dosPermissions && (q.dir = !0), q.dir && (I = y(I)), q.createFolders && (O = x(I)) && v.call(this, O, !0);
        var P = M === "string" && q.binary === !1 && q.base64 === !1;
        E && E.binary !== void 0 || (q.binary = !P), (D instanceof d && D.uncompressedSize === 0 || q.dir || !D || D.length === 0) && (q.base64 = !1, q.binary = !0, D = "", q.compression = "STORE", M = "string");
        var A = null;
        A = D instanceof d || D instanceof l ? D : g.isNode && g.isStream(D) ? new b(I, D) : a.prepareContent(I, D, q.binary, q.optimizedBinaryString, q.base64);
        var F = new p(I, A, q);
        this.files[I] = F;
      }
      var o = e("./utf8"), a = e("./utils"), l = e("./stream/GenericWorker"), h = e("./stream/StreamHelper"), u = e("./defaults"), d = e("./compressedObject"), p = e("./zipObject"), f = e("./generate"), g = e("./nodejsUtils"), b = e("./nodejs/NodejsStreamInputAdapter"), x = function(I) {
        I.slice(-1) === "/" && (I = I.substring(0, I.length - 1));
        var D = I.lastIndexOf("/");
        return 0 < D ? I.substring(0, D) : "";
      }, y = function(I) {
        return I.slice(-1) !== "/" && (I += "/"), I;
      }, v = function(I, D) {
        return D = D !== void 0 ? D : u.createFolders, I = y(I), this.files[I] || s.call(this, I, null, { dir: !0, createFolders: D }), this.files[I];
      };
      function k(I) {
        return Object.prototype.toString.call(I) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(I) {
        var D, E, O;
        for (D in this.files) O = this.files[D], (E = D.slice(this.root.length, D.length)) && D.slice(0, this.root.length) === this.root && I(E, O);
      }, filter: function(I) {
        var D = [];
        return this.forEach(function(E, O) {
          I(E, O) && D.push(O);
        }), D;
      }, file: function(I, D, E) {
        if (arguments.length !== 1) return I = this.root + I, s.call(this, I, D, E), this;
        if (k(I)) {
          var O = I;
          return this.filter(function(q, P) {
            return !P.dir && O.test(q);
          });
        }
        var M = this.files[this.root + I];
        return M && !M.dir ? M : null;
      }, folder: function(I) {
        if (!I) return this;
        if (k(I)) return this.filter(function(M, q) {
          return q.dir && I.test(M);
        });
        var D = this.root + I, E = v.call(this, D), O = this.clone();
        return O.root = E.name, O;
      }, remove: function(I) {
        I = this.root + I;
        var D = this.files[I];
        if (D || (I.slice(-1) !== "/" && (I += "/"), D = this.files[I]), D && !D.dir) delete this.files[I];
        else for (var E = this.filter(function(M, q) {
          return q.name.slice(0, I.length) === I;
        }), O = 0; O < E.length; O++) delete this.files[E[O].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(I) {
        var D, E = {};
        try {
          if ((E = a.extend(I || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = E.type.toLowerCase(), E.compression = E.compression.toUpperCase(), E.type === "binarystring" && (E.type = "string"), !E.type) throw new Error("No output type specified.");
          a.checkSupport(E.type), E.platform !== "darwin" && E.platform !== "freebsd" && E.platform !== "linux" && E.platform !== "sunos" || (E.platform = "UNIX"), E.platform === "win32" && (E.platform = "DOS");
          var O = E.comment || this.comment || "";
          D = f.generateWorker(this, E, O);
        } catch (M) {
          (D = new l("error")).error(M);
        }
        return new h(D, E.type || "string", E.mimeType);
      }, generateAsync: function(I, D) {
        return this.generateInternalStream(I).accumulate(D);
      }, generateNodeStream: function(I, D) {
        return (I = I || {}).type || (I.type = "nodebuffer"), this.generateInternalStream(I).toNodejsStream(D);
      } };
      i.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, r) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
        for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l];
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === l && this.data[p + 1] === h && this.data[p + 2] === u && this.data[p + 3] === d) return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.readData(4);
        return l === p[0] && h === p[1] && u === p[2] && d === p[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, r) {
      var s = e("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, h = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--) h = (h << 8) + this.byteAt(l);
        return this.index += a, h;
      }, readString: function(a) {
        return s.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, r) {
      var s = e("./Uint8ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, r) {
      var s = e("./ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, r) {
      var s = e("../utils"), o = e("../support"), a = e("./ArrayReader"), l = e("./StringReader"), h = e("./NodeBufferReader"), u = e("./Uint8ArrayReader");
      i.exports = function(d) {
        var p = s.getTypeOf(d);
        return s.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new h(d) : o.uint8array ? new u(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../crc32");
      function a() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(a, s), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var h = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = h + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var h = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          h.dataIsReady = !0, h.data = u, h.max = u && u.length || 0, h.type = s.getTypeOf(u), h.isPaused || h._tickAndRepeat();
        }, function(u) {
          h.error(u);
        });
      }
      s.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, h = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, h);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, h);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, h);
        }
        return this.index = h, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, r) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o]) for (var l = 0; l < this._listeners[o].length; l++) this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = s;
    }, {}], 29: [function(e, i, r) {
      var s = e("../utils"), o = e("./ConvertWorker"), a = e("./GenericWorker"), l = e("../base64"), h = e("../support"), u = e("../external"), d = null;
      if (h.nodestream) try {
        d = e("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(g, b) {
        return new u.Promise(function(x, y) {
          var v = [], k = g._internalType, C = g._outputType, I = g._mimeType;
          g.on("data", function(D, E) {
            v.push(D), b && b(E);
          }).on("error", function(D) {
            v = [], y(D);
          }).on("end", function() {
            try {
              var D = function(E, O, M) {
                switch (E) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", O), M);
                  case "base64":
                    return l.encode(O);
                  default:
                    return s.transformTo(E, O);
                }
              }(C, function(E, O) {
                var M, q = 0, P = null, A = 0;
                for (M = 0; M < O.length; M++) A += O[M].length;
                switch (E) {
                  case "string":
                    return O.join("");
                  case "array":
                    return Array.prototype.concat.apply([], O);
                  case "uint8array":
                    for (P = new Uint8Array(A), M = 0; M < O.length; M++) P.set(O[M], q), q += O[M].length;
                    return P;
                  case "nodebuffer":
                    return Buffer.concat(O);
                  default:
                    throw new Error("concat : unsupported type '" + E + "'");
                }
              }(k, v), I);
              x(D);
            } catch (E) {
              y(E);
            }
            v = [];
          }).resume();
        });
      }
      function f(g, b, x) {
        var y = b;
        switch (b) {
          case "blob":
          case "arraybuffer":
            y = "uint8array";
            break;
          case "base64":
            y = "string";
        }
        try {
          this._internalType = y, this._outputType = b, this._mimeType = x, s.checkSupport(y), this._worker = g.pipe(new o(y)), g.lock();
        } catch (v) {
          this._worker = new a("error"), this._worker.error(v);
        }
      }
      f.prototype = { accumulate: function(g) {
        return p(this, g);
      }, on: function(g, b) {
        var x = this;
        return g === "data" ? this._worker.on(g, function(y) {
          b.call(x, y.data, y.meta);
        }) : this._worker.on(g, function() {
          s.delay(b, arguments, x);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, i.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, r) {
      if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") r.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          r.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(s), r.blob = o.getBlob("application/zip").size === 0;
          } catch {
            r.blob = !1;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch {
        r.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, r) {
      for (var s = e("./utils"), o = e("./support"), a = e("./nodejsUtils"), l = e("./stream/GenericWorker"), h = new Array(256), u = 0; u < 256; u++) h[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      h[254] = h[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      r.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : function(g) {
          var b, x, y, v, k, C = g.length, I = 0;
          for (v = 0; v < C; v++) (64512 & (x = g.charCodeAt(v))) == 55296 && v + 1 < C && (64512 & (y = g.charCodeAt(v + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (y - 56320), v++), I += x < 128 ? 1 : x < 2048 ? 2 : x < 65536 ? 3 : 4;
          for (b = o.uint8array ? new Uint8Array(I) : new Array(I), v = k = 0; k < I; v++) (64512 & (x = g.charCodeAt(v))) == 55296 && v + 1 < C && (64512 & (y = g.charCodeAt(v + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (y - 56320), v++), x < 128 ? b[k++] = x : (x < 2048 ? b[k++] = 192 | x >>> 6 : (x < 65536 ? b[k++] = 224 | x >>> 12 : (b[k++] = 240 | x >>> 18, b[k++] = 128 | x >>> 12 & 63), b[k++] = 128 | x >>> 6 & 63), b[k++] = 128 | 63 & x);
          return b;
        }(f);
      }, r.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : function(g) {
          var b, x, y, v, k = g.length, C = new Array(2 * k);
          for (b = x = 0; b < k; ) if ((y = g[b++]) < 128) C[x++] = y;
          else if (4 < (v = h[y])) C[x++] = 65533, b += v - 1;
          else {
            for (y &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && b < k; ) y = y << 6 | 63 & g[b++], v--;
            1 < v ? C[x++] = 65533 : y < 65536 ? C[x++] = y : (y -= 65536, C[x++] = 55296 | y >> 10 & 1023, C[x++] = 56320 | 1023 & y);
          }
          return C.length !== x && (C.subarray ? C = C.subarray(0, x) : C.length = x), s.applyFromCharCode(C);
        }(f = s.transformTo(o.uint8array ? "uint8array" : "array", f));
      }, s.inherits(d, l), d.prototype.processChunk = function(f) {
        var g = s.transformTo(o.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var b = g;
            (g = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), g.set(b, this.leftOver.length);
          } else g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var x = function(v, k) {
          var C;
          for ((k = k || v.length) > v.length && (k = v.length), C = k - 1; 0 <= C && (192 & v[C]) == 128; ) C--;
          return C < 0 || C === 0 ? k : C + h[v[C]] > k ? C : k;
        }(g), y = g;
        x !== g.length && (o.uint8array ? (y = g.subarray(0, x), this.leftOver = g.subarray(x, g.length)) : (y = g.slice(0, x), this.leftOver = g.slice(x, g.length))), this.push({ data: r.utf8decode(y), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, r.Utf8DecodeWorker = d, s.inherits(p, l), p.prototype.processChunk = function(f) {
        this.push({ data: r.utf8encode(f.data), meta: f.meta });
      }, r.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, r) {
      var s = e("./support"), o = e("./base64"), a = e("./nodejsUtils"), l = e("./external");
      function h(b) {
        return b;
      }
      function u(b, x) {
        for (var y = 0; y < b.length; ++y) x[y] = 255 & b.charCodeAt(y);
        return x;
      }
      e("setimmediate"), r.newBlob = function(b, x) {
        r.checkSupport("blob");
        try {
          return new Blob([b], { type: x });
        } catch {
          try {
            var y = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return y.append(b), y.getBlob(x);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(b, x, y) {
        var v = [], k = 0, C = b.length;
        if (C <= y) return String.fromCharCode.apply(null, b);
        for (; k < C; ) x === "array" || x === "nodebuffer" ? v.push(String.fromCharCode.apply(null, b.slice(k, Math.min(k + y, C)))) : v.push(String.fromCharCode.apply(null, b.subarray(k, Math.min(k + y, C)))), k += y;
        return v.join("");
      }, stringifyByChar: function(b) {
        for (var x = "", y = 0; y < b.length; y++) x += String.fromCharCode(b[y]);
        return x;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(b) {
        var x = 65536, y = r.getTypeOf(b), v = !0;
        if (y === "uint8array" ? v = d.applyCanBeUsed.uint8array : y === "nodebuffer" && (v = d.applyCanBeUsed.nodebuffer), v) for (; 1 < x; ) try {
          return d.stringifyByChunk(b, y, x);
        } catch {
          x = Math.floor(x / 2);
        }
        return d.stringifyByChar(b);
      }
      function f(b, x) {
        for (var y = 0; y < b.length; y++) x[y] = b[y];
        return x;
      }
      r.applyFromCharCode = p;
      var g = {};
      g.string = { string: h, array: function(b) {
        return u(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return g.string.uint8array(b).buffer;
      }, uint8array: function(b) {
        return u(b, new Uint8Array(b.length));
      }, nodebuffer: function(b) {
        return u(b, a.allocBuffer(b.length));
      } }, g.array = { string: p, array: h, arraybuffer: function(b) {
        return new Uint8Array(b).buffer;
      }, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return a.newBufferFrom(b);
      } }, g.arraybuffer = { string: function(b) {
        return p(new Uint8Array(b));
      }, array: function(b) {
        return f(new Uint8Array(b), new Array(b.byteLength));
      }, arraybuffer: h, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return a.newBufferFrom(new Uint8Array(b));
      } }, g.uint8array = { string: p, array: function(b) {
        return f(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return b.buffer;
      }, uint8array: h, nodebuffer: function(b) {
        return a.newBufferFrom(b);
      } }, g.nodebuffer = { string: p, array: function(b) {
        return f(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return g.nodebuffer.uint8array(b).buffer;
      }, uint8array: function(b) {
        return f(b, new Uint8Array(b.length));
      }, nodebuffer: h }, r.transformTo = function(b, x) {
        if (x = x || "", !b) return x;
        r.checkSupport(b);
        var y = r.getTypeOf(x);
        return g[y][b](x);
      }, r.resolve = function(b) {
        for (var x = b.split("/"), y = [], v = 0; v < x.length; v++) {
          var k = x[v];
          k === "." || k === "" && v !== 0 && v !== x.length - 1 || (k === ".." ? y.pop() : y.push(k));
        }
        return y.join("/");
      }, r.getTypeOf = function(b) {
        return typeof b == "string" ? "string" : Object.prototype.toString.call(b) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(b) ? "nodebuffer" : s.uint8array && b instanceof Uint8Array ? "uint8array" : s.arraybuffer && b instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, r.checkSupport = function(b) {
        if (!s[b.toLowerCase()]) throw new Error(b + " is not supported by this platform");
      }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(b) {
        var x, y, v = "";
        for (y = 0; y < (b || "").length; y++) v += "\\x" + ((x = b.charCodeAt(y)) < 16 ? "0" : "") + x.toString(16).toUpperCase();
        return v;
      }, r.delay = function(b, x, y) {
        setImmediate(function() {
          b.apply(y || null, x || []);
        });
      }, r.inherits = function(b, x) {
        function y() {
        }
        y.prototype = x.prototype, b.prototype = new y();
      }, r.extend = function() {
        var b, x, y = {};
        for (b = 0; b < arguments.length; b++) for (x in arguments[b]) Object.prototype.hasOwnProperty.call(arguments[b], x) && y[x] === void 0 && (y[x] = arguments[b][x]);
        return y;
      }, r.prepareContent = function(b, x, y, v, k) {
        return l.Promise.resolve(x).then(function(C) {
          return s.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(I, D) {
            var E = new FileReader();
            E.onload = function(O) {
              I(O.target.result);
            }, E.onerror = function(O) {
              D(O.target.error);
            }, E.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var I = r.getTypeOf(C);
          return I ? (I === "arraybuffer" ? C = r.transformTo("uint8array", C) : I === "string" && (k ? C = o.decode(C) : y && v !== !0 && (C = function(D) {
            return u(D, s.uint8array ? new Uint8Array(D.length) : new Array(D.length));
          }(C))), C) : l.Promise.reject(new Error("Can't read the data of '" + b + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./signature"), l = e("./zipEntry"), h = e("./support");
      function u(d) {
        this.files = [], this.loadOptions = d;
      }
      u.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(d) + ")");
        }
      }, isSignature: function(d, p) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var g = this.reader.readString(4) === p;
        return this.reader.setIndex(f), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), p = h.uint8array ? "uint8array" : "array", f = o.transformTo(p, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, p, f, g = this.zip64EndOfCentralSize - 44; 0 < g; ) d = this.reader.readInt(2), p = this.reader.readInt(4), f = this.reader.readData(p), this.zip64ExtensibleData[d] = { id: d, length: p, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, p;
        for (d = 0; d < this.files.length; d++) p = this.files[d], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (d < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var p = d;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var g = p - f;
        if (0 < g) this.isSignature(p, a.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0) throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = s(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./compressedObject"), l = e("./crc32"), h = e("./utf8"), u = e("./compressions"), d = e("./support");
      function p(f, g) {
        this.options = f, this.loadOptions = g;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var g, b;
        if (f.skip(22), this.fileNameLength = f.readInt(2), b = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(x) {
          for (var y in u) if (Object.prototype.hasOwnProperty.call(u, y) && u[y].magic === x) return u[y];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, g, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var g = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        f.skip(g), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = s(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var g, b, x, y = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < y; ) g = f.readInt(2), b = f.readInt(2), x = f.readData(b), this.extraFields[g] = { id: g, length: b, value: x };
        f.setIndex(y);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = h.utf8decode(this.fileName), this.fileCommentStr = h.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null) this.fileNameStr = g;
          else {
            var b = o.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(b);
          }
          var x = this.findExtraFieldUnicodeComment();
          if (x !== null) this.fileCommentStr = x;
          else {
            var y = o.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(y);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var g = s(f.value);
          return g.readInt(1) !== 1 || l(this.fileName) !== g.readInt(4) ? null : h.utf8decode(g.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var g = s(f.value);
          return g.readInt(1) !== 1 || l(this.fileComment) !== g.readInt(4) ? null : h.utf8decode(g.readData(f.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, r) {
      function s(g, b, x) {
        this.name = g, this.dir = x.dir, this.date = x.date, this.comment = x.comment, this.unixPermissions = x.unixPermissions, this.dosPermissions = x.dosPermissions, this._data = b, this._dataBinary = x.binary, this.options = { compression: x.compression, compressionOptions: x.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), a = e("./stream/DataWorker"), l = e("./utf8"), h = e("./compressedObject"), u = e("./stream/GenericWorker");
      s.prototype = { internalStream: function(g) {
        var b = null, x = "string";
        try {
          if (!g) throw new Error("No output type specified.");
          var y = (x = g.toLowerCase()) === "string" || x === "text";
          x !== "binarystring" && x !== "text" || (x = "string"), b = this._decompressWorker();
          var v = !this._dataBinary;
          v && !y && (b = b.pipe(new l.Utf8EncodeWorker())), !v && y && (b = b.pipe(new l.Utf8DecodeWorker()));
        } catch (k) {
          (b = new u("error")).error(k);
        }
        return new o(b, x, "");
      }, async: function(g, b) {
        return this.internalStream(g).accumulate(b);
      }, nodeStream: function(g, b) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(b);
      }, _compressWorker: function(g, b) {
        if (this._data instanceof h && this._data.compression.magic === g.magic) return this._data.getCompressedWorker();
        var x = this._decompressWorker();
        return this._dataBinary || (x = x.pipe(new l.Utf8EncodeWorker())), h.createWorkerFrom(x, g, b);
      }, _decompressWorker: function() {
        return this._data instanceof h ? this._data.getContentWorker() : this._data instanceof u ? this._data : new a(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++) s.prototype[d[f]] = p;
      i.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, r) {
      (function(s) {
        var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
        if (l) {
          var h = 0, u = new l(g), d = s.document.createTextNode("");
          u.observe(d, { characterData: !0 }), o = function() {
            d.data = h = ++h % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0) o = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
          var b = s.document.createElement("script");
          b.onreadystatechange = function() {
            g(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
          }, s.document.documentElement.appendChild(b);
        } : function() {
          setTimeout(g, 0);
        };
        else {
          var p = new s.MessageChannel();
          p.port1.onmessage = g, o = function() {
            p.port2.postMessage(0);
          };
        }
        var f = [];
        function g() {
          var b, x;
          a = !0;
          for (var y = f.length; y; ) {
            for (x = f, f = [], b = -1; ++b < y; ) x[b]();
            y = f.length;
          }
          a = !1;
        }
        i.exports = function(b) {
          f.push(b) !== 1 || a || o();
        };
      }).call(this, typeof ho < "u" ? ho : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, r) {
      var s = e("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], h = ["FULFILLED"], u = ["PENDING"];
      function d(y) {
        if (typeof y != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, y !== o && b(this, y);
      }
      function p(y, v, k) {
        this.promise = y, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof k == "function" && (this.onRejected = k, this.callRejected = this.otherCallRejected);
      }
      function f(y, v, k) {
        s(function() {
          var C;
          try {
            C = v(k);
          } catch (I) {
            return a.reject(y, I);
          }
          C === y ? a.reject(y, new TypeError("Cannot resolve promise with itself")) : a.resolve(y, C);
        });
      }
      function g(y) {
        var v = y && y.then;
        if (y && (typeof y == "object" || typeof y == "function") && typeof v == "function") return function() {
          v.apply(y, arguments);
        };
      }
      function b(y, v) {
        var k = !1;
        function C(E) {
          k || (k = !0, a.reject(y, E));
        }
        function I(E) {
          k || (k = !0, a.resolve(y, E));
        }
        var D = x(function() {
          v(I, C);
        });
        D.status === "error" && C(D.value);
      }
      function x(y, v) {
        var k = {};
        try {
          k.value = y(v), k.status = "success";
        } catch (C) {
          k.status = "error", k.value = C;
        }
        return k;
      }
      (i.exports = d).prototype.finally = function(y) {
        if (typeof y != "function") return this;
        var v = this.constructor;
        return this.then(function(k) {
          return v.resolve(y()).then(function() {
            return k;
          });
        }, function(k) {
          return v.resolve(y()).then(function() {
            throw k;
          });
        });
      }, d.prototype.catch = function(y) {
        return this.then(null, y);
      }, d.prototype.then = function(y, v) {
        if (typeof y != "function" && this.state === h || typeof v != "function" && this.state === l) return this;
        var k = new this.constructor(o);
        return this.state !== u ? f(k, this.state === h ? y : v, this.outcome) : this.queue.push(new p(k, y, v)), k;
      }, p.prototype.callFulfilled = function(y) {
        a.resolve(this.promise, y);
      }, p.prototype.otherCallFulfilled = function(y) {
        f(this.promise, this.onFulfilled, y);
      }, p.prototype.callRejected = function(y) {
        a.reject(this.promise, y);
      }, p.prototype.otherCallRejected = function(y) {
        f(this.promise, this.onRejected, y);
      }, a.resolve = function(y, v) {
        var k = x(g, v);
        if (k.status === "error") return a.reject(y, k.value);
        var C = k.value;
        if (C) b(y, C);
        else {
          y.state = h, y.outcome = v;
          for (var I = -1, D = y.queue.length; ++I < D; ) y.queue[I].callFulfilled(v);
        }
        return y;
      }, a.reject = function(y, v) {
        y.state = l, y.outcome = v;
        for (var k = -1, C = y.queue.length; ++k < C; ) y.queue[k].callRejected(v);
        return y;
      }, d.resolve = function(y) {
        return y instanceof this ? y : a.resolve(new this(o), y);
      }, d.reject = function(y) {
        var v = new this(o);
        return a.reject(v, y);
      }, d.all = function(y) {
        var v = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var k = y.length, C = !1;
        if (!k) return this.resolve([]);
        for (var I = new Array(k), D = 0, E = -1, O = new this(o); ++E < k; ) M(y[E], E);
        return O;
        function M(q, P) {
          v.resolve(q).then(function(A) {
            I[P] = A, ++D !== k || C || (C = !0, a.resolve(O, I));
          }, function(A) {
            C || (C = !0, a.reject(O, A));
          });
        }
      }, d.race = function(y) {
        var v = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var k = y.length, C = !1;
        if (!k) return this.resolve([]);
        for (var I = -1, D = new this(o); ++I < k; ) E = y[I], v.resolve(E).then(function(O) {
          C || (C = !0, a.resolve(D, O));
        }, function(O) {
          C || (C = !0, a.reject(D, O));
        });
        var E;
        return D;
      };
    }, { immediate: 36 }], 38: [function(e, i, r) {
      var s = {};
      (0, e("./lib/utils/common").assign)(s, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, r) {
      var s = e("./zlib/deflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/messages"), h = e("./zlib/zstream"), u = Object.prototype.toString, d = 0, p = -1, f = 0, g = 8;
      function b(y) {
        if (!(this instanceof b)) return new b(y);
        this.options = o.assign({ level: p, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, y || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var k = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (k !== d) throw new Error(l[k]);
        if (v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var C;
          if (C = typeof v.dictionary == "string" ? a.string2buf(v.dictionary) : u.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (k = s.deflateSetDictionary(this.strm, C)) !== d) throw new Error(l[k]);
          this._dict_set = !0;
        }
      }
      function x(y, v) {
        var k = new b(v);
        if (k.push(y, !0), k.err) throw k.msg || l[k.err];
        return k.result;
      }
      b.prototype.push = function(y, v) {
        var k, C, I = this.strm, D = this.options.chunkSize;
        if (this.ended) return !1;
        C = v === ~~v ? v : v === !0 ? 4 : 0, typeof y == "string" ? I.input = a.string2buf(y) : u.call(y) === "[object ArrayBuffer]" ? I.input = new Uint8Array(y) : I.input = y, I.next_in = 0, I.avail_in = I.input.length;
        do {
          if (I.avail_out === 0 && (I.output = new o.Buf8(D), I.next_out = 0, I.avail_out = D), (k = s.deflate(I, C)) !== 1 && k !== d) return this.onEnd(k), !(this.ended = !0);
          I.avail_out !== 0 && (I.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(I.output, I.next_out))) : this.onData(o.shrinkBuf(I.output, I.next_out)));
        } while ((0 < I.avail_in || I.avail_out === 0) && k !== 1);
        return C === 4 ? (k = s.deflateEnd(this.strm), this.onEnd(k), this.ended = !0, k === d) : C !== 2 || (this.onEnd(d), !(I.avail_out = 0));
      }, b.prototype.onData = function(y) {
        this.chunks.push(y);
      }, b.prototype.onEnd = function(y) {
        y === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, r.Deflate = b, r.deflate = x, r.deflateRaw = function(y, v) {
        return (v = v || {}).raw = !0, x(y, v);
      }, r.gzip = function(y, v) {
        return (v = v || {}).gzip = !0, x(y, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, r) {
      var s = e("./zlib/inflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/constants"), h = e("./zlib/messages"), u = e("./zlib/zstream"), d = e("./zlib/gzheader"), p = Object.prototype.toString;
      function f(b) {
        if (!(this instanceof f)) return new f(b);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
        var x = this.options;
        x.raw && 0 <= x.windowBits && x.windowBits < 16 && (x.windowBits = -x.windowBits, x.windowBits === 0 && (x.windowBits = -15)), !(0 <= x.windowBits && x.windowBits < 16) || b && b.windowBits || (x.windowBits += 32), 15 < x.windowBits && x.windowBits < 48 && !(15 & x.windowBits) && (x.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var y = s.inflateInit2(this.strm, x.windowBits);
        if (y !== l.Z_OK) throw new Error(h[y]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      function g(b, x) {
        var y = new f(x);
        if (y.push(b, !0), y.err) throw y.msg || h[y.err];
        return y.result;
      }
      f.prototype.push = function(b, x) {
        var y, v, k, C, I, D, E = this.strm, O = this.options.chunkSize, M = this.options.dictionary, q = !1;
        if (this.ended) return !1;
        v = x === ~~x ? x : x === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof b == "string" ? E.input = a.binstring2buf(b) : p.call(b) === "[object ArrayBuffer]" ? E.input = new Uint8Array(b) : E.input = b, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new o.Buf8(O), E.next_out = 0, E.avail_out = O), (y = s.inflate(E, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && M && (D = typeof M == "string" ? a.string2buf(M) : p.call(M) === "[object ArrayBuffer]" ? new Uint8Array(M) : M, y = s.inflateSetDictionary(this.strm, D)), y === l.Z_BUF_ERROR && q === !0 && (y = l.Z_OK, q = !1), y !== l.Z_STREAM_END && y !== l.Z_OK) return this.onEnd(y), !(this.ended = !0);
          E.next_out && (E.avail_out !== 0 && y !== l.Z_STREAM_END && (E.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (k = a.utf8border(E.output, E.next_out), C = E.next_out - k, I = a.buf2string(E.output, k), E.next_out = C, E.avail_out = O - C, C && o.arraySet(E.output, E.output, k, C, 0), this.onData(I)) : this.onData(o.shrinkBuf(E.output, E.next_out)))), E.avail_in === 0 && E.avail_out === 0 && (q = !0);
        } while ((0 < E.avail_in || E.avail_out === 0) && y !== l.Z_STREAM_END);
        return y === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (y = s.inflateEnd(this.strm), this.onEnd(y), this.ended = !0, y === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(E.avail_out = 0));
      }, f.prototype.onData = function(b) {
        this.chunks.push(b);
      }, f.prototype.onEnd = function(b) {
        b === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, r.Inflate = f, r.inflate = g, r.inflateRaw = function(b, x) {
        return (x = x || {}).raw = !0, g(b, x);
      }, r.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      r.assign = function(l) {
        for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
          var u = h.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var d in u) u.hasOwnProperty(d) && (l[d] = u[d]);
          }
        }
        return l;
      }, r.shrinkBuf = function(l, h) {
        return l.length === h ? l : l.subarray ? l.subarray(0, h) : (l.length = h, l);
      };
      var o = { arraySet: function(l, h, u, d, p) {
        if (h.subarray && l.subarray) l.set(h.subarray(u, u + d), p);
        else for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        var h, u, d, p, f, g;
        for (h = d = 0, u = l.length; h < u; h++) d += l[h].length;
        for (g = new Uint8Array(d), h = p = 0, u = l.length; h < u; h++) f = l[h], g.set(f, p), p += f.length;
        return g;
      } }, a = { arraySet: function(l, h, u, d, p) {
        for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      r.setTyped = function(l) {
        l ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, a));
      }, r.setTyped(s);
    }, {}], 42: [function(e, i, r) {
      var s = e("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), h = 0; h < 256; h++) l[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      function u(d, p) {
        if (p < 65537 && (d.subarray && a || !d.subarray && o)) return String.fromCharCode.apply(null, s.shrinkBuf(d, p));
        for (var f = "", g = 0; g < p; g++) f += String.fromCharCode(d[g]);
        return f;
      }
      l[254] = l[254] = 1, r.string2buf = function(d) {
        var p, f, g, b, x, y = d.length, v = 0;
        for (b = 0; b < y; b++) (64512 & (f = d.charCodeAt(b))) == 55296 && b + 1 < y && (64512 & (g = d.charCodeAt(b + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), b++), v += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (p = new s.Buf8(v), b = x = 0; x < v; b++) (64512 & (f = d.charCodeAt(b))) == 55296 && b + 1 < y && (64512 & (g = d.charCodeAt(b + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), b++), f < 128 ? p[x++] = f : (f < 2048 ? p[x++] = 192 | f >>> 6 : (f < 65536 ? p[x++] = 224 | f >>> 12 : (p[x++] = 240 | f >>> 18, p[x++] = 128 | f >>> 12 & 63), p[x++] = 128 | f >>> 6 & 63), p[x++] = 128 | 63 & f);
        return p;
      }, r.buf2binstring = function(d) {
        return u(d, d.length);
      }, r.binstring2buf = function(d) {
        for (var p = new s.Buf8(d.length), f = 0, g = p.length; f < g; f++) p[f] = d.charCodeAt(f);
        return p;
      }, r.buf2string = function(d, p) {
        var f, g, b, x, y = p || d.length, v = new Array(2 * y);
        for (f = g = 0; f < y; ) if ((b = d[f++]) < 128) v[g++] = b;
        else if (4 < (x = l[b])) v[g++] = 65533, f += x - 1;
        else {
          for (b &= x === 2 ? 31 : x === 3 ? 15 : 7; 1 < x && f < y; ) b = b << 6 | 63 & d[f++], x--;
          1 < x ? v[g++] = 65533 : b < 65536 ? v[g++] = b : (b -= 65536, v[g++] = 55296 | b >> 10 & 1023, v[g++] = 56320 | 1023 & b);
        }
        return u(v, g);
      }, r.utf8border = function(d, p) {
        var f;
        for ((p = p || d.length) > d.length && (p = d.length), f = p - 1; 0 <= f && (192 & d[f]) == 128; ) f--;
        return f < 0 || f === 0 ? p : f + l[d[f]] > p ? f : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, r) {
      i.exports = function(s, o, a, l) {
        for (var h = 65535 & s | 0, u = s >>> 16 & 65535 | 0, d = 0; a !== 0; ) {
          for (a -= d = 2e3 < a ? 2e3 : a; u = u + (h = h + o[l++] | 0) | 0, --d; ) ;
          h %= 65521, u %= 65521;
        }
        return h | u << 16 | 0;
      };
    }, {}], 44: [function(e, i, r) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, r) {
      var s = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var h = 0; h < 8; h++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, h) {
        var u = s, d = h + l;
        o ^= -1;
        for (var p = h; p < d; p++) o = o >>> 8 ^ u[255 & (o ^ a[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, r) {
      var s, o = e("../utils/common"), a = e("./trees"), l = e("./adler32"), h = e("./crc32"), u = e("./messages"), d = 0, p = 4, f = 0, g = -2, b = -1, x = 4, y = 2, v = 8, k = 9, C = 286, I = 30, D = 19, E = 2 * C + 1, O = 15, M = 3, q = 258, P = q + M + 1, A = 42, F = 113, _ = 1, J = 2, V = 3, R = 4;
      function tt(T, ht) {
        return T.msg = u[ht], ht;
      }
      function H(T) {
        return (T << 1) - (4 < T ? 9 : 0);
      }
      function ct(T) {
        for (var ht = T.length; 0 <= --ht; ) T[ht] = 0;
      }
      function it(T) {
        var ht = T.state, $ = ht.pending;
        $ > T.avail_out && ($ = T.avail_out), $ !== 0 && (o.arraySet(T.output, ht.pending_buf, ht.pending_out, $, T.next_out), T.next_out += $, ht.pending_out += $, T.total_out += $, T.avail_out -= $, ht.pending -= $, ht.pending === 0 && (ht.pending_out = 0));
      }
      function N(T, ht) {
        a._tr_flush_block(T, 0 <= T.block_start ? T.block_start : -1, T.strstart - T.block_start, ht), T.block_start = T.strstart, it(T.strm);
      }
      function z(T, ht) {
        T.pending_buf[T.pending++] = ht;
      }
      function G(T, ht) {
        T.pending_buf[T.pending++] = ht >>> 8 & 255, T.pending_buf[T.pending++] = 255 & ht;
      }
      function Y(T, ht) {
        var $, nt, X = T.max_chain_length, st = T.strstart, vt = T.prev_length, St = T.nice_match, ft = T.strstart > T.w_size - P ? T.strstart - (T.w_size - P) : 0, Et = T.window, zt = T.w_mask, Tt = T.prev, $t = T.strstart + q, te = Et[st + vt - 1], oe = Et[st + vt];
        T.prev_length >= T.good_match && (X >>= 2), St > T.lookahead && (St = T.lookahead);
        do
          if (Et[($ = ht) + vt] === oe && Et[$ + vt - 1] === te && Et[$] === Et[st] && Et[++$] === Et[st + 1]) {
            st += 2, $++;
            do
              ;
            while (Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && st < $t);
            if (nt = q - ($t - st), st = $t - q, vt < nt) {
              if (T.match_start = ht, St <= (vt = nt)) break;
              te = Et[st + vt - 1], oe = Et[st + vt];
            }
          }
        while ((ht = Tt[ht & zt]) > ft && --X != 0);
        return vt <= T.lookahead ? vt : T.lookahead;
      }
      function ot(T) {
        var ht, $, nt, X, st, vt, St, ft, Et, zt, Tt = T.w_size;
        do {
          if (X = T.window_size - T.lookahead - T.strstart, T.strstart >= Tt + (Tt - P)) {
            for (o.arraySet(T.window, T.window, Tt, Tt, 0), T.match_start -= Tt, T.strstart -= Tt, T.block_start -= Tt, ht = $ = T.hash_size; nt = T.head[--ht], T.head[ht] = Tt <= nt ? nt - Tt : 0, --$; ) ;
            for (ht = $ = Tt; nt = T.prev[--ht], T.prev[ht] = Tt <= nt ? nt - Tt : 0, --$; ) ;
            X += Tt;
          }
          if (T.strm.avail_in === 0) break;
          if (vt = T.strm, St = T.window, ft = T.strstart + T.lookahead, Et = X, zt = void 0, zt = vt.avail_in, Et < zt && (zt = Et), $ = zt === 0 ? 0 : (vt.avail_in -= zt, o.arraySet(St, vt.input, vt.next_in, zt, ft), vt.state.wrap === 1 ? vt.adler = l(vt.adler, St, zt, ft) : vt.state.wrap === 2 && (vt.adler = h(vt.adler, St, zt, ft)), vt.next_in += zt, vt.total_in += zt, zt), T.lookahead += $, T.lookahead + T.insert >= M) for (st = T.strstart - T.insert, T.ins_h = T.window[st], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[st + 1]) & T.hash_mask; T.insert && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[st + M - 1]) & T.hash_mask, T.prev[st & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = st, st++, T.insert--, !(T.lookahead + T.insert < M)); ) ;
        } while (T.lookahead < P && T.strm.avail_in !== 0);
      }
      function xt(T, ht) {
        for (var $, nt; ; ) {
          if (T.lookahead < P) {
            if (ot(T), T.lookahead < P && ht === d) return _;
            if (T.lookahead === 0) break;
          }
          if ($ = 0, T.lookahead >= M && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + M - 1]) & T.hash_mask, $ = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), $ !== 0 && T.strstart - $ <= T.w_size - P && (T.match_length = Y(T, $)), T.match_length >= M) if (nt = a._tr_tally(T, T.strstart - T.match_start, T.match_length - M), T.lookahead -= T.match_length, T.match_length <= T.max_lazy_match && T.lookahead >= M) {
            for (T.match_length--; T.strstart++, T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + M - 1]) & T.hash_mask, $ = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart, --T.match_length != 0; ) ;
            T.strstart++;
          } else T.strstart += T.match_length, T.match_length = 0, T.ins_h = T.window[T.strstart], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + 1]) & T.hash_mask;
          else nt = a._tr_tally(T, 0, T.window[T.strstart]), T.lookahead--, T.strstart++;
          if (nt && (N(T, !1), T.strm.avail_out === 0)) return _;
        }
        return T.insert = T.strstart < M - 1 ? T.strstart : M - 1, ht === p ? (N(T, !0), T.strm.avail_out === 0 ? V : R) : T.last_lit && (N(T, !1), T.strm.avail_out === 0) ? _ : J;
      }
      function gt(T, ht) {
        for (var $, nt, X; ; ) {
          if (T.lookahead < P) {
            if (ot(T), T.lookahead < P && ht === d) return _;
            if (T.lookahead === 0) break;
          }
          if ($ = 0, T.lookahead >= M && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + M - 1]) & T.hash_mask, $ = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), T.prev_length = T.match_length, T.prev_match = T.match_start, T.match_length = M - 1, $ !== 0 && T.prev_length < T.max_lazy_match && T.strstart - $ <= T.w_size - P && (T.match_length = Y(T, $), T.match_length <= 5 && (T.strategy === 1 || T.match_length === M && 4096 < T.strstart - T.match_start) && (T.match_length = M - 1)), T.prev_length >= M && T.match_length <= T.prev_length) {
            for (X = T.strstart + T.lookahead - M, nt = a._tr_tally(T, T.strstart - 1 - T.prev_match, T.prev_length - M), T.lookahead -= T.prev_length - 1, T.prev_length -= 2; ++T.strstart <= X && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + M - 1]) & T.hash_mask, $ = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), --T.prev_length != 0; ) ;
            if (T.match_available = 0, T.match_length = M - 1, T.strstart++, nt && (N(T, !1), T.strm.avail_out === 0)) return _;
          } else if (T.match_available) {
            if ((nt = a._tr_tally(T, 0, T.window[T.strstart - 1])) && N(T, !1), T.strstart++, T.lookahead--, T.strm.avail_out === 0) return _;
          } else T.match_available = 1, T.strstart++, T.lookahead--;
        }
        return T.match_available && (nt = a._tr_tally(T, 0, T.window[T.strstart - 1]), T.match_available = 0), T.insert = T.strstart < M - 1 ? T.strstart : M - 1, ht === p ? (N(T, !0), T.strm.avail_out === 0 ? V : R) : T.last_lit && (N(T, !1), T.strm.avail_out === 0) ? _ : J;
      }
      function wt(T, ht, $, nt, X) {
        this.good_length = T, this.max_lazy = ht, this.nice_length = $, this.max_chain = nt, this.func = X;
      }
      function qt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * E), this.dyn_dtree = new o.Buf16(2 * (2 * I + 1)), this.bl_tree = new o.Buf16(2 * (2 * D + 1)), ct(this.dyn_ltree), ct(this.dyn_dtree), ct(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(O + 1), this.heap = new o.Buf16(2 * C + 1), ct(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * C + 1), ct(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Rt(T) {
        var ht;
        return T && T.state ? (T.total_in = T.total_out = 0, T.data_type = y, (ht = T.state).pending = 0, ht.pending_out = 0, ht.wrap < 0 && (ht.wrap = -ht.wrap), ht.status = ht.wrap ? A : F, T.adler = ht.wrap === 2 ? 0 : 1, ht.last_flush = d, a._tr_init(ht), f) : tt(T, g);
      }
      function Yt(T) {
        var ht = Rt(T);
        return ht === f && function($) {
          $.window_size = 2 * $.w_size, ct($.head), $.max_lazy_match = s[$.level].max_lazy, $.good_match = s[$.level].good_length, $.nice_match = s[$.level].nice_length, $.max_chain_length = s[$.level].max_chain, $.strstart = 0, $.block_start = 0, $.lookahead = 0, $.insert = 0, $.match_length = $.prev_length = M - 1, $.match_available = 0, $.ins_h = 0;
        }(T.state), ht;
      }
      function Kt(T, ht, $, nt, X, st) {
        if (!T) return g;
        var vt = 1;
        if (ht === b && (ht = 6), nt < 0 ? (vt = 0, nt = -nt) : 15 < nt && (vt = 2, nt -= 16), X < 1 || k < X || $ !== v || nt < 8 || 15 < nt || ht < 0 || 9 < ht || st < 0 || x < st) return tt(T, g);
        nt === 8 && (nt = 9);
        var St = new qt();
        return (T.state = St).strm = T, St.wrap = vt, St.gzhead = null, St.w_bits = nt, St.w_size = 1 << St.w_bits, St.w_mask = St.w_size - 1, St.hash_bits = X + 7, St.hash_size = 1 << St.hash_bits, St.hash_mask = St.hash_size - 1, St.hash_shift = ~~((St.hash_bits + M - 1) / M), St.window = new o.Buf8(2 * St.w_size), St.head = new o.Buf16(St.hash_size), St.prev = new o.Buf16(St.w_size), St.lit_bufsize = 1 << X + 6, St.pending_buf_size = 4 * St.lit_bufsize, St.pending_buf = new o.Buf8(St.pending_buf_size), St.d_buf = 1 * St.lit_bufsize, St.l_buf = 3 * St.lit_bufsize, St.level = ht, St.strategy = st, St.method = $, Yt(T);
      }
      s = [new wt(0, 0, 0, 0, function(T, ht) {
        var $ = 65535;
        for ($ > T.pending_buf_size - 5 && ($ = T.pending_buf_size - 5); ; ) {
          if (T.lookahead <= 1) {
            if (ot(T), T.lookahead === 0 && ht === d) return _;
            if (T.lookahead === 0) break;
          }
          T.strstart += T.lookahead, T.lookahead = 0;
          var nt = T.block_start + $;
          if ((T.strstart === 0 || T.strstart >= nt) && (T.lookahead = T.strstart - nt, T.strstart = nt, N(T, !1), T.strm.avail_out === 0) || T.strstart - T.block_start >= T.w_size - P && (N(T, !1), T.strm.avail_out === 0)) return _;
        }
        return T.insert = 0, ht === p ? (N(T, !0), T.strm.avail_out === 0 ? V : R) : (T.strstart > T.block_start && (N(T, !1), T.strm.avail_out), _);
      }), new wt(4, 4, 8, 4, xt), new wt(4, 5, 16, 8, xt), new wt(4, 6, 32, 32, xt), new wt(4, 4, 16, 16, gt), new wt(8, 16, 32, 32, gt), new wt(8, 16, 128, 128, gt), new wt(8, 32, 128, 256, gt), new wt(32, 128, 258, 1024, gt), new wt(32, 258, 258, 4096, gt)], r.deflateInit = function(T, ht) {
        return Kt(T, ht, v, 15, 8, 0);
      }, r.deflateInit2 = Kt, r.deflateReset = Yt, r.deflateResetKeep = Rt, r.deflateSetHeader = function(T, ht) {
        return T && T.state ? T.state.wrap !== 2 ? g : (T.state.gzhead = ht, f) : g;
      }, r.deflate = function(T, ht) {
        var $, nt, X, st;
        if (!T || !T.state || 5 < ht || ht < 0) return T ? tt(T, g) : g;
        if (nt = T.state, !T.output || !T.input && T.avail_in !== 0 || nt.status === 666 && ht !== p) return tt(T, T.avail_out === 0 ? -5 : g);
        if (nt.strm = T, $ = nt.last_flush, nt.last_flush = ht, nt.status === A) if (nt.wrap === 2) T.adler = 0, z(nt, 31), z(nt, 139), z(nt, 8), nt.gzhead ? (z(nt, (nt.gzhead.text ? 1 : 0) + (nt.gzhead.hcrc ? 2 : 0) + (nt.gzhead.extra ? 4 : 0) + (nt.gzhead.name ? 8 : 0) + (nt.gzhead.comment ? 16 : 0)), z(nt, 255 & nt.gzhead.time), z(nt, nt.gzhead.time >> 8 & 255), z(nt, nt.gzhead.time >> 16 & 255), z(nt, nt.gzhead.time >> 24 & 255), z(nt, nt.level === 9 ? 2 : 2 <= nt.strategy || nt.level < 2 ? 4 : 0), z(nt, 255 & nt.gzhead.os), nt.gzhead.extra && nt.gzhead.extra.length && (z(nt, 255 & nt.gzhead.extra.length), z(nt, nt.gzhead.extra.length >> 8 & 255)), nt.gzhead.hcrc && (T.adler = h(T.adler, nt.pending_buf, nt.pending, 0)), nt.gzindex = 0, nt.status = 69) : (z(nt, 0), z(nt, 0), z(nt, 0), z(nt, 0), z(nt, 0), z(nt, nt.level === 9 ? 2 : 2 <= nt.strategy || nt.level < 2 ? 4 : 0), z(nt, 3), nt.status = F);
        else {
          var vt = v + (nt.w_bits - 8 << 4) << 8;
          vt |= (2 <= nt.strategy || nt.level < 2 ? 0 : nt.level < 6 ? 1 : nt.level === 6 ? 2 : 3) << 6, nt.strstart !== 0 && (vt |= 32), vt += 31 - vt % 31, nt.status = F, G(nt, vt), nt.strstart !== 0 && (G(nt, T.adler >>> 16), G(nt, 65535 & T.adler)), T.adler = 1;
        }
        if (nt.status === 69) if (nt.gzhead.extra) {
          for (X = nt.pending; nt.gzindex < (65535 & nt.gzhead.extra.length) && (nt.pending !== nt.pending_buf_size || (nt.gzhead.hcrc && nt.pending > X && (T.adler = h(T.adler, nt.pending_buf, nt.pending - X, X)), it(T), X = nt.pending, nt.pending !== nt.pending_buf_size)); ) z(nt, 255 & nt.gzhead.extra[nt.gzindex]), nt.gzindex++;
          nt.gzhead.hcrc && nt.pending > X && (T.adler = h(T.adler, nt.pending_buf, nt.pending - X, X)), nt.gzindex === nt.gzhead.extra.length && (nt.gzindex = 0, nt.status = 73);
        } else nt.status = 73;
        if (nt.status === 73) if (nt.gzhead.name) {
          X = nt.pending;
          do {
            if (nt.pending === nt.pending_buf_size && (nt.gzhead.hcrc && nt.pending > X && (T.adler = h(T.adler, nt.pending_buf, nt.pending - X, X)), it(T), X = nt.pending, nt.pending === nt.pending_buf_size)) {
              st = 1;
              break;
            }
            st = nt.gzindex < nt.gzhead.name.length ? 255 & nt.gzhead.name.charCodeAt(nt.gzindex++) : 0, z(nt, st);
          } while (st !== 0);
          nt.gzhead.hcrc && nt.pending > X && (T.adler = h(T.adler, nt.pending_buf, nt.pending - X, X)), st === 0 && (nt.gzindex = 0, nt.status = 91);
        } else nt.status = 91;
        if (nt.status === 91) if (nt.gzhead.comment) {
          X = nt.pending;
          do {
            if (nt.pending === nt.pending_buf_size && (nt.gzhead.hcrc && nt.pending > X && (T.adler = h(T.adler, nt.pending_buf, nt.pending - X, X)), it(T), X = nt.pending, nt.pending === nt.pending_buf_size)) {
              st = 1;
              break;
            }
            st = nt.gzindex < nt.gzhead.comment.length ? 255 & nt.gzhead.comment.charCodeAt(nt.gzindex++) : 0, z(nt, st);
          } while (st !== 0);
          nt.gzhead.hcrc && nt.pending > X && (T.adler = h(T.adler, nt.pending_buf, nt.pending - X, X)), st === 0 && (nt.status = 103);
        } else nt.status = 103;
        if (nt.status === 103 && (nt.gzhead.hcrc ? (nt.pending + 2 > nt.pending_buf_size && it(T), nt.pending + 2 <= nt.pending_buf_size && (z(nt, 255 & T.adler), z(nt, T.adler >> 8 & 255), T.adler = 0, nt.status = F)) : nt.status = F), nt.pending !== 0) {
          if (it(T), T.avail_out === 0) return nt.last_flush = -1, f;
        } else if (T.avail_in === 0 && H(ht) <= H($) && ht !== p) return tt(T, -5);
        if (nt.status === 666 && T.avail_in !== 0) return tt(T, -5);
        if (T.avail_in !== 0 || nt.lookahead !== 0 || ht !== d && nt.status !== 666) {
          var St = nt.strategy === 2 ? function(ft, Et) {
            for (var zt; ; ) {
              if (ft.lookahead === 0 && (ot(ft), ft.lookahead === 0)) {
                if (Et === d) return _;
                break;
              }
              if (ft.match_length = 0, zt = a._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++, zt && (N(ft, !1), ft.strm.avail_out === 0)) return _;
            }
            return ft.insert = 0, Et === p ? (N(ft, !0), ft.strm.avail_out === 0 ? V : R) : ft.last_lit && (N(ft, !1), ft.strm.avail_out === 0) ? _ : J;
          }(nt, ht) : nt.strategy === 3 ? function(ft, Et) {
            for (var zt, Tt, $t, te, oe = ft.window; ; ) {
              if (ft.lookahead <= q) {
                if (ot(ft), ft.lookahead <= q && Et === d) return _;
                if (ft.lookahead === 0) break;
              }
              if (ft.match_length = 0, ft.lookahead >= M && 0 < ft.strstart && (Tt = oe[$t = ft.strstart - 1]) === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t]) {
                te = ft.strstart + q;
                do
                  ;
                while (Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && $t < te);
                ft.match_length = q - (te - $t), ft.match_length > ft.lookahead && (ft.match_length = ft.lookahead);
              }
              if (ft.match_length >= M ? (zt = a._tr_tally(ft, 1, ft.match_length - M), ft.lookahead -= ft.match_length, ft.strstart += ft.match_length, ft.match_length = 0) : (zt = a._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++), zt && (N(ft, !1), ft.strm.avail_out === 0)) return _;
            }
            return ft.insert = 0, Et === p ? (N(ft, !0), ft.strm.avail_out === 0 ? V : R) : ft.last_lit && (N(ft, !1), ft.strm.avail_out === 0) ? _ : J;
          }(nt, ht) : s[nt.level].func(nt, ht);
          if (St !== V && St !== R || (nt.status = 666), St === _ || St === V) return T.avail_out === 0 && (nt.last_flush = -1), f;
          if (St === J && (ht === 1 ? a._tr_align(nt) : ht !== 5 && (a._tr_stored_block(nt, 0, 0, !1), ht === 3 && (ct(nt.head), nt.lookahead === 0 && (nt.strstart = 0, nt.block_start = 0, nt.insert = 0))), it(T), T.avail_out === 0)) return nt.last_flush = -1, f;
        }
        return ht !== p ? f : nt.wrap <= 0 ? 1 : (nt.wrap === 2 ? (z(nt, 255 & T.adler), z(nt, T.adler >> 8 & 255), z(nt, T.adler >> 16 & 255), z(nt, T.adler >> 24 & 255), z(nt, 255 & T.total_in), z(nt, T.total_in >> 8 & 255), z(nt, T.total_in >> 16 & 255), z(nt, T.total_in >> 24 & 255)) : (G(nt, T.adler >>> 16), G(nt, 65535 & T.adler)), it(T), 0 < nt.wrap && (nt.wrap = -nt.wrap), nt.pending !== 0 ? f : 1);
      }, r.deflateEnd = function(T) {
        var ht;
        return T && T.state ? (ht = T.state.status) !== A && ht !== 69 && ht !== 73 && ht !== 91 && ht !== 103 && ht !== F && ht !== 666 ? tt(T, g) : (T.state = null, ht === F ? tt(T, -3) : f) : g;
      }, r.deflateSetDictionary = function(T, ht) {
        var $, nt, X, st, vt, St, ft, Et, zt = ht.length;
        if (!T || !T.state || (st = ($ = T.state).wrap) === 2 || st === 1 && $.status !== A || $.lookahead) return g;
        for (st === 1 && (T.adler = l(T.adler, ht, zt, 0)), $.wrap = 0, zt >= $.w_size && (st === 0 && (ct($.head), $.strstart = 0, $.block_start = 0, $.insert = 0), Et = new o.Buf8($.w_size), o.arraySet(Et, ht, zt - $.w_size, $.w_size, 0), ht = Et, zt = $.w_size), vt = T.avail_in, St = T.next_in, ft = T.input, T.avail_in = zt, T.next_in = 0, T.input = ht, ot($); $.lookahead >= M; ) {
          for (nt = $.strstart, X = $.lookahead - (M - 1); $.ins_h = ($.ins_h << $.hash_shift ^ $.window[nt + M - 1]) & $.hash_mask, $.prev[nt & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = nt, nt++, --X; ) ;
          $.strstart = nt, $.lookahead = M - 1, ot($);
        }
        return $.strstart += $.lookahead, $.block_start = $.strstart, $.insert = $.lookahead, $.lookahead = 0, $.match_length = $.prev_length = M - 1, $.match_available = 0, T.next_in = St, T.input = ft, T.avail_in = vt, $.wrap = st, f;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, r) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, r) {
      i.exports = function(s, o) {
        var a, l, h, u, d, p, f, g, b, x, y, v, k, C, I, D, E, O, M, q, P, A, F, _, J;
        a = s.state, l = s.next_in, _ = s.input, h = l + (s.avail_in - 5), u = s.next_out, J = s.output, d = u - (o - s.avail_out), p = u + (s.avail_out - 257), f = a.dmax, g = a.wsize, b = a.whave, x = a.wnext, y = a.window, v = a.hold, k = a.bits, C = a.lencode, I = a.distcode, D = (1 << a.lenbits) - 1, E = (1 << a.distbits) - 1;
        t: do {
          k < 15 && (v += _[l++] << k, k += 8, v += _[l++] << k, k += 8), O = C[v & D];
          e: for (; ; ) {
            if (v >>>= M = O >>> 24, k -= M, (M = O >>> 16 & 255) === 0) J[u++] = 65535 & O;
            else {
              if (!(16 & M)) {
                if (!(64 & M)) {
                  O = C[(65535 & O) + (v & (1 << M) - 1)];
                  continue e;
                }
                if (32 & M) {
                  a.mode = 12;
                  break t;
                }
                s.msg = "invalid literal/length code", a.mode = 30;
                break t;
              }
              q = 65535 & O, (M &= 15) && (k < M && (v += _[l++] << k, k += 8), q += v & (1 << M) - 1, v >>>= M, k -= M), k < 15 && (v += _[l++] << k, k += 8, v += _[l++] << k, k += 8), O = I[v & E];
              n: for (; ; ) {
                if (v >>>= M = O >>> 24, k -= M, !(16 & (M = O >>> 16 & 255))) {
                  if (!(64 & M)) {
                    O = I[(65535 & O) + (v & (1 << M) - 1)];
                    continue n;
                  }
                  s.msg = "invalid distance code", a.mode = 30;
                  break t;
                }
                if (P = 65535 & O, k < (M &= 15) && (v += _[l++] << k, (k += 8) < M && (v += _[l++] << k, k += 8)), f < (P += v & (1 << M) - 1)) {
                  s.msg = "invalid distance too far back", a.mode = 30;
                  break t;
                }
                if (v >>>= M, k -= M, (M = u - d) < P) {
                  if (b < (M = P - M) && a.sane) {
                    s.msg = "invalid distance too far back", a.mode = 30;
                    break t;
                  }
                  if (F = y, (A = 0) === x) {
                    if (A += g - M, M < q) {
                      for (q -= M; J[u++] = y[A++], --M; ) ;
                      A = u - P, F = J;
                    }
                  } else if (x < M) {
                    if (A += g + x - M, (M -= x) < q) {
                      for (q -= M; J[u++] = y[A++], --M; ) ;
                      if (A = 0, x < q) {
                        for (q -= M = x; J[u++] = y[A++], --M; ) ;
                        A = u - P, F = J;
                      }
                    }
                  } else if (A += x - M, M < q) {
                    for (q -= M; J[u++] = y[A++], --M; ) ;
                    A = u - P, F = J;
                  }
                  for (; 2 < q; ) J[u++] = F[A++], J[u++] = F[A++], J[u++] = F[A++], q -= 3;
                  q && (J[u++] = F[A++], 1 < q && (J[u++] = F[A++]));
                } else {
                  for (A = u - P; J[u++] = J[A++], J[u++] = J[A++], J[u++] = J[A++], 2 < (q -= 3); ) ;
                  q && (J[u++] = J[A++], 1 < q && (J[u++] = J[A++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < h && u < p);
        l -= q = k >> 3, v &= (1 << (k -= q << 3)) - 1, s.next_in = l, s.next_out = u, s.avail_in = l < h ? h - l + 5 : 5 - (l - h), s.avail_out = u < p ? p - u + 257 : 257 - (u - p), a.hold = v, a.bits = k;
      };
    }, {}], 49: [function(e, i, r) {
      var s = e("../utils/common"), o = e("./adler32"), a = e("./crc32"), l = e("./inffast"), h = e("./inftrees"), u = 1, d = 2, p = 0, f = -2, g = 1, b = 852, x = 592;
      function y(A) {
        return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((65280 & A) << 8) + ((255 & A) << 24);
      }
      function v() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function k(A) {
        var F;
        return A && A.state ? (F = A.state, A.total_in = A.total_out = F.total = 0, A.msg = "", F.wrap && (A.adler = 1 & F.wrap), F.mode = g, F.last = 0, F.havedict = 0, F.dmax = 32768, F.head = null, F.hold = 0, F.bits = 0, F.lencode = F.lendyn = new s.Buf32(b), F.distcode = F.distdyn = new s.Buf32(x), F.sane = 1, F.back = -1, p) : f;
      }
      function C(A) {
        var F;
        return A && A.state ? ((F = A.state).wsize = 0, F.whave = 0, F.wnext = 0, k(A)) : f;
      }
      function I(A, F) {
        var _, J;
        return A && A.state ? (J = A.state, F < 0 ? (_ = 0, F = -F) : (_ = 1 + (F >> 4), F < 48 && (F &= 15)), F && (F < 8 || 15 < F) ? f : (J.window !== null && J.wbits !== F && (J.window = null), J.wrap = _, J.wbits = F, C(A))) : f;
      }
      function D(A, F) {
        var _, J;
        return A ? (J = new v(), (A.state = J).window = null, (_ = I(A, F)) !== p && (A.state = null), _) : f;
      }
      var E, O, M = !0;
      function q(A) {
        if (M) {
          var F;
          for (E = new s.Buf32(512), O = new s.Buf32(32), F = 0; F < 144; ) A.lens[F++] = 8;
          for (; F < 256; ) A.lens[F++] = 9;
          for (; F < 280; ) A.lens[F++] = 7;
          for (; F < 288; ) A.lens[F++] = 8;
          for (h(u, A.lens, 0, 288, E, 0, A.work, { bits: 9 }), F = 0; F < 32; ) A.lens[F++] = 5;
          h(d, A.lens, 0, 32, O, 0, A.work, { bits: 5 }), M = !1;
        }
        A.lencode = E, A.lenbits = 9, A.distcode = O, A.distbits = 5;
      }
      function P(A, F, _, J) {
        var V, R = A.state;
        return R.window === null && (R.wsize = 1 << R.wbits, R.wnext = 0, R.whave = 0, R.window = new s.Buf8(R.wsize)), J >= R.wsize ? (s.arraySet(R.window, F, _ - R.wsize, R.wsize, 0), R.wnext = 0, R.whave = R.wsize) : (J < (V = R.wsize - R.wnext) && (V = J), s.arraySet(R.window, F, _ - J, V, R.wnext), (J -= V) ? (s.arraySet(R.window, F, _ - J, J, 0), R.wnext = J, R.whave = R.wsize) : (R.wnext += V, R.wnext === R.wsize && (R.wnext = 0), R.whave < R.wsize && (R.whave += V))), 0;
      }
      r.inflateReset = C, r.inflateReset2 = I, r.inflateResetKeep = k, r.inflateInit = function(A) {
        return D(A, 15);
      }, r.inflateInit2 = D, r.inflate = function(A, F) {
        var _, J, V, R, tt, H, ct, it, N, z, G, Y, ot, xt, gt, wt, qt, Rt, Yt, Kt, T, ht, $, nt, X = 0, st = new s.Buf8(4), vt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0) return f;
        (_ = A.state).mode === 12 && (_.mode = 13), tt = A.next_out, V = A.output, ct = A.avail_out, R = A.next_in, J = A.input, H = A.avail_in, it = _.hold, N = _.bits, z = H, G = ct, ht = p;
        t: for (; ; ) switch (_.mode) {
          case g:
            if (_.wrap === 0) {
              _.mode = 13;
              break;
            }
            for (; N < 16; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            if (2 & _.wrap && it === 35615) {
              st[_.check = 0] = 255 & it, st[1] = it >>> 8 & 255, _.check = a(_.check, st, 2, 0), N = it = 0, _.mode = 2;
              break;
            }
            if (_.flags = 0, _.head && (_.head.done = !1), !(1 & _.wrap) || (((255 & it) << 8) + (it >> 8)) % 31) {
              A.msg = "incorrect header check", _.mode = 30;
              break;
            }
            if ((15 & it) != 8) {
              A.msg = "unknown compression method", _.mode = 30;
              break;
            }
            if (N -= 4, T = 8 + (15 & (it >>>= 4)), _.wbits === 0) _.wbits = T;
            else if (T > _.wbits) {
              A.msg = "invalid window size", _.mode = 30;
              break;
            }
            _.dmax = 1 << T, A.adler = _.check = 1, _.mode = 512 & it ? 10 : 12, N = it = 0;
            break;
          case 2:
            for (; N < 16; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            if (_.flags = it, (255 & _.flags) != 8) {
              A.msg = "unknown compression method", _.mode = 30;
              break;
            }
            if (57344 & _.flags) {
              A.msg = "unknown header flags set", _.mode = 30;
              break;
            }
            _.head && (_.head.text = it >> 8 & 1), 512 & _.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, _.check = a(_.check, st, 2, 0)), N = it = 0, _.mode = 3;
          case 3:
            for (; N < 32; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            _.head && (_.head.time = it), 512 & _.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, st[2] = it >>> 16 & 255, st[3] = it >>> 24 & 255, _.check = a(_.check, st, 4, 0)), N = it = 0, _.mode = 4;
          case 4:
            for (; N < 16; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            _.head && (_.head.xflags = 255 & it, _.head.os = it >> 8), 512 & _.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, _.check = a(_.check, st, 2, 0)), N = it = 0, _.mode = 5;
          case 5:
            if (1024 & _.flags) {
              for (; N < 16; ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              _.length = it, _.head && (_.head.extra_len = it), 512 & _.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, _.check = a(_.check, st, 2, 0)), N = it = 0;
            } else _.head && (_.head.extra = null);
            _.mode = 6;
          case 6:
            if (1024 & _.flags && (H < (Y = _.length) && (Y = H), Y && (_.head && (T = _.head.extra_len - _.length, _.head.extra || (_.head.extra = new Array(_.head.extra_len)), s.arraySet(_.head.extra, J, R, Y, T)), 512 & _.flags && (_.check = a(_.check, J, Y, R)), H -= Y, R += Y, _.length -= Y), _.length)) break t;
            _.length = 0, _.mode = 7;
          case 7:
            if (2048 & _.flags) {
              if (H === 0) break t;
              for (Y = 0; T = J[R + Y++], _.head && T && _.length < 65536 && (_.head.name += String.fromCharCode(T)), T && Y < H; ) ;
              if (512 & _.flags && (_.check = a(_.check, J, Y, R)), H -= Y, R += Y, T) break t;
            } else _.head && (_.head.name = null);
            _.length = 0, _.mode = 8;
          case 8:
            if (4096 & _.flags) {
              if (H === 0) break t;
              for (Y = 0; T = J[R + Y++], _.head && T && _.length < 65536 && (_.head.comment += String.fromCharCode(T)), T && Y < H; ) ;
              if (512 & _.flags && (_.check = a(_.check, J, Y, R)), H -= Y, R += Y, T) break t;
            } else _.head && (_.head.comment = null);
            _.mode = 9;
          case 9:
            if (512 & _.flags) {
              for (; N < 16; ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              if (it !== (65535 & _.check)) {
                A.msg = "header crc mismatch", _.mode = 30;
                break;
              }
              N = it = 0;
            }
            _.head && (_.head.hcrc = _.flags >> 9 & 1, _.head.done = !0), A.adler = _.check = 0, _.mode = 12;
            break;
          case 10:
            for (; N < 32; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            A.adler = _.check = y(it), N = it = 0, _.mode = 11;
          case 11:
            if (_.havedict === 0) return A.next_out = tt, A.avail_out = ct, A.next_in = R, A.avail_in = H, _.hold = it, _.bits = N, 2;
            A.adler = _.check = 1, _.mode = 12;
          case 12:
            if (F === 5 || F === 6) break t;
          case 13:
            if (_.last) {
              it >>>= 7 & N, N -= 7 & N, _.mode = 27;
              break;
            }
            for (; N < 3; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            switch (_.last = 1 & it, N -= 1, 3 & (it >>>= 1)) {
              case 0:
                _.mode = 14;
                break;
              case 1:
                if (q(_), _.mode = 20, F !== 6) break;
                it >>>= 2, N -= 2;
                break t;
              case 2:
                _.mode = 17;
                break;
              case 3:
                A.msg = "invalid block type", _.mode = 30;
            }
            it >>>= 2, N -= 2;
            break;
          case 14:
            for (it >>>= 7 & N, N -= 7 & N; N < 32; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            if ((65535 & it) != (it >>> 16 ^ 65535)) {
              A.msg = "invalid stored block lengths", _.mode = 30;
              break;
            }
            if (_.length = 65535 & it, N = it = 0, _.mode = 15, F === 6) break t;
          case 15:
            _.mode = 16;
          case 16:
            if (Y = _.length) {
              if (H < Y && (Y = H), ct < Y && (Y = ct), Y === 0) break t;
              s.arraySet(V, J, R, Y, tt), H -= Y, R += Y, ct -= Y, tt += Y, _.length -= Y;
              break;
            }
            _.mode = 12;
            break;
          case 17:
            for (; N < 14; ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            if (_.nlen = 257 + (31 & it), it >>>= 5, N -= 5, _.ndist = 1 + (31 & it), it >>>= 5, N -= 5, _.ncode = 4 + (15 & it), it >>>= 4, N -= 4, 286 < _.nlen || 30 < _.ndist) {
              A.msg = "too many length or distance symbols", _.mode = 30;
              break;
            }
            _.have = 0, _.mode = 18;
          case 18:
            for (; _.have < _.ncode; ) {
              for (; N < 3; ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              _.lens[vt[_.have++]] = 7 & it, it >>>= 3, N -= 3;
            }
            for (; _.have < 19; ) _.lens[vt[_.have++]] = 0;
            if (_.lencode = _.lendyn, _.lenbits = 7, $ = { bits: _.lenbits }, ht = h(0, _.lens, 0, 19, _.lencode, 0, _.work, $), _.lenbits = $.bits, ht) {
              A.msg = "invalid code lengths set", _.mode = 30;
              break;
            }
            _.have = 0, _.mode = 19;
          case 19:
            for (; _.have < _.nlen + _.ndist; ) {
              for (; wt = (X = _.lencode[it & (1 << _.lenbits) - 1]) >>> 16 & 255, qt = 65535 & X, !((gt = X >>> 24) <= N); ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              if (qt < 16) it >>>= gt, N -= gt, _.lens[_.have++] = qt;
              else {
                if (qt === 16) {
                  for (nt = gt + 2; N < nt; ) {
                    if (H === 0) break t;
                    H--, it += J[R++] << N, N += 8;
                  }
                  if (it >>>= gt, N -= gt, _.have === 0) {
                    A.msg = "invalid bit length repeat", _.mode = 30;
                    break;
                  }
                  T = _.lens[_.have - 1], Y = 3 + (3 & it), it >>>= 2, N -= 2;
                } else if (qt === 17) {
                  for (nt = gt + 3; N < nt; ) {
                    if (H === 0) break t;
                    H--, it += J[R++] << N, N += 8;
                  }
                  N -= gt, T = 0, Y = 3 + (7 & (it >>>= gt)), it >>>= 3, N -= 3;
                } else {
                  for (nt = gt + 7; N < nt; ) {
                    if (H === 0) break t;
                    H--, it += J[R++] << N, N += 8;
                  }
                  N -= gt, T = 0, Y = 11 + (127 & (it >>>= gt)), it >>>= 7, N -= 7;
                }
                if (_.have + Y > _.nlen + _.ndist) {
                  A.msg = "invalid bit length repeat", _.mode = 30;
                  break;
                }
                for (; Y--; ) _.lens[_.have++] = T;
              }
            }
            if (_.mode === 30) break;
            if (_.lens[256] === 0) {
              A.msg = "invalid code -- missing end-of-block", _.mode = 30;
              break;
            }
            if (_.lenbits = 9, $ = { bits: _.lenbits }, ht = h(u, _.lens, 0, _.nlen, _.lencode, 0, _.work, $), _.lenbits = $.bits, ht) {
              A.msg = "invalid literal/lengths set", _.mode = 30;
              break;
            }
            if (_.distbits = 6, _.distcode = _.distdyn, $ = { bits: _.distbits }, ht = h(d, _.lens, _.nlen, _.ndist, _.distcode, 0, _.work, $), _.distbits = $.bits, ht) {
              A.msg = "invalid distances set", _.mode = 30;
              break;
            }
            if (_.mode = 20, F === 6) break t;
          case 20:
            _.mode = 21;
          case 21:
            if (6 <= H && 258 <= ct) {
              A.next_out = tt, A.avail_out = ct, A.next_in = R, A.avail_in = H, _.hold = it, _.bits = N, l(A, G), tt = A.next_out, V = A.output, ct = A.avail_out, R = A.next_in, J = A.input, H = A.avail_in, it = _.hold, N = _.bits, _.mode === 12 && (_.back = -1);
              break;
            }
            for (_.back = 0; wt = (X = _.lencode[it & (1 << _.lenbits) - 1]) >>> 16 & 255, qt = 65535 & X, !((gt = X >>> 24) <= N); ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            if (wt && !(240 & wt)) {
              for (Rt = gt, Yt = wt, Kt = qt; wt = (X = _.lencode[Kt + ((it & (1 << Rt + Yt) - 1) >> Rt)]) >>> 16 & 255, qt = 65535 & X, !(Rt + (gt = X >>> 24) <= N); ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              it >>>= Rt, N -= Rt, _.back += Rt;
            }
            if (it >>>= gt, N -= gt, _.back += gt, _.length = qt, wt === 0) {
              _.mode = 26;
              break;
            }
            if (32 & wt) {
              _.back = -1, _.mode = 12;
              break;
            }
            if (64 & wt) {
              A.msg = "invalid literal/length code", _.mode = 30;
              break;
            }
            _.extra = 15 & wt, _.mode = 22;
          case 22:
            if (_.extra) {
              for (nt = _.extra; N < nt; ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              _.length += it & (1 << _.extra) - 1, it >>>= _.extra, N -= _.extra, _.back += _.extra;
            }
            _.was = _.length, _.mode = 23;
          case 23:
            for (; wt = (X = _.distcode[it & (1 << _.distbits) - 1]) >>> 16 & 255, qt = 65535 & X, !((gt = X >>> 24) <= N); ) {
              if (H === 0) break t;
              H--, it += J[R++] << N, N += 8;
            }
            if (!(240 & wt)) {
              for (Rt = gt, Yt = wt, Kt = qt; wt = (X = _.distcode[Kt + ((it & (1 << Rt + Yt) - 1) >> Rt)]) >>> 16 & 255, qt = 65535 & X, !(Rt + (gt = X >>> 24) <= N); ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              it >>>= Rt, N -= Rt, _.back += Rt;
            }
            if (it >>>= gt, N -= gt, _.back += gt, 64 & wt) {
              A.msg = "invalid distance code", _.mode = 30;
              break;
            }
            _.offset = qt, _.extra = 15 & wt, _.mode = 24;
          case 24:
            if (_.extra) {
              for (nt = _.extra; N < nt; ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              _.offset += it & (1 << _.extra) - 1, it >>>= _.extra, N -= _.extra, _.back += _.extra;
            }
            if (_.offset > _.dmax) {
              A.msg = "invalid distance too far back", _.mode = 30;
              break;
            }
            _.mode = 25;
          case 25:
            if (ct === 0) break t;
            if (Y = G - ct, _.offset > Y) {
              if ((Y = _.offset - Y) > _.whave && _.sane) {
                A.msg = "invalid distance too far back", _.mode = 30;
                break;
              }
              ot = Y > _.wnext ? (Y -= _.wnext, _.wsize - Y) : _.wnext - Y, Y > _.length && (Y = _.length), xt = _.window;
            } else xt = V, ot = tt - _.offset, Y = _.length;
            for (ct < Y && (Y = ct), ct -= Y, _.length -= Y; V[tt++] = xt[ot++], --Y; ) ;
            _.length === 0 && (_.mode = 21);
            break;
          case 26:
            if (ct === 0) break t;
            V[tt++] = _.length, ct--, _.mode = 21;
            break;
          case 27:
            if (_.wrap) {
              for (; N < 32; ) {
                if (H === 0) break t;
                H--, it |= J[R++] << N, N += 8;
              }
              if (G -= ct, A.total_out += G, _.total += G, G && (A.adler = _.check = _.flags ? a(_.check, V, G, tt - G) : o(_.check, V, G, tt - G)), G = ct, (_.flags ? it : y(it)) !== _.check) {
                A.msg = "incorrect data check", _.mode = 30;
                break;
              }
              N = it = 0;
            }
            _.mode = 28;
          case 28:
            if (_.wrap && _.flags) {
              for (; N < 32; ) {
                if (H === 0) break t;
                H--, it += J[R++] << N, N += 8;
              }
              if (it !== (4294967295 & _.total)) {
                A.msg = "incorrect length check", _.mode = 30;
                break;
              }
              N = it = 0;
            }
            _.mode = 29;
          case 29:
            ht = 1;
            break t;
          case 30:
            ht = -3;
            break t;
          case 31:
            return -4;
          case 32:
          default:
            return f;
        }
        return A.next_out = tt, A.avail_out = ct, A.next_in = R, A.avail_in = H, _.hold = it, _.bits = N, (_.wsize || G !== A.avail_out && _.mode < 30 && (_.mode < 27 || F !== 4)) && P(A, A.output, A.next_out, G - A.avail_out) ? (_.mode = 31, -4) : (z -= A.avail_in, G -= A.avail_out, A.total_in += z, A.total_out += G, _.total += G, _.wrap && G && (A.adler = _.check = _.flags ? a(_.check, V, G, A.next_out - G) : o(_.check, V, G, A.next_out - G)), A.data_type = _.bits + (_.last ? 64 : 0) + (_.mode === 12 ? 128 : 0) + (_.mode === 20 || _.mode === 15 ? 256 : 0), (z == 0 && G === 0 || F === 4) && ht === p && (ht = -5), ht);
      }, r.inflateEnd = function(A) {
        if (!A || !A.state) return f;
        var F = A.state;
        return F.window && (F.window = null), A.state = null, p;
      }, r.inflateGetHeader = function(A, F) {
        var _;
        return A && A.state && 2 & (_ = A.state).wrap ? ((_.head = F).done = !1, p) : f;
      }, r.inflateSetDictionary = function(A, F) {
        var _, J = F.length;
        return A && A.state ? (_ = A.state).wrap !== 0 && _.mode !== 11 ? f : _.mode === 11 && o(1, F, J, 0) !== _.check ? -3 : P(A, F, J, J) ? (_.mode = 31, -4) : (_.havedict = 1, p) : f;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, r) {
      var s = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(u, d, p, f, g, b, x, y) {
        var v, k, C, I, D, E, O, M, q, P = y.bits, A = 0, F = 0, _ = 0, J = 0, V = 0, R = 0, tt = 0, H = 0, ct = 0, it = 0, N = null, z = 0, G = new s.Buf16(16), Y = new s.Buf16(16), ot = null, xt = 0;
        for (A = 0; A <= 15; A++) G[A] = 0;
        for (F = 0; F < f; F++) G[d[p + F]]++;
        for (V = P, J = 15; 1 <= J && G[J] === 0; J--) ;
        if (J < V && (V = J), J === 0) return g[b++] = 20971520, g[b++] = 20971520, y.bits = 1, 0;
        for (_ = 1; _ < J && G[_] === 0; _++) ;
        for (V < _ && (V = _), A = H = 1; A <= 15; A++) if (H <<= 1, (H -= G[A]) < 0) return -1;
        if (0 < H && (u === 0 || J !== 1)) return -1;
        for (Y[1] = 0, A = 1; A < 15; A++) Y[A + 1] = Y[A] + G[A];
        for (F = 0; F < f; F++) d[p + F] !== 0 && (x[Y[d[p + F]]++] = F);
        if (E = u === 0 ? (N = ot = x, 19) : u === 1 ? (N = o, z -= 257, ot = a, xt -= 257, 256) : (N = l, ot = h, -1), A = _, D = b, tt = F = it = 0, C = -1, I = (ct = 1 << (R = V)) - 1, u === 1 && 852 < ct || u === 2 && 592 < ct) return 1;
        for (; ; ) {
          for (O = A - tt, q = x[F] < E ? (M = 0, x[F]) : x[F] > E ? (M = ot[xt + x[F]], N[z + x[F]]) : (M = 96, 0), v = 1 << A - tt, _ = k = 1 << R; g[D + (it >> tt) + (k -= v)] = O << 24 | M << 16 | q | 0, k !== 0; ) ;
          for (v = 1 << A - 1; it & v; ) v >>= 1;
          if (v !== 0 ? (it &= v - 1, it += v) : it = 0, F++, --G[A] == 0) {
            if (A === J) break;
            A = d[p + x[F]];
          }
          if (V < A && (it & I) !== C) {
            for (tt === 0 && (tt = V), D += _, H = 1 << (R = A - tt); R + tt < J && !((H -= G[R + tt]) <= 0); ) R++, H <<= 1;
            if (ct += 1 << R, u === 1 && 852 < ct || u === 2 && 592 < ct) return 1;
            g[C = it & I] = V << 24 | R << 16 | D - b | 0;
          }
        }
        return it !== 0 && (g[D + it] = A - tt << 24 | 64 << 16 | 0), y.bits = V, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, r) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, r) {
      var s = e("../utils/common"), o = 0, a = 1;
      function l(X) {
        for (var st = X.length; 0 <= --st; ) X[st] = 0;
      }
      var h = 0, u = 29, d = 256, p = d + 1 + u, f = 30, g = 19, b = 2 * p + 1, x = 15, y = 16, v = 7, k = 256, C = 16, I = 17, D = 18, E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], O = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], M = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], q = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], P = new Array(2 * (p + 2));
      l(P);
      var A = new Array(2 * f);
      l(A);
      var F = new Array(512);
      l(F);
      var _ = new Array(256);
      l(_);
      var J = new Array(u);
      l(J);
      var V, R, tt, H = new Array(f);
      function ct(X, st, vt, St, ft) {
        this.static_tree = X, this.extra_bits = st, this.extra_base = vt, this.elems = St, this.max_length = ft, this.has_stree = X && X.length;
      }
      function it(X, st) {
        this.dyn_tree = X, this.max_code = 0, this.stat_desc = st;
      }
      function N(X) {
        return X < 256 ? F[X] : F[256 + (X >>> 7)];
      }
      function z(X, st) {
        X.pending_buf[X.pending++] = 255 & st, X.pending_buf[X.pending++] = st >>> 8 & 255;
      }
      function G(X, st, vt) {
        X.bi_valid > y - vt ? (X.bi_buf |= st << X.bi_valid & 65535, z(X, X.bi_buf), X.bi_buf = st >> y - X.bi_valid, X.bi_valid += vt - y) : (X.bi_buf |= st << X.bi_valid & 65535, X.bi_valid += vt);
      }
      function Y(X, st, vt) {
        G(X, vt[2 * st], vt[2 * st + 1]);
      }
      function ot(X, st) {
        for (var vt = 0; vt |= 1 & X, X >>>= 1, vt <<= 1, 0 < --st; ) ;
        return vt >>> 1;
      }
      function xt(X, st, vt) {
        var St, ft, Et = new Array(x + 1), zt = 0;
        for (St = 1; St <= x; St++) Et[St] = zt = zt + vt[St - 1] << 1;
        for (ft = 0; ft <= st; ft++) {
          var Tt = X[2 * ft + 1];
          Tt !== 0 && (X[2 * ft] = ot(Et[Tt]++, Tt));
        }
      }
      function gt(X) {
        var st;
        for (st = 0; st < p; st++) X.dyn_ltree[2 * st] = 0;
        for (st = 0; st < f; st++) X.dyn_dtree[2 * st] = 0;
        for (st = 0; st < g; st++) X.bl_tree[2 * st] = 0;
        X.dyn_ltree[2 * k] = 1, X.opt_len = X.static_len = 0, X.last_lit = X.matches = 0;
      }
      function wt(X) {
        8 < X.bi_valid ? z(X, X.bi_buf) : 0 < X.bi_valid && (X.pending_buf[X.pending++] = X.bi_buf), X.bi_buf = 0, X.bi_valid = 0;
      }
      function qt(X, st, vt, St) {
        var ft = 2 * st, Et = 2 * vt;
        return X[ft] < X[Et] || X[ft] === X[Et] && St[st] <= St[vt];
      }
      function Rt(X, st, vt) {
        for (var St = X.heap[vt], ft = vt << 1; ft <= X.heap_len && (ft < X.heap_len && qt(st, X.heap[ft + 1], X.heap[ft], X.depth) && ft++, !qt(st, St, X.heap[ft], X.depth)); ) X.heap[vt] = X.heap[ft], vt = ft, ft <<= 1;
        X.heap[vt] = St;
      }
      function Yt(X, st, vt) {
        var St, ft, Et, zt, Tt = 0;
        if (X.last_lit !== 0) for (; St = X.pending_buf[X.d_buf + 2 * Tt] << 8 | X.pending_buf[X.d_buf + 2 * Tt + 1], ft = X.pending_buf[X.l_buf + Tt], Tt++, St === 0 ? Y(X, ft, st) : (Y(X, (Et = _[ft]) + d + 1, st), (zt = E[Et]) !== 0 && G(X, ft -= J[Et], zt), Y(X, Et = N(--St), vt), (zt = O[Et]) !== 0 && G(X, St -= H[Et], zt)), Tt < X.last_lit; ) ;
        Y(X, k, st);
      }
      function Kt(X, st) {
        var vt, St, ft, Et = st.dyn_tree, zt = st.stat_desc.static_tree, Tt = st.stat_desc.has_stree, $t = st.stat_desc.elems, te = -1;
        for (X.heap_len = 0, X.heap_max = b, vt = 0; vt < $t; vt++) Et[2 * vt] !== 0 ? (X.heap[++X.heap_len] = te = vt, X.depth[vt] = 0) : Et[2 * vt + 1] = 0;
        for (; X.heap_len < 2; ) Et[2 * (ft = X.heap[++X.heap_len] = te < 2 ? ++te : 0)] = 1, X.depth[ft] = 0, X.opt_len--, Tt && (X.static_len -= zt[2 * ft + 1]);
        for (st.max_code = te, vt = X.heap_len >> 1; 1 <= vt; vt--) Rt(X, Et, vt);
        for (ft = $t; vt = X.heap[1], X.heap[1] = X.heap[X.heap_len--], Rt(X, Et, 1), St = X.heap[1], X.heap[--X.heap_max] = vt, X.heap[--X.heap_max] = St, Et[2 * ft] = Et[2 * vt] + Et[2 * St], X.depth[ft] = (X.depth[vt] >= X.depth[St] ? X.depth[vt] : X.depth[St]) + 1, Et[2 * vt + 1] = Et[2 * St + 1] = ft, X.heap[1] = ft++, Rt(X, Et, 1), 2 <= X.heap_len; ) ;
        X.heap[--X.heap_max] = X.heap[1], function(oe, ae) {
          var xe, Xt, Nt, Ot, ie, Jt, fe = ae.dyn_tree, ne = ae.max_code, de = ae.stat_desc.static_tree, Ue = ae.stat_desc.has_stree, Te = ae.stat_desc.extra_bits, Sn = ae.stat_desc.extra_base, Mn = ae.stat_desc.max_length, Ze = 0;
          for (Ot = 0; Ot <= x; Ot++) oe.bl_count[Ot] = 0;
          for (fe[2 * oe.heap[oe.heap_max] + 1] = 0, xe = oe.heap_max + 1; xe < b; xe++) Mn < (Ot = fe[2 * fe[2 * (Xt = oe.heap[xe]) + 1] + 1] + 1) && (Ot = Mn, Ze++), fe[2 * Xt + 1] = Ot, ne < Xt || (oe.bl_count[Ot]++, ie = 0, Sn <= Xt && (ie = Te[Xt - Sn]), Jt = fe[2 * Xt], oe.opt_len += Jt * (Ot + ie), Ue && (oe.static_len += Jt * (de[2 * Xt + 1] + ie)));
          if (Ze !== 0) {
            do {
              for (Ot = Mn - 1; oe.bl_count[Ot] === 0; ) Ot--;
              oe.bl_count[Ot]--, oe.bl_count[Ot + 1] += 2, oe.bl_count[Mn]--, Ze -= 2;
            } while (0 < Ze);
            for (Ot = Mn; Ot !== 0; Ot--) for (Xt = oe.bl_count[Ot]; Xt !== 0; ) ne < (Nt = oe.heap[--xe]) || (fe[2 * Nt + 1] !== Ot && (oe.opt_len += (Ot - fe[2 * Nt + 1]) * fe[2 * Nt], fe[2 * Nt + 1] = Ot), Xt--);
          }
        }(X, st), xt(Et, te, X.bl_count);
      }
      function T(X, st, vt) {
        var St, ft, Et = -1, zt = st[1], Tt = 0, $t = 7, te = 4;
        for (zt === 0 && ($t = 138, te = 3), st[2 * (vt + 1) + 1] = 65535, St = 0; St <= vt; St++) ft = zt, zt = st[2 * (St + 1) + 1], ++Tt < $t && ft === zt || (Tt < te ? X.bl_tree[2 * ft] += Tt : ft !== 0 ? (ft !== Et && X.bl_tree[2 * ft]++, X.bl_tree[2 * C]++) : Tt <= 10 ? X.bl_tree[2 * I]++ : X.bl_tree[2 * D]++, Et = ft, te = (Tt = 0) === zt ? ($t = 138, 3) : ft === zt ? ($t = 6, 3) : ($t = 7, 4));
      }
      function ht(X, st, vt) {
        var St, ft, Et = -1, zt = st[1], Tt = 0, $t = 7, te = 4;
        for (zt === 0 && ($t = 138, te = 3), St = 0; St <= vt; St++) if (ft = zt, zt = st[2 * (St + 1) + 1], !(++Tt < $t && ft === zt)) {
          if (Tt < te) for (; Y(X, ft, X.bl_tree), --Tt != 0; ) ;
          else ft !== 0 ? (ft !== Et && (Y(X, ft, X.bl_tree), Tt--), Y(X, C, X.bl_tree), G(X, Tt - 3, 2)) : Tt <= 10 ? (Y(X, I, X.bl_tree), G(X, Tt - 3, 3)) : (Y(X, D, X.bl_tree), G(X, Tt - 11, 7));
          Et = ft, te = (Tt = 0) === zt ? ($t = 138, 3) : ft === zt ? ($t = 6, 3) : ($t = 7, 4);
        }
      }
      l(H);
      var $ = !1;
      function nt(X, st, vt, St) {
        G(X, (h << 1) + (St ? 1 : 0), 3), function(ft, Et, zt, Tt) {
          wt(ft), z(ft, zt), z(ft, ~zt), s.arraySet(ft.pending_buf, ft.window, Et, zt, ft.pending), ft.pending += zt;
        }(X, st, vt);
      }
      r._tr_init = function(X) {
        $ || (function() {
          var st, vt, St, ft, Et, zt = new Array(x + 1);
          for (ft = St = 0; ft < u - 1; ft++) for (J[ft] = St, st = 0; st < 1 << E[ft]; st++) _[St++] = ft;
          for (_[St - 1] = ft, ft = Et = 0; ft < 16; ft++) for (H[ft] = Et, st = 0; st < 1 << O[ft]; st++) F[Et++] = ft;
          for (Et >>= 7; ft < f; ft++) for (H[ft] = Et << 7, st = 0; st < 1 << O[ft] - 7; st++) F[256 + Et++] = ft;
          for (vt = 0; vt <= x; vt++) zt[vt] = 0;
          for (st = 0; st <= 143; ) P[2 * st + 1] = 8, st++, zt[8]++;
          for (; st <= 255; ) P[2 * st + 1] = 9, st++, zt[9]++;
          for (; st <= 279; ) P[2 * st + 1] = 7, st++, zt[7]++;
          for (; st <= 287; ) P[2 * st + 1] = 8, st++, zt[8]++;
          for (xt(P, p + 1, zt), st = 0; st < f; st++) A[2 * st + 1] = 5, A[2 * st] = ot(st, 5);
          V = new ct(P, E, d + 1, p, x), R = new ct(A, O, 0, f, x), tt = new ct(new Array(0), M, 0, g, v);
        }(), $ = !0), X.l_desc = new it(X.dyn_ltree, V), X.d_desc = new it(X.dyn_dtree, R), X.bl_desc = new it(X.bl_tree, tt), X.bi_buf = 0, X.bi_valid = 0, gt(X);
      }, r._tr_stored_block = nt, r._tr_flush_block = function(X, st, vt, St) {
        var ft, Et, zt = 0;
        0 < X.level ? (X.strm.data_type === 2 && (X.strm.data_type = function(Tt) {
          var $t, te = 4093624447;
          for ($t = 0; $t <= 31; $t++, te >>>= 1) if (1 & te && Tt.dyn_ltree[2 * $t] !== 0) return o;
          if (Tt.dyn_ltree[18] !== 0 || Tt.dyn_ltree[20] !== 0 || Tt.dyn_ltree[26] !== 0) return a;
          for ($t = 32; $t < d; $t++) if (Tt.dyn_ltree[2 * $t] !== 0) return a;
          return o;
        }(X)), Kt(X, X.l_desc), Kt(X, X.d_desc), zt = function(Tt) {
          var $t;
          for (T(Tt, Tt.dyn_ltree, Tt.l_desc.max_code), T(Tt, Tt.dyn_dtree, Tt.d_desc.max_code), Kt(Tt, Tt.bl_desc), $t = g - 1; 3 <= $t && Tt.bl_tree[2 * q[$t] + 1] === 0; $t--) ;
          return Tt.opt_len += 3 * ($t + 1) + 5 + 5 + 4, $t;
        }(X), ft = X.opt_len + 3 + 7 >>> 3, (Et = X.static_len + 3 + 7 >>> 3) <= ft && (ft = Et)) : ft = Et = vt + 5, vt + 4 <= ft && st !== -1 ? nt(X, st, vt, St) : X.strategy === 4 || Et === ft ? (G(X, 2 + (St ? 1 : 0), 3), Yt(X, P, A)) : (G(X, 4 + (St ? 1 : 0), 3), function(Tt, $t, te, oe) {
          var ae;
          for (G(Tt, $t - 257, 5), G(Tt, te - 1, 5), G(Tt, oe - 4, 4), ae = 0; ae < oe; ae++) G(Tt, Tt.bl_tree[2 * q[ae] + 1], 3);
          ht(Tt, Tt.dyn_ltree, $t - 1), ht(Tt, Tt.dyn_dtree, te - 1);
        }(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, zt + 1), Yt(X, X.dyn_ltree, X.dyn_dtree)), gt(X), St && wt(X);
      }, r._tr_tally = function(X, st, vt) {
        return X.pending_buf[X.d_buf + 2 * X.last_lit] = st >>> 8 & 255, X.pending_buf[X.d_buf + 2 * X.last_lit + 1] = 255 & st, X.pending_buf[X.l_buf + X.last_lit] = 255 & vt, X.last_lit++, st === 0 ? X.dyn_ltree[2 * vt]++ : (X.matches++, st--, X.dyn_ltree[2 * (_[vt] + d + 1)]++, X.dyn_dtree[2 * N(st)]++), X.last_lit === X.lit_bufsize - 1;
      }, r._tr_align = function(X) {
        G(X, 2, 3), Y(X, k, P), function(st) {
          st.bi_valid === 16 ? (z(st, st.bi_buf), st.bi_buf = 0, st.bi_valid = 0) : 8 <= st.bi_valid && (st.pending_buf[st.pending++] = 255 & st.bi_buf, st.bi_buf >>= 8, st.bi_valid -= 8);
        }(X);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, r) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, r) {
      (function(s) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, h, u, d, p = 1, f = {}, g = !1, b = o.document, x = Object.getPrototypeOf && Object.getPrototypeOf(o);
            x = x && x.setTimeout ? x : o, l = {}.toString.call(o.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                v(C);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var C = !0, I = o.onmessage;
                return o.onmessage = function() {
                  C = !1;
                }, o.postMessage("", "*"), o.onmessage = I, C;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), function(C) {
              o.postMessage(d + C, "*");
            }) : o.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(C) {
              v(C.data);
            }, function(C) {
              u.port2.postMessage(C);
            }) : b && "onreadystatechange" in b.createElement("script") ? (h = b.documentElement, function(C) {
              var I = b.createElement("script");
              I.onreadystatechange = function() {
                v(C), I.onreadystatechange = null, h.removeChild(I), I = null;
              }, h.appendChild(I);
            }) : function(C) {
              setTimeout(v, 0, C);
            }, x.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var I = new Array(arguments.length - 1), D = 0; D < I.length; D++) I[D] = arguments[D + 1];
              var E = { callback: C, args: I };
              return f[p] = E, l(p), p++;
            }, x.clearImmediate = y;
          }
          function y(C) {
            delete f[C];
          }
          function v(C) {
            if (g) setTimeout(v, 0, C);
            else {
              var I = f[C];
              if (I) {
                g = !0;
                try {
                  (function(D) {
                    var E = D.callback, O = D.args;
                    switch (O.length) {
                      case 0:
                        E();
                        break;
                      case 1:
                        E(O[0]);
                        break;
                      case 2:
                        E(O[0], O[1]);
                        break;
                      case 3:
                        E(O[0], O[1], O[2]);
                        break;
                      default:
                        E.apply(a, O);
                    }
                  })(I);
                } finally {
                  y(C), g = !1;
                }
              }
            }
          }
          function k(C) {
            C.source === o && typeof C.data == "string" && C.data.indexOf(d) === 0 && v(+C.data.slice(d.length));
          }
        })(typeof self > "u" ? s === void 0 ? this : s : self);
      }).call(this, typeof ho < "u" ? ho : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(qm);
var Gk = qm.exports;
const Vk = /* @__PURE__ */ Oc(Gk), Yk = {
  key: 0,
  class: "debug"
}, Kk = !0, Xk = /* @__PURE__ */ ns({
  __name: "WordPress",
  setup(n) {
    const t = mo(() => import("./FormulaPricing-DVQyavY6.js")), e = mo(() => import("./ObjectViewer-DL0r1Qhs.js")), i = "production", r = {}, s = {};
    let o, a, l;
    const h = {
      banding: null,
      finish: null
    };
    let u = null, d = [], p = null, f = {};
    const g = Ne(!1), b = Ne("manual"), x = Ne(""), y = Ne([]), v = Ne(null), k = Ne(!0), C = Ne(null), I = Ne(!1), D = Ne(null), E = rn(() => window.smartcutConfig.settings.units ?? "decimal");
    F2("calculator", () => D.value);
    const O = (Nt) => {
      g.value && console.log("SmartCut -", ...Nt);
    }, M = (Nt) => {
      console.error(`SmartCut - ${Nt}`);
    }, q = (Nt = !0) => {
      I.value = !0, ["checkout", "intro_text", "offcuts", "banding_key"].forEach((ie) => ht(ie, "block")), zt() && ht("pricing_table", "table"), Nt ? A(!0) : F(), J();
    }, P = (Nt = !0, Ot = !0) => {
      I.value = !1, ["checkout", "intro_text", "offcuts", "banding_key", "pricing_table"].forEach((Jt) => ht(Jt, "none")), Ot === !0 ? _() : Ot === !1 && J(), A ? A() : Nt === !1 && F();
    }, A = (Nt = !1) => {
      ht("quantity", "inline-block"), r.quantity.readOnly = Nt;
    }, F = () => {
      I.value !== !1 && (V(1), ht("quantity", "none"), r.quantity.readOnly = !0);
    }, _ = () => {
      if (!r.cart_button) {
        M("Cart button not found");
        return;
      }
      r.cart_button.disabled = !1;
    }, J = () => {
      if (I.value !== !1) {
        if (!r.cart_button) {
          M("Cart button not found");
          return;
        }
        r.cart_button.disabled = !0;
      }
    }, V = (Nt, Ot = 0) => {
      if (O(["setting cart quantity", Nt]), !r.quantity) {
        M("Quantity field not found when trying to set");
        return;
      }
      r.quantity.value = Nt.toFixed(Ot), console.assert(r.quantity.value === Nt.toFixed(Ot), "Quantity field value not set correctly");
    }, R = (Nt) => {
      O(["setting variation price", Nt]);
      const Ot = document.querySelector(".woocommerce-variation-price .smartcut-price-selector");
      Ot && (Ot.innerText = ot(Nt)), v.value.display_price = Nt;
    }, tt = () => {
      if (!(window != null && window.smartcutConfig)) {
        M("SmartCut config not found");
        return;
      }
      const Nt = window.smartcutConfig;
      l = Nt.settings;
      const Ot = qt(Rn(window, ["smartcutConfig", "banding_data"])), ie = qt(Rn(window, ["smartcutConfig", "finish_data"])), Jt = {
        debug: l.debug,
        units: l.units,
        locale: Nt.locale,
        decimalPlaces: 2,
        //saw
        stockType: l.stock_type,
        bladeWidth: l.blade_width,
        cutPreference: l.cut_preference,
        stackHeight: l.stack_height,
        stockSelection: l.stock_selection,
        stockGrain: l.stock_grain,
        minSpacing: l.min_spacing,
        maxParts: l.max_parts ?? null,
        orientationModel: l.orientation_model,
        minDimension: l.min_dimension,
        partTrim: l.part_trim,
        enable: {
          banding: l.enable_banding,
          finish: l.enable_finish,
          orientation: l.enable_orientation,
          diagram: !l.hide_diagram,
          machining: l.enable_machining,
          csvImport: l.enable_import,
          partName: l.enable_part_name,
          imageUpload: l.enable_image_upload,
          focus: !0,
          click: !0,
          progressNumber: l.pricing_strategy !== "part_area"
        },
        colors: {
          partA: (l == null ? void 0 : l.part_a_color) ?? "#1d9bc4",
          partB: (l == null ? void 0 : l.part_b_color) ?? "#065d7a",
          partHover: (l == null ? void 0 : l.part_hover_color) ?? "#f8b029",
          partSelected: (l == null ? void 0 : l.part_selected_color) ?? "#5bc85b",
          stock: (l == null ? void 0 : l.stock_color) ?? "#ffd166",
          button: (l == null ? void 0 : l.button_color) ?? "#118ab2",
          buttonText: (l == null ? void 0 : l.button_text_color) ?? "#ffffff",
          text: (l == null ? void 0 : l.text_color) ?? "#ffffff"
        }
      };
      g.value = Jt.debug;
      const fe = {
        units: "decimal",
        faces: {
          enabled: l.machining_sides
        },
        holes: {
          enabled: l.machining_holes,
          defaultDiameter: l.machining_holes_default_diameter,
          diameters: l.machining_holes_diameters.split(",").map((Te) => Te.trim()).filter(Boolean),
          minDiameter: l.machining_holes_min_diameter,
          maxDiameter: l.machining_holes_max_diameter,
          enableDepth: l.machining_holes_depth,
          depths: l.machining_holes_depths.split(",").map((Te) => Te.trim()).filter(Boolean),
          defaultDepth: l.machining_holes_default_depth,
          minDepth: l.machining_holes_min_depth,
          maxDepth: l.machining_holes_max_depth
        },
        hingeHoles: {
          enabled: l.machining_hinge_holes,
          minimumHoleDistance: l.machining_hinge_holes_minimum_hole_distance,
          defaultDistanceFromEdge: l.machining_hinge_holes_default_distance_from_edge,
          defaultOuterSpacing: l.machining_hinge_holes_default_outer_spacing,
          defaultHingeLength: l.machining_hinge_holes_default_hinge_length
        },
        corners: {
          enabled: l.machining_radius_corners || l.machining_bevel_corners,
          types: [
            l.machining_radius_corners ? "radius" : null,
            l.machining_bevel_corners ? "bevel" : null
          ].filter(Boolean),
          minValue: l.machining_corners_min_value,
          maxValue: l.machining_corners_max_value,
          enableBanding: l.machining_corners_enable_banding
        }
      };
      k.value = vt(), k.value ? A(!0) : F(), u.type === "variable" ? P(!1, !1) : q(k.value);
      const ne = {
        type: u.type,
        stock: y.value,
        variations: d ?? null,
        options: Jt,
        banding: Ot,
        finish: ie,
        machining: fe
      };
      ne.type === "variable" && (O(["setting variable product form listeners"]), jQuery(function(Te) {
        Te(".variations_form").on("reset_data", () => P(!1, !1)).on("found_variation", (Sn, Mn) => oe(Sn, Mn));
      }));
      const de = {
        product: u,
        selectedVariation: v,
        inputs: s,
        elements: r,
        inputType: b,
        formatPrice: ot,
        setInputValue: $,
        setCartQuantity: V,
        setVariationPrice: R,
        isExtraEnabled: St,
        isQuantityPricing: vt,
        isMachiningEnabled: ft,
        isSurchargeEnabled: Et,
        getTotalBandingPrice: Kt,
        getTotalFinishPrice: Yt,
        getTotalMachiningPrice: T,
        getInputValue: nt,
        enableAddToCart: _,
        log: O,
        error: M
      }, Ue = Hk({
        pricing_strategy: l.pricing_strategy,
        units: l.units,
        unit_system: l.unit_system,
        cut_length_price: l.cut_length_price,
        per_part_price: l.per_part_price,
        surcharge: l.surcharge,
        surcharge_type: l.surcharge_type,
        enable_offcut_pricing: l.enable_offcut_pricing,
        offcut_min_length: l.offcut_min_length,
        offcut_min_width: l.offcut_min_width
      }, de);
      o = Ue.calculatePrice, a = Ue.resetPricing, Es(() => {
        D.value && D.value.init(ne);
      });
    }, H = (Nt) => {
      const Ot = (Nt == null ? void 0 : Nt.multiple_sizes) === !0;
      u = {
        type: Nt == null ? void 0 : Nt.product_type,
        multiple_sizes: Ot,
        size: Nt != null && Nt.size ? Nt.size.split(" | ") : [],
        l: !Ot && (Nt != null && Nt.l) ? parseFloat(Nt.l) : null,
        w: !Ot && (Nt != null && Nt.w) ? parseFloat(Nt.w) : null,
        t: (Nt == null ? void 0 : Nt.t) ?? null,
        price: Nt != null && Nt.price ? parseFloat(Nt.price) : null,
        stock_name: (Nt == null ? void 0 : Nt.stock_sku) || Nt.stock_name
      }, u.multiple_sizes || (u.l || M("product 'length' attribute not available"), u.w || M("product 'width' attribute not available"));
    }, ct = (Nt) => {
      b.value = Rn(window, ["smartcutConfig", "settings", "enable_formula"]) === !0 ? "formula" : "manual", x.value = Rn(window, ["smartcutConfig", "settings", "formula_url"]), O([`Input type: ${b.value}`]), O([`Input type: ${b.value}`]), f = {
        thousands_separator: Nt == null ? void 0 : Nt.thousands_separator,
        decimal_separator: Nt == null ? void 0 : Nt.decimal_separator,
        number_of_decimals: Nt == null ? void 0 : Nt.number_of_decimals,
        currency_symbol: Nt == null ? void 0 : Nt.currency_symbol,
        currency_position: Nt == null ? void 0 : Nt.currency_position
      };
    }, it = () => {
      const Nt = {
        checkout: "#smartcut-app",
        intro_text: "#smartcut-intro-text",
        pricing_table: "#smartcut-pricing-table",
        offcuts: "#include_offcuts_field",
        banding_key: "#smartcut-banding-key",
        finish_key: "#smartcut-finish-key",
        banding_total_price: "#smartcut-banding-total bdi .smartcut-price-selector",
        finish_total_price: "#smartcut-finish-total bdi .smartcut-price-selector",
        cut_length_price: "#smartcut-cut-length-total bdi .smartcut-price-selector",
        per_part_price: "#smartcut-per-part-total bdi .smartcut-price-selector",
        part_area_price: "#smartcut-area-total bdi .smartcut-price-selector",
        offcut_area_price: "#smartcut-offcut-area-total bdi .smartcut-price-selector",
        roll_length_price: "#smartcut-roll-length-total bdi .smartcut-price-selector",
        surcharge_price: "#smartcut-surcharge-total bdi .smartcut-price-selector",
        machining_total_price: "#smartcut-machining-total bdi .smartcut-price-selector",
        stock_total_price: "#smartcut-stock-total bdi .smartcut-price-selector",
        quantity: ".smartcut-stock-quantity",
        //this is the add to cart quantity element(s)
        cart_button: ".single_add_to_cart_button"
      };
      for (const [Ot, ie] of Object.entries(Nt))
        r[Ot] = document.querySelector(ie);
      if (!r.checkout)
        return M("checkout iframe not found");
      if (!r.quantity)
        return M("quantity field not found");
      if (!r.cart_button)
        return M("cart button not found");
      r.quantity.readOnly = !0, J();
    }, N = () => ({
      x1: l.stock_trim_x1 ?? 0,
      x2: l.stock_trim_x2 ?? 0,
      y1: l.stock_type === "linear" ? 0 : l.stock_trim_y1 ?? 0,
      y2: l.stock_type === "linear" ? 0 : l.stock_trim_y2 ?? 0
    }), z = (Nt = null, Ot = null, ie = null, Jt = null, fe = null) => {
      let ne;
      if (fe && typeof fe == "object") {
        ne = [];
        for (const [Ue, Te] of Object.entries(fe))
          Ue !== "attribute_size" && Ue !== "attribute_thickness" && ne.push(`${Ue.replace("attribute_", "")}: ${Te}`);
        ne = ne.join(" - ");
      }
      return {
        name: u.stock_name,
        type: l.stock_type,
        l: Nt,
        w: Ot,
        t: ie,
        grain: l.stock_grain,
        cost: parseFloat((Jt == null ? void 0 : Jt.toString()) || "0"),
        trim: N(),
        allowExactFitShapes: !0,
        notes: ne
      };
    }, G = () => {
      u != null && u.stock_name || M("product name not specified"), y.value = [], u.multiple_sizes ? u.size.forEach((Nt) => {
        const [Ot, ie] = Nt.split("x"), Jt = z(
          parseFloat(Ot),
          parseFloat(ie),
          u == null ? void 0 : u.t,
          u.price
        );
        y.value.push(Jt);
      }) : y.value.push(z(
        u.l,
        u.w,
        u == null ? void 0 : u.t,
        u == null ? void 0 : u.price
      ));
    }, Y = (Nt, Ot) => {
      const ie = Nt.split(".");
      return ie[0] = ie[0].replace(/\B(?=(\d{3})+(?!\d))/g, Ot), ie.join(".");
    }, ot = (Nt = 0, Ot = "") => {
      if (!Nt)
        return Ot ? gt("0.00") : "0.00";
      typeof Nt == "string" && (Nt = parseFloat(Nt));
      const ie = Nt.toFixed(f.number_of_decimals).replace(".", f.decimal_separator), Jt = Y(ie, f.thousands_separator);
      return Ot ? gt(Jt) : Jt;
    }, xt = (Nt) => {
      if (Nt == null) return "";
      typeof Nt == "string" && (Nt = parseFloat(Nt));
      const ie = Nt % 1 !== 0 ? f.number_of_decimals : 0, Jt = Nt.toFixed(ie).replace(".", f.decimal_separator);
      return Y(Jt, f.thousands_separator);
    }, gt = (Nt) => {
      switch (f.currency_position) {
        case "left":
          return `${f.currency_symbol}${Nt}`;
        case "right":
          return `${Nt}${f.currency_symbol}`;
        default:
          return `${f.currency_symbol}${Nt}`;
      }
    }, wt = (Nt) => {
      const Ot = (ie) => b1($l(ie), 100).replace("|", "_");
      return Array.isArray(Nt) ? Nt.map(Ot).join(",") : Ot(Nt);
    }, qt = (Nt) => {
      if (!Nt) return null;
      const Ot = {
        labels: [],
        pricing: {}
      }, ie = Object.values(Nt);
      for (const Jt of ie)
        Jt != null && Jt.variations ? (Ot.labels.push(...Object.keys(Jt.options)), Object.values(Jt.variations).forEach((fe) => {
          const { options: ne } = fe, de = Object.values(ne).map((Ue) => wt(Ue)).join("|");
          Ot.pricing[de] = parseInt(fe.price);
        })) : Jt != null && Jt.options && Object.keys(Jt.options).forEach((fe) => {
          Ot.pricing[wt(fe)] = parseInt(Jt.price);
        });
      return Ot.labels.length || Ot.labels.push("type"), Ot;
    }, Rt = (Nt, Ot) => {
      if (!Ot.length || !ac(h, [Nt])) return null;
      const ie = Rn(h, [Nt]);
      if (!Po(ie)) return null;
      const fe = Object.values(ie).map((ne) => ne != null && ne.variations ? Object.values(ne.variations).map((de) => (de.type = "variable", de)) : (ne.type = "simple", ne)).flat().find((ne) => {
        let de;
        return ne.type === "simple" ? de = Object.keys(ne.options) : de = Object.values(ne.options), de ? de.every((Ue, Te) => wt(Ue) === wt(Ot[Te])) : !1;
      });
      return fe != null && fe.price ? parseFloat(fe.price) : null;
    }, Yt = (Nt) => {
      let Ot = 0;
      if (typeof Nt == "object") {
        for (let [ie, Jt] of Object.entries(Nt)) {
          typeof Jt == "string" && (Jt = parseFloat(Jt));
          const fe = ie.split("|"), ne = Rt("finish", fe);
          if (ne === null) continue;
          const Ue = Number(Jt) / 1e6 * parseFloat(ne.toString());
          Ot += Ue;
        }
        if ("min_finish_charge" in l) {
          const ie = parseFloat(l == null ? void 0 : l.min_finish_charge);
          if (ie > 0 && Ot > 0 && Ot < ie)
            return ie;
        }
      }
      return Ot;
    }, Kt = (Nt) => {
      let Ot = 0;
      if (typeof Nt == "object") {
        for (let [ie, Jt] of Object.entries(Nt)) {
          typeof Jt == "string" && (Jt = parseFloat(Jt));
          const fe = ie.split("|"), ne = Rt("banding", fe);
          if (ne === null) continue;
          const de = Jt / (l.unit_system === "imperial" ? 12 : 1e3) * parseFloat(ne.toString());
          Ot += de;
        }
        if ("min_banding_charge" in l) {
          const ie = parseFloat(l == null ? void 0 : l.min_banding_charge);
          if (ie > 0 && Ot > 0 && Ot < ie)
            return ie;
        }
      }
      return Ot;
    }, T = (Nt) => (p.holes ?? 0) * (Nt.metadata.numHoles ?? 0) + (p.corners ?? 0) * (Nt.metadata.numCorners ?? 0), ht = (Nt, Ot) => {
      var ie;
      Nt in r && ((ie = r[Nt]) != null && ie.style) && (r[Nt].style.display = Ot);
    }, $ = (Nt, Ot) => {
      X(Nt) ? s[Nt].value = Ot : M(`Attempting to set input but key '${Nt}' does not exist`);
    }, nt = (Nt) => {
      if (X(Nt))
        return s[Nt].value;
      M(`Attempting to get input but key '${Nt}' does not exist`);
    }, X = (Nt) => Nt in s && s[Nt] instanceof HTMLInputElement, st = () => {
      V(1), J(), $("smartcut-cut-to-size-surcharge", 0), a();
      for (const Nt in s)
        Nt !== "smartcut-hardware-price" && $(Nt, null);
    }, vt = () => {
      var Nt;
      if (((Nt = window.smartcutConfig) == null ? void 0 : Nt.product_type) === "variable")
        return !1;
      switch (l.pricing_strategy) {
        case "full_stock":
        case "part_area":
        case "full_stock_plus_cut_length":
        case "full_stock_plus_num_parts":
          return !0;
        case "roll_length":
        case "cut_length":
          return !1;
        default:
          return !1;
      }
    }, St = (Nt) => {
      if (ac(l, ["enable", Nt]) && Rn(l, ["enable", Nt]) === !1)
        return !1;
      const Ot = Rn(h, [Nt]);
      return !!(Ot && Object.values(Ot).length);
    }, ft = () => l.enable_machining === !0, Et = () => !((l == null ? void 0 : l.surcharge_type) === "none" || !(l != null && l.surcharge) || l.surcharge === "0.00"), zt = () => !!(l.pricing_strategy === "full_stock_plus_cut_length" || l.pricing_strategy === "full_stock_plus_num_parts" || l.pricing_strategy === "part_area" || l.pricing_strategy === "roll_length" || Et() || St("banding") || St("finish") || ft()), Tt = (Nt) => {
      var ie;
      let Ot = (ie = Nt == null ? void 0 : Nt.attributes) == null ? void 0 : ie.attribute_size;
      return Ot || (Ot = u == null ? void 0 : u.size), Ot;
    }, $t = (Nt) => /\d+x\d+/.test(Nt), te = () => {
      window.smartcutConfig.input_fields.forEach((Nt) => {
        const Ot = Nt.replaceAll("_", "-");
        s[Ot] = document.getElementById(Ot);
      });
    }, oe = (Nt, Ot) => {
      st(), v.value = Ot, O(["variation selected", Ot.attributes]), y.value = [];
      const ie = Rn(Ot, ["attributes", "attribute_thickness"]);
      if (u.selected_thickness = ie, u.multiple_sizes) {
        const Jt = Tt(Ot);
        if (O([`variation found with size: ${Jt} & thickness: ${ie}`]), !Jt)
          return P(!1), M("The size of this multiple size product could not be found");
        if (Array.isArray(Jt) ? q(k.value) : $t(Jt) ? P(!0, !0) : q(k.value), d != null && d.length && ie) {
          let fe;
          Array.isArray(Jt) ? fe = Jt.map((ne) => ({
            size: ne,
            l: ne.split("x")[0],
            w: ne.split("x")[1],
            t: ie,
            price: Ot.display_price
          })) : fe = d.filter((ne) => {
            var de, Ue;
            return /\d+x\d+/.test((de = ne == null ? void 0 : ne.attributes) == null ? void 0 : de.size) ? ie === ((Ue = ne == null ? void 0 : ne.attributes) == null ? void 0 : Ue.thickness) : !1;
          }).map((ne) => {
            var de, Ue, Te, Sn;
            return O([
              `size attribute: '${(de = ne == null ? void 0 : ne.attributes) == null ? void 0 : de.size}'`,
              `price for 'thickness ${ie}, size: ${Jt}' is ${Ot.display_price}`
            ]), {
              size: (Ue = ne == null ? void 0 : ne.attributes) == null ? void 0 : Ue.size,
              l: (Te = ne == null ? void 0 : ne.attributes) == null ? void 0 : Te.size.split("x")[0],
              w: (Sn = ne == null ? void 0 : ne.attributes) == null ? void 0 : Sn.size.split("x")[1],
              t: u.selected_thickness,
              price: Ot.display_price
            };
          }), I.value === !0 && fe.forEach((ne) => {
            const de = z(
              ne.l,
              ne.w,
              ne.t,
              ne.price,
              Ot == null ? void 0 : Ot.attributes
            );
            y.value.push(de);
          });
        }
      } else {
        const Jt = d.find((fe) => fe.attributes.thickness === ie);
        if (!Jt) return M(`variation not found for thickness ${ie}`);
        y.value.push(z(
          u.l,
          u.w,
          ie,
          Jt.price,
          Ot == null ? void 0 : Ot.attributes
        )), q(k.value);
      }
    }, ae = async (Nt) => {
      st(), O(["result event received", Nt]);
      const Ot = await o(Nt);
      if (!Ot.success) {
        console.error(Ot.error);
        return;
      }
      await xe(Nt);
    }, xe = async (Nt) => {
      const ie = nw(Nt, C.value, xt).split(",")[1], Jt = new Vk();
      Jt.file("order-summary.pdf", ie);
      const fe = await Jt.generateAsync({ type: "blob" }), ne = new File([fe], "order-summary.zip", { type: "application/zip" });
      if (!X("smartcut-order-summary")) return;
      const de = s["smartcut-order-summary"].closest("form");
      if (!de) return;
      const Ue = new DataTransfer();
      Ue.items.add(ne);
      const Te = de.querySelector('[name="smartcut_order_summary"]');
      Te instanceof HTMLInputElement && (Te.files = Ue.files);
    }, Xt = (Nt, Ot) => {
      J(), C.value = gl(Nt), $("smartcut-hardware-price", Ot);
    };
    return Io(() => {
      console.log("💥 Powered by https://smartcut.dev", window.smartcutConfig.version), O(["Launching WordPress checkout..."]), h.banding = Rn(window, ["smartcutConfig", "banding_data"]), h.finish = Rn(window, ["smartcutConfig", "finish_data"]), p = Rn(window, ["smartcutConfig", "machining_pricing"]), d = Rn(window, ["smartcutConfig", "variations"]), it(), te(), H(window.smartcutConfig), ct(window.smartcutConfig), tt(), G(), [
        "div.quantity > input.plus",
        "div.quantity > input.minus",
        "div.quantity .qty-plus",
        "div.quantity .qty-minus"
      ].forEach((ie) => {
        const Jt = document.querySelector(ie);
        Jt && (Jt.style.display = "none");
      });
      const Ot = new CustomEvent("smartcut/ready");
      window.dispatchEvent(Ot), O(["Wordpress checkout ready"]);
    }), (Nt, Ot) => (Zt(), ce(Qn, null, [
      Oe(i) === "development" && Kk ? (Zt(), ce("div", Yk, [
        Ot[0] || (Ot[0] = ye("div", null, "WP - developer information", -1)),
        Zn(Oe(e), {
          data: [Oe(u)],
          paths: ["product"]
        }, null, 8, ["data"])
      ])) : ke("", !0),
      b.value === "formula" && x.value ? (Zt(), Wn(Oe(t), {
        key: 1,
        ref: "formulapricing",
        units: E.value,
        "format-price": ot,
        url: x.value,
        debug: g.value,
        onHardwareResult: Xt,
        onPanelResult: J
      }, null, 8, ["units", "url", "debug"])) : ke("", !0),
      b.value === "manual" || b.value === "formula" && x.value ? (Zt(), Wn(Uk, {
        key: 2,
        ref_key: "calculator",
        ref: D,
        readonly: b.value === "formula",
        debug: g.value,
        stock: y.value,
        "find-extras-price": Rt,
        "format-price": ot,
        units: E.value,
        onLog: O,
        onError: M,
        onResult: ae,
        onInputsChanged: J
      }, null, 8, ["readonly", "debug", "stock", "units"])) : ke("", !0)
    ], 64));
  }
}), Jk = /* @__PURE__ */ ns({
  __name: "Launch",
  props: {
    type: { default: "" }
  },
  setup(n) {
    const t = mo(() => import("./Vanilla-DSZ1n1_w.js")), e = {
      wordpress: Xk,
      vanilla: t
    }, i = n, r = rn(() => {
      const s = i.type.toLowerCase();
      return e[s] || null;
    });
    return (s, o) => (Zt(), Wn(M2(r.value), { ref: "checkout" }, null, 512));
  }
}), iA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: Jk }, Symbol.toStringTag, { value: "Module" }));
export {
  Uk as C,
  wl as I,
  iA as L,
  La as _,
  ho as a,
  en as b,
  ac as c,
  Oc as d,
  Be as e,
  Qt as f,
  Rn as g,
  dr as h,
  d1 as i,
  eA as j,
  h1 as k,
  Yg as l,
  nA as m,
  f6 as n,
  Ky as o,
  Mm as r,
  Rm as s,
  sf as u,
  jt as v
};
