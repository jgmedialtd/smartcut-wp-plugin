var S2 = Object.defineProperty;
var k2 = (n, t, e) => t in n ? S2(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var tt = (n, t, e) => k2(n, typeof t != "symbol" ? t + "" : t, e);
import { i as A2, u as Ie, o as Lo, n as Qr, r as Ce, a as N2, w as hr, g as C2, b as P2, c as L2, s as uo, d as fa, e as bp, f as Ar, m as da, h as I2, j as ee, k as de, F as Zn, l as Lr, p as di, q as jn, t as be, v as mn, x as Xg, y as Jg, z as E2, A as Pe, B as is, C as sn, D as Of, E as Zg, G as Fl, H as Wn, I as Ln, J as qu, K as O2, L as go, M as T2, N as F2 } from "./main-CvwYKkoi.js";
let xu;
const M2 = new Uint8Array(16);
function R2() {
  if (!xu && (xu = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !xu))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return xu(M2);
}
const Kn = [];
for (let n = 0; n < 256; ++n)
  Kn.push((n + 256).toString(16).slice(1));
function D2(n, t = 0) {
  return Kn[n[t + 0]] + Kn[n[t + 1]] + Kn[n[t + 2]] + Kn[n[t + 3]] + "-" + Kn[n[t + 4]] + Kn[n[t + 5]] + "-" + Kn[n[t + 6]] + Kn[n[t + 7]] + "-" + Kn[n[t + 8]] + Kn[n[t + 9]] + "-" + Kn[n[t + 10]] + Kn[n[t + 11]] + Kn[n[t + 12]] + Kn[n[t + 13]] + Kn[n[t + 14]] + Kn[n[t + 15]];
}
const B2 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vp = {
  randomUUID: B2
};
function Qg(n, t, e) {
  if (vp.randomUUID && !t && !n)
    return vp.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || R2)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, D2(i);
}
const ua = 1e-10, j2 = 10, q2 = Number.MAX_SAFE_INTEGER, z2 = 4294967295, Jn = (n) => typeof n == "number" && Number.isFinite(n), zu = (n) => Array.isArray(n) && n.length > 0;
function ll(n, t, e = ua) {
  if (n === t) return 0;
  if (Number.isInteger(n) && Number.isInteger(t))
    return n > t ? 1 : -1;
  const i = n - t;
  return Math.abs(i) < e ? 0 : i;
}
const $2 = {
  greaterThan: (n, t, e = ua) => !Jn(n) || !Jn(t) ? !1 : ll(n, t, e) > 0,
  greaterThanOrEqualTo: (n, t, e = ua) => !Jn(n) || !Jn(t) ? !1 : ll(n, t, e) >= 0,
  lessThan: (n, t, e = ua) => !Jn(n) || !Jn(t) ? !1 : ll(n, t, e) < 0,
  lessThanOrEqualTo: (n, t, e = ua) => !Jn(n) || !Jn(t) ? !1 : ll(n, t, e) <= 0,
  equalTo: (n, t, e = ua) => !Jn(n) || !Jn(t) ? !1 : ll(n, t, e) === 0
};
function U2(n) {
  return Jn(n) ? Number.isInteger(n) ? n : Number(n.toFixed(j2)) : !1;
}
function W2(n) {
  if (!Jn(n) || n < 0 || n > q2)
    throw new Error("Invalid length parameter");
  return Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / (z2 + 1) * n);
}
function H2(n, t) {
  if (!zu(n))
    throw new Error("Invalid array parameter");
  if (!Jn(t) || t < 0 || t > n.length)
    throw new Error("Invalid size parameter");
  const e = n.slice(), i = n.length - t;
  for (let r = n.length - 1; r >= i; r--) {
    const s = Math.floor(Math.random() * (r + 1));
    [e[r], e[s]] = [e[s], e[r]];
  }
  return e.slice(i);
}
class _u {
  static calculateMean(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    return t.reduce((e, i) => e + i, 0) / t.length;
  }
  static calculateStandardDeviation(t, e = null) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const i = e ?? this.calculateMean(t), r = t.reduce((s, o) => {
      const a = o - i;
      return s + a * a;
    }, 0) / t.length;
    return Math.sqrt(r);
  }
  static calculateCoefficientOfVariation(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const e = this.calculateMean(t);
    if (e === 0)
      throw new Error("Mean is zero, coefficient of variation undefined");
    return this.calculateStandardDeviation(t, e) / e;
  }
}
const He = {
  ...$2,
  isNumber: Jn,
  round: U2,
  getRandom: W2,
  getRandomSample: H2,
  calculateStandardDeviation: _u.calculateStandardDeviation.bind(_u),
  calculateCoefficientOfVariation: _u.calculateCoefficientOfVariation.bind(_u)
}, Ju = {
  //sort by width then length - use .sort(sortHeightDescWidthDesc)
  WDLD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
  },
  WALA(n, t) {
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
  },
  //sort by length d then width d
  LDWD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
  },
  LAWA(n, t) {
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
  },
  //sort by width d
  WD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.w === t.w) return 0;
  },
  LD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.l === t.l) return 0;
  },
  LDIDA(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  WDIDA(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  //sort by proportion
  /* sortProportion: function(a, b) {
  
  		if (a.proportion < b.proportion) return 1;
  		if (a.proportion > b.proportion) return -1;
  
  		if (a.proportion === b.proportion) return a.index - b.index;
  
  	} */
  //area descending
  AD(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
  },
  AA(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) return 0;
  },
  AAID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  ADID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  //by id ascending
  ID(n, t) {
    if (!n.id || !t.id) return 0;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  IDDesc(n, t) {
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(i[0]) - parseInt(e[0]) : parseInt(i[1]) - parseInt(e[1]);
  },
  StockID(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  StockIDAD(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    const r = n.getArea(), s = t.getArea();
    if (r < s) return 1;
    if (r > s) return -1;
  },
  parentID(n, t) {
    return n.parentID - t.parentID;
  },
  YX(n, t) {
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
    if (n.y === t.y) return 0;
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
  },
  XY(n, t) {
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
    if (n.x === t.x) return 0;
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
  },
  subset(n, t) {
    if (n.totalLength < t.totalLength) return 1;
    if (n.totalLength > t.totalLength) return -1;
    if (n.area === t.area) return 0;
    if (n.area < t.area) return 1;
    if (n.area > t.area) return -1;
  },
  placementOrder(n, t) {
    return (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  typePlacementOrder(n, t) {
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  stockIDTypePlacementOrder(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  offcutPlacementOrder(n, t) {
    var r, s;
    if (!((r = n == null ? void 0 : n.stock) != null && r.id) || !((s = t == null ? void 0 : t.stock) != null && s.id)) return 0;
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : e[1] !== i[1] ? parseInt(e[1]) - parseInt(i[1]) : (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  groupPlacementOrder(n, t) {
    if (n.placementOrder > t.placementOrder) return 1;
    if (n.placementOrder < t.placementOrder) return -1;
    if (n.groupPlacementOrder === t.groupPlacementOrder) return 0;
    if (n.groupPlacementOrder > t.groupPlacementOrder) return 1;
    if (n.groupPlacementOrder < t.groupPlacementOrder) return -1;
  },
  swapFirstTwo(n) {
    const t = n[1];
    n[1] = n[0], n[0] = t;
  },
  //Fisher-Yates shuffle
  shuffle(n) {
    for (let t = n.length - 1; t > 0; t--) {
      const e = Math.floor(Math.random() * (t + 1));
      [n[t], n[e]] = [n[e], n[t]];
    }
  },
  /**
      * generator function which accepts a dimension to cater for shape rotation lock
      */
  fillThenArea(n) {
    return function(t, e) {
      return t.getLongSide(n) > e.getLongSide(n) ? -1 : t.getLongSide(n) < e.getLongSide(n) ? 1 : t.getArea() > e.getArea() ? -1 : t.getArea() < e.getArea() ? 1 : 0;
    };
  },
  aspect(n, t) {
    const e = n.getAspect(), i = t.getAspect();
    return e > i ? -1 : e < i ? 1 : 0;
  }
};
function G2(n) {
  if (n === "l") return "x";
  if (n === "w") return "y";
}
function ko(n) {
  return n ? n === "l" ? "w" : "l" : null;
}
function V2(n) {
  return n ? n === "x" ? "y" : "x" : null;
}
class pa {
  constructor(t) {
    tt(this, "x1");
    tt(this, "x2");
    tt(this, "y1");
    tt(this, "y2");
    tt(this, "dimension");
    tt(this, "direction");
    tt(this, "shapeCollisions");
    tt(this, "origin");
    tt(this, "type");
    this.x1 = t.x1, this.x2 = t.x2, this.y1 = t.y1, this.y2 = t.y2, this.dimension = Y2(this), this.direction = K2(this), this.type = t != null && t.type ? t.type : null, this.origin = t != null && t.origin ? t.origin : null;
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
}
function Cs(n, t, e, i, r = null, s = null) {
  return new pa({ x1: n, y1: t, x2: e, y2: i, origin: r, type: s });
}
function Y2(n) {
  return typeof n > "u" || !He.isNumber(n.x1) || !He.isNumber(n.x2) || !He.isNumber(n.y1) || !He.isNumber(n.y2) ? null : n.x1 === n.x2 && n.y1 !== n.y2 ? "w" : n.y1 === n.y2 && n.x1 !== n.x2 ? "l" : null;
}
function K2(n) {
  return typeof n > "u" || !He.isNumber(n.x1) || !He.isNumber(n.x2) || !He.isNumber(n.y1) || !He.isNumber(n.y2) ? null : n.x1 < n.x2 ? "lr" : n.x1 > n.x2 ? "rl" : n.y1 < n.y2 ? "bt" : n.y1 > n.y2 ? "tb" : null;
}
function X2(n, t) {
  const e = n.getCorners(), i = {};
  return e.bottomLeft.x > 0 && e.bottomLeft.y > 0 && (i.bottomLeftDown = Cs(
    e.bottomLeft.x,
    e.bottomLeft.y,
    e.bottomLeft.x,
    0,
    "bottomLeft",
    "bottomLeftDown"
  ), i.bottomLeftLeft = Cs(
    e.bottomLeft.x,
    e.bottomLeft.y,
    0,
    e.bottomLeft.y,
    "bottomLeft",
    "bottomLeftLeft"
  )), e.topLeft.x > 0 && e.topLeft.y < t.w && (i.topLeftLeft = Cs(
    e.topLeft.x,
    e.topLeft.y,
    0,
    e.topLeft.y,
    "topLeft",
    "topLeftLeft"
  ), i.topLeftTop = Cs(
    e.topLeft.x,
    e.topLeft.y,
    e.topLeft.x,
    t.w,
    "topLeft",
    "topLeftTop"
  )), e.topRight.y < t.w && e.topRight.x < t.l && (i.topRightTop = Cs(
    e.topRight.x,
    e.topRight.y,
    e.topRight.x,
    t.w,
    "topRight",
    "topRightTop"
  ), i.topRightRight = Cs(
    e.topRight.x,
    e.topRight.y,
    t.l,
    e.topRight.y,
    "topRight",
    "topRightRight"
  )), e.bottomRight.x < t.l && e.bottomRight.y > 0 && (i.bottomRightRight = Cs(
    e.bottomRight.x,
    e.bottomRight.y,
    t.l,
    e.bottomRight.y,
    "bottomRight",
    "bottomRightRight"
  ), i.bottomRightDown = Cs(
    e.bottomRight.x,
    e.bottomRight.y,
    e.bottomRight.x,
    0,
    "bottomRight",
    "bottomRightDown"
  )), i;
}
var t0 = Object.defineProperty, J2 = Object.getOwnPropertyNames, Et = (n, t) => t0(n, "name", { value: t, configurable: !0 }), Z2 = (n, t) => function() {
  return t || (0, n[J2(n)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Tf = (n, t) => {
  for (var e in t)
    t0(n, e, { get: t[e], enumerable: !0 });
}, Q2 = Z2({
  "(disabled):util"() {
  }
}), Zu = {};
Tf(Zu, {
  addChainableMethod: () => Hf,
  addLengthGuard: () => Dl,
  addMethod: () => $f,
  addProperty: () => zf,
  checkError: () => Mi,
  compareByInspect: () => nc,
  eql: () => C0,
  expectTypes: () => a0,
  flag: () => De,
  getActual: () => Sc,
  getMessage: () => Rf,
  getName: () => Ac,
  getOperator: () => Kf,
  getOwnEnumerableProperties: () => Yf,
  getOwnEnumerablePropertySymbols: () => Vf,
  getPathInfo: () => qf,
  hasProperty: () => kc,
  inspect: () => We,
  isNaN: () => ic,
  isNumeric: () => Gn,
  isProxyEnabled: () => Rl,
  isRegExp: () => rc,
  objDisplay: () => mo,
  overwriteChainableMethod: () => Gf,
  overwriteMethod: () => Wf,
  overwriteProperty: () => Uf,
  proxify: () => Aa,
  test: () => Ff,
  transferFlags: () => mr,
  type: () => on
});
var Mi = {};
Tf(Mi, {
  compatibleConstructor: () => i0,
  compatibleInstance: () => n0,
  compatibleMessage: () => r0,
  getConstructorName: () => s0,
  getMessage: () => o0
});
function _c(n) {
  return n instanceof Error || Object.prototype.toString.call(n) === "[object Error]";
}
Et(_c, "isErrorInstance");
function e0(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
Et(e0, "isRegExp");
function n0(n, t) {
  return _c(t) && n === t;
}
Et(n0, "compatibleInstance");
function i0(n, t) {
  return _c(t) ? n.constructor === t.constructor || n instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? n.constructor === t || n instanceof t : !1;
}
Et(i0, "compatibleConstructor");
function r0(n, t) {
  const e = typeof n == "string" ? n : n.message;
  return e0(t) ? t.test(e) : typeof t == "string" ? e.indexOf(t) !== -1 : !1;
}
Et(r0, "compatibleMessage");
function s0(n) {
  let t = n;
  return _c(n) ? t = n.constructor.name : typeof n == "function" && (t = n.name, t === "" && (t = new n().name || t)), t;
}
Et(s0, "getConstructorName");
function o0(n) {
  let t = "";
  return n && n.message ? t = n.message : typeof n == "string" && (t = n), t;
}
Et(o0, "getMessage");
function De(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    i[t] = e;
  else
    return i[t];
}
Et(De, "flag");
function Ff(n, t) {
  var e = De(n, "negate"), i = t[0];
  return e ? !i : i;
}
Et(Ff, "test");
function on(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
Et(on, "type");
var ty = "captureStackTrace" in Error, So, Ye = (So = class extends Error {
  constructor(e = "Unspecified AssertionError", i, r) {
    super(e);
    tt(this, "message");
    this.message = e, ty && Error.captureStackTrace(this, r || So);
    for (const s in i)
      s in this || (this[s] = i[s]);
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, Et(So, "AssertionError"), So);
function a0(n, t) {
  var e = De(n, "message"), i = De(n, "ssfi");
  e = e ? e + ": " : "", n = De(n, "object"), t = t.map(function(o) {
    return o.toLowerCase();
  }), t.sort();
  var r = t.map(function(o, a) {
    var l = ~["a", "e", "i", "o", "u"].indexOf(o.charAt(0)) ? "an" : "a", h = t.length > 1 && a === t.length - 1 ? "or " : "";
    return h + l + " " + o;
  }).join(", "), s = on(n).toLowerCase();
  if (!t.some(function(o) {
    return s === o;
  }))
    throw new Ye(
      e + "object tested must be " + r + ", but " + s + " given",
      void 0,
      i
    );
}
Et(a0, "expectTypes");
function Sc(n, t) {
  return t.length > 4 ? t[4] : n._obj;
}
Et(Sc, "getActual");
var wp = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, ey = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, va = "…";
function l0(n, t) {
  const e = wp[ey[t]] || wp[t] || "";
  return e ? `\x1B[${e[0]}m${String(n)}\x1B[${e[1]}m` : String(n);
}
Et(l0, "colorise");
function u0({
  showHidden: n = !1,
  depth: t = 2,
  colors: e = !1,
  customInspect: i = !0,
  showProxy: r = !1,
  maxArrayLength: s = 1 / 0,
  breakLength: o = 1 / 0,
  seen: a = [],
  // eslint-disable-next-line no-shadow
  truncate: l = 1 / 0,
  stylize: h = String
} = {}, u) {
  const d = {
    showHidden: !!n,
    depth: Number(t),
    colors: !!e,
    customInspect: !!i,
    showProxy: !!r,
    maxArrayLength: Number(s),
    breakLength: Number(o),
    truncate: Number(l),
    seen: a,
    inspect: u,
    stylize: h
  };
  return d.colors && (d.stylize = l0), d;
}
Et(u0, "normaliseOptions");
function c0(n) {
  return n >= "\uD800" && n <= "\uDBFF";
}
Et(c0, "isHighSurrogate");
function rs(n, t, e = va) {
  n = String(n);
  const i = e.length, r = n.length;
  if (i > t && r > i)
    return e;
  if (r > t && r > i) {
    let s = t - i;
    return s > 0 && c0(n[s - 1]) && (s = s - 1), `${n.slice(0, s)}${e}`;
  }
  return n;
}
Et(rs, "truncate");
function Ji(n, t, e, i = ", ") {
  e = e || t.inspect;
  const r = n.length;
  if (r === 0)
    return "";
  const s = t.truncate;
  let o = "", a = "", l = "";
  for (let h = 0; h < r; h += 1) {
    const u = h + 1 === n.length, d = h + 2 === n.length;
    l = `${va}(${n.length - h})`;
    const p = n[h];
    t.truncate = s - o.length - (u ? 0 : i.length);
    const f = a || e(p, t) + (u ? "" : i), m = o.length + f.length, b = m + l.length;
    if (u && m > s && o.length + l.length <= s || !u && !d && b > s || (a = u ? "" : e(n[h + 1], t) + (d ? "" : i), !u && d && b > s && m + a.length > s))
      break;
    if (o += f, !u && !d && m + a.length >= s) {
      l = `${va}(${n.length - h - 1})`;
      break;
    }
    l = "";
  }
  return `${o}${l}`;
}
Et(Ji, "inspectList");
function h0(n) {
  return n.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? n : JSON.stringify(n).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
Et(h0, "quoteComplexKey");
function wa([n, t], e) {
  return e.truncate -= 2, typeof n == "string" ? n = h0(n) : typeof n != "number" && (n = `[${e.inspect(n, e)}]`), e.truncate -= n.length, t = e.inspect(t, e), `${n}: ${t}`;
}
Et(wa, "inspectProperty");
function f0(n, t) {
  const e = Object.keys(n).slice(n.length);
  if (!n.length && !e.length)
    return "[]";
  t.truncate -= 4;
  const i = Ji(n, t);
  t.truncate -= i.length;
  let r = "";
  return e.length && (r = Ji(e.map((s) => [s, n[s]]), t, wa)), `[ ${i}${r ? `, ${r}` : ""} ]`;
}
Et(f0, "inspectArray");
var ny = /* @__PURE__ */ Et((n) => typeof Buffer == "function" && n instanceof Buffer ? "Buffer" : n[Symbol.toStringTag] ? n[Symbol.toStringTag] : n.constructor.name, "getArrayName");
function Nr(n, t) {
  const e = ny(n);
  t.truncate -= e.length + 4;
  const i = Object.keys(n).slice(n.length);
  if (!n.length && !i.length)
    return `${e}[]`;
  let r = "";
  for (let o = 0; o < n.length; o++) {
    const a = `${t.stylize(rs(n[o], t.truncate), "number")}${o === n.length - 1 ? "" : ", "}`;
    if (t.truncate -= a.length, n[o] !== n.length && t.truncate <= 3) {
      r += `${va}(${n.length - n[o] + 1})`;
      break;
    }
    r += a;
  }
  let s = "";
  return i.length && (s = Ji(i.map((o) => [o, n[o]]), t, wa)), `${e}[ ${r}${s ? `, ${s}` : ""} ]`;
}
Et(Nr, "inspectTypedArray");
function d0(n, t) {
  const e = n.toJSON();
  if (e === null)
    return "Invalid Date";
  const i = e.split("T"), r = i[0];
  return t.stylize(`${r}T${rs(i[1], t.truncate - r.length - 1)}`, "date");
}
Et(d0, "inspectDate");
function qh(n, t) {
  const e = n[Symbol.toStringTag] || "Function", i = n.name;
  return i ? t.stylize(`[${e} ${rs(i, t.truncate - 11)}]`, "special") : t.stylize(`[${e}]`, "special");
}
Et(qh, "inspectFunction");
function p0([n, t], e) {
  return e.truncate -= 4, n = e.inspect(n, e), e.truncate -= n.length, t = e.inspect(t, e), `${n} => ${t}`;
}
Et(p0, "inspectMapEntry");
function g0(n) {
  const t = [];
  return n.forEach((e, i) => {
    t.push([i, e]);
  }), t;
}
Et(g0, "mapToEntries");
function m0(n, t) {
  return n.size - 1 <= 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Ji(g0(n), t, p0)} }`);
}
Et(m0, "inspectMap");
var iy = Number.isNaN || ((n) => n !== n);
function zh(n, t) {
  return iy(n) ? t.stylize("NaN", "number") : n === 1 / 0 ? t.stylize("Infinity", "number") : n === -1 / 0 ? t.stylize("-Infinity", "number") : n === 0 ? t.stylize(1 / n === 1 / 0 ? "+0" : "-0", "number") : t.stylize(rs(String(n), t.truncate), "number");
}
Et(zh, "inspectNumber");
function $h(n, t) {
  let e = rs(n.toString(), t.truncate - 1);
  return e !== va && (e += "n"), t.stylize(e, "bigint");
}
Et($h, "inspectBigInt");
function y0(n, t) {
  const e = n.toString().split("/")[2], i = t.truncate - (2 + e.length), r = n.source;
  return t.stylize(`/${rs(r, i)}/${e}`, "regexp");
}
Et(y0, "inspectRegExp");
function b0(n) {
  const t = [];
  return n.forEach((e) => {
    t.push(e);
  }), t;
}
Et(b0, "arrayFromSet");
function v0(n, t) {
  return n.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Ji(b0(n), t)} }`);
}
Et(v0, "inspectSet");
var xp = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), ry = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, sy = 16, oy = 4;
function w0(n) {
  return ry[n] || `\\u${`0000${n.charCodeAt(0).toString(sy)}`.slice(-oy)}`;
}
Et(w0, "escape");
function Uh(n, t) {
  return xp.test(n) && (n = n.replace(xp, w0)), t.stylize(`'${rs(n, t.truncate - 2)}'`, "string");
}
Et(Uh, "inspectString");
function Wh(n) {
  return "description" in Symbol.prototype ? n.description ? `Symbol(${n.description})` : "Symbol()" : n.toString();
}
Et(Wh, "inspectSymbol");
var x0 = /* @__PURE__ */ Et(() => "Promise{…}", "getPromiseValue");
try {
  const { getPromiseDetails: n, kPending: t, kRejected: e } = process.binding("util");
  Array.isArray(n(Promise.resolve())) && (x0 = /* @__PURE__ */ Et((i, r) => {
    const [s, o] = n(i);
    return s === t ? "Promise{<pending>}" : `Promise${s === e ? "!" : ""}{${r.inspect(o, r)}}`;
  }, "getPromiseValue"));
} catch {
}
var ay = x0;
function xl(n, t) {
  const e = Object.getOwnPropertyNames(n), i = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n) : [];
  if (e.length === 0 && i.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const r = Ji(e.map((a) => [a, n[a]]), t, wa), s = Ji(i.map((a) => [a, n[a]]), t, wa);
  t.seen.pop();
  let o = "";
  return r && s && (o = ", "), `{ ${r}${o}${s} }`;
}
Et(xl, "inspectObject");
var mh = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function _0(n, t) {
  let e = "";
  return mh && mh in n && (e = n[mh]), e = e || n.constructor.name, (!e || e === "_class") && (e = "<Anonymous Class>"), t.truncate -= e.length, `${e}${xl(n, t)}`;
}
Et(_0, "inspectClass");
function S0(n, t) {
  return n.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Ji(n, t)} ]`);
}
Et(S0, "inspectArguments");
var ly = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function k0(n, t) {
  const e = Object.getOwnPropertyNames(n).filter((o) => ly.indexOf(o) === -1), i = n.name;
  t.truncate -= i.length;
  let r = "";
  if (typeof n.message == "string" ? r = rs(n.message, t.truncate) : e.unshift("message"), r = r ? `: ${r}` : "", t.truncate -= r.length + 5, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const s = Ji(e.map((o) => [o, n[o]]), t, wa);
  return `${i}${r}${s ? ` { ${s} }` : ""}`;
}
Et(k0, "inspectObject");
function A0([n, t], e) {
  return e.truncate -= 3, t ? `${e.stylize(String(n), "yellow")}=${e.stylize(`"${t}"`, "string")}` : `${e.stylize(String(n), "yellow")}`;
}
Et(A0, "inspectAttribute");
function Qu(n, t) {
  return Ji(n, t, Mf, `
`);
}
Et(Qu, "inspectHTMLCollection");
function Mf(n, t) {
  const e = n.getAttributeNames(), i = n.tagName.toLowerCase(), r = t.stylize(`<${i}`, "special"), s = t.stylize(">", "special"), o = t.stylize(`</${i}>`, "special");
  t.truncate -= i.length * 2 + 5;
  let a = "";
  e.length > 0 && (a += " ", a += Ji(e.map((u) => [u, n.getAttribute(u)]), t, A0, " ")), t.truncate -= a.length;
  const l = t.truncate;
  let h = Qu(n.children, t);
  return h && h.length > l && (h = `${va}(${n.children.length})`), `${r}${a}${s}${h}${o}`;
}
Et(Mf, "inspectHTML");
var uy = typeof Symbol == "function" && typeof Symbol.for == "function", yh = uy ? Symbol.for("chai/inspect") : "@@chai/inspect", ga = !1;
try {
  const n = Q2();
  ga = n.inspect ? n.inspect.custom : !1;
} catch {
  ga = !1;
}
var _p = /* @__PURE__ */ new WeakMap(), Sp = {}, kp = {
  undefined: (n, t) => t.stylize("undefined", "undefined"),
  null: (n, t) => t.stylize("null", "null"),
  boolean: (n, t) => t.stylize(String(n), "boolean"),
  Boolean: (n, t) => t.stylize(String(n), "boolean"),
  number: zh,
  Number: zh,
  bigint: $h,
  BigInt: $h,
  string: Uh,
  String: Uh,
  function: qh,
  Function: qh,
  symbol: Wh,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: Wh,
  Array: f0,
  Date: d0,
  Map: m0,
  Set: v0,
  RegExp: y0,
  Promise: ay,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (n, t) => t.stylize("WeakSet{…}", "special"),
  WeakMap: (n, t) => t.stylize("WeakMap{…}", "special"),
  Arguments: S0,
  Int8Array: Nr,
  Uint8Array: Nr,
  Uint8ClampedArray: Nr,
  Int16Array: Nr,
  Uint16Array: Nr,
  Int32Array: Nr,
  Uint32Array: Nr,
  Float32Array: Nr,
  Float64Array: Nr,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: k0,
  HTMLCollection: Qu,
  NodeList: Qu
}, cy = /* @__PURE__ */ Et((n, t, e) => yh in n && typeof n[yh] == "function" ? n[yh](t) : ga && ga in n && typeof n[ga] == "function" ? n[ga](t.depth, t) : "inspect" in n && typeof n.inspect == "function" ? n.inspect(t.depth, t) : "constructor" in n && _p.has(n.constructor) ? _p.get(n.constructor)(n, t) : Sp[e] ? Sp[e](n, t) : "", "inspectCustom"), hy = Object.prototype.toString;
function tc(n, t = {}) {
  const e = u0(t, tc), { customInspect: i } = e;
  let r = n === null ? "null" : typeof n;
  if (r === "object" && (r = hy.call(n).slice(8, -1)), r in kp)
    return kp[r](n, e);
  if (i && n) {
    const o = cy(n, e, r);
    if (o)
      return typeof o == "string" ? o : tc(o, e);
  }
  const s = n ? Object.getPrototypeOf(n) : !1;
  return s === Object.prototype || s === null ? xl(n, e) : n && typeof HTMLElement == "function" && n instanceof HTMLElement ? Mf(n, e) : "constructor" in n ? n.constructor !== Object ? _0(n, e) : xl(n, e) : n === Object(n) ? xl(n, e) : e.stylize(String(n), r);
}
Et(tc, "inspect");
var pi = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function We(n, t, e, i) {
  var r = {
    colors: i,
    depth: typeof e > "u" ? 2 : e,
    showHidden: t,
    truncate: pi.truncateThreshold ? pi.truncateThreshold : 1 / 0
  };
  return tc(n, r);
}
Et(We, "inspect");
function mo(n) {
  var t = We(n), e = Object.prototype.toString.call(n);
  if (pi.truncateThreshold && t.length >= pi.truncateThreshold) {
    if (e === "[object Function]")
      return !n.name || n.name === "" ? "[Function]" : "[Function: " + n.name + "]";
    if (e === "[object Array]")
      return "[ Array(" + n.length + ") ]";
    if (e === "[object Object]") {
      var i = Object.keys(n), r = i.length > 2 ? i.splice(0, 2).join(", ") + ", ..." : i.join(", ");
      return "{ Object (" + r + ") }";
    } else
      return t;
  } else
    return t;
}
Et(mo, "objDisplay");
function Rf(n, t) {
  var e = De(n, "negate"), i = De(n, "object"), r = t[3], s = Sc(n, t), o = e ? t[2] : t[1], a = De(n, "message");
  return typeof o == "function" && (o = o()), o = o || "", o = o.replace(/#\{this\}/g, function() {
    return mo(i);
  }).replace(/#\{act\}/g, function() {
    return mo(s);
  }).replace(/#\{exp\}/g, function() {
    return mo(r);
  }), a ? a + ": " + o : o;
}
Et(Rf, "getMessage");
function mr(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), e = arguments.length === 3 ? e : !0;
  for (var r in i)
    (e || r !== "object" && r !== "ssfi" && r !== "lockSsfi" && r != "message") && (t.__flags[r] = i[r]);
}
Et(mr, "transferFlags");
function Hh(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
Et(Hh, "type");
function Df() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
Et(Df, "FakeMap");
Df.prototype = {
  get: /* @__PURE__ */ Et(function(t) {
    return t[this._key];
  }, "get"),
  set: /* @__PURE__ */ Et(function(t, e) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: e,
      configurable: !0
    });
  }, "set")
};
var N0 = typeof WeakMap == "function" ? WeakMap : Df;
function Gh(n, t, e) {
  if (!e || Ao(n) || Ao(t))
    return null;
  var i = e.get(n);
  if (i) {
    var r = i.get(t);
    if (typeof r == "boolean")
      return r;
  }
  return null;
}
Et(Gh, "memoizeCompare");
function ml(n, t, e, i) {
  if (!(!e || Ao(n) || Ao(t))) {
    var r = e.get(n);
    r ? r.set(t, i) : (r = new N0(), r.set(t, i), e.set(n, r));
  }
}
Et(ml, "memoizeSet");
var C0 = Ml;
function Ml(n, t, e) {
  if (e && e.comparator)
    return Vh(n, t, e);
  var i = Bf(n, t);
  return i !== null ? i : Vh(n, t, e);
}
Et(Ml, "deepEqual");
function Bf(n, t) {
  return n === t ? n !== 0 || 1 / n === 1 / t : n !== n && // eslint-disable-line no-self-compare
  t !== t ? !0 : Ao(n) || Ao(t) ? !1 : null;
}
Et(Bf, "simpleEqual");
function Vh(n, t, e) {
  e = e || {}, e.memoize = e.memoize === !1 ? !1 : e.memoize || new N0();
  var i = e && e.comparator, r = Gh(n, t, e.memoize);
  if (r !== null)
    return r;
  var s = Gh(t, n, e.memoize);
  if (s !== null)
    return s;
  if (i) {
    var o = i(n, t);
    if (o === !1 || o === !0)
      return ml(n, t, e.memoize, o), o;
    var a = Bf(n, t);
    if (a !== null)
      return a;
  }
  var l = Hh(n);
  if (l !== Hh(t))
    return ml(n, t, e.memoize, !1), !1;
  ml(n, t, e.memoize, !0);
  var h = P0(n, t, l, e);
  return ml(n, t, e.memoize, h), h;
}
Et(Vh, "extensiveDeepEqual");
function P0(n, t, e, i) {
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Ml(n.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return n === t;
    case "Error":
      return jf(n, t, ["name", "message", "code"], i);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Ms(n, t, i);
    case "RegExp":
      return L0(n, t);
    case "Generator":
      return I0(n, t, i);
    case "DataView":
      return Ms(new Uint8Array(n.buffer), new Uint8Array(t.buffer), i);
    case "ArrayBuffer":
      return Ms(new Uint8Array(n), new Uint8Array(t), i);
    case "Set":
      return Yh(n, t, i);
    case "Map":
      return Yh(n, t, i);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return n.equals(t);
    case "Temporal.Duration":
      return n.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return n.toString() === t.toString();
    default:
      return O0(n, t, i);
  }
}
Et(P0, "extensiveDeepEqualByType");
function L0(n, t) {
  return n.toString() === t.toString();
}
Et(L0, "regexpEqual");
function Yh(n, t, e) {
  try {
    if (n.size !== t.size)
      return !1;
    if (n.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var i = [], r = [];
  return n.forEach(/* @__PURE__ */ Et(function(o, a) {
    i.push([o, a]);
  }, "gatherEntries")), t.forEach(/* @__PURE__ */ Et(function(o, a) {
    r.push([o, a]);
  }, "gatherEntries")), Ms(i.sort(), r.sort(), e);
}
Et(Yh, "entriesEqual");
function Ms(n, t, e) {
  var i = n.length;
  if (i !== t.length)
    return !1;
  if (i === 0)
    return !0;
  for (var r = -1; ++r < i; )
    if (Ml(n[r], t[r], e) === !1)
      return !1;
  return !0;
}
Et(Ms, "iterableEqual");
function I0(n, t, e) {
  return Ms(ec(n), ec(t), e);
}
Et(I0, "generatorEqual");
function E0(n) {
  return typeof Symbol < "u" && typeof n == "object" && typeof Symbol.iterator < "u" && typeof n[Symbol.iterator] == "function";
}
Et(E0, "hasIteratorFunction");
function Kh(n) {
  if (E0(n))
    try {
      return ec(n[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
Et(Kh, "getIteratorEntries");
function ec(n) {
  for (var t = n.next(), e = [t.value]; t.done === !1; )
    t = n.next(), e.push(t.value);
  return e;
}
Et(ec, "getGeneratorEntries");
function Xh(n) {
  var t = [];
  for (var e in n)
    t.push(e);
  return t;
}
Et(Xh, "getEnumerableKeys");
function Jh(n) {
  for (var t = [], e = Object.getOwnPropertySymbols(n), i = 0; i < e.length; i += 1) {
    var r = e[i];
    Object.getOwnPropertyDescriptor(n, r).enumerable && t.push(r);
  }
  return t;
}
Et(Jh, "getEnumerableSymbols");
function jf(n, t, e, i) {
  var r = e.length;
  if (r === 0)
    return !0;
  for (var s = 0; s < r; s += 1)
    if (Ml(n[e[s]], t[e[s]], i) === !1)
      return !1;
  return !0;
}
Et(jf, "keysEqual");
function O0(n, t, e) {
  var i = Xh(n), r = Xh(t), s = Jh(n), o = Jh(t);
  if (i = i.concat(s), r = r.concat(o), i.length && i.length === r.length)
    return Ms(Zh(i).sort(), Zh(r).sort()) === !1 ? !1 : jf(n, t, i, e);
  var a = Kh(n), l = Kh(t);
  return a.length && a.length === l.length ? (a.sort(), l.sort(), Ms(a, l, e)) : i.length === 0 && a.length === 0 && r.length === 0 && l.length === 0;
}
Et(O0, "objectEqual");
function Ao(n) {
  return n === null || typeof n != "object";
}
Et(Ao, "isPrimitive");
function Zh(n) {
  return n.map(/* @__PURE__ */ Et(function(e) {
    return typeof e == "symbol" ? e.toString() : e;
  }, "mapSymbol"));
}
Et(Zh, "mapSymbols");
function kc(n, t) {
  return typeof n > "u" || n === null ? !1 : t in Object(n);
}
Et(kc, "hasProperty");
function T0(n) {
  return n.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((i) => {
    if (i === "constructor" || i === "__proto__" || i === "prototype")
      return {};
    const s = /^\[(\d+)\]$/.exec(i);
    let o = null;
    return s ? o = { i: parseFloat(s[1]) } : o = { p: i.replace(/\\([.[\]])/g, "$1") }, o;
  });
}
Et(T0, "parsePath");
function Qh(n, t, e) {
  let i = n, r = null;
  e = typeof e > "u" ? t.length : e;
  for (let s = 0; s < e; s++) {
    const o = t[s];
    i && (typeof o.p > "u" ? i = i[o.i] : i = i[o.p], s === e - 1 && (r = i));
  }
  return r;
}
Et(Qh, "internalGetPathValue");
function qf(n, t) {
  const e = T0(t), i = e[e.length - 1], r = {
    parent: e.length > 1 ? Qh(n, e, e.length - 1) : n,
    name: i.p || i.i,
    value: Qh(n, e)
  };
  return r.exists = kc(r.parent, r.name), r;
}
Et(qf, "getPathInfo");
function lt(n, t, e, i) {
  return De(this, "ssfi", e || lt), De(this, "lockSsfi", i), De(this, "object", n), De(this, "message", t), De(this, "eql", pi.deepEqual || C0), Aa(this);
}
Et(lt, "Assertion");
Object.defineProperty(lt, "includeStack", {
  get: function() {
    return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), pi.includeStack;
  },
  set: function(n) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), pi.includeStack = n;
  }
});
Object.defineProperty(lt, "showDiff", {
  get: function() {
    return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), pi.showDiff;
  },
  set: function(n) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), pi.showDiff = n;
  }
});
lt.addProperty = function(n, t) {
  zf(this.prototype, n, t);
};
lt.addMethod = function(n, t) {
  $f(this.prototype, n, t);
};
lt.addChainableMethod = function(n, t, e) {
  Hf(this.prototype, n, t, e);
};
lt.overwriteProperty = function(n, t) {
  Uf(this.prototype, n, t);
};
lt.overwriteMethod = function(n, t) {
  Wf(this.prototype, n, t);
};
lt.overwriteChainableMethod = function(n, t, e) {
  Gf(this.prototype, n, t, e);
};
lt.prototype.assert = function(n, t, e, i, r, s) {
  var o = Ff(this, arguments);
  if (s !== !1 && (s = !0), i === void 0 && r === void 0 && (s = !1), pi.showDiff !== !0 && (s = !1), !o) {
    t = Rf(this, arguments);
    var a = Sc(this, arguments), l = {
      actual: a,
      expected: i,
      showDiff: s
    }, h = Kf(this, arguments);
    throw h && (l.operator = h), new Ye(
      t,
      l,
      pi.includeStack ? this.assert : De(this, "ssfi")
    );
  }
};
Object.defineProperty(
  lt.prototype,
  "_obj",
  {
    get: function() {
      return De(this, "object");
    },
    set: function(n) {
      De(this, "object", n);
    }
  }
);
function Rl() {
  return pi.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
Et(Rl, "isProxyEnabled");
function zf(n, t, e) {
  e = e === void 0 ? function() {
  } : e, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ Et(function i() {
        !Rl() && !De(this, "lockSsfi") && De(this, "ssfi", i);
        var r = e.call(this);
        if (r !== void 0)
          return r;
        var s = new lt();
        return mr(this, s), s;
      }, "propertyGetter"),
      configurable: !0
    }
  );
}
Et(zf, "addProperty");
var fy = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Dl(n, t, e) {
  return fy.configurable && Object.defineProperty(n, "length", {
    get: function() {
      throw Error(e ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".');
    }
  }), n;
}
Et(Dl, "addLengthGuard");
function F0(n) {
  var t = Object.getOwnPropertyNames(n);
  function e(r) {
    t.indexOf(r) === -1 && t.push(r);
  }
  Et(e, "addProperty");
  for (var i = Object.getPrototypeOf(n); i !== null; )
    Object.getOwnPropertyNames(i).forEach(e), i = Object.getPrototypeOf(i);
  return t;
}
Et(F0, "getProperties");
var Ap = ["__flags", "__methods", "_obj", "assert"];
function Aa(n, t) {
  return Rl() ? new Proxy(n, {
    get: /* @__PURE__ */ Et(function e(i, r) {
      if (typeof r == "string" && pi.proxyExcludedKeys.indexOf(r) === -1 && !Reflect.has(i, r)) {
        if (t)
          throw Error("Invalid Chai property: " + t + "." + r + '. See docs for proper usage of "' + t + '".');
        var s = null, o = 4;
        throw F0(i).forEach(function(a) {
          if (!Object.prototype.hasOwnProperty(a) && Ap.indexOf(a) === -1) {
            var l = M0(
              r,
              a,
              o
            );
            l < o && (s = a, o = l);
          }
        }), Error(s !== null ? "Invalid Chai property: " + r + '. Did you mean "' + s + '"?' : "Invalid Chai property: " + r);
      }
      return Ap.indexOf(r) === -1 && !De(i, "lockSsfi") && De(i, "ssfi", e), Reflect.get(i, r);
    }, "proxyGetter")
  }) : n;
}
Et(Aa, "proxify");
function M0(n, t, e) {
  if (Math.abs(n.length - t.length) >= e)
    return e;
  for (var i = [], r = 0; r <= n.length; r++)
    i[r] = Array(t.length + 1).fill(0), i[r][0] = r;
  for (var s = 0; s < t.length; s++)
    i[0][s] = s;
  for (var r = 1; r <= n.length; r++)
    for (var o = n.charCodeAt(r - 1), s = 1; s <= t.length; s++) {
      if (Math.abs(r - s) >= e) {
        i[r][s] = e;
        continue;
      }
      i[r][s] = Math.min(
        i[r - 1][s] + 1,
        i[r][s - 1] + 1,
        i[r - 1][s - 1] + (o === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  return i[n.length][t.length];
}
Et(M0, "stringDistanceCapped");
function $f(n, t, e) {
  var i = /* @__PURE__ */ Et(function() {
    De(this, "lockSsfi") || De(this, "ssfi", i);
    var r = e.apply(this, arguments);
    if (r !== void 0)
      return r;
    var s = new lt();
    return mr(this, s), s;
  }, "methodWrapper");
  Dl(i, t, !1), n[t] = Aa(i, t);
}
Et($f, "addMethod");
function Uf(n, t, e) {
  var i = Object.getOwnPropertyDescriptor(n, t), r = /* @__PURE__ */ Et(function() {
  }, "_super");
  i && typeof i.get == "function" && (r = i.get), Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ Et(function s() {
        !Rl() && !De(this, "lockSsfi") && De(this, "ssfi", s);
        var o = De(this, "lockSsfi");
        De(this, "lockSsfi", !0);
        var a = e(r).call(this);
        if (De(this, "lockSsfi", o), a !== void 0)
          return a;
        var l = new lt();
        return mr(this, l), l;
      }, "overwritingPropertyGetter"),
      configurable: !0
    }
  );
}
Et(Uf, "overwriteProperty");
function Wf(n, t, e) {
  var i = n[t], r = /* @__PURE__ */ Et(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  i && typeof i == "function" && (r = i);
  var s = /* @__PURE__ */ Et(function() {
    De(this, "lockSsfi") || De(this, "ssfi", s);
    var o = De(this, "lockSsfi");
    De(this, "lockSsfi", !0);
    var a = e(r).apply(this, arguments);
    if (De(this, "lockSsfi", o), a !== void 0)
      return a;
    var l = new lt();
    return mr(this, l), l;
  }, "overwritingMethodWrapper");
  Dl(s, t, !1), n[t] = Aa(s, t);
}
Et(Wf, "overwriteMethod");
var dy = typeof Object.setPrototypeOf == "function", Np = /* @__PURE__ */ Et(function() {
}, "testFn"), py = Object.getOwnPropertyNames(Np).filter(function(n) {
  var t = Object.getOwnPropertyDescriptor(Np, n);
  return typeof t != "object" ? !0 : !t.configurable;
}), gy = Function.prototype.call, my = Function.prototype.apply;
function Hf(n, t, e, i) {
  typeof i != "function" && (i = /* @__PURE__ */ Et(function() {
  }, "chainingBehavior"));
  var r = {
    method: e,
    chainingBehavior: i
  };
  n.__methods || (n.__methods = {}), n.__methods[t] = r, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ Et(function() {
        r.chainingBehavior.call(this);
        var o = /* @__PURE__ */ Et(function() {
          De(this, "lockSsfi") || De(this, "ssfi", o);
          var h = r.method.apply(this, arguments);
          if (h !== void 0)
            return h;
          var u = new lt();
          return mr(this, u), u;
        }, "chainableMethodWrapper");
        if (Dl(o, t, !0), dy) {
          var a = Object.create(this);
          a.call = gy, a.apply = my, Object.setPrototypeOf(o, a);
        } else {
          var l = Object.getOwnPropertyNames(n);
          l.forEach(function(h) {
            if (py.indexOf(h) === -1) {
              var u = Object.getOwnPropertyDescriptor(n, h);
              Object.defineProperty(o, h, u);
            }
          });
        }
        return mr(this, o), Aa(o);
      }, "chainableMethodGetter"),
      configurable: !0
    }
  );
}
Et(Hf, "addChainableMethod");
function Gf(n, t, e, i) {
  var r = n.__methods[t], s = r.chainingBehavior;
  r.chainingBehavior = /* @__PURE__ */ Et(function() {
    var l = i(s).call(this);
    if (l !== void 0)
      return l;
    var h = new lt();
    return mr(this, h), h;
  }, "overwritingChainableMethodGetter");
  var o = r.method;
  r.method = /* @__PURE__ */ Et(function() {
    var l = e(o).apply(this, arguments);
    if (l !== void 0)
      return l;
    var h = new lt();
    return mr(this, h), h;
  }, "overwritingChainableMethodWrapper");
}
Et(Gf, "overwriteChainableMethod");
function nc(n, t) {
  return We(n) < We(t) ? -1 : 1;
}
Et(nc, "compareByInspect");
function Vf(n) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(n).filter(function(t) {
    return Object.getOwnPropertyDescriptor(n, t).enumerable;
  });
}
Et(Vf, "getOwnEnumerablePropertySymbols");
function Yf(n) {
  return Object.keys(n).concat(Vf(n));
}
Et(Yf, "getOwnEnumerableProperties");
function R0(n) {
  return n !== n;
}
Et(R0, "_isNaN");
var ic = Number.isNaN || R0;
function D0(n) {
  var t = on(n), e = ["Array", "Object", "Function"];
  return e.indexOf(t) !== -1;
}
Et(D0, "isObjectType");
function Kf(n, t) {
  var e = De(n, "operator"), i = De(n, "negate"), r = t[3], s = i ? t[2] : t[1];
  if (e)
    return e;
  if (typeof s == "function" && (s = s()), s = s || "", !!s && !/\shave\s/.test(s)) {
    var o = D0(r);
    return /\snot\s/.test(s) ? o ? "notDeepStrictEqual" : "notStrictEqual" : o ? "deepStrictEqual" : "strictEqual";
  }
}
Et(Kf, "getOperator");
function Ac(n) {
  return n.name;
}
Et(Ac, "getName");
function rc(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
Et(rc, "isRegExp");
function Gn(n) {
  return ["Number", "BigInt"].includes(on(n));
}
Et(Gn, "isNumeric");
var { flag: At } = Zu;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(n) {
  lt.addProperty(n);
});
lt.addProperty("not", function() {
  At(this, "negate", !0);
});
lt.addProperty("deep", function() {
  At(this, "deep", !0);
});
lt.addProperty("nested", function() {
  At(this, "nested", !0);
});
lt.addProperty("own", function() {
  At(this, "own", !0);
});
lt.addProperty("ordered", function() {
  At(this, "ordered", !0);
});
lt.addProperty("any", function() {
  At(this, "any", !0), At(this, "all", !1);
});
lt.addProperty("all", function() {
  At(this, "all", !0), At(this, "any", !1);
});
var Cp = {
  function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function Xf(n, t) {
  t && At(this, "message", t), n = n.toLowerCase();
  var e = At(this, "object"), i = ~["a", "e", "i", "o", "u"].indexOf(n.charAt(0)) ? "an " : "a ";
  const r = on(e).toLowerCase();
  Cp.function.includes(n) ? this.assert(
    Cp[n].includes(r),
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  ) : this.assert(
    n === r,
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  );
}
Et(Xf, "an");
lt.addChainableMethod("an", Xf);
lt.addChainableMethod("a", Xf);
function B0(n, t) {
  return ic(n) && ic(t) || n === t;
}
Et(B0, "SameValueZero");
function Bl() {
  At(this, "contains", !0);
}
Et(Bl, "includeChainingBehavior");
function jl(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = on(e).toLowerCase(), r = At(this, "message"), s = At(this, "negate"), o = At(this, "ssfi"), a = At(this, "deep"), l = a ? "deep " : "", h = a ? At(this, "eql") : B0;
  r = r ? r + ": " : "";
  var u = !1;
  switch (i) {
    case "string":
      u = e.indexOf(n) !== -1;
      break;
    case "weakset":
      if (a)
        throw new Ye(
          r + "unable to use .deep.include with WeakSet",
          void 0,
          o
        );
      u = e.has(n);
      break;
    case "map":
      e.forEach(function(m) {
        u = u || h(m, n);
      });
      break;
    case "set":
      a ? e.forEach(function(m) {
        u = u || h(m, n);
      }) : u = e.has(n);
      break;
    case "array":
      a ? u = e.some(function(m) {
        return h(m, n);
      }) : u = e.indexOf(n) !== -1;
      break;
    default:
      if (n !== Object(n))
        throw new Ye(
          r + "the given combination of arguments (" + i + " and " + on(n).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + on(n).toLowerCase(),
          void 0,
          o
        );
      var d = Object.keys(n), p = null, f = 0;
      if (d.forEach(function(m) {
        var b = new lt(e);
        if (mr(this, b, !0), At(b, "lockSsfi", !0), !s || d.length === 1) {
          b.property(m, n[m]);
          return;
        }
        try {
          b.property(m, n[m]);
        } catch (x) {
          if (!Mi.compatibleConstructor(x, Ye))
            throw x;
          p === null && (p = x), f++;
        }
      }, this), s && d.length > 1 && f === d.length)
        throw p;
      return;
  }
  this.assert(
    u,
    "expected #{this} to " + l + "include " + We(n),
    "expected #{this} to not " + l + "include " + We(n)
  );
}
Et(jl, "include");
lt.addChainableMethod("include", jl, Bl);
lt.addChainableMethod("contain", jl, Bl);
lt.addChainableMethod("contains", jl, Bl);
lt.addChainableMethod("includes", jl, Bl);
lt.addProperty("ok", function() {
  this.assert(
    At(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
lt.addProperty("true", function() {
  this.assert(
    At(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !At(this, "negate")
  );
});
lt.addProperty("numeric", function() {
  const n = At(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(on(n)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !At(this, "negate")
  );
});
lt.addProperty("callable", function() {
  const n = At(this, "object"), t = At(this, "ssfi"), e = At(this, "message"), i = e ? `${e}: ` : "", r = At(this, "negate"), s = r ? `${i}expected ${We(n)} not to be a callable function` : `${i}expected ${We(n)} to be a callable function`, o = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(on(n));
  if (o && r || !o && !r)
    throw new Ye(
      s,
      void 0,
      t
    );
});
lt.addProperty("false", function() {
  this.assert(
    At(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!At(this, "negate")
  );
});
lt.addProperty("null", function() {
  this.assert(
    At(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
lt.addProperty("undefined", function() {
  this.assert(
    At(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
lt.addProperty("NaN", function() {
  this.assert(
    ic(At(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function Jf() {
  var n = At(this, "object");
  this.assert(
    n != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
Et(Jf, "assertExist");
lt.addProperty("exist", Jf);
lt.addProperty("exists", Jf);
lt.addProperty("empty", function() {
  var n = At(this, "object"), t = At(this, "ssfi"), e = At(this, "message"), i;
  switch (e = e ? e + ": " : "", on(n).toLowerCase()) {
    case "array":
    case "string":
      i = n.length;
      break;
    case "map":
    case "set":
      i = n.size;
      break;
    case "weakmap":
    case "weakset":
      throw new Ye(
        e + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function":
      var r = e + ".empty was passed a function " + Ac(n);
      throw new Ye(r.trim(), void 0, t);
    default:
      if (n !== Object(n))
        throw new Ye(
          e + ".empty was passed non-string primitive " + We(n),
          void 0,
          t
        );
      i = Object.keys(n).length;
  }
  this.assert(
    i === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function Zf() {
  var n = At(this, "object"), t = on(n);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
Et(Zf, "checkArguments");
lt.addProperty("arguments", Zf);
lt.addProperty("Arguments", Zf);
function Nc(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object");
  if (At(this, "deep")) {
    var i = At(this, "lockSsfi");
    At(this, "lockSsfi", !0), this.eql(n), At(this, "lockSsfi", i);
  } else
    this.assert(
      n === e,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      n,
      this._obj,
      !0
    );
}
Et(Nc, "assertEqual");
lt.addMethod("equal", Nc);
lt.addMethod("equals", Nc);
lt.addMethod("eq", Nc);
function Qf(n, t) {
  t && At(this, "message", t);
  var e = At(this, "eql");
  this.assert(
    e(n, At(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    n,
    this._obj,
    !0
  );
}
Et(Qf, "assertEql");
lt.addMethod("eql", Qf);
lt.addMethod("eqls", Qf);
function Cc(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "doLength"), r = At(this, "message"), s = r ? r + ": " : "", o = At(this, "ssfi"), a = on(e).toLowerCase(), l = on(n).toLowerCase();
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    throw new Ye(s + "the argument to above must be a date", void 0, o);
  if (!Gn(n) && (i || Gn(e)))
    throw new Ye(s + "the argument to above must be a number", void 0, o);
  if (!i && a !== "date" && !Gn(e)) {
    var h = a === "string" ? "'" + e + "'" : e;
    throw new Ye(s + "expected " + h + " to be a number or a date", void 0, o);
  }
  if (i) {
    var u = "length", d;
    a === "map" || a === "set" ? (u = "size", d = e.size) : d = e.length, this.assert(
      d > n,
      "expected #{this} to have a " + u + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + u + " above #{exp}",
      n,
      d
    );
  } else
    this.assert(
      e > n,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n
    );
}
Et(Cc, "assertAbove");
lt.addMethod("above", Cc);
lt.addMethod("gt", Cc);
lt.addMethod("greaterThan", Cc);
function Pc(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "doLength"), r = At(this, "message"), s = r ? r + ": " : "", o = At(this, "ssfi"), a = on(e).toLowerCase(), l = on(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to least must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to least must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f >= n,
      "expected #{this} to have a " + p + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e >= n,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n
    );
}
Et(Pc, "assertLeast");
lt.addMethod("least", Pc);
lt.addMethod("gte", Pc);
lt.addMethod("greaterThanOrEqual", Pc);
function Lc(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "doLength"), r = At(this, "message"), s = r ? r + ": " : "", o = At(this, "ssfi"), a = on(e).toLowerCase(), l = on(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to below must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to below must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f < n,
      "expected #{this} to have a " + p + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e < n,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n
    );
}
Et(Lc, "assertBelow");
lt.addMethod("below", Lc);
lt.addMethod("lt", Lc);
lt.addMethod("lessThan", Lc);
function Ic(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "doLength"), r = At(this, "message"), s = r ? r + ": " : "", o = At(this, "ssfi"), a = on(e).toLowerCase(), l = on(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to most must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to most must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f <= n,
      "expected #{this} to have a " + p + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + p + " above #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e <= n,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n
    );
}
Et(Ic, "assertMost");
lt.addMethod("most", Ic);
lt.addMethod("lte", Ic);
lt.addMethod("lessThanOrEqual", Ic);
lt.addMethod("within", function(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "object"), r = At(this, "doLength"), s = At(this, "message"), o = s ? s + ": " : "", a = At(this, "ssfi"), l = on(i).toLowerCase(), h = on(n).toLowerCase(), u = on(t).toLowerCase(), d, p = !0, f = h === "date" && u === "date" ? n.toISOString() + ".." + t.toISOString() : n + ".." + t;
  if (r && l !== "map" && l !== "set" && new lt(i, s, a, !0).to.have.property("length"), !r && l === "date" && (h !== "date" || u !== "date"))
    d = o + "the arguments to within must be dates";
  else if ((!Gn(n) || !Gn(t)) && (r || Gn(i)))
    d = o + "the arguments to within must be numbers";
  else if (!r && l !== "date" && !Gn(i)) {
    var m = l === "string" ? "'" + i + "'" : i;
    d = o + "expected " + m + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Ye(d, void 0, a);
  if (r) {
    var b = "length", x;
    l === "map" || l === "set" ? (b = "size", x = i.size) : x = i.length, this.assert(
      x >= n && x <= t,
      "expected #{this} to have a " + b + " within " + f,
      "expected #{this} to not have a " + b + " within " + f
    );
  } else
    this.assert(
      i >= n && i <= t,
      "expected #{this} to be within " + f,
      "expected #{this} to not be within " + f
    );
});
function td(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "ssfi"), r = At(this, "message");
  try {
    var s = e instanceof n;
  } catch (a) {
    throw a instanceof TypeError ? (r = r ? r + ": " : "", new Ye(
      r + "The instanceof assertion needs a constructor but " + on(n) + " was given.",
      void 0,
      i
    )) : a;
  }
  var o = Ac(n);
  o == null && (o = "an unnamed constructor"), this.assert(
    s,
    "expected #{this} to be an instance of " + o,
    "expected #{this} to not be an instance of " + o
  );
}
Et(td, "assertInstanceOf");
lt.addMethod("instanceof", td);
lt.addMethod("instanceOf", td);
function ed(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "nested"), r = At(this, "own"), s = At(this, "message"), o = At(this, "object"), a = At(this, "ssfi"), l = typeof n;
  if (s = s ? s + ": " : "", i) {
    if (l !== "string")
      throw new Ye(
        s + "the argument to property must be a string when using nested syntax",
        void 0,
        a
      );
  } else if (l !== "string" && l !== "number" && l !== "symbol")
    throw new Ye(
      s + "the argument to property must be a string, number, or symbol",
      void 0,
      a
    );
  if (i && r)
    throw new Ye(
      s + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      a
    );
  if (o == null)
    throw new Ye(
      s + "Target cannot be null or undefined.",
      void 0,
      a
    );
  var h = At(this, "deep"), u = At(this, "negate"), d = i ? qf(o, n) : null, p = i ? d.value : o[n], f = h ? At(this, "eql") : (x, y) => x === y, m = "";
  h && (m += "deep "), r && (m += "own "), i && (m += "nested "), m += "property ";
  var b;
  r ? b = Object.prototype.hasOwnProperty.call(o, n) : i ? b = d.exists : b = kc(o, n), (!u || arguments.length === 1) && this.assert(
    b,
    "expected #{this} to have " + m + We(n),
    "expected #{this} to not have " + m + We(n)
  ), arguments.length > 1 && this.assert(
    b && f(t, p),
    "expected #{this} to have " + m + We(n) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + m + We(n) + " of #{act}",
    t,
    p
  ), At(this, "object", p);
}
Et(ed, "assertProperty");
lt.addMethod("property", ed);
function nd(n, t, e) {
  At(this, "own", !0), ed.apply(this, arguments);
}
Et(nd, "assertOwnProperty");
lt.addMethod("ownProperty", nd);
lt.addMethod("haveOwnProperty", nd);
function id(n, t, e) {
  typeof t == "string" && (e = t, t = null), e && At(this, "message", e);
  var i = At(this, "object"), r = Object.getOwnPropertyDescriptor(Object(i), n), s = At(this, "eql");
  r && t ? this.assert(
    s(t, r),
    "expected the own property descriptor for " + We(n) + " on #{this} to match " + We(t) + ", got " + We(r),
    "expected the own property descriptor for " + We(n) + " on #{this} to not match " + We(t),
    t,
    r,
    !0
  ) : this.assert(
    r,
    "expected #{this} to have an own property descriptor for " + We(n),
    "expected #{this} to not have an own property descriptor for " + We(n)
  ), At(this, "object", r);
}
Et(id, "assertOwnPropertyDescriptor");
lt.addMethod("ownPropertyDescriptor", id);
lt.addMethod("haveOwnPropertyDescriptor", id);
function rd() {
  At(this, "doLength", !0);
}
Et(rd, "assertLengthChain");
function sd(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = on(e).toLowerCase(), r = At(this, "message"), s = At(this, "ssfi"), o = "length", a;
  switch (i) {
    case "map":
    case "set":
      o = "size", a = e.size;
      break;
    default:
      new lt(e, r, s, !0).to.have.property("length"), a = e.length;
  }
  this.assert(
    a == n,
    "expected #{this} to have a " + o + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + o + " of #{act}",
    n,
    a
  );
}
Et(sd, "assertLength");
lt.addChainableMethod("length", sd, rd);
lt.addChainableMethod("lengthOf", sd, rd);
function od(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object");
  this.assert(
    n.exec(e),
    "expected #{this} to match " + n,
    "expected #{this} not to match " + n
  );
}
Et(od, "assertMatch");
lt.addMethod("match", od);
lt.addMethod("matches", od);
lt.addMethod("string", function(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "message"), r = At(this, "ssfi");
  new lt(e, i, r, !0).is.a("string"), this.assert(
    ~e.indexOf(n),
    "expected #{this} to contain " + We(n),
    "expected #{this} to not contain " + We(n)
  );
});
function ad(n) {
  var t = At(this, "object"), e = on(t), i = on(n), r = At(this, "ssfi"), s = At(this, "deep"), o, a = "", l, h = !0, u = At(this, "message");
  u = u ? u + ": " : "";
  var d = u + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (e === "Map" || e === "Set")
    a = s ? "deeply " : "", l = [], t.forEach(function(v, k) {
      l.push(k);
    }), i !== "Array" && (n = Array.prototype.slice.call(arguments));
  else {
    switch (l = Yf(t), i) {
      case "Array":
        if (arguments.length > 1)
          throw new Ye(d, void 0, r);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new Ye(d, void 0, r);
        n = Object.keys(n);
        break;
      default:
        n = Array.prototype.slice.call(arguments);
    }
    n = n.map(function(v) {
      return typeof v == "symbol" ? v : String(v);
    });
  }
  if (!n.length)
    throw new Ye(u + "keys required", void 0, r);
  var p = n.length, f = At(this, "any"), m = At(this, "all"), b = n, x = s ? At(this, "eql") : (v, k) => v === k;
  if (!f && !m && (m = !0), f && (h = b.some(function(v) {
    return l.some(function(k) {
      return x(v, k);
    });
  })), m && (h = b.every(function(v) {
    return l.some(function(k) {
      return x(v, k);
    });
  }), At(this, "contains") || (h = h && n.length == l.length)), p > 1) {
    n = n.map(function(v) {
      return We(v);
    });
    var y = n.pop();
    m && (o = n.join(", ") + ", and " + y), f && (o = n.join(", ") + ", or " + y);
  } else
    o = We(n[0]);
  o = (p > 1 ? "keys " : "key ") + o, o = (At(this, "contains") ? "contain " : "have ") + o, this.assert(
    h,
    "expected #{this} to " + a + o,
    "expected #{this} to not " + a + o,
    b.slice(0).sort(nc),
    l.sort(nc),
    !0
  );
}
Et(ad, "assertKeys");
lt.addMethod("keys", ad);
lt.addMethod("key", ad);
function Ec(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "object"), r = At(this, "ssfi"), s = At(this, "message"), o = At(this, "negate") || !1;
  new lt(i, s, r, !0).is.a("function"), (rc(n) || typeof n == "string") && (t = n, n = null);
  let a, l = !1;
  try {
    i();
  } catch (v) {
    l = !0, a = v;
  }
  var h = n === void 0 && t === void 0, u = !!(n && t), d = !1, p = !1;
  if (h || !h && !o) {
    var f = "an error";
    n instanceof Error ? f = "#{exp}" : n && (f = Mi.getConstructorName(n));
    let v = a;
    if (a instanceof Error)
      v = a.toString();
    else if (typeof a == "string")
      v = a;
    else if (a && (typeof a == "object" || typeof a == "function"))
      try {
        v = Mi.getConstructorName(a);
      } catch {
      }
    this.assert(
      l,
      "expected #{this} to throw " + f,
      "expected #{this} to not throw an error but #{act} was thrown",
      n && n.toString(),
      v
    );
  }
  if (n && a) {
    if (n instanceof Error) {
      var m = Mi.compatibleInstance(a, n);
      m === o && (u && o ? d = !0 : this.assert(
        o,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (a && !o ? " but #{act} was thrown" : ""),
        n.toString(),
        a.toString()
      ));
    }
    var b = Mi.compatibleConstructor(a, n);
    b === o && (u && o ? d = !0 : this.assert(
      o,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
      n instanceof Error ? n.toString() : n && Mi.getConstructorName(n),
      a instanceof Error ? a.toString() : a && Mi.getConstructorName(a)
    ));
  }
  if (a && t !== void 0 && t !== null) {
    var x = "including";
    rc(t) && (x = "matching");
    var y = Mi.compatibleMessage(a, t);
    y === o && (u && o ? p = !0 : this.assert(
      o,
      "expected #{this} to throw error " + x + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + x + " #{exp}",
      t,
      Mi.getMessage(a)
    ));
  }
  d && p && this.assert(
    o,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
    n instanceof Error ? n.toString() : n && Mi.getConstructorName(n),
    a instanceof Error ? a.toString() : a && Mi.getConstructorName(a)
  ), At(this, "object", a);
}
Et(Ec, "assertThrows");
lt.addMethod("throw", Ec);
lt.addMethod("throws", Ec);
lt.addMethod("Throw", Ec);
function ld(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "itself"), r = typeof e == "function" && !i ? e.prototype[n] : e[n];
  this.assert(
    typeof r == "function",
    "expected #{this} to respond to " + We(n),
    "expected #{this} to not respond to " + We(n)
  );
}
Et(ld, "respondTo");
lt.addMethod("respondTo", ld);
lt.addMethod("respondsTo", ld);
lt.addProperty("itself", function() {
  At(this, "itself", !0);
});
function ud(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = n(e);
  this.assert(
    i,
    "expected #{this} to satisfy " + mo(n),
    "expected #{this} to not satisfy" + mo(n),
    !At(this, "negate"),
    i
  );
}
Et(ud, "satisfy");
lt.addMethod("satisfy", ud);
lt.addMethod("satisfies", ud);
function cd(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "object"), r = At(this, "message"), s = At(this, "ssfi");
  new lt(i, r, s, !0).is.numeric;
  let o = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new Ye(r ? `${r}: ${o}` : o, void 0, s);
  if (new lt(t, r, s, !0).is.numeric, o = "A `expected` value is required for `closeTo`", n == null)
    throw new Ye(r ? `${r}: ${o}` : o, void 0, s);
  new lt(n, r, s, !0).is.numeric;
  const a = /* @__PURE__ */ Et((l) => l < 0n ? -l : l, "abs");
  this.assert(
    a(i - n) <= t,
    "expected #{this} to be close to " + n + " +/- " + t,
    "expected #{this} not to be close to " + n + " +/- " + t
  );
}
Et(cd, "closeTo");
lt.addMethod("closeTo", cd);
lt.addMethod("approximately", cd);
function j0(n, t, e, i, r) {
  let s = Array.from(t), o = Array.from(n);
  if (!i) {
    if (o.length !== s.length)
      return !1;
    s = s.slice();
  }
  return o.every(function(a, l) {
    if (r)
      return e ? e(a, s[l]) : a === s[l];
    if (!e) {
      var h = s.indexOf(a);
      return h === -1 ? !1 : (i || s.splice(h, 1), !0);
    }
    return s.some(function(u, d) {
      return e(a, u) ? (i || s.splice(d, 1), !0) : !1;
    });
  });
}
Et(j0, "isSubsetOf");
lt.addMethod("members", function(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "message"), r = At(this, "ssfi");
  new lt(e, i, r, !0).to.be.iterable, new lt(n, i, r, !0).to.be.iterable;
  var s = At(this, "contains"), o = At(this, "ordered"), a, l, h;
  s ? (a = o ? "an ordered superset" : "a superset", l = "expected #{this} to be " + a + " of #{exp}", h = "expected #{this} to not be " + a + " of #{exp}") : (a = o ? "ordered members" : "members", l = "expected #{this} to have the same " + a + " as #{exp}", h = "expected #{this} to not have the same " + a + " as #{exp}");
  var u = At(this, "deep") ? At(this, "eql") : void 0;
  this.assert(
    j0(n, e, u, s, o),
    l,
    h,
    n,
    e,
    !0
  );
});
lt.addProperty("iterable", function(n) {
  n && At(this, "message", n);
  var t = At(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function q0(n, t) {
  t && At(this, "message", t);
  var e = At(this, "object"), i = At(this, "message"), r = At(this, "ssfi"), s = At(this, "contains"), o = At(this, "deep"), a = At(this, "eql");
  new lt(n, i, r, !0).to.be.an("array"), s ? this.assert(
    n.some(function(l) {
      return e.indexOf(l) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    n,
    e
  ) : o ? this.assert(
    n.some(function(l) {
      return a(e, l);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    n,
    e
  ) : this.assert(
    n.indexOf(e) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    n,
    e
  );
}
Et(q0, "oneOf");
lt.addMethod("oneOf", q0);
function hd(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "object"), r = At(this, "message"), s = At(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  At(this, "deltaMsgObj", l), At(this, "initialDeltaValue", o), At(this, "finalDeltaValue", a), At(this, "deltaBehavior", "change"), At(this, "realDelta", a !== o), this.assert(
    o !== a,
    "expected " + l + " to change",
    "expected " + l + " to not change"
  );
}
Et(hd, "assertChanges");
lt.addMethod("change", hd);
lt.addMethod("changes", hd);
function fd(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "object"), r = At(this, "message"), s = At(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), new lt(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  At(this, "deltaMsgObj", l), At(this, "initialDeltaValue", o), At(this, "finalDeltaValue", a), At(this, "deltaBehavior", "increase"), At(this, "realDelta", a - o), this.assert(
    a - o > 0,
    "expected " + l + " to increase",
    "expected " + l + " to not increase"
  );
}
Et(fd, "assertIncreases");
lt.addMethod("increase", fd);
lt.addMethod("increases", fd);
function dd(n, t, e) {
  e && At(this, "message", e);
  var i = At(this, "object"), r = At(this, "message"), s = At(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), new lt(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  At(this, "deltaMsgObj", l), At(this, "initialDeltaValue", o), At(this, "finalDeltaValue", a), At(this, "deltaBehavior", "decrease"), At(this, "realDelta", o - a), this.assert(
    a - o < 0,
    "expected " + l + " to decrease",
    "expected " + l + " to not decrease"
  );
}
Et(dd, "assertDecreases");
lt.addMethod("decrease", dd);
lt.addMethod("decreases", dd);
function z0(n, t) {
  t && At(this, "message", t);
  var e = At(this, "deltaMsgObj"), i = At(this, "initialDeltaValue"), r = At(this, "finalDeltaValue"), s = At(this, "deltaBehavior"), o = At(this, "realDelta"), a;
  s === "change" ? a = Math.abs(r - i) === Math.abs(n) : a = o === Math.abs(n), this.assert(
    a,
    "expected " + e + " to " + s + " by " + n,
    "expected " + e + " to not " + s + " by " + n
  );
}
Et(z0, "assertDelta");
lt.addMethod("by", z0);
lt.addProperty("extensible", function() {
  var n = At(this, "object"), t = n === Object(n) && Object.isExtensible(n);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
lt.addProperty("sealed", function() {
  var n = At(this, "object"), t = n === Object(n) ? Object.isSealed(n) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
lt.addProperty("frozen", function() {
  var n = At(this, "object"), t = n === Object(n) ? Object.isFrozen(n) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
lt.addProperty("finite", function(n) {
  var t = At(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Rs(n, t) {
  return new lt(n, t);
}
Et(Rs, "expect");
Rs.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "expect.fail()", new Ye(e, {
    actual: n,
    expected: t,
    operator: i
  }, Rs.fail);
};
var $0 = {};
Tf($0, {
  Should: () => by,
  should: () => yy
});
function pd() {
  function n() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new lt(this.valueOf(), null, n) : new lt(this, null, n);
  }
  Et(n, "shouldGetter");
  function t(i) {
    Object.defineProperty(this, "should", {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  Et(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: n,
    configurable: !0
  });
  var e = {};
  return e.fail = function(i, r, s, o) {
    throw arguments.length < 2 && (s = i, i = void 0), s = s || "should.fail()", new Ye(s, {
      actual: i,
      expected: r,
      operator: o
    }, e.fail);
  }, e.equal = function(i, r, s) {
    new lt(i, s).to.equal(r);
  }, e.Throw = function(i, r, s, o) {
    new lt(i, o).to.Throw(r, s);
  }, e.exist = function(i, r) {
    new lt(i, r).to.exist;
  }, e.not = {}, e.not.equal = function(i, r, s) {
    new lt(i, s).to.not.equal(r);
  }, e.not.Throw = function(i, r, s, o) {
    new lt(i, o).to.not.Throw(r, s);
  }, e.not.exist = function(i, r) {
    new lt(i, r).to.not.exist;
  }, e.throw = e.Throw, e.not.throw = e.not.Throw, e;
}
Et(pd, "loadShould");
var yy = pd, by = pd;
function ot(n, t) {
  var e = new lt(null, null, ot, !0);
  e.assert(
    n,
    t,
    "[ negation message unavailable ]"
  );
}
Et(ot, "assert");
ot.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "assert.fail()", new Ye(e, {
    actual: n,
    expected: t,
    operator: i
  }, ot.fail);
};
ot.isOk = function(n, t) {
  new lt(n, t, ot.isOk, !0).is.ok;
};
ot.isNotOk = function(n, t) {
  new lt(n, t, ot.isNotOk, !0).is.not.ok;
};
ot.equal = function(n, t, e) {
  var i = new lt(n, e, ot.equal, !0);
  i.assert(
    t == De(i, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    n,
    !0
  );
};
ot.notEqual = function(n, t, e) {
  var i = new lt(n, e, ot.notEqual, !0);
  i.assert(
    t != De(i, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    n,
    !0
  );
};
ot.strictEqual = function(n, t, e) {
  new lt(n, e, ot.strictEqual, !0).to.equal(t);
};
ot.notStrictEqual = function(n, t, e) {
  new lt(n, e, ot.notStrictEqual, !0).to.not.equal(t);
};
ot.deepEqual = ot.deepStrictEqual = function(n, t, e) {
  new lt(n, e, ot.deepEqual, !0).to.eql(t);
};
ot.notDeepEqual = function(n, t, e) {
  new lt(n, e, ot.notDeepEqual, !0).to.not.eql(t);
};
ot.isAbove = function(n, t, e) {
  new lt(n, e, ot.isAbove, !0).to.be.above(t);
};
ot.isAtLeast = function(n, t, e) {
  new lt(n, e, ot.isAtLeast, !0).to.be.least(t);
};
ot.isBelow = function(n, t, e) {
  new lt(n, e, ot.isBelow, !0).to.be.below(t);
};
ot.isAtMost = function(n, t, e) {
  new lt(n, e, ot.isAtMost, !0).to.be.most(t);
};
ot.isTrue = function(n, t) {
  new lt(n, t, ot.isTrue, !0).is.true;
};
ot.isNotTrue = function(n, t) {
  new lt(n, t, ot.isNotTrue, !0).to.not.equal(!0);
};
ot.isFalse = function(n, t) {
  new lt(n, t, ot.isFalse, !0).is.false;
};
ot.isNotFalse = function(n, t) {
  new lt(n, t, ot.isNotFalse, !0).to.not.equal(!1);
};
ot.isNull = function(n, t) {
  new lt(n, t, ot.isNull, !0).to.equal(null);
};
ot.isNotNull = function(n, t) {
  new lt(n, t, ot.isNotNull, !0).to.not.equal(null);
};
ot.isNaN = function(n, t) {
  new lt(n, t, ot.isNaN, !0).to.be.NaN;
};
ot.isNotNaN = function(n, t) {
  new lt(n, t, ot.isNotNaN, !0).not.to.be.NaN;
};
ot.exists = function(n, t) {
  new lt(n, t, ot.exists, !0).to.exist;
};
ot.notExists = function(n, t) {
  new lt(n, t, ot.notExists, !0).to.not.exist;
};
ot.isUndefined = function(n, t) {
  new lt(n, t, ot.isUndefined, !0).to.equal(void 0);
};
ot.isDefined = function(n, t) {
  new lt(n, t, ot.isDefined, !0).to.not.equal(void 0);
};
ot.isCallable = function(n, t) {
  new lt(n, t, ot.isCallable, !0).is.callable;
};
ot.isNotCallable = function(n, t) {
  new lt(n, t, ot.isNotCallable, !0).is.not.callable;
};
ot.isObject = function(n, t) {
  new lt(n, t, ot.isObject, !0).to.be.a("object");
};
ot.isNotObject = function(n, t) {
  new lt(n, t, ot.isNotObject, !0).to.not.be.a("object");
};
ot.isArray = function(n, t) {
  new lt(n, t, ot.isArray, !0).to.be.an("array");
};
ot.isNotArray = function(n, t) {
  new lt(n, t, ot.isNotArray, !0).to.not.be.an("array");
};
ot.isString = function(n, t) {
  new lt(n, t, ot.isString, !0).to.be.a("string");
};
ot.isNotString = function(n, t) {
  new lt(n, t, ot.isNotString, !0).to.not.be.a("string");
};
ot.isNumber = function(n, t) {
  new lt(n, t, ot.isNumber, !0).to.be.a("number");
};
ot.isNotNumber = function(n, t) {
  new lt(n, t, ot.isNotNumber, !0).to.not.be.a("number");
};
ot.isNumeric = function(n, t) {
  new lt(n, t, ot.isNumeric, !0).is.numeric;
};
ot.isNotNumeric = function(n, t) {
  new lt(n, t, ot.isNotNumeric, !0).is.not.numeric;
};
ot.isFinite = function(n, t) {
  new lt(n, t, ot.isFinite, !0).to.be.finite;
};
ot.isBoolean = function(n, t) {
  new lt(n, t, ot.isBoolean, !0).to.be.a("boolean");
};
ot.isNotBoolean = function(n, t) {
  new lt(n, t, ot.isNotBoolean, !0).to.not.be.a("boolean");
};
ot.typeOf = function(n, t, e) {
  new lt(n, e, ot.typeOf, !0).to.be.a(t);
};
ot.notTypeOf = function(n, t, e) {
  new lt(n, e, ot.notTypeOf, !0).to.not.be.a(t);
};
ot.instanceOf = function(n, t, e) {
  new lt(n, e, ot.instanceOf, !0).to.be.instanceOf(t);
};
ot.notInstanceOf = function(n, t, e) {
  new lt(n, e, ot.notInstanceOf, !0).to.not.be.instanceOf(t);
};
ot.include = function(n, t, e) {
  new lt(n, e, ot.include, !0).include(t);
};
ot.notInclude = function(n, t, e) {
  new lt(n, e, ot.notInclude, !0).not.include(t);
};
ot.deepInclude = function(n, t, e) {
  new lt(n, e, ot.deepInclude, !0).deep.include(t);
};
ot.notDeepInclude = function(n, t, e) {
  new lt(n, e, ot.notDeepInclude, !0).not.deep.include(t);
};
ot.nestedInclude = function(n, t, e) {
  new lt(n, e, ot.nestedInclude, !0).nested.include(t);
};
ot.notNestedInclude = function(n, t, e) {
  new lt(n, e, ot.notNestedInclude, !0).not.nested.include(t);
};
ot.deepNestedInclude = function(n, t, e) {
  new lt(n, e, ot.deepNestedInclude, !0).deep.nested.include(t);
};
ot.notDeepNestedInclude = function(n, t, e) {
  new lt(n, e, ot.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
ot.ownInclude = function(n, t, e) {
  new lt(n, e, ot.ownInclude, !0).own.include(t);
};
ot.notOwnInclude = function(n, t, e) {
  new lt(n, e, ot.notOwnInclude, !0).not.own.include(t);
};
ot.deepOwnInclude = function(n, t, e) {
  new lt(n, e, ot.deepOwnInclude, !0).deep.own.include(t);
};
ot.notDeepOwnInclude = function(n, t, e) {
  new lt(n, e, ot.notDeepOwnInclude, !0).not.deep.own.include(t);
};
ot.match = function(n, t, e) {
  new lt(n, e, ot.match, !0).to.match(t);
};
ot.notMatch = function(n, t, e) {
  new lt(n, e, ot.notMatch, !0).to.not.match(t);
};
ot.property = function(n, t, e) {
  new lt(n, e, ot.property, !0).to.have.property(t);
};
ot.notProperty = function(n, t, e) {
  new lt(n, e, ot.notProperty, !0).to.not.have.property(t);
};
ot.propertyVal = function(n, t, e, i) {
  new lt(n, i, ot.propertyVal, !0).to.have.property(t, e);
};
ot.notPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.notPropertyVal, !0).to.not.have.property(t, e);
};
ot.deepPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.deepPropertyVal, !0).to.have.deep.property(t, e);
};
ot.notDeepPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.notDeepPropertyVal, !0).to.not.have.deep.property(t, e);
};
ot.ownProperty = function(n, t, e) {
  new lt(n, e, ot.ownProperty, !0).to.have.own.property(t);
};
ot.notOwnProperty = function(n, t, e) {
  new lt(n, e, ot.notOwnProperty, !0).to.not.have.own.property(t);
};
ot.ownPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.ownPropertyVal, !0).to.have.own.property(t, e);
};
ot.notOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.notOwnPropertyVal, !0).to.not.have.own.property(t, e);
};
ot.deepOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.deepOwnPropertyVal, !0).to.have.deep.own.property(t, e);
};
ot.notDeepOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, e);
};
ot.nestedProperty = function(n, t, e) {
  new lt(n, e, ot.nestedProperty, !0).to.have.nested.property(t);
};
ot.notNestedProperty = function(n, t, e) {
  new lt(n, e, ot.notNestedProperty, !0).to.not.have.nested.property(t);
};
ot.nestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.nestedPropertyVal, !0).to.have.nested.property(t, e);
};
ot.notNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.notNestedPropertyVal, !0).to.not.have.nested.property(t, e);
};
ot.deepNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, e);
};
ot.notDeepNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, ot.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, e);
};
ot.lengthOf = function(n, t, e) {
  new lt(n, e, ot.lengthOf, !0).to.have.lengthOf(t);
};
ot.hasAnyKeys = function(n, t, e) {
  new lt(n, e, ot.hasAnyKeys, !0).to.have.any.keys(t);
};
ot.hasAllKeys = function(n, t, e) {
  new lt(n, e, ot.hasAllKeys, !0).to.have.all.keys(t);
};
ot.containsAllKeys = function(n, t, e) {
  new lt(n, e, ot.containsAllKeys, !0).to.contain.all.keys(t);
};
ot.doesNotHaveAnyKeys = function(n, t, e) {
  new lt(n, e, ot.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
ot.doesNotHaveAllKeys = function(n, t, e) {
  new lt(n, e, ot.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
ot.hasAnyDeepKeys = function(n, t, e) {
  new lt(n, e, ot.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
ot.hasAllDeepKeys = function(n, t, e) {
  new lt(n, e, ot.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
ot.containsAllDeepKeys = function(n, t, e) {
  new lt(n, e, ot.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
ot.doesNotHaveAnyDeepKeys = function(n, t, e) {
  new lt(n, e, ot.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
ot.doesNotHaveAllDeepKeys = function(n, t, e) {
  new lt(n, e, ot.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
ot.throws = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null);
  var r = new lt(n, i, ot.throws, !0).to.throw(t, e);
  return De(r, "object");
};
ot.doesNotThrow = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null), new lt(n, i, ot.doesNotThrow, !0).to.not.throw(t, e);
};
ot.operator = function(n, t, e, i) {
  var r;
  switch (t) {
    case "==":
      r = n == e;
      break;
    case "===":
      r = n === e;
      break;
    case ">":
      r = n > e;
      break;
    case ">=":
      r = n >= e;
      break;
    case "<":
      r = n < e;
      break;
    case "<=":
      r = n <= e;
      break;
    case "!=":
      r = n != e;
      break;
    case "!==":
      r = n !== e;
      break;
    default:
      throw i = i && i + ": ", new Ye(
        i + 'Invalid operator "' + t + '"',
        void 0,
        ot.operator
      );
  }
  var s = new lt(r, i, ot.operator, !0);
  s.assert(
    De(s, "object") === !0,
    "expected " + We(n) + " to be " + t + " " + We(e),
    "expected " + We(n) + " to not be " + t + " " + We(e)
  );
};
ot.closeTo = function(n, t, e, i) {
  new lt(n, i, ot.closeTo, !0).to.be.closeTo(t, e);
};
ot.approximately = function(n, t, e, i) {
  new lt(n, i, ot.approximately, !0).to.be.approximately(t, e);
};
ot.sameMembers = function(n, t, e) {
  new lt(n, e, ot.sameMembers, !0).to.have.same.members(t);
};
ot.notSameMembers = function(n, t, e) {
  new lt(n, e, ot.notSameMembers, !0).to.not.have.same.members(t);
};
ot.sameDeepMembers = function(n, t, e) {
  new lt(n, e, ot.sameDeepMembers, !0).to.have.same.deep.members(t);
};
ot.notSameDeepMembers = function(n, t, e) {
  new lt(n, e, ot.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
ot.sameOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
ot.notSameOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
ot.sameDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
ot.notSameDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
ot.includeMembers = function(n, t, e) {
  new lt(n, e, ot.includeMembers, !0).to.include.members(t);
};
ot.notIncludeMembers = function(n, t, e) {
  new lt(n, e, ot.notIncludeMembers, !0).to.not.include.members(t);
};
ot.includeDeepMembers = function(n, t, e) {
  new lt(n, e, ot.includeDeepMembers, !0).to.include.deep.members(t);
};
ot.notIncludeDeepMembers = function(n, t, e) {
  new lt(n, e, ot.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
ot.includeOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.includeOrderedMembers, !0).to.include.ordered.members(t);
};
ot.notIncludeOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
ot.includeDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
ot.notIncludeDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, ot.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
ot.oneOf = function(n, t, e) {
  new lt(n, e, ot.oneOf, !0).to.be.oneOf(t);
};
ot.isIterable = function(n, t) {
  if (n == null || !n[Symbol.iterator])
    throw t = t ? `${t} expected ${We(n)} to be an iterable` : `expected ${We(n)} to be an iterable`, new Ye(
      t,
      void 0,
      ot.isIterable
    );
};
ot.changes = function(n, t, e, i) {
  arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, ot.changes, !0).to.change(t, e);
};
ot.changesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, ot.changesBy, !0).to.change(t, e).by(i);
};
ot.doesNotChange = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, ot.doesNotChange, !0).to.not.change(t, e);
};
ot.changesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, ot.changesButNotBy, !0).to.change(t, e).but.not.by(i);
};
ot.increases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, ot.increases, !0).to.increase(t, e);
};
ot.increasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, ot.increasesBy, !0).to.increase(t, e).by(i);
};
ot.doesNotIncrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, ot.doesNotIncrease, !0).to.not.increase(t, e);
};
ot.increasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, ot.increasesButNotBy, !0).to.increase(t, e).but.not.by(i);
};
ot.decreases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, ot.decreases, !0).to.decrease(t, e);
};
ot.decreasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, ot.decreasesBy, !0).to.decrease(t, e).by(i);
};
ot.doesNotDecrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, ot.doesNotDecrease, !0).to.not.decrease(t, e);
};
ot.doesNotDecreaseBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  return new lt(n, r, ot.doesNotDecreaseBy, !0).to.not.decrease(t, e).by(i);
};
ot.decreasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, ot.decreasesButNotBy, !0).to.decrease(t, e).but.not.by(i);
};
ot.ifError = function(n) {
  if (n)
    throw n;
};
ot.isExtensible = function(n, t) {
  new lt(n, t, ot.isExtensible, !0).to.be.extensible;
};
ot.isNotExtensible = function(n, t) {
  new lt(n, t, ot.isNotExtensible, !0).to.not.be.extensible;
};
ot.isSealed = function(n, t) {
  new lt(n, t, ot.isSealed, !0).to.be.sealed;
};
ot.isNotSealed = function(n, t) {
  new lt(n, t, ot.isNotSealed, !0).to.not.be.sealed;
};
ot.isFrozen = function(n, t) {
  new lt(n, t, ot.isFrozen, !0).to.be.frozen;
};
ot.isNotFrozen = function(n, t) {
  new lt(n, t, ot.isNotFrozen, !0).to.not.be.frozen;
};
ot.isEmpty = function(n, t) {
  new lt(n, t, ot.isEmpty, !0).to.be.empty;
};
ot.isNotEmpty = function(n, t) {
  new lt(n, t, ot.isNotEmpty, !0).to.not.be.empty;
};
(/* @__PURE__ */ Et(function n(t, e) {
  return ot[e] = ot[t], n;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var Pp = [];
function vy(n) {
  const t = {
    AssertionError: Ye,
    util: Zu,
    config: pi,
    expect: Rs,
    assert: ot,
    Assertion: lt,
    ...$0
  };
  return ~Pp.indexOf(n) || (n(t, Zu), Pp.push(n)), t;
}
Et(vy, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var co = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oc(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function wy(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(e, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), e;
}
var tf = { exports: {} }, bh, Lp;
function xy() {
  if (Lp) return bh;
  Lp = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  bh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var m = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (m ? "s" : "");
  }
  return bh;
}
function _y(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = s, e.enable = r, e.enabled = o, e.humanize = xy(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, m;
    function b(...x) {
      if (!b.enabled)
        return;
      const y = b, v = Number(/* @__PURE__ */ new Date()), k = v - (d || v);
      y.diff = k, y.prev = d, y.curr = v, d = v, x[0] = e.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let C = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (q, O) => {
        if (q === "%%")
          return "%";
        C++;
        const F = e.formatters[O];
        if (typeof F == "function") {
          const M = x[C];
          q = F.call(y, M), x.splice(C, 1), C--;
        }
        return q;
      }), e.formatArgs.call(y, x), (y.log || e.log).apply(y, x);
    }
    return b.namespace = u, b.useColors = e.useColors(), b.color = e.selectColor(u), b.extend = i, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, m = e.enabled(u)), m),
      set: (x) => {
        p = x;
      }
    }), typeof e.init == "function" && e.init(b), b;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? e.skips.push(new RegExp("^" + u.slice(1) + "$")) : e.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [
      ...e.names.map(a),
      ...e.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = e.skips.length; d < p; d++)
      if (e.skips[d].test(u))
        return !1;
    for (d = 0, p = e.names.length; d < p; d++)
      if (e.names[d].test(u))
        return !0;
    return !1;
  }
  function a(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var Sy = _y;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = Sy(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(tf, tf.exports);
var ky = tf.exports;
const U0 = /* @__PURE__ */ Oc(ky), Ay = {
  cacheResults: !0,
  successMetric: "efficiency",
  calculateCuts: !0,
  stack: !0,
  findDuplicatePatterns: !0,
  //dev specific
  captureProfile: !1,
  runTests: !1,
  throwErrorsOnFailedTests: !1,
  // recordPlacementPositions: isDevOrTest ? true : false,
  sample: {
    enable: !0,
    groupSize: 6,
    efficiency: 4,
    guillotine: 2
  },
  priority: {
    enable: !0,
    variationThreshold: 0.3
  },
  secondRun: {
    enabled: !1,
    efficiencyCutoff: 0.5,
    stack: !1
  },
  efficiency: {
    tidy: !1,
    //[] issue with picking winner when tidy is enabled
    rayCasting: !0
  },
  groups: {
    shapeAreaCutOff: 0.7,
    tolerance: 0.04,
    guillotine: {
      strips: !0,
      segments: !0,
      runWithout: !1
    },
    efficiency: {
      firstShapes: !0,
      position: !0,
      limit: 100
    }
  },
  guillotine: {
    viableShapeArea: 0.5,
    secondPass: !0,
    strips: {
      rearrange: !0,
      efficiencyThreshold: 0.7
    },
    stripShapes: {
      allocation: !0,
      iterations: 6,
      numPriorityShapes: 1
    }
  },
  subset: {
    shuffles: 80,
    //this is the default - can be overwritten (for example when creating groups)
    guillotine: {
      shuffles: 80
    },
    efficiency: {
      limit: 0.5
    }
  },
  evo: {
    disable: !1,
    stockLimit: 40
  }
};
pi.showDiff = !0;
const Ip = U0("tests");
U0("timers");
function W0() {
  return typeof process < "u" && (process != null && process.env), !1;
}
function H0(n, t = null) {
  if (n != null && n.length && W0() && Ay.runTests)
    for (const e of n)
      try {
        e();
      } catch (i) {
        t ? Ip(t, i.message) : Ip(i.message);
      }
}
var ef = { exports: {} }, vh, Ep;
function Ny() {
  if (Ep) return vh;
  Ep = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  vh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var m = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (m ? "s" : "");
  }
  return vh;
}
function Cy(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = s, e.enable = r, e.enabled = o, e.humanize = Ny(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, m;
    function b(...x) {
      if (!b.enabled)
        return;
      const y = b, v = Number(/* @__PURE__ */ new Date()), k = v - (d || v);
      y.diff = k, y.prev = d, y.curr = v, d = v, x[0] = e.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let C = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (q, O) => {
        if (q === "%%")
          return "%";
        C++;
        const F = e.formatters[O];
        if (typeof F == "function") {
          const M = x[C];
          q = F.call(y, M), x.splice(C, 1), C--;
        }
        return q;
      }), e.formatArgs.call(y, x), (y.log || e.log).apply(y, x);
    }
    return b.namespace = u, b.useColors = e.useColors(), b.color = e.selectColor(u), b.extend = i, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, m = e.enabled(u)), m),
      set: (x) => {
        p = x;
      }
    }), typeof e.init == "function" && e.init(b), b;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? e.skips.push(new RegExp("^" + u.slice(1) + "$")) : e.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [
      ...e.names.map(a),
      ...e.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = e.skips.length; d < p; d++)
      if (e.skips[d].test(u))
        return !1;
    for (d = 0, p = e.names.length; d < p; d++)
      if (e.names[d].test(u))
        return !0;
    return !1;
  }
  function a(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var Py = Cy;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = Py(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(ef, ef.exports);
var Ly = ef.exports;
const Zi = /* @__PURE__ */ Oc(Ly);
Zi.colors = [
  2,
  3,
  4,
  5,
  7,
  9,
  10,
  11,
  14,
  159
];
Zi("logs");
Zi("cuts");
Zi("guillotine");
Zi("results");
Zi("scoring");
Zi("calculations");
Zi("subset");
Zi("secondRun");
Zi("stack");
const Iy = Zi("errors");
Zi("allStock");
Iy.color = 1;
function Ey(n) {
  if (n != null && n.dimension)
    switch (n.dimension) {
      case "l":
        return n.x2 - n.x1;
      case "w":
        return n.y2 - n.y1;
    }
  switch (n.type) {
    case "top":
    case "bottom":
      return n.x2 - n.x1;
    case "left":
    case "right":
      return n.y2 - n.y1;
  }
  return 0;
}
class Tc extends pa {
  //used to mark for removal
  constructor(e) {
    var i, r, s, o;
    e.x2 < e.x1 && ([e.x1, e.x2] = [e.x2, e.x1]), e.y2 < e.y1 && ([e.y1, e.y2] = [e.y2, e.y1]);
    super(e);
    tt(this, "stock");
    tt(this, "stockId");
    tt(this, "guillotine");
    tt(this, "guillotineData");
    tt(this, "isTrim");
    tt(this, "distances");
    tt(this, "beamTrimX1");
    tt(this, "beamTrimY1");
    tt(this, "type", null);
    tt(this, "remove");
    Dt(e == null ? void 0 : e.stock) && (((r = (i = e.stock) == null ? void 0 : i.constructor) == null ? void 0 : r.name) === "Stock" ? this.stock = e.stock : this.stock = new es(e.stock), this.stockId = this.stock.id), this.stockId = (s = e == null ? void 0 : e.stock) == null ? void 0 : s.id, this.type = e.type ?? null, this.guillotine = e.guillotine, this.guillotineData = Dt(e.guillotineData) ? e.guillotineData : {}, this.guillotineData.ptxDummyCut = (e == null ? void 0 : e.ptxDummyCut) || ((o = e == null ? void 0 : e.guillotineData) == null ? void 0 : o.ptxDummyCut) || !1, this.isTrim = Dt(e.isTrim) ? e.isTrim : !1, this.distances = Dt(e.distances) ? e.distances : {}, this.beamTrimX1 = e.beamTrimX1, this.beamTrimY1 = e.beamTrimY1;
  }
  //compress for saving / transfer
  compress() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.shapeCollisions, delete this.stock;
  }
  clone() {
    const e = structuredClone(this);
    return new Tc(e);
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
  trim() {
    this.dimension === "l" ? (this.x1 = this.x1 < 0 ? 0 : this.x1, this.x2 = this.x2 > this.stock.l ? this.stock.l : this.x2) : this.dimension === "w" && (this.y1 = this.y1 < 0 ? 0 : this.y1, this.y2 = this.y2 > this.stock.w ? this.stock.w : this.y2);
  }
  lookupDirectionByType(e) {
    const r = {
      top: "l",
      bottom: "l",
      left: "w",
      right: "w"
    }[e];
    if (r) return r;
    throw new Error("no direction found in lookupDirectionByType");
  }
  isInsideStock() {
    switch (this.type) {
      case "bottom":
        return He.greaterThan(
          this.y1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "left":
        return He.greaterThan(
          this.x1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "top":
        return He.lessThan(
          this.y1 - this.stock.getBladeWidth() / 2,
          this.stock.w
        );
      case "right":
        return He.lessThan(
          this.x1 - this.stock.getBladeWidth() / 2,
          this.stock.l
        );
      default:
        return !0;
    }
  }
  /**
      * the cuts are visualised differently from their exact dimensions
      * @param {string} coord
      */
  getVisCoords(e) {
    return this[e];
  }
  getLength() {
    return Ey(this);
  }
  getArea() {
    if (!this.stock) return 0;
    const e = this.getLength();
    return e ? e * this.stock.getBladeWidth() : 0;
  }
}
const Oy = {
  tb: {
    bottomLeft: {
      top: "topRight",
      topLeft: "topLeft"
    },
    bottomRight: {
      top: "topLeft",
      topRight: "topRight"
    }
  },
  bt: {
    topLeft: {
      bottom: "bottomRight",
      bottomLeft: "bottomLeft"
    },
    topRight: {
      bottom: "bottomLeft",
      bottomRight: "bottomRight"
    }
  },
  lr: {
    topRight: {
      left: "bottomLeft",
      topLeft: "topLeft"
    },
    bottomRight: {
      left: "topLeft",
      bottomLeft: "bottomLeft"
    }
  },
  rl: {
    topLeft: {
      right: "bottomRight",
      topRight: "topRight"
    },
    bottomLeft: {
      right: "topRight",
      bottomRight: "bottomRight"
    }
  }
}, Su = {
  topLeft: {
    top: ["topRight"],
    default: ["topRight"]
  },
  bottomRight: {
    right: ["topRight"],
    default: ["topRight"]
  }
}, ku = {
  topRight: {
    top: ["topLeft"],
    right: ["bottomRight"],
    default: ["topLeft", "bottomRight"]
  },
  topLeft: {
    top: ["topRight"],
    left: ["bottomLeft"],
    default: ["topRight", "bottomLeft"]
  },
  bottomRight: {
    bottom: ["bottomLeft"],
    right: ["topRight"],
    default: ["bottomLeft", "topRight"]
  },
  bottomLeft: {
    bottom: ["bottomRight"],
    left: ["topLeft"],
    default: ["bottomRight", "topLeft"]
  }
};
class Hn {
  constructor(t, e, i = null) {
    tt(this, "x");
    tt(this, "y");
    tt(this, "z");
    tt(this, "a");
    //shape id
    tt(this, "b");
    //shape id
    tt(this, "direction");
    //direction of the raay
    tt(this, "type");
    //[] need to type
    tt(this, "corner");
    //originating corner of this point
    tt(this, "grid");
    //if a grid point, which grid position
    tt(this, "stockID");
    tt(this, "raycast");
    tt(this, "collision");
    tt(this, "tooClose");
    tt(this, "adjustedForMinSpacing");
    this.x = parseFloat(t), this.y = parseFloat(e), this.z = parseFloat(i) || 0, this.validate();
  }
  /**
   * clone with the ability to change the coordinates
   * NOTE: looks odd for performance reasons
   */
  clone(t = null, e = null) {
    const i = new Hn(t ?? this.x, e ?? this.y);
    for (const r in this)
      r !== "x" && r !== "y" && (i[r] = this[r]);
    return i;
  }
  validate() {
    if (isNaN(this.x) || isNaN(this.y))
      throw new Error("invalid point coordinates");
  }
  coords() {
    return {
      x: this.x,
      y: this.y
    };
  }
  collidesWith(t) {
    return this.x >= t.x && this.x <= t.x + t.l && this.y >= t.y && this.y <= t.y + t.w;
  }
  isIdenticalTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * given a point from a shape corner or a ray, get the available positions for this shape
   * @returns the position of the shape relative to the point e.g. bottomRight means the shape is placed to the bottom right of the point
   * @remarks does not cater for diagonals
   */
  //[x] needs to cater for raycast coords, which don't originate from a shape corner
  //[x] cater for raycast corners and grid
  getAvailableShapePositions(t) {
    const e = /* @__PURE__ */ new Set();
    if (this.raycast) {
      const i = Oy[this.direction];
      return i && i[this.corner] && i[this.corner][this.grid] && e.add(i[this.corner][this.grid]), e;
    }
    return (t == null ? void 0 : t.cutType) !== "efficiency" ? (Su[this.corner] && (this.grid ? Su[this.corner][this.grid] && Su[this.corner][this.grid].forEach((i) => e.add(i)) : Su[this.corner].default.forEach((i) => e.add(i))), e) : (ku[this.corner] && (this.grid ? ku[this.corner][this.grid] && ku[this.corner][this.grid].forEach((i) => e.add(i)) : ku[this.corner].default.forEach((i) => e.add(i))), e);
  }
}
class Io {
  constructor(t = []) {
    tt(this, "points", /* @__PURE__ */ new Map());
    t.forEach((e) => this.addPoint(e));
  }
  addPoint(t, e = null) {
    if (this.contains(t)) {
      const i = this.getPoint(t);
      i.type === "group" && !e && (i.type = void 0);
      return;
    }
    t.validate(), e && (t.type = e), this.points.set(this.createKey(t), t);
  }
  addPoints(t, e = null) {
    for (const i of t) {
      if (!i) return;
      i.validate(), this.addPoint(i, e);
    }
  }
  createKey(t) {
    return `${t.x},${t.y}`;
  }
  getPoint(t) {
    return this.points.get(this.createKey(t));
  }
  deletePoint(t) {
    t.validate(), this.points.delete(this.createKey(t));
  }
  deletePoints(t) {
    for (const e of t)
      e.validate(), this.deletePoint(e);
  }
  clear() {
    this.points.clear();
  }
  toArray() {
    return Array.from(this.points.values());
  }
  contains(t) {
    return this.points.has(this.createKey(t));
  }
}
function Qe(n, t, e, i, r) {
  const s = Ty[n](t, e);
  return i && (s.corner = i), r && (s.direction = r), s;
}
const Ty = {
  bottom: (n, t) => {
    const e = n.clone(n.x, n.y - t);
    return e.grid = "bottom", e;
  },
  bottomLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y - t);
    return e.grid = "bottomLeft", e;
  },
  bottomRight: (n, t) => {
    const e = n.clone(n.x + t, n.y - t);
    return e.grid = "bottomRight", e;
  },
  left: (n, t) => {
    const e = n.clone(n.x - t, n.y);
    return e.grid = "left", e;
  },
  centre: (n) => {
    const t = n.clone(n.x, n.y);
    return t.grid = "centre", t;
  },
  right: (n, t) => {
    const e = n.clone(n.x + t, n.y);
    return e.grid = "right", e;
  },
  top: (n, t) => {
    const e = n.clone(n.x, n.y + t);
    return e.grid = "top", e;
  },
  topLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y + t);
    return e.grid = "topLeft", e;
  },
  topRight: (n, t) => {
    const e = n.clone(n.x + t, n.y + t);
    return e.grid = "topRight", e;
  }
};
function Fy(n, t, e) {
  var o, a, l, h, u, d;
  const i = new Io(), r = e.toArray().sort(G0), s = t.getBladeWidth();
  if (r.forEach((p) => {
    const f = p.corner, m = p.type;
    if (!s)
      i.addPoint(p);
    else
      switch (f) {
        case "topRight":
          i.addPoint(
            Qe("top", p, s, f),
            m
          ), i.addPoint(
            Qe("right", p, s, f),
            m
          );
          break;
        case "topLeft":
          i.addPoint(
            Qe("top", p, s, f),
            m
          ), i.addPoint(
            Qe("left", p, s, f),
            m
          );
          break;
        case "bottomRight":
          i.addPoint(
            Qe("bottom", p, s, f),
            m
          ), i.addPoint(
            Qe("right", p, s, f),
            m
          );
          break;
        case "bottomLeft":
          i.addPoint(
            Qe("bottom", p, s, f),
            m
          ), i.addPoint(
            Qe("left", p, s, f),
            m
          );
          break;
      }
    const b = i.toArray();
    if (s)
      for (let x = b.length; x--; ) {
        const y = b[x];
        e.contains(y) && i.deletePoint(y);
      }
    else
      for (let x = b.length; x--; ) {
        const y = b[x];
        for (let v = n.length; v--; ) {
          const k = n[v];
          if (y.x === k.x && y.y === k.y) {
            i.deletePoint(y);
            break;
          }
        }
      }
  }), s) {
    const p = /* @__PURE__ */ new Set();
    let f, m, b, x;
    ((o = t == null ? void 0 : t.constructor) == null ? void 0 : o.name) === "Stock" && (t != null && t.trimmed) || ((a = t == null ? void 0 : t.constructor) == null ? void 0 : a.name) === "Segment" ? (f = t.x, m = t.y, b = t.x + t.l, x = t.y + t.w) : (f = t.x + ((l = t == null ? void 0 : t.trim) == null ? void 0 : l.x1), m = t.y + ((h = t == null ? void 0 : t.trim) == null ? void 0 : h.y1), b = t.x + t.l - ((u = t == null ? void 0 : t.trim) == null ? void 0 : u.x2), x = t.y + t.w - ((d = t == null ? void 0 : t.trim) == null ? void 0 : d.y2));
    let y = i.toArray();
    for (let v = y.length; v--; ) {
      const k = y[v];
      (He.lessThan(k.x, f) || He.lessThan(k.y, m) || He.greaterThan(k.x, b) || He.greaterThan(k.y, x)) && y.splice(v, 1);
    }
    i.clear(), i.addPoints(y), p.clear(), y = i.toArray();
    for (let v = y.length; v--; ) {
      const k = y[v];
      for (let C = n.length; C--; ) {
        const I = n[C];
        if (k.collidesWith(I)) {
          i.deletePoint(k);
          break;
        }
      }
    }
  }
  return i;
}
function My(n, t, e) {
  let i = [];
  const r = n.getMinSpacing(e), s = t.corner, o = t.direction;
  if (t.type === "shape")
    switch (s) {
      case "topLeft":
        o === "rl" && (i.push(Qe("right", t, r, s, o)), i.push(Qe("topRight", t, r, s, o))), o === "bt" && (i.push(Qe("bottom", t, r, s, o)), i.push(Qe("bottomLeft", t, r, s, o)));
        break;
      case "topRight":
        o === "lr" && (i.push(Qe("left", t, r, s, o)), i.push(Qe("topLeft", t, r, s, o))), o === "bt" && (i.push(Qe("bottom", t, r, s, o)), i.push(Qe("bottomRight", t, r, s, o)));
        break;
      case "bottomRight":
        o === "lr" && (i.push(Qe("left", t, r, s, o)), i.push(Qe("bottomLeft", t, r, s, o))), o === "tb" && (i.push(Qe("top", t, r, s, o)), i.push(Qe("topRight", t, r, s, o)));
        break;
      case "bottomLeft":
        o === "rl" && (i.push(Qe("right", t, r, s, o)), i.push(Qe("bottomRight", t, r, s, o))), o === "tb" && (i.push(Qe("top", t, r, s, o)), i.push(Qe("topLeft", t, r, s, o)));
        break;
    }
  else if (t.type === "edge")
    switch (o) {
      case "rl":
      case "lr":
        i.push(Qe("top", t, 0)), i.push(Qe("centre", t, 0)), i.push(Qe("bottom", t, 0));
        break;
      case "tb":
      case "bt":
        i.push(Qe("left", t, 0)), i.push(Qe("right", t, 0)), i.push(Qe("centre", t, 0));
        break;
    }
  if (i = i.filter((l) => l.x >= 0 && l.y >= 0), !i.length) return null;
  const a = new Io();
  for (const l of i)
    l.raycast = !0, a.addPoints(K0(n, l, e).toArray());
  return X0(n, e, a), a;
}
function Ry(n, t) {
  const e = new Io();
  return n.sort(G0), n.forEach((i) => {
    Pr(i) ? (e.addPoints(i.getCoords(t)), i.shapes.forEach((r) => {
      const s = r.getCoords(t);
      e.addPoints(s, "group");
    })) : e.addPoints(i.getCoords(t));
  }), e.points.forEach((i) => {
    i.stockID = t.getStock().id;
  }), e;
}
function Dy(n = [], t, e) {
  const i = Ry(
    n === null ? t : n,
    e
  );
  return Fy(
    t,
    e,
    i
  );
}
function G0(n, t) {
  return n.y === t.y ? t.x - n.x : t.y - n.y;
}
function V0(n, t, e, i, r, s) {
  n.a = t.id, n.b = e ? e.id : null, n.direction = i, n.raycast = !0, n.type = r, n.corner = s;
}
function By(n, t) {
  if (n.saw.cutType !== "efficiency" || t.length <= 1) return null;
  let e = new Io();
  const i = Y0(t, n);
  for (const a of t)
    for (const l of i) {
      if (l.shape.id === a.id) continue;
      const h = Object.values(l.rays);
      for (const u of h)
        jy(
          u,
          l.shape,
          a,
          e
        );
    }
  const s = n.saw.efficiencyOptions.primaryCompression === "x" ? "lr" : "tb", o = t.reduce((a, l) => (s === "tb" ? a.x + a.l > l.x + l.l : a.y + a.w > l.y + l.w) ? a : l);
  return i.filter(({ shape: a }) => a.id === o.id).forEach(({ shape: a, rays: l }) => {
    const h = Object.values(l);
    for (const u of h) {
      const d = new Hn(u.x2, u.y2);
      s === u.direction && (V0(d, a, null, u.direction, "edge"), e.addPoint(d));
    }
  }), e = qy(e), e;
}
function Y0(n, t) {
  return n.map((e) => {
    const i = X2(e, t);
    return {
      shape: e,
      rays: i
    };
  });
}
function jy(n, t, e, i) {
  switch (n.direction) {
    case "rl":
      Au(
        n,
        t,
        e,
        i,
        e.x + e.l
      );
      break;
    case "lr":
      Au(
        n,
        t,
        e,
        i,
        e.x
      );
      break;
    case "tb":
      Au(
        n,
        t,
        e,
        i,
        e.y + e.w
      );
      break;
    case "bt":
      Au(
        n,
        t,
        e,
        i,
        e.y
      );
      break;
  }
}
function Au(n, t, e, i, r) {
  const s = n.dimension === "w", o = s ? "y" : "x", a = s ? "x" : "y", l = s ? "l" : "w";
  if (n[`${a}1`] >= e[a] && n[`${a}1`] <= e[a] + e[l]) {
    const h = n.direction === "lr" && n[`${o}1`] <= r && n[`${o}2`] >= r, u = n.direction === "rl" && n[`${o}1`] >= r && n[`${o}2`] <= r, d = n.direction === "bt" && n[`${o}1`] <= r && n[`${o}2`] >= r, p = n.direction === "tb" && n[`${o}1`] >= r && n[`${o}2`] <= r;
    if (h || u || d || p) {
      const m = s ? n[`${a}1`] : r, b = s ? r : n[`${a}1`], x = new Hn(m, b), y = n.origin;
      V0(x, t, e, n.direction, "shape", y), i.addPoint(x);
    }
  }
}
function qy(n) {
  const t = new Io();
  return n.points.size === 0 || new Set(n.toArray().map((i) => i.a)).forEach((i) => {
    const r = n.toArray().filter((s) => s.a === i);
    ["right", "left", "top", "bottom"].forEach((s) => {
      const o = zy(
        r,
        s
      );
      o && t.addPoint(o);
    });
  }), t;
}
function zy(n, t) {
  return n.length === 0 ? null : n.reduce((e, i) => {
    switch (t) {
      case "left":
        return !e || i.x < e.x ? i : e;
      case "right":
        return !e || i.x > e.x ? i : e;
      case "top":
        return !e || i.y > e.y ? i : e;
      case "bottom":
        return !e || i.y < e.y ? i : e;
      default:
        return null;
    }
  }, null);
}
function K0(n, t, e) {
  const i = new Io(), r = t.getAvailableShapePositions(e);
  for (const s of r) {
    let o;
    switch (o = $y(t, n, e), s) {
      case "bottomLeft":
        o = o.clone(o.x - n.l, o.y - n.w), o.shapePosition = "bottomLeft";
        break;
      case "bottomRight":
        o = o.clone(o.x, o.y - n.w), o.shapePosition = "bottomRight";
        break;
      case "topLeft":
        o = o.clone(o.x - n.l, o.y), o.shapePosition = "topLeft";
        break;
      case "topRight":
        o = o.clone(o.x, o.y), o.shapePosition = "topRight";
        break;
    }
    i.addPoint(o);
  }
  return X0(n, e, i), i;
}
function $y(n, t, e) {
  if (e.saw.cutType !== "efficiency") return n;
  const i = t.getMinSpacing(e), r = e.getBladeWidth();
  if (!i || i === r) return n;
  let s;
  if (!n.grid) return n;
  switch (n.grid) {
    case "bottom":
      s = n.clone(n.x, n.y - i + r);
      break;
    case "top":
      s = n.clone(n.x, n.y + i - r);
      break;
    case "left":
      s = n.clone(n.x - i + r, n.y);
      break;
    case "right":
      s = n.clone(n.x + i - r, n.y);
      break;
  }
  return s ? (s.x < 0 && (s.x = 0), s.y < 0 && (s.y = 0), s.adjustedForMinSpacing = !0, s) : n;
}
function X0(n, t, e) {
  var l, h, u, d, p, f;
  let i, r, s, o;
  ((l = t == null ? void 0 : t.constructor) == null ? void 0 : l.name) === "Stock" && (t != null && t.trimmed) || ((h = t == null ? void 0 : t.constructor) == null ? void 0 : h.name) === "Segment" ? (i = 0, r = 0, s = t.x + t.l - n.l, o = t.y + t.w - n.w) : (i = (u = t == null ? void 0 : t.trim) == null ? void 0 : u.x1, r = (d = t == null ? void 0 : t.trim) == null ? void 0 : d.y1, s = t.l - ((p = t == null ? void 0 : t.trim) == null ? void 0 : p.x2) - n.l, o = t.w - ((f = t == null ? void 0 : t.trim) == null ? void 0 : f.y2) - n.w);
  const a = e.toArray();
  for (let m = a.length; m--; ) {
    const b = a[m];
    (He.lessThan(b.x, i) || He.lessThan(b.y, r) || He.greaterThan(b.x, s) || He.greaterThan(b.y, o) || b.x < 0 || b.y < 0) && e.deletePoint(b);
  }
}
/**
* @license Fraction.js v4.3.7 31/08/2023
* https://www.xarg.org/2014/03/rational-numbers-in-javascript/
*
* Copyright (c) 2023, Robert Eisele (robert@raw.org)
* Dual licensed under the MIT or GPL Version 2 licenses.
**/
var Uy = 2e3, ye = {
  s: 1,
  n: 0,
  d: 1
};
function Jr(n, t) {
  if (isNaN(n = parseInt(n, 10)))
    throw $u();
  return n * t;
}
function wn(n, t) {
  if (t === 0)
    throw gd();
  var e = Object.create(Is.prototype);
  e.s = n < 0 ? -1 : 1, n = n < 0 ? -n : n;
  var i = ma(n, t);
  return e.n = n / i, e.d = t / i, e;
}
function Op(n) {
  for (var t = {}, e = n, i = 2, r = 4; r <= e; ) {
    for (; e % i === 0; )
      e /= i, t[i] = (t[i] || 0) + 1;
    r += 1 + 2 * i++;
  }
  return e !== n ? e > 1 && (t[e] = (t[e] || 0) + 1) : t[n] = (t[n] || 0) + 1, t;
}
var Fi = function(n, t) {
  var e = 0, i = 1, r = 1, s = 0, o = 0, a = 0, l = 1, h = 1, u = 0, d = 1, p = 1, f = 1, m = 1e7, b;
  if (n != null) if (t !== void 0) {
    if (e = n, i = t, r = e * i, e % 1 !== 0 || i % 1 !== 0)
      throw Vy();
  } else
    switch (typeof n) {
      case "object": {
        if ("d" in n && "n" in n)
          e = n.n, i = n.d, "s" in n && (e *= n.s);
        else if (0 in n)
          e = n[0], 1 in n && (i = n[1]);
        else
          throw $u();
        r = e * i;
        break;
      }
      case "number": {
        if (n < 0 && (r = n, n = -n), n % 1 === 0)
          e = n;
        else if (n > 0) {
          for (n >= 1 && (h = Math.pow(10, Math.floor(1 + Math.log(n) / Math.LN10)), n /= h); d <= m && f <= m; )
            if (b = (u + p) / (d + f), n === b) {
              d + f <= m ? (e = u + p, i = d + f) : f > d ? (e = p, i = f) : (e = u, i = d);
              break;
            } else
              n > b ? (u += p, d += f) : (p += u, f += d), d > m ? (e = p, i = f) : (e = u, i = d);
          e *= h;
        } else (isNaN(n) || isNaN(t)) && (i = e = NaN);
        break;
      }
      case "string": {
        if (d = n.match(/\d+|./g), d === null)
          throw $u();
        if (d[u] === "-" ? (r = -1, u++) : d[u] === "+" && u++, d.length === u + 1 ? o = Jr(d[u++], r) : d[u + 1] === "." || d[u] === "." ? (d[u] !== "." && (s = Jr(d[u++], r)), u++, (u + 1 === d.length || d[u + 1] === "(" && d[u + 3] === ")" || d[u + 1] === "'" && d[u + 3] === "'") && (o = Jr(d[u], r), l = Math.pow(10, d[u].length), u++), (d[u] === "(" && d[u + 2] === ")" || d[u] === "'" && d[u + 2] === "'") && (a = Jr(d[u + 1], r), h = Math.pow(10, d[u + 1].length) - 1, u += 3)) : d[u + 1] === "/" || d[u + 1] === ":" ? (o = Jr(d[u], r), l = Jr(d[u + 2], 1), u += 3) : d[u + 3] === "/" && d[u + 1] === " " && (s = Jr(d[u], r), o = Jr(d[u + 2], r), l = Jr(d[u + 4], 1), u += 5), d.length <= u) {
          i = l * h, r = /* void */
          e = a + i * s + h * o;
          break;
        }
      }
      default:
        throw $u();
    }
  if (i === 0)
    throw gd();
  ye.s = r < 0 ? -1 : 1, ye.n = Math.abs(e), ye.d = Math.abs(i);
};
function Wy(n, t, e) {
  for (var i = 1; t > 0; n = n * n % e, t >>= 1)
    t & 1 && (i = i * n % e);
  return i;
}
function Hy(n, t) {
  for (; t % 2 === 0; t /= 2)
    ;
  for (; t % 5 === 0; t /= 5)
    ;
  if (t === 1)
    return 0;
  for (var e = 10 % t, i = 1; e !== 1; i++)
    if (e = e * 10 % t, i > Uy)
      return 0;
  return i;
}
function Gy(n, t, e) {
  for (var i = 1, r = Wy(10, e, t), s = 0; s < 300; s++) {
    if (i === r)
      return s;
    i = i * 10 % t, r = r * 10 % t;
  }
  return 0;
}
function ma(n, t) {
  if (!n)
    return t;
  if (!t)
    return n;
  for (; ; ) {
    if (n %= t, !n)
      return t;
    if (t %= n, !t)
      return n;
  }
}
function Is(n, t) {
  if (Fi(n, t), this instanceof Is)
    n = ma(ye.d, ye.n), this.s = ye.s, this.n = ye.n / n, this.d = ye.d / n;
  else
    return wn(ye.s * ye.n, ye.d);
}
var gd = function() {
  return new Error("Division by Zero");
}, $u = function() {
  return new Error("Invalid argument");
}, Vy = function() {
  return new Error("Parameters must be integer");
};
Is.prototype = {
  s: 1,
  n: 0,
  d: 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return wn(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return wn(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(n, t) {
    return Fi(n, t), wn(
      this.s * this.n * ye.d + ye.s * this.d * ye.n,
      this.d * ye.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(n, t) {
    return Fi(n, t), wn(
      this.s * this.n * ye.d - ye.s * this.d * ye.n,
      this.d * ye.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(n, t) {
    return Fi(n, t), wn(
      this.s * ye.s * this.n * ye.n,
      this.d * ye.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(n, t) {
    return Fi(n, t), wn(
      this.s * ye.s * this.n * ye.d,
      this.d * ye.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return wn(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  mod: function(n, t) {
    if (isNaN(this.n) || isNaN(this.d))
      return new Is(NaN);
    if (n === void 0)
      return wn(this.s * this.n % this.d, 1);
    if (Fi(n, t), ye.n === 0 && this.d === 0)
      throw gd();
    return wn(
      this.s * (ye.d * this.n) % (ye.n * this.d),
      ye.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(n, t) {
    return Fi(n, t), wn(ma(ye.n, this.n) * ma(ye.d, this.d), ye.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(n, t) {
    return Fi(n, t), ye.n === 0 && this.n === 0 ? wn(0, 1) : wn(ye.n * this.n, ma(ye.n, this.n) * ma(ye.d, this.d));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Is(NaN) : wn(Math.ceil(n * this.s * this.n / this.d), n);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Is(NaN) : wn(Math.floor(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Is(NaN) : wn(Math.round(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  roundTo: function(n, t) {
    return Fi(n, t), wn(this.s * Math.round(this.n * ye.d / (this.d * ye.n)) * ye.n, ye.d);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return wn(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(n, t) {
    if (Fi(n, t), ye.d === 1)
      return ye.s < 0 ? wn(Math.pow(this.s * this.d, ye.n), Math.pow(this.n, ye.n)) : wn(Math.pow(this.s * this.n, ye.n), Math.pow(this.d, ye.n));
    if (this.s < 0) return null;
    var e = Op(this.n), i = Op(this.d), r = 1, s = 1;
    for (var o in e)
      if (o !== "1") {
        if (o === "0") {
          r = 0;
          break;
        }
        if (e[o] *= ye.n, e[o] % ye.d === 0)
          e[o] /= ye.d;
        else return null;
        r *= Math.pow(o, e[o]);
      }
    for (var o in i)
      if (o !== "1") {
        if (i[o] *= ye.n, i[o] % ye.d === 0)
          i[o] /= ye.d;
        else return null;
        s *= Math.pow(o, i[o]);
      }
    return ye.s < 0 ? wn(s, r) : wn(r, s);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(n, t) {
    return Fi(n, t), this.s * this.n * ye.d === ye.s * ye.n * this.d;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  compare: function(n, t) {
    Fi(n, t);
    var e = this.s * this.n * ye.d - ye.s * ye.n * this.d;
    return (0 < e) - (e < 0);
  },
  simplify: function(n) {
    if (isNaN(this.n) || isNaN(this.d))
      return this;
    n = n || 1e-3;
    for (var t = this.abs(), e = t.toContinued(), i = 1; i < e.length; i++) {
      for (var r = wn(e[i - 1], 1), s = i - 2; s >= 0; s--)
        r = r.inverse().add(e[s]);
      if (Math.abs(r.sub(t).valueOf()) < n)
        return r.mul(this.s);
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(n, t) {
    return Fi(n, t), !(!(ye.n * this.d) || this.n * ye.d % (ye.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return this.s * this.n / this.d;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  toFraction: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, e += " ", i %= r), e += i, e += "/", e += r), e;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, i %= r), e += "\\frac{", e += i, e += "}{", e += r, e += "}"), e;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    var n, t = this.n, e = this.d, i = [];
    if (isNaN(t) || isNaN(e))
      return i;
    do
      i.push(Math.floor(t / e)), n = t % e, t = e, e = n;
    while (t !== 1);
    return i;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(n) {
    var t = this.n, e = this.d;
    if (isNaN(t) || isNaN(e))
      return "NaN";
    n = n || 15;
    var i = Hy(t, e), r = Gy(t, e, i), s = this.s < 0 ? "-" : "";
    if (s += t / e | 0, t %= e, t *= 10, t && (s += "."), i) {
      for (var o = r; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += "(";
      for (var o = i; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += ")";
    } else
      for (var o = n; t && o--; )
        s += t / e | 0, t %= e, t *= 10;
    return s;
  }
};
function Yy(n) {
  if (!n) return null;
  if (n = n.toString().trim(), typeof navigator > "u" || typeof navigator.language > "u")
    return parseFloat(n);
  const { thousandsSeparator: t, decimalSeparator: e } = Ky();
  return n = Array.from(n, (i) => i === t ? "" : i === e ? "." : i).join(""), parseFloat(n);
}
function Ky() {
  const n = navigator.language, t = 123456789e-2.toLocaleString(n), e = t.replace(/\d/g, ""), i = Array.from(new Set(e.split("")));
  let r = "", s = "";
  if (i.length === 1)
    s = i[0];
  else if (i.length === 2) {
    const o = t[t.length - 3];
    i.includes(o) ? (s = o, r = i.find((a) => a !== o)) : (s = i[1], r = i[0]);
  }
  return { thousandsSeparator: r, decimalSeparator: s };
}
function J0(n) {
  if (!n || typeof n == "number") return !1;
  n = n.toString().replace(/[^0-9/ ]/g, "");
  const t = /\b\d+\/\d+\b/g;
  return n.match(t);
}
function Xy(n, t = !1) {
  if (!Dt(n)) return null;
  if (n === 0) return "0";
  let e = n.toString().trim();
  if (!e) return null;
  if (J0(n))
    return e = e.replace(/[^0-9/,. -]/g, "").replace(/  +/g, " "), e;
  {
    e = e.replace(/[^0-9,. -]/g, ""), e.startsWith(".") && (e = "0" + e);
    let i;
    return t ? i = Yy(e) : i = parseFloat(e), i ? i.toString() : null;
  }
}
function ul(n) {
  let t;
  try {
    t = new Is(n);
  } catch {
    console.log(`issue parsing ${n} to new Fraction()`), t = 0;
  }
  return t;
}
function re(n, t = "decimal", e = !1, i = !1, r = 0) {
  if (!Dt(n) || !t) return null;
  if (t !== "decimal" && t !== "fraction")
    return console.error("incorrect conversion type specified for convertUnit"), null;
  try {
    const s = Xy(n, i);
    if (!s) return 0;
    let o;
    if (t === "fraction")
      if (J0(s))
        o = ul(s);
      else {
        const a = parseFloat(s);
        Number.isInteger(a) ? o = ul(s) : o = ul(a);
      }
    else o = ul(s);
    switch (t) {
      case "fraction":
        if (r > 0) {
          const a = o.valueOf(), l = Math.round(a * r) / r;
          o = ul(l);
        }
        return o.toFraction(!0);
      case "decimal":
        if (e === !1 || typeof e != "number")
          return o.valueOf();
        {
          const a = o.valueOf();
          return a === 0 ? 0 : parseFloat(a.toFixed(e));
        }
      default:
        return 0;
    }
  } catch (s) {
    return console.error(s), 0;
  }
}
function Jy(n) {
  let t = n;
  return typeof n != "number" && (t = parseFloat(n)), t % 1 !== 0;
}
const ai = {
  customData: (n, t = null) => {
    const e = [];
    return typeof n != "object" ? (e.push({ message: "Custom data must be an object." }), e) : (Object.entries(n).forEach(([i, r]) => {
      Dt(r) && (["string", "number", "boolean"].includes(typeof r) || e.push({
        message: `Custom data ${i} must be a string, number or boolean.`,
        index: t
      }));
    }), e);
  },
  banding: (n, t = null) => {
    const e = [];
    if (!Dt(n)) return [];
    if (typeof n != "object")
      return e.push({
        message: "Banding must be an object.",
        field: ["banding"],
        index: t
      }), e;
    Object.entries(n).forEach(([i, r]) => {
      Dt(r) && r !== !0 && r !== !1 && e.push({
        message: `Banding ${i} must be a boolean.`,
        field: ["banding"],
        index: t
      });
    });
  },
  //when trim provided as number
  partTrim(n, t, e = null) {
    t = re(t);
    const i = re(n.l), r = re(n.w), s = i - t * 2, o = r - t * 2;
    return s < 0 || o < 0 ? [
      {
        message: `When applying trim of ${t}, part is ${s} x ${o}.`,
        field: ["trim"],
        index: e
      }
    ] : [];
  },
  //when trim provided as object
  trim: (n, t = null) => {
    const e = [];
    if (!Dt(n.trim)) return e;
    if (pr.forEach((i) => {
      Dt(n.trim[i]) || (n.trim[i] = 0);
    }), !ts(n) || ts(n) && !(n != null && n.trimmed)) {
      const i = ["l", "w"], [r, s] = i.map((d) => re(n[d])), [o, a, l, h] = pr.map((d) => re(n.trim[d]));
      Object.entries({ x1: o, x2: a, y1: l, y2: h }).forEach(([d, p]) => {
        isNaN(p) && e.push({
          message: `The value of trim ${sf[d]} is not understood.`,
          field: ["trim"],
          index: t
        });
      }), r && s && r > 0 && s > 0 && (o + a >= n.l && e.push({
        message: `Trim W1 + W2 = ${o + a}, which is greater than or equal to total length of ${r}.`,
        field: ["trim"],
        subField: ["x1", "x2"],
        index: t
      }), l + h >= n.w && e.push({
        message: `Trim L1 + L2 = ${l + h}, which is greater than or equal to total width of ${s}.`,
        field: ["trim"],
        subField: ["y1", "y2"],
        index: t
      }));
    }
    return e;
  },
  x: (n, t = null) => {
    const e = [];
    return Dt(n) ? (n = re(n), isNaN(n) ? (e.push({ message: `X value is not understood, got ${n}`, index: t }), e) : (n < 0 && e.push({ message: `X must be greater than or equal to zero, got ${n}` }), e)) : e;
  },
  y: (n, t = null) => {
    const e = [];
    return Dt(n) && (n = re(n), isNaN(n) && e.push({ message: `Y value is not understood, got ${n}`, index: t }), n < 0 && e.push({ message: `Y must be greater than or equal to zero, got ${n}`, index: t })), e;
  },
  l: (n, t = null, e = 0) => {
    const i = [];
    return Dt(n) ? (n = re(n), isNaN(n) ? (i.push({
      message: `Length value is not understood, got ${n}`,
      field: ["l"],
      index: t
    }), i) : (n < e && i.push({
      message: `Length must be greater than or equal to ${e}, got ${n}`,
      field: ["l"],
      index: t
    }), i)) : (i.push({
      message: "Length is required.",
      field: ["l"],
      index: t
    }), i);
  },
  w: (n, t = null, e = 0) => {
    const i = [];
    return Dt(n) ? (n = re(n), isNaN(n) ? (i.push({
      message: `Width value is not understood, got ${n}`,
      field: ["w"],
      index: t
    }), i) : (n < e && i.push({
      message: `Width must be greater than or equal to ${e}, got ${n}`,
      field: ["w"],
      index: t
    }), i)) : (i.push({
      message: "Width is required.",
      field: ["w"],
      index: t
    }), i);
  },
  t: (n, t = null) => {
    const e = [];
    return !Dt(n) || n === "" ? e : (n = re(n), isNaN(n) ? (e.push({
      message: `Thickness value is not understood, got ${n}`,
      field: ["t"],
      index: t
    }), e) : (n && n <= 0 && e.push({
      message: `Thickness must be greater than zero, got ${n}`,
      field: ["t"],
      index: t
    }), e));
  },
  q: (n, t = null, e = null) => {
    const i = [];
    return Dt(n) ? (n = parseInt(n), isNaN(n) ? (i.push({
      message: `Quantity value is not understood, got ${n}`,
      field: ["q"],
      index: e
    }), i) : (Jy(n) && i.push({
      message: "Quantity should be an integer.",
      field: ["q"],
      index: e
    }), n <= 0 && (t || i.push({
      message: `Quantity should be greater than or equal to zero, got ${n}`,
      field: ["q"],
      index: e
    })), i)) : (i.push({
      message: "Quantity should be set.",
      field: ["q"],
      index: e
    }), i);
  },
  orientationLock: (n, t = null) => {
    const e = [];
    return Dt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Orientation lock must be l or w, got ${n}`,
      field: ["orientationLock"],
      index: t
    })), e;
  },
  grain: (n, t = null) => {
    const e = [];
    return Dt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Grain must be l or w, got ${n}`,
      index: t
    })), e;
  },
  stockMatch: (n, t, e, i = 0, r = null) => {
    if (!n.q) return [];
    if (n.applyPartTrim(i), n.issues.length) return [];
    const s = Hb([n], t, e);
    if (!s) return [];
    const o = [];
    if (s.unusableShapes.length) {
      const a = s.unusableShapes[0], l = a.stockMatch;
      if (!l.fit) {
        const h = a.getTrimmedDimensions();
        o.push({
          message: `${h.l.toFixed(0)}x${h.w.toFixed(0)} will not fit on any stock - check trim, dimensions & orientation lock.`,
          field: ["l", "w"],
          index: r
        });
      }
      l.material || o.push({
        message: "No matching stock material found.",
        field: ["material"],
        index: r
      }), l.thickness || o.push({
        message: "No matching stock thickness found.",
        field: ["t"],
        index: r
      }), !l.width && e === "linear" && o.push({
        message: "No matching stock width found - required for linear calculations.",
        field: ["w"],
        index: r
      });
    }
    return o;
  },
  machining: (n, t = null) => {
    n.machining.validateEverything(n, t);
  }
};
function nf(n) {
  let t, e;
  switch (n) {
    case "l":
    case "length":
      t = "guillotine", e = "l";
      break;
    case "w":
    case "width":
      t = "guillotine", e = "w";
      break;
    case "flex":
      t = "guillotine", e = "flex";
      break;
    case "efficiency":
      t = "efficiency", e = "none";
      break;
    case "beam":
      t = "beam", e = "l";
      break;
    default:
      t = null, e = null;
      break;
  }
  return {
    cutPreference: e,
    cutType: t
  };
}
var Z0 = typeof global == "object" && global && global.Object === Object && global, Zy = typeof self == "object" && self && self.Object === Object && self, md = Z0 || Zy || Function("return this")(), sc = md.Symbol, Q0 = Object.prototype, Qy = Q0.hasOwnProperty, t5 = Q0.toString, cl = sc ? sc.toStringTag : void 0;
function e5(n) {
  var t = Qy.call(n, cl), e = n[cl];
  try {
    n[cl] = void 0;
    var i = !0;
  } catch {
  }
  var r = t5.call(n);
  return i && (t ? n[cl] = e : delete n[cl]), r;
}
var n5 = Object.prototype, i5 = n5.toString;
function r5(n) {
  return i5.call(n);
}
var s5 = "[object Null]", o5 = "[object Undefined]", Tp = sc ? sc.toStringTag : void 0;
function yd(n) {
  return n == null ? n === void 0 ? o5 : s5 : Tp && Tp in Object(n) ? e5(n) : r5(n);
}
function bd(n) {
  return n != null && typeof n == "object";
}
var a5 = Array.isArray;
function Fc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
function t1(n) {
  return n;
}
var l5 = "[object AsyncFunction]", u5 = "[object Function]", c5 = "[object GeneratorFunction]", h5 = "[object Proxy]";
function e1(n) {
  if (!Fc(n))
    return !1;
  var t = yd(n);
  return t == u5 || t == c5 || t == l5 || t == h5;
}
var wh = md["__core-js_shared__"], Fp = function() {
  var n = /[^.]+$/.exec(wh && wh.keys && wh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function f5(n) {
  return !!Fp && Fp in n;
}
var d5 = Function.prototype, p5 = d5.toString;
function g5(n) {
  if (n != null) {
    try {
      return p5.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var m5 = /[\\^$.*+?()[\]{}|]/g, y5 = /^\[object .+?Constructor\]$/, b5 = Function.prototype, v5 = Object.prototype, w5 = b5.toString, x5 = v5.hasOwnProperty, _5 = RegExp(
  "^" + w5.call(x5).replace(m5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function S5(n) {
  if (!Fc(n) || f5(n))
    return !1;
  var t = e1(n) ? _5 : y5;
  return t.test(g5(n));
}
function k5(n, t) {
  return n == null ? void 0 : n[t];
}
function A5(n, t) {
  var e = k5(n, t);
  return S5(e) ? e : void 0;
}
function N5(n, t, e) {
  switch (e.length) {
    case 0:
      return n.call(t);
    case 1:
      return n.call(t, e[0]);
    case 2:
      return n.call(t, e[0], e[1]);
    case 3:
      return n.call(t, e[0], e[1], e[2]);
  }
  return n.apply(t, e);
}
var C5 = 800, P5 = 16, L5 = Date.now;
function I5(n) {
  var t = 0, e = 0;
  return function() {
    var i = L5(), r = P5 - (i - e);
    if (e = i, r > 0) {
      if (++t >= C5)
        return arguments[0];
    } else
      t = 0;
    return n.apply(void 0, arguments);
  };
}
function E5(n) {
  return function() {
    return n;
  };
}
var Mp = function() {
  try {
    var n = A5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), O5 = Mp ? function(n, t) {
  return Mp(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: E5(t),
    writable: !0
  });
} : t1, T5 = I5(O5), F5 = 9007199254740991, M5 = /^(?:0|[1-9]\d*)$/;
function n1(n, t) {
  var e = typeof n;
  return t = t ?? F5, !!t && (e == "number" || e != "symbol" && M5.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function i1(n, t) {
  return n === t || n !== n && t !== t;
}
var Rp = Math.max;
function R5(n, t, e) {
  return t = Rp(t === void 0 ? n.length - 1 : t, 0), function() {
    for (var i = arguments, r = -1, s = Rp(i.length - t, 0), o = Array(s); ++r < s; )
      o[r] = i[t + r];
    r = -1;
    for (var a = Array(t + 1); ++r < t; )
      a[r] = i[r];
    return a[t] = e(o), N5(n, this, a);
  };
}
function D5(n, t) {
  return T5(R5(n, t, t1), n + "");
}
var B5 = 9007199254740991;
function r1(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= B5;
}
function s1(n) {
  return n != null && r1(n.length) && !e1(n);
}
function j5(n, t, e) {
  if (!Fc(e))
    return !1;
  var i = typeof t;
  return (i == "number" ? s1(e) && n1(t, e.length) : i == "string" && t in e) ? i1(e[t], n) : !1;
}
var q5 = Object.prototype;
function z5(n) {
  var t = n && n.constructor, e = typeof t == "function" && t.prototype || q5;
  return n === e;
}
function $5(n, t) {
  for (var e = -1, i = Array(n); ++e < n; )
    i[e] = t(e);
  return i;
}
var U5 = "[object Arguments]";
function Dp(n) {
  return bd(n) && yd(n) == U5;
}
var o1 = Object.prototype, W5 = o1.hasOwnProperty, H5 = o1.propertyIsEnumerable, G5 = Dp(/* @__PURE__ */ function() {
  return arguments;
}()) ? Dp : function(n) {
  return bd(n) && W5.call(n, "callee") && !H5.call(n, "callee");
};
function V5() {
  return !1;
}
var a1 = typeof exports == "object" && exports && !exports.nodeType && exports, Bp = a1 && typeof module == "object" && module && !module.nodeType && module, Y5 = Bp && Bp.exports === a1, jp = Y5 ? md.Buffer : void 0, K5 = jp ? jp.isBuffer : void 0, X5 = K5 || V5, J5 = "[object Arguments]", Z5 = "[object Array]", Q5 = "[object Boolean]", tb = "[object Date]", eb = "[object Error]", nb = "[object Function]", ib = "[object Map]", rb = "[object Number]", sb = "[object Object]", ob = "[object RegExp]", ab = "[object Set]", lb = "[object String]", ub = "[object WeakMap]", cb = "[object ArrayBuffer]", hb = "[object DataView]", fb = "[object Float32Array]", db = "[object Float64Array]", pb = "[object Int8Array]", gb = "[object Int16Array]", mb = "[object Int32Array]", yb = "[object Uint8Array]", bb = "[object Uint8ClampedArray]", vb = "[object Uint16Array]", wb = "[object Uint32Array]", fn = {};
fn[fb] = fn[db] = fn[pb] = fn[gb] = fn[mb] = fn[yb] = fn[bb] = fn[vb] = fn[wb] = !0;
fn[J5] = fn[Z5] = fn[cb] = fn[Q5] = fn[hb] = fn[tb] = fn[eb] = fn[nb] = fn[ib] = fn[rb] = fn[sb] = fn[ob] = fn[ab] = fn[lb] = fn[ub] = !1;
function xb(n) {
  return bd(n) && r1(n.length) && !!fn[yd(n)];
}
function _b(n) {
  return function(t) {
    return n(t);
  };
}
var l1 = typeof exports == "object" && exports && !exports.nodeType && exports, _l = l1 && typeof module == "object" && module && !module.nodeType && module, Sb = _l && _l.exports === l1, xh = Sb && Z0.process, qp = function() {
  try {
    var n = _l && _l.require && _l.require("util").types;
    return n || xh && xh.binding && xh.binding("util");
  } catch {
  }
}(), zp = qp && qp.isTypedArray, kb = zp ? _b(zp) : xb;
function Ab(n, t) {
  var e = a5(n), i = !e && G5(n), r = !e && !i && X5(n), s = !e && !i && !r && kb(n), o = e || i || r || s, a = o ? $5(n.length, String) : [], l = a.length;
  for (var h in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (h == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (h == "offset" || h == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || // Skip index properties.
    n1(h, l)) || a.push(h);
  return a;
}
function Nb(n) {
  var t = [];
  if (n != null)
    for (var e in Object(n))
      t.push(e);
  return t;
}
var Cb = Object.prototype, Pb = Cb.hasOwnProperty;
function Lb(n) {
  if (!Fc(n))
    return Nb(n);
  var t = z5(n), e = [];
  for (var i in n)
    i == "constructor" && (t || !Pb.call(n, i)) || e.push(i);
  return e;
}
function Ib(n) {
  return s1(n) ? Ab(n) : Lb(n);
}
var u1 = Object.prototype, Eb = u1.hasOwnProperty, yl = D5(function(n, t) {
  n = Object(n);
  var e = -1, i = t.length, r = i > 2 ? t[2] : void 0;
  for (r && j5(t[0], t[1], r) && (i = 1); ++e < i; )
    for (var s = t[e], o = Ib(s), a = -1, l = o.length; ++a < l; ) {
      var h = o[a], u = n[h];
      (u === void 0 || i1(u, u1[h]) && !Eb.call(n, h)) && (n[h] = s[h]);
    }
  return n;
});
function Ob(n, t, e) {
  if (!ql.includes(t) || !n.machining.corners) return 0;
  const i = c1(n, t);
  return e * i;
}
function c1(n, t) {
  if (!ql.includes(t) || !n.machining.corners) return 0;
  const e = n.machining.corners.find((r) => r.getCorner() === t);
  return e ? e.getLength() : 0;
}
function h1(n, t, e, i) {
  Object.keys(t).forEach((r) => {
    var s, o;
    r in n && ((s = t[r]) != null && s.min && re(n[r]) < re(t[r].min) ? e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be less than ${t[r].min}.`,
      fields: [r]
    }) : (o = t[r]) != null && o.max && re(n[r]) > re(t[r].max) && e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be greater than ${t[r].max}.`,
      fields: [r]
    }));
  });
}
class rf {
  constructor({ x: t, y: e, diameter: i, depth: r = 0, face: s = 0, type: o = null }) {
    tt(this, "x");
    tt(this, "y");
    tt(this, "diameter");
    tt(this, "depth");
    tt(this, "face");
    tt(this, "valid");
    tt(this, "type");
    this.x = t, this.y = e, this.diameter = i, this.depth = r, this.face = s, this.type = o;
  }
  getFace() {
    return fr[this.face];
  }
  getXDrawPosition(t) {
    let e = 0;
    const i = re(this.x);
    return t.rot ? e = t.l - re(this.y) + ("x" in t ? re(t.x) : 0) : e = i + ("x" in t ? re(t.x) : 0), e;
  }
  getYDrawPosition(t, e, i) {
    let r = t.rot ? re(this.x) : re(this.y);
    return r += "y" in t ? re(t.y) : 0, e === 1 && (i ? r = re(i.w) - r : r = re(t.w) - r), r;
  }
  shouldShow(t, e) {
    return this.face === e || this.isThroughShape(t) === !0;
  }
  isThroughShape(t) {
    return !this.depth || re(this.depth) >= re(t.t);
  }
  getDistanceToEdge(t) {
    const e = this.x, i = this.y, r = this.diameter / 2, s = re(t.getLongSide()), o = re(t.getShortSide()), a = t.machining.corners.map((m) => m.type ? m.size : 0), l = [
      {
        edge: "left",
        distance: e - r
      },
      {
        edge: "right",
        distance: s - e - r
      },
      {
        edge: "bottom",
        distance: o - i - r
      },
      {
        edge: "top",
        distance: i - r
      }
    ], h = t.machining.corners.map((m, b) => {
      const x = b === 0 || b === 3, y = b < 2, v = x ? e : s - e;
      let k = null;
      this.face === 0 ? k = y ? i : o - i : this.face === 1 && (k = y ? o - i : i);
      const C = Math.sqrt(v * v + k * k);
      return {
        c: m,
        distance: C
      };
    }), u = Math.min(...l.map((m) => m.distance)), d = Math.min(...h.map((m) => m.distance)), p = h.findIndex((m) => m.distance === d), f = t.machining.corners[p];
    if (f && f.type === "radius") {
      let m = p === 0 || p === 3 ? 0 : s, b = p < 2 ? 0 : o;
      const x = p < 2;
      m += p === 0 || p === 3 ? a[p] : -a[p], b += x ? a[p] : -a[p];
      const v = e - m, k = p < 2;
      let C;
      this.face === 0 ? C = k ? i : o - i : this.face === 1 && (C = k ? o - i : i);
      const I = C - b, q = Math.sqrt(v * v + I * I), O = a[p] - q - r;
      let F = !1;
      return f.index === 0 ? F = e <= m && C <= b : f.index === 1 ? F = e >= m && C <= b : f.index === 2 ? F = e >= m && C >= b : f.index === 3 && (F = e <= m && C >= b), F && O < u ? O : u;
    } else if (f && f.type === "bevel") {
      let m, b, x;
      f.index === 0 ? (m = 1, b = 1, x = -f.size) : f.index === 1 ? (m = 1, b = -1, x = -s + f.size) : f.index === 2 ? (m = 1, b = 1, x = -s - o + f.size) : f.index === 3 && (m = -1, b = 1, x = -o + f.size);
      const y = f.index === 0 ? 1 : -1, v = (m * e + b * i + x) / Math.sqrt(m * m + b * b) * y - r;
      return v < u ? v : u;
    } else
      return u;
  }
  validate(t, e, i = null) {
    const r = [];
    if (!Dt(this.x) || !Dt(this.y) || !Dt(this.diameter)) {
      const o = {
        index: e,
        message: "X, Y & diameter are all required.",
        fields: []
      };
      this.x || o.fields.push("x"), this.y || o.fields.push("y"), this.diameter || o.fields.push("diameter"), r.push(o);
    }
    return re(this.diameter) <= 0 && r.push({
      index: e,
      message: "Diameter cannot be negative or zero.",
      fields: ["diameter"]
    }), re(this.depth) < 0 && r.push({
      index: e,
      message: "Depth cannot be negative.",
      fields: ["depth"]
    }), "t" in t && re(t.t) > 0 && re(this.depth) > re(t.t) && r.push({
      index: e,
      message: "Depth cannot be greater than part thickness.",
      fields: ["depth"]
    }), (!("t" in t) || !t.t) && re(this.depth) > 0 && r.push({
      index: e,
      message: "Part thickness is not defined.",
      fields: ["depth"]
    }), this.getDistanceToEdge(t) < 0 && r.push({
      index: e,
      message: "Outside of part."
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class $p {
  constructor({
    position: t = null,
    //from left or bottom
    edge: e = "x1",
    face: i = 0,
    numHoles: r = null,
    diameter: s = 0,
    depth: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    hingeLength: h = 0,
    minimumHoleDistance: u = 0,
    positionLimit: d = 0
  }, p) {
    tt(this, "position");
    tt(this, "edge");
    tt(this, "face");
    tt(this, "numHoles");
    tt(this, "holes", []);
    tt(this, "diameter");
    tt(this, "depth");
    tt(this, "distanceFromEdge");
    //from edge to center of hole
    tt(this, "outerSpacing");
    //from edge to center of hole
    tt(this, "hingeLength");
    tt(this, "minimumHoleDistance");
    tt(this, "positionLimit");
    tt(this, "valid");
    this.position = t, this.edge = e, this.face = i, this.numHoles = r, this.diameter = s, this.depth = o, this.distanceFromEdge = a, this.outerSpacing = l, this.hingeLength = h, this.minimumHoleDistance = u, this.positionLimit = d, p && this.createHoles(p);
  }
  getFace() {
    return fr[this.face];
  }
  getHoleSpacing() {
    const t = re(this.hingeLength) - re(this.outerSpacing) * 2, e = this.numHoles - 1;
    return t / e;
  }
  getHoleXPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
        i = this.distanceFromEdge;
        break;
      case "x2":
        i = t.getLongSide() - re(this.distanceFromEdge);
        break;
      case "y1":
      case "y2":
        i = re(this.position) + re(this.outerSpacing) + r * e;
        break;
    }
    return i;
  }
  getHoleYPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
      case "x2":
        i = re(this.position) + re(this.outerSpacing) + r * e;
        break;
      case "y1":
        i = re(this.distanceFromEdge);
        break;
      case "y2":
        i = t.getShortSide() - re(this.distanceFromEdge);
        break;
    }
    return i;
  }
  createHoles(t) {
    this.holes = [];
    for (let e = 0; e < this.numHoles; e++) {
      const i = new rf({
        x: this.getHoleXPosition(t, e),
        y: this.getHoleYPosition(t, e),
        diameter: this.diameter,
        depth: this.depth,
        face: this.face,
        type: "hinge"
      });
      this.holes.push(i);
    }
    return this.holes;
  }
  validate(t, e, i = null) {
    const r = [];
    return this.holes.forEach((s, o) => {
      const a = s.validate(t, o).map((l) => (l.index = e, l.message = `Hole ${o + 1}: ${l.message}`, l));
      r.push(...a);
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class Up {
  constructor({ type: t = "radius", size: e, index: i }) {
    tt(this, "type");
    tt(this, "size");
    tt(this, "index");
    tt(this, "valid");
    this.type = t, this.size = e, this.index = i;
  }
  getLength() {
    return this.type === "radius" ? Math.PI * this.size / 2 : this.type === "bevel" ? Math.sqrt(2) * this.size : 0;
  }
  getCorner() {
    return ["a", "b", "c", "d"][this.index];
  }
  isPresent() {
    return (this.valid === !0 || this.valid === void 0) && this.type !== null && this.size > 0;
  }
  validate(t, e) {
    const i = t.getShortSide(), r = [];
    if (this.type === null) {
      this.size = null;
      const s = this.getCorner();
      t.banding[s] = !1;
    }
    return this.type && re(this.size) <= 0 && r.push({
      index: e,
      message: "Corner size cannot be zero or negative"
    }), this.type && re(this.size) > i / 2 && (this.size = i / 2), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class f1 {
  //shelfHoles?: ShelfHoles[] = [];
  constructor({
    holes: t = [],
    hingeHoles: e = [],
    corners: i = []
  } = {}) {
    tt(this, "holes", []);
    tt(this, "corners", []);
    tt(this, "hingeHoles", []);
    i && i.length === 4 ? this.corners = i.map((r) => new Up(r)) : [0, 1, 2, 3].forEach((r) => {
      this.corners.push(new Up({
        type: null,
        size: null,
        index: r
      }));
    }), t && (this.holes = t.map((r) => new rf(r))), e && (this.hingeHoles = e.map((r) => new $p(r)));
  }
  validateEverything(t, e = null) {
    const i = this.validate(t, "holes"), r = this.validate(t, "hingeHoles"), s = this.validate(t, "corners");
    t.issues.push(...i.map((o) => gr(t) ? { message: `Part ${t.id} hole issue: ${o.message}`, index: e } : { message: `Hole issue: ${o.message}`, index: e })), t.issues.push(...r.map((o) => gr(t) ? { message: `Part ${t.id} hinge hole issue: ${o.message}`, index: e } : { message: `Hinge hole issue: ${o.message}`, index: e })), t.issues.push(...s.map((o) => gr(t) ? { message: `Part ${t.id} corner issue: ${o.message}`, index: e } : { message: `Corner issue: ${o.message}`, index: e }));
  }
  validate(t, e, i = null) {
    if (!t) return [];
    if (!e) return [];
    const r = [];
    return r.push(...this.validateAll(t, e, i)), r;
  }
  validateAll(t, e, i = null) {
    if (!t) return [];
    const r = [];
    return this[e].forEach((s, o) => r.push(...s.validate(t, o, i))), r;
  }
  createHole(t, e, i, r = 0, s = 0) {
    const o = new rf({
      x: t,
      y: e,
      diameter: i,
      depth: r,
      face: s
    });
    return this.holes.push(o), o;
  }
  createHingeHoles({
    numHoles: t,
    position: e,
    diameter: i,
    depth: r = 0,
    edge: s = "x1",
    face: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    minimumHoleDistance: h = 0,
    hingeLength: u = 0
  }) {
    const d = new $p({
      numHoles: t,
      position: e,
      //from left or bottom
      edge: s,
      face: o,
      diameter: i,
      depth: r,
      distanceFromEdge: a,
      outerSpacing: l,
      minimumHoleDistance: h,
      hingeLength: u
    });
    return this.hingeHoles.push(d), d;
  }
  updateHingeHoles(t) {
    this.hingeHoles.forEach((e) => e.createHoles(t));
  }
  getAllHingeHoles(t) {
    const e = [];
    return this.hingeHoles.forEach((i) => {
      i.holes.length ? e.push(...i.holes) : (i.createHoles(t), e.push(...i.holes));
    }), e;
  }
  getNumHoles() {
    return this.holes.length + this.hingeHoles.reduce(
      (t, e) => t + e.numHoles,
      0
    );
  }
  getNumCorners() {
    return this.corners.filter((t) => t.type !== null).length;
  }
}
function d1(n) {
  var t, e, i, r, s, o, a, l;
  return !n || !(n != null && n.machining) ? !1 : (e = (t = n.machining) == null ? void 0 : t.holes) != null && e.length || (r = (i = n.machining) == null ? void 0 : i.hingeHoles) != null && r.length ? !0 : (o = (s = n.machining) == null ? void 0 : s.corners) != null && o.length ? (l = (a = n.machining) == null ? void 0 : a.corners) == null ? void 0 : l.some((h) => h.type && h.size) : !1;
}
function Tb(n) {
  var t, e, i, r;
  if ("machining" in n) {
    if (!d1(n)) {
      n.machining = null;
      return;
    }
    (t = n.machining.holes) != null && t.length || (n.machining.holes = null), (e = n.machining.hingeHoles) != null && e.length || (n.machining.hingeHoles = null), (r = (i = n.machining) == null ? void 0 : i.corners) != null && r.some((s) => s.type && s.size) || (n.machining.corners = null);
  }
}
class Fb {
  constructor(t = null) {
    tt(this, "id");
    //api
    tt(this, "listId");
    tt(this, "shapeListIds", []);
    tt(this, "shapes");
    tt(this, "direction");
    tt(this, "q");
    tt(this, "duplicate", !1);
    tt(this, "issues", []);
    tt(this, "stockMatch");
    var e;
    this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Math.ceil(Math.random() * 1e16), this.id = t == null ? void 0 : t.id, this.shapes = Dt(t == null ? void 0 : t.shapes) ? t.shapes.map((i) => i.toString()) : [], this.shapeListIds = Dt(t == null ? void 0 : t.shapeListIds) ? t.shapeListIds : [], this.direction = Dt(t == null ? void 0 : t.direction) ? t.direction : "l", this.q = Dt(t == null ? void 0 : t.q) ? t.q : 1, Dt(t == null ? void 0 : t.shapeList) && ((e = t.shapeList) != null && e.length) && this.validate(t.shapeList);
  }
  validate(t = []) {
    var o, a;
    if (this.issues = [], !(t != null && t.length))
      throw new Error("shapeList is required to validate user group");
    const e = this.findShapes(t);
    if (!e.length)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    const i = e[0];
    if (gr(i)) {
      if (!(this != null && this.shapes) || ((o = this.shapes) == null ? void 0 : o.length) < 2)
        return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    } else if (!(this != null && this.shapeListIds) || ((a = this.shapeListIds) == null ? void 0 : a.length) < 2)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    if (e.forEach((l, h) => {
      !l.isSquare() && !["l", "w"].includes(l.orientationLock) && this.issues.push({ message: `Part in position ${h + 1} must have orientation lock set to be part of a group.` });
    }), this.issues.length) return this.issues;
    const r = ko(this.direction), s = i.getTrimmedDimensions(!0)[r];
    return e.forEach((l, h) => {
      if (l.id === i.id) return;
      const u = l.getTrimmedDimensions(!0)[r];
      He.equalTo(u, s) || this.issues.push({ message: `Part in position ${h + 1} final ${r === "l" ? "length" : "width"} is not correct for the group. Expected ${s} and is ${u}. Check the dimensions, trim & orientation lock.` });
    }), this.issues;
  }
  findShapes(t = []) {
    var i, r;
    if (!t.length) return [];
    let e = [];
    if (cr(t[0])) {
      if (!((i = this.shapeListIds) != null && i.length)) return [];
      if (e = this.shapeListIds.map((s) => t.find((o) => o.listId === s)).filter((s) => s), !e.length)
        throw new Error("could not map group shapes to shape list");
      return e;
    } else {
      if (!((r = this.shapes) != null && r.length)) return [];
      const s = /* @__PURE__ */ new Set();
      e = this.shapes.map((o) => {
        const a = t.find((l) => l.parentID === o && !l.inUserGroup && !s.has(l.id));
        return a ? (s.add(a.id), a) : null;
      }).filter((o) => o);
    }
    if (!e.length)
      throw new Error("could not map group shapes to shape list");
    return e;
  }
  populateParentID(t) {
    var e;
    t != null && t.length && (e = this == null ? void 0 : this.shapeListIds) != null && e.length && (this.shapes = this.shapeListIds.map((i) => (t.findIndex((s) => s.listId === i) + 1).toString()));
  }
  //create a group from a user group
  createGroup(t = 0, e = 0, i = [], r = null) {
    if (!(i != null && i.length))
      throw new Error("some parts are required to create a user group");
    if (!gr(i[0]))
      throw new Error("shapeList must be of type Shape[]");
    const s = this.findShapes(i);
    if (!s.length) return !1;
    const o = s[0];
    s.forEach((u) => {
      const d = i.findIndex((p) => !p.inUserGroup && p.parentID === u.parentID);
      if (d === -1)
        throw new Error("shape not found in shapeList while creating user group.");
      i.splice(d, 1), u.setRotationToOrientationLockWithoutContainer(), u.inUserGroup = !0;
    });
    let a = 0, l = 0;
    this.direction === "l" ? l = o.w : a = o.l;
    let h;
    try {
      const u = {
        id: `ug${t}.${e}`,
        shapes: s,
        l: a,
        w: l,
        t: o == null ? void 0 : o.t,
        material: o == null ? void 0 : o.material,
        // joinDimension:
        //     referenceShape.l === l ? referenceShape.l : referenceShape.w,
        direction: this.direction,
        preventAutoRotation: !0,
        container: r,
        type: "user"
      };
      h = new $s(u);
    } catch (u) {
      return console.error(u), !1;
    }
    return h.parentID = `ug${t}`, r && h.updateShapeSpacing(r), h;
  }
}
const pr = ["y1", "y2", "x1", "x2"], ql = ["a", "b", "c", "d"], Os = [...pr, ...ql], fr = ["a", "b"];
function p1(n) {
  return ql.includes(n);
}
function Mb(n) {
  return Os.includes(n);
}
const sf = {
  x: "x",
  y: "y",
  l: "length",
  w: "width",
  t: "thickness",
  q: "quantity",
  orientationLock: "rotation",
  name: "name",
  material: "material",
  banding: "banding",
  finish: "finish",
  cost: "cost",
  grain: "grain",
  trim: "trim",
  x1: "w1",
  x2: "w2",
  y1: "l1",
  y2: "l2",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  all: "all"
};
function Rb(n) {
  return pr.map((t) => n[t] ?? null);
}
function No(n) {
  if (!Dt(n) || typeof n != "object") return {};
  n = { ...n };
  for (const [t, e] of Object.entries(n))
    t !== "_id" && t.startsWith("_") && (n[t.substring(1)] = e, delete n[t]);
  return n;
}
function Db(n, t = null) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    var i;
    return delete e.id, t ? e.units = t : e.units || (e.units = ((i = this == null ? void 0 : this.optionsStore) == null ? void 0 : i.units) ?? "decimal"), new vd(e);
  });
}
function Bb({
  stockList: n,
  removeScores: t = !1,
  saw: e = null,
  preventAutoRotation: i = !1,
  preventGrainRotation: r = !1
}) {
  return !n || !(n != null && n.length) ? [] : n.filter((s) => s).map((s) => {
    e && (s.saw = e), i && (s.preventAutoRotation = !0), r && (s.preventGrainRotation = !0);
    const o = new es(s);
    if (o.issues.length)
      throw new Error(
        `Issues found when attempting to recreate stock list - ${o.issues.map((a) => a.message).join()}`,
        { cause: o.issues }
      );
    return t && delete o.algoBenchmark, o;
  }).sort(Ju.ID);
}
function jb({
  shapeList: n,
  stockList: t,
  preventAutoRotation: e = !1
}) {
  if (typeof t > "u")
    throw new Error("recreateShapeList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.filter((i) => i).map((i) => {
    var o;
    e && (i.preventAutoRotation = !0);
    let r;
    if (Vb(i) && ((o = i == null ? void 0 : i.shapes) != null && o.length)) {
      i.shapes = i.shapes.map((a) => new ns(a));
      try {
        r = new $s(i);
      } catch {
        throw new Error("error creating group from shape data");
      }
    } else
      r = new ns(i);
    if (r.issues.length)
      throw new Error(`Issues found when attempting to recreate shape list - ${r.issues.join()}`);
    const s = t.find((a) => {
      var l;
      return a.id === (((l = i == null ? void 0 : i.stock) == null ? void 0 : l.id) ?? (i == null ? void 0 : i.stockId));
    });
    return r.stock = s, r;
  }).sort(Ju.ID);
}
function qb({
  cutList: n,
  stockList: t
}) {
  if (typeof t > "u")
    throw new Error("recreateCutList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = new Tc(e), r = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return i.stock = r, i;
  });
}
function zb({
  segmentList: n,
  stockList: t
}) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return e.stock = i, new y1(e);
  });
}
function g1(n = null, t = null, e = null) {
  if (!n) throw new Error("no container supplied to willItFit");
  if (!t) throw new Error("no shape supplied to willItFit");
  const i = t.rot;
  function r(p = !1, f = "l") {
    var m, b;
    return He.equalTo(
      t[p ? ko(f) : f],
      n[f]
    ) || He.lessThanOrEqualTo(t[p ? ko(f) : f], n[f] - (of(n) ? (b = (m = n == null ? void 0 : n.saw) == null ? void 0 : m.options) == null ? void 0 : b.minSpacing : 0));
  }
  function s(p = !0) {
    return t.forceRotate(i), p;
  }
  const o = t.getNecessaryOrientation(n);
  let a = null;
  if (o && (a = o === "l" ? 0 : 1), t.orientationLock) {
    if (Dt(e) && e !== a)
      return s(!1);
    t.forceRotate(a);
  } else Dt(e) && t.forceRotate(e);
  if (a && t.rot !== a)
    return s(!1);
  const l = r(!1, "l"), h = r(!1, "w"), u = r(!0, "l"), d = r(!0, "w");
  return Dt(e) || o ? s(l && h) : s(l && h || u && d);
}
function oc(n, t, e = "decimal", i = !1) {
  return Dt(n == null ? void 0 : n[t]) ? re(n[t], e, !1, i) : null;
}
class m1 {
  constructor(t, e = !1) {
    tt(this, "readonly");
    tt(this, "id");
    tt(this, "listId");
    tt(this, "units", "decimal");
    tt(this, "l");
    tt(this, "w");
    tt(this, "t");
    tt(this, "q");
    tt(this, "name");
    tt(this, "material");
    tt(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    tt(this, "cost", null);
    tt(this, "grain", "");
    tt(this, "selected", !1);
    //used for multiple editing
    tt(this, "multiEdit", !1);
    //is this the multi-select stock
    tt(this, "type", null);
    tt(this, "autoAdd", !1);
    tt(this, "used");
    tt(this, "saw");
    tt(this, "preventGrainRotation");
    tt(this, "allowExactFitShapes");
    tt(this, "issues", []);
    tt(this, "warnings", []);
    tt(this, "notes", "");
    var s, o;
    t = No(t), Dt(t.units) || console.warn("Attempting to create InputStock without units"), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((a) => {
      this[a] = oc(t, a, this.units, e);
    }), this.q = Dt(t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.autoAdd = Dt(t.autoAdd) ? t.autoAdd : !1, this.name = Dt(t.name) ? $l(t.name).toUpperCase() : "", this.material = Dt(t.material) ? t.material.trim().toUpperCase() : "";
    const r = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }, r.forEach((a) => {
      this.trim[a] = oc(t.trim, a, this.units, e);
    }), this.cost = Dt(t.cost) ? t.cost : null, t.grain = (s = t == null ? void 0 : t.grain) == null ? void 0 : s.toLowerCase(), (t == null ? void 0 : t.grain) === " " && (t.grain = ""), this.grain = t.grain, this.multiEdit = t.multiEdit, this.type = t.type, this.allowExactFitShapes = Dt(t == null ? void 0 : t.allowExactFitShapes) ? t.allowExactFitShapes : !1, this.preventGrainRotation = !0, this.notes = t != null && t.notes ? (o = t.notes) == null ? void 0 : o.replace(/,/g, "") : "";
  }
  //change the units of the stock
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? re(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = Dt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  //change the type of stock
  changeType(t) {
    switch (t !== "sheet" && (this.grain = ""), t) {
      case "linear":
        this.trim.y1 = 0, this.trim.y2 = 0;
        break;
      case "roll":
        this.trim.x1 = 0, this.trim.x2 = 0, this.trim.y1 = 0, this.trim.y2 = 0, this.t = null;
        break;
    }
  }
  //create an id from an index
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  isSquare() {
    return this.l === this.w;
  }
  getWarnings() {
    this.warnings = [], ["q"].forEach((t) => this.warnings.push(...ai[t](this[t])));
  }
  validate() {
    return this.issues = [], ["l", "w", "t"].forEach((t) => this.issues.push(...ai[t](this[t]))), this.issues.push(...ai.trim(this)), this.getWarnings(), this.issues;
  }
}
class vd {
  constructor(t, e = !1) {
    tt(this, "readonly");
    tt(this, "id");
    tt(this, "listId");
    tt(this, "units", "decimal");
    tt(this, "l");
    tt(this, "w");
    tt(this, "t");
    tt(this, "q", 1);
    tt(this, "name", "");
    tt(this, "material", "");
    tt(this, "cost");
    tt(this, "orientationLock");
    tt(this, "selectedMaterial");
    tt(this, "selected", !1);
    //used for multiple editing
    tt(this, "multiEdit", !1);
    tt(this, "issues", []);
    tt(this, "warnings", []);
    tt(this, "notes", "");
    tt(this, "stockLock");
    tt(this, "stockMatch");
    tt(this, "customData");
    //objects
    tt(this, "machining");
    tt(this, "trim", Object.fromEntries(
      pr.map((t) => [t, 0])
    ));
    tt(this, "banding", Object.fromEntries(
      Os.map((t) => [t, !1])
    ));
    tt(this, "bandingOptions", Object.fromEntries([
      ...Os,
      "all"
    ].map((t) => [t, {}])));
    tt(this, "finish", Object.fromEntries(
      fr.map((t) => [t, ""])
    ));
    tt(this, "finishOptions", Object.fromEntries(
      fr.map((t) => [t, {}])
    ));
    var r, s, o, a, l;
    t = t = No(t), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((h) => {
      this[h] = oc(t, h, this.units, e);
    }), this.q = Dt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.name = Dt(t.name) ? $l(t.name).toUpperCase() : "", this.material = Dt(t.material) ? t.material.trim().toUpperCase() : "", this.multiEdit = t.multiEdit, this.notes = t != null && t.notes ? (r = t.notes) == null ? void 0 : r.replace(/,/g, "") : "", this.stockLock = (t == null ? void 0 : t.stockLock) ?? [];
    for (const h of Object.keys(this.trim))
      this.trim[h] = oc(t.trim, h, this.units, e);
    for (const h of Object.keys(this.banding))
      this.banding[h] = Dt((s = t == null ? void 0 : t.banding) == null ? void 0 : s[h]) ? t.banding[h] : !1;
    for (const h of Object.keys(this.bandingOptions))
      this.bandingOptions[h] = Dt((o = t == null ? void 0 : t.bandingOptions) == null ? void 0 : o[h]) ? t.bandingOptions[h] : {};
    for (const h of Object.keys(this.finish))
      this.finish[h] = Dt((a = t == null ? void 0 : t.finish) == null ? void 0 : a[h]) ? t.finish[h] : "";
    for (const h of Object.keys(this.finishOptions))
      this.finishOptions[h] = Dt((l = t == null ? void 0 : t.finishOptions) == null ? void 0 : l[h]) ? t.finishOptions[h] : {};
    this.orientationLock = Dt(t.orientationLock) ? t.orientationLock.toLowerCase() : "", this.machining = new f1(t.machining ?? {
      holes: [],
      hingeHoles: [],
      corners: []
    }), this.customData = (t == null ? void 0 : t.customData) ?? {};
  }
  /**
   * change the units of the shape
   * @param {String} newUnits
   */
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? re(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = Dt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  isSquare() {
    return this.l === this.w;
  }
  /**
   * change the type of the stock
   * @param {String} newType
   */
  changeStockType(t) {
    switch (t) {
      case "sheet":
      case "roll":
        this.orientationLock = "", t === "roll" && (this.t = null);
        break;
      case "linear":
        this.orientationLock = "", this.banding = Object.fromEntries(
          Os.map((e) => [e, !1])
        );
        break;
    }
  }
  /**
   * create an id from an index
   * @param {Integer} index
   * @param {Integer} secondaryIndex
   */
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  getLongSide() {
    return re(this.l) > re(this.w) ? re(this.l) : re(this.w);
  }
  getShortSide() {
    return re(this.l) < re(this.w) ? re(this.l) : re(this.w);
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      name: this.name,
      listId: this.listId,
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      name: this.name,
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: re(this.l), w: re(this.w) };
    return t && (e = this.getRotatedDimensions()), {
      name: this.name,
      listId: this.listId,
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2),
      orientationLock: this.orientationLock
    };
  }
  //used to apply a single trim value to all sides
  applyPartTrim(t, e) {
    if (!this.readonly)
      if (t = re(t), this.trim) {
        for (const i in this.trim)
          this.trim[i] = t;
        e === "linear" && (this.trim.y1 = 0, this.trim.y2 = 0);
      } else
        this.trim = {
          x1: t,
          x2: t,
          y1: e !== "linear" ? t : 0,
          y2: e !== "linear" ? t : 0
        };
  }
  /**
   * to align with Shape
   * @remarks input shapes are always 0
   */
  get rot() {
    return 0;
  }
  validate(t, e, i, r = 0, s = !1) {
    return this.issues = [], ["l", "w", "t"].forEach((o) => {
      const a = ai[o](this[o], e);
      a.length && this.issues.push(...a);
    }), r = re(r), this.issues.push(...ai.partTrim(this, r, e)), this.issues.push(...ai.trim(this, e)), ai.machining(this, e), this.getWarnings(t, e, i, r, s), this.issues;
  }
  getWarnings(t, e = null, i, r = 0, s = !1) {
    this.warnings = [], ["q"].forEach((o) => {
      this.warnings.push(...ai[o](this[o], e));
    }), t.length && !s && this.warnings.push(...ai.stockMatch(this, t, i, r, e));
  }
}
class zl {
  constructor(t) {
    tt(this, "id");
    tt(this, "parentID");
    tt(this, "name");
    tt(this, "x");
    tt(this, "y");
    tt(this, "l");
    tt(this, "w");
    tt(this, "t");
    tt(this, "q");
    tt(this, "material");
    tt(this, "grain");
    tt(this, "orientationLock");
    tt(this, "duplicate");
    tt(this, "trimmed");
    tt(this, "preventAutoRotation");
    tt(this, "preventGrainRotation");
    tt(this, "units");
    tt(this, "issues", []);
    tt(this, "stock");
    tt(this, "stockId");
    //used when object is compressed
    tt(this, "cost");
    tt(this, "offcut");
    tt(this, "notes");
    //for user notes
    tt(this, "proximity");
    //objects
    tt(this, "_trim", Object.fromEntries(
      pr.map((t) => [t, 0])
    ));
    tt(this, "customData");
    this.initRectangle(t);
  }
  validateRectangle(t) {
    Pr(this) || ["x", "y", "l", "w", "t"].forEach((e) => {
      this.createIssues(ai[e](t[e]));
    }), ts(this) && "q" in t && this.createIssues(ai.q((t == null ? void 0 : t.q) ?? 0, t.autoAdd)), "q" in t && this.isShape() && !this.isGroup() && !this.isUserGroup() && this.createIssues(ai.q((t == null ? void 0 : t.q) ?? 0)), "customData" in t && this.createIssues(ai.customData((t == null ? void 0 : t.customData) ?? {}));
  }
  initRectangle(t, e = !1) {
    var r, s, o;
    if (!e) {
      if (this.validateRectangle(t), this.issues.length) return;
      this.id = Dt(t.id) ? t.id.toString() : this.id || null, this.setParentID(), Dt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? this.q = parseInt(t.q) : this.q = t.q : this.q = 0, this.name = Dt(t.name) && ((r = t == null ? void 0 : t.name) != null && r.length) ? (s = b1($l(t == null ? void 0 : t.name))) == null ? void 0 : s.toUpperCase() : null, Dt(t == null ? void 0 : t.cost) ? typeof t.cost == "string" ? this.cost = parseFloat(t.cost) : typeof t.cost == "number" && (this.cost = t.cost) : this.cost = 0, this.material = Dt(t.material) ? t.material.trim().toLowerCase() : null, this.duplicate = Dt(t == null ? void 0 : t.duplicate) ? t.duplicate : !1, this.grain = typeof t.grain < "u" && Dt(t == null ? void 0 : t.grain) ? t.grain.toLowerCase() : null, this.trimmed = Dt(t == null ? void 0 : t.trimmed) ? t.trimmed : !1, this.offcut = Dt(t == null ? void 0 : t.offcut) ? t.offcut : !1, this.notes = typeof (t == null ? void 0 : t.notes) == "string" && t.notes.length ? t.notes.replace(/,/g, "").substring(0, 200) : "", this.customData = (t == null ? void 0 : t.customData) ?? {}, this.proximity = {
        rectangle: null,
        distance: null
      };
      try {
        this.trim = t == null ? void 0 : t.trim;
      } catch (a) {
        if ((o = a == null ? void 0 : a.cause) != null && o.issues) this.issues.push(...a.cause.issues);
        else throw new Error("error when attempting to set trim");
      }
    }
    [
      {
        key: "x",
        default: 0,
        required: !1
      },
      {
        key: "y",
        default: 0,
        required: !1
      },
      {
        key: "l",
        default: null,
        required: !0
      },
      {
        key: "w",
        default: 1,
        //for linear
        required: !0
      },
      {
        key: "t",
        default: null,
        required: !1
      }
    ].forEach((a) => {
      let l = t[a.key];
      if (!Dt(l))
        return this[a.key] = this[a.key] || a.default;
      typeof l == "string" && (l = re(l)), this[a.key] = l;
    }), !(t != null && t.preventAutoRotation) && !t.trimmed && this.w > this.l && ([this.l, this.w] = [this.w, this.l], this.grain && !(t != null && t.preventGrainRotation) && (this.grain = ko(this.grain))), Dt(t == null ? void 0 : t.stock) && (ts(t.stock) ? this.stock = t.stock : this.stock = new es(t.stock), this.stockId = this.stock.id);
  }
  updateRectangle(t) {
    t.preventAutoRotation = !0, this.initRectangle(t, !0);
  }
  set trim(t) {
    if (this._trim = Object.fromEntries(
      pr.map((e) => [e, 0])
    ), !!Co(t, !0))
      for (const e of pr) {
        let i;
        if (typeof t[e] == "string") {
          const r = re(t[e]);
          isNaN(r) || r < 0 ? (this.issues.push(
            this.createIssue(
              `${t[e] ?? "N/A"} is not a valid value for trim: ${e}`
            )
          ), i = 0) : i = r;
        } else
          i = t[e];
        this._trim[e] = i;
      }
  }
  get trim() {
    return this._trim;
  }
  get rot() {
    return this.w > this.l ? 1 : 0;
  }
  setParentID() {
    this.parentID = this.getParentID();
  }
  getParentID() {
    return this.id ? this.parentID ? this.parentID : typeof this.id != "number" && this.id.includes(".") ? this.id.split(".")[0] : typeof this.id != "number" && !this.id.includes(".") ? null : this != null && this.id ? this.id.toString() : null : null;
  }
  getCopyNumber() {
    return typeof this.id != "number" && this.id.includes(".") ? parseInt(this.id.split(".")[1]) : 0;
  }
  createIssues(t) {
    t != null && t.length && t.forEach((e) => {
      this.issues.push(this.createIssue(e.message, e.field));
    });
  }
  createIssue(t, e = null) {
    var o;
    let i = "";
    const r = this.getClass();
    switch (r) {
      case "Shape":
        i = "part";
        break;
      case "Stock":
        i = "stock";
        break;
      default:
        i = r.toLowerCase();
        break;
    }
    const s = (o = this == null ? void 0 : this.name) != null && o.length ? this.name.toUpperCase() : this.parentID;
    return s ? {
      message: `${t} [${i.charAt(0).toUpperCase() + i.slice(1)} ${s}]`,
      field: e
    } : { message: t, field: e };
  }
  dimensions() {
    return {
      id: this.id,
      l: this.l,
      w: this.w,
      t: this.t
    };
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  coords() {
    return {
      id: this.id,
      x: this.x,
      y: this.y
    };
  }
  hasCoords(t, e) {
    return this.x === t && this.y === e;
  }
  getAspect() {
    return this.l > this.w ? this.w / this.l : this.l / this.w;
  }
  getPerimeter() {
    return this.w * 2 + this.l * 2;
  }
  getLongSide() {
    return this.l > this.w ? this.l : this.w;
  }
  getShortSide() {
    return this.l < this.w ? this.l : this.w;
  }
  getSides() {
    return [
      this.getSide("bottom"),
      this.getSide("right"),
      this.getSide("top"),
      this.getSide("left")
    ];
  }
  getSide(t) {
    switch (t) {
      case "bottom":
        return new pa({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y,
          type: "bottom"
          // parentID: this.id
        });
      case "right":
        return new pa({
          x1: this.x + this.l,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y + this.w,
          type: "right"
          // parentID: this.id
        });
      case "top":
        return new pa({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y + this.w,
          y2: this.y + this.w,
          type: "top"
          // parentID: this.id
        });
      case "left":
        return new pa({
          x1: this.x,
          x2: this.x,
          y1: this.y,
          y2: this.y + this.w,
          type: "left"
          // parentID: this.id
        });
    }
  }
  getTopPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y + this.w + ((this.stock.getBladeWidth() || e) ?? 0) : this.y + this.w;
  }
  getRightPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x + this.l + ((this.stock.getBladeWidth() || e) ?? 0) : this.x + this.l;
  }
  getBottomPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y - ((this.stock.getBladeWidth() || e) ?? 0) : this.y;
  }
  getLeftPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x - ((this.stock.getBladeWidth() || e) ?? 0) : this.x;
  }
  sharesSide(t, e = 0, i = null) {
    switch (i) {
      case "left":
        return t.x + t.l + e === this.x;
      case "right":
        return t.x === this.x + this.l + e;
      case "bottom":
        return t.y + t.w + e === this.y;
      case "top":
        return t.y === this.y + this.w + e;
    }
    return !1;
  }
  sameSide(t, e = null) {
    switch (e) {
      case "left":
        return t.x === this.x;
      case "right":
        return t.x + t.l === this.x + this.l;
      case "bottom":
        return t.y === this.y;
      case "top":
        return t.y + t.w === this.y + this.w;
    }
    return !1;
  }
  //considers if the shape can rotate
  getLongestDimension(t) {
    return this.orientationLock ? this[t] : this.getLongSide();
  }
  getArea() {
    return this.w * this.l;
  }
  getCoords(t, e = !1) {
    const i = new Hn(this.x + this.l, this.y);
    i.corner = "bottomRight";
    const r = new Hn(this.x, this.y + this.w);
    if (r.corner = "topLeft", (t == null ? void 0 : t.cutType) !== "efficiency" && !e)
      return [r, i];
    const s = new Hn(this.x, this.y);
    s.corner = "bottomLeft";
    const o = new Hn(this.x + this.l, this.y + this.w);
    return o.corner = "topRight", [s, r, o, i];
  }
  getCorners() {
    return {
      bottomLeft: new Hn(this.x, this.y),
      topLeft: new Hn(this.x, this.y + this.w),
      topRight: new Hn(this.x + this.l, this.y + this.w),
      bottomRight: new Hn(this.x + this.l, this.y)
    };
  }
  round() {
    return {
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  getClass() {
    return this.constructor.name;
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: this.l, w: this.w };
    return t && (e = this.getRotatedDimensions()), this.trimmed ? e : {
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2)
    };
  }
  //trim the rectangle
  trimDimensions() {
    var t, e, i, r;
    return this.trimmed ? !1 : (this.trim && Object.values(this.trim).filter((s) => !isNaN(parseFloat(String(s)))).length && (Dt(this.l) && (this.l -= ((t = this == null ? void 0 : this.trim) != null && t.x1 ? this.trim.x1 : 0) + ((e = this == null ? void 0 : this.trim) != null && e.x2 ? this.trim.x2 : 0), this.l <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative length")))), Dt(this.w) && (this.w -= ((i = this == null ? void 0 : this.trim) != null && i.y1 ? this.trim.y1 : 0) + ((r = this == null ? void 0 : this.trim) != null && r.y2 ? this.trim.y2 : 0), this.w <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative width"))))), this.trimmed = !0, !0);
  }
  /**
   * change the size of the rectangle back to the original size
   */
  removeTrim() {
    var t, e, i, r;
    if (this.trimmed) {
      if (this.l += (typeof ((t = this == null ? void 0 : this.trim) == null ? void 0 : t.x1) == "number" ? this.trim.x1 : 0) + (typeof ((e = this == null ? void 0 : this.trim) == null ? void 0 : e.x2) == "number" ? this.trim.x2 : 0), this.w += (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.y1) == "number" ? this.trim.y1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.y2) == "number" ? this.trim.y2 : 0), this.l <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative length`);
      if (this.w <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative width`);
      this.trimmed = !1;
    }
  }
  getUntrimmedDimensions() {
    var i, r, s, o;
    if (!this.trimmed) return { l: this.l, w: this.w };
    const t = this.getLongSide(), e = this.getShortSide();
    return {
      l: t + (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.x1) == "number" ? this.trim.x1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.x2) == "number" ? this.trim.x2 : 0),
      w: e + (typeof ((s = this == null ? void 0 : this.trim) == null ? void 0 : s.y1) == "number" ? this.trim.y1 : 0) + (typeof ((o = this == null ? void 0 : this.trim) == null ? void 0 : o.y2) == "number" ? this.trim.y2 : 0)
    };
  }
  isIdentical(t, e = !1) {
    if (this.constructor !== t.constructor || this.t !== t.t || this.orientationLock !== t.orientationLock)
      return !1;
    if (Pr(this)) {
      if (t.id === this.id) return !0;
    } else {
      if (t.parentID === this.parentID) return !0;
      if (gr(this) && e && this.parentID !== t.parentID) return !1;
    }
    const { w: i, l: r } = this, { w: s, l: o } = t;
    if (!(i === s && r === o) && !(i === o && r === s))
      return !1;
    const a = this.trim, l = t.trim;
    return !a || !l ? a === l : a.x1 === l.x1 && a.x2 === l.x2 && a.y1 === l.y1 && a.y2 === l.y2;
  }
  /**
   * is this rectangle a square
   */
  isSquare() {
    return this.l === this.w;
  }
  getDistancesToContainerEdges(t) {
    return [
      this.x - t.x,
      t.l - (this.x + this.l),
      t.w - (this.y + this.w),
      this.y - t.y
    ];
  }
  isInsideStock(t) {
    return !(this.x + this.l > t.l || this.y + this.w > t.w || this.x < 0 || this.y < 0);
  }
  /**
  * Creates or retrieves a cached rectangle used for proximity detection.
  * Optimized for frequent calls with the same distance parameter.
  */
  getProximityRectangle(t) {
    if (!t || t < 0) return null;
    const e = this.proximity;
    if ((e == null ? void 0 : e.distance) === t) {
      const r = e.rectangle;
      return this.x === 0 ? (r.x = 0, r.l = this.l + t) : (r.x = this.x - t, r.l = this.l + t * 2), this.y === 0 ? (r.y = 0, r.w = this.w + t) : (r.y = this.y - t, r.w = this.w + t * 2), r;
    }
    const i = new zl({
      id: `${this.id}-proximity`,
      name: "proximity",
      x: this.x === 0 ? 0 : this.x - t,
      y: this.y === 0 ? 0 : this.y - t,
      l: this.x === 0 ? this.l + t : this.l + t * 2,
      w: this.y === 0 ? this.w + t : this.w + t * 2,
      preventAutoRotation: !0
    });
    return this.proximity = { rectangle: i, distance: t }, i;
  }
  isShape() {
    return gr(this);
  }
  isSegment() {
    return Kb(this);
  }
  isStock() {
    return ts(this);
  }
  isGroup() {
    return Pr(this);
  }
  isUserGroup() {
    return xd(this);
  }
}
class wd extends zl {
  constructor(e) {
    super(e);
    tt(this, "type");
    tt(this, "saw");
    tt(this, "algoBenchmark");
    //used by evo
    tt(this, "shapes", []);
    switch (this.shapes = e.shapes, ["sheet", "linear", "roll", null, void 0, ""].includes(e.type) ? this.type = e.type : this.issues.push({ message: `Container type ${e.type ?? "N/A"} is not valid` }), this.type || (this.type = "sheet"), this.setSaw(e), this.cutType) {
      case "beam":
        (!Dt(this.t) || this.t <= 0) && this.issues.push(this.createIssue("Stock for beam saws must have a thickness set"));
        break;
    }
  }
  setSaw(e) {
    var i, r, s, o;
    if (Dt(e) || (this.saw = new js(null)), Dt(e == null ? void 0 : e.saw)) {
      if (!((r = e == null ? void 0 : e.saw) != null && r.cutType)) {
        const { cutType: a, cutPreference: l } = nf(e.saw.cutPreference);
        e.saw.cutType = a, e.saw.cutPreference = l;
      }
    } else {
      e.saw = {};
      const { cutType: a, cutPreference: l } = nf(e.cutPreference);
      e.saw.cutType = a, e.saw.cutPreference = l, Dt(e == null ? void 0 : e.bladeWidth) && (e.saw.bladeWidth = e.bladeWidth), Dt((i = e == null ? void 0 : e.blade) == null ? void 0 : i.width) && (e.saw.bladeWidth = e.blade.width), Dt(e == null ? void 0 : e.efficiencyOptions) && (e.saw.efficiencyOptions = e.efficiencyOptions), Dt(e == null ? void 0 : e.guillotineOptions) && (e.saw.guillotineOptions = e.guillotineOptions), Dt(e == null ? void 0 : e.stackHeight) && (e.saw.stackHeight = e.stackHeight);
    }
    try {
      Dt(e == null ? void 0 : e.saw) && (Xb(e.saw) ? this.saw = e.saw : this.saw = new js(e.saw, this.type)), (o = (s = this.saw) == null ? void 0 : s.issues) != null && o.length && this.issues.push(...this.saw.issues);
    } catch (a) {
      throw new Error("error creating saw", { cause: a });
    }
  }
  get cutType() {
    var e, i, r, s;
    return Dt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.cutType) ? this.saw.cutType : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutType) ?? null;
  }
  get cutPreference() {
    var e, i, r, s;
    return Dt((e = this.saw) == null ? void 0 : e.cutPreference) ? this.saw.cutPreference : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutPreference) ?? null;
  }
  get guillotineOptions() {
    var e, i, r, s;
    return Dt((e = this.saw) == null ? void 0 : e.guillotineOptions) ? this.saw.guillotineOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.guillotineOptions) ?? null;
  }
  get efficiencyOptions() {
    var e, i, r, s;
    return Dt((e = this.saw) == null ? void 0 : e.efficiencyOptions) ? this.saw.efficiencyOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.efficiencyOptions) ?? null;
  }
  get primaryCompression() {
    var e, i;
    if (this.cutType === "efficiency")
      return (i = (e = this.saw) == null ? void 0 : e.efficiencyOptions) != null && i.primaryCompression ? this.efficiencyOptions.primaryCompression : "y";
  }
  getHalfBladeWidth() {
    const e = this.getBladeWidth();
    return e ? e / 2 : 0;
  }
  getBladeWidth() {
    var i, r, s;
    const e = (((i = this == null ? void 0 : this.saw) == null ? void 0 : i.bladeWidth) || ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.bladeWidth)) ?? 0;
    return isNaN(e) ? 0 : e;
  }
  getStock() {
    return ts(this) ? this : this != null && this.stock ? this.stock : null;
  }
}
class js {
  constructor(t, e = "sheet") {
    tt(this, "issues");
    tt(this, "bladeWidth");
    tt(this, "cutType");
    tt(this, "cutPreference");
    tt(this, "guillotineOptions");
    tt(this, "efficiencyOptions");
    tt(this, "stackHeight");
    tt(this, "stockType");
    tt(this, "options");
    switch (t = No(t), this.options = yl({}, t == null ? void 0 : t.options, {
      stockSelection: "efficiency",
      stackingMode: "dimensions",
      minSpacing: 0,
      minSpacingDimension: {}
    }), this.stackHeight = (t == null ? void 0 : t.stackHeight) ?? null, this.stockType = (t == null ? void 0 : t.stockType) ?? e, this.issues = [], ["sheet", "linear", "roll"].includes(this.stockType) || this.issues.push({ message: `Saw stock type: ${this.stockType} not valid` }), this.stockType || (this.stockType = "sheet"), this.cutType = t == null ? void 0 : t.cutType, this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "roll":
        ["efficiency", "guillotine", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "linear":
        break;
      default:
        ["none", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
    }
    switch (this.cutPreference = t == null ? void 0 : t.cutPreference, this.cutType) {
      case "guillotine":
        ["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.cutType === "guillotine" && this.cutPreference === "l" && this.stockType === "roll" && this.issues.push({ message: `Cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"} and stock type: ${this.stockType}` }), this.options.minSpacing = 0;
        break;
      case "beam":
        ["l", null, void 0].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.options.minSpacing = 0;
        break;
    }
    switch (Dt(t == null ? void 0 : t.bladeWidth) ? typeof t.bladeWidth == "string" ? this.bladeWidth = re(t.bladeWidth) : this.bladeWidth = t.bladeWidth : this.bladeWidth = 0, (isNaN(this.bladeWidth) || this.bladeWidth < 0) && (this.issues.push({ message: `Blade width: ${this.bladeWidth ?? "N/A"} is not valid` }), this.bladeWidth = 0), this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Invalid cut type: ${this.cutType} for stock type: ${e}, cut preference: ${this.cutPreference}` }), this.cutType === "guillotine" && (["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Invalid cut preference: ${this.cutPreference} for stock type: ${e}, cut type: ${this.cutType}` })), this.cutType === "beam" && [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" }), this.cutType === "beam" && (this.cutPreference = "l"), this.cutType || (this.cutType = "efficiency");
        break;
      case "linear":
        this.cutType = null, this.cutPreference = null;
        break;
    }
    switch (this.cutType) {
      case "efficiency":
        this.efficiencyOptions = yl({}, t == null ? void 0 : t.efficiencyOptions, { primaryCompression: "y" });
        break;
      case "guillotine":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        break;
      case "beam":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null }), this.cutPreference = "l", [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" });
        break;
    }
  }
  clone() {
    const t = structuredClone(this);
    return new js(t);
  }
}
class es extends wd {
  constructor(e) {
    e = No(e), e.preventAutoRotation = (e == null ? void 0 : e.type) === "roll", e.autoAdd && !e.q && (e.q = 1);
    super(e);
    tt(this, "_id");
    //used for mongo
    tt(this, "autoAdd");
    tt(this, "allowExactFitShapes");
    tt(this, "analysis");
    tt(this, "tidy");
    tt(this, "used");
    tt(this, "stack");
    tt(this, "winningStrategy");
    //used for reporting
    tt(this, "unusable");
    //used by stock matching
    tt(this, "duplicatePattern");
    tt(this, "score");
    tt(this, "rootSegment");
    delete this.stock, this._id = e == null ? void 0 : e._id, this.autoAdd = Dt(e == null ? void 0 : e.autoAdd) ? e.autoAdd : !1, this.allowExactFitShapes = Dt(e == null ? void 0 : e.allowExactFitShapes) ? e.allowExactFitShapes : !1, this.analysis = Dt(e.analysis) ? e.analysis : null, this.tidy = Dt(e == null ? void 0 : e.tidy) ? e.tidy : !1, this.algoBenchmark = null, this.used = Dt(e == null ? void 0 : e.used) ? e.used : !1, this.stack = Dt(e == null ? void 0 : e.stack) ? e.stack : !1, this.duplicatePattern = (e == null ? void 0 : e.duplicatePattern) ?? null, this.initStock(e);
  }
  initStock(e) {
    switch (this.type) {
      case "linear":
      case "roll":
        this.trim.y1 = 0, this.trim.y2 = 0, this.grain = null;
        break;
    }
    this.validateStock(e), this.issues.length;
  }
  reset() {
    this.used = !1, this.stack = null, this.score = null, this.rootSegment = null, this.tidy = null, this.analysis = null, this.duplicatePattern = null, this.shapes = [];
  }
  validateStock(e) {
    ["grain"].forEach((i) => {
      this.createIssues(ai[i](e[i]));
    }), this.createIssues(ai.trim(this));
  }
  /**
   * compress for saving / transfer
   */
  save() {
    delete this.tidy, delete this.score, delete this.rootSegment, delete this.shapes, delete this.saw, this == null || delete this.algoBenchmark, this.stack = ts(this.stack) ? this.stack.id : this.stack, !this.trim.x1 && !this.trim.x2 && !this.trim.y1 && !this.trim.y2 && (this.trim = null);
  }
  resetStrategies() {
    this.algoBenchmark = null;
  }
  isIdentical(e) {
    let i = !1, r = !1, s = !1, o = !1;
    if (this.material === e.material && (i = !0), this.t === e.t && (r = !0), this.l === e.l && (s = !0), this.w === e.w && (o = !0), i && r && s && o) return !0;
  }
  hasStack() {
    return typeof this.stack == "number";
  }
  isStacked() {
    return ts(this.stack) || typeof this.stack == "string";
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = parseInt(i.pop()), e++), i.push(e.toString());
    const r = i.join("."), s = structuredClone(this);
    return s.id = r, s.used = !1, s.duplicate = !0, s.stack = !1, s.saw = this.saw, new es(s);
  }
}
class $b extends zl {
  constructor(e) {
    super(e);
    tt(this, "addToInventory");
    //for front end selection
    tt(this, "added");
    //for adding to inputStock
    tt(this, "placementOrder");
    tt(this, "flex");
    this.cost = this.getCost(), this.addToInventory = (e == null ? void 0 : e.addToInventory) ?? !0, this.added = !1, this.placementOrder = (e == null ? void 0 : e.placementOrder) ?? null, this.offcut = !0;
  }
  compressForSaving() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) || ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this._trim, delete this.trimmed;
  }
  getCost() {
    var e;
    return (e = this.stock) != null && e.isStock() && this.stock ? parseFloat((this.getArea() / this.stock.getArea() * this.stock.cost).toFixed(2)) : 0;
  }
}
function Ub({
  offcuts: n,
  stockList: t,
  preventAutoRotation: e = !0
}) {
  return !n || !(n != null && n.length) ? [] : n.map((i) => {
    const r = t.find((o) => {
      var a;
      return o.id === (((a = i == null ? void 0 : i.stock) == null ? void 0 : a.id) ?? (i == null ? void 0 : i.stockId));
    });
    return i.stock = r, e && (i.preventAutoRotation = !0), new $b(i);
  });
}
class ns extends zl {
  constructor(e) {
    e = No(e);
    super(e);
    tt(this, "added");
    tt(this, "guillotineData");
    tt(this, "stockLock");
    tt(this, "score");
    tt(this, "bestScore");
    tt(this, "placementOrder");
    //groups
    tt(this, "groupPlacementOrder");
    tt(this, "group");
    tt(this, "groupID");
    tt(this, "inGroup");
    //is the shape currently part of at least one group
    tt(this, "inUserGroup");
    //is the shape currently part of a user group`
    tt(this, "addedAsGroup");
    tt(this, "isFirstShape");
    tt(this, "firstShapeSampleRotations", []);
    //used for setting the rotation of the first shape (guillotine)
    tt(this, "index");
    //used for ptx
    tt(this, "patternMatch");
    //used for stack detection
    tt(this, "stockMatch");
    tt(this, "minSpacing");
    tt(this, "priority");
    tt(this, "weighting", {});
    //objects
    tt(this, "machining");
    tt(this, "_banding", Object.fromEntries(
      Os.map((e) => [e, !1])
    ));
    tt(this, "_finish", Object.fromEntries(
      fr.map((e) => [e, ""])
    ));
    this.initShape(e);
  }
  initShape(e, i = !1) {
    var r;
    if (!i) {
      if (this.validateShape(e), this.issues.length) throw new Error(this.issues.map((s) => s.message).join(`
`));
      e.orientationLock = (r = e == null ? void 0 : e.orientationLock) == null ? void 0 : r.toLowerCase(), (e == null ? void 0 : e.orientationLock) === " " && (e.orientationLock = ""), this.orientationLock = Dt(e == null ? void 0 : e.orientationLock) && this.l !== this.w ? e.orientationLock : null, Dt(e == null ? void 0 : e.stockLock) ? Array.isArray(e == null ? void 0 : e.stockLock) && (this.stockLock = e.stockLock.map((s) => s.toString())) : this.stockLock = [], this.banding = e == null ? void 0 : e.banding, this.finish = e == null ? void 0 : e.finish, this.machining = Dt(e == null ? void 0 : e.machining) ? new f1(e.machining) : null;
    }
    this.added = Dt(e == null ? void 0 : e.added) ? e.added : !1, this.initGuillotineData(e), this.inGroup = Dt(e == null ? void 0 : e.inGroup) ? e.inGroup : this.inGroup || !1, this.inUserGroup = Dt(e == null ? void 0 : e.inUserGroup) ? e.inUserGroup : this.inUserGroup || !1, this.groupID = Dt(e == null ? void 0 : e.groupID) ? e.groupID : this.groupID || null, this.addedAsGroup = Dt(e == null ? void 0 : e.addedAsGroup) ? e.addedAsGroup : this.addedAsGroup || !1, this.score = Dt(e == null ? void 0 : e.score) ? e.score : this.score || null, this.bestScore = Dt(e == null ? void 0 : e.bestScore) ? e.bestScore : this.bestScore || {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    }, this.placementOrder = Dt(e == null ? void 0 : e.placementOrder) ? e.placementOrder : this.placementOrder || null, this.groupPlacementOrder = Dt(e == null ? void 0 : e.groupPlacementOrder) ? e.groupPlacementOrder : this.groupPlacementOrder || null, this.minSpacing = (e == null ? void 0 : e.minSpacing) ?? (this.minSpacing || 0), this.priority = (e == null ? void 0 : e.priority) ?? {};
  }
  initGuillotineData(e) {
    var i, r, s, o, a, l, h, u;
    this.guillotineData = yl({}, e == null ? void 0 : e.guillotineData, {
      firstShape: ((i = this == null ? void 0 : this.guillotineData) == null ? void 0 : i.firstShape) || null,
      myPhase: ((r = this == null ? void 0 : this.guillotineData) == null ? void 0 : r.myPhase) || null,
      myStripParent: ((s = this == null ? void 0 : this.guillotineData) == null ? void 0 : s.myStripParent) || null,
      myStripDirection: ((o = this == null ? void 0 : this.guillotineData) == null ? void 0 : o.myStripDirection) || null,
      stripShapeBatches: {
        subsetUsed: ((l = (a = this == null ? void 0 : this.guillotineData) == null ? void 0 : a.stripShapeBatches) == null ? void 0 : l.subsetUsed) || !1,
        groups: ((u = (h = this == null ? void 0 : this.guillotineData) == null ? void 0 : h.stripShapeBatches) == null ? void 0 : u.groups) || {}
      }
    });
  }
  cloneGuillotineData() {
    var e;
    return (e = this.guillotineData) != null && e.myStripParent && (gr(this.guillotineData.myStripParent) || Pr(this.guillotineData.myStripParent)) && (this.guillotineData.myStripParent = this.guillotineData.myStripParent.compress()), structuredClone(this.guillotineData);
  }
  getCopyNumber() {
    return parseInt(this.id.split(".").pop());
  }
  getMinSpacing(e, i = !1) {
    var o, a;
    if (!e) return 0;
    let r = (this == null ? void 0 : this.minSpacing) || ((a = (o = e.saw) == null ? void 0 : o.options) == null ? void 0 : a.minSpacing) || 0;
    const s = e.getBladeWidth();
    return s > r && (r = s), i && (r -= s), r < 0 && (r = 0), r;
  }
  validateShape(e) {
    ["orientationLock", "banding"].forEach((i) => {
      this.createIssues(ai[i](e[i]));
    }), this.machining && this.machining.validateEverything(this);
  }
  //individual shape weighting
  /* calculateWeighting()
  	{
  		// const aspect = this.w / this.l;
  		if ( aspect > 0.5 )
  		{
  			//cater for small parts
  			const area = s.getArea();
  			const areaPercentage = area / maxArea;
  
  			if ( areaPercentage <= 0.1 )
  			{
  				s.weighting.edge = areaPercentage;
  			}
  		}
  		//the closer to zero, the higher the edge weighting
  		this.weighting.edge = 1 - aspect;
  		this.weighting.edge *= 2;
  	} */
  update(e) {
    e = No(e), this.initShape(e, !0), this.updateRectangle(e);
  }
  //banding
  set banding(e) {
    if (this._banding = Object.fromEntries(
      Os.map((i) => [i, !1])
    ), !!Co(e, !0))
      for (const i of Os)
        this._banding[i] = Dt(e == null ? void 0 : e[i]) ? e[i] : !1;
  }
  get banding() {
    return this._banding;
  }
  //get an array of banding in the order L1, L2, W1, W2
  get bandingArray() {
    return Rb(this._banding);
  }
  get finish() {
    return this._finish;
  }
  get FacesArray() {
    return fr.map((e) => {
      var i;
      return (i = this.finish) == null ? void 0 : i[e];
    });
  }
  set finish(e) {
    if (this._finish = Object.fromEntries(
      fr.map((i) => [i, ""])
    ), !!Co(e, !0))
      for (const i of fr)
        this._finish[i] = Dt(e == null ? void 0 : e[i]) ? e[i] : "";
  }
  //compress for saving / transfer
  save() {
    var e, i, r;
    delete this.group, (e = this == null ? void 0 : this.guillotineData) == null || delete e.stripShapeBatches, this.stockId = (i = this == null ? void 0 : this.stock) == null ? void 0 : i.id, delete this.stock, delete this.score, delete this.bestScore, Os.every((s) => {
      var o;
      return !((o = this._banding) != null && o[s]);
    }) && (this._banding = null), fr.every((s) => {
      var o;
      return !((o = this._finish) != null && o[s]);
    }) && (this._finish = null), Tb(this), (r = this.guillotineData) == null || delete r.myStripParent, delete this.score, delete this.inGroup, delete this.groupID, delete this.addedAsGroup, delete this.proximity;
  }
  isExactFit(e) {
    return this.orientationLock === "w" && this.w === e.w || this.orientationLock === "l" && this.l === e.l || !this.orientationLock && this.w === e.w && this.l === e.l;
  }
  addToStock(e) {
    this.stock = e, this.stockId = e.id, this.added = !0, this.inGroup = !1, e.used = !0, this.grain = e.grain, e != null && e.grain && this.rot && (this.grain = ko(e.grain)), H0([
      () => Rs(this.isInsideStock(e), `shape ${this.id} is not inside stock`).to.be.true
    ]);
  }
  removeFromStock() {
    this.placementOrder = null, this.stock = null, this.stockId = null, this.added = !1, this.addedAsGroup = !1, this == null || delete this.isFirstShape, Pr(this) && this.shapes.forEach((e) => e.removeFromStock());
  }
  setBestScore(e, i = null) {
    const r = {
      x: e.x,
      y: e.y,
      rot: e.rot,
      total: e.score.total,
      score: e.score,
      group: e.group,
      weighting: null,
      point: i
    };
    this.bestScore = r;
  }
  resetBestScore() {
    const e = {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.bestScore = e, this.resetGuillotineData(!0);
  }
  resetScore() {
    this.score = null, this.resetGuillotineData(!0);
  }
  resetBothScores() {
    this.resetBestScore(), this.resetScore();
  }
  resetPosition() {
    this.x = 0, this.y = 0, this.placementOrder = null, this.resetGuillotineData(!0);
  }
  resetGroupData() {
    this.inGroup = !1, this.group = null, this.groupID = null, this.groupPlacementOrder = null, this.grain = null;
  }
  resetGuillotineData(e = !1) {
    var r, s;
    const i = {
      firstShape: !1,
      myPhase: null,
      myStripDirection: null,
      stripShapeBatches: {
        subsetUsed: !1,
        groups: {}
      }
    };
    e && (i.stripShapeBatches.groups = (s = (r = this.guillotineData) == null ? void 0 : r.stripShapeBatches) == null ? void 0 : s.groups), this.guillotineData = i;
  }
  reset(e = !1, i = !0, r = !1) {
    this.removeFromStock(), this.resetPosition(), this.setRotation(0), this.placementOrder = null, this == null || delete this.isFirstShape, this.patternMatch = !1, e || this.resetBothScores(), r || this.resetGroupData(), this.resetGuillotineData(i);
  }
  round() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y),
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  //get an array of allowed rotations for this container
  getAllowedRotations(e) {
    const i = [];
    for (let r = 0; r <= 1; r++)
      this.canRotate(r, e) && this.willItFit(e, r) && i.push(r);
    return i;
  }
  /**
   * checks if a shape can rotate
   * checks for fit and grain
   * does not change the shape's rotation during the checks
   * @returns false if cannot rotate or can rotate but won't fit
   */
  canRotate(e = null, i = null) {
    if (!Dt(e))
      throw new Error("no rotation provided to canRotate");
    if (e === !0 && (e = 1), e === !1 && (e = 0), this.isSquare() && e || i && !this.willItFit(i, e))
      return !1;
    const r = this.getNecessaryOrientation(i);
    return !(r === "l" && e === 1 || r === "w" && e === 0);
  }
  /**
   * can a shape rotate to produce the specified dimensions on a specific side
   * @todo tests
   */
  canRotateToDimension(e, i, r = null) {
    if (!i) throw new Error("requiredSide not supplied to canRotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (r) {
      if (i === "l") {
        if (s === e && this.canRotate(0, r) || o === e && this.canRotate(1, r)) return !0;
      } else if (i === "w" && (o === e && this.canRotate(0, r) || s === e && this.canRotate(1, r)))
        return !0;
    } else if (this.orientationLock) {
      if (this.orientationLock === "l")
        return i === "l" && e === s;
      if (this.orientationLock === "w")
        return i === "l" && e === o;
    }
    return !1;
  }
  canRotateToDimensionRange(e, i, r, s = null) {
    if (!r) throw new Error("requiredSide not supplied to canRotateToDimensionRange");
    if (this.l >= e && this.l <= i || this.w >= e && this.w <= i) {
      if (this.l === this.w) return !0;
      const o = this.getLongSide(), a = this.getShortSide();
      if (s) {
        if (r === "l") {
          if (o >= e && o <= i && this.canRotate(0, s) || a >= e && a <= i && this.canRotate(1, s)) return !0;
        } else if (r === "w" && (a >= e && a <= i && this.canRotate(0, s) || o >= e && o <= i && this.canRotate(1, s)))
          return !0;
      } else if (this.orientationLock) {
        if (this.orientationLock === "l")
          return r === "l" && o >= e && o <= i;
        if (this.orientationLock === "w")
          return r === "l" && a >= e && a <= i;
      }
    }
    return !1;
  }
  rotateToDimension(e, i, r) {
    if (!i) throw new Error("requiredSide not supplied to rotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (i === "l") {
      if (s === e && this.canRotate(0, r)) return this.setRotation(0);
      if (o === e && this.canRotate(1, r)) return this.setRotation(1);
    } else if (i === "w") {
      if (o === e && this.canRotate(0, r)) return this.setRotation(0);
      if (s === e && this.canRotate(1, r)) return this.setRotation(1);
    }
    return !1;
  }
  //get the orientation lock catering for container grain
  convertShapeGrainToOrientationLock(e) {
    if (!e) throw new Error("container not supplied to convertShapeGrainToOrientationLock");
    if (!of(e)) throw new Error("container is not a container");
    if (Pr(this)) return this.orientationLock;
    if (!Dt(this.orientationLock)) return null;
    const i = e.getStock();
    return Dt(i.grain) ? this.orientationLock === i.grain ? "l" : "w" : this.orientationLock;
  }
  /**
   * get the orientation lock catering for container grain
   */
  getNecessaryOrientation(e) {
    if (!e) return this.orientationLock;
    if (Pr(this)) return this.orientationLock;
    if (!Dt(this.orientationLock)) return null;
    if (of(e))
      return this.convertShapeGrainToOrientationLock(e);
    if (Pr(this) || xd(this))
      return Dt(this.orientationLock) ? this.orientationLock : null;
  }
  /**
   * get the required grain rotation
   * checks for stock grain and part orientationLock
   * does not check for fit
   */
  getGrainRotation(e) {
    if (Pr(this)) return this.rot;
    if (!Dt(this.orientationLock)) return null;
    const i = e.getStock();
    return !this.orientationLock || !Dt(i == null ? void 0 : i.grain) ? null : this.isGroup() ? this.orientationLock === "l" ? 0 : 1 : this.orientationLock === (i == null ? void 0 : i.grain) ? 0 : 1;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  rotate(e = null, i = null) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.canRotate(e, i) ? (this.rot === e || this.swapDimensions(), !0) : !1;
  }
  swapDimensions() {
    [this.l, this.w] = [this.w, this.l];
  }
  forceRotate(e) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.rot === e || this.swapDimensions(), !0;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotation(e = null, i = null) {
    return e ? e = 1 : e = 0, i && e && !this.willItFit(i, e) ? !1 : this.rotate(e, i);
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotationToOrientationLock(e) {
    if (!e)
      throw new Error("container not supplied to setRotationToOrientationLock");
    const i = this.getNecessaryOrientation(e);
    if (i === "l") return this.setRotation(0);
    if (i === "w") return this.setRotation(1);
  }
  setRotationToOrientationLockWithoutContainer() {
    if (this.orientationLock === "l") return this.setRotation(0);
    if (this.orientationLock === "w") return this.setRotation(1);
  }
  getBandingLength(e) {
    return !Mb(e) || !this.banding[e] ? 0 : e === "x1" || e === "x2" ? this.getShortSide() : e === "y1" || e === "y2" ? this.getLongSide() : p1(e) ? c1(this, e) : 0;
  }
  getPriority(e) {
    var r;
    if (!e) return 0;
    const i = e.parentID;
    return (r = this.priority) != null && r[i] ? this.priority[i] : 0;
  }
  clearPriority() {
    this.priority = {};
  }
  getPerimeterCutVectors() {
    var r;
    const e = (r = this.stock) != null && r.isStock() ? this.stock.getBladeWidth() / 2 : null;
    return [
      //bottom
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y - e,
        type: "bottom"
      },
      //right
      {
        x1: this.x + this.l + e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "right"
      },
      //top
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y + this.w + e,
        y2: this.y + this.w + e,
        type: "top"
      },
      //left
      {
        x1: this.x - e,
        x2: this.x - e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "left"
      }
    ];
  }
  /* getTrimmedDimensions()
  	{
  		if ( this.trimmed )
  			return {
  				l: this.l,
  				w: this.w
  			};
  
  		return {
  			l: this.l - this.trim.x1 - this.trim.x2,
  			w: this.w - this.trim.y1 - this.trim.y2
  		};
  	} */
  /**
   * create cuts around the perimeter of a shape
   * @param {Stock} stock
   * @returns {Array} cuts
   */
  createPerimeterCuts(e = null) {
    let i = [];
    if (e = e || this.stock, !e) throw new Error("stock is required to create a cut");
    return this.getPerimeterCutVectors().forEach((s) => {
      var o;
      return i.push(new Tc({
        stock: (o = this.stock) != null && o.isStock() ? this.stock : e,
        x1: s.x1,
        x2: s.x2,
        y1: s.y1,
        y2: s.y2,
        type: s.type
      }));
    }), i = i.filter((s) => s.isInsideStock()), i;
  }
  createOffset(e) {
    if (!this.stock) throw new Error("createOffset - stock not defined");
    const i = {
      x: this.x - e,
      y: this.y - e,
      l: this.l + e * 2,
      w: this.w + e * 2
    };
    return i.x < 0 && (i.x = 0, i.l -= e), i.y < 0 && (i.y = 0, i.w -= e), i.x + i.l > this.stock.l && (i.l = this.stock.l - i.x), i.y + i.w > this.stock.w && (i.w = this.stock.w - i.y), i;
  }
  setPositionToBestScore() {
    this.setRotation(this.bestScore.rot), this.x = this.bestScore.x, this.y = this.bestScore.y;
  }
  /**
   * will this shape fit in a container
   */
  willItFit(e, i = null) {
    return g1(e, this, i);
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = i.pop(), e++), i.push(e);
    const r = i.join("."), s = this.stock;
    this.stock = null;
    const o = structuredClone(this);
    return o.stock = s, o.id = r, o.added = !1, o.duplicate = !0, delete o.score, delete o.bestScore, delete o.stock, delete o.placementOrder, delete o.inGroup, delete o.addedAsGroup, delete o.groupID, delete o.isFirstShape, new ns(o);
  }
  //this is a compressed version of the shape to help with memory management
  compress() {
    const e = this.cloneGuillotineData();
    return e.myStripParent = Yb(this.guillotineData.myStripParent) ? this.guillotineData.myStripParent.id : this.guillotineData.myStripParent, {
      id: this.id,
      x: this.added ? this.x : 0,
      y: this.added ? this.y : 0,
      l: this.l,
      w: this.w,
      added: this.added,
      guillotineData: e,
      placementOrder: this.placementOrder,
      bestScore: this.bestScore,
      inGroup: this.inGroup,
      groupID: this.groupID,
      addedAsGroup: this.addedAsGroup,
      groupPlacementOrder: this.groupPlacementOrder,
      minSpacing: this.minSpacing,
      cloneType: "shape",
      priority: Object.assign({}, this.priority)
    };
  }
  isTooCloseToEdges(e) {
    var r, s;
    const i = ((s = (r = e.saw) == null ? void 0 : r.options) == null ? void 0 : s.minSpacing) || this.minSpacing;
    return i ? this.getDistancesToContainerEdges(e).some((o) => o > 0 && o <= i) : !1;
  }
  validateStripShapeBatches() {
    const e = Object.values(this.guillotineData.stripShapeBatches.groups);
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (r.id !== this.id)
        throw new Error(`strip shape group id does not match shape id ${this.id} ${r.id} ${i}`);
      if (![this.l, this.w].includes(r.dimension))
        throw new Error(`strip shape group dimension does not match shape dimensions ${this.id} ${r.id} ${i} ${this.l} ${this.w} ${r.dimension}`);
    }
  }
  getStripShapeBatchData(e) {
    var i;
    return typeof e != "number" || !((i = this == null ? void 0 : this.guillotineData) != null && i.stripShapeBatches) || !this.guillotineData.stripShapeBatches.groups || !(e in this.guillotineData.stripShapeBatches.groups) ? !1 : this.guillotineData.stripShapeBatches.groups[e];
  }
  isInStripShapeBatch(e) {
    return !!this.getStripShapeBatchData(e);
  }
  isStacked() {
    return this.added && this.stock && this.stock.isStacked();
  }
}
class y1 extends wd {
  constructor(e) {
    var t = (...nA) => (super(...nA), tt(this, "firstShape"), tt(this, "cuts"), tt(this, "phase"), tt(this, "merged"), tt(this, "children"), tt(this, "siblings"), //used by vis only
    tt(this, "parent"), tt(this, "segmentType"), tt(this, "completed"), //used by vis only
    tt(this, "rowSegment"), //used by cuts
    tt(this, "placementOrder"), tt(this, "hasBeamTrim"), tt(this, "cutDirection"), this);
    if (e) {
      if (e.preventAutoRotation = !0, t(e), this.validateSegment(e), this.issues.length)
        throw new Error(`Segment validation failed - ${this.issues.join(" ")}`);
      delete this.trim, delete this.trimmed, this.shapes = Dt(e == null ? void 0 : e.shapes) ? e.shapes : [], this.firstShape = Dt(e == null ? void 0 : e.firstShape) ? e.firstShape : null, this.cuts = [], this.phase = Dt(e == null ? void 0 : e.phase) ? e.phase : null, this.merged = Dt(e == null ? void 0 : e.merged) ? e.merged : !1, this.parent = Dt(e == null ? void 0 : e.parent) ? e.parent : null, this.children = Dt(e == null ? void 0 : e.children) ? e.children : [], this.siblings = Dt(e == null ? void 0 : e.siblings) ? e.siblings : [], this.offcut = Dt(e == null ? void 0 : e.offcut) ? e.offcut : !1, this.segmentType = Dt(e == null ? void 0 : e.segmentType) ? e.segmentType : null, this.placementOrder = null, this.cutDirection = Dt(e == null ? void 0 : e.cutDirection) ? e.cutDirection : "l", this.hasBeamTrim = Dt(e == null ? void 0 : e.hasBeamTrim) ? e.hasBeamTrim : !1;
    }
  }
  validateSegment(e) {
    var i, r;
    (He.lessThanOrEqualTo(e.w, 0) || He.lessThanOrEqualTo(e.l, 0)) && this.issues.push({ message: `Zero / negative dimension - l: ${e.l}, w: ${e.w}.` }), (He.lessThan(e.x, 0) || He.lessThan(e.y, 0)) && this.issues.push({ message: `Negative position - x: ${e == null ? void 0 : e.x}, y: ${e == null ? void 0 : e.y}.` }), e != null && e.stock && (He.greaterThan(e.x + e.l, e.stock.l) || He.greaterThan(e.y + e.w, e.stock.w)) && this.issues.push({ message: `Outside of stock ${e.stock.id} - x: ${e.x}, y: ${e.y}, l: ${e.l}, w: ${e.w}, sl: ${(i = e == null ? void 0 : e.stock) == null ? void 0 : i.l}, sw: ${(r = e == null ? void 0 : e.stock) == null ? void 0 : r.w}.` });
  }
  //compress for saving / transfer
  save() {
    var e;
    this.children = this.children.map((i) => ({
      id: i.id,
      x: i.x,
      y: i.y,
      l: i.l,
      w: i.w,
      offcut: i.offcut
    })), this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this.shapes, delete this.saw, delete this.siblings, delete this.parent, delete this.trim, this.algoBenchmark = null;
  }
  getBladeWidth() {
    return this.stock.getBladeWidth();
  }
  /**
   * create a normalised shape list to allow searching for duplicates
   */
  getNormalisedShapes(e) {
    return e.map((i) => ({
      x: i.x - this.x,
      y: i.y - this.y,
      l: i.l,
      w: i.w
    }));
  }
  reset() {
    this.stock.used = !1, this.children = [], this.siblings = [], this.parent = null, this.cuts = [], this.phase = null;
  }
}
class $s extends ns {
  //used for sorting
  constructor(e) {
    var i, r;
    if (e = No(e), !((i = e == null ? void 0 : e.shapes) != null && i.length))
      throw new Error("attempting to create a group with no shapes");
    e.preventAutoRotation = !0;
    super(e);
    tt(this, "shapes");
    tt(this, "positions");
    tt(this, "direction");
    tt(this, "container");
    tt(this, "outOfBounds");
    tt(this, "collision");
    tt(this, "counter", 0);
    tt(this, "type");
    tt(this, "efficiency");
    this.q = 1, delete this._banding, delete this._finish, delete this._trim, this.shapes = e.shapes, this.positions = (r = e == null ? void 0 : e.positions) != null && r.length ? e.positions : [], this.direction = e.direction, this.container = e.container, this.type = (e == null ? void 0 : e.type) ?? "auto", this.initGroup();
  }
  initGroup() {
    var e;
    (e = this == null ? void 0 : this.shapes) != null && e.length && (this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]));
  }
  setShapePositions() {
    if (!this.container) return;
    this.positions = [], this.type !== "user" && this.sortShapes();
    let e = 0;
    const i = G2(this.direction);
    this.shapes.forEach((o, a) => {
      this.positions.push({
        shape: o.id,
        [i]: e,
        [V2(i)]: 0,
        rot: o.rot.valueOf()
      }), o.inGroup = !0, e += a === this.shapes.length - 1 ? o[this.direction] : o[this.direction] + o.getMinSpacing(this.container);
    }), this[this.direction] = e;
    const r = ko(this.direction), s = this.shapes.reduce((o, a) => a[r] > o ? a[r] : o, 0);
    if (this[r] = s, W0()) {
      const o = this.shapes.slice(0, -1).reduce((h, u) => h + u.getMinSpacing(this.container), 0), l = this.shapes.reduce((h, u) => h + u[this.direction], 0) + o;
      H0([
        () => Rs(He.equalTo(l, this[this.direction]), "group dimension is incorrect in direction").to.be.true,
        () => Rs(e, "currentPosition is incorrect in direction").to.equal(this[this.direction]),
        () => Rs(s, "group dimension in other direction is not correct").to.equal(this[r])
      ]);
    }
    if (this.w > this.container.w || this.l > this.container.l)
      throw new Error(`group ${this.id} is bigger than container - group ${this.l}x${this.w}, container ${this.container.l}x${this.container.w}`);
  }
  //update the shape spacing and overall group dimensions to account for min spacing
  updateShapeSpacing(e) {
    this.container = e, this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]);
  }
  //get the area of the shapes (does not include blade width) - overwrites the rectangle method
  getArea() {
    return this.shapes.reduce((e, i) => e + i.getArea(), 0);
  }
  destroy() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !1);
  }
  reset() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !0);
  }
  /**
   * orientate all the shapes correctly to fit in the group
   */
  orientateShapes(e) {
    this.shapes.forEach((i) => {
      const r = this.positions.find((o) => o.shape === i.id);
      if (!r) throw new Error("position not found for shape in group");
      if (!i.rotate(r.rot, e)) throw new Error("orientateShapes - unable to rotate shape in group");
    });
  }
  /**
   * sort the shapes by size
   */
  sortShapes() {
    const e = ko(this.direction);
    this.shapes.sort((i, r) => r[e] === i[e] ? r[this.direction] === i[this.direction] ? i.id.localeCompare(r.id, void 0, { numeric: !0 }) : r[this.direction] - i[this.direction] : r[e] - i[e]);
  }
  /**
   * place the group shapes on the stock
   */
  placeMyShapes(e) {
    if (!e) throw new Error("placeShapes requires stock");
    this.addToStock(e);
    for (let i = 0; i < this.shapes.length; i++) {
      const r = this.shapes[i];
      r.addToStock(e);
      const s = this.positions.find((l) => l.shape === r.id);
      if (!s) throw new Error("position not found for shape in group");
      if (r.x = this.x + s.x, r.y = this.y + s.y, !r.rotate(s.rot, e)) throw new Error("placeMyShapes - unable to rotate shape in group");
      i === 0 && this.x === 0 && this.y === 0 && (r.isFirstShape = !0), r.addedAsGroup = this.id, r.inGroup = !1, r.score = this.score;
      const a = r.guillotineData.stripShapeBatches;
      r.guillotineData = this.cloneGuillotineData(), r.guillotineData.stripShapeBatches = a, r.bestScore = this.bestScore, typeof this.placementOrder == "number" && (r.groupPlacementOrder = i, r.placementOrder = this.placementOrder + i / 1e6);
    }
  }
  //this is for groups which are created once and reused between stock e.g. user groups
  orientateCorrectly(e) {
    this.orientateShapes(e), this.setRotationToOrientationLock(e);
  }
  clone(e = []) {
    const r = `g${parseInt(this.id.split("g")[1]) + 1}`, s = this.shapes, o = this.container, a = this.stock;
    this.shapes = [], this.container = null, this.stock = null;
    const l = structuredClone(this);
    return this.shapes = s, this.container = o, this.stock = a, l.container = this.container, l.shapes = e, l.id = r, new $s(l);
  }
  compress() {
    const e = super.compress.call(this);
    return e.direction = this.direction, e.positions = structuredClone(this.positions), e.shapes = this.shapes.map((i) => i.compress()), e.type = this.type, e.cloneType = "group", e;
  }
}
function Wb(n, t, e, i) {
  return t.filter((r, s) => {
    var o, a;
    return n.stockMatch.material[s] = null, n.stockMatch.thickness[s] = null, n.stockMatch.width[s] = null, n.stockMatch.fit[s] = null, (gr(n) || xd(n)) && (g1(r, n) ? n.stockMatch.fit[s] = !0 : n.stockMatch.fit[s] = !1), e ? !(r != null && r.material) && !(n != null && n.material) || ((o = r == null ? void 0 : r.material) == null ? void 0 : o.toLowerCase()) === ((a = n == null ? void 0 : n.material) == null ? void 0 : a.toLowerCase()) ? n.stockMatch.material[s] = !0 : n.stockMatch.material[s] = !1 : n.stockMatch.material[s] = !0, i ? Dt(n.t) && Dt(r.t) ? (gr(n) && He.equalTo(n.t, r.t) || n.t === r.t) && (n.stockMatch.thickness[s] = !0) : n.stockMatch.thickness[s] = !1 : n.stockMatch.thickness[s] = !0, r.type === "linear" ? gr(n) && (n.canRotate(0, r) && He.equalTo(n.w, r.w) || n.canRotate(1, r) && He.equalTo(n.l, r.w) ? n.stockMatch.width[s] = !0 : n.stockMatch.width[s] = !1) : n.stockMatch.width[s] = !0, n.stockMatch.fit[s] && n.stockMatch.material[s] && n.stockMatch.thickness[s] && n.stockMatch.width[s];
  });
}
function Hb(n, t, e) {
  const i = cr(n[0]);
  if (i && (t = t.map((u) => {
    const d = new es(u);
    return d.trimDimensions(), d;
  }), n = n.map((u) => {
    const d = new ns(u);
    return d.trimDimensions(), d;
  })), Uu(t[0]) && (t = t.map((u, d) => (u.id = `${d.toString()}.0`, new es(u)))), n.some((u) => Dt(u.stockLock) && u.stockLock.length)) return;
  t = t.filter((u) => u.autoAdd === !0 || Dt(u.q) && u.q > 0);
  const s = t.some((u) => Dt(u.material)), o = t.some((u) => Dt(u.t)), a = /* @__PURE__ */ new Set();
  for (const u of n) {
    u.stockMatch = {
      material: [],
      thickness: [],
      width: [],
      fit: []
    };
    const d = Wb(u, t, s, o);
    if (u.stockMatch.fit = !u.stockMatch.fit.every((p) => p === !1), u.stockMatch.material = !u.stockMatch.material.every((p) => p === !1), u.stockMatch.thickness = !u.stockMatch.thickness.every((p) => p === !1), u.stockMatch.width = !u.stockMatch.width.every((p) => p === !1), !i) {
      if (d.length) {
        const p = d.map((f) => f.getParentID());
        u.stockLock = p, p.forEach((f) => a.add(f));
      } else if (u.stockMatch.fit)
        u.stockMatch.material || u.issues.push({ message: `materials must match - could not find any stock with ${u.material ? u.material + " material" : "no material set"}` }), u.stockMatch.thickness || u.issues.push({ message: `thicknesses must match - could not find any stock with ${u.t ? "thickness " + u.t : "no thickness set"}` }), e === "linear" && !u.stockMatch.width && u.issues.push({ message: `widths must match for linear calculations - could not find any stock with ${u.w ? "width " + u.w : "no width set"}` });
      else {
        const p = u.getTrimmedDimensions();
        u.issues.push({ message: `${p.l.toFixed()}x${p.w.toFixed()} will not fit on any stock - check dimensions, min spacing, trim & orientation lock` });
      }
      u.stockMatch = null;
    }
  }
  const l = n.filter((u) => !u.stockLock || !u.stockLock.length).sort(Ju.ID), h = t.filter((u) => !a.has(u.parentID)).sort(Ju.ID);
  return t = t.filter((u) => ts(u)).filter((u) => a.has(u.parentID)), (s || o) && (n = n.filter((u) => {
    var d;
    return (d = u == null ? void 0 : u.stockLock) == null ? void 0 : d.length;
  })), {
    stockList: t,
    unusableStock: h,
    shapeList: n,
    unusableShapes: l
  };
}
function Gb(n) {
  if (!n.length) return "n";
  const t = n.map((e) => e.grain).filter((e) => e);
  return t.length ? t.every((e) => e === "l") ? "l" : t.every((e) => e === "w") ? "w" : t.some((e) => e === "l" || e === "w") ? "y" : "n" : "n";
}
function Vb(n) {
  return n.shapes !== void 0;
}
function Pr(n) {
  return n instanceof $s && n.type !== "user";
}
function xd(n) {
  return n instanceof $s && n.type === "user";
}
function ho(n) {
  return n instanceof Fb;
}
function Uu(n) {
  return n instanceof m1;
}
function cr(n) {
  return n instanceof vd;
}
function ts(n) {
  return n instanceof es;
}
function of(n) {
  return n instanceof wd;
}
function gr(n) {
  return n instanceof ns && !(n instanceof $s);
}
function Yb(n) {
  return n instanceof ns || n instanceof $s;
}
function Kb(n) {
  return n instanceof y1;
}
function Xb(n) {
  return n instanceof js;
}
function Jb(n) {
  return !n || typeof n != "string" ? "" : n.toUpperCase();
}
function ac(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n) !== void 0;
}
function gn(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n);
}
function Dt(n) {
  return !(n === void 0 || n === null || n === "" || typeof n == "object" && !Object.values(n).length);
}
function Co(n, t = !1) {
  if (!Dt(n) || typeof n != "object") return !1;
  const e = Object.values(n);
  return e.length === 0 ? !1 : t ? e.some((i) => Dt(i) && i) : e.some((i) => Dt(i));
}
function Zb(n) {
  return n != null && n.length ? n.filter((t) => t.used && (t.stack === !1 || typeof t.stack == "number")) : [];
}
function Qb() {
  const n = document.documentElement;
  return "requestFullscreen" in n || "webkitRequestFullscreen" in n || "mozRequestFullScreen" in n || "msRequestFullscreen" in n;
}
function $l(n) {
  return n ? (n = n.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^ a-z0-9._\-|]/gim, ""), n.trim()) : null;
}
function b1(n, t = 100) {
  return n ? (n = n.trim(), n = n.substring(0, t), n) : "";
}
function nn(n) {
  "@babel/helpers - typeof";
  return nn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nn(n);
}
var li = Uint8Array, Ri = Uint16Array, _d = Int32Array, Mc = new li([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Rc = new li([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), af = new li([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), v1 = function(n, t) {
  for (var e = new Ri(31), i = 0; i < 31; ++i)
    e[i] = t += 1 << n[i - 1];
  for (var r = new _d(e[30]), i = 1; i < 30; ++i)
    for (var s = e[i]; s < e[i + 1]; ++s)
      r[s] = s - e[i] << 5 | i;
  return { b: e, r };
}, w1 = v1(Mc, 2), x1 = w1.b, lf = w1.r;
x1[28] = 258, lf[258] = 28;
var _1 = v1(Rc, 0), tv = _1.b, Wp = _1.r, uf = new Ri(32768);
for (var dn = 0; dn < 32768; ++dn) {
  var Ps = (dn & 43690) >> 1 | (dn & 21845) << 1;
  Ps = (Ps & 52428) >> 2 | (Ps & 13107) << 2, Ps = (Ps & 61680) >> 4 | (Ps & 3855) << 4, uf[dn] = ((Ps & 65280) >> 8 | (Ps & 255) << 8) >> 1;
}
var Or = function(n, t, e) {
  for (var i = n.length, r = 0, s = new Ri(t); r < i; ++r)
    n[r] && ++s[n[r] - 1];
  var o = new Ri(t);
  for (r = 1; r < t; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  var a;
  if (e) {
    a = new Ri(1 << t);
    var l = 15 - t;
    for (r = 0; r < i; ++r)
      if (n[r])
        for (var h = r << 4 | n[r], u = t - n[r], d = o[n[r] - 1]++ << u, p = d | (1 << u) - 1; d <= p; ++d)
          a[uf[d] >> l] = h;
  } else
    for (a = new Ri(i), r = 0; r < i; ++r)
      n[r] && (a[r] = uf[o[n[r] - 1]++] >> 15 - n[r]);
  return a;
}, qs = new li(288);
for (var dn = 0; dn < 144; ++dn)
  qs[dn] = 8;
for (var dn = 144; dn < 256; ++dn)
  qs[dn] = 9;
for (var dn = 256; dn < 280; ++dn)
  qs[dn] = 7;
for (var dn = 280; dn < 288; ++dn)
  qs[dn] = 8;
var Pl = new li(32);
for (var dn = 0; dn < 32; ++dn)
  Pl[dn] = 5;
var ev = /* @__PURE__ */ Or(qs, 9, 0), nv = /* @__PURE__ */ Or(qs, 9, 1), iv = /* @__PURE__ */ Or(Pl, 5, 0), rv = /* @__PURE__ */ Or(Pl, 5, 1), _h = function(n) {
  for (var t = n[0], e = 1; e < n.length; ++e)
    n[e] > t && (t = n[e]);
  return t;
}, or = function(n, t, e) {
  var i = t / 8 | 0;
  return (n[i] | n[i + 1] << 8) >> (t & 7) & e;
}, Sh = function(n, t) {
  var e = t / 8 | 0;
  return (n[e] | n[e + 1] << 8 | n[e + 2] << 16) >> (t & 7);
}, Sd = function(n) {
  return (n + 7) / 8 | 0;
}, S1 = function(n, t, e) {
  return (e == null || e > n.length) && (e = n.length), new li(n.subarray(t, e));
}, sv = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], lr = function(n, t, e) {
  var i = new Error(t || sv[n]);
  if (i.code = n, Error.captureStackTrace && Error.captureStackTrace(i, lr), !e)
    throw i;
  return i;
}, ov = function(n, t, e, i) {
  var r = n.length, s = 0;
  if (!r || t.f && !t.l)
    return e || new li(0);
  var o = !e, a = o || t.i != 2, l = t.i;
  o && (e = new li(r * 3));
  var h = function(Rt) {
    var te = e.length;
    if (Rt > te) {
      var Xt = new li(Math.max(te * 2, Rt));
      Xt.set(e), e = Xt;
    }
  }, u = t.f || 0, d = t.p || 0, p = t.b || 0, f = t.l, m = t.d, b = t.m, x = t.n, y = r * 8;
  do {
    if (!f) {
      u = or(n, d, 1);
      var v = or(n, d + 1, 3);
      if (d += 3, v)
        if (v == 1)
          f = nv, m = rv, b = 9, x = 5;
        else if (v == 2) {
          var q = or(n, d, 31) + 257, O = or(n, d + 10, 15) + 4, F = q + or(n, d + 5, 31) + 1;
          d += 14;
          for (var M = new li(F), j = new li(19), P = 0; P < O; ++P)
            j[af[P]] = or(n, d + P * 3, 7);
          d += O * 3;
          for (var A = _h(j), T = (1 << A) - 1, _ = Or(j, A, 1), P = 0; P < F; ) {
            var Z = _[or(n, d, T)];
            d += Z & 15;
            var k = Z >> 4;
            if (k < 16)
              M[P++] = k;
            else {
              var V = 0, R = 0;
              for (k == 16 ? (R = 3 + or(n, d, 3), d += 2, V = M[P - 1]) : k == 17 ? (R = 3 + or(n, d, 7), d += 3) : k == 18 && (R = 11 + or(n, d, 127), d += 7); R--; )
                M[P++] = V;
            }
          }
          var Q = M.subarray(0, q), H = M.subarray(q);
          b = _h(Q), x = _h(H), f = Or(Q, b, 1), m = Or(H, x, 1);
        } else
          lr(1);
      else {
        var k = Sd(d) + 4, C = n[k - 4] | n[k - 3] << 8, I = k + C;
        if (I > r) {
          l && lr(0);
          break;
        }
        a && h(p + C), e.set(n.subarray(k, I), p), t.b = p += C, t.p = d = I * 8, t.f = u;
        continue;
      }
      if (d > y) {
        l && lr(0);
        break;
      }
    }
    a && h(p + 131072);
    for (var ct = (1 << b) - 1, nt = (1 << x) - 1, N = d; ; N = d) {
      var V = f[Sh(n, d) & ct], z = V >> 4;
      if (d += V & 15, d > y) {
        l && lr(0);
        break;
      }
      if (V || lr(2), z < 256)
        e[p++] = z;
      else if (z == 256) {
        N = d, f = null;
        break;
      } else {
        var G = z - 254;
        if (z > 264) {
          var P = z - 257, Y = Mc[P];
          G = or(n, d, (1 << Y) - 1) + x1[P], d += Y;
        }
        var st = m[Sh(n, d) & nt], vt = st >> 4;
        st || lr(3), d += st & 15;
        var H = tv[vt];
        if (vt > 3) {
          var Y = Rc[vt];
          H += Sh(n, d) & (1 << Y) - 1, d += Y;
        }
        if (d > y) {
          l && lr(0);
          break;
        }
        a && h(p + 131072);
        var mt = p + G;
        if (p < H) {
          var _t = s - H, Bt = Math.min(H, mt);
          for (_t + p < 0 && lr(3); p < Bt; ++p)
            e[p] = i[_t + p];
        }
        for (; p < mt; ++p)
          e[p] = e[p - H];
      }
    }
    t.l = f, t.p = N, t.b = p, t.f = u, f && (u = 1, t.m = b, t.d = m, t.n = x);
  } while (!u);
  return p != e.length && o ? S1(e, 0, p) : e.subarray(0, p);
}, Zr = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8;
}, hl = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8, n[i + 2] |= e >> 16;
}, kh = function(n, t) {
  for (var e = [], i = 0; i < n.length; ++i)
    n[i] && e.push({ s: i, f: n[i] });
  var r = e.length, s = e.slice();
  if (!r)
    return { t: A1, l: 0 };
  if (r == 1) {
    var o = new li(e[0].s + 1);
    return o[e[0].s] = 1, { t: o, l: 1 };
  }
  e.sort(function(I, q) {
    return I.f - q.f;
  }), e.push({ s: -1, f: 25001 });
  var a = e[0], l = e[1], h = 0, u = 1, d = 2;
  for (e[0] = { s: -1, f: a.f + l.f, l: a, r: l }; u != r - 1; )
    a = e[e[h].f < e[d].f ? h++ : d++], l = e[h != u && e[h].f < e[d].f ? h++ : d++], e[u++] = { s: -1, f: a.f + l.f, l: a, r: l };
  for (var p = s[0].s, i = 1; i < r; ++i)
    s[i].s > p && (p = s[i].s);
  var f = new Ri(p + 1), m = cf(e[u - 1], f, 0);
  if (m > t) {
    var i = 0, b = 0, x = m - t, y = 1 << x;
    for (s.sort(function(q, O) {
      return f[O.s] - f[q.s] || q.f - O.f;
    }); i < r; ++i) {
      var v = s[i].s;
      if (f[v] > t)
        b += y - (1 << m - f[v]), f[v] = t;
      else
        break;
    }
    for (b >>= x; b > 0; ) {
      var k = s[i].s;
      f[k] < t ? b -= 1 << t - f[k]++ - 1 : ++i;
    }
    for (; i >= 0 && b; --i) {
      var C = s[i].s;
      f[C] == t && (--f[C], ++b);
    }
    m = t;
  }
  return { t: new li(f), l: m };
}, cf = function(n, t, e) {
  return n.s == -1 ? Math.max(cf(n.l, t, e + 1), cf(n.r, t, e + 1)) : t[n.s] = e;
}, Hp = function(n) {
  for (var t = n.length; t && !n[--t]; )
    ;
  for (var e = new Ri(++t), i = 0, r = n[0], s = 1, o = function(l) {
    e[i++] = l;
  }, a = 1; a <= t; ++a)
    if (n[a] == r && a != t)
      ++s;
    else {
      if (!r && s > 2) {
        for (; s > 138; s -= 138)
          o(32754);
        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(r), --s; s > 6; s -= 6)
          o(8304);
        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        o(r);
      s = 1, r = n[a];
    }
  return { c: e.subarray(0, i), n: t };
}, fl = function(n, t) {
  for (var e = 0, i = 0; i < t.length; ++i)
    e += n[i] * t[i];
  return e;
}, k1 = function(n, t, e) {
  var i = e.length, r = Sd(t + 2);
  n[r] = i & 255, n[r + 1] = i >> 8, n[r + 2] = n[r] ^ 255, n[r + 3] = n[r + 1] ^ 255;
  for (var s = 0; s < i; ++s)
    n[r + s + 4] = e[s];
  return (r + 4 + i) * 8;
}, Gp = function(n, t, e, i, r, s, o, a, l, h, u) {
  Zr(t, u++, e), ++r[256];
  for (var d = kh(r, 15), p = d.t, f = d.l, m = kh(s, 15), b = m.t, x = m.l, y = Hp(p), v = y.c, k = y.n, C = Hp(b), I = C.c, q = C.n, O = new Ri(19), F = 0; F < v.length; ++F)
    ++O[v[F] & 31];
  for (var F = 0; F < I.length; ++F)
    ++O[I[F] & 31];
  for (var M = kh(O, 7), j = M.t, P = M.l, A = 19; A > 4 && !j[af[A - 1]]; --A)
    ;
  var T = h + 5 << 3, _ = fl(r, qs) + fl(s, Pl) + o, Z = fl(r, p) + fl(s, b) + o + 14 + 3 * A + fl(O, j) + 2 * O[16] + 3 * O[17] + 7 * O[18];
  if (l >= 0 && T <= _ && T <= Z)
    return k1(t, u, n.subarray(l, l + h));
  var V, R, Q, H;
  if (Zr(t, u, 1 + (Z < _)), u += 2, Z < _) {
    V = Or(p, f, 0), R = p, Q = Or(b, x, 0), H = b;
    var ct = Or(j, P, 0);
    Zr(t, u, k - 257), Zr(t, u + 5, q - 1), Zr(t, u + 10, A - 4), u += 14;
    for (var F = 0; F < A; ++F)
      Zr(t, u + 3 * F, j[af[F]]);
    u += 3 * A;
    for (var nt = [v, I], N = 0; N < 2; ++N)
      for (var z = nt[N], F = 0; F < z.length; ++F) {
        var G = z[F] & 31;
        Zr(t, u, ct[G]), u += j[G], G > 15 && (Zr(t, u, z[F] >> 5 & 127), u += z[F] >> 12);
      }
  } else
    V = ev, R = qs, Q = iv, H = Pl;
  for (var F = 0; F < a; ++F) {
    var Y = i[F];
    if (Y > 255) {
      var G = Y >> 18 & 31;
      hl(t, u, V[G + 257]), u += R[G + 257], G > 7 && (Zr(t, u, Y >> 23 & 31), u += Mc[G]);
      var st = Y & 31;
      hl(t, u, Q[st]), u += H[st], st > 3 && (hl(t, u, Y >> 5 & 8191), u += Rc[st]);
    } else
      hl(t, u, V[Y]), u += R[Y];
  }
  return hl(t, u, V[256]), u + R[256];
}, av = /* @__PURE__ */ new _d([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), A1 = /* @__PURE__ */ new li(0), lv = function(n, t, e, i, r, s) {
  var o = s.z || n.length, a = new li(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r), l = a.subarray(i, a.length - r), h = s.l, u = (s.r || 0) & 7;
  if (t) {
    u && (l[0] = s.r >> 3);
    for (var d = av[t - 1], p = d >> 13, f = d & 8191, m = (1 << e) - 1, b = s.p || new Ri(32768), x = s.h || new Ri(m + 1), y = Math.ceil(e / 3), v = 2 * y, k = function(E) {
      return (n[E] ^ n[E + 1] << y ^ n[E + 2] << v) & m;
    }, C = new _d(25e3), I = new Ri(288), q = new Ri(32), O = 0, F = 0, M = s.i || 0, j = 0, P = s.w || 0, A = 0; M + 2 < o; ++M) {
      var T = k(M), _ = M & 32767, Z = x[T];
      if (b[_] = Z, x[T] = _, P <= M) {
        var V = o - M;
        if ((O > 7e3 || j > 24576) && (V > 423 || !h)) {
          u = Gp(n, l, 0, C, I, q, F, j, A, M - A, u), j = O = F = 0, A = M;
          for (var R = 0; R < 286; ++R)
            I[R] = 0;
          for (var R = 0; R < 30; ++R)
            q[R] = 0;
        }
        var Q = 2, H = 0, ct = f, nt = _ - Z & 32767;
        if (V > 2 && T == k(M - nt))
          for (var N = Math.min(p, V) - 1, z = Math.min(32767, M), G = Math.min(258, V); nt <= z && --ct && _ != Z; ) {
            if (n[M + Q] == n[M + Q - nt]) {
              for (var Y = 0; Y < G && n[M + Y] == n[M + Y - nt]; ++Y)
                ;
              if (Y > Q) {
                if (Q = Y, H = nt, Y > N)
                  break;
                for (var st = Math.min(nt, Y - 2), vt = 0, R = 0; R < st; ++R) {
                  var mt = M - nt + R & 32767, _t = b[mt], Bt = mt - _t & 32767;
                  Bt > vt && (vt = Bt, Z = mt);
                }
              }
            }
            _ = Z, Z = b[_], nt += _ - Z & 32767;
          }
        if (H) {
          C[j++] = 268435456 | lf[Q] << 18 | Wp[H];
          var Rt = lf[Q] & 31, te = Wp[H] & 31;
          F += Mc[Rt] + Rc[te], ++I[257 + Rt], ++q[te], P = M + Q, ++O;
        } else
          C[j++] = n[M], ++I[n[M]];
      }
    }
    for (M = Math.max(M, P); M < o; ++M)
      C[j++] = n[M], ++I[n[M]];
    u = Gp(n, l, h, C, I, q, F, j, A, M - A, u), h || (s.r = u & 7 | l[u / 8 | 0] << 3, u -= 7, s.h = x, s.p = b, s.i = M, s.w = P);
  } else {
    for (var M = s.w || 0; M < o + h; M += 65535) {
      var Xt = M + 65535;
      Xt >= o && (l[u / 8 | 0] = h, Xt = o), u = k1(l, u + 1, n.subarray(M, Xt));
    }
    s.i = o;
  }
  return S1(a, 0, i + Sd(u) + r);
}, N1 = function() {
  var n = 1, t = 0;
  return {
    p: function(e) {
      for (var i = n, r = t, s = e.length | 0, o = 0; o != s; ) {
        for (var a = Math.min(o + 2655, s); o < a; ++o)
          r += i += e[o];
        i = (i & 65535) + 15 * (i >> 16), r = (r & 65535) + 15 * (r >> 16);
      }
      n = i, t = r;
    },
    d: function() {
      return n %= 65521, t %= 65521, (n & 255) << 24 | (n & 65280) << 8 | (t & 255) << 8 | t >> 8;
    }
  };
}, uv = function(n, t, e, i, r) {
  if (!r && (r = { l: 1 }, t.dictionary)) {
    var s = t.dictionary.subarray(-32768), o = new li(s.length + n.length);
    o.set(s), o.set(n, s.length), n = o, r.w = s.length;
  }
  return lv(n, t.level == null ? 6 : t.level, t.mem == null ? r.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 20 : 12 + t.mem, e, i, r);
}, C1 = function(n, t, e) {
  for (; e; ++t)
    n[t] = e, e >>>= 8;
}, cv = function(n, t) {
  var e = t.level, i = e == 0 ? 0 : e < 6 ? 1 : e == 9 ? 3 : 2;
  if (n[0] = 120, n[1] = i << 6 | (t.dictionary && 32), n[1] |= 31 - (n[0] << 8 | n[1]) % 31, t.dictionary) {
    var r = N1();
    r.p(t.dictionary), C1(n, 2, r.d());
  }
}, hv = function(n, t) {
  return ((n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31) && lr(6, "invalid zlib data"), (n[1] >> 5 & 1) == +!t && lr(6, "invalid zlib data: " + (n[1] & 32 ? "need" : "unexpected") + " dictionary"), (n[1] >> 3 & 4) + 2;
};
function hf(n, t) {
  t || (t = {});
  var e = N1();
  e.p(n);
  var i = uv(n, t, t.dictionary ? 6 : 2, 4);
  return cv(i, t), C1(i, i.length - 4, e.d()), i;
}
function fv(n, t) {
  return ov(n.subarray(hv(n, t), -4), { i: 2 }, t, t);
}
var dv = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), pv = 0;
try {
  dv.decode(A1, { stream: !0 }), pv = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Le = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Ah() {
  Le.console && typeof Le.console.log == "function" && Le.console.log.apply(Le.console, arguments);
}
var ln = { log: Ah, warn: function(n) {
  Le.console && (typeof Le.console.warn == "function" ? Le.console.warn.apply(Le.console, arguments) : Ah.call(null, arguments));
}, error: function(n) {
  Le.console && (typeof Le.console.error == "function" ? Le.console.error.apply(Le.console, arguments) : Ah(n));
} };
function Nh(n, t, e) {
  var i = new XMLHttpRequest();
  i.open("GET", n), i.responseType = "blob", i.onload = function() {
    ao(i.response, t, e);
  }, i.onerror = function() {
    ln.error("could not download file");
  }, i.send();
}
function Vp(n) {
  var t = new XMLHttpRequest();
  t.open("HEAD", n, !1);
  try {
    t.send();
  } catch {
  }
  return t.status >= 200 && t.status <= 299;
}
function Nu(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var t = document.createEvent("MouseEvents");
    t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(t);
  }
}
var Sl, ff, ao = Le.saveAs || ((typeof window > "u" ? "undefined" : nn(window)) !== "object" || window !== Le ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, t, e) {
  var i = Le.URL || Le.webkitURL, r = document.createElement("a");
  t = t || n.name || "download", r.download = t, r.rel = "noopener", typeof n == "string" ? (r.href = n, r.origin !== location.origin ? Vp(r.href) ? Nh(n, t, e) : Nu(r, r.target = "_blank") : Nu(r)) : (r.href = i.createObjectURL(n), setTimeout(function() {
    i.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Nu(r);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, t, e) {
  if (t = t || n.name || "download", typeof n == "string") if (Vp(n)) Nh(n, t, e);
  else {
    var i = document.createElement("a");
    i.href = n, i.target = "_blank", setTimeout(function() {
      Nu(i);
    });
  }
  else navigator.msSaveOrOpenBlob(function(r, s) {
    return s === void 0 ? s = { autoBom: !1 } : nn(s) !== "object" && (ln.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(r.type) ? new Blob(["\uFEFF", r], { type: r.type }) : r;
  }(n, e), t);
} : function(n, t, e, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof n == "string") return Nh(n, t, e);
  var r = n.type === "application/octet-stream", s = /constructor/i.test(Le.HTMLElement) || Le.safari, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || r && s) && (typeof FileReader > "u" ? "undefined" : nn(FileReader)) === "object") {
    var a = new FileReader();
    a.onloadend = function() {
      var u = a.result;
      u = o ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = u : location = u, i = null;
    }, a.readAsDataURL(n);
  } else {
    var l = Le.URL || Le.webkitURL, h = l.createObjectURL(n);
    i ? i.location = h : location.href = h, i = null, setTimeout(function() {
      l.revokeObjectURL(h);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function P1(n) {
  var t;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var e = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(a) {
    return [parseInt(a[1]), parseInt(a[2]), parseInt(a[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(a) {
    return [parseInt(a[1], 16), parseInt(a[2], 16), parseInt(a[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(a) {
    return [parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16), parseInt(a[3] + a[3], 16)];
  } }], i = 0; i < e.length; i++) {
    var r = e[i].re, s = e[i].process, o = r.exec(n);
    o && (t = s(o), this.r = t[0], this.g = t[1], this.b = t[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var a = this.r.toString(16), l = this.g.toString(16), h = this.b.toString(16);
    return a.length == 1 && (a = "0" + a), l.length == 1 && (l = "0" + l), h.length == 1 && (h = "0" + h), "#" + a + l + h;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ch(n, t) {
  var e = n[0], i = n[1], r = n[2], s = n[3];
  e = ni(e, i, r, s, t[0], 7, -680876936), s = ni(s, e, i, r, t[1], 12, -389564586), r = ni(r, s, e, i, t[2], 17, 606105819), i = ni(i, r, s, e, t[3], 22, -1044525330), e = ni(e, i, r, s, t[4], 7, -176418897), s = ni(s, e, i, r, t[5], 12, 1200080426), r = ni(r, s, e, i, t[6], 17, -1473231341), i = ni(i, r, s, e, t[7], 22, -45705983), e = ni(e, i, r, s, t[8], 7, 1770035416), s = ni(s, e, i, r, t[9], 12, -1958414417), r = ni(r, s, e, i, t[10], 17, -42063), i = ni(i, r, s, e, t[11], 22, -1990404162), e = ni(e, i, r, s, t[12], 7, 1804603682), s = ni(s, e, i, r, t[13], 12, -40341101), r = ni(r, s, e, i, t[14], 17, -1502002290), e = ii(e, i = ni(i, r, s, e, t[15], 22, 1236535329), r, s, t[1], 5, -165796510), s = ii(s, e, i, r, t[6], 9, -1069501632), r = ii(r, s, e, i, t[11], 14, 643717713), i = ii(i, r, s, e, t[0], 20, -373897302), e = ii(e, i, r, s, t[5], 5, -701558691), s = ii(s, e, i, r, t[10], 9, 38016083), r = ii(r, s, e, i, t[15], 14, -660478335), i = ii(i, r, s, e, t[4], 20, -405537848), e = ii(e, i, r, s, t[9], 5, 568446438), s = ii(s, e, i, r, t[14], 9, -1019803690), r = ii(r, s, e, i, t[3], 14, -187363961), i = ii(i, r, s, e, t[8], 20, 1163531501), e = ii(e, i, r, s, t[13], 5, -1444681467), s = ii(s, e, i, r, t[2], 9, -51403784), r = ii(r, s, e, i, t[7], 14, 1735328473), e = ri(e, i = ii(i, r, s, e, t[12], 20, -1926607734), r, s, t[5], 4, -378558), s = ri(s, e, i, r, t[8], 11, -2022574463), r = ri(r, s, e, i, t[11], 16, 1839030562), i = ri(i, r, s, e, t[14], 23, -35309556), e = ri(e, i, r, s, t[1], 4, -1530992060), s = ri(s, e, i, r, t[4], 11, 1272893353), r = ri(r, s, e, i, t[7], 16, -155497632), i = ri(i, r, s, e, t[10], 23, -1094730640), e = ri(e, i, r, s, t[13], 4, 681279174), s = ri(s, e, i, r, t[0], 11, -358537222), r = ri(r, s, e, i, t[3], 16, -722521979), i = ri(i, r, s, e, t[6], 23, 76029189), e = ri(e, i, r, s, t[9], 4, -640364487), s = ri(s, e, i, r, t[12], 11, -421815835), r = ri(r, s, e, i, t[15], 16, 530742520), e = si(e, i = ri(i, r, s, e, t[2], 23, -995338651), r, s, t[0], 6, -198630844), s = si(s, e, i, r, t[7], 10, 1126891415), r = si(r, s, e, i, t[14], 15, -1416354905), i = si(i, r, s, e, t[5], 21, -57434055), e = si(e, i, r, s, t[12], 6, 1700485571), s = si(s, e, i, r, t[3], 10, -1894986606), r = si(r, s, e, i, t[10], 15, -1051523), i = si(i, r, s, e, t[1], 21, -2054922799), e = si(e, i, r, s, t[8], 6, 1873313359), s = si(s, e, i, r, t[15], 10, -30611744), r = si(r, s, e, i, t[6], 15, -1560198380), i = si(i, r, s, e, t[13], 21, 1309151649), e = si(e, i, r, s, t[4], 6, -145523070), s = si(s, e, i, r, t[11], 10, -1120210379), r = si(r, s, e, i, t[2], 15, 718787259), i = si(i, r, s, e, t[9], 21, -343485551), n[0] = Ts(e, n[0]), n[1] = Ts(i, n[1]), n[2] = Ts(r, n[2]), n[3] = Ts(s, n[3]);
}
function Dc(n, t, e, i, r, s) {
  return t = Ts(Ts(t, n), Ts(i, s)), Ts(t << r | t >>> 32 - r, e);
}
function ni(n, t, e, i, r, s, o) {
  return Dc(t & e | ~t & i, n, t, r, s, o);
}
function ii(n, t, e, i, r, s, o) {
  return Dc(t & i | e & ~i, n, t, r, s, o);
}
function ri(n, t, e, i, r, s, o) {
  return Dc(t ^ e ^ i, n, t, r, s, o);
}
function si(n, t, e, i, r, s, o) {
  return Dc(e ^ (t | ~i), n, t, r, s, o);
}
function L1(n) {
  var t, e = n.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (t = 64; t <= n.length; t += 64) Ch(i, gv(n.substring(t - 64, t)));
  n = n.substring(t - 64);
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (t = 0; t < n.length; t++) r[t >> 2] |= n.charCodeAt(t) << (t % 4 << 3);
  if (r[t >> 2] |= 128 << (t % 4 << 3), t > 55) for (Ch(i, r), t = 0; t < 16; t++) r[t] = 0;
  return r[14] = 8 * e, Ch(i, r), i;
}
function gv(n) {
  var t, e = [];
  for (t = 0; t < 64; t += 4) e[t >> 2] = n.charCodeAt(t) + (n.charCodeAt(t + 1) << 8) + (n.charCodeAt(t + 2) << 16) + (n.charCodeAt(t + 3) << 24);
  return e;
}
Sl = Le.atob.bind(Le), ff = Le.btoa.bind(Le);
var Yp = "0123456789abcdef".split("");
function mv(n) {
  for (var t = "", e = 0; e < 4; e++) t += Yp[n >> 8 * e + 4 & 15] + Yp[n >> 8 * e & 15];
  return t;
}
function yv(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function df(n) {
  return L1(n).map(yv).join("");
}
var bv = function(n) {
  for (var t = 0; t < n.length; t++) n[t] = mv(n[t]);
  return n.join("");
}(L1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Ts(n, t) {
  if (bv) {
    var e = (65535 & n) + (65535 & t);
    return (n >> 16) + (t >> 16) + (e >> 16) << 16 | 65535 & e;
  }
  return n + t & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function pf(n, t) {
  var e, i, r, s;
  if (n !== e) {
    for (var o = (r = n, s = 1 + (256 / n.length >> 0), new Array(s + 1).join(r)), a = [], l = 0; l < 256; l++) a[l] = l;
    var h = 0;
    for (l = 0; l < 256; l++) {
      var u = a[l];
      h = (h + u + o.charCodeAt(l)) % 256, a[l] = a[h], a[h] = u;
    }
    e = n, i = a;
  } else a = i;
  var d = t.length, p = 0, f = 0, m = "";
  for (l = 0; l < d; l++) f = (f + (u = a[p = (p + 1) % 256])) % 256, a[p] = a[f], a[f] = u, o = a[(a[p] + a[f]) % 256], m += String.fromCharCode(t.charCodeAt(l) ^ o);
  return m;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Kp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function ca(n, t, e, i) {
  this.v = 1, this.r = 2;
  var r = 192;
  n.forEach(function(a) {
    if (Kp.perm !== void 0) throw new Error("Invalid permission: " + a);
    r += Kp[a];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (t + this.padding).substr(0, 32), o = (e + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, o), this.P = -(1 + (255 ^ r)), this.encryptionKey = df(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = pf(this.encryptionKey, this.padding);
}
function ha(n) {
  if (/[^\u0000-\u00ff]/.test(n)) throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var t = "", e = n.length, i = 0; i < e; i++) {
    var r = n.charCodeAt(i);
    r < 33 || r === 35 || r === 37 || r === 40 || r === 41 || r === 47 || r === 60 || r === 62 || r === 91 || r === 93 || r === 123 || r === 125 || r > 126 ? t += "#" + ("0" + r.toString(16)).slice(-2) : t += n[i];
  }
  return t;
}
function Xp(n) {
  if (nn(n) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var t = {};
  this.subscribe = function(e, i, r) {
    if (r = r || !1, typeof e != "string" || typeof i != "function" || typeof r != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    t.hasOwnProperty(e) || (t[e] = {});
    var s = Math.random().toString(35);
    return t[e][s] = [i, !!r], s;
  }, this.unsubscribe = function(e) {
    for (var i in t) if (t[i][e]) return delete t[i][e], Object.keys(t[i]).length === 0 && delete t[i], !0;
    return !1;
  }, this.publish = function(e) {
    if (t.hasOwnProperty(e)) {
      var i = Array.prototype.slice.call(arguments, 1), r = [];
      for (var s in t[e]) {
        var o = t[e][s];
        try {
          o[0].apply(n, i);
        } catch (a) {
          Le.console && ln.error("jsPDF PubSub Error", a.message, a);
        }
        o[1] && r.push(s);
      }
      r.length && r.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return t;
  };
}
function Ll(n) {
  if (!(this instanceof Ll)) return new Ll(n);
  var t = "opacity,stroke-opacity".split(",");
  for (var e in n) n.hasOwnProperty(e) && t.indexOf(e) >= 0 && (this[e] = n[e]);
  this.id = "", this.objectNumber = -1;
}
function I1(n, t) {
  this.gState = n, this.matrix = t, this.id = "", this.objectNumber = -1;
}
function Es(n, t, e, i, r) {
  if (!(this instanceof Es)) return new Es(n, t, e, i, r);
  this.type = n === "axial" ? 2 : 3, this.coords = t, this.colors = e, I1.call(this, i, r);
}
function fo(n, t, e, i, r) {
  if (!(this instanceof fo)) return new fo(n, t, e, i, r);
  this.boundingBox = n, this.xStep = t, this.yStep = e, this.stream = "", this.cloneIndex = 0, I1.call(this, i, r);
}
function ke(n) {
  var t, e = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], r = arguments[2], s = arguments[3], o = [], a = 1, l = 16, h = "S", u = null;
  nn(n = n || {}) === "object" && (e = n.orientation, i = n.unit || i, r = n.format || r, s = n.compress || n.compressPdf || s, (u = n.encryption || null) !== null && (u.userPassword = u.userPassword || "", u.ownerPassword = u.ownerPassword || "", u.userPermissions = u.userPermissions || []), a = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (t = n.precision), n.floatPrecision !== void 0 && (l = n.floatPrecision), h = n.defaultPathOperation || "S"), o = n.filters || (s === !0 ? ["FlateEncode"] : o), i = i || "mm", e = ("" + (e || "P")).toLowerCase();
  var d = n.putOnlyUsedFonts || !1, p = {}, f = { internal: {}, __private__: {} };
  f.__private__.PubSub = Xp;
  var m = "1.3", b = f.__private__.getPdfVersion = function() {
    return m;
  };
  f.__private__.setPdfVersion = function(w) {
    m = w;
  };
  var x = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  f.__private__.getPageFormats = function() {
    return x;
  };
  var y = f.__private__.getPageFormat = function(w) {
    return x[w];
  };
  r = r || "a4";
  var v = { COMPAT: "compat", ADVANCED: "advanced" }, k = v.COMPAT;
  function C() {
    this.saveGraphicsState(), U(new me(Qt, 0, 0, -Qt, 0, gs() * Qt).toString() + " cm"), this.setFontSize(this.getFontSize() / Qt), h = "n", k = v.ADVANCED;
  }
  function I() {
    this.restoreGraphicsState(), h = "S", k = v.COMPAT;
  }
  var q = f.__private__.combineFontStyleAndFontWeight = function(w, B) {
    if (w == "bold" && B == "normal" || w == "bold" && B == 400 || w == "normal" && B == "italic" || w == "bold" && B == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return B && (w = B == 400 || B === "normal" ? w === "italic" ? "italic" : "normal" : B != 700 && B !== "bold" || w !== "normal" ? (B == 700 ? "bold" : B) + "" + w : "bold"), w;
  };
  f.advancedAPI = function(w) {
    var B = k === v.COMPAT;
    return B && C.call(this), typeof w != "function" || (w(this), B && I.call(this)), this;
  }, f.compatAPI = function(w) {
    var B = k === v.ADVANCED;
    return B && I.call(this), typeof w != "function" || (w(this), B && C.call(this)), this;
  }, f.isAdvancedAPI = function() {
    return k === v.ADVANCED;
  };
  var O, F = function(w) {
    if (k !== v.ADVANCED) throw new Error(w + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, M = f.roundToPrecision = f.__private__.roundToPrecision = function(w, B) {
    var ut = t || B;
    if (isNaN(w) || isNaN(ut)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return w.toFixed(ut).replace(/0+$/, "");
  };
  O = f.hpf = f.__private__.hpf = typeof l == "number" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, l);
  } : l === "smart" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, w > -1 && w < 1 ? 16 : 5);
  } : function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, 16);
  };
  var j = f.f2 = f.__private__.f2 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f2");
    return M(w, 2);
  }, P = f.__private__.f3 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f3");
    return M(w, 3);
  }, A = f.scale = f.__private__.scale = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.scale");
    return k === v.COMPAT ? w * Qt : k === v.ADVANCED ? w : void 0;
  }, T = function(w) {
    return k === v.COMPAT ? gs() - w : k === v.ADVANCED ? w : void 0;
  }, _ = function(w) {
    return A(T(w));
  };
  f.__private__.setPrecision = f.setPrecision = function(w) {
    typeof parseInt(w, 10) == "number" && (t = parseInt(w, 10));
  };
  var Z, V = "00000000000000000000000000000000", R = f.__private__.getFileId = function() {
    return V;
  }, Q = f.__private__.setFileId = function(w) {
    return V = w !== void 0 && /^[a-fA-F0-9]{32}$/.test(w) ? w.toUpperCase() : V.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), u !== null && (Oe = new ca(u.userPermissions, u.userPassword, u.ownerPassword, V)), V;
  };
  f.setFileId = function(w) {
    return Q(w), this;
  }, f.getFileId = function() {
    return R();
  };
  var H = f.__private__.convertDateToPDFDate = function(w) {
    var B = w.getTimezoneOffset(), ut = B < 0 ? "+" : "-", gt = Math.floor(Math.abs(B / 60)), Ct = Math.abs(B % 60), Mt = [ut, G(gt), "'", G(Ct), "'"].join("");
    return ["D:", w.getFullYear(), G(w.getMonth() + 1), G(w.getDate()), G(w.getHours()), G(w.getMinutes()), G(w.getSeconds()), Mt].join("");
  }, ct = f.__private__.convertPDFDateToDate = function(w) {
    var B = parseInt(w.substr(2, 4), 10), ut = parseInt(w.substr(6, 2), 10) - 1, gt = parseInt(w.substr(8, 2), 10), Ct = parseInt(w.substr(10, 2), 10), Mt = parseInt(w.substr(12, 2), 10), Zt = parseInt(w.substr(14, 2), 10);
    return new Date(B, ut, gt, Ct, Mt, Zt, 0);
  }, nt = f.__private__.setCreationDate = function(w) {
    var B;
    if (w === void 0 && (w = /* @__PURE__ */ new Date()), w instanceof Date) B = H(w);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(w)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      B = w;
    }
    return Z = B;
  }, N = f.__private__.getCreationDate = function(w) {
    var B = Z;
    return w === "jsDate" && (B = ct(Z)), B;
  };
  f.setCreationDate = function(w) {
    return nt(w), this;
  }, f.getCreationDate = function(w) {
    return N(w);
  };
  var z, G = f.__private__.padd2 = function(w) {
    return ("0" + parseInt(w)).slice(-2);
  }, Y = f.__private__.padd2Hex = function(w) {
    return ("00" + (w = w.toString())).substr(w.length);
  }, st = 0, vt = [], mt = [], _t = 0, Bt = [], Rt = [], te = !1, Xt = mt, E = function() {
    st = 0, _t = 0, mt = [], vt = [], Bt = [], Qi = yn(), Ci = yn();
  };
  f.__private__.setCustomOutputDestination = function(w) {
    te = !0, Xt = w;
  };
  var ft = function(w) {
    te || (Xt = w);
  };
  f.__private__.resetCustomOutputDestination = function() {
    te = !1, Xt = mt;
  };
  var U = f.__private__.out = function(w) {
    return w = w.toString(), _t += w.length + 1, Xt.push(w), Xt;
  }, et = f.__private__.write = function(w) {
    return U(arguments.length === 1 ? w.toString() : Array.prototype.join.call(arguments, " "));
  }, X = f.__private__.getArrayBuffer = function(w) {
    for (var B = w.length, ut = new ArrayBuffer(B), gt = new Uint8Array(ut); B--; ) gt[B] = w.charCodeAt(B);
    return ut;
  }, rt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  f.__private__.getStandardFonts = function() {
    return rt;
  };
  var wt = n.fontSize || 16;
  f.__private__.setFontSize = f.setFontSize = function(w) {
    return wt = k === v.ADVANCED ? w / Qt : w, this;
  };
  var kt, dt = f.__private__.getFontSize = f.getFontSize = function() {
    return k === v.COMPAT ? wt : wt * Qt;
  }, Pt = n.R2L || !1;
  f.__private__.setR2L = f.setR2L = function(w) {
    return Pt = w, this;
  }, f.__private__.getR2L = f.getR2L = function() {
    return Pt;
  };
  var qt, Ft = f.__private__.setZoomMode = function(w) {
    var B = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(w)) kt = w;
    else if (isNaN(w)) {
      if (B.indexOf(w) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + w + '" is not recognized.');
      kt = w;
    } else kt = parseInt(w, 10);
  };
  f.__private__.getZoomMode = function() {
    return kt;
  };
  var Vt, ne = f.__private__.setPageMode = function(w) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(w) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + w + '" is not recognized.');
    qt = w;
  };
  f.__private__.getPageMode = function() {
    return qt;
  };
  var ie = f.__private__.setLayoutMode = function(w) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(w) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + w + '" is not recognized.');
    Vt = w;
  };
  f.__private__.getLayoutMode = function() {
    return Vt;
  }, f.__private__.setDisplayMode = f.setDisplayMode = function(w, B, ut) {
    return Ft(w), ie(B), ne(ut), this;
  };
  var ue = { title: "", subject: "", author: "", keywords: "", creator: "" };
  f.__private__.getDocumentProperty = function(w) {
    if (Object.keys(ue).indexOf(w) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ue[w];
  }, f.__private__.getDocumentProperties = function() {
    return ue;
  }, f.__private__.setDocumentProperties = f.setProperties = f.setDocumentProperties = function(w) {
    for (var B in ue) ue.hasOwnProperty(B) && w[B] && (ue[B] = w[B]);
    return this;
  }, f.__private__.setDocumentProperty = function(w, B) {
    if (Object.keys(ue).indexOf(w) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ue[w] = B;
  };
  var we, Qt, Ke, ht, jt, Kt = {}, Ht = {}, Ae = [], Jt = {}, Yt = {}, le = {}, Xe = {}, xn = null, Ge = 0, Ne = [], Be = new Xp(f), Di = n.hotfixes || [], pn = {}, Ni = {}, Bi = [], me = function w(B, ut, gt, Ct, Mt, Zt) {
    if (!(this instanceof w)) return new w(B, ut, gt, Ct, Mt, Zt);
    isNaN(B) && (B = 1), isNaN(ut) && (ut = 0), isNaN(gt) && (gt = 0), isNaN(Ct) && (Ct = 1), isNaN(Mt) && (Mt = 0), isNaN(Zt) && (Zt = 0), this._matrix = [B, ut, gt, Ct, Mt, Zt];
  };
  Object.defineProperty(me.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(me.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(me.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(me.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(me.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(me.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(me.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(me.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(me.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(me.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(me.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(me.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(me.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(me.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(me.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(me.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), me.prototype.join = function(w) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O).join(w);
  }, me.prototype.multiply = function(w) {
    var B = w.sx * this.sx + w.shy * this.shx, ut = w.sx * this.shy + w.shy * this.sy, gt = w.shx * this.sx + w.sy * this.shx, Ct = w.shx * this.shy + w.sy * this.sy, Mt = w.tx * this.sx + w.ty * this.shx + this.tx, Zt = w.tx * this.shy + w.ty * this.sy + this.ty;
    return new me(B, ut, gt, Ct, Mt, Zt);
  }, me.prototype.decompose = function() {
    var w = this.sx, B = this.shy, ut = this.shx, gt = this.sy, Ct = this.tx, Mt = this.ty, Zt = Math.sqrt(w * w + B * B), he = (w /= Zt) * ut + (B /= Zt) * gt;
    ut -= w * he, gt -= B * he;
    var xe = Math.sqrt(ut * ut + gt * gt);
    return he /= xe, w * (gt /= xe) < B * (ut /= xe) && (w = -w, B = -B, he = -he, Zt = -Zt), { scale: new me(Zt, 0, 0, xe, 0, 0), translate: new me(1, 0, 0, 1, Ct, Mt), rotate: new me(w, B, -B, w, 0, 0), skew: new me(1, 0, he, 1, 0, 0) };
  }, me.prototype.toString = function(w) {
    return this.join(" ");
  }, me.prototype.inversed = function() {
    var w = this.sx, B = this.shy, ut = this.shx, gt = this.sy, Ct = this.tx, Mt = this.ty, Zt = 1 / (w * gt - B * ut), he = gt * Zt, xe = -B * Zt, Me = -ut * Zt, Te = w * Zt;
    return new me(he, xe, Me, Te, -he * Ct - Me * Mt, -xe * Ct - Te * Mt);
  }, me.prototype.applyToPoint = function(w) {
    var B = w.x * this.sx + w.y * this.shx + this.tx, ut = w.x * this.shy + w.y * this.sy + this.ty;
    return new Bo(B, ut);
  }, me.prototype.applyToRectangle = function(w) {
    var B = this.applyToPoint(w), ut = this.applyToPoint(new Bo(w.x + w.w, w.y + w.h));
    return new $a(B.x, B.y, ut.x - B.x, ut.y - B.y);
  }, me.prototype.clone = function() {
    var w = this.sx, B = this.shy, ut = this.shx, gt = this.sy, Ct = this.tx, Mt = this.ty;
    return new me(w, B, ut, gt, Ct, Mt);
  }, f.Matrix = me;
  var gi = f.matrixMult = function(w, B) {
    return B.multiply(w);
  }, ji = new me(1, 0, 0, 1, 0, 0);
  f.unitMatrix = f.identityMatrix = ji;
  var Qn = function(w, B) {
    if (!Yt[w]) {
      var ut = (B instanceof Es ? "Sh" : "P") + (Object.keys(Jt).length + 1).toString(10);
      B.id = ut, Yt[w] = ut, Jt[ut] = B, Be.publish("addPattern", B);
    }
  };
  f.ShadingPattern = Es, f.TilingPattern = fo, f.addShadingPattern = function(w, B) {
    return F("addShadingPattern()"), Qn(w, B), this;
  }, f.beginTilingPattern = function(w) {
    F("beginTilingPattern()"), Kl(w.boundingBox[0], w.boundingBox[1], w.boundingBox[2] - w.boundingBox[0], w.boundingBox[3] - w.boundingBox[1], w.matrix);
  }, f.endTilingPattern = function(w, B) {
    F("endTilingPattern()"), B.stream = Rt[z].join(`
`), Qn(w, B), Be.publish("endTilingPattern", B), Bi.pop().restore();
  };
  var An = f.__private__.newObject = function() {
    var w = yn();
    return ui(w, !0), w;
  }, yn = f.__private__.newObjectDeferred = function() {
    return st++, vt[st] = function() {
      return _t;
    }, st;
  }, ui = function(w, B) {
    return B = typeof B == "boolean" && B, vt[w] = _t, B && U(w + " 0 obj"), w;
  }, ss = f.__private__.newAdditionalObject = function() {
    var w = { objId: yn(), content: "" };
    return Bt.push(w), w;
  }, Qi = yn(), Ci = yn(), mi = f.__private__.decodeColorString = function(w) {
    var B = w.split(" ");
    if (B.length !== 2 || B[1] !== "g" && B[1] !== "G")
      B.length === 5 && (B[4] === "k" || B[4] === "K") && (B = [(1 - B[0]) * (1 - B[3]), (1 - B[1]) * (1 - B[3]), (1 - B[2]) * (1 - B[3]), "r"]);
    else {
      var ut = parseFloat(B[0]);
      B = [ut, ut, ut, "r"];
    }
    for (var gt = "#", Ct = 0; Ct < 3; Ct++) gt += ("0" + Math.floor(255 * parseFloat(B[Ct])).toString(16)).slice(-2);
    return gt;
  }, Pi = f.__private__.encodeColorString = function(w) {
    var B;
    typeof w == "string" && (w = { ch1: w });
    var ut = w.ch1, gt = w.ch2, Ct = w.ch3, Mt = w.ch4, Zt = w.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ut == "string" && ut.charAt(0) !== "#") {
      var he = new P1(ut);
      if (he.ok) ut = he.toHex();
      else if (!/^\d*\.?\d*$/.test(ut)) throw new Error('Invalid color "' + ut + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof ut == "string" && /^#[0-9A-Fa-f]{3}$/.test(ut) && (ut = "#" + ut[1] + ut[1] + ut[2] + ut[2] + ut[3] + ut[3]), typeof ut == "string" && /^#[0-9A-Fa-f]{6}$/.test(ut)) {
      var xe = parseInt(ut.substr(1), 16);
      ut = xe >> 16 & 255, gt = xe >> 8 & 255, Ct = 255 & xe;
    }
    if (gt === void 0 || Mt === void 0 && ut === gt && gt === Ct) if (typeof ut == "string") B = ut + " " + Zt[0];
    else switch (w.precision) {
      case 2:
        B = j(ut / 255) + " " + Zt[0];
        break;
      case 3:
      default:
        B = P(ut / 255) + " " + Zt[0];
    }
    else if (Mt === void 0 || nn(Mt) === "object") {
      if (Mt && !isNaN(Mt.a) && Mt.a === 0) return B = ["1.", "1.", "1.", Zt[1]].join(" ");
      if (typeof ut == "string") B = [ut, gt, Ct, Zt[1]].join(" ");
      else switch (w.precision) {
        case 2:
          B = [j(ut / 255), j(gt / 255), j(Ct / 255), Zt[1]].join(" ");
          break;
        default:
        case 3:
          B = [P(ut / 255), P(gt / 255), P(Ct / 255), Zt[1]].join(" ");
      }
    } else if (typeof ut == "string") B = [ut, gt, Ct, Mt, Zt[2]].join(" ");
    else switch (w.precision) {
      case 2:
        B = [j(ut), j(gt), j(Ct), j(Mt), Zt[2]].join(" ");
        break;
      case 3:
      default:
        B = [P(ut), P(gt), P(Ct), P(Mt), Zt[2]].join(" ");
    }
    return B;
  }, qi = f.__private__.getFilters = function() {
    return o;
  }, yi = f.__private__.putStream = function(w) {
    var B = (w = w || {}).data || "", ut = w.filters || qi(), gt = w.alreadyAppliedFilters || [], Ct = w.addLength1 || !1, Mt = B.length, Zt = w.objectId, he = function(ei) {
      return ei;
    };
    if (u !== null && Zt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    u !== null && (he = Oe.encryptor(Zt, 0));
    var xe = {};
    ut === !0 && (ut = ["FlateEncode"]);
    var Me = w.additionalKeyValues || [], Te = (xe = ke.API.processDataByFilters !== void 0 ? ke.API.processDataByFilters(B, ut) : { data: B, reverseChain: [] }).reverseChain + (Array.isArray(gt) ? gt.join(" ") : gt.toString());
    if (xe.data.length !== 0 && (Me.push({ key: "Length", value: xe.data.length }), Ct === !0 && Me.push({ key: "Length1", value: Mt })), Te.length != 0) if (Te.split("/").length - 1 == 1) Me.push({ key: "Filter", value: Te });
    else {
      Me.push({ key: "Filter", value: "[" + Te + "]" });
      for (var $e = 0; $e < Me.length; $e += 1) if (Me[$e].key === "DecodeParms") {
        for (var vn = [], _n = 0; _n < xe.reverseChain.split("/").length - 1; _n += 1) vn.push("null");
        vn.push(Me[$e].value), Me[$e].value = "[" + vn.join(" ") + "]";
      }
    }
    U("<<");
    for (var Fn = 0; Fn < Me.length; Fn++) U("/" + Me[Fn].key + " " + Me[Fn].value);
    U(">>"), xe.data.length !== 0 && (U("stream"), U(he(xe.data)), U("endstream"));
  }, tr = f.__private__.putPage = function(w) {
    var B = w.number, ut = w.data, gt = w.objId, Ct = w.contentsObjId;
    ui(gt, !0), U("<</Type /Page"), U("/Parent " + w.rootDictionaryObjId + " 0 R"), U("/Resources " + w.resourceDictionaryObjId + " 0 R"), U("/MediaBox [" + parseFloat(O(w.mediaBox.bottomLeftX)) + " " + parseFloat(O(w.mediaBox.bottomLeftY)) + " " + O(w.mediaBox.topRightX) + " " + O(w.mediaBox.topRightY) + "]"), w.cropBox !== null && U("/CropBox [" + O(w.cropBox.bottomLeftX) + " " + O(w.cropBox.bottomLeftY) + " " + O(w.cropBox.topRightX) + " " + O(w.cropBox.topRightY) + "]"), w.bleedBox !== null && U("/BleedBox [" + O(w.bleedBox.bottomLeftX) + " " + O(w.bleedBox.bottomLeftY) + " " + O(w.bleedBox.topRightX) + " " + O(w.bleedBox.topRightY) + "]"), w.trimBox !== null && U("/TrimBox [" + O(w.trimBox.bottomLeftX) + " " + O(w.trimBox.bottomLeftY) + " " + O(w.trimBox.topRightX) + " " + O(w.trimBox.topRightY) + "]"), w.artBox !== null && U("/ArtBox [" + O(w.artBox.bottomLeftX) + " " + O(w.artBox.bottomLeftY) + " " + O(w.artBox.topRightX) + " " + O(w.artBox.topRightY) + "]"), typeof w.userUnit == "number" && w.userUnit !== 1 && U("/UserUnit " + w.userUnit), Be.publish("putPage", { objId: gt, pageContext: Ne[B], pageNumber: B, page: ut }), U("/Contents " + Ct + " 0 R"), U(">>"), U("endobj");
    var Mt = ut.join(`
`);
    return k === v.ADVANCED && (Mt += `
Q`), ui(Ct, !0), yi({ data: Mt, filters: qi(), objectId: Ct }), U("endobj"), gt;
  }, Dr = f.__private__.putPages = function() {
    var w, B, ut = [];
    for (w = 1; w <= Ge; w++) Ne[w].objId = yn(), Ne[w].contentsObjId = yn();
    for (w = 1; w <= Ge; w++) ut.push(tr({ number: w, data: Rt[w], objId: Ne[w].objId, contentsObjId: Ne[w].contentsObjId, mediaBox: Ne[w].mediaBox, cropBox: Ne[w].cropBox, bleedBox: Ne[w].bleedBox, trimBox: Ne[w].trimBox, artBox: Ne[w].artBox, userUnit: Ne[w].userUnit, rootDictionaryObjId: Qi, resourceDictionaryObjId: Ci }));
    ui(Qi, !0), U("<</Type /Pages");
    var gt = "/Kids [";
    for (B = 0; B < Ge; B++) gt += ut[B] + " 0 R ";
    U(gt + "]"), U("/Count " + Ge), U(">>"), U("endobj"), Be.publish("postPutPages");
  }, Br = function(w) {
    Be.publish("putFont", { font: w, out: U, newObject: An, putStream: yi }), w.isAlreadyPutted !== !0 && (w.objectNumber = An(), U("<<"), U("/Type /Font"), U("/BaseFont /" + ha(w.postScriptName)), U("/Subtype /Type1"), typeof w.encoding == "string" && U("/Encoding /" + w.encoding), U("/FirstChar 32"), U("/LastChar 255"), U(">>"), U("endobj"));
  }, jr = function() {
    for (var w in Kt) Kt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && Br(Kt[w]);
  }, er = function(w) {
    w.objectNumber = An();
    var B = [];
    B.push({ key: "Type", value: "/XObject" }), B.push({ key: "Subtype", value: "/Form" }), B.push({ key: "BBox", value: "[" + [O(w.x), O(w.y), O(w.x + w.width), O(w.y + w.height)].join(" ") + "]" }), B.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" });
    var ut = w.pages[1].join(`
`);
    yi({ data: ut, additionalKeyValues: B, objectId: w.objectNumber }), U("endobj");
  }, qr = function() {
    for (var w in pn) pn.hasOwnProperty(w) && er(pn[w]);
  }, Us = function(w, B) {
    var ut, gt = [], Ct = 1 / (B - 1);
    for (ut = 0; ut < 1; ut += Ct) gt.push(ut);
    if (gt.push(1), w[0].offset != 0) {
      var Mt = { offset: 0, color: w[0].color };
      w.unshift(Mt);
    }
    if (w[w.length - 1].offset != 1) {
      var Zt = { offset: 1, color: w[w.length - 1].color };
      w.push(Zt);
    }
    for (var he = "", xe = 0, Me = 0; Me < gt.length; Me++) {
      for (ut = gt[Me]; ut > w[xe + 1].offset; ) xe++;
      var Te = w[xe].offset, $e = (ut - Te) / (w[xe + 1].offset - Te), vn = w[xe].color, _n = w[xe + 1].color;
      he += Y(Math.round((1 - $e) * vn[0] + $e * _n[0]).toString(16)) + Y(Math.round((1 - $e) * vn[1] + $e * _n[1]).toString(16)) + Y(Math.round((1 - $e) * vn[2] + $e * _n[2]).toString(16));
    }
    return he.trim();
  }, os = function(w, B) {
    B || (B = 21);
    var ut = An(), gt = Us(w.colors, B), Ct = [];
    Ct.push({ key: "FunctionType", value: "0" }), Ct.push({ key: "Domain", value: "[0.0 1.0]" }), Ct.push({ key: "Size", value: "[" + B + "]" }), Ct.push({ key: "BitsPerSample", value: "8" }), Ct.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ct.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), yi({ data: gt, additionalKeyValues: Ct, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: ut }), U("endobj"), w.objectNumber = An(), U("<< /ShadingType " + w.type), U("/ColorSpace /DeviceRGB");
    var Mt = "/Coords [" + O(parseFloat(w.coords[0])) + " " + O(parseFloat(w.coords[1])) + " ";
    w.type === 2 ? Mt += O(parseFloat(w.coords[2])) + " " + O(parseFloat(w.coords[3])) : Mt += O(parseFloat(w.coords[2])) + " " + O(parseFloat(w.coords[3])) + " " + O(parseFloat(w.coords[4])) + " " + O(parseFloat(w.coords[5])), U(Mt += "]"), w.matrix && U("/Matrix [" + w.matrix.toString() + "]"), U("/Function " + ut + " 0 R"), U("/Extend [true true]"), U(">>"), U("endobj");
  }, as = function(w, B) {
    var ut = yn(), gt = An();
    B.push({ resourcesOid: ut, objectOid: gt }), w.objectNumber = gt;
    var Ct = [];
    Ct.push({ key: "Type", value: "/Pattern" }), Ct.push({ key: "PatternType", value: "1" }), Ct.push({ key: "PaintType", value: "1" }), Ct.push({ key: "TilingType", value: "1" }), Ct.push({ key: "BBox", value: "[" + w.boundingBox.map(O).join(" ") + "]" }), Ct.push({ key: "XStep", value: O(w.xStep) }), Ct.push({ key: "YStep", value: O(w.yStep) }), Ct.push({ key: "Resources", value: ut + " 0 R" }), w.matrix && Ct.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" }), yi({ data: w.stream, additionalKeyValues: Ct, objectId: w.objectNumber }), U("endobj");
  }, zr = function(w) {
    var B;
    for (B in Jt) Jt.hasOwnProperty(B) && (Jt[B] instanceof Es ? os(Jt[B]) : Jt[B] instanceof fo && as(Jt[B], w));
  }, To = function(w) {
    for (var B in w.objectNumber = An(), U("<<"), w) switch (B) {
      case "opacity":
        U("/ca " + j(w[B]));
        break;
      case "stroke-opacity":
        U("/CA " + j(w[B]));
    }
    U(">>"), U("endobj");
  }, La = function() {
    var w;
    for (w in le) le.hasOwnProperty(w) && To(le[w]);
  }, vr = function() {
    for (var w in U("/XObject <<"), pn) pn.hasOwnProperty(w) && pn[w].objectNumber >= 0 && U("/" + w + " " + pn[w].objectNumber + " 0 R");
    Be.publish("putXobjectDict"), U(">>");
  }, Ia = function() {
    Oe.oid = An(), U("<<"), U("/Filter /Standard"), U("/V " + Oe.v), U("/R " + Oe.r), U("/U <" + Oe.toHexString(Oe.U) + ">"), U("/O <" + Oe.toHexString(Oe.O) + ">"), U("/P " + Oe.P), U(">>"), U("endobj");
  }, wr = function() {
    for (var w in U("/Font <<"), Kt) Kt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && U("/" + w + " " + Kt[w].objectNumber + " 0 R");
    U(">>");
  }, Ea = function() {
    if (Object.keys(Jt).length > 0) {
      for (var w in U("/Shading <<"), Jt) Jt.hasOwnProperty(w) && Jt[w] instanceof Es && Jt[w].objectNumber >= 0 && U("/" + w + " " + Jt[w].objectNumber + " 0 R");
      Be.publish("putShadingPatternDict"), U(">>");
    }
  }, ls = function(w) {
    if (Object.keys(Jt).length > 0) {
      for (var B in U("/Pattern <<"), Jt) Jt.hasOwnProperty(B) && Jt[B] instanceof f.TilingPattern && Jt[B].objectNumber >= 0 && Jt[B].objectNumber < w && U("/" + B + " " + Jt[B].objectNumber + " 0 R");
      Be.publish("putTilingPatternDict"), U(">>");
    }
  }, Oa = function() {
    if (Object.keys(le).length > 0) {
      var w;
      for (w in U("/ExtGState <<"), le) le.hasOwnProperty(w) && le[w].objectNumber >= 0 && U("/" + w + " " + le[w].objectNumber + " 0 R");
      Be.publish("putGStateDict"), U(">>");
    }
  }, bn = function(w) {
    ui(w.resourcesOid, !0), U("<<"), U("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), wr(), Ea(), ls(w.objectOid), Oa(), vr(), U(">>"), U("endobj");
  }, Ws = function() {
    var w = [];
    jr(), La(), qr(), zr(w), Be.publish("putResources"), w.forEach(bn), bn({ resourcesOid: Ci, objectOid: Number.MAX_SAFE_INTEGER }), Be.publish("postPutResources");
  }, Fo = function() {
    Be.publish("putAdditionalObjects");
    for (var w = 0; w < Bt.length; w++) {
      var B = Bt[w];
      ui(B.objId, !0), U(B.content), U("endobj");
    }
    Be.publish("postPutAdditionalObjects");
  }, Hs = function(w) {
    Ht[w.fontName] = Ht[w.fontName] || {}, Ht[w.fontName][w.fontStyle] = w.id;
  }, Gs = function(w, B, ut, gt, Ct) {
    var Mt = { id: "F" + (Object.keys(Kt).length + 1).toString(10), postScriptName: w, fontName: B, fontStyle: ut, encoding: gt, isStandardFont: Ct || !1, metadata: {} };
    return Be.publish("addFont", { font: Mt, instance: this }), Kt[Mt.id] = Mt, Hs(Mt), Mt.id;
  }, Ta = function(w) {
    for (var B = 0, ut = rt.length; B < ut; B++) {
      var gt = Gs.call(this, w[B][0], w[B][1], w[B][2], rt[B][3], !0);
      d === !1 && (p[gt] = !0);
      var Ct = w[B][0].split("-");
      Hs({ id: gt, fontName: Ct[0], fontStyle: Ct[1] || "" });
    }
    Be.publish("addFonts", { fonts: Kt, dictionary: Ht });
  }, Tn = function(w) {
    return w.foo = function() {
      try {
        return w.apply(this, arguments);
      } catch (gt) {
        var B = gt.stack || "";
        ~B.indexOf(" at ") && (B = B.split(" at ")[1]);
        var ut = "Error in function " + B.split(`
`)[0].split("<")[0] + ": " + gt.message;
        if (!Le.console) throw new Error(ut);
        Le.console.error(ut, gt), Le.alert && alert(ut);
      }
    }, w.foo.bar = w, w.foo;
  }, us = function(w, B) {
    var ut, gt, Ct, Mt, Zt, he, xe, Me, Te;
    if (Ct = (B = B || {}).sourceEncoding || "Unicode", Zt = B.outputEncoding, (B.autoencode || Zt) && Kt[we].metadata && Kt[we].metadata[Ct] && Kt[we].metadata[Ct].encoding && (Mt = Kt[we].metadata[Ct].encoding, !Zt && Kt[we].encoding && (Zt = Kt[we].encoding), !Zt && Mt.codePages && (Zt = Mt.codePages[0]), typeof Zt == "string" && (Zt = Mt[Zt]), Zt)) {
      for (xe = !1, he = [], ut = 0, gt = w.length; ut < gt; ut++) (Me = Zt[w.charCodeAt(ut)]) ? he.push(String.fromCharCode(Me)) : he.push(w[ut]), he[ut].charCodeAt(0) >> 8 && (xe = !0);
      w = he.join("");
    }
    for (ut = w.length; xe === void 0 && ut !== 0; ) w.charCodeAt(ut - 1) >> 8 && (xe = !0), ut--;
    if (!xe) return w;
    for (he = B.noBOM ? [] : [254, 255], ut = 0, gt = w.length; ut < gt; ut++) {
      if ((Te = (Me = w.charCodeAt(ut)) >> 8) >> 8) throw new Error("Character at position " + ut + " of string '" + w + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      he.push(Te), he.push(Me - (Te << 8));
    }
    return String.fromCharCode.apply(void 0, he);
  }, ti = f.__private__.pdfEscape = f.pdfEscape = function(w, B) {
    return us(w, B).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, cs = f.__private__.beginPage = function(w) {
    Rt[++Ge] = [], Ne[Ge] = { objId: 0, contentsObjId: 0, userUnit: Number(a), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(w[0]), topRightY: Number(w[1]) } }, Ys(Ge), ft(Rt[z]);
  }, Vs = function(w, B) {
    var ut, gt, Ct;
    switch (e = B || e, typeof w == "string" && (ut = y(w.toLowerCase()), Array.isArray(ut) && (gt = ut[0], Ct = ut[1])), Array.isArray(w) && (gt = w[0] * Qt, Ct = w[1] * Qt), isNaN(gt) && (gt = r[0], Ct = r[1]), (gt > 14400 || Ct > 14400) && (ln.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), gt = Math.min(14400, gt), Ct = Math.min(14400, Ct)), r = [gt, Ct], e.substr(0, 1)) {
      case "l":
        Ct > gt && (r = [Ct, gt]);
        break;
      case "p":
        gt > Ct && (r = [Ct, gt]);
    }
    cs(r), Wl(Ba), U(nr), qa !== 0 && U(qa + " J"), za !== 0 && U(za + " j"), Be.publish("addPage", { pageNumber: Ge });
  }, hs = function(w) {
    w > 0 && w <= Ge && (Rt.splice(w, 1), Ne.splice(w, 1), Ge--, z > Ge && (z = Ge), this.setPage(z));
  }, Ys = function(w) {
    w > 0 && w <= Ge && (z = w);
  }, Fa = f.__private__.getNumberOfPages = f.getNumberOfPages = function() {
    return Rt.length - 1;
  }, Mo = function(w, B, ut) {
    var gt, Ct = void 0;
    return ut = ut || {}, w = w !== void 0 ? w : Kt[we].fontName, B = B !== void 0 ? B : Kt[we].fontStyle, gt = w.toLowerCase(), Ht[gt] !== void 0 && Ht[gt][B] !== void 0 ? Ct = Ht[gt][B] : Ht[w] !== void 0 && Ht[w][B] !== void 0 ? Ct = Ht[w][B] : ut.disableWarning === !1 && ln.warn("Unable to look up font label for font '" + w + "', '" + B + "'. Refer to getFontList() for available fonts."), Ct || ut.noFallback || (Ct = Ht.times[B]) == null && (Ct = Ht.times.normal), Ct;
  }, Ma = f.__private__.putInfo = function() {
    var w = An(), B = function(gt) {
      return gt;
    };
    for (var ut in u !== null && (B = Oe.encryptor(w, 0)), U("<<"), U("/Producer (" + ti(B("jsPDF " + ke.version)) + ")"), ue) ue.hasOwnProperty(ut) && ue[ut] && U("/" + ut.substr(0, 1).toUpperCase() + ut.substr(1) + " (" + ti(B(ue[ut])) + ")");
    U("/CreationDate (" + ti(B(Z)) + ")"), U(">>"), U("endobj");
  }, at = f.__private__.putCatalog = function(w) {
    var B = (w = w || {}).rootDictionaryObjId || Qi;
    switch (An(), U("<<"), U("/Type /Catalog"), U("/Pages " + B + " 0 R"), kt || (kt = "fullwidth"), kt) {
      case "fullwidth":
        U("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        U("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        U("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        U("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var ut = "" + kt;
        ut.substr(ut.length - 1) === "%" && (kt = parseInt(kt) / 100), typeof kt == "number" && U("/OpenAction [3 0 R /XYZ null null " + j(kt) + "]");
    }
    switch (Vt || (Vt = "continuous"), Vt) {
      case "continuous":
        U("/PageLayout /OneColumn");
        break;
      case "single":
        U("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        U("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        U("/PageLayout /TwoColumnRight");
    }
    qt && U("/PageMode /" + qt), Be.publish("putCatalog"), U(">>"), U("endobj");
  }, pt = f.__private__.putTrailer = function() {
    U("trailer"), U("<<"), U("/Size " + (st + 1)), U("/Root " + st + " 0 R"), U("/Info " + (st - 1) + " 0 R"), u !== null && U("/Encrypt " + Oe.oid + " 0 R"), U("/ID [ <" + V + "> <" + V + "> ]"), U(">>");
  }, xt = f.__private__.putHeader = function() {
    U("%PDF-" + m), U("%ºß¬à");
  }, zt = f.__private__.putXRef = function() {
    var w = "0000000000";
    U("xref"), U("0 " + (st + 1)), U("0000000000 65535 f ");
    for (var B = 1; B <= st; B++)
      typeof vt[B] == "function" ? U((w + vt[B]()).slice(-10) + " 00000 n ") : vt[B] !== void 0 ? U((w + vt[B]).slice(-10) + " 00000 n ") : U("0000000000 00000 n ");
  }, Ot = f.__private__.buildDocument = function() {
    E(), ft(mt), Be.publish("buildDocument"), xt(), Dr(), Fo(), Ws(), u !== null && Ia(), Ma(), at();
    var w = _t;
    return zt(), pt(), U("startxref"), U("" + w), U("%%EOF"), ft(Rt[z]), mt.join(`
`);
  }, pe = f.__private__.getBlob = function(w) {
    return new Blob([X(w)], { type: "application/pdf" });
  }, ce = f.output = f.__private__.output = Tn(function(w, B) {
    switch (typeof (B = B || {}) == "string" ? B = { filename: B } : B.filename = B.filename || "generated.pdf", w) {
      case void 0:
        return Ot();
      case "save":
        f.save(B.filename);
        break;
      case "arraybuffer":
        return X(Ot());
      case "blob":
        return pe(Ot());
      case "bloburi":
      case "bloburl":
        if (Le.URL !== void 0 && typeof Le.URL.createObjectURL == "function") return Le.URL && Le.URL.createObjectURL(pe(Ot())) || void 0;
        ln.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var ut = "", gt = Ot();
        try {
          ut = ff(gt);
        } catch {
          ut = ff(unescape(encodeURIComponent(gt)));
        }
        return "data:application/pdf;filename=" + B.filename + ";base64," + ut;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Le) === "[object Window]") {
          var Ct = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Mt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          B.pdfObjectUrl && (Ct = B.pdfObjectUrl, Mt = "");
          var Zt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ct + '"' + Mt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(B) + ");<\/script></body></html>", he = Le.open();
          return he !== null && he.document.write(Zt), he;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Le) === "[object Window]") {
          var xe = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (B.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + B.filename + '" width="500px" height="400px" /></body></html>', Me = Le.open();
          if (Me !== null) {
            Me.document.write(xe);
            var Te = this;
            Me.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Me.document.title = B.filename, Me.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Te.output("bloburl"));
            };
          }
          return Me;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Le) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var $e = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", B) + '"></iframe></body></html>', vn = Le.open();
        if (vn !== null && (vn.document.write($e), vn.document.title = B.filename), vn || typeof safari > "u") return vn;
        break;
      case "datauri":
      case "dataurl":
        return Le.document.location.href = this.output("datauristring", B);
      default:
        return null;
    }
  }), _e = function(w) {
    return Array.isArray(Di) === !0 && Di.indexOf(w) > -1;
  };
  switch (i) {
    case "pt":
      Qt = 1;
      break;
    case "mm":
      Qt = 72 / 25.4;
      break;
    case "cm":
      Qt = 72 / 2.54;
      break;
    case "in":
      Qt = 72;
      break;
    case "px":
      Qt = _e("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Qt = 12;
      break;
    case "ex":
      Qt = 6;
      break;
    default:
      if (typeof i != "number") throw new Error("Invalid unit: " + i);
      Qt = i;
  }
  var Oe = null;
  nt(), Q();
  var un = function(w) {
    return u !== null ? Oe.encryptor(w, 0) : function(B) {
      return B;
    };
  }, Ee = f.__private__.getPageInfo = f.getPageInfo = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Ne[w].objId, pageNumber: w, pageContext: Ne[w] };
  }, ae = f.__private__.getPageInfoByObjId = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var B in Ne) if (Ne[B].objId === w) break;
    return Ee(B);
  }, ve = f.__private__.getCurrentPageInfo = f.getCurrentPageInfo = function() {
    return { objId: Ne[z].objId, pageNumber: z, pageContext: Ne[z] };
  };
  f.addPage = function() {
    return Vs.apply(this, arguments), this;
  }, f.setPage = function() {
    return Ys.apply(this, arguments), ft.call(this, Rt[z]), this;
  }, f.insertPage = function(w) {
    return this.addPage(), this.movePage(z, w), this;
  }, f.movePage = function(w, B) {
    var ut, gt;
    if (w > B) {
      ut = Rt[w], gt = Ne[w];
      for (var Ct = w; Ct > B; Ct--) Rt[Ct] = Rt[Ct - 1], Ne[Ct] = Ne[Ct - 1];
      Rt[B] = ut, Ne[B] = gt, this.setPage(B);
    } else if (w < B) {
      ut = Rt[w], gt = Ne[w];
      for (var Mt = w; Mt < B; Mt++) Rt[Mt] = Rt[Mt + 1], Ne[Mt] = Ne[Mt + 1];
      Rt[B] = ut, Ne[B] = gt, this.setPage(B);
    }
    return this;
  }, f.deletePage = function() {
    return hs.apply(this, arguments), this;
  }, f.__private__.text = f.text = function(w, B, ut, gt, Ct) {
    var Mt, Zt, he, xe, Me, Te, $e, vn, _n, Fn = (gt = gt || {}).scope || this;
    if (typeof w == "number" && typeof B == "number" && (typeof ut == "string" || Array.isArray(ut))) {
      var ei = ut;
      ut = B, B = w, w = ei;
    }
    if (arguments[3] instanceof me ? (F("The transform parameter of text() with a Matrix value"), _n = Ct) : (he = arguments[4], xe = arguments[5], nn($e = arguments[3]) === "object" && $e !== null || (typeof he == "string" && (xe = he, he = null), typeof $e == "string" && (xe = $e, $e = null), typeof $e == "number" && (he = $e, $e = null), gt = { flags: $e, angle: he, align: xe })), isNaN(B) || isNaN(ut) || w == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (w.length === 0) return Fn;
    var zn = "", ir = !1, Ii = typeof gt.lineHeightFactor == "number" ? gt.lineHeightFactor : Js, _r = Fn.internal.scaleFactor;
    function Xl(cn) {
      return cn = cn.split("	").join(Array(gt.TabLen || 9).join(" ")), ti(cn, $e);
    }
    function Ga(cn) {
      for (var hn, Cn = cn.concat(), Bn = [], Vr = Cn.length; Vr--; ) typeof (hn = Cn.shift()) == "string" ? Bn.push(hn) : Array.isArray(cn) && (hn.length === 1 || hn[1] === void 0 && hn[2] === void 0) ? Bn.push(hn[0]) : Bn.push([hn[0], hn[1], hn[2]]);
      return Bn;
    }
    function Va(cn, hn) {
      var Cn;
      if (typeof cn == "string") Cn = hn(cn)[0];
      else if (Array.isArray(cn)) {
        for (var Bn, Vr, el = cn.concat(), Ko = [], eu = el.length; eu--; ) typeof (Bn = el.shift()) == "string" ? Ko.push(hn(Bn)[0]) : Array.isArray(Bn) && typeof Bn[0] == "string" && (Vr = hn(Bn[0], Bn[1], Bn[2]), Ko.push([Vr[0], Vr[1], Vr[2]]));
        Cn = Ko;
      }
      return Cn;
    }
    var qo = !1, Ya = !0;
    if (typeof w == "string") qo = !0;
    else if (Array.isArray(w)) {
      var Ka = w.concat();
      Zt = [];
      for (var zo, Vn = Ka.length; Vn--; ) (typeof (zo = Ka.shift()) != "string" || Array.isArray(zo) && typeof zo[0] != "string") && (Ya = !1);
      qo = Ya;
    }
    if (qo === !1) throw new Error('Type of text must be string or Array. "' + w + '" is not recognized.');
    typeof w == "string" && (w = w.match(/[\r?\n]/) ? w.split(/\r\n|\r|\n/g) : [w]);
    var $o = wt / Fn.internal.scaleFactor, Uo = $o * (Ii - 1);
    switch (gt.baseline) {
      case "bottom":
        ut -= Uo;
        break;
      case "top":
        ut += $o - Uo;
        break;
      case "hanging":
        ut += $o - 2 * Uo;
        break;
      case "middle":
        ut += $o / 2 - Uo;
    }
    if ((Te = gt.maxWidth || 0) > 0 && (typeof w == "string" ? w = Fn.splitTextToSize(w, Te) : Object.prototype.toString.call(w) === "[object Array]" && (w = w.reduce(function(cn, hn) {
      return cn.concat(Fn.splitTextToSize(hn, Te));
    }, []))), Mt = { text: w, x: B, y: ut, options: gt, mutex: { pdfEscape: ti, activeFontKey: we, fonts: Kt, activeFontSize: wt } }, Be.publish("preProcessText", Mt), w = Mt.text, he = (gt = Mt.options).angle, !(_n instanceof me) && he && typeof he == "number") {
      he *= Math.PI / 180, gt.rotationDirection === 0 && (he = -he), k === v.ADVANCED && (he = -he);
      var Wo = Math.cos(he), Xa = Math.sin(he);
      _n = new me(Wo, Xa, -Xa, Wo, 0, 0);
    } else he && he instanceof me && (_n = he);
    k !== v.ADVANCED || _n || (_n = ji), (Me = gt.charSpace || Do) !== void 0 && (zn += O(A(Me)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (vn = gt.horizontalScale) !== void 0 && (zn += O(100 * vn) + ` Tz
`), gt.lang;
    var bi = -1, Zc = gt.renderingMode !== void 0 ? gt.renderingMode : gt.stroke, Ja = Fn.internal.getCurrentPageInfo().pageContext;
    switch (Zc) {
      case 0:
      case !1:
      case "fill":
        bi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        bi = 1;
        break;
      case 2:
      case "fillThenStroke":
        bi = 2;
        break;
      case 3:
      case "invisible":
        bi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        bi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        bi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        bi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        bi = 7;
    }
    var Jl = Ja.usedRenderingMode !== void 0 ? Ja.usedRenderingMode : -1;
    bi !== -1 ? zn += bi + ` Tr
` : Jl !== -1 && (zn += `0 Tr
`), bi !== -1 && (Ja.usedRenderingMode = bi), xe = gt.align || "left";
    var $i, Ho = wt * Ii, Zl = Fn.internal.pageSize.getWidth(), Ql = Kt[we];
    Me = gt.charSpace || Do, Te = gt.maxWidth || 0, $e = Object.assign({ autoencode: !0, noBOM: !0 }, gt.flags);
    var ms = [], to = function(cn) {
      return Fn.getStringUnitWidth(cn, { font: Ql, charSpace: Me, fontSize: wt, doKerning: !1 }) * wt / _r;
    };
    if (Object.prototype.toString.call(w) === "[object Array]") {
      var vi;
      Zt = Ga(w), xe !== "left" && ($i = Zt.map(to));
      var ci, ys = 0;
      if (xe === "right") {
        B -= $i[0], w = [], Vn = Zt.length;
        for (var Wr = 0; Wr < Vn; Wr++) Wr === 0 ? (ci = xr(B), vi = Ur(ut)) : (ci = A(ys - $i[Wr]), vi = -Ho), w.push([Zt[Wr], ci, vi]), ys = $i[Wr];
      } else if (xe === "center") {
        B -= $i[0] / 2, w = [], Vn = Zt.length;
        for (var Hr = 0; Hr < Vn; Hr++) Hr === 0 ? (ci = xr(B), vi = Ur(ut)) : (ci = A((ys - $i[Hr]) / 2), vi = -Ho), w.push([Zt[Hr], ci, vi]), ys = $i[Hr];
      } else if (xe === "left") {
        w = [], Vn = Zt.length;
        for (var Go = 0; Go < Vn; Go++) w.push(Zt[Go]);
      } else if (xe === "justify" && Ql.encoding === "Identity-H") {
        w = [], Vn = Zt.length, Te = Te !== 0 ? Te : Zl;
        for (var Gr = 0, Nn = 0; Nn < Vn; Nn++) if (vi = Nn === 0 ? Ur(ut) : -Ho, ci = Nn === 0 ? xr(B) : Gr, Nn < Vn - 1) {
          var Za = A((Te - $i[Nn]) / (Zt[Nn].split(" ").length - 1)), hi = Zt[Nn].split(" ");
          w.push([hi[0] + " ", ci, vi]), Gr = 0;
          for (var Ui = 1; Ui < hi.length; Ui++) {
            var Vo = (to(hi[Ui - 1] + " " + hi[Ui]) - to(hi[Ui])) * _r + Za;
            Ui == hi.length - 1 ? w.push([hi[Ui], Vo, 0]) : w.push([hi[Ui] + " ", Vo, 0]), Gr -= Vo;
          }
        } else w.push([Zt[Nn], ci, vi]);
        w.push(["", Gr, 0]);
      } else {
        if (xe !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (w = [], Vn = Zt.length, Te = Te !== 0 ? Te : Zl, Nn = 0; Nn < Vn; Nn++) vi = Nn === 0 ? Ur(ut) : -Ho, ci = Nn === 0 ? xr(B) : 0, Nn < Vn - 1 ? ms.push(O(A((Te - $i[Nn]) / (Zt[Nn].split(" ").length - 1)))) : ms.push(0), w.push([Zt[Nn], ci, vi]);
      }
    }
    var tu = typeof gt.R2L == "boolean" ? gt.R2L : Pt;
    tu === !0 && (w = Va(w, function(cn, hn, Cn) {
      return [cn.split("").reverse().join(""), hn, Cn];
    })), Mt = { text: w, x: B, y: ut, options: gt, mutex: { pdfEscape: ti, activeFontKey: we, fonts: Kt, activeFontSize: wt } }, Be.publish("postProcessText", Mt), w = Mt.text, ir = Mt.mutex.isHex || !1;
    var Qa = Kt[we].encoding;
    Qa !== "WinAnsiEncoding" && Qa !== "StandardEncoding" || (w = Va(w, function(cn, hn, Cn) {
      return [Xl(cn), hn, Cn];
    })), Zt = Ga(w), w = [];
    for (var eo, no, bs, io = 0, Yo = 1, ro = Array.isArray(Zt[0]) ? Yo : io, vs = "", tl = function(cn, hn, Cn) {
      var Bn = "";
      return Cn instanceof me ? (Cn = typeof gt.angle == "number" ? gi(Cn, new me(1, 0, 0, 1, cn, hn)) : gi(new me(1, 0, 0, 1, cn, hn), Cn), k === v.ADVANCED && (Cn = gi(new me(1, 0, 0, -1, 0, 0), Cn)), Bn = Cn.join(" ") + ` Tm
`) : Bn = O(cn) + " " + O(hn) + ` Td
`, Bn;
    }, Wi = 0; Wi < Zt.length; Wi++) {
      switch (vs = "", ro) {
        case Yo:
          bs = (ir ? "<" : "(") + Zt[Wi][0] + (ir ? ">" : ")"), eo = parseFloat(Zt[Wi][1]), no = parseFloat(Zt[Wi][2]);
          break;
        case io:
          bs = (ir ? "<" : "(") + Zt[Wi] + (ir ? ">" : ")"), eo = xr(B), no = Ur(ut);
      }
      ms !== void 0 && ms[Wi] !== void 0 && (vs = ms[Wi] + ` Tw
`), Wi === 0 ? w.push(vs + tl(eo, no, _n) + bs) : ro === io ? w.push(vs + bs) : ro === Yo && w.push(vs + tl(eo, no, _n) + bs);
    }
    w = ro === io ? w.join(` Tj
T* `) : w.join(` Tj
`), w += ` Tj
`;
    var Hi = `BT
/`;
    return Hi += we + " " + wt + ` Tf
`, Hi += O(wt * Ii) + ` TL
`, Hi += Zs + `
`, Hi += zn, Hi += w, U(Hi += "ET"), p[we] = !0, Fn;
  };
  var Li = f.__private__.clip = f.clip = function(w) {
    return U(w === "evenodd" ? "W*" : "W"), this;
  };
  f.clipEvenOdd = function() {
    return Li("evenodd");
  }, f.__private__.discardPath = f.discardPath = function() {
    return U("n"), this;
  };
  var zi = f.__private__.isValidStyle = function(w) {
    var B = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(w) !== -1 && (B = !0), B;
  };
  f.__private__.setDefaultPathOperation = f.setDefaultPathOperation = function(w) {
    return zi(w) && (h = w), this;
  };
  var fs = f.__private__.getStyle = f.getStyle = function(w) {
    var B = h;
    switch (w) {
      case "D":
      case "S":
        B = "S";
        break;
      case "F":
        B = "f";
        break;
      case "FD":
      case "DF":
        B = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        B = w;
    }
    return B;
  }, Ks = f.close = function() {
    return U("h"), this;
  };
  f.stroke = function() {
    return U("S"), this;
  }, f.fill = function(w) {
    return $r("f", w), this;
  }, f.fillEvenOdd = function(w) {
    return $r("f*", w), this;
  }, f.fillStroke = function(w) {
    return $r("B", w), this;
  }, f.fillStrokeEvenOdd = function(w) {
    return $r("B*", w), this;
  };
  var $r = function(w, B) {
    nn(B) === "object" ? Hc(B, w) : U(w);
  }, Ra = function(w) {
    w === null || k === v.ADVANCED && w === void 0 || (w = fs(w), U(w));
  };
  function Wc(w, B, ut, gt, Ct) {
    var Mt = new fo(B || this.boundingBox, ut || this.xStep, gt || this.yStep, this.gState, Ct || this.matrix);
    Mt.stream = this.stream;
    var Zt = w + "$$" + this.cloneIndex++ + "$$";
    return Qn(Zt, Mt), Mt;
  }
  var Hc = function(w, B) {
    var ut = Yt[w.key], gt = Jt[ut];
    if (gt instanceof Es) U("q"), U(Gc(B)), gt.gState && f.setGState(gt.gState), U(w.matrix.toString() + " cm"), U("/" + ut + " sh"), U("Q");
    else if (gt instanceof fo) {
      var Ct = new me(1, 0, 0, -1, 0, gs());
      w.matrix && (Ct = Ct.multiply(w.matrix || ji), ut = Wc.call(gt, w.key, w.boundingBox, w.xStep, w.yStep, Ct).id), U("q"), U("/Pattern cs"), U("/" + ut + " scn"), gt.gState && f.setGState(gt.gState), U(B), U("Q");
    }
  }, Gc = function(w) {
    switch (w) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Da = f.moveTo = function(w, B) {
    return U(O(A(w)) + " " + O(_(B)) + " m"), this;
  }, Xs = f.lineTo = function(w, B) {
    return U(O(A(w)) + " " + O(_(B)) + " l"), this;
  }, ds = f.curveTo = function(w, B, ut, gt, Ct, Mt) {
    return U([O(A(w)), O(_(B)), O(A(ut)), O(_(gt)), O(A(Ct)), O(_(Mt)), "c"].join(" ")), this;
  };
  f.__private__.line = f.line = function(w, B, ut, gt, Ct) {
    if (isNaN(w) || isNaN(B) || isNaN(ut) || isNaN(gt) || !zi(Ct)) throw new Error("Invalid arguments passed to jsPDF.line");
    return k === v.COMPAT ? this.lines([[ut - w, gt - B]], w, B, [1, 1], Ct || "S") : this.lines([[ut - w, gt - B]], w, B, [1, 1]).stroke();
  }, f.__private__.lines = f.lines = function(w, B, ut, gt, Ct, Mt) {
    var Zt, he, xe, Me, Te, $e, vn, _n, Fn, ei, zn, ir;
    if (typeof w == "number" && (ir = ut, ut = B, B = w, w = ir), gt = gt || [1, 1], Mt = Mt || !1, isNaN(B) || isNaN(ut) || !Array.isArray(w) || !Array.isArray(gt) || !zi(Ct) || typeof Mt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Da(B, ut), Zt = gt[0], he = gt[1], Me = w.length, ei = B, zn = ut, xe = 0; xe < Me; xe++) (Te = w[xe]).length === 2 ? (ei = Te[0] * Zt + ei, zn = Te[1] * he + zn, Xs(ei, zn)) : ($e = Te[0] * Zt + ei, vn = Te[1] * he + zn, _n = Te[2] * Zt + ei, Fn = Te[3] * he + zn, ei = Te[4] * Zt + ei, zn = Te[5] * he + zn, ds($e, vn, _n, Fn, ei, zn));
    return Mt && Ks(), Ra(Ct), this;
  }, f.path = function(w) {
    for (var B = 0; B < w.length; B++) {
      var ut = w[B], gt = ut.c;
      switch (ut.op) {
        case "m":
          Da(gt[0], gt[1]);
          break;
        case "l":
          Xs(gt[0], gt[1]);
          break;
        case "c":
          ds.apply(this, gt);
          break;
        case "h":
          Ks();
      }
    }
    return this;
  }, f.__private__.rect = f.rect = function(w, B, ut, gt, Ct) {
    if (isNaN(w) || isNaN(B) || isNaN(ut) || isNaN(gt) || !zi(Ct)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return k === v.COMPAT && (gt = -gt), U([O(A(w)), O(_(B)), O(A(ut)), O(A(gt)), "re"].join(" ")), Ra(Ct), this;
  }, f.__private__.triangle = f.triangle = function(w, B, ut, gt, Ct, Mt, Zt) {
    if (isNaN(w) || isNaN(B) || isNaN(ut) || isNaN(gt) || isNaN(Ct) || isNaN(Mt) || !zi(Zt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[ut - w, gt - B], [Ct - ut, Mt - gt], [w - Ct, B - Mt]], w, B, [1, 1], Zt, !0), this;
  }, f.__private__.roundedRect = f.roundedRect = function(w, B, ut, gt, Ct, Mt, Zt) {
    if (isNaN(w) || isNaN(B) || isNaN(ut) || isNaN(gt) || isNaN(Ct) || isNaN(Mt) || !zi(Zt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var he = 4 / 3 * (Math.SQRT2 - 1);
    return Ct = Math.min(Ct, 0.5 * ut), Mt = Math.min(Mt, 0.5 * gt), this.lines([[ut - 2 * Ct, 0], [Ct * he, 0, Ct, Mt - Mt * he, Ct, Mt], [0, gt - 2 * Mt], [0, Mt * he, -Ct * he, Mt, -Ct, Mt], [2 * Ct - ut, 0], [-Ct * he, 0, -Ct, -Mt * he, -Ct, -Mt], [0, 2 * Mt - gt], [0, -Mt * he, Ct * he, -Mt, Ct, -Mt]], w + Ct, B, [1, 1], Zt, !0), this;
  }, f.__private__.ellipse = f.ellipse = function(w, B, ut, gt, Ct) {
    if (isNaN(w) || isNaN(B) || isNaN(ut) || isNaN(gt) || !zi(Ct)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Mt = 4 / 3 * (Math.SQRT2 - 1) * ut, Zt = 4 / 3 * (Math.SQRT2 - 1) * gt;
    return Da(w + ut, B), ds(w + ut, B - Zt, w + Mt, B - gt, w, B - gt), ds(w - Mt, B - gt, w - ut, B - Zt, w - ut, B), ds(w - ut, B + Zt, w - Mt, B + gt, w, B + gt), ds(w + Mt, B + gt, w + ut, B + Zt, w + ut, B), Ra(Ct), this;
  }, f.__private__.circle = f.circle = function(w, B, ut, gt) {
    if (isNaN(w) || isNaN(B) || isNaN(ut) || !zi(gt)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(w, B, ut, ut, gt);
  }, f.setFont = function(w, B, ut) {
    return ut && (B = q(B, ut)), we = Mo(w, B, { disableWarning: !1 }), this;
  };
  var Vc = f.__private__.getFont = f.getFont = function() {
    return Kt[Mo.apply(f, arguments)];
  };
  f.__private__.getFontList = f.getFontList = function() {
    var w, B, ut = {};
    for (w in Ht) if (Ht.hasOwnProperty(w)) for (B in ut[w] = [], Ht[w]) Ht[w].hasOwnProperty(B) && ut[w].push(B);
    return ut;
  }, f.addFont = function(w, B, ut, gt, Ct) {
    var Mt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Mt.indexOf(arguments[3]) !== -1 ? Ct = arguments[3] : arguments[3] && Mt.indexOf(arguments[3]) == -1 && (ut = q(ut, gt)), Ct = Ct || "Identity-H", Gs.call(this, w, B, ut, Ct);
  };
  var Js, Ba = n.lineWidth || 0.200025, Ro = f.__private__.getLineWidth = f.getLineWidth = function() {
    return Ba;
  }, Wl = f.__private__.setLineWidth = f.setLineWidth = function(w) {
    return Ba = w, U(O(A(w)) + " w"), this;
  };
  f.__private__.setLineDash = ke.API.setLineDash = ke.API.setLineDashPattern = function(w, B) {
    if (w = w || [], B = B || 0, isNaN(B) || !Array.isArray(w)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return w = w.map(function(ut) {
      return O(A(ut));
    }).join(" "), B = O(A(B)), U("[" + w + "] " + B + " d"), this;
  };
  var Hl = f.__private__.getLineHeight = f.getLineHeight = function() {
    return wt * Js;
  };
  f.__private__.getLineHeight = f.getLineHeight = function() {
    return wt * Js;
  };
  var Gl = f.__private__.setLineHeightFactor = f.setLineHeightFactor = function(w) {
    return typeof (w = w || 1.15) == "number" && (Js = w), this;
  }, Vl = f.__private__.getLineHeightFactor = f.getLineHeightFactor = function() {
    return Js;
  };
  Gl(n.lineHeight);
  var xr = f.__private__.getHorizontalCoordinate = function(w) {
    return A(w);
  }, Ur = f.__private__.getVerticalCoordinate = function(w) {
    return k === v.ADVANCED ? w : Ne[z].mediaBox.topRightY - Ne[z].mediaBox.bottomLeftY - A(w);
  }, Yc = f.__private__.getHorizontalCoordinateString = f.getHorizontalCoordinateString = function(w) {
    return O(xr(w));
  }, ps = f.__private__.getVerticalCoordinateString = f.getVerticalCoordinateString = function(w) {
    return O(Ur(w));
  }, nr = n.strokeColor || "0 G";
  f.__private__.getStrokeColor = f.getDrawColor = function() {
    return mi(nr);
  }, f.__private__.setStrokeColor = f.setDrawColor = function(w, B, ut, gt) {
    return nr = Pi({ ch1: w, ch2: B, ch3: ut, ch4: gt, pdfColorType: "draw", precision: 2 }), U(nr), this;
  };
  var ja = n.fillColor || "0 g";
  f.__private__.getFillColor = f.getFillColor = function() {
    return mi(ja);
  }, f.__private__.setFillColor = f.setFillColor = function(w, B, ut, gt) {
    return ja = Pi({ ch1: w, ch2: B, ch3: ut, ch4: gt, pdfColorType: "fill", precision: 2 }), U(ja), this;
  };
  var Zs = n.textColor || "0 g", Kc = f.__private__.getTextColor = f.getTextColor = function() {
    return mi(Zs);
  };
  f.__private__.setTextColor = f.setTextColor = function(w, B, ut, gt) {
    return Zs = Pi({ ch1: w, ch2: B, ch3: ut, ch4: gt, pdfColorType: "text", precision: 3 }), this;
  };
  var Do = n.charSpace, Xc = f.__private__.getCharSpace = f.getCharSpace = function() {
    return parseFloat(Do || 0);
  };
  f.__private__.setCharSpace = f.setCharSpace = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Do = w, this;
  };
  var qa = 0;
  f.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, f.__private__.setLineCap = f.setLineCap = function(w) {
    var B = f.CapJoinStyles[w];
    if (B === void 0) throw new Error("Line cap style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return qa = B, U(B + " J"), this;
  };
  var za = 0;
  f.__private__.setLineJoin = f.setLineJoin = function(w) {
    var B = f.CapJoinStyles[w];
    if (B === void 0) throw new Error("Line join style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return za = B, U(B + " j"), this;
  }, f.__private__.setLineMiterLimit = f.__private__.setMiterLimit = f.setLineMiterLimit = f.setMiterLimit = function(w) {
    if (w = w || 0, isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return U(O(A(w)) + " M"), this;
  }, f.GState = Ll, f.setGState = function(w) {
    (w = typeof w == "string" ? le[Xe[w]] : Yl(null, w)).equals(xn) || (U("/" + w.id + " gs"), xn = w);
  };
  var Yl = function(w, B) {
    if (!w || !Xe[w]) {
      var ut = !1;
      for (var gt in le) if (le.hasOwnProperty(gt) && le[gt].equals(B)) {
        ut = !0;
        break;
      }
      if (ut) B = le[gt];
      else {
        var Ct = "GS" + (Object.keys(le).length + 1).toString(10);
        le[Ct] = B, B.id = Ct;
      }
      return w && (Xe[w] = B.id), Be.publish("addGState", B), B;
    }
  };
  f.addGState = function(w, B) {
    return Yl(w, B), this;
  }, f.saveGraphicsState = function() {
    return U("q"), Ae.push({ key: we, size: wt, color: Zs }), this;
  }, f.restoreGraphicsState = function() {
    U("Q");
    var w = Ae.pop();
    return we = w.key, wt = w.size, Zs = w.color, xn = null, this;
  }, f.setCurrentTransformationMatrix = function(w) {
    return U(w.toString() + " cm"), this;
  }, f.comment = function(w) {
    return U("#" + w), this;
  };
  var Bo = function(w, B) {
    var ut = w || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return ut;
    }, set: function(Mt) {
      isNaN(Mt) || (ut = parseFloat(Mt));
    } });
    var gt = B || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return gt;
    }, set: function(Mt) {
      isNaN(Mt) || (gt = parseFloat(Mt));
    } });
    var Ct = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Mt) {
      Ct = Mt.toString();
    } }), this;
  }, $a = function(w, B, ut, gt) {
    Bo.call(this, w, B), this.type = "rect";
    var Ct = ut || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Zt) {
      isNaN(Zt) || (Ct = parseFloat(Zt));
    } });
    var Mt = gt || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Mt;
    }, set: function(Zt) {
      isNaN(Zt) || (Mt = parseFloat(Zt));
    } }), this;
  }, Ua = function() {
    this.page = Ge, this.currentPage = z, this.pages = Rt.slice(0), this.pagesContext = Ne.slice(0), this.x = Ke, this.y = ht, this.matrix = jt, this.width = Qs(z), this.height = gs(z), this.outputDestination = Xt, this.id = "", this.objectNumber = -1;
  };
  Ua.prototype.restore = function() {
    Ge = this.page, z = this.currentPage, Ne = this.pagesContext, Rt = this.pages, Ke = this.x, ht = this.y, jt = this.matrix, Wa(z, this.width), Ha(z, this.height), Xt = this.outputDestination;
  };
  var Kl = function(w, B, ut, gt, Ct) {
    Bi.push(new Ua()), Ge = z = 0, Rt = [], Ke = w, ht = B, jt = Ct, cs([ut, gt]);
  }, Jc = function(w) {
    if (Ni[w]) Bi.pop().restore();
    else {
      var B = new Ua(), ut = "Xo" + (Object.keys(pn).length + 1).toString(10);
      B.id = ut, Ni[w] = ut, pn[ut] = B, Be.publish("addFormObject", B), Bi.pop().restore();
    }
  };
  for (var jo in f.beginFormObject = function(w, B, ut, gt, Ct) {
    return Kl(w, B, ut, gt, Ct), this;
  }, f.endFormObject = function(w) {
    return Jc(w), this;
  }, f.doFormObject = function(w, B) {
    var ut = pn[Ni[w]];
    return U("q"), U(B.toString() + " cm"), U("/" + ut.id + " Do"), U("Q"), this;
  }, f.getFormObject = function(w) {
    var B = pn[Ni[w]];
    return { x: B.x, y: B.y, width: B.width, height: B.height, matrix: B.matrix };
  }, f.save = function(w, B) {
    return w = w || "generated.pdf", (B = B || {}).returnPromise = B.returnPromise || !1, B.returnPromise === !1 ? (ao(pe(Ot()), w), typeof ao.unload == "function" && Le.setTimeout && setTimeout(ao.unload, 911), this) : new Promise(function(ut, gt) {
      try {
        var Ct = ao(pe(Ot()), w);
        typeof ao.unload == "function" && Le.setTimeout && setTimeout(ao.unload, 911), ut(Ct);
      } catch (Mt) {
        gt(Mt.message);
      }
    });
  }, ke.API) ke.API.hasOwnProperty(jo) && (jo === "events" && ke.API.events.length ? function(w, B) {
    var ut, gt, Ct;
    for (Ct = B.length - 1; Ct !== -1; Ct--) ut = B[Ct][0], gt = B[Ct][1], w.subscribe.apply(w, [ut].concat(typeof gt == "function" ? [gt] : gt));
  }(Be, ke.API.events) : f[jo] = ke.API[jo]);
  var Qs = f.getPageWidth = function(w) {
    return (Ne[w = w || z].mediaBox.topRightX - Ne[w].mediaBox.bottomLeftX) / Qt;
  }, Wa = f.setPageWidth = function(w, B) {
    Ne[w].mediaBox.topRightX = B * Qt + Ne[w].mediaBox.bottomLeftX;
  }, gs = f.getPageHeight = function(w) {
    return (Ne[w = w || z].mediaBox.topRightY - Ne[w].mediaBox.bottomLeftY) / Qt;
  }, Ha = f.setPageHeight = function(w, B) {
    Ne[w].mediaBox.topRightY = B * Qt + Ne[w].mediaBox.bottomLeftY;
  };
  return f.internal = { pdfEscape: ti, getStyle: fs, getFont: Vc, getFontSize: dt, getCharSpace: Xc, getTextColor: Kc, getLineHeight: Hl, getLineHeightFactor: Vl, getLineWidth: Ro, write: et, getHorizontalCoordinate: xr, getVerticalCoordinate: Ur, getCoordinateString: Yc, getVerticalCoordinateString: ps, collections: {}, newObject: An, newAdditionalObject: ss, newObjectDeferred: yn, newObjectDeferredBegin: ui, getFilters: qi, putStream: yi, events: Be, scaleFactor: Qt, pageSize: { getWidth: function() {
    return Qs(z);
  }, setWidth: function(w) {
    Wa(z, w);
  }, getHeight: function() {
    return gs(z);
  }, setHeight: function(w) {
    Ha(z, w);
  } }, encryptionOptions: u, encryption: Oe, getEncryptor: un, output: ce, getNumberOfPages: Fa, pages: Rt, out: U, f2: j, f3: P, getPageInfo: Ee, getPageInfoByObjId: ae, getCurrentPageInfo: ve, getPDFVersion: b, Point: Bo, Rectangle: $a, Matrix: me, hasHotfix: _e }, Object.defineProperty(f.internal.pageSize, "width", { get: function() {
    return Qs(z);
  }, set: function(w) {
    Wa(z, w);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(f.internal.pageSize, "height", { get: function() {
    return gs(z);
  }, set: function(w) {
    Ha(z, w);
  }, enumerable: !0, configurable: !0 }), Ta.call(f, rt), we = "F1", Vs(r, e), Be.publish("initialized"), f;
}
ca.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, ca.prototype.toHexString = function(n) {
  return n.split("").map(function(t) {
    return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, ca.prototype.hexToBytes = function(n) {
  for (var t = [], e = 0; e < n.length; e += 2) t.push(String.fromCharCode(parseInt(n.substr(e, 2), 16)));
  return t.join("");
}, ca.prototype.processOwnerPassword = function(n, t) {
  return pf(df(t).substr(0, 5), n);
}, ca.prototype.encryptor = function(n, t) {
  var e = df(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & t, t >> 8 & 255)).substr(0, 10);
  return function(i) {
    return pf(e, i);
  };
}, Ll.prototype.equals = function(n) {
  var t, e = "id,objectNumber,equals";
  if (!n || nn(n) !== nn(this)) return !1;
  var i = 0;
  for (t in this) if (!(e.indexOf(t) >= 0)) {
    if (this.hasOwnProperty(t) && !n.hasOwnProperty(t) || this[t] !== n[t]) return !1;
    i++;
  }
  for (t in n) n.hasOwnProperty(t) && e.indexOf(t) < 0 && i--;
  return i === 0;
}, ke.API = { events: [] }, ke.version = "2.5.2";
var kn = ke.API, kd = 1, Eo = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, ta = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Fe = function(n) {
  return n.toFixed(2);
}, Ls = function(n) {
  return n.toFixed(5);
};
kn.__acroform__ = {};
var Ai = function(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n;
}, Jp = function(n) {
  return n * kd;
}, Cr = function(n) {
  var t = new O1(), e = ge.internal.getHeight(n) || 0, i = ge.internal.getWidth(n) || 0;
  return t.BBox = [0, 0, Number(Fe(i)), Number(Fe(e))], t;
}, vv = kn.__acroform__.setBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << t;
}, wv = kn.__acroform__.clearBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << t);
}, xv = kn.__acroform__.getBit = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << t ? 1 : 0;
}, In = kn.__acroform__.getBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return xv(n, t - 1);
}, En = kn.__acroform__.setBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return vv(n, t - 1);
}, On = kn.__acroform__.clearBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return wv(n, t - 1);
}, _v = kn.__acroform__.calculateCoordinates = function(n, t) {
  var e = t.internal.getHorizontalCoordinate, i = t.internal.getVerticalCoordinate, r = n[0], s = n[1], o = n[2], a = n[3], l = {};
  return l.lowerLeft_X = e(r) || 0, l.lowerLeft_Y = i(s + a) || 0, l.upperRight_X = e(r + o) || 0, l.upperRight_Y = i(s) || 0, [Number(Fe(l.lowerLeft_X)), Number(Fe(l.lowerLeft_Y)), Number(Fe(l.upperRight_X)), Number(Fe(l.upperRight_Y))];
}, Sv = function(n) {
  if (n.appearanceStreamContent) return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var t = [], e = n._V || n.DV, i = gf(n, e), r = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    t.push("/Tx BMC"), t.push("q"), t.push("BT"), t.push(n.scope.__private__.encodeColorString(n.color)), t.push("/" + r + " " + Fe(i.fontSize) + " Tf"), t.push("1 0 0 1 0 0 Tm"), t.push(i.text), t.push("ET"), t.push("Q"), t.push("EMC");
    var s = Cr(n);
    return s.scope = n.scope, s.stream = t.join(`
`), s;
  }
}, gf = function(n, t) {
  var e = n.fontSize === 0 ? n.maxFontSize : n.fontSize, i = { text: "", fontSize: "" }, r = (t = (t = t.substr(0, 1) == "(" ? t.substr(1) : t).substr(t.length - 1) == ")" ? t.substr(0, t.length - 1) : t).split(" ");
  r = n.multiline ? r.map(function(P) {
    return P.split(`
`);
  }) : r.map(function(P) {
    return [P];
  });
  var s = e, o = ge.internal.getHeight(n) || 0;
  o = o < 0 ? -o : o;
  var a = ge.internal.getWidth(n) || 0;
  a = a < 0 ? -a : a;
  var l = function(P, A, T) {
    if (P + 1 < r.length) {
      var _ = A + " " + r[P + 1][0];
      return Cu(_, n, T).width <= a - 4;
    }
    return !1;
  };
  s++;
  t: for (; s > 0; ) {
    t = "", s--;
    var h, u, d = Cu("3", n, s).height, p = n.multiline ? o - s : (o - d) / 2, f = p += 2, m = 0, b = 0, x = 0;
    if (s <= 0) {
      t = `(...) Tj
`, t += "% Width of Text: " + Cu(t, n, s = 12).width + ", FieldWidth:" + a + `
`;
      break;
    }
    for (var y = "", v = 0, k = 0; k < r.length; k++) if (r.hasOwnProperty(k)) {
      var C = !1;
      if (r[k].length !== 1 && x !== r[k].length - 1) {
        if ((d + 2) * (v + 2) + 2 > o) continue t;
        y += r[k][x], C = !0, b = k, k--;
      } else {
        y = (y += r[k][x] + " ").substr(y.length - 1) == " " ? y.substr(0, y.length - 1) : y;
        var I = parseInt(k), q = l(I, y, s), O = k >= r.length - 1;
        if (q && !O) {
          y += " ", x = 0;
          continue;
        }
        if (q || O) {
          if (O) b = I;
          else if (n.multiline && (d + 2) * (v + 2) + 2 > o) continue t;
        } else {
          if (!n.multiline || (d + 2) * (v + 2) + 2 > o) continue t;
          b = I;
        }
      }
      for (var F = "", M = m; M <= b; M++) {
        var j = r[M];
        if (n.multiline) {
          if (M === b) {
            F += j[x] + " ", x = (x + 1) % j.length;
            continue;
          }
          if (M === m) {
            F += j[j.length - 1] + " ";
            continue;
          }
        }
        F += j[0] + " ";
      }
      switch (F = F.substr(F.length - 1) == " " ? F.substr(0, F.length - 1) : F, u = Cu(F, n, s).width, n.textAlign) {
        case "right":
          h = a - u - 2;
          break;
        case "center":
          h = (a - u) / 2;
          break;
        case "left":
        default:
          h = 2;
      }
      t += Fe(h) + " " + Fe(f) + ` Td
`, t += "(" + Eo(F) + `) Tj
`, t += -Fe(h) + ` 0 Td
`, f = -(s + 2), u = 0, m = C ? b : b + 1, v++, y = "";
    }
    break;
  }
  return i.text = t, i.fontSize = s, i;
}, Cu = function(n, t, e) {
  var i = t.scope.internal.getFont(t.fontName, t.fontStyle), r = t.scope.getStringUnitWidth(n, { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e);
  return { height: t.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e) * 1.5, width: r };
}, kv = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Av = function(n, t) {
  var e = { type: "reference", object: n };
  t.internal.getPageInfo(n.page).pageContext.annotations.find(function(i) {
    return i.type === e.type && i.object === e.object;
  }) === void 0 && t.internal.getPageInfo(n.page).pageContext.annotations.push(e);
}, Nv = function(n, t) {
  for (var e in n) if (n.hasOwnProperty(e)) {
    var i = e, r = n[e];
    t.internal.newObjectDeferredBegin(r.objId, !0), nn(r) === "object" && typeof r.putStream == "function" && r.putStream(), delete n[i];
  }
}, Cv = function(n, t) {
  if (t.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (yr.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(kv)), n.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    kd = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new T1(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(e) {
        e.internal.events.unsubscribe(e.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete e.internal.acroformPlugin.acroFormDictionaryRoot._eventID, e.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(e) {
        e.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = e.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r in i) if (i.hasOwnProperty(r)) {
          var s = i[r];
          s.objId = void 0, s.hasAnnotation && Av(s, e);
        }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(e) {
        if (e.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        e.internal.write("/AcroForm " + e.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(e) {
      (function(i, r) {
        var s = !i;
        for (var o in i || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (i.hasOwnProperty(o)) {
          var a = i[o], l = [], h = a.Rect;
          if (a.Rect && (a.Rect = _v(a.Rect, r)), r.internal.newObjectDeferredBegin(a.objId, !0), a.DA = ge.createDefaultAppearanceStream(a), nn(a) === "object" && typeof a.getKeyValueListForStream == "function" && (l = a.getKeyValueListForStream()), a.Rect = h, a.hasAppearanceStream && !a.appearanceStreamContent) {
            var u = Sv(a);
            l.push({ key: "AP", value: "<</N " + u + ">>" }), r.internal.acroformPlugin.xForms.push(u);
          }
          if (a.appearanceStreamContent) {
            var d = "";
            for (var p in a.appearanceStreamContent) if (a.appearanceStreamContent.hasOwnProperty(p)) {
              var f = a.appearanceStreamContent[p];
              if (d += "/" + p + " ", d += "<<", Object.keys(f).length >= 1 || Array.isArray(f)) {
                for (var o in f) if (f.hasOwnProperty(o)) {
                  var m = f[o];
                  typeof m == "function" && (m = m.call(r, a)), d += "/" + o + " " + m + " ", r.internal.acroformPlugin.xForms.indexOf(m) >= 0 || r.internal.acroformPlugin.xForms.push(m);
                }
              } else typeof (m = f) == "function" && (m = m.call(r, a)), d += "/" + o + " " + m, r.internal.acroformPlugin.xForms.indexOf(m) >= 0 || r.internal.acroformPlugin.xForms.push(m);
              d += ">>";
            }
            l.push({ key: "AP", value: `<<
` + d + ">>" });
          }
          r.internal.putStream({ additionalKeyValues: l, objectId: a.objId }), r.internal.out("endobj");
        }
        s && Nv(r.internal.acroformPlugin.xForms, r);
      })(e, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, E1 = kn.__acroform__.arrayToPdfArray = function(n, t, e) {
  var i = function(o) {
    return o;
  };
  if (Array.isArray(n)) {
    for (var r = "[", s = 0; s < n.length; s++) switch (s !== 0 && (r += " "), nn(n[s])) {
      case "boolean":
      case "number":
      case "object":
        r += n[s].toString();
        break;
      case "string":
        n[s].substr(0, 1) !== "/" ? (t !== void 0 && e && (i = e.internal.getEncryptor(t)), r += "(" + Eo(i(n[s].toString())) + ")") : r += n[s].toString();
    }
    return r += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Ph = function(n, t, e) {
  var i = function(r) {
    return r;
  };
  return t !== void 0 && e && (i = e.internal.getEncryptor(t)), (n = n || "").toString(), n = "(" + Eo(i(n)) + ")";
}, Ir = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Ir.prototype.toString = function() {
  return this.objId + " 0 R";
}, Ir.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, Ir.prototype.getKeyValueListForStream = function() {
  var n = [], t = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var e in t) if (Object.getOwnPropertyDescriptor(this, t[e]).configurable === !1) {
    var i = t[e], r = this[i];
    r && (Array.isArray(r) ? n.push({ key: i, value: E1(r, this.objId, this.scope) }) : r instanceof Ir ? (r.scope = this.scope, n.push({ key: i, value: r.objId + " 0 R" })) : typeof r != "function" && n.push({ key: i, value: r }));
  }
  return n;
};
var O1 = function() {
  Ir.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, t = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return t;
  }, set: function(e) {
    t = e;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(e) {
    n = e.trim();
  }, get: function() {
    return n || null;
  } });
};
Ai(O1, Ir);
var T1 = function() {
  Ir.call(this);
  var n, t = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return t.length > 0 ? t : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return t;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var e = function(i) {
        return i;
      };
      return this.scope && (e = this.scope.internal.getEncryptor(this.objId)), "(" + Eo(e(n)) + ")";
    }
  }, set: function(e) {
    n = e;
  } });
};
Ai(T1, Ir);
var yr = function n() {
  Ir.call(this);
  var t = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(y) {
    if (isNaN(y)) throw new Error('Invalid value "' + y + '" for attribute F supplied.');
    t = y;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!In(t, 3);
  }, set: function(y) {
    y ? this.F = En(t, 3) : this.F = On(t, 3);
  } });
  var e = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(y) {
    if (isNaN(y)) throw new Error('Invalid value "' + y + '" for attribute Ff supplied.');
    e = y;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0) return i;
  }, set: function(y) {
    i = y !== void 0 ? y : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(y) {
    i[0] = y;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(y) {
    i[1] = y;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(y) {
    i[2] = y;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(y) {
    i[3] = y;
  } });
  var r = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(y) {
    switch (y) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        r = y;
        break;
      default:
        throw new Error('Invalid value "' + y + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof lc) return;
      s = "FieldObject" + n.FieldNum++;
    }
    var y = function(v) {
      return v;
    };
    return this.scope && (y = this.scope.internal.getEncryptor(this.objId)), "(" + Eo(y(s)) + ")";
  }, set: function(y) {
    s = y.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(y) {
    s = y;
  } });
  var o = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(y) {
    o = y;
  } });
  var a = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(y) {
    a = y;
  } });
  var l = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(y) {
    l = y;
  } });
  var h = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return h === void 0 ? 50 / kd : h;
  }, set: function(y) {
    h = y;
  } });
  var u = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return u;
  }, set: function(y) {
    u = y;
  } });
  var d = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!d || this instanceof lc || this instanceof Ds)) return Ph(d, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), d = y;
  } });
  var p = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (p) return this instanceof qn ? p : Ph(p, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), p = this instanceof qn ? y : y.substr(0, 1) === "(" ? ta(y.substr(1, y.length - 2)) : ta(y);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof qn ? ta(p.substr(1, p.length - 1)) : p;
  }, set: function(y) {
    y = y.toString(), p = this instanceof qn ? "/" + y : y;
  } });
  var f = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return f;
  }, set: function(y) {
    this.V = y;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return this instanceof qn ? f : Ph(f, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), f = this instanceof qn ? y : y.substr(0, 1) === "(" ? ta(y.substr(1, y.length - 2)) : ta(y);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof qn ? ta(f.substr(1, f.length - 1)) : f;
  }, set: function(y) {
    y = y.toString(), f = this instanceof qn ? "/" + y : y;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var m, b = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(y) {
    y = !!y, b = y;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (m) return m;
  }, set: function(y) {
    m = y;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 1);
  }, set: function(y) {
    y ? this.Ff = En(this.Ff, 1) : this.Ff = On(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 2);
  }, set: function(y) {
    y ? this.Ff = En(this.Ff, 2) : this.Ff = On(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 3);
  }, set: function(y) {
    y ? this.Ff = En(this.Ff, 3) : this.Ff = On(this.Ff, 3);
  } });
  var x = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (x !== null) return x;
  }, set: function(y) {
    if ([0, 1, 2].indexOf(y) === -1) throw new Error('Invalid value "' + y + '" for attribute Q supplied.');
    x = y;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var y;
    switch (x) {
      case 0:
      default:
        y = "left";
        break;
      case 1:
        y = "center";
        break;
      case 2:
        y = "right";
    }
    return y;
  }, configurable: !0, enumerable: !0, set: function(y) {
    switch (y) {
      case "right":
      case 2:
        x = 2;
        break;
      case "center":
      case 1:
        x = 1;
        break;
      case "left":
      case 0:
      default:
        x = 0;
    }
  } });
};
Ai(yr, Ir);
var yo = function() {
  yr.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } });
  var t = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return E1(t, this.objId, this.scope);
  }, set: function(e) {
    var i, r;
    r = [], typeof (i = e) == "string" && (r = function(s, o, a) {
      a || (a = 1);
      for (var l, h = []; l = o.exec(s); ) h.push(l[a]);
      return h;
    }(i, /\((.*?)\)/g)), t = r;
  } }), this.getOptions = function() {
    return t;
  }, this.setOptions = function(e) {
    t = e, this.sort && t.sort();
  }, this.addOption = function(e) {
    e = (e = e || "").toString(), t.push(e), this.sort && t.sort();
  }, this.removeOption = function(e, i) {
    for (i = i || !1, e = (e = e || "").toString(); t.indexOf(e) !== -1 && (t.splice(t.indexOf(e), 1), i !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 18);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 18) : this.Ff = On(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 19);
  }, set: function(e) {
    this.combo === !0 && (e ? this.Ff = En(this.Ff, 19) : this.Ff = On(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 20);
  }, set: function(e) {
    e ? (this.Ff = En(this.Ff, 20), t.sort()) : this.Ff = On(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 22);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 22) : this.Ff = On(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 23) : this.Ff = On(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 27);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 27) : this.Ff = On(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Ai(yo, yr);
var bo = function() {
  yo.call(this), this.fontName = "helvetica", this.combo = !1;
};
Ai(bo, yo);
var vo = function() {
  bo.call(this), this.combo = !0;
};
Ai(vo, bo);
var kl = function() {
  vo.call(this), this.edit = !0;
};
Ai(kl, vo);
var qn = function() {
  yr.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 15);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 15) : this.Ff = On(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 16);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 16) : this.Ff = On(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 17);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 17) : this.Ff = On(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = En(this.Ff, 26) : this.Ff = On(this.Ff, 26);
  } });
  var n, t = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var e = function(s) {
      return s;
    };
    if (this.scope && (e = this.scope.internal.getEncryptor(this.objId)), Object.keys(t).length !== 0) {
      var i, r = [];
      for (i in r.push("<<"), t) r.push("/" + i + " (" + Eo(e(t[i])) + ")");
      return r.push(">>"), r.join(`
`);
    }
  }, set: function(e) {
    nn(e) === "object" && (t = e);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return t.CA || "";
  }, set: function(e) {
    typeof e == "string" && (t.CA = e);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(e) {
    n = "/" + e;
  } });
};
Ai(qn, yr);
var Al = function() {
  qn.call(this), this.pushButton = !0;
};
Ai(Al, qn);
var wo = function() {
  qn.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t !== void 0 ? t : [];
  } });
};
Ai(wo, qn);
var lc = function() {
  var n, t;
  yr.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(r) {
    n = r;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return t;
  }, set: function(r) {
    t = r;
  } });
  var e, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var r = function(a) {
      return a;
    };
    this.scope && (r = this.scope.internal.getEncryptor(this.objId));
    var s, o = [];
    for (s in o.push("<<"), i) o.push("/" + s + " (" + Eo(r(i[s])) + ")");
    return o.push(">>"), o.join(`
`);
  }, set: function(r) {
    nn(r) === "object" && (i = r);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(r) {
    typeof r == "string" && (i.CA = r);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(r) {
    e = r;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(r) {
    e = "/" + r;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = ge.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Ai(lc, yr), wo.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var t in this.Kids) if (this.Kids.hasOwnProperty(t)) {
    var e = this.Kids[t];
    e.appearanceStreamContent = n.createAppearanceStream(e.optionName), e.caption = n.getCA();
  }
}, wo.prototype.createOption = function(n) {
  var t = new lc();
  return t.Parent = this, t.optionName = n, this.Kids.push(t), Pv.call(this.scope, t), t;
};
var Nl = function() {
  qn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = ge.CheckBox.createAppearanceStream();
};
Ai(Nl, qn);
var Ds = function() {
  yr.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 13);
  }, set: function(t) {
    t ? this.Ff = En(this.Ff, 13) : this.Ff = On(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 21);
  }, set: function(t) {
    t ? this.Ff = En(this.Ff, 21) : this.Ff = On(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = En(this.Ff, 23) : this.Ff = On(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 24);
  }, set: function(t) {
    t ? this.Ff = En(this.Ff, 24) : this.Ff = On(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 25);
  }, set: function(t) {
    t ? this.Ff = En(this.Ff, 25) : this.Ff = On(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = En(this.Ff, 26) : this.Ff = On(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    Number.isInteger(t) && (n = t);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Ai(Ds, yr);
var Cl = function() {
  Ds.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!In(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = En(this.Ff, 14) : this.Ff = On(this.Ff, 14);
  } }), this.password = !0;
};
Ai(Cl, Ds);
var ge = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: ge.CheckBox.YesNormal }, D: { On: ge.CheckBox.YesPushDown, Off: ge.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), s = gf(n, n.caption);
  return e.push("0.749023 g"), e.push("0 0 " + Fe(ge.internal.getWidth(n)) + " " + Fe(ge.internal.getHeight(n)) + " re"), e.push("f"), e.push("BMC"), e.push("q"), e.push("0 0 1 rg"), e.push("/" + i + " " + Fe(s.fontSize) + " Tf " + r), e.push("BT"), e.push(s.text), e.push("ET"), e.push("Q"), e.push("EMC"), t.stream = e.join(`
`), t;
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), r = [], s = ge.internal.getHeight(n), o = ge.internal.getWidth(n), a = gf(n, n.caption);
  return r.push("1 g"), r.push("0 0 " + Fe(o) + " " + Fe(s) + " re"), r.push("f"), r.push("q"), r.push("0 0 1 rg"), r.push("0 0 " + Fe(o - 1) + " " + Fe(s - 1) + " re"), r.push("W"), r.push("n"), r.push("0 g"), r.push("BT"), r.push("/" + e + " " + Fe(a.fontSize) + " Tf " + i), r.push(a.text), r.push("ET"), r.push("Q"), t.stream = r.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Fe(ge.internal.getWidth(n)) + " " + Fe(ge.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var t = { D: { Off: ge.RadioButton.Circle.OffPushDown }, N: {} };
  return t.N[n] = ge.RadioButton.Circle.YesNormal, t.D[n] = ge.RadioButton.Circle.YesPushDown, t;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = ge.internal.getWidth(n) <= ge.internal.getHeight(n) ? ge.internal.getWidth(n) / 4 : ge.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = ge.internal.Bezier_C, s = Number((i * r).toFixed(5));
  return e.push("q"), e.push("1 0 0 1 " + Ls(ge.internal.getWidth(n) / 2) + " " + Ls(ge.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), e.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), e.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), e.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = ge.internal.getWidth(n) <= ge.internal.getHeight(n) ? ge.internal.getWidth(n) / 4 : ge.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * ge.internal.Bezier_C).toFixed(5)), o = Number((i * ge.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Ls(ge.internal.getWidth(n) / 2) + " " + Ls(ge.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), e.push("0 g"), e.push("q"), e.push("1 0 0 1 " + Ls(ge.internal.getWidth(n) / 2) + " " + Ls(ge.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), e.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), e.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), e.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = ge.internal.getWidth(n) <= ge.internal.getHeight(n) ? ge.internal.getWidth(n) / 4 : ge.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * ge.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Ls(ge.internal.getWidth(n) / 2) + " " + Ls(ge.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
} }, Cross: { createAppearanceStream: function(n) {
  var t = { D: { Off: ge.RadioButton.Cross.OffPushDown }, N: {} };
  return t.N[n] = ge.RadioButton.Cross.YesNormal, t.D[n] = ge.RadioButton.Cross.YesPushDown, t;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = ge.internal.calculateCross(n);
  return e.push("q"), e.push("1 1 " + Fe(ge.internal.getWidth(n) - 2) + " " + Fe(ge.internal.getHeight(n) - 2) + " re"), e.push("W"), e.push("n"), e.push(Fe(i.x1.x) + " " + Fe(i.x1.y) + " m"), e.push(Fe(i.x2.x) + " " + Fe(i.x2.y) + " l"), e.push(Fe(i.x4.x) + " " + Fe(i.x4.y) + " m"), e.push(Fe(i.x3.x) + " " + Fe(i.x3.y) + " l"), e.push("s"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = ge.internal.calculateCross(n), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + Fe(ge.internal.getWidth(n)) + " " + Fe(ge.internal.getHeight(n)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + Fe(ge.internal.getWidth(n) - 2) + " " + Fe(ge.internal.getHeight(n) - 2) + " re"), i.push("W"), i.push("n"), i.push(Fe(e.x1.x) + " " + Fe(e.x1.y) + " m"), i.push(Fe(e.x2.x) + " " + Fe(e.x2.y) + " l"), i.push(Fe(e.x4.x) + " " + Fe(e.x4.y) + " m"), i.push(Fe(e.x3.x) + " " + Fe(e.x3.y) + " l"), i.push("s"), i.push("Q"), t.stream = i.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Fe(ge.internal.getWidth(n)) + " " + Fe(ge.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} } }, createDefaultAppearanceStream: function(n) {
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, e = n.scope.__private__.encodeColorString(n.color);
  return "/" + t + " " + n.fontSize + " Tf " + e;
} };
ge.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var t = ge.internal.getWidth(n), e = ge.internal.getHeight(n), i = Math.min(t, e);
  return { x1: { x: (t - i) / 2, y: (e - i) / 2 + i }, x2: { x: (t - i) / 2 + i, y: (e - i) / 2 }, x3: { x: (t - i) / 2, y: (e - i) / 2 }, x4: { x: (t - i) / 2 + i, y: (e - i) / 2 + i } };
} }, ge.internal.getWidth = function(n) {
  var t = 0;
  return nn(n) === "object" && (t = Jp(n.Rect[2])), t;
}, ge.internal.getHeight = function(n) {
  var t = 0;
  return nn(n) === "object" && (t = Jp(n.Rect[3])), t;
};
var Pv = kn.addField = function(n) {
  if (Cv(this, n), !(n instanceof yr)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var t;
  return (t = n).scope.internal.acroformPlugin.printedOut && (t.scope.internal.acroformPlugin.printedOut = !1, t.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), t.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
kn.AcroFormChoiceField = yo, kn.AcroFormListBox = bo, kn.AcroFormComboBox = vo, kn.AcroFormEditBox = kl, kn.AcroFormButton = qn, kn.AcroFormPushButton = Al, kn.AcroFormRadioButton = wo, kn.AcroFormCheckBox = Nl, kn.AcroFormTextField = Ds, kn.AcroFormPasswordField = Cl, kn.AcroFormAppearance = ge, kn.AcroForm = { ChoiceField: yo, ListBox: bo, ComboBox: vo, EditBox: kl, Button: qn, PushButton: Al, RadioButton: wo, CheckBox: Nl, TextField: Ds, PasswordField: Cl, Appearance: ge }, ke.AcroForm = { ChoiceField: yo, ListBox: bo, ComboBox: vo, EditBox: kl, Button: qn, PushButton: Al, RadioButton: wo, CheckBox: Nl, TextField: Ds, PasswordField: Cl, Appearance: ge };
var Lv = ke.AcroForm;
function F1(n) {
  return n.reduce(function(t, e, i) {
    return t[e] = i, t;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var t = "UNKNOWN", e = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = n.__addimage__.getImageFileTypeByImageData = function(P, A) {
    var T, _, Z, V, R, Q = t;
    if ((A = A || t) === "RGBA" || P.data !== void 0 && P.data instanceof Uint8ClampedArray && "height" in P && "width" in P) return "RGBA";
    if (q(P)) for (R in e) for (Z = e[R], T = 0; T < Z.length; T += 1) {
      for (V = !0, _ = 0; _ < Z[T].length; _ += 1) if (Z[T][_] !== void 0 && Z[T][_] !== P[_]) {
        V = !1;
        break;
      }
      if (V === !0) {
        Q = R;
        break;
      }
    }
    else for (R in e) for (Z = e[R], T = 0; T < Z.length; T += 1) {
      for (V = !0, _ = 0; _ < Z[T].length; _ += 1) if (Z[T][_] !== void 0 && Z[T][_] !== P.charCodeAt(_)) {
        V = !1;
        break;
      }
      if (V === !0) {
        Q = R;
        break;
      }
    }
    return Q === t && A !== t && (Q = A), Q;
  }, r = function P(A) {
    for (var T = this.internal.write, _ = this.internal.putStream, Z = (0, this.internal.getFilters)(); Z.indexOf("FlateEncode") !== -1; ) Z.splice(Z.indexOf("FlateEncode"), 1);
    A.objectId = this.internal.newObject();
    var V = [];
    if (V.push({ key: "Type", value: "/XObject" }), V.push({ key: "Subtype", value: "/Image" }), V.push({ key: "Width", value: A.width }), V.push({ key: "Height", value: A.height }), A.colorSpace === x.INDEXED ? V.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (A.palette.length / 3 - 1) + " " + ("sMask" in A && A.sMask !== void 0 ? A.objectId + 2 : A.objectId + 1) + " 0 R]" }) : (V.push({ key: "ColorSpace", value: "/" + A.colorSpace }), A.colorSpace === x.DEVICE_CMYK && V.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), V.push({ key: "BitsPerComponent", value: A.bitsPerComponent }), "decodeParameters" in A && A.decodeParameters !== void 0 && V.push({ key: "DecodeParms", value: "<<" + A.decodeParameters + ">>" }), "transparency" in A && Array.isArray(A.transparency)) {
      for (var R = "", Q = 0, H = A.transparency.length; Q < H; Q++) R += A.transparency[Q] + " " + A.transparency[Q] + " ";
      V.push({ key: "Mask", value: "[" + R + "]" });
    }
    A.sMask !== void 0 && V.push({ key: "SMask", value: A.objectId + 1 + " 0 R" });
    var ct = A.filter !== void 0 ? ["/" + A.filter] : void 0;
    if (_({ data: A.data, additionalKeyValues: V, alreadyAppliedFilters: ct, objectId: A.objectId }), T("endobj"), "sMask" in A && A.sMask !== void 0) {
      var nt = "/Predictor " + A.predictor + " /Colors 1 /BitsPerComponent " + A.bitsPerComponent + " /Columns " + A.width, N = { width: A.width, height: A.height, colorSpace: "DeviceGray", bitsPerComponent: A.bitsPerComponent, decodeParameters: nt, data: A.sMask };
      "filter" in A && (N.filter = A.filter), P.call(this, N);
    }
    if (A.colorSpace === x.INDEXED) {
      var z = this.internal.newObject();
      _({ data: F(new Uint8Array(A.palette)), objectId: z }), T("endobj");
    }
  }, s = function() {
    var P = this.internal.collections.addImage_images;
    for (var A in P) r.call(this, P[A]);
  }, o = function() {
    var P, A = this.internal.collections.addImage_images, T = this.internal.write;
    for (var _ in A) T("/I" + (P = A[_]).index, P.objectId, "0", "R");
  }, a = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", o));
  }, l = function() {
    var P = this.internal.collections.addImage_images;
    return a.call(this), P;
  }, h = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, u = function(P) {
    return typeof n["process" + P.toUpperCase()] == "function";
  }, d = function(P) {
    return nn(P) === "object" && P.nodeType === 1;
  }, p = function(P, A) {
    if (P.nodeName === "IMG" && P.hasAttribute("src")) {
      var T = "" + P.getAttribute("src");
      if (T.indexOf("data:image/") === 0) return Sl(unescape(T).split("base64,").pop());
      var _ = n.loadFile(T, !0);
      if (_ !== void 0) return _;
    }
    if (P.nodeName === "CANVAS") {
      if (P.width === 0 || P.height === 0) throw new Error("Given canvas must have data. Canvas width: " + P.width + ", height: " + P.height);
      var Z;
      switch (A) {
        case "PNG":
          Z = "image/png";
          break;
        case "WEBP":
          Z = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          Z = "image/jpeg";
      }
      return Sl(P.toDataURL(Z, 1).split("base64,").pop());
    }
  }, f = function(P) {
    var A = this.internal.collections.addImage_images;
    if (A) {
      for (var T in A) if (P === A[T].alias) return A[T];
    }
  }, m = function(P, A, T) {
    return P || A || (P = -96, A = -96), P < 0 && (P = -1 * T.width * 72 / P / this.internal.scaleFactor), A < 0 && (A = -1 * T.height * 72 / A / this.internal.scaleFactor), P === 0 && (P = A * T.width / T.height), A === 0 && (A = P * T.height / T.width), [P, A];
  }, b = function(P, A, T, _, Z, V) {
    var R = m.call(this, T, _, Z), Q = this.internal.getCoordinateString, H = this.internal.getVerticalCoordinateString, ct = l.call(this);
    if (T = R[0], _ = R[1], ct[Z.index] = Z, V) {
      V *= Math.PI / 180;
      var nt = Math.cos(V), N = Math.sin(V), z = function(Y) {
        return Y.toFixed(4);
      }, G = [z(nt), z(N), z(-1 * N), z(nt), 0, 0, "cm"];
    }
    this.internal.write("q"), V ? (this.internal.write([1, "0", "0", 1, Q(P), H(A + _), "cm"].join(" ")), this.internal.write(G.join(" ")), this.internal.write([Q(T), "0", "0", Q(_), "0", "0", "cm"].join(" "))) : this.internal.write([Q(T), "0", "0", Q(_), Q(P), H(A + _), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + Z.index + " Do"), this.internal.write("Q");
  }, x = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, v = n.__addimage__.sHashCode = function(P) {
    var A, T, _ = 0;
    if (typeof P == "string") for (T = P.length, A = 0; A < T; A++) _ = (_ << 5) - _ + P.charCodeAt(A), _ |= 0;
    else if (q(P)) for (T = P.byteLength / 2, A = 0; A < T; A++) _ = (_ << 5) - _ + P[A], _ |= 0;
    return _;
  }, k = n.__addimage__.validateStringAsBase64 = function(P) {
    (P = P || "").toString().trim();
    var A = !0;
    return P.length === 0 && (A = !1), P.length % 4 != 0 && (A = !1), /^[A-Za-z0-9+/]+$/.test(P.substr(0, P.length - 2)) === !1 && (A = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(P.substr(-2)) === !1 && (A = !1), A;
  }, C = n.__addimage__.extractImageFromDataUrl = function(P) {
    var A = (P = P || "").split("base64,"), T = null;
    if (A.length === 2) {
      var _ = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(A[0]);
      Array.isArray(_) && (T = { mimeType: _[1], charset: _[2], data: A[1] });
    }
    return T;
  }, I = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(P) {
    return I() && P instanceof ArrayBuffer;
  };
  var q = n.__addimage__.isArrayBufferView = function(P) {
    return I() && typeof Uint32Array < "u" && (P instanceof Int8Array || P instanceof Uint8Array || typeof Uint8ClampedArray < "u" && P instanceof Uint8ClampedArray || P instanceof Int16Array || P instanceof Uint16Array || P instanceof Int32Array || P instanceof Uint32Array || P instanceof Float32Array || P instanceof Float64Array);
  }, O = n.__addimage__.binaryStringToUint8Array = function(P) {
    for (var A = P.length, T = new Uint8Array(A), _ = 0; _ < A; _++) T[_] = P.charCodeAt(_);
    return T;
  }, F = n.__addimage__.arrayBufferToBinaryString = function(P) {
    for (var A = "", T = q(P) ? P : new Uint8Array(P), _ = 0; _ < T.length; _ += 8192) A += String.fromCharCode.apply(null, T.subarray(_, _ + 8192));
    return A;
  };
  n.addImage = function() {
    var P, A, T, _, Z, V, R, Q, H;
    if (typeof arguments[1] == "number" ? (A = t, T = arguments[1], _ = arguments[2], Z = arguments[3], V = arguments[4], R = arguments[5], Q = arguments[6], H = arguments[7]) : (A = arguments[1], T = arguments[2], _ = arguments[3], Z = arguments[4], V = arguments[5], R = arguments[6], Q = arguments[7], H = arguments[8]), nn(P = arguments[0]) === "object" && !d(P) && "imageData" in P) {
      var ct = P;
      P = ct.imageData, A = ct.format || A || t, T = ct.x || T || 0, _ = ct.y || _ || 0, Z = ct.w || ct.width || Z, V = ct.h || ct.height || V, R = ct.alias || R, Q = ct.compression || Q, H = ct.rotation || ct.angle || H;
    }
    var nt = this.internal.getFilters();
    if (Q === void 0 && nt.indexOf("FlateEncode") !== -1 && (Q = "SLOW"), isNaN(T) || isNaN(_)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    a.call(this);
    var N = M.call(this, P, A, R, Q);
    return b.call(this, T, _, Z, V, N, H), this;
  };
  var M = function(P, A, T, _) {
    var Z, V, R;
    if (typeof P == "string" && i(P) === t) {
      P = unescape(P);
      var Q = j(P, !1);
      (Q !== "" || (Q = n.loadFile(P, !0)) !== void 0) && (P = Q);
    }
    if (d(P) && (P = p(P, A)), A = i(P, A), !u(A)) throw new Error("addImage does not support files of type '" + A + "', please ensure that a plugin for '" + A + "' support is added.");
    if (((R = T) == null || R.length === 0) && (T = function(H) {
      return typeof H == "string" || q(H) ? v(H) : q(H.data) ? v(H.data) : null;
    }(P)), (Z = f.call(this, T)) || (I() && (P instanceof Uint8Array || A === "RGBA" || (V = P, P = O(P))), Z = this["process" + A.toUpperCase()](P, h.call(this), T, function(H) {
      return H && typeof H == "string" && (H = H.toUpperCase()), H in n.image_compression ? H : y.NONE;
    }(_), V)), !Z) throw new Error("An unknown error occurred whilst processing the image.");
    return Z;
  }, j = n.__addimage__.convertBase64ToBinaryString = function(P, A) {
    var T;
    A = typeof A != "boolean" || A;
    var _, Z = "";
    if (typeof P == "string") {
      _ = (T = C(P)) !== null ? T.data : P;
      try {
        Z = Sl(_);
      } catch (V) {
        if (A) throw k(_) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + V.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Z;
  };
  n.getImageProperties = function(P) {
    var A, T, _ = "";
    if (d(P) && (P = p(P)), typeof P == "string" && i(P) === t && ((_ = j(P, !1)) === "" && (_ = n.loadFile(P) || ""), P = _), T = i(P), !u(T)) throw new Error("addImage does not support files of type '" + T + "', please ensure that a plugin for '" + T + "' support is added.");
    if (!I() || P instanceof Uint8Array || (P = O(P)), !(A = this["process" + T.toUpperCase()](P))) throw new Error("An unknown error occurred whilst processing the image");
    return A.fileType = T, A;
  };
})(ke.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    if (e !== void 0 && e != "") return !0;
  };
  ke.API.events.push(["addPage", function(e) {
    this.internal.getPageInfo(e.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(e) {
    for (var i, r, s, o = this.internal.getCoordinateString, a = this.internal.getVerticalCoordinateString, l = this.internal.getPageInfoByObjId(e.objId), h = e.pageContext.annotations, u = !1, d = 0; d < h.length && !u; d++) switch ((i = h[d]).type) {
      case "link":
        (t(i.options.url) || t(i.options.pageNumber)) && (u = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        u = !0;
    }
    if (u != 0) {
      this.internal.write("/Annots [");
      for (var p = 0; p < h.length; p++) {
        i = h[p];
        var f = this.internal.pdfEscape, m = this.internal.getEncryptor(e.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var b = this.internal.newAdditionalObject(), x = this.internal.newAdditionalObject(), y = this.internal.getEncryptor(b.objId), v = i.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y) + "] ") + "/Contents (" + f(y(i.contents)) + ")", s += " /Popup " + x.objId + " 0 R", s += " /P " + l.objId + " 0 R", s += " /T (" + f(y(v)) + ") >>", b.content = s;
            var k = b.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + o(i.bounds.x + 30) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w + 30) + " " + a(i.bounds.y) + "] ") + " /Parent " + k, i.open && (s += " /Open true"), s += " >>", x.content = s, this.internal.write(b.objId, "0 R", x.objId, "0 R");
            break;
          case "freetext":
            r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y + i.bounds.h) + "] ";
            var C = i.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + f(m(i.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + C + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (i.options.name) {
              var I = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = I.page, i.options.top = I.y;
            } else i.options.top || (i.options.top = 0);
            if (r = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", s = "", i.options.url) s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + f(m(i.options.url)) + ") >>";
            else if (i.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + i.options.top + "]";
                  break;
                case "FitV":
                  i.options.left = i.options.left || 0, s += " /FitV " + i.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var q = a(i.options.top);
                  i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), s += " /XYZ " + i.options.left + " " + q + " " + i.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(e) {
    var i = this.internal.getCurrentPageInfo();
    switch (e.type) {
      case "link":
        this.link(e.bounds.x, e.bounds.y, e.bounds.w, e.bounds.h, e);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(e);
    }
  }, n.link = function(e, i, r, s, o) {
    var a = this.internal.getCurrentPageInfo(), l = this.internal.getCoordinateString, h = this.internal.getVerticalCoordinateString;
    a.pageContext.annotations.push({ finalBounds: { x: l(e), y: h(i), w: l(e + r), h: h(i + s) }, options: o, type: "link" });
  }, n.textWithLink = function(e, i, r, s) {
    var o, a, l = this.getTextWidth(e), h = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      a = s.maxWidth;
      var u = this.splitTextToSize(e, a).length;
      o = Math.ceil(h * u);
    } else a = l, o = h;
    return this.text(e, i, r, s), r += 0.2 * h, s.align === "center" && (i -= l / 2), s.align === "right" && (i -= l), this.link(i, r - h, a, o, s), l;
  }, n.getTextWidth = function(e) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(e) * i / this.internal.scaleFactor;
  };
}(ke.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, e = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, r = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var s = n.__arabicParser__.isInArabicSubstitutionA = function(b) {
    return t[b.charCodeAt(0)] !== void 0;
  }, o = n.__arabicParser__.isArabicLetter = function(b) {
    return typeof b == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(b);
  }, a = n.__arabicParser__.isArabicEndLetter = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length <= 2;
  }, l = n.__arabicParser__.isArabicAlfLetter = function(b) {
    return o(b) && r.indexOf(b.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 1;
  };
  var h = n.__arabicParser__.arabicLetterHasFinalForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 3;
  };
  var u = n.__arabicParser__.arabicLetterHasMedialForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length == 4;
  }, d = n.__arabicParser__.resolveLigatures = function(b) {
    var x = 0, y = e, v = "", k = 0;
    for (x = 0; x < b.length; x += 1) y[b.charCodeAt(x)] !== void 0 ? (k++, typeof (y = y[b.charCodeAt(x)]) == "number" && (v += String.fromCharCode(y), y = e, k = 0), x === b.length - 1 && (y = e, v += b.charAt(x - (k - 1)), x -= k - 1, k = 0)) : (y = e, v += b.charAt(x - k), x -= k, k = 0);
    return v;
  };
  n.__arabicParser__.isArabicDiacritic = function(b) {
    return b !== void 0 && i[b.charCodeAt(0)] !== void 0;
  };
  var p = n.__arabicParser__.getCorrectForm = function(b, x, y) {
    return o(b) ? s(b) === !1 ? -1 : !h(b) || !o(x) && !o(y) || !o(y) && a(x) || a(b) && !o(x) || a(b) && l(x) || a(b) && a(x) ? 0 : u(b) && o(x) && !a(x) && o(y) && h(y) ? 3 : a(b) || !o(y) ? 1 : 2 : -1;
  }, f = function(b) {
    var x = 0, y = 0, v = 0, k = "", C = "", I = "", q = (b = b || "").split("\\s+"), O = [];
    for (x = 0; x < q.length; x += 1) {
      for (O.push(""), y = 0; y < q[x].length; y += 1) k = q[x][y], C = q[x][y - 1], I = q[x][y + 1], o(k) ? (v = p(k, C, I), O[x] += v !== -1 ? String.fromCharCode(t[k.charCodeAt(0)][v]) : k) : O[x] += k;
      O[x] = d(O[x]);
    }
    return O.join(" ");
  }, m = n.__arabicParser__.processArabic = n.processArabic = function() {
    var b, x = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, y = [];
    if (Array.isArray(x)) {
      var v = 0;
      for (y = [], v = 0; v < x.length; v += 1) Array.isArray(x[v]) ? y.push([f(x[v][0]), x[v][1], x[v][2]]) : y.push([f(x[v])]);
      b = y;
    } else b = f(x);
    return typeof arguments[0] == "string" ? b : (arguments[0].text = b, arguments[0]);
  };
  n.events.push(["preProcessText", m]);
}(ke.API), ke.API.autoPrint = function(n) {
  var t;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        t = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + t + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    var e = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return e;
    }, set: function(a) {
      e = a;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(a) {
      i = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 150 : a, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(a) {
      r = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 300 : a, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(a) {
      s = a;
    } });
    var o = {};
    Object.defineProperty(this, "style", { get: function() {
      return o;
    }, set: function(a) {
      o = a;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  t.prototype.getContext = function(e, i) {
    var r;
    if ((e = e || "2d") !== "2d") return null;
    for (r in i) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = i[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, t.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new t(), this.canvas.pdf = this;
  }]);
}(ke.API), function(n) {
  var t = { left: 0, top: 0, bottom: 0, right: 0 }, e = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, t), this.internal.__cell__.margins.width = this.getPageWidth(), r.call(this));
  }, r = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var l = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return l;
    }, set: function(b) {
      l = b;
    } });
    var h = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return h;
    }, set: function(b) {
      h = b;
    } });
    var u = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return u;
    }, set: function(b) {
      u = b;
    } });
    var d = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return d;
    }, set: function(b) {
      d = b;
    } });
    var p = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return p;
    }, set: function(b) {
      p = b;
    } });
    var f = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return f;
    }, set: function(b) {
      f = b;
    } });
    var m = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return m;
    }, set: function(b) {
      m = b;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(l) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof l == "function" ? l : void 0, this;
  }, n.getTextDimensions = function(l, h) {
    i.call(this);
    var u = (h = h || {}).fontSize || this.getFontSize(), d = h.font || this.getFont(), p = h.scaleFactor || this.internal.scaleFactor, f = 0, m = 0, b = 0, x = this;
    if (!Array.isArray(l) && typeof l != "string") {
      if (typeof l != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      l = String(l);
    }
    var y = h.maxWidth;
    y > 0 ? typeof l == "string" ? l = this.splitTextToSize(l, y) : Object.prototype.toString.call(l) === "[object Array]" && (l = l.reduce(function(k, C) {
      return k.concat(x.splitTextToSize(C, y));
    }, [])) : l = Array.isArray(l) ? l : [l];
    for (var v = 0; v < l.length; v++) f < (b = this.getStringUnitWidth(l[v], { font: d }) * u) && (f = b);
    return f !== 0 && (m = l.length), { w: f /= p, h: Math.max((m * u * this.getLineHeightFactor() - u * (this.getLineHeightFactor() - 1)) / p, 0) };
  }, n.cellAddPage = function() {
    i.call(this), this.addPage();
    var l = this.internal.__cell__.margins || t;
    return this.internal.__cell__.lastCell = new s(l.left, l.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var o = n.cell = function() {
    var l;
    l = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var h = this.internal.__cell__.lastCell, u = this.internal.__cell__.padding, d = this.internal.__cell__.margins || t, p = this.internal.__cell__.tableHeaderRow, f = this.internal.__cell__.printHeaders;
    return h.lineNumber !== void 0 && (h.lineNumber === l.lineNumber ? (l.x = (h.x || 0) + (h.width || 0), l.y = h.y || 0) : h.y + h.height + l.height + d.bottom > this.getPageHeight() ? (this.cellAddPage(), l.y = d.top, f && p && (this.printHeaderRow(l.lineNumber, !0), l.y += p[0].height)) : l.y = h.y + h.height || l.y), l.text[0] !== void 0 && (this.rect(l.x, l.y, l.width, l.height, e === !0 ? "FD" : void 0), l.align === "right" ? this.text(l.text, l.x + l.width - u, l.y + u, { align: "right", baseline: "top" }) : l.align === "center" ? this.text(l.text, l.x + l.width / 2, l.y + u, { align: "center", baseline: "top", maxWidth: l.width - u - u }) : this.text(l.text, l.x + u, l.y + u, { align: "left", baseline: "top", maxWidth: l.width - u - u })), this.internal.__cell__.lastCell = l, this;
  };
  n.table = function(l, h, u, d, p) {
    if (i.call(this), !u) throw new Error("No data for PDF table.");
    var f, m, b, x, y = [], v = [], k = [], C = {}, I = {}, q = [], O = [], F = (p = p || {}).autoSize || !1, M = p.printHeaders !== !1, j = p.css && p.css["font-size"] !== void 0 ? 16 * p.css["font-size"] : p.fontSize || 12, P = p.margins || Object.assign({ width: this.getPageWidth() }, t), A = typeof p.padding == "number" ? p.padding : 3, T = p.headerBackgroundColor || "#c8c8c8", _ = p.headerTextColor || "#000";
    if (r.call(this), this.internal.__cell__.printHeaders = M, this.internal.__cell__.margins = P, this.internal.__cell__.table_font_size = j, this.internal.__cell__.padding = A, this.internal.__cell__.headerBackgroundColor = T, this.internal.__cell__.headerTextColor = _, this.setFontSize(j), d == null) v = y = Object.keys(u[0]), k = y.map(function() {
      return "left";
    });
    else if (Array.isArray(d) && nn(d[0]) === "object") for (y = d.map(function(ct) {
      return ct.name;
    }), v = d.map(function(ct) {
      return ct.prompt || ct.name || "";
    }), k = d.map(function(ct) {
      return ct.align || "left";
    }), f = 0; f < d.length; f += 1) I[d[f].name] = d[f].width * (19.049976 / 25.4);
    else Array.isArray(d) && typeof d[0] == "string" && (v = y = d, k = y.map(function() {
      return "left";
    }));
    if (F || Array.isArray(d) && typeof d[0] == "string") for (f = 0; f < y.length; f += 1) {
      for (C[x = y[f]] = u.map(function(ct) {
        return ct[x];
      }), this.setFont(void 0, "bold"), q.push(this.getTextDimensions(v[f], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), m = C[x], this.setFont(void 0, "normal"), b = 0; b < m.length; b += 1) q.push(this.getTextDimensions(m[b], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      I[x] = Math.max.apply(null, q) + A + A, q = [];
    }
    if (M) {
      var Z = {};
      for (f = 0; f < y.length; f += 1) Z[y[f]] = {}, Z[y[f]].text = v[f], Z[y[f]].align = k[f];
      var V = a.call(this, Z, I);
      O = y.map(function(ct) {
        return new s(l, h, I[ct], V, Z[ct].text, void 0, Z[ct].align);
      }), this.setTableHeaderRow(O), this.printHeaderRow(1, !1);
    }
    var R = d.reduce(function(ct, nt) {
      return ct[nt.name] = nt.align, ct;
    }, {});
    for (f = 0; f < u.length; f += 1) {
      "rowStart" in p && p.rowStart instanceof Function && p.rowStart({ row: f, data: u[f] }, this);
      var Q = a.call(this, u[f], I);
      for (b = 0; b < y.length; b += 1) {
        var H = u[f][y[b]];
        "cellStart" in p && p.cellStart instanceof Function && p.cellStart({ row: f, col: b, data: H }, this), o.call(this, new s(l, h, I[y[b]], Q, H, f + 2, R[y[b]]));
      }
    }
    return this.internal.__cell__.table_x = l, this.internal.__cell__.table_y = h, this;
  };
  var a = function(l, h) {
    var u = this.internal.__cell__.padding, d = this.internal.__cell__.table_font_size, p = this.internal.scaleFactor;
    return Object.keys(l).map(function(f) {
      var m = l[f];
      return this.splitTextToSize(m.hasOwnProperty("text") ? m.text : m, h[f] - u - u);
    }, this).map(function(f) {
      return this.getLineHeightFactor() * f.length * d / p + u + u;
    }, this).reduce(function(f, m) {
      return Math.max(f, m);
    }, 0);
  };
  n.setTableHeaderRow = function(l) {
    i.call(this), this.internal.__cell__.tableHeaderRow = l;
  }, n.printHeaderRow = function(l, h) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var u;
    if (e = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var d = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(d[0], d[1], d[2], d[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var p = [], f = 0; f < this.internal.__cell__.tableHeaderRow.length; f += 1) {
      u = this.internal.__cell__.tableHeaderRow[f].clone(), h && (u.y = this.internal.__cell__.margins.top || 0, p.push(u)), u.lineNumber = l;
      var m = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), o.call(this, u), this.setTextColor(m);
    }
    p.length > 0 && this.setTableHeaderRow(p), this.setFont(void 0, "normal"), e = !1;
  };
}(ke.API);
var M1 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, R1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], mf = F1(R1), D1 = [100, 200, 300, 400, 500, 600, 700, 800, 900], Iv = F1(D1);
function yf(n) {
  var t = n.family.replace(/"|'/g, "").toLowerCase(), e = function(s) {
    return M1[s = s || "normal"] ? s : "normal";
  }(n.style), i = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), r = function(s) {
    return typeof mf[s = s || "normal"] == "number" ? s : "normal";
  }(n.stretch);
  return { family: t, style: e, weight: i, stretch: r, src: n.src || [], ref: n.ref || { name: t, style: [r, e, i].join(" ") } };
}
function Zp(n, t, e, i) {
  var r;
  for (r = e; r >= 0 && r < t.length; r += i) if (n[t[r]]) return n[t[r]];
  for (r = e; r >= 0 && r < t.length; r -= i) if (n[t[r]]) return n[t[r]];
}
var Ev = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Qp = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function tg(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function Ov(n, t, e) {
  for (var i = (e = e || {}).defaultFontFamily || "times", r = Object.assign({}, Ev, e.genericFontFamilies || {}), s = null, o = null, a = 0; a < t.length; ++a) if (r[(s = yf(t[a])).family] && (s.family = r[s.family]), n.hasOwnProperty(s.family)) {
    o = n[s.family];
    break;
  }
  if (!(o = o || n[i])) throw new Error("Could not find a font-family for the rule '" + tg(s) + "' and default family '" + i + "'.");
  if (o = function(l, h) {
    if (h[l]) return h[l];
    var u = mf[l], d = u <= mf.normal ? -1 : 1, p = Zp(h, R1, u, d);
    if (!p) throw new Error("Could not find a matching font-stretch value for " + l);
    return p;
  }(s.stretch, o), o = function(l, h) {
    if (h[l]) return h[l];
    for (var u = M1[l], d = 0; d < u.length; ++d) if (h[u[d]]) return h[u[d]];
    throw new Error("Could not find a matching font-style for " + l);
  }(s.style, o), !(o = function(l, h) {
    if (h[l]) return h[l];
    if (l === 400 && h[500]) return h[500];
    if (l === 500 && h[400]) return h[400];
    var u = Iv[l], d = Zp(h, D1, u, l < 400 ? -1 : 1);
    if (!d) throw new Error("Could not find a matching font-weight for value " + l);
    return d;
  }(s.weight, o))) throw new Error("Failed to resolve a font for the rule '" + tg(s) + "'.");
  return o;
}
function eg(n) {
  return n.trimLeft();
}
function Tv(n, t) {
  for (var e = 0; e < n.length; ) {
    if (n.charAt(e) === t) return [n.substring(0, e), n.substring(e + 1)];
    e += 1;
  }
  return null;
}
function Fv(n) {
  var t = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return t === null ? null : [t[0], n.substring(t[0].length)];
}
var Pu, ng, ig, Lh = ["times"];
(function(n) {
  var t, e, i, r, s, o, a, l, h, u = function(N) {
    return N = N || {}, this.isStrokeTransparent = N.isStrokeTransparent || !1, this.strokeOpacity = N.strokeOpacity || 1, this.strokeStyle = N.strokeStyle || "#000000", this.fillStyle = N.fillStyle || "#000000", this.isFillTransparent = N.isFillTransparent || !1, this.fillOpacity = N.fillOpacity || 1, this.font = N.font || "10px sans-serif", this.textBaseline = N.textBaseline || "alphabetic", this.textAlign = N.textAlign || "left", this.lineWidth = N.lineWidth || 1, this.lineJoin = N.lineJoin || "miter", this.lineCap = N.lineCap || "butt", this.path = N.path || [], this.transform = N.transform !== void 0 ? N.transform.clone() : new l(), this.globalCompositeOperation = N.globalCompositeOperation || "normal", this.globalAlpha = N.globalAlpha || 1, this.clip_path = N.clip_path || [], this.currentPoint = N.currentPoint || new o(), this.miterLimit = N.miterLimit || 10, this.lastPoint = N.lastPoint || new o(), this.lineDashOffset = N.lineDashOffset || 0, this.lineDash = N.lineDash || [], this.margin = N.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = N.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof N.ignoreClearRect != "boolean" || N.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new d(this), t = this.internal.f2, e = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, r = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, o = this.internal.Point, a = this.internal.Rectangle, l = this.internal.Matrix, h = new u();
  }]);
  var d = function(N) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var z = N;
    Object.defineProperty(this, "pdf", { get: function() {
      return z;
    } });
    var G = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return G;
    }, set: function(ft) {
      G = !!ft;
    } });
    var Y = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Y;
    }, set: function(ft) {
      Y = !!ft;
    } });
    var st = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return st;
    }, set: function(ft) {
      isNaN(ft) || (st = ft);
    } });
    var vt = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return vt;
    }, set: function(ft) {
      isNaN(ft) || (vt = ft);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return h.margin;
    }, set: function(ft) {
      var U;
      typeof ft == "number" ? U = [ft, ft, ft, ft] : ((U = new Array(4))[0] = ft[0], U[1] = ft.length >= 2 ? ft[1] : U[0], U[2] = ft.length >= 3 ? ft[2] : U[0], U[3] = ft.length >= 4 ? ft[3] : U[1]), h.margin = U;
    } });
    var mt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return mt;
    }, set: function(ft) {
      mt = ft;
    } });
    var _t = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return _t;
    }, set: function(ft) {
      _t = ft;
    } });
    var Bt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return Bt;
    }, set: function(ft) {
      Bt = ft;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return h;
    }, set: function(ft) {
      ft instanceof u && (h = ft);
    } }), Object.defineProperty(this, "path", { get: function() {
      return h.path;
    }, set: function(ft) {
      h.path = ft;
    } });
    var Rt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Rt;
    }, set: function(ft) {
      Rt = ft;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ft) {
      var U;
      U = p(ft), this.ctx.fillStyle = U.style, this.ctx.isFillTransparent = U.a === 0, this.ctx.fillOpacity = U.a, this.pdf.setFillColor(U.r, U.g, U.b, { a: U.a }), this.pdf.setTextColor(U.r, U.g, U.b, { a: U.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ft) {
      var U = p(ft);
      this.ctx.strokeStyle = U.style, this.ctx.isStrokeTransparent = U.a === 0, this.ctx.strokeOpacity = U.a, U.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (U.a, this.pdf.setDrawColor(U.r, U.g, U.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ft) {
      ["butt", "round", "square"].indexOf(ft) !== -1 && (this.ctx.lineCap = ft, this.pdf.setLineCap(ft));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ft) {
      isNaN(ft) || (this.ctx.lineWidth = ft, this.pdf.setLineWidth(ft));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ft) {
      ["bevel", "round", "miter"].indexOf(ft) !== -1 && (this.ctx.lineJoin = ft, this.pdf.setLineJoin(ft));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ft) {
      isNaN(ft) || (this.ctx.miterLimit = ft, this.pdf.setMiterLimit(ft));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ft) {
      this.ctx.textBaseline = ft;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ft) {
      ["right", "end", "center", "left", "start"].indexOf(ft) !== -1 && (this.ctx.textAlign = ft);
    } });
    var te = null;
    function Xt(ft, U) {
      if (te === null) {
        var et = function(X) {
          var rt = [];
          return Object.keys(X).forEach(function(wt) {
            X[wt].forEach(function(kt) {
              var dt = null;
              switch (kt) {
                case "bold":
                  dt = { family: wt, weight: "bold" };
                  break;
                case "italic":
                  dt = { family: wt, style: "italic" };
                  break;
                case "bolditalic":
                  dt = { family: wt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  dt = { family: wt };
              }
              dt !== null && (dt.ref = { name: wt, style: kt }, rt.push(dt));
            });
          }), rt;
        }(ft.getFontList());
        te = function(X) {
          for (var rt = {}, wt = 0; wt < X.length; ++wt) {
            var kt = yf(X[wt]), dt = kt.family, Pt = kt.stretch, qt = kt.style, Ft = kt.weight;
            rt[dt] = rt[dt] || {}, rt[dt][Pt] = rt[dt][Pt] || {}, rt[dt][Pt][qt] = rt[dt][Pt][qt] || {}, rt[dt][Pt][qt][Ft] = kt;
          }
          return rt;
        }(et.concat(U));
      }
      return te;
    }
    var E = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return E;
    }, set: function(ft) {
      te = null, E = ft;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ft) {
      var U;
      if (this.ctx.font = ft, (U = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ft)) !== null) {
        var et = U[1], X = (U[2], U[3]), rt = U[4], wt = (U[5], U[6]), kt = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(rt)[2];
        rt = Math.floor(kt === "px" ? parseFloat(rt) * this.pdf.internal.scaleFactor : kt === "em" ? parseFloat(rt) * this.pdf.getFontSize() : parseFloat(rt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(rt);
        var dt = function(ue) {
          var we, Qt, Ke = [], ht = ue.trim();
          if (ht === "") return Lh;
          if (ht in Qp) return [Qp[ht]];
          for (; ht !== ""; ) {
            switch (Qt = null, we = (ht = eg(ht)).charAt(0)) {
              case '"':
              case "'":
                Qt = Tv(ht.substring(1), we);
                break;
              default:
                Qt = Fv(ht);
            }
            if (Qt === null || (Ke.push(Qt[0]), (ht = eg(Qt[1])) !== "" && ht.charAt(0) !== ",")) return Lh;
            ht = ht.replace(/^,/, "");
          }
          return Ke;
        }(wt);
        if (this.fontFaces) {
          var Pt = Ov(Xt(this.pdf, this.fontFaces), dt.map(function(ue) {
            return { family: ue, stretch: "normal", weight: X, style: et };
          }));
          this.pdf.setFont(Pt.ref.name, Pt.ref.style);
        } else {
          var qt = "";
          (X === "bold" || parseInt(X, 10) >= 700 || et === "bold") && (qt = "bold"), et === "italic" && (qt += "italic"), qt.length === 0 && (qt = "normal");
          for (var Ft = "", Vt = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, ne = 0; ne < dt.length; ne++) {
            if (this.pdf.internal.getFont(dt[ne], qt, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Ft = dt[ne];
              break;
            }
            if (qt === "bolditalic" && this.pdf.internal.getFont(dt[ne], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Ft = dt[ne], qt = "bold";
            else if (this.pdf.internal.getFont(dt[ne], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Ft = dt[ne], qt = "normal";
              break;
            }
          }
          if (Ft === "") {
            for (var ie = 0; ie < dt.length; ie++) if (Vt[dt[ie]]) {
              Ft = Vt[dt[ie]];
              break;
            }
          }
          Ft = Ft === "" ? "Times" : Ft, this.pdf.setFont(Ft, qt);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ft) {
      this.ctx.globalCompositeOperation = ft;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ft) {
      this.ctx.globalAlpha = ft;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ft) {
      this.ctx.lineDashOffset = ft, nt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ft) {
      this.ctx.lineDash = ft, nt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ft) {
      this.ctx.ignoreClearRect = !!ft;
    } });
  };
  d.prototype.setLineDash = function(N) {
    this.lineDash = N;
  }, d.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, d.prototype.fill = function() {
    C.call(this, "fill", !1);
  }, d.prototype.stroke = function() {
    C.call(this, "stroke", !1);
  }, d.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, d.prototype.moveTo = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw ln.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var G = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "mt", x: G.x, y: G.y }), this.ctx.lastPoint = new o(N, z);
  }, d.prototype.closePath = function() {
    var N = new o(0, 0), z = 0;
    for (z = this.path.length - 1; z !== -1; z--) if (this.path[z].type === "begin" && nn(this.path[z + 1]) === "object" && typeof this.path[z + 1].x == "number") {
      N = new o(this.path[z + 1].x, this.path[z + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new o(N.x, N.y);
  }, d.prototype.lineTo = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw ln.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var G = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "lt", x: G.x, y: G.y }), this.ctx.lastPoint = new o(G.x, G.y);
  }, d.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), C.call(this, null, !0);
  }, d.prototype.quadraticCurveTo = function(N, z, G, Y) {
    if (isNaN(G) || isNaN(Y) || isNaN(N) || isNaN(z)) throw ln.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var st = this.ctx.transform.applyToPoint(new o(G, Y)), vt = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "qct", x1: vt.x, y1: vt.y, x: st.x, y: st.y }), this.ctx.lastPoint = new o(st.x, st.y);
  }, d.prototype.bezierCurveTo = function(N, z, G, Y, st, vt) {
    if (isNaN(st) || isNaN(vt) || isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw ln.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var mt = this.ctx.transform.applyToPoint(new o(st, vt)), _t = this.ctx.transform.applyToPoint(new o(N, z)), Bt = this.ctx.transform.applyToPoint(new o(G, Y));
    this.path.push({ type: "bct", x1: _t.x, y1: _t.y, x2: Bt.x, y2: Bt.y, x: mt.x, y: mt.y }), this.ctx.lastPoint = new o(mt.x, mt.y);
  }, d.prototype.arc = function(N, z, G, Y, st, vt) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y) || isNaN(st)) throw ln.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (vt = !!vt, !this.ctx.transform.isIdentity) {
      var mt = this.ctx.transform.applyToPoint(new o(N, z));
      N = mt.x, z = mt.y;
      var _t = this.ctx.transform.applyToPoint(new o(0, G)), Bt = this.ctx.transform.applyToPoint(new o(0, 0));
      G = Math.sqrt(Math.pow(_t.x - Bt.x, 2) + Math.pow(_t.y - Bt.y, 2));
    }
    Math.abs(st - Y) >= 2 * Math.PI && (Y = 0, st = 2 * Math.PI), this.path.push({ type: "arc", x: N, y: z, radius: G, startAngle: Y, endAngle: st, counterclockwise: vt });
  }, d.prototype.arcTo = function(N, z, G, Y, st) {
    throw new Error("arcTo not implemented.");
  }, d.prototype.rect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw ln.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(N, z), this.lineTo(N + G, z), this.lineTo(N + G, z + Y), this.lineTo(N, z + Y), this.lineTo(N, z), this.lineTo(N + G, z), this.lineTo(N, z);
  }, d.prototype.fillRect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw ln.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!f.call(this)) {
      var st = {};
      this.lineCap !== "butt" && (st.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (st.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(N, z, G, Y), this.fill(), st.hasOwnProperty("lineCap") && (this.lineCap = st.lineCap), st.hasOwnProperty("lineJoin") && (this.lineJoin = st.lineJoin);
    }
  }, d.prototype.strokeRect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw ln.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    m.call(this) || (this.beginPath(), this.rect(N, z, G, Y), this.stroke());
  }, d.prototype.clearRect = function(N, z, G, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y)) throw ln.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(N, z, G, Y));
  }, d.prototype.save = function(N) {
    N = typeof N != "boolean" || N;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(z), N) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Y = new u(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Y;
    }
  }, d.prototype.restore = function(N) {
    N = typeof N != "boolean" || N;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(z), N && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, d.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var p = function(N) {
    var z, G, Y, st;
    if (N.isCanvasGradient === !0 && (N = N.getColor()), !N) return { r: 0, g: 0, b: 0, a: 0, style: N };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(N)) z = 0, G = 0, Y = 0, st = 0;
    else {
      var vt = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(N);
      if (vt !== null) z = parseInt(vt[1]), G = parseInt(vt[2]), Y = parseInt(vt[3]), st = 1;
      else if ((vt = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(N)) !== null) z = parseInt(vt[1]), G = parseInt(vt[2]), Y = parseInt(vt[3]), st = parseFloat(vt[4]);
      else {
        if (st = 1, typeof N == "string" && N.charAt(0) !== "#") {
          var mt = new P1(N);
          N = mt.ok ? mt.toHex() : "#000000";
        }
        N.length === 4 ? (z = N.substring(1, 2), z += z, G = N.substring(2, 3), G += G, Y = N.substring(3, 4), Y += Y) : (z = N.substring(1, 3), G = N.substring(3, 5), Y = N.substring(5, 7)), z = parseInt(z, 16), G = parseInt(G, 16), Y = parseInt(Y, 16);
      }
    }
    return { r: z, g: G, b: Y, a: st, style: N };
  }, f = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, m = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  d.prototype.fillText = function(N, z, G, Y) {
    if (isNaN(z) || isNaN(G) || typeof N != "string") throw ln.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Y = isNaN(Y) ? void 0 : Y, !f.call(this)) {
      var st = Q(this.ctx.transform.rotation), vt = this.ctx.transform.scaleX;
      A.call(this, { text: N, x: z, y: G, scale: vt, angle: st, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.strokeText = function(N, z, G, Y) {
    if (isNaN(z) || isNaN(G) || typeof N != "string") throw ln.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!m.call(this)) {
      Y = isNaN(Y) ? void 0 : Y;
      var st = Q(this.ctx.transform.rotation), vt = this.ctx.transform.scaleX;
      A.call(this, { text: N, x: z, y: G, scale: vt, renderingMode: "stroke", angle: st, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.measureText = function(N) {
    if (typeof N != "string") throw ln.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var z = this.pdf, G = this.pdf.internal.scaleFactor, Y = z.internal.getFontSize(), st = z.getStringUnitWidth(N) * Y / z.internal.scaleFactor, vt = function(mt) {
      var _t = (mt = mt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return _t;
      } }), this;
    };
    return new vt({ width: st *= Math.round(96 * G / 72 * 1e4) / 1e4 });
  }, d.prototype.scale = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw ln.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var G = new l(N, 0, 0, z, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, d.prototype.rotate = function(N) {
    if (isNaN(N)) throw ln.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var z = new l(Math.cos(N), Math.sin(N), -Math.sin(N), Math.cos(N), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(z);
  }, d.prototype.translate = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw ln.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var G = new l(1, 0, 0, 1, N, z);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, d.prototype.transform = function(N, z, G, Y, st, vt) {
    if (isNaN(N) || isNaN(z) || isNaN(G) || isNaN(Y) || isNaN(st) || isNaN(vt)) throw ln.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var mt = new l(N, z, G, Y, st, vt);
    this.ctx.transform = this.ctx.transform.multiply(mt);
  }, d.prototype.setTransform = function(N, z, G, Y, st, vt) {
    N = isNaN(N) ? 1 : N, z = isNaN(z) ? 0 : z, G = isNaN(G) ? 0 : G, Y = isNaN(Y) ? 1 : Y, st = isNaN(st) ? 0 : st, vt = isNaN(vt) ? 0 : vt, this.ctx.transform = new l(N, z, G, Y, st, vt);
  };
  var b = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  d.prototype.drawImage = function(N, z, G, Y, st, vt, mt, _t, Bt) {
    var Rt = this.pdf.getImageProperties(N), te = 1, Xt = 1, E = 1, ft = 1;
    Y !== void 0 && _t !== void 0 && (E = _t / Y, ft = Bt / st, te = Rt.width / Y * _t / Y, Xt = Rt.height / st * Bt / st), vt === void 0 && (vt = z, mt = G, z = 0, G = 0), Y !== void 0 && _t === void 0 && (_t = Y, Bt = st), Y === void 0 && _t === void 0 && (_t = Rt.width, Bt = Rt.height);
    for (var U, et = this.ctx.transform.decompose(), X = Q(et.rotate.shx), rt = new l(), wt = (rt = (rt = (rt = rt.multiply(et.translate)).multiply(et.skew)).multiply(et.scale)).applyToRectangle(new a(vt - z * E, mt - G * ft, Y * te, st * Xt)), kt = x.call(this, wt), dt = [], Pt = 0; Pt < kt.length; Pt += 1) dt.indexOf(kt[Pt]) === -1 && dt.push(kt[Pt]);
    if (k(dt), this.autoPaging) for (var qt = dt[0], Ft = dt[dt.length - 1], Vt = qt; Vt < Ft + 1; Vt++) {
      this.pdf.setPage(Vt);
      var ne = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], ie = Vt === 1 ? this.posY + this.margin[0] : this.margin[0], ue = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], we = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Qt = Vt === 1 ? 0 : ue + (Vt - 2) * we;
      if (this.ctx.clip_path.length !== 0) {
        var Ke = this.path;
        U = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(U, this.posX + this.margin[3], -Qt + ie + this.ctx.prevPageLastElemOffset), I.call(this, "fill", !0), this.path = Ke;
      }
      var ht = JSON.parse(JSON.stringify(wt));
      ht = v([ht], this.posX + this.margin[3], -Qt + ie + this.ctx.prevPageLastElemOffset)[0];
      var jt = (Vt > qt || Vt < Ft) && b.call(this);
      jt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ne, we, null).clip().discardPath()), this.pdf.addImage(N, "JPEG", ht.x, ht.y, ht.w, ht.h, null, null, X), jt && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(N, "JPEG", wt.x, wt.y, wt.w, wt.h, null, null, X);
  };
  var x = function(N, z, G) {
    var Y = [];
    z = z || this.pdf.internal.pageSize.width, G = G || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var st = this.posY + this.ctx.prevPageLastElemOffset;
    switch (N.type) {
      default:
      case "mt":
      case "lt":
        Y.push(Math.floor((N.y + st) / G) + 1);
        break;
      case "arc":
        Y.push(Math.floor((N.y + st - N.radius) / G) + 1), Y.push(Math.floor((N.y + st + N.radius) / G) + 1);
        break;
      case "qct":
        var vt = H(this.ctx.lastPoint.x, this.ctx.lastPoint.y, N.x1, N.y1, N.x, N.y);
        Y.push(Math.floor((vt.y + st) / G) + 1), Y.push(Math.floor((vt.y + vt.h + st) / G) + 1);
        break;
      case "bct":
        var mt = ct(this.ctx.lastPoint.x, this.ctx.lastPoint.y, N.x1, N.y1, N.x2, N.y2, N.x, N.y);
        Y.push(Math.floor((mt.y + st) / G) + 1), Y.push(Math.floor((mt.y + mt.h + st) / G) + 1);
        break;
      case "rect":
        Y.push(Math.floor((N.y + st) / G) + 1), Y.push(Math.floor((N.y + N.h + st) / G) + 1);
    }
    for (var _t = 0; _t < Y.length; _t += 1) for (; this.pdf.internal.getNumberOfPages() < Y[_t]; ) y.call(this);
    return Y;
  }, y = function() {
    var N = this.fillStyle, z = this.strokeStyle, G = this.font, Y = this.lineCap, st = this.lineWidth, vt = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = N, this.strokeStyle = z, this.font = G, this.lineCap = Y, this.lineWidth = st, this.lineJoin = vt;
  }, v = function(N, z, G) {
    for (var Y = 0; Y < N.length; Y++) switch (N[Y].type) {
      case "bct":
        N[Y].x2 += z, N[Y].y2 += G;
      case "qct":
        N[Y].x1 += z, N[Y].y1 += G;
      case "mt":
      case "lt":
      case "arc":
      default:
        N[Y].x += z, N[Y].y += G;
    }
    return N;
  }, k = function(N) {
    return N.sort(function(z, G) {
      return z - G;
    });
  }, C = function(N, z) {
    for (var G, Y, st = this.fillStyle, vt = this.strokeStyle, mt = this.lineCap, _t = this.lineWidth, Bt = Math.abs(_t * this.ctx.transform.scaleX), Rt = this.lineJoin, te = JSON.parse(JSON.stringify(this.path)), Xt = JSON.parse(JSON.stringify(this.path)), E = [], ft = 0; ft < Xt.length; ft++) if (Xt[ft].x !== void 0) for (var U = x.call(this, Xt[ft]), et = 0; et < U.length; et += 1) E.indexOf(U[et]) === -1 && E.push(U[et]);
    for (var X = 0; X < E.length; X++) for (; this.pdf.internal.getNumberOfPages() < E[X]; ) y.call(this);
    if (k(E), this.autoPaging) for (var rt = E[0], wt = E[E.length - 1], kt = rt; kt < wt + 1; kt++) {
      this.pdf.setPage(kt), this.fillStyle = st, this.strokeStyle = vt, this.lineCap = mt, this.lineWidth = Bt, this.lineJoin = Rt;
      var dt = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Pt = kt === 1 ? this.posY + this.margin[0] : this.margin[0], qt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ft = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Vt = kt === 1 ? 0 : qt + (kt - 2) * Ft;
      if (this.ctx.clip_path.length !== 0) {
        var ne = this.path;
        G = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(G, this.posX + this.margin[3], -Vt + Pt + this.ctx.prevPageLastElemOffset), I.call(this, N, !0), this.path = ne;
      }
      if (Y = JSON.parse(JSON.stringify(te)), this.path = v(Y, this.posX + this.margin[3], -Vt + Pt + this.ctx.prevPageLastElemOffset), z === !1 || kt === 0) {
        var ie = (kt > rt || kt < wt) && b.call(this);
        ie && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], dt, Ft, null).clip().discardPath()), I.call(this, N, z), ie && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = _t;
    }
    else this.lineWidth = Bt, I.call(this, N, z), this.lineWidth = _t;
    this.path = te;
  }, I = function(N, z) {
    if ((N !== "stroke" || z || !m.call(this)) && (N === "stroke" || z || !f.call(this))) {
      for (var G, Y, st = [], vt = this.path, mt = 0; mt < vt.length; mt++) {
        var _t = vt[mt];
        switch (_t.type) {
          case "begin":
            st.push({ begin: !0 });
            break;
          case "close":
            st.push({ close: !0 });
            break;
          case "mt":
            st.push({ start: _t, deltas: [], abs: [] });
            break;
          case "lt":
            var Bt = st.length;
            if (vt[mt - 1] && !isNaN(vt[mt - 1].x) && (G = [_t.x - vt[mt - 1].x, _t.y - vt[mt - 1].y], Bt > 0)) {
              for (; Bt >= 0; Bt--) if (st[Bt - 1].close !== !0 && st[Bt - 1].begin !== !0) {
                st[Bt - 1].deltas.push(G), st[Bt - 1].abs.push(_t);
                break;
              }
            }
            break;
          case "bct":
            G = [_t.x1 - vt[mt - 1].x, _t.y1 - vt[mt - 1].y, _t.x2 - vt[mt - 1].x, _t.y2 - vt[mt - 1].y, _t.x - vt[mt - 1].x, _t.y - vt[mt - 1].y], st[st.length - 1].deltas.push(G);
            break;
          case "qct":
            var Rt = vt[mt - 1].x + 2 / 3 * (_t.x1 - vt[mt - 1].x), te = vt[mt - 1].y + 2 / 3 * (_t.y1 - vt[mt - 1].y), Xt = _t.x + 2 / 3 * (_t.x1 - _t.x), E = _t.y + 2 / 3 * (_t.y1 - _t.y), ft = _t.x, U = _t.y;
            G = [Rt - vt[mt - 1].x, te - vt[mt - 1].y, Xt - vt[mt - 1].x, E - vt[mt - 1].y, ft - vt[mt - 1].x, U - vt[mt - 1].y], st[st.length - 1].deltas.push(G);
            break;
          case "arc":
            st.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(st[st.length - 1].abs) && st[st.length - 1].abs.push(_t);
        }
      }
      Y = z ? null : N === "stroke" ? "stroke" : "fill";
      for (var et = !1, X = 0; X < st.length; X++) if (st[X].arc) for (var rt = st[X].abs, wt = 0; wt < rt.length; wt++) {
        var kt = rt[wt];
        kt.type === "arc" ? F.call(this, kt.x, kt.y, kt.radius, kt.startAngle, kt.endAngle, kt.counterclockwise, void 0, z, !et) : T.call(this, kt.x, kt.y), et = !0;
      }
      else if (st[X].close === !0) this.pdf.internal.out("h"), et = !1;
      else if (st[X].begin !== !0) {
        var dt = st[X].start.x, Pt = st[X].start.y;
        _.call(this, st[X].deltas, dt, Pt), et = !0;
      }
      Y && M.call(this, Y), z && j.call(this);
    }
  }, q = function(N) {
    var z = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, G = z * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return N - G;
      case "top":
        return N + z - G;
      case "hanging":
        return N + z - 2 * G;
      case "middle":
        return N + z / 2 - G;
      case "ideographic":
        return N;
      case "alphabetic":
      default:
        return N;
    }
  }, O = function(N) {
    return N + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  d.prototype.createLinearGradient = function() {
    var N = function() {
    };
    return N.colorStops = [], N.addColorStop = function(z, G) {
      this.colorStops.push([z, G]);
    }, N.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, N.isCanvasGradient = !0, N;
  }, d.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, d.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var F = function(N, z, G, Y, st, vt, mt, _t, Bt) {
    for (var Rt = V.call(this, G, Y, st, vt), te = 0; te < Rt.length; te++) {
      var Xt = Rt[te];
      te === 0 && (Bt ? P.call(this, Xt.x1 + N, Xt.y1 + z) : T.call(this, Xt.x1 + N, Xt.y1 + z)), Z.call(this, N, z, Xt.x2, Xt.y2, Xt.x3, Xt.y3, Xt.x4, Xt.y4);
    }
    _t ? j.call(this) : M.call(this, mt);
  }, M = function(N) {
    switch (N) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, j = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, P = function(N, z) {
    this.pdf.internal.out(e(N) + " " + i(z) + " m");
  }, A = function(N) {
    var z;
    switch (N.align) {
      case "right":
      case "end":
        z = "right";
        break;
      case "center":
        z = "center";
        break;
      case "left":
      case "start":
      default:
        z = "left";
    }
    var G = this.pdf.getTextDimensions(N.text), Y = q.call(this, N.y), st = O.call(this, Y) - G.h, vt = this.ctx.transform.applyToPoint(new o(N.x, Y)), mt = this.ctx.transform.decompose(), _t = new l();
    _t = (_t = (_t = _t.multiply(mt.translate)).multiply(mt.skew)).multiply(mt.scale);
    for (var Bt, Rt, te, Xt = this.ctx.transform.applyToRectangle(new a(N.x, Y, G.w, G.h)), E = _t.applyToRectangle(new a(N.x, st, G.w, G.h)), ft = x.call(this, E), U = [], et = 0; et < ft.length; et += 1) U.indexOf(ft[et]) === -1 && U.push(ft[et]);
    if (k(U), this.autoPaging) for (var X = U[0], rt = U[U.length - 1], wt = X; wt < rt + 1; wt++) {
      this.pdf.setPage(wt);
      var kt = wt === 1 ? this.posY + this.margin[0] : this.margin[0], dt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Pt = this.pdf.internal.pageSize.height - this.margin[2], qt = Pt - this.margin[0], Ft = this.pdf.internal.pageSize.width - this.margin[1], Vt = Ft - this.margin[3], ne = wt === 1 ? 0 : dt + (wt - 2) * qt;
      if (this.ctx.clip_path.length !== 0) {
        var ie = this.path;
        Bt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(Bt, this.posX + this.margin[3], -1 * ne + kt), I.call(this, "fill", !0), this.path = ie;
      }
      var ue = v([JSON.parse(JSON.stringify(E))], this.posX + this.margin[3], -ne + kt + this.ctx.prevPageLastElemOffset)[0];
      N.scale >= 0.01 && (Rt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Rt * N.scale), te = this.lineWidth, this.lineWidth = te * N.scale);
      var we = this.autoPaging !== "text";
      if (we || ue.y + ue.h <= Pt) {
        if (we || ue.y >= kt && ue.x <= Ft) {
          var Qt = we ? N.text : this.pdf.splitTextToSize(N.text, N.maxWidth || Ft - ue.x)[0], Ke = v([JSON.parse(JSON.stringify(Xt))], this.posX + this.margin[3], -ne + kt + this.ctx.prevPageLastElemOffset)[0], ht = we && (wt > X || wt < rt) && b.call(this);
          ht && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Vt, qt, null).clip().discardPath()), this.pdf.text(Qt, Ke.x, Ke.y, { angle: N.angle, align: z, renderingMode: N.renderingMode }), ht && this.pdf.restoreGraphicsState();
        }
      } else ue.y < Pt && (this.ctx.prevPageLastElemOffset += Pt - ue.y);
      N.scale >= 0.01 && (this.pdf.setFontSize(Rt), this.lineWidth = te);
    }
    else N.scale >= 0.01 && (Rt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Rt * N.scale), te = this.lineWidth, this.lineWidth = te * N.scale), this.pdf.text(N.text, vt.x + this.posX, vt.y + this.posY, { angle: N.angle, align: z, renderingMode: N.renderingMode, maxWidth: N.maxWidth }), N.scale >= 0.01 && (this.pdf.setFontSize(Rt), this.lineWidth = te);
  }, T = function(N, z, G, Y) {
    G = G || 0, Y = Y || 0, this.pdf.internal.out(e(N + G) + " " + i(z + Y) + " l");
  }, _ = function(N, z, G) {
    return this.pdf.lines(N, z, G, null, null);
  }, Z = function(N, z, G, Y, st, vt, mt, _t) {
    this.pdf.internal.out([t(r(G + N)), t(s(Y + z)), t(r(st + N)), t(s(vt + z)), t(r(mt + N)), t(s(_t + z)), "c"].join(" "));
  }, V = function(N, z, G, Y) {
    for (var st = 2 * Math.PI, vt = Math.PI / 2; z > G; ) z -= st;
    var mt = Math.abs(G - z);
    mt < st && Y && (mt = st - mt);
    for (var _t = [], Bt = Y ? -1 : 1, Rt = z; mt > 1e-5; ) {
      var te = Rt + Bt * Math.min(mt, vt);
      _t.push(R.call(this, N, Rt, te)), mt -= Math.abs(te - Rt), Rt = te;
    }
    return _t;
  }, R = function(N, z, G) {
    var Y = (G - z) / 2, st = N * Math.cos(Y), vt = N * Math.sin(Y), mt = st, _t = -vt, Bt = mt * mt + _t * _t, Rt = Bt + mt * st + _t * vt, te = 4 / 3 * (Math.sqrt(2 * Bt * Rt) - Rt) / (mt * vt - _t * st), Xt = mt - te * _t, E = _t + te * mt, ft = Xt, U = -E, et = Y + z, X = Math.cos(et), rt = Math.sin(et);
    return { x1: N * Math.cos(z), y1: N * Math.sin(z), x2: Xt * X - E * rt, y2: Xt * rt + E * X, x3: ft * X - U * rt, y3: ft * rt + U * X, x4: N * Math.cos(G), y4: N * Math.sin(G) };
  }, Q = function(N) {
    return 180 * N / Math.PI;
  }, H = function(N, z, G, Y, st, vt) {
    var mt = N + 0.5 * (G - N), _t = z + 0.5 * (Y - z), Bt = st + 0.5 * (G - st), Rt = vt + 0.5 * (Y - vt), te = Math.min(N, st, mt, Bt), Xt = Math.max(N, st, mt, Bt), E = Math.min(z, vt, _t, Rt), ft = Math.max(z, vt, _t, Rt);
    return new a(te, E, Xt - te, ft - E);
  }, ct = function(N, z, G, Y, st, vt, mt, _t) {
    var Bt, Rt, te, Xt, E, ft, U, et, X, rt, wt, kt, dt, Pt, qt = G - N, Ft = Y - z, Vt = st - G, ne = vt - Y, ie = mt - st, ue = _t - vt;
    for (Rt = 0; Rt < 41; Rt++) X = (U = (te = N + (Bt = Rt / 40) * qt) + Bt * ((E = G + Bt * Vt) - te)) + Bt * (E + Bt * (st + Bt * ie - E) - U), rt = (et = (Xt = z + Bt * Ft) + Bt * ((ft = Y + Bt * ne) - Xt)) + Bt * (ft + Bt * (vt + Bt * ue - ft) - et), Rt == 0 ? (wt = X, kt = rt, dt = X, Pt = rt) : (wt = Math.min(wt, X), kt = Math.min(kt, rt), dt = Math.max(dt, X), Pt = Math.max(Pt, rt));
    return new a(Math.round(wt), Math.round(kt), Math.round(dt - wt), Math.round(Pt - kt));
  }, nt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var N, z, G = (N = this.ctx.lineDash, z = this.ctx.lineDashOffset, JSON.stringify({ lineDash: N, lineDashOffset: z }));
      this.prevLineDash !== G && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = G);
    }
  };
})(ke.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(s) {
    var o, a, l, h, u, d, p, f, m, b;
    for (a = [], l = 0, h = (s += o = "\0\0\0\0".slice(s.length % 4 || 4)).length; h > l; l += 4) (u = (s.charCodeAt(l) << 24) + (s.charCodeAt(l + 1) << 16) + (s.charCodeAt(l + 2) << 8) + s.charCodeAt(l + 3)) !== 0 ? (d = (u = ((u = ((u = ((u = (u - (b = u % 85)) / 85) - (m = u % 85)) / 85) - (f = u % 85)) / 85) - (p = u % 85)) / 85) % 85, a.push(d + 33, p + 33, f + 33, m + 33, b + 33)) : a.push(122);
    return function(x, y) {
      for (var v = y; v > 0; v--) x.pop();
    }(a, o.length), String.fromCharCode.apply(String, a) + "~>";
  }, e = function(s) {
    var o, a, l, h, u, d = String, p = "length", f = 255, m = "charCodeAt", b = "slice", x = "replace";
    for (s[b](-2), s = s[b](0, -2)[x](/\s/g, "")[x]("z", "!!!!!"), l = [], h = 0, u = (s += o = "uuuuu"[b](s[p] % 5 || 5))[p]; u > h; h += 5) a = 52200625 * (s[m](h) - 33) + 614125 * (s[m](h + 1) - 33) + 7225 * (s[m](h + 2) - 33) + 85 * (s[m](h + 3) - 33) + (s[m](h + 4) - 33), l.push(f & a >> 24, f & a >> 16, f & a >> 8, f & a);
    return function(y, v) {
      for (var k = v; k > 0; k--) y.pop();
    }(l, o[p]), d.fromCharCode.apply(d, l);
  }, i = function(s) {
    var o = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), o.test(s) === !1) return "";
    for (var a = "", l = 0; l < s.length; l += 2) a += String.fromCharCode("0x" + (s[l] + s[l + 1]));
    return a;
  }, r = function(s) {
    for (var o = new Uint8Array(s.length), a = s.length; a--; ) o[a] = s.charCodeAt(a);
    return s = (o = hf(o)).reduce(function(l, h) {
      return l + String.fromCharCode(h);
    }, "");
  };
  n.processDataByFilters = function(s, o) {
    var a = 0, l = s || "", h = [];
    for (typeof (o = o || []) == "string" && (o = [o]), a = 0; a < o.length; a += 1) switch (o[a]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        l = e(l), h.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        l = t(l), h.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        l = i(l), h.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        l = l.split("").map(function(u) {
          return ("0" + u.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", h.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        l = r(l), h.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + o[a] + '" is not implemented');
    }
    return { data: l, reverseChain: h.reverse().join(" ") };
  };
}(ke.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.loadFile = function(t, e, i) {
    return function(r, s, o) {
      s = s !== !1, o = typeof o == "function" ? o : function() {
      };
      var a = void 0;
      try {
        a = function(l, h, u) {
          var d = new XMLHttpRequest(), p = 0, f = function(m) {
            var b = m.length, x = [], y = String.fromCharCode;
            for (p = 0; p < b; p += 1) x.push(y(255 & m.charCodeAt(p)));
            return x.join("");
          };
          if (d.open("GET", l, !h), d.overrideMimeType("text/plain; charset=x-user-defined"), h === !1 && (d.onload = function() {
            d.status === 200 ? u(f(this.responseText)) : u(void 0);
          }), d.send(null), h && d.status === 200) return f(d.responseText);
        }(r, s, o);
      } catch {
      }
      return a;
    }(t, e, i);
  }, n.loadImageFile = n.loadFile;
}(ke.API), function(n) {
  function t() {
    return (Le.html2canvas ? Promise.resolve(Le.html2canvas) : import("./html2canvas.esm-d2sM-0Wm.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load html2canvas: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  function e() {
    return (Le.DOMPurify ? Promise.resolve(Le.DOMPurify) : import("./purify.es-DD-6ZaCo.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load dompurify: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  var i = function(o) {
    var a = nn(o);
    return a === "undefined" ? "undefined" : a === "string" || o instanceof String ? "string" : a === "number" || o instanceof Number ? "number" : a === "function" || o instanceof Function ? "function" : o && o.constructor === Array ? "array" : o && o.nodeType === 1 ? "element" : a === "object" ? "object" : "unknown";
  }, r = function(o, a) {
    var l = document.createElement(o);
    for (var h in a.className && (l.className = a.className), a.innerHTML && a.dompurify && (l.innerHTML = a.dompurify.sanitize(a.innerHTML)), a.style) l.style[h] = a.style[h];
    return l;
  }, s = function o(a) {
    var l = Object.assign(o.convert(Promise.resolve()), JSON.parse(JSON.stringify(o.template))), h = o.convert(Promise.resolve(), l);
    return h = (h = h.setProgress(1, o, 1, [o])).set(a);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(o, a) {
    return o.__proto__ = a || s.prototype, o;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(o, a) {
    return this.then(function() {
      switch (a = a || function(l) {
        switch (i(l)) {
          case "string":
            return "string";
          case "element":
            return l.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(o)) {
        case "string":
          return this.then(e).then(function(l) {
            return this.set({ src: r("div", { innerHTML: o, dompurify: l }) });
          });
        case "element":
          return this.set({ src: o });
        case "canvas":
          return this.set({ canvas: o });
        case "img":
          return this.set({ img: o });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(o) {
    switch (o) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var o = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, a = function l(h, u) {
        for (var d = h.nodeType === 3 ? document.createTextNode(h.nodeValue) : h.cloneNode(!1), p = h.firstChild; p; p = p.nextSibling) u !== !0 && p.nodeType === 1 && p.nodeName === "SCRIPT" || d.appendChild(l(p, u));
        return h.nodeType === 1 && (h.nodeName === "CANVAS" ? (d.width = h.width, d.height = h.height, d.getContext("2d").drawImage(h, 0, 0)) : h.nodeName !== "TEXTAREA" && h.nodeName !== "SELECT" || (d.value = h.value), d.addEventListener("load", function() {
          d.scrollTop = h.scrollTop, d.scrollLeft = h.scrollLeft;
        }, !0)), d;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      a.tagName === "BODY" && (o.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = r("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = r("div", { className: "html2pdf__container", style: o }), this.prop.container.appendChild(a), this.prop.container.firstChild.appendChild(r("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = Object.assign({}, this.opt.html2canvas);
      return delete l.onrendered, a(this.prop.container, l);
    }).then(function(a) {
      (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = this.opt.jsPDF, h = this.opt.fontFaces, u = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, d = Object.assign({ async: !0, allowTaint: !0, scale: u, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete d.onrendered, l.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, l.context2d.posX = this.opt.x, l.context2d.posY = this.opt.y, l.context2d.margin = this.opt.margin, l.context2d.fontFaces = h, h) for (var p = 0; p < h.length; ++p) {
        var f = h[p], m = f.src.find(function(b) {
          return b.format === "truetype";
        });
        m && l.addFont(m.url, f.ref.name, f.ref.style);
      }
      return d.windowHeight = d.windowHeight || 0, d.windowHeight = d.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : d.windowHeight, l.context2d.save(!0), a(this.prop.container, d);
    }).then(function(a) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var o = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = o;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(o, a, l) {
    return (l = l || "pdf").toLowerCase() === "img" || l.toLowerCase() === "image" ? this.outputImg(o, a) : this.outputPdf(o, a);
  }, s.prototype.outputPdf = function(o, a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(o, a);
    });
  }, s.prototype.outputImg = function(o) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (o) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + o + '" is not supported.';
      }
    });
  }, s.prototype.save = function(o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(o ? { filename: o } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(o) {
    if (i(o) !== "object") return this;
    var a = Object.keys(o || {}).map(function(l) {
      if (l in s.template.prop) return function() {
        this.prop[l] = o[l];
      };
      switch (l) {
        case "margin":
          return this.setMargin.bind(this, o.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = o.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, o.pageSize);
        default:
          return function() {
            this.opt[l] = o[l];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(a);
    });
  }, s.prototype.get = function(o, a) {
    return this.then(function() {
      var l = o in s.template.prop ? this.prop[o] : this.opt[o];
      return a ? a(l) : l;
    });
  }, s.prototype.setMargin = function(o) {
    return this.then(function() {
      switch (i(o)) {
        case "number":
          o = [o, o, o, o];
        case "array":
          if (o.length === 2 && (o = [o[0], o[1], o[0], o[1]]), o.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = o;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(o) {
    function a(l, h) {
      return Math.floor(l * h / 72 * 96);
    }
    return this.then(function() {
      (o = o || ke.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (o.inner = { width: o.width - this.opt.margin[1] - this.opt.margin[3], height: o.height - this.opt.margin[0] - this.opt.margin[2] }, o.inner.px = { width: a(o.inner.width, o.k), height: a(o.inner.height, o.k) }, o.inner.ratio = o.inner.height / o.inner.width), this.prop.pageSize = o;
    });
  }, s.prototype.setProgress = function(o, a, l, h) {
    return o != null && (this.progress.val = o), a != null && (this.progress.state = a), l != null && (this.progress.n = l), h != null && (this.progress.stack = h), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(o, a, l, h) {
    return this.setProgress(o ? this.progress.val + o : null, a || null, l ? this.progress.n + l : null, h ? this.progress.stack.concat(h) : null);
  }, s.prototype.then = function(o, a) {
    var l = this;
    return this.thenCore(o, a, function(h, u) {
      return l.updateProgress(null, null, 1, [h]), Promise.prototype.then.call(this, function(d) {
        return l.updateProgress(null, h), d;
      }).then(h, u).then(function(d) {
        return l.updateProgress(1), d;
      });
    });
  }, s.prototype.thenCore = function(o, a, l) {
    l = l || Promise.prototype.then, o && (o = o.bind(this)), a && (a = a.bind(this));
    var h = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), u = l.call(h, o, a);
    return s.convert(u, this.__proto__);
  }, s.prototype.thenExternal = function(o, a) {
    return Promise.prototype.then.call(this, o, a);
  }, s.prototype.thenList = function(o) {
    var a = this;
    return o.forEach(function(l) {
      a = a.thenCore(l);
    }), a;
  }, s.prototype.catch = function(o) {
    o && (o = o.bind(this));
    var a = Promise.prototype.catch.call(this, o);
    return s.convert(a, this);
  }, s.prototype.catchExternal = function(o) {
    return Promise.prototype.catch.call(this, o);
  }, s.prototype.error = function(o) {
    return this.then(function() {
      throw new Error(o);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, ke.getPageSize = function(o, a, l) {
    if (nn(o) === "object") {
      var h = o;
      o = h.orientation, a = h.unit || a, l = h.format || l;
    }
    a = a || "mm", l = l || "a4", o = ("" + (o || "P")).toLowerCase();
    var u, d = ("" + l).toLowerCase(), p = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (a) {
      case "pt":
        u = 1;
        break;
      case "mm":
        u = 72 / 25.4;
        break;
      case "cm":
        u = 72 / 2.54;
        break;
      case "in":
        u = 72;
        break;
      case "px":
        u = 0.75;
        break;
      case "pc":
      case "em":
        u = 12;
        break;
      case "ex":
        u = 6;
        break;
      default:
        throw "Invalid unit: " + a;
    }
    var f, m = 0, b = 0;
    if (p.hasOwnProperty(d)) m = p[d][1] / u, b = p[d][0] / u;
    else try {
      m = l[1], b = l[0];
    } catch {
      throw new Error("Invalid format: " + l);
    }
    if (o === "p" || o === "portrait") o = "p", b > m && (f = b, b = m, m = f);
    else {
      if (o !== "l" && o !== "landscape") throw "Invalid orientation: " + o;
      o = "l", m > b && (f = b, b = m, m = f);
    }
    return { width: b, height: m, unit: a, k: u, orientation: o };
  }, n.html = function(o, a) {
    (a = a || {}).callback = a.callback || function() {
    }, a.html2canvas = a.html2canvas || {}, a.html2canvas.canvas = a.html2canvas.canvas || this.canvas, a.jsPDF = a.jsPDF || this, a.fontFaces = a.fontFaces ? a.fontFaces.map(yf) : null;
    var l = new s(a);
    return a.worker ? l : l.from(o).doCallback();
  };
}(ke.API), ke.API.addJS = function(n) {
  return ig = n, this.internal.events.subscribe("postPutResources", function() {
    Pu = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Pu + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), ng = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + ig + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Pu !== void 0 && ng !== void 0 && this.internal.out("/Names <</JavaScript " + Pu + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t;
  n.events.push(["postPutResources", function() {
    var e = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var r = e.outline.render().split(/\r\n/), s = 0; s < r.length; s++) {
      var o = r[s], a = i.exec(o);
      if (a != null) {
        var l = a[1];
        e.internal.newObjectDeferredBegin(l, !1);
      }
      e.internal.write(o);
    }
    if (this.outline.createNamedDestinations) {
      var h = this.internal.pages.length, u = [];
      for (s = 0; s < h; s++) {
        var d = e.internal.newObject();
        u.push(d);
        var p = e.internal.getPageInfo(s + 1);
        e.internal.write("<< /D[" + p.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f = e.internal.newObject();
      for (e.internal.write("<< /Names [ "), s = 0; s < u.length; s++) e.internal.write("(page_" + (s + 1) + ")" + u[s] + " 0 R");
      e.internal.write(" ] >>", "endobj"), t = e.internal.newObject(), e.internal.write("<< /Dests " + f + " 0 R"), e.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + t + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var e = this;
    e.outline = { createNamedDestinations: !1, root: { children: [] } }, e.outline.add = function(i, r, s) {
      var o = { title: r, options: s, children: [] };
      return i == null && (i = this.root), i.children.push(o), o;
    }, e.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = e, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, e.outline.genIds_r = function(i) {
      i.id = e.internal.newObjectDeferred();
      for (var r = 0; r < i.children.length; r++) this.genIds_r(i.children[r]);
    }, e.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, e.outline.renderItems = function(i) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < i.children.length; s++) {
        var o = i.children[s];
        this.objStart(o), this.line("/Title " + this.makeString(o.title)), this.line("/Parent " + this.makeRef(i)), s > 0 && this.line("/Prev " + this.makeRef(i.children[s - 1])), s < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[s + 1])), o.children.length > 0 && (this.line("/First " + this.makeRef(o.children[0])), this.line("/Last " + this.makeRef(o.children[o.children.length - 1])));
        var a = this.count = this.count_r({ count: 0 }, o);
        if (a > 0 && this.line("/Count " + a), o.options && o.options.pageNumber) {
          var l = e.internal.getPageInfo(o.options.pageNumber);
          this.line("/Dest [" + l.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var h = 0; h < i.children.length; h++) this.renderItems(i.children[h]);
    }, e.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, e.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, e.outline.makeString = function(i) {
      return "(" + e.internal.pdfEscape(i) + ")";
    }, e.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, e.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, e.outline.count_r = function(i, r) {
      for (var s = 0; s < r.children.length; s++) i.count++, this.count_r(i, r.children[s]);
      return i.count;
    };
  }]);
}(ke.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(e, i, r, s, o, a) {
    var l, h = this.decode.DCT_DECODE, u = null;
    if (typeof e == "string" || this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) {
      switch (e = o || e, e = this.__addimage__.isArrayBuffer(e) ? new Uint8Array(e) : e, (l = function(d) {
        for (var p, f = 256 * d.charCodeAt(4) + d.charCodeAt(5), m = d.length, b = { width: 0, height: 0, numcomponents: 1 }, x = 4; x < m; x += 2) {
          if (x += f, t.indexOf(d.charCodeAt(x + 1)) !== -1) {
            p = 256 * d.charCodeAt(x + 5) + d.charCodeAt(x + 6), b = { width: 256 * d.charCodeAt(x + 7) + d.charCodeAt(x + 8), height: p, numcomponents: d.charCodeAt(x + 9) };
            break;
          }
          f = 256 * d.charCodeAt(x + 2) + d.charCodeAt(x + 3);
        }
        return b;
      }(e = this.__addimage__.isArrayBufferView(e) ? this.__addimage__.arrayBufferToBinaryString(e) : e)).numcomponents) {
        case 1:
          a = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          a = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          a = this.color_spaces.DEVICE_RGB;
      }
      u = { data: e, width: l.width, height: l.height, colorSpace: a, bitsPerComponent: 8, filter: h, index: i, alias: r };
    }
    return u;
  };
}(ke.API);
var ea, Lu, rg, sg, og, Mv = function() {
  var n, t, e;
  function i(s) {
    var o, a, l, h, u, d, p, f, m, b, x, y, v, k;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, d = null; ; ) {
      switch (o = this.readUInt32(), m = (function() {
        var C, I;
        for (I = [], C = 0; C < 4; ++C) I.push(String.fromCharCode(this.data[this.pos++]));
        return I;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(o);
          break;
        case "fcTL":
          d && this.animation.frames.push(d), this.pos += 4, d = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, u = this.readUInt16(), h = this.readUInt16() || 100, d.delay = 1e3 * u / h, d.disposeOp = this.data[this.pos++], d.blendOp = this.data[this.pos++], d.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (m === "fdAT" && (this.pos += 4, o -= 4), s = (d != null ? d.data : void 0) || this.imgData, y = 0; 0 <= o ? y < o : y > o; 0 <= o ? ++y : --y) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (l = this.palette.length / 3, this.transparency.indexed = this.read(o), this.transparency.indexed.length > l) throw new Error("More transparent colors than palette size");
              if ((b = l - this.transparency.indexed.length) > 0) for (v = 0; 0 <= b ? v < b : v > b; 0 <= b ? ++v : --v) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(o)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(o);
          }
          break;
        case "tEXt":
          p = (x = this.read(o)).indexOf(0), f = String.fromCharCode.apply(String, x.slice(0, p)), this.text[f] = String.fromCharCode.apply(String, x.slice(p + 1));
          break;
        case "IEND":
          return d && this.animation.frames.push(d), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (k = this.colorType) === 4 || k === 6, a = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += o;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  i.prototype.read = function(s) {
    var o, a;
    for (a = [], o = 0; 0 <= s ? o < s : o > s; 0 <= s ? ++o : --o) a.push(this.data[this.pos++]);
    return a;
  }, i.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.decodePixels = function(s) {
    var o = this.pixelBitlength / 8, a = new Uint8Array(this.width * this.height * o), l = 0, h = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function u(d, p, f, m) {
      var b, x, y, v, k, C, I, q, O, F, M, j, P, A, T, _, Z, V, R, Q, H, ct = Math.ceil((h.width - d) / f), nt = Math.ceil((h.height - p) / m), N = h.width == ct && h.height == nt;
      for (A = o * ct, j = N ? a : new Uint8Array(A * nt), C = s.length, P = 0, x = 0; P < nt && l < C; ) {
        switch (s[l++]) {
          case 0:
            for (v = Z = 0; Z < A; v = Z += 1) j[x++] = s[l++];
            break;
          case 1:
            for (v = V = 0; V < A; v = V += 1) b = s[l++], k = v < o ? 0 : j[x - o], j[x++] = (b + k) % 256;
            break;
          case 2:
            for (v = R = 0; R < A; v = R += 1) b = s[l++], y = (v - v % o) / o, T = P && j[(P - 1) * A + y * o + v % o], j[x++] = (T + b) % 256;
            break;
          case 3:
            for (v = Q = 0; Q < A; v = Q += 1) b = s[l++], y = (v - v % o) / o, k = v < o ? 0 : j[x - o], T = P && j[(P - 1) * A + y * o + v % o], j[x++] = (b + Math.floor((k + T) / 2)) % 256;
            break;
          case 4:
            for (v = H = 0; H < A; v = H += 1) b = s[l++], y = (v - v % o) / o, k = v < o ? 0 : j[x - o], P === 0 ? T = _ = 0 : (T = j[(P - 1) * A + y * o + v % o], _ = y && j[(P - 1) * A + (y - 1) * o + v % o]), I = k + T - _, q = Math.abs(I - k), F = Math.abs(I - T), M = Math.abs(I - _), O = q <= F && q <= M ? k : F <= M ? T : _, j[x++] = (b + O) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[l - 1]);
        }
        if (!N) {
          var z = ((p + P * m) * h.width + d) * o, G = P * A;
          for (v = 0; v < ct; v += 1) {
            for (var Y = 0; Y < o; Y += 1) a[z++] = j[G++];
            z += (f - 1) * o;
          }
        }
        P++;
      }
    }
    return s = fv(s), h.interlaceMethod == 1 ? (u(0, 0, 8, 8), u(4, 0, 8, 8), u(0, 4, 4, 8), u(2, 0, 4, 4), u(0, 2, 2, 4), u(1, 0, 2, 2), u(0, 1, 1, 2)) : u(0, 0, 1, 1), a;
  }, i.prototype.decodePalette = function() {
    var s, o, a, l, h, u, d, p, f;
    for (a = this.palette, u = this.transparency.indexed || [], h = new Uint8Array((u.length || 0) + a.length), l = 0, s = 0, o = d = 0, p = a.length; d < p; o = d += 3) h[l++] = a[o], h[l++] = a[o + 1], h[l++] = a[o + 2], h[l++] = (f = u[s++]) != null ? f : 255;
    return h;
  }, i.prototype.copyToImageData = function(s, o) {
    var a, l, h, u, d, p, f, m, b, x, y;
    if (l = this.colors, b = null, a = this.hasAlphaChannel, this.palette.length && (b = (y = this._decodedPalette) != null ? y : this._decodedPalette = this.decodePalette(), l = 4, a = !0), m = (h = s.data || s).length, d = b || o, u = p = 0, l === 1) for (; u < m; ) f = b ? 4 * o[u / 4] : p, x = d[f++], h[u++] = x, h[u++] = x, h[u++] = x, h[u++] = a ? d[f++] : 255, p = f;
    else for (; u < m; ) f = b ? 4 * o[u / 4] : p, h[u++] = d[f++], h[u++] = d[f++], h[u++] = d[f++], h[u++] = a ? d[f++] : 255, p = f;
  }, i.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var r = function() {
    if (Object.prototype.toString.call(Le) === "[object Window]") {
      try {
        t = Le.document.createElement("canvas"), e = t.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return r(), n = function(s) {
    var o;
    if (r() === !0) return e.width = s.width, e.height = s.height, e.clearRect(0, 0, s.width, s.height), e.putImageData(s, 0, 0), (o = new Image()).src = t.toDataURL(), o;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, i.prototype.decodeFrames = function(s) {
    var o, a, l, h, u, d, p, f;
    if (this.animation) {
      for (f = [], a = u = 0, d = (p = this.animation.frames).length; u < d; a = ++u) o = p[a], l = s.createImageData(o.width, o.height), h = this.decodePixels(new Uint8Array(o.data)), this.copyToImageData(l, h), o.imageData = l, f.push(o.image = n(l));
      return f;
    }
  }, i.prototype.renderFrame = function(s, o) {
    var a, l, h;
    return a = (l = this.animation.frames)[o], h = l[o - 1], o === 0 && s.clearRect(0, 0, this.width, this.height), (h != null ? h.disposeOp : void 0) === 1 ? s.clearRect(h.xOffset, h.yOffset, h.width, h.height) : (h != null ? h.disposeOp : void 0) === 2 && s.putImageData(h.imageData, h.xOffset, h.yOffset), a.blendOp === 0 && s.clearRect(a.xOffset, a.yOffset, a.width, a.height), s.drawImage(a.image, a.xOffset, a.yOffset);
  }, i.prototype.animate = function(s) {
    var o, a, l, h, u, d, p = this;
    return a = 0, d = this.animation, h = d.numFrames, l = d.frames, u = d.numPlays, (o = function() {
      var f, m;
      if (f = a++ % h, m = l[f], p.renderFrame(s, f), h > 1 && a / h < u) return p.animation._timeout = setTimeout(o, m.delay);
    })();
  }, i.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, i.prototype.render = function(s) {
    var o, a;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, o = s.getContext("2d"), this.animation ? (this.decodeFrames(o), this.animate(o)) : (a = o.createImageData(this.width, this.height), this.copyToImageData(a, this.decodePixels()), o.putImageData(a, 0, 0));
  }, i;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Rv(n) {
  var t = 0;
  if (n[t++] !== 71 || n[t++] !== 73 || n[t++] !== 70 || n[t++] !== 56 || (n[t++] + 1 & 253) != 56 || n[t++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var e = n[t++] | n[t++] << 8, i = n[t++] | n[t++] << 8, r = n[t++], s = r >> 7, o = 1 << (7 & r) + 1;
  n[t++], n[t++];
  var a = null, l = null;
  s && (a = t, l = o, t += 3 * o);
  var h = !0, u = [], d = 0, p = null, f = 0, m = null;
  for (this.width = e, this.height = i; h && t < n.length; ) switch (n[t++]) {
    case 33:
      switch (n[t++]) {
        case 255:
          if (n[t] !== 11 || n[t + 1] == 78 && n[t + 2] == 69 && n[t + 3] == 84 && n[t + 4] == 83 && n[t + 5] == 67 && n[t + 6] == 65 && n[t + 7] == 80 && n[t + 8] == 69 && n[t + 9] == 50 && n[t + 10] == 46 && n[t + 11] == 48 && n[t + 12] == 3 && n[t + 13] == 1 && n[t + 16] == 0) t += 14, m = n[t++] | n[t++] << 8, t++;
          else for (t += 12; ; ) {
            if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
            if (P === 0) break;
            t += P;
          }
          break;
        case 249:
          if (n[t++] !== 4 || n[t + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var b = n[t++];
          d = n[t++] | n[t++] << 8, p = n[t++], !(1 & b) && (p = null), f = b >> 2 & 7, t++;
          break;
        case 254:
          for (; ; ) {
            if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
            if (P === 0) break;
            t += P;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + n[t - 1].toString(16));
      }
      break;
    case 44:
      var x = n[t++] | n[t++] << 8, y = n[t++] | n[t++] << 8, v = n[t++] | n[t++] << 8, k = n[t++] | n[t++] << 8, C = n[t++], I = C >> 6 & 1, q = 1 << (7 & C) + 1, O = a, F = l, M = !1;
      C >> 7 && (M = !0, O = t, F = q, t += 3 * q);
      var j = t;
      for (t++; ; ) {
        var P;
        if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
        if (P === 0) break;
        t += P;
      }
      u.push({ x, y, width: v, height: k, has_local_palette: M, palette_offset: O, palette_size: F, data_offset: j, data_length: t - j, transparent_index: p, interlaced: !!I, delay: d, disposal: f });
      break;
    case 59:
      h = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + n[t - 1].toString(16));
  }
  this.numFrames = function() {
    return u.length;
  }, this.loopCount = function() {
    return m;
  }, this.frameInfo = function(A) {
    if (A < 0 || A >= u.length) throw new Error("Frame index out of range.");
    return u[A];
  }, this.decodeAndBlitFrameBGRA = function(A, T) {
    var _ = this.frameInfo(A), Z = _.width * _.height, V = new Uint8Array(Z);
    ag(n, _.data_offset, V, Z);
    var R = _.palette_offset, Q = _.transparent_index;
    Q === null && (Q = 256);
    var H = _.width, ct = e - H, nt = H, N = 4 * (_.y * e + _.x), z = 4 * ((_.y + _.height) * e + _.x), G = N, Y = 4 * ct;
    _.interlaced === !0 && (Y += 4 * e * 7);
    for (var st = 8, vt = 0, mt = V.length; vt < mt; ++vt) {
      var _t = V[vt];
      if (nt === 0 && (nt = H, (G += Y) >= z && (Y = 4 * ct + 4 * e * (st - 1), G = N + (H + ct) * (st << 1), st >>= 1)), _t === Q) G += 4;
      else {
        var Bt = n[R + 3 * _t], Rt = n[R + 3 * _t + 1], te = n[R + 3 * _t + 2];
        T[G++] = te, T[G++] = Rt, T[G++] = Bt, T[G++] = 255;
      }
      --nt;
    }
  }, this.decodeAndBlitFrameRGBA = function(A, T) {
    var _ = this.frameInfo(A), Z = _.width * _.height, V = new Uint8Array(Z);
    ag(n, _.data_offset, V, Z);
    var R = _.palette_offset, Q = _.transparent_index;
    Q === null && (Q = 256);
    var H = _.width, ct = e - H, nt = H, N = 4 * (_.y * e + _.x), z = 4 * ((_.y + _.height) * e + _.x), G = N, Y = 4 * ct;
    _.interlaced === !0 && (Y += 4 * e * 7);
    for (var st = 8, vt = 0, mt = V.length; vt < mt; ++vt) {
      var _t = V[vt];
      if (nt === 0 && (nt = H, (G += Y) >= z && (Y = 4 * ct + 4 * e * (st - 1), G = N + (H + ct) * (st << 1), st >>= 1)), _t === Q) G += 4;
      else {
        var Bt = n[R + 3 * _t], Rt = n[R + 3 * _t + 1], te = n[R + 3 * _t + 2];
        T[G++] = Bt, T[G++] = Rt, T[G++] = te, T[G++] = 255;
      }
      --nt;
    }
  };
}
function ag(n, t, e, i) {
  for (var r = n[t++], s = 1 << r, o = s + 1, a = o + 1, l = r + 1, h = (1 << l) - 1, u = 0, d = 0, p = 0, f = n[t++], m = new Int32Array(4096), b = null; ; ) {
    for (; u < 16 && f !== 0; ) d |= n[t++] << u, u += 8, f === 1 ? f = n[t++] : --f;
    if (u < l) break;
    var x = d & h;
    if (d >>= l, u -= l, x !== s) {
      if (x === o) break;
      for (var y = x < a ? x : b, v = 0, k = y; k > s; ) k = m[k] >> 8, ++v;
      var C = k;
      if (p + v + (y !== x ? 1 : 0) > i) return void ln.log("Warning, gif stream longer than expected.");
      e[p++] = C;
      var I = p += v;
      for (y !== x && (e[p++] = C), k = y; v--; ) k = m[k], e[--I] = 255 & k, k >>= 8;
      b !== null && a < 4096 && (m[a++] = b << 8 | C, a >= h + 1 && l < 12 && (++l, h = h << 1 | 1)), b = x;
    } else a = o + 1, h = (1 << (l = r + 1)) - 1, b = null;
  }
  return p !== i && ln.log("Warning, gif stream shorter than expected."), e;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ih(n) {
  var t, e, i, r, s, o = Math.floor, a = new Array(64), l = new Array(64), h = new Array(64), u = new Array(64), d = new Array(65535), p = new Array(65535), f = new Array(64), m = new Array(64), b = [], x = 0, y = 7, v = new Array(64), k = new Array(64), C = new Array(64), I = new Array(256), q = new Array(2048), O = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], F = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], j = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], A = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], T = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _ = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Z = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function V(N, z) {
    for (var G = 0, Y = 0, st = new Array(), vt = 1; vt <= 16; vt++) {
      for (var mt = 1; mt <= N[vt]; mt++) st[z[Y]] = [], st[z[Y]][0] = G, st[z[Y]][1] = vt, Y++, G++;
      G *= 2;
    }
    return st;
  }
  function R(N) {
    for (var z = N[0], G = N[1] - 1; G >= 0; ) z & 1 << G && (x |= 1 << y), G--, --y < 0 && (x == 255 ? (Q(255), Q(0)) : Q(x), y = 7, x = 0);
  }
  function Q(N) {
    b.push(N);
  }
  function H(N) {
    Q(N >> 8 & 255), Q(255 & N);
  }
  function ct(N, z, G, Y, st) {
    for (var vt, mt = st[0], _t = st[240], Bt = function(rt, wt) {
      var kt, dt, Pt, qt, Ft, Vt, ne, ie, ue, we, Qt = 0;
      for (ue = 0; ue < 8; ++ue) {
        kt = rt[Qt], dt = rt[Qt + 1], Pt = rt[Qt + 2], qt = rt[Qt + 3], Ft = rt[Qt + 4], Vt = rt[Qt + 5], ne = rt[Qt + 6];
        var Ke = kt + (ie = rt[Qt + 7]), ht = kt - ie, jt = dt + ne, Kt = dt - ne, Ht = Pt + Vt, Ae = Pt - Vt, Jt = qt + Ft, Yt = qt - Ft, le = Ke + Jt, Xe = Ke - Jt, xn = jt + Ht, Ge = jt - Ht;
        rt[Qt] = le + xn, rt[Qt + 4] = le - xn;
        var Ne = 0.707106781 * (Ge + Xe);
        rt[Qt + 2] = Xe + Ne, rt[Qt + 6] = Xe - Ne;
        var Be = 0.382683433 * ((le = Yt + Ae) - (Ge = Kt + ht)), Di = 0.5411961 * le + Be, pn = 1.306562965 * Ge + Be, Ni = 0.707106781 * (xn = Ae + Kt), Bi = ht + Ni, me = ht - Ni;
        rt[Qt + 5] = me + Di, rt[Qt + 3] = me - Di, rt[Qt + 1] = Bi + pn, rt[Qt + 7] = Bi - pn, Qt += 8;
      }
      for (Qt = 0, ue = 0; ue < 8; ++ue) {
        kt = rt[Qt], dt = rt[Qt + 8], Pt = rt[Qt + 16], qt = rt[Qt + 24], Ft = rt[Qt + 32], Vt = rt[Qt + 40], ne = rt[Qt + 48];
        var gi = kt + (ie = rt[Qt + 56]), ji = kt - ie, Qn = dt + ne, An = dt - ne, yn = Pt + Vt, ui = Pt - Vt, ss = qt + Ft, Qi = qt - Ft, Ci = gi + ss, mi = gi - ss, Pi = Qn + yn, qi = Qn - yn;
        rt[Qt] = Ci + Pi, rt[Qt + 32] = Ci - Pi;
        var yi = 0.707106781 * (qi + mi);
        rt[Qt + 16] = mi + yi, rt[Qt + 48] = mi - yi;
        var tr = 0.382683433 * ((Ci = Qi + ui) - (qi = An + ji)), Dr = 0.5411961 * Ci + tr, Br = 1.306562965 * qi + tr, jr = 0.707106781 * (Pi = ui + An), er = ji + jr, qr = ji - jr;
        rt[Qt + 40] = qr + Dr, rt[Qt + 24] = qr - Dr, rt[Qt + 8] = er + Br, rt[Qt + 56] = er - Br, Qt++;
      }
      for (ue = 0; ue < 64; ++ue) we = rt[ue] * wt[ue], f[ue] = we > 0 ? we + 0.5 | 0 : we - 0.5 | 0;
      return f;
    }(N, z), Rt = 0; Rt < 64; ++Rt) m[O[Rt]] = Bt[Rt];
    var te = m[0] - G;
    G = m[0], te == 0 ? R(Y[0]) : (R(Y[p[vt = 32767 + te]]), R(d[vt]));
    for (var Xt = 63; Xt > 0 && m[Xt] == 0; ) Xt--;
    if (Xt == 0) return R(mt), G;
    for (var E, ft = 1; ft <= Xt; ) {
      for (var U = ft; m[ft] == 0 && ft <= Xt; ) ++ft;
      var et = ft - U;
      if (et >= 16) {
        E = et >> 4;
        for (var X = 1; X <= E; ++X) R(_t);
        et &= 15;
      }
      vt = 32767 + m[ft], R(st[(et << 4) + p[vt]]), R(d[vt]), ft++;
    }
    return Xt != 63 && R(mt), G;
  }
  function nt(N) {
    N = Math.min(Math.max(N, 1), 100), s != N && (function(z) {
      for (var G = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Y = 0; Y < 64; Y++) {
        var st = o((G[Y] * z + 50) / 100);
        st = Math.min(Math.max(st, 1), 255), a[O[Y]] = st;
      }
      for (var vt = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], mt = 0; mt < 64; mt++) {
        var _t = o((vt[mt] * z + 50) / 100);
        _t = Math.min(Math.max(_t, 1), 255), l[O[mt]] = _t;
      }
      for (var Bt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Rt = 0, te = 0; te < 8; te++) for (var Xt = 0; Xt < 8; Xt++) h[Rt] = 1 / (a[O[Rt]] * Bt[te] * Bt[Xt] * 8), u[Rt] = 1 / (l[O[Rt]] * Bt[te] * Bt[Xt] * 8), Rt++;
    }(N < 50 ? Math.floor(5e3 / N) : Math.floor(200 - 2 * N)), s = N);
  }
  this.encode = function(N, z) {
    z && nt(z), b = new Array(), x = 0, y = 7, H(65496), H(65504), H(16), Q(74), Q(70), Q(73), Q(70), Q(0), Q(1), Q(1), Q(0), H(1), H(1), Q(0), Q(0), function() {
      H(65499), H(132), Q(0);
      for (var dt = 0; dt < 64; dt++) Q(a[dt]);
      Q(1);
      for (var Pt = 0; Pt < 64; Pt++) Q(l[Pt]);
    }(), function(dt, Pt) {
      H(65472), H(17), Q(8), H(Pt), H(dt), Q(3), Q(1), Q(17), Q(0), Q(2), Q(17), Q(1), Q(3), Q(17), Q(1);
    }(N.width, N.height), function() {
      H(65476), H(418), Q(0);
      for (var dt = 0; dt < 16; dt++) Q(F[dt + 1]);
      for (var Pt = 0; Pt <= 11; Pt++) Q(M[Pt]);
      Q(16);
      for (var qt = 0; qt < 16; qt++) Q(j[qt + 1]);
      for (var Ft = 0; Ft <= 161; Ft++) Q(P[Ft]);
      Q(1);
      for (var Vt = 0; Vt < 16; Vt++) Q(A[Vt + 1]);
      for (var ne = 0; ne <= 11; ne++) Q(T[ne]);
      Q(17);
      for (var ie = 0; ie < 16; ie++) Q(_[ie + 1]);
      for (var ue = 0; ue <= 161; ue++) Q(Z[ue]);
    }(), H(65498), H(12), Q(3), Q(1), Q(0), Q(2), Q(17), Q(3), Q(17), Q(0), Q(63), Q(0);
    var G = 0, Y = 0, st = 0;
    x = 0, y = 7, this.encode.displayName = "_encode_";
    for (var vt, mt, _t, Bt, Rt, te, Xt, E, ft, U = N.data, et = N.width, X = N.height, rt = 4 * et, wt = 0; wt < X; ) {
      for (vt = 0; vt < rt; ) {
        for (Rt = rt * wt + vt, Xt = -1, E = 0, ft = 0; ft < 64; ft++) te = Rt + (E = ft >> 3) * rt + (Xt = 4 * (7 & ft)), wt + E >= X && (te -= rt * (wt + 1 + E - X)), vt + Xt >= rt && (te -= vt + Xt - rt + 4), mt = U[te++], _t = U[te++], Bt = U[te++], v[ft] = (q[mt] + q[_t + 256 >> 0] + q[Bt + 512 >> 0] >> 16) - 128, k[ft] = (q[mt + 768 >> 0] + q[_t + 1024 >> 0] + q[Bt + 1280 >> 0] >> 16) - 128, C[ft] = (q[mt + 1280 >> 0] + q[_t + 1536 >> 0] + q[Bt + 1792 >> 0] >> 16) - 128;
        G = ct(v, h, G, t, i), Y = ct(k, u, Y, e, r), st = ct(C, u, st, e, r), vt += 32;
      }
      wt += 8;
    }
    if (y >= 0) {
      var kt = [];
      kt[1] = y + 1, kt[0] = (1 << y + 1) - 1, R(kt);
    }
    return H(65497), new Uint8Array(b);
  }, n = n || 50, function() {
    for (var N = String.fromCharCode, z = 0; z < 256; z++) I[z] = N(z);
  }(), t = V(F, M), e = V(A, T), i = V(j, P), r = V(_, Z), function() {
    for (var N = 1, z = 2, G = 1; G <= 15; G++) {
      for (var Y = N; Y < z; Y++) p[32767 + Y] = G, d[32767 + Y] = [], d[32767 + Y][1] = G, d[32767 + Y][0] = Y;
      for (var st = -(z - 1); st <= -N; st++) p[32767 + st] = G, d[32767 + st] = [], d[32767 + st][1] = G, d[32767 + st][0] = z - 1 + st;
      N <<= 1, z <<= 1;
    }
  }(), function() {
    for (var N = 0; N < 256; N++) q[N] = 19595 * N, q[N + 256 >> 0] = 38470 * N, q[N + 512 >> 0] = 7471 * N + 32768, q[N + 768 >> 0] = -11059 * N, q[N + 1024 >> 0] = -21709 * N, q[N + 1280 >> 0] = 32768 * N + 8421375, q[N + 1536 >> 0] = -27439 * N, q[N + 1792 >> 0] = -5329 * N;
  }(), nt(n);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function ar(n, t) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!t, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function lg(n) {
  function t(F) {
    if (!F) throw Error("assert :P");
  }
  function e(F, M, j) {
    for (var P = 0; 4 > P; P++) if (F[M + P] != j.charCodeAt(P)) return !0;
    return !1;
  }
  function i(F, M, j, P, A) {
    for (var T = 0; T < A; T++) F[M + T] = j[P + T];
  }
  function r(F, M, j, P) {
    for (var A = 0; A < P; A++) F[M + A] = j;
  }
  function s(F) {
    return new Int32Array(F);
  }
  function o(F, M) {
    for (var j = [], P = 0; P < F; P++) j.push(new M());
    return j;
  }
  function a(F, M) {
    var j = [];
    return function P(A, T, _) {
      for (var Z = _[T], V = 0; V < Z && (A.push(_.length > T + 1 ? [] : new M()), !(_.length < T + 1)); V++) P(A[V], T + 1, _);
    }(j, 0, F), j;
  }
  var l = function() {
    var F = this;
    function M(c, g) {
      for (var S = 1 << g - 1 >>> 0; c & S; ) S >>>= 1;
      return S ? (c & S - 1) + S : c;
    }
    function j(c, g, S, L, D) {
      t(!(L % S));
      do
        c[g + (L -= S)] = D;
      while (0 < L);
    }
    function P(c, g, S, L, D) {
      if (t(2328 >= D), 512 >= D) var $ = s(512);
      else if (($ = s(D)) == null) return 0;
      return function(W, K, J, it, yt, Lt) {
        var It, Nt, Wt = K, Tt = 1 << J, bt = s(16), St = s(16);
        for (t(yt != 0), t(it != null), t(W != null), t(0 < J), Nt = 0; Nt < yt; ++Nt) {
          if (15 < it[Nt]) return 0;
          ++bt[it[Nt]];
        }
        if (bt[0] == yt) return 0;
        for (St[1] = 0, It = 1; 15 > It; ++It) {
          if (bt[It] > 1 << It) return 0;
          St[It + 1] = St[It] + bt[It];
        }
        for (Nt = 0; Nt < yt; ++Nt) It = it[Nt], 0 < it[Nt] && (Lt[St[It]++] = Nt);
        if (St[15] == 1) return (it = new A()).g = 0, it.value = Lt[0], j(W, Wt, 1, Tt, it), Tt;
        var $t, Gt = -1, Ut = Tt - 1, fe = 0, se = 1, Se = 1, oe = 1 << J;
        for (Nt = 0, It = 1, yt = 2; It <= J; ++It, yt <<= 1) {
          if (se += Se <<= 1, 0 > (Se -= bt[It])) return 0;
          for (; 0 < bt[It]; --bt[It]) (it = new A()).g = It, it.value = Lt[Nt++], j(W, Wt + fe, yt, oe, it), fe = M(fe, It);
        }
        for (It = J + 1, yt = 2; 15 >= It; ++It, yt <<= 1) {
          if (se += Se <<= 1, 0 > (Se -= bt[It])) return 0;
          for (; 0 < bt[It]; --bt[It]) {
            if (it = new A(), (fe & Ut) != Gt) {
              for (Wt += oe, $t = 1 << (Gt = It) - J; 15 > Gt && !(0 >= ($t -= bt[Gt])); ) ++Gt, $t <<= 1;
              Tt += oe = 1 << ($t = Gt - J), W[K + (Gt = fe & Ut)].g = $t + J, W[K + Gt].value = Wt - K - Gt;
            }
            it.g = It - J, it.value = Lt[Nt++], j(W, Wt + (fe >> J), yt, oe, it), fe = M(fe, It);
          }
        }
        return se != 2 * St[15] - 1 ? 0 : Tt;
      }(c, g, S, L, D, $);
    }
    function A() {
      this.value = this.g = 0;
    }
    function T() {
      this.value = this.g = 0;
    }
    function _() {
      this.G = o(5, A), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o(Vn, T);
    }
    function Z(c, g, S, L) {
      t(c != null), t(g != null), t(2147483648 > L), c.Ca = 254, c.I = 0, c.b = -8, c.Ka = 0, c.oa = g, c.pa = S, c.Jd = g, c.Yc = S + L, c.Zc = 4 <= L ? S + L - 4 + 1 : S, vt(c);
    }
    function V(c, g) {
      for (var S = 0; 0 < g--; ) S |= _t(c, 128) << g;
      return S;
    }
    function R(c, g) {
      var S = V(c, g);
      return mt(c) ? -S : S;
    }
    function Q(c, g, S, L) {
      var D, $ = 0;
      for (t(c != null), t(g != null), t(4294967288 > L), c.Sb = L, c.Ra = 0, c.u = 0, c.h = 0, 4 < L && (L = 4), D = 0; D < L; ++D) $ += g[S + D] << 8 * D;
      c.Ra = $, c.bb = L, c.oa = g, c.pa = S;
    }
    function H(c) {
      for (; 8 <= c.u && c.bb < c.Sb; ) c.Ra >>>= 8, c.Ra += c.oa[c.pa + c.bb] << Wo - 8 >>> 0, ++c.bb, c.u -= 8;
      G(c) && (c.h = 1, c.u = 0);
    }
    function ct(c, g) {
      if (t(0 <= g), !c.h && g <= Uo) {
        var S = z(c) & $o[g];
        return c.u += g, H(c), S;
      }
      return c.h = 1, c.u = 0;
    }
    function nt() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function z(c) {
      return c.Ra >>> (c.u & Wo - 1) >>> 0;
    }
    function G(c) {
      return t(c.bb <= c.Sb), c.h || c.bb == c.Sb && c.u > Wo;
    }
    function Y(c, g) {
      c.u = g, c.h = G(c);
    }
    function st(c) {
      c.u >= Xa && (t(c.u >= Xa), H(c));
    }
    function vt(c) {
      t(c != null && c.oa != null), c.pa < c.Zc ? (c.I = (c.oa[c.pa++] | c.I << 8) >>> 0, c.b += 8) : (t(c != null && c.oa != null), c.pa < c.Yc ? (c.b += 8, c.I = c.oa[c.pa++] | c.I << 8) : c.Ka ? c.b = 0 : (c.I <<= 8, c.b += 8, c.Ka = 1));
    }
    function mt(c) {
      return V(c, 1);
    }
    function _t(c, g) {
      var S = c.Ca;
      0 > c.b && vt(c);
      var L = c.b, D = S * g >>> 8, $ = (c.I >>> L > D) + 0;
      for ($ ? (S -= D, c.I -= D + 1 << L >>> 0) : S = D + 1, L = S, D = 0; 256 <= L; ) D += 8, L >>= 8;
      return L = 7 ^ D + bi[L], c.b -= L, c.Ca = (S << L) - 1, $;
    }
    function Bt(c, g, S) {
      c[g + 0] = S >> 24 & 255, c[g + 1] = S >> 16 & 255, c[g + 2] = S >> 8 & 255, c[g + 3] = S >> 0 & 255;
    }
    function Rt(c, g) {
      return c[g + 0] << 0 | c[g + 1] << 8;
    }
    function te(c, g) {
      return Rt(c, g) | c[g + 2] << 16;
    }
    function Xt(c, g) {
      return Rt(c, g) | Rt(c, g + 2) << 16;
    }
    function E(c, g) {
      var S = 1 << g;
      return t(c != null), t(0 < g), c.X = s(S), c.X == null ? 0 : (c.Mb = 32 - g, c.Xa = g, 1);
    }
    function ft(c, g) {
      t(c != null), t(g != null), t(c.Xa == g.Xa), i(g.X, 0, c.X, 0, 1 << g.Xa);
    }
    function U() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function et(c, g, S, L) {
      t(S != null), t(L != null);
      var D = S[0], $ = L[0];
      return D == 0 && (D = (c * $ + g / 2) / g), $ == 0 && ($ = (g * D + c / 2) / c), 0 >= D || 0 >= $ ? 0 : (S[0] = D, L[0] = $, 1);
    }
    function X(c, g) {
      return c + (1 << g) - 1 >>> g;
    }
    function rt(c, g) {
      return ((4278255360 & c) + (4278255360 & g) >>> 0 & 4278255360) + ((16711935 & c) + (16711935 & g) >>> 0 & 16711935) >>> 0;
    }
    function wt(c, g) {
      F[g] = function(S, L, D, $, W, K, J) {
        var it;
        for (it = 0; it < W; ++it) {
          var yt = F[c](K[J + it - 1], D, $ + it);
          K[J + it] = rt(S[L + it], yt);
        }
      };
    }
    function kt() {
      this.ud = this.hd = this.jd = 0;
    }
    function dt(c, g) {
      return ((4278124286 & (c ^ g)) >>> 1) + (c & g) >>> 0;
    }
    function Pt(c) {
      return 0 <= c && 256 > c ? c : 0 > c ? 0 : 255 < c ? 255 : void 0;
    }
    function qt(c, g) {
      return Pt(c + (c - g + 0.5 >> 1));
    }
    function Ft(c, g, S) {
      return Math.abs(g - S) - Math.abs(c - S);
    }
    function Vt(c, g, S, L, D, $, W) {
      for (L = $[W - 1], S = 0; S < D; ++S) $[W + S] = L = rt(c[g + S], L);
    }
    function ne(c, g, S, L, D) {
      var $;
      for ($ = 0; $ < S; ++$) {
        var W = c[g + $], K = W >> 8 & 255, J = 16711935 & (J = (J = 16711935 & W) + ((K << 16) + K));
        L[D + $] = (4278255360 & W) + J >>> 0;
      }
    }
    function ie(c, g) {
      g.jd = c >> 0 & 255, g.hd = c >> 8 & 255, g.ud = c >> 16 & 255;
    }
    function ue(c, g, S, L, D, $) {
      var W;
      for (W = 0; W < L; ++W) {
        var K = g[S + W], J = K >>> 8, it = K, yt = 255 & (yt = (yt = K >>> 16) + ((c.jd << 24 >> 24) * (J << 24 >> 24) >>> 5));
        it = 255 & (it = (it = it + ((c.hd << 24 >> 24) * (J << 24 >> 24) >>> 5)) + ((c.ud << 24 >> 24) * (yt << 24 >> 24) >>> 5)), D[$ + W] = (4278255360 & K) + (yt << 16) + it;
      }
    }
    function we(c, g, S, L, D) {
      F[g] = function($, W, K, J, it, yt, Lt, It, Nt) {
        for (J = Lt; J < It; ++J) for (Lt = 0; Lt < Nt; ++Lt) it[yt++] = D(K[L($[W++])]);
      }, F[c] = function($, W, K, J, it, yt, Lt) {
        var It = 8 >> $.b, Nt = $.Ea, Wt = $.K[0], Tt = $.w;
        if (8 > It) for ($ = (1 << $.b) - 1, Tt = (1 << It) - 1; W < K; ++W) {
          var bt, St = 0;
          for (bt = 0; bt < Nt; ++bt) bt & $ || (St = L(J[it++])), yt[Lt++] = D(Wt[St & Tt]), St >>= It;
        }
        else F["VP8LMapColor" + S](J, it, Wt, Tt, yt, Lt, W, K, Nt);
      };
    }
    function Qt(c, g, S, L, D) {
      for (S = g + S; g < S; ) {
        var $ = c[g++];
        L[D++] = $ >> 16 & 255, L[D++] = $ >> 8 & 255, L[D++] = $ >> 0 & 255;
      }
    }
    function Ke(c, g, S, L, D) {
      for (S = g + S; g < S; ) {
        var $ = c[g++];
        L[D++] = $ >> 16 & 255, L[D++] = $ >> 8 & 255, L[D++] = $ >> 0 & 255, L[D++] = $ >> 24 & 255;
      }
    }
    function ht(c, g, S, L, D) {
      for (S = g + S; g < S; ) {
        var $ = (W = c[g++]) >> 16 & 240 | W >> 12 & 15, W = W >> 0 & 240 | W >> 28 & 15;
        L[D++] = $, L[D++] = W;
      }
    }
    function jt(c, g, S, L, D) {
      for (S = g + S; g < S; ) {
        var $ = (W = c[g++]) >> 16 & 248 | W >> 13 & 7, W = W >> 5 & 224 | W >> 3 & 31;
        L[D++] = $, L[D++] = W;
      }
    }
    function Kt(c, g, S, L, D) {
      for (S = g + S; g < S; ) {
        var $ = c[g++];
        L[D++] = $ >> 0 & 255, L[D++] = $ >> 8 & 255, L[D++] = $ >> 16 & 255;
      }
    }
    function Ht(c, g, S, L, D, $) {
      if ($ == 0) for (S = g + S; g < S; ) Bt(L, (($ = c[g++])[0] >> 24 | $[1] >> 8 & 65280 | $[2] << 8 & 16711680 | $[3] << 24) >>> 0), D += 32;
      else i(L, D, c, g, S);
    }
    function Ae(c, g) {
      F[g][0] = F[c + "0"], F[g][1] = F[c + "1"], F[g][2] = F[c + "2"], F[g][3] = F[c + "3"], F[g][4] = F[c + "4"], F[g][5] = F[c + "5"], F[g][6] = F[c + "6"], F[g][7] = F[c + "7"], F[g][8] = F[c + "8"], F[g][9] = F[c + "9"], F[g][10] = F[c + "10"], F[g][11] = F[c + "11"], F[g][12] = F[c + "12"], F[g][13] = F[c + "13"], F[g][14] = F[c + "0"], F[g][15] = F[c + "0"];
    }
    function Jt(c) {
      return c == eh || c == nh || c == au || c == ih;
    }
    function Yt() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function le() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Xe() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Yt(), this.f.kb = new le(), this.sd = null;
    }
    function xn() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Ge() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function Ne(c) {
      return alert("todo:WebPSamplerProcessPlane"), c.T;
    }
    function Be(c, g) {
      var S = c.T, L = g.ba.f.RGBA, D = L.eb, $ = L.fb + c.ka * L.A, W = Vi[g.ba.S], K = c.y, J = c.O, it = c.f, yt = c.N, Lt = c.ea, It = c.W, Nt = g.cc, Wt = g.dc, Tt = g.Mc, bt = g.Nc, St = c.ka, $t = c.ka + c.T, Gt = c.U, Ut = Gt + 1 >> 1;
      for (St == 0 ? W(K, J, null, null, it, yt, Lt, It, it, yt, Lt, It, D, $, null, null, Gt) : (W(g.ec, g.fc, K, J, Nt, Wt, Tt, bt, it, yt, Lt, It, D, $ - L.A, D, $, Gt), ++S); St + 2 < $t; St += 2) Nt = it, Wt = yt, Tt = Lt, bt = It, yt += c.Rc, It += c.Rc, $ += 2 * L.A, W(K, (J += 2 * c.fa) - c.fa, K, J, Nt, Wt, Tt, bt, it, yt, Lt, It, D, $ - L.A, D, $, Gt);
      return J += c.fa, c.j + $t < c.o ? (i(g.ec, g.fc, K, J, Gt), i(g.cc, g.dc, it, yt, Ut), i(g.Mc, g.Nc, Lt, It, Ut), S--) : 1 & $t || W(K, J, null, null, it, yt, Lt, It, it, yt, Lt, It, D, $ + L.A, null, null, Gt), S;
    }
    function Di(c, g, S) {
      var L = c.F, D = [c.J];
      if (L != null) {
        var $ = c.U, W = g.ba.S, K = W == ou || W == au;
        g = g.ba.f.RGBA;
        var J = [0], it = c.ka;
        J[0] = c.T, c.Kb && (it == 0 ? --J[0] : (--it, D[0] -= c.width), c.j + c.ka + c.T == c.o && (J[0] = c.o - c.j - it));
        var yt = g.eb;
        it = g.fb + it * g.A, c = hn(L, D[0], c.width, $, J, yt, it + (K ? 0 : 3), g.A), t(S == J), c && Jt(W) && Hi(yt, it, K, $, J, g.A);
      }
      return 0;
    }
    function pn(c) {
      var g = c.ma, S = g.ba.S, L = 11 > S, D = S == ru || S == su || S == ou || S == th || S == 12 || Jt(S);
      if (g.memory = null, g.Ib = null, g.Jb = null, g.Nd = null, !Ya(g.Oa, c, D ? 11 : 12)) return 0;
      if (D && Jt(S) && Zt(), c.da) alert("todo:use_scaling");
      else {
        if (L) {
          if (g.Ib = Ne, c.Kb) {
            if (S = c.U + 1 >> 1, g.memory = s(c.U + 2 * S), g.memory == null) return 0;
            g.ec = g.memory, g.fc = 0, g.cc = g.ec, g.dc = g.fc + c.U, g.Mc = g.cc, g.Nc = g.dc + S, g.Ib = Be, Zt();
          }
        } else alert("todo:EmitYUV");
        D && (g.Jb = Di, L && Ct());
      }
      if (L && !tp) {
        for (c = 0; 256 > c; ++c) r2[c] = 89858 * (c - 128) + uu >> lu, a2[c] = -22014 * (c - 128) + uu, o2[c] = -45773 * (c - 128), s2[c] = 113618 * (c - 128) + uu >> lu;
        for (c = il; c < oh; ++c) g = 76283 * (c - 16) + uu >> lu, l2[c - il] = Ii(g, 255), u2[c - il] = Ii(g + 8 >> 4, 15);
        tp = 1;
      }
      return 1;
    }
    function Ni(c) {
      var g = c.ma, S = c.U, L = c.T;
      return t(!(1 & c.ka)), 0 >= S || 0 >= L ? 0 : (S = g.Ib(c, g), g.Jb != null && g.Jb(c, g, S), g.Dc += S, 1);
    }
    function Bi(c) {
      c.ma.memory = null;
    }
    function me(c, g, S, L) {
      return ct(c, 8) != 47 ? 0 : (g[0] = ct(c, 14) + 1, S[0] = ct(c, 14) + 1, L[0] = ct(c, 1), ct(c, 3) != 0 ? 0 : !c.h);
    }
    function gi(c, g) {
      if (4 > c) return c + 1;
      var S = c - 2 >> 1;
      return (2 + (1 & c) << S) + ct(g, S) + 1;
    }
    function ji(c, g) {
      return 120 < g ? g - 120 : 1 <= (S = ((S = Wm[g - 1]) >> 4) * c + (8 - (15 & S))) ? S : 1;
      var S;
    }
    function Qn(c, g, S) {
      var L = z(S), D = c[g += 255 & L].g - 8;
      return 0 < D && (Y(S, S.u + 8), L = z(S), g += c[g].value, g += L & (1 << D) - 1), Y(S, S.u + c[g].g), c[g].value;
    }
    function An(c, g, S) {
      return S.g += c.g, S.value += c.value << g >>> 0, t(8 >= S.g), c.g;
    }
    function yn(c, g, S) {
      var L = c.xc;
      return t((g = L == 0 ? 0 : c.vc[c.md * (S >> L) + (g >> L)]) < c.Wb), c.Ya[g];
    }
    function ui(c, g, S, L) {
      var D = c.ab, $ = c.c * g, W = c.C;
      g = W + g;
      var K = S, J = L;
      for (L = c.Ta, S = c.Ua; 0 < D--; ) {
        var it = c.gc[D], yt = W, Lt = g, It = K, Nt = J, Wt = (J = L, K = S, it.Ea);
        switch (t(yt < Lt), t(Lt <= it.nc), it.hc) {
          case 2:
            Jl(It, Nt, (Lt - yt) * Wt, J, K);
            break;
          case 0:
            var Tt = yt, bt = Lt, St = J, $t = K, Gt = (oe = it).Ea;
            Tt == 0 && (Zc(It, Nt, null, null, 1, St, $t), Vt(It, Nt + 1, 0, 0, Gt - 1, St, $t + 1), Nt += Gt, $t += Gt, ++Tt);
            for (var Ut = 1 << oe.b, fe = Ut - 1, se = X(Gt, oe.b), Se = oe.K, oe = oe.w + (Tt >> oe.b) * se; Tt < bt; ) {
              var Je = Se, tn = oe, Ue = 1;
              for (Ja(It, Nt, St, $t - Gt, 1, St, $t); Ue < Gt; ) {
                var qe = (Ue & ~fe) + Ut;
                qe > Gt && (qe = Gt), (0, ms[Je[tn++] >> 8 & 15])(It, Nt + +Ue, St, $t + Ue - Gt, qe - Ue, St, $t + Ue), Ue = qe;
              }
              Nt += Gt, $t += Gt, ++Tt & fe || (oe += se);
            }
            Lt != it.nc && i(J, K - Wt, J, K + (Lt - yt - 1) * Wt, Wt);
            break;
          case 1:
            for (Wt = It, bt = Nt, Gt = (It = it.Ea) - ($t = It & ~(St = (Nt = 1 << it.b) - 1)), Tt = X(It, it.b), Ut = it.K, it = it.w + (yt >> it.b) * Tt; yt < Lt; ) {
              for (fe = Ut, se = it, Se = new kt(), oe = bt + $t, Je = bt + It; bt < oe; ) ie(fe[se++], Se), to(Se, Wt, bt, Nt, J, K), bt += Nt, K += Nt;
              bt < Je && (ie(fe[se++], Se), to(Se, Wt, bt, Gt, J, K), bt += Gt, K += Gt), ++yt & St || (it += Tt);
            }
            break;
          case 3:
            if (It == J && Nt == K && 0 < it.b) {
              for (bt = J, It = Wt = K + (Lt - yt) * Wt - ($t = (Lt - yt) * X(it.Ea, it.b)), Nt = J, St = K, Tt = [], $t = (Gt = $t) - 1; 0 <= $t; --$t) Tt[$t] = Nt[St + $t];
              for ($t = Gt - 1; 0 <= $t; --$t) bt[It + $t] = Tt[$t];
              $i(it, yt, Lt, J, Wt, J, K);
            } else $i(it, yt, Lt, It, Nt, J, K);
        }
        K = L, J = S;
      }
      J != S && i(L, S, K, J, $);
    }
    function ss(c, g) {
      var S = c.V, L = c.Ba + c.c * c.C, D = g - c.C;
      if (t(g <= c.l.o), t(16 >= D), 0 < D) {
        var $ = c.l, W = c.Ta, K = c.Ua, J = $.width;
        if (ui(c, D, S, L), D = K = [K], t((S = c.C) < (L = g)), t($.v < $.va), L > $.o && (L = $.o), S < $.j) {
          var it = $.j - S;
          S = $.j, D[0] += it * J;
        }
        if (S >= L ? S = 0 : (D[0] += 4 * $.v, $.ka = S - $.j, $.U = $.va - $.v, $.T = L - S, S = 1), S) {
          if (K = K[0], 11 > (S = c.ca).S) {
            var yt = S.f.RGBA, Lt = (L = S.S, D = $.U, $ = $.T, it = yt.eb, yt.A), It = $;
            for (yt = yt.fb + c.Ma * yt.A; 0 < It--; ) {
              var Nt = W, Wt = K, Tt = D, bt = it, St = yt;
              switch (L) {
                case iu:
                  vi(Nt, Wt, Tt, bt, St);
                  break;
                case ru:
                  ci(Nt, Wt, Tt, bt, St);
                  break;
                case eh:
                  ci(Nt, Wt, Tt, bt, St), Hi(bt, St, 0, Tt, 1, 0);
                  break;
                case Wd:
                  Hr(Nt, Wt, Tt, bt, St);
                  break;
                case su:
                  Ht(Nt, Wt, Tt, bt, St, 1);
                  break;
                case nh:
                  Ht(Nt, Wt, Tt, bt, St, 1), Hi(bt, St, 0, Tt, 1, 0);
                  break;
                case ou:
                  Ht(Nt, Wt, Tt, bt, St, 0);
                  break;
                case au:
                  Ht(Nt, Wt, Tt, bt, St, 0), Hi(bt, St, 1, Tt, 1, 0);
                  break;
                case th:
                  ys(Nt, Wt, Tt, bt, St);
                  break;
                case ih:
                  ys(Nt, Wt, Tt, bt, St), cn(bt, St, Tt, 1, 0);
                  break;
                case Hd:
                  Wr(Nt, Wt, Tt, bt, St);
                  break;
                default:
                  t(0);
              }
              K += J, yt += Lt;
            }
            c.Ma += $;
          } else alert("todo:EmitRescaledRowsYUVA");
          t(c.Ma <= S.height);
        }
      }
      c.C = g, t(c.C <= c.i);
    }
    function Qi(c) {
      var g;
      if (0 < c.ua) return 0;
      for (g = 0; g < c.Wb; ++g) {
        var S = c.Ya[g].G, L = c.Ya[g].H;
        if (0 < S[1][L[1] + 0].g || 0 < S[2][L[2] + 0].g || 0 < S[3][L[3] + 0].g) return 0;
      }
      return 1;
    }
    function Ci(c, g, S, L, D, $) {
      if (c.Z != 0) {
        var W = c.qd, K = c.rd;
        for (t(xs[c.Z] != null); g < S; ++g) xs[c.Z](W, K, L, D, L, D, $), W = L, K = D, D += $;
        c.qd = W, c.rd = K;
      }
    }
    function mi(c, g) {
      var S = c.l.ma, L = S.Z == 0 || S.Z == 1 ? c.l.j : c.C;
      if (L = c.C < L ? L : c.C, t(g <= c.l.o), g > L) {
        var D = c.l.width, $ = S.ca, W = S.tb + D * L, K = c.V, J = c.Ba + c.c * L, it = c.gc;
        t(c.ab == 1), t(it[0].hc == 3), Zl(it[0], L, g, K, J, $, W), Ci(S, L, g, $, W, D);
      }
      c.C = c.Ma = g;
    }
    function Pi(c, g, S, L, D, $, W) {
      var K = c.$ / L, J = c.$ % L, it = c.m, yt = c.s, Lt = S + c.$, It = Lt;
      D = S + L * D;
      var Nt = S + L * $, Wt = 280 + yt.ua, Tt = c.Pb ? K : 16777216, bt = 0 < yt.ua ? yt.Wa : null, St = yt.wc, $t = Lt < Nt ? yn(yt, J, K) : null;
      t(c.C < $), t(Nt <= D);
      var Gt = !1;
      t: for (; ; ) {
        for (; Gt || Lt < Nt; ) {
          var Ut = 0;
          if (K >= Tt) {
            var fe = Lt - S;
            t((Tt = c).Pb), Tt.wd = Tt.m, Tt.xd = fe, 0 < Tt.s.ua && ft(Tt.s.Wa, Tt.s.vb), Tt = K + Gm;
          }
          if (J & St || ($t = yn(yt, J, K)), t($t != null), $t.Qb && (g[Lt] = $t.qb, Gt = !0), !Gt) if (st(it), $t.jc) {
            Ut = it, fe = g;
            var se = Lt, Se = $t.pd[z(Ut) & Vn - 1];
            t($t.jc), 256 > Se.g ? (Y(Ut, Ut.u + Se.g), fe[se] = Se.value, Ut = 0) : (Y(Ut, Ut.u + Se.g - 256), t(256 <= Se.value), Ut = Se.value), Ut == 0 && (Gt = !0);
          } else Ut = Qn($t.G[0], $t.H[0], it);
          if (it.h) break;
          if (Gt || 256 > Ut) {
            if (!Gt) if ($t.nd) g[Lt] = ($t.qb | Ut << 8) >>> 0;
            else {
              if (st(it), Gt = Qn($t.G[1], $t.H[1], it), st(it), fe = Qn($t.G[2], $t.H[2], it), se = Qn($t.G[3], $t.H[3], it), it.h) break;
              g[Lt] = (se << 24 | Gt << 16 | Ut << 8 | fe) >>> 0;
            }
            if (Gt = !1, ++Lt, ++J >= L && (J = 0, ++K, W != null && K <= $ && !(K % 16) && W(c, K), bt != null)) for (; It < Lt; ) Ut = g[It++], bt.X[(506832829 * Ut & 4294967295) >>> bt.Mb] = Ut;
          } else if (280 > Ut) {
            if (Ut = gi(Ut - 256, it), fe = Qn($t.G[4], $t.H[4], it), st(it), fe = ji(L, fe = gi(fe, it)), it.h) break;
            if (Lt - S < fe || D - Lt < Ut) break t;
            for (se = 0; se < Ut; ++se) g[Lt + se] = g[Lt + se - fe];
            for (Lt += Ut, J += Ut; J >= L; ) J -= L, ++K, W != null && K <= $ && !(K % 16) && W(c, K);
            if (t(Lt <= D), J & St && ($t = yn(yt, J, K)), bt != null) for (; It < Lt; ) Ut = g[It++], bt.X[(506832829 * Ut & 4294967295) >>> bt.Mb] = Ut;
          } else {
            if (!(Ut < Wt)) break t;
            for (Gt = Ut - 280, t(bt != null); It < Lt; ) Ut = g[It++], bt.X[(506832829 * Ut & 4294967295) >>> bt.Mb] = Ut;
            Ut = Lt, t(!(Gt >>> (fe = bt).Xa)), g[Ut] = fe.X[Gt], Gt = !0;
          }
          Gt || t(it.h == G(it));
        }
        if (c.Pb && it.h && Lt < D) t(c.m.h), c.a = 5, c.m = c.wd, c.$ = c.xd, 0 < c.s.ua && ft(c.s.vb, c.s.Wa);
        else {
          if (it.h) break t;
          W != null && W(c, K > $ ? $ : K), c.a = 0, c.$ = Lt - S;
        }
        return 1;
      }
      return c.a = 3, 0;
    }
    function qi(c) {
      t(c != null), c.vc = null, c.yc = null, c.Ya = null;
      var g = c.Wa;
      g != null && (g.X = null), c.vb = null, t(c != null);
    }
    function yi() {
      var c = new Jc();
      return c == null ? null : (c.a = 0, c.xb = Yd, Ae("Predictor", "VP8LPredictors"), Ae("Predictor", "VP8LPredictors_C"), Ae("PredictorAdd", "VP8LPredictorsAdd"), Ae("PredictorAdd", "VP8LPredictorsAdd_C"), Jl = ne, to = ue, vi = Qt, ci = Ke, ys = ht, Wr = jt, Hr = Kt, F.VP8LMapColor32b = Ho, F.VP8LMapColor8b = Ql, c);
    }
    function tr(c, g, S, L, D) {
      var $ = 1, W = [c], K = [g], J = L.m, it = L.s, yt = null, Lt = 0;
      t: for (; ; ) {
        if (S) for (; $ && ct(J, 1); ) {
          var It = W, Nt = K, Wt = L, Tt = 1, bt = Wt.m, St = Wt.gc[Wt.ab], $t = ct(bt, 2);
          if (Wt.Oc & 1 << $t) $ = 0;
          else {
            switch (Wt.Oc |= 1 << $t, St.hc = $t, St.Ea = It[0], St.nc = Nt[0], St.K = [null], ++Wt.ab, t(4 >= Wt.ab), $t) {
              case 0:
              case 1:
                St.b = ct(bt, 3) + 2, Tt = tr(X(St.Ea, St.b), X(St.nc, St.b), 0, Wt, St.K), St.K = St.K[0];
                break;
              case 3:
                var Gt, Ut = ct(bt, 8) + 1, fe = 16 < Ut ? 0 : 4 < Ut ? 1 : 2 < Ut ? 2 : 3;
                if (It[0] = X(St.Ea, fe), St.b = fe, Gt = Tt = tr(Ut, 1, 0, Wt, St.K)) {
                  var se, Se = Ut, oe = St, Je = 1 << (8 >> oe.b), tn = s(Je);
                  if (tn == null) Gt = 0;
                  else {
                    var Ue = oe.K[0], qe = oe.w;
                    for (tn[0] = oe.K[0][0], se = 1; se < 1 * Se; ++se) tn[se] = rt(Ue[qe + se], tn[se - 1]);
                    for (; se < 4 * Je; ++se) tn[se] = 0;
                    oe.K[0] = null, oe.K[0] = tn, Gt = 1;
                  }
                }
                Tt = Gt;
                break;
              case 2:
                break;
              default:
                t(0);
            }
            $ = Tt;
          }
        }
        if (W = W[0], K = K[0], $ && ct(J, 1) && !($ = 1 <= (Lt = ct(J, 4)) && 11 >= Lt)) {
          L.a = 3;
          break t;
        }
        var an;
        if (an = $) e: {
          var rn, Re, Mn, wi = L, Rn = W, xi = K, en = Lt, Oi = S, Ti = wi.m, $n = wi.s, Yn = [null], fi = 1, Yi = 0, Sr = Hm[en];
          n: for (; ; ) {
            if (Oi && ct(Ti, 1)) {
              var Un = ct(Ti, 3) + 2, Kr = X(Rn, Un), so = X(xi, Un), Xo = Kr * so;
              if (!tr(Kr, so, 0, wi, Yn)) break n;
              for (Yn = Yn[0], $n.xc = Un, rn = 0; rn < Xo; ++rn) {
                var _s = Yn[rn] >> 8 & 65535;
                Yn[rn] = _s, _s >= fi && (fi = _s + 1);
              }
            }
            if (Ti.h) break n;
            for (Re = 0; 5 > Re; ++Re) {
              var Sn = Gd[Re];
              !Re && 0 < en && (Sn += 1 << en), Yi < Sn && (Yi = Sn);
            }
            var ah = o(fi * Sr, A), ip = fi, rp = o(ip, _);
            if (rp == null) var hu = null;
            else t(65536 >= ip), hu = rp;
            var rl = s(Yi);
            if (hu == null || rl == null || ah == null) {
              wi.a = 1;
              break n;
            }
            var fu = ah;
            for (rn = Mn = 0; rn < fi; ++rn) {
              var sr = hu[rn], Jo = sr.G, Zo = sr.H, sp = 0, du = 1, op = 0;
              for (Re = 0; 5 > Re; ++Re) {
                Sn = Gd[Re], Jo[Re] = fu, Zo[Re] = Mn, !Re && 0 < en && (Sn += 1 << en);
                r: {
                  var pu, lh = Sn, gu = wi, sl = rl, f2 = fu, d2 = Mn, uh = 0, Ss = gu.m, p2 = ct(Ss, 1);
                  if (r(sl, 0, 0, lh), p2) {
                    var g2 = ct(Ss, 1) + 1, m2 = ct(Ss, 1), ap = ct(Ss, m2 == 0 ? 1 : 8);
                    sl[ap] = 1, g2 == 2 && (sl[ap = ct(Ss, 8)] = 1);
                    var mu = 1;
                  } else {
                    var lp = s(19), up = ct(Ss, 4) + 4;
                    if (19 < up) {
                      gu.a = 3;
                      var yu = 0;
                      break r;
                    }
                    for (pu = 0; pu < up; ++pu) lp[Um[pu]] = ct(Ss, 3);
                    var ch = void 0, ol = void 0, cp = gu, y2 = lp, bu = lh, hp = sl, hh = 0, ks = cp.m, fp = 8, dp = o(128, A);
                    i: for (; P(dp, 0, 7, y2, 19); ) {
                      if (ct(ks, 1)) {
                        var b2 = 2 + 2 * ct(ks, 3);
                        if ((ch = 2 + ct(ks, b2)) > bu) break i;
                      } else ch = bu;
                      for (ol = 0; ol < bu && ch--; ) {
                        st(ks);
                        var pp = dp[0 + (127 & z(ks))];
                        Y(ks, ks.u + pp.g);
                        var Qo = pp.value;
                        if (16 > Qo) hp[ol++] = Qo, Qo != 0 && (fp = Qo);
                        else {
                          var v2 = Qo == 16, gp = Qo - 16, w2 = zm[gp], mp = ct(ks, qm[gp]) + w2;
                          if (ol + mp > bu) break i;
                          for (var x2 = v2 ? fp : 0; 0 < mp--; ) hp[ol++] = x2;
                        }
                      }
                      hh = 1;
                      break i;
                    }
                    hh || (cp.a = 3), mu = hh;
                  }
                  (mu = mu && !Ss.h) && (uh = P(f2, d2, 8, sl, lh)), mu && uh != 0 ? yu = uh : (gu.a = 3, yu = 0);
                }
                if (yu == 0) break n;
                if (du && $m[Re] == 1 && (du = fu[Mn].g == 0), sp += fu[Mn].g, Mn += yu, 3 >= Re) {
                  var al, fh = rl[0];
                  for (al = 1; al < Sn; ++al) rl[al] > fh && (fh = rl[al]);
                  op += fh;
                }
              }
              if (sr.nd = du, sr.Qb = 0, du && (sr.qb = (Jo[3][Zo[3] + 0].value << 24 | Jo[1][Zo[1] + 0].value << 16 | Jo[2][Zo[2] + 0].value) >>> 0, sp == 0 && 256 > Jo[0][Zo[0] + 0].value && (sr.Qb = 1, sr.qb += Jo[0][Zo[0] + 0].value << 8)), sr.jc = !sr.Qb && 6 > op, sr.jc) {
                var vu, Xr = sr;
                for (vu = 0; vu < Vn; ++vu) {
                  var As = vu, Ns = Xr.pd[As], wu = Xr.G[0][Xr.H[0] + As];
                  256 <= wu.value ? (Ns.g = wu.g + 256, Ns.value = wu.value) : (Ns.g = 0, Ns.value = 0, As >>= An(wu, 8, Ns), As >>= An(Xr.G[1][Xr.H[1] + As], 16, Ns), As >>= An(Xr.G[2][Xr.H[2] + As], 0, Ns), An(Xr.G[3][Xr.H[3] + As], 24, Ns));
                }
              }
            }
            $n.vc = Yn, $n.Wb = fi, $n.Ya = hu, $n.yc = ah, an = 1;
            break e;
          }
          an = 0;
        }
        if (!($ = an)) {
          L.a = 3;
          break t;
        }
        if (0 < Lt) {
          if (it.ua = 1 << Lt, !E(it.Wa, Lt)) {
            L.a = 1, $ = 0;
            break t;
          }
        } else it.ua = 0;
        var dh = L, yp = W, _2 = K, ph = dh.s, gh = ph.xc;
        if (dh.c = yp, dh.i = _2, ph.md = X(yp, gh), ph.wc = gh == 0 ? -1 : (1 << gh) - 1, S) {
          L.xb = Qm;
          break t;
        }
        if ((yt = s(W * K)) == null) {
          L.a = 1, $ = 0;
          break t;
        }
        $ = ($ = Pi(L, yt, 0, W, K, K, null)) && !J.h;
        break t;
      }
      return $ ? (D != null ? D[0] = yt : (t(yt == null), t(S)), L.$ = 0, S || qi(it)) : qi(it), $;
    }
    function Dr(c, g) {
      var S = c.c * c.i, L = S + g + 16 * g;
      return t(c.c <= g), c.V = s(L), c.V == null ? (c.Ta = null, c.Ua = 0, c.a = 1, 0) : (c.Ta = c.V, c.Ua = c.Ba + S + g, 1);
    }
    function Br(c, g) {
      var S = c.C, L = g - S, D = c.V, $ = c.Ba + c.c * S;
      for (t(g <= c.l.o); 0 < L; ) {
        var W = 16 < L ? 16 : L, K = c.l.ma, J = c.l.width, it = J * W, yt = K.ca, Lt = K.tb + J * S, It = c.Ta, Nt = c.Ua;
        ui(c, W, D, $), Cn(It, Nt, yt, Lt, it), Ci(K, S, S + W, yt, Lt, J), L -= W, D += W * c.c, S += W;
      }
      t(S == g), c.C = c.Ma = g;
    }
    function jr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function er() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function qr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function Us() {
      this.Yb = function() {
        var c = [];
        return function g(S, L, D) {
          for (var $ = D[L], W = 0; W < $ && (S.push(D.length > L + 1 ? [] : 0), !(D.length < L + 1)); W++) g(S[W], L + 1, D);
        }(c, 0, [3, 11]), c;
      }();
    }
    function os() {
      this.jb = s(3), this.Wc = a([4, 8], Us), this.Xc = a([4, 17], Us);
    }
    function as() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function zr() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function To() {
      this.Na = this.la = 0;
    }
    function La() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function vr() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ia() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new zr()), this.Y = 0, this.ya = Array(new vr()), this.aa = 0, this.l = new ls();
    }
    function wr() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Ea() {
      this.cb = this.a = 0, this.sc = "", this.m = new nt(), this.Od = new jr(), this.Kc = new er(), this.ed = new as(), this.Qa = new qr(), this.Ic = this.$c = this.Aa = 0, this.D = new Ia(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o(8, nt), this.ia = 0, this.pb = o(4, La), this.Pa = new os(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new wr()), this.Hd = 0, this.rb = Array(new To()), this.sb = 0, this.wa = Array(new zr()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new vr()), this.L = this.aa = 0, this.gd = a([4, 2], zr), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function ls() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Oa() {
      var c = new Ea();
      return c != null && (c.a = 0, c.sc = "OK", c.cb = 0, c.Xb = 0, nl || (nl = Hs)), c;
    }
    function bn(c, g, S) {
      return c.a == 0 && (c.a = g, c.sc = S, c.cb = 0), 0;
    }
    function Ws(c, g, S) {
      return 3 <= S && c[g + 0] == 157 && c[g + 1] == 1 && c[g + 2] == 42;
    }
    function Fo(c, g) {
      if (c == null) return 0;
      if (c.a = 0, c.sc = "OK", g == null) return bn(c, 2, "null VP8Io passed to VP8GetHeaders()");
      var S = g.data, L = g.w, D = g.ha;
      if (4 > D) return bn(c, 7, "Truncated header.");
      var $ = S[L + 0] | S[L + 1] << 8 | S[L + 2] << 16, W = c.Od;
      if (W.Rb = !(1 & $), W.td = $ >> 1 & 7, W.yd = $ >> 4 & 1, W.ub = $ >> 5, 3 < W.td) return bn(c, 3, "Incorrect keyframe parameters.");
      if (!W.yd) return bn(c, 4, "Frame not displayable.");
      L += 3, D -= 3;
      var K = c.Kc;
      if (W.Rb) {
        if (7 > D) return bn(c, 7, "cannot parse picture header");
        if (!Ws(S, L, D)) return bn(c, 3, "Bad code word");
        K.c = 16383 & (S[L + 4] << 8 | S[L + 3]), K.Td = S[L + 4] >> 6, K.i = 16383 & (S[L + 6] << 8 | S[L + 5]), K.Ud = S[L + 6] >> 6, L += 7, D -= 7, c.za = K.c + 15 >> 4, c.Ub = K.i + 15 >> 4, g.width = K.c, g.height = K.i, g.Da = 0, g.j = 0, g.v = 0, g.va = g.width, g.o = g.height, g.da = 0, g.ib = g.width, g.hb = g.height, g.U = g.width, g.T = g.height, r(($ = c.Pa).jb, 0, 255, $.jb.length), t(($ = c.Qa) != null), $.Cb = 0, $.Bb = 0, $.Fb = 1, r($.Zb, 0, 0, $.Zb.length), r($.Lb, 0, 0, $.Lb);
      }
      if (W.ub > D) return bn(c, 7, "bad partition length");
      Z($ = c.m, S, L, W.ub), L += W.ub, D -= W.ub, W.Rb && (K.Ld = mt($), K.Kd = mt($)), K = c.Qa;
      var J, it = c.Pa;
      if (t($ != null), t(K != null), K.Cb = mt($), K.Cb) {
        if (K.Bb = mt($), mt($)) {
          for (K.Fb = mt($), J = 0; 4 > J; ++J) K.Zb[J] = mt($) ? R($, 7) : 0;
          for (J = 0; 4 > J; ++J) K.Lb[J] = mt($) ? R($, 6) : 0;
        }
        if (K.Bb) for (J = 0; 3 > J; ++J) it.jb[J] = mt($) ? V($, 8) : 255;
      } else K.Bb = 0;
      if ($.Ka) return bn(c, 3, "cannot parse segment header");
      if ((K = c.ed).zd = mt($), K.Tb = V($, 6), K.wb = V($, 3), K.Pc = mt($), K.Pc && mt($)) {
        for (it = 0; 4 > it; ++it) mt($) && (K.vd[it] = R($, 6));
        for (it = 0; 4 > it; ++it) mt($) && (K.od[it] = R($, 6));
      }
      if (c.L = K.Tb == 0 ? 0 : K.zd ? 1 : 2, $.Ka) return bn(c, 3, "cannot parse filter header");
      var yt = D;
      if (D = J = L, L = J + yt, K = yt, c.Xb = (1 << V(c.m, 2)) - 1, yt < 3 * (it = c.Xb)) S = 7;
      else {
        for (J += 3 * it, K -= 3 * it, yt = 0; yt < it; ++yt) {
          var Lt = S[D + 0] | S[D + 1] << 8 | S[D + 2] << 16;
          Lt > K && (Lt = K), Z(c.Jc[+yt], S, J, Lt), J += Lt, K -= Lt, D += 3;
        }
        Z(c.Jc[+it], S, J, K), S = J < L ? 0 : 5;
      }
      if (S != 0) return bn(c, S, "cannot parse partitions");
      for (S = V(J = c.m, 7), D = mt(J) ? R(J, 4) : 0, L = mt(J) ? R(J, 4) : 0, K = mt(J) ? R(J, 4) : 0, it = mt(J) ? R(J, 4) : 0, J = mt(J) ? R(J, 4) : 0, yt = c.Qa, Lt = 0; 4 > Lt; ++Lt) {
        if (yt.Cb) {
          var It = yt.Zb[Lt];
          yt.Fb || (It += S);
        } else {
          if (0 < Lt) {
            c.pb[Lt] = c.pb[0];
            continue;
          }
          It = S;
        }
        var Nt = c.pb[Lt];
        Nt.Sc[0] = rh[Ii(It + D, 127)], Nt.Sc[1] = sh[Ii(It + 0, 127)], Nt.Eb[0] = 2 * rh[Ii(It + L, 127)], Nt.Eb[1] = 101581 * sh[Ii(It + K, 127)] >> 16, 8 > Nt.Eb[1] && (Nt.Eb[1] = 8), Nt.Qc[0] = rh[Ii(It + it, 117)], Nt.Qc[1] = sh[Ii(It + J, 127)], Nt.lc = It + J;
      }
      if (!W.Rb) return bn(c, 4, "Not a key frame.");
      for (mt($), W = c.Pa, S = 0; 4 > S; ++S) {
        for (D = 0; 8 > D; ++D) for (L = 0; 3 > L; ++L) for (K = 0; 11 > K; ++K) it = _t($, Jm[S][D][L][K]) ? V($, 8) : Km[S][D][L][K], W.Wc[S][D].Yb[L][K] = it;
        for (D = 0; 17 > D; ++D) W.Xc[S][D] = W.Wc[S][Zm[D]];
      }
      return c.kc = mt($), c.kc && (c.Bd = V($, 8)), c.cb = 1;
    }
    function Hs(c, g, S, L, D, $, W) {
      var K = g[D].Yb[S];
      for (S = 0; 16 > D; ++D) {
        if (!_t(c, K[S + 0])) return D;
        for (; !_t(c, K[S + 1]); ) if (K = g[++D].Yb[0], S = 0, D == 16) return 16;
        var J = g[D + 1].Yb;
        if (_t(c, K[S + 2])) {
          var it = c, yt = 0;
          if (_t(it, (It = K)[(Lt = S) + 3])) if (_t(it, It[Lt + 6])) {
            for (K = 0, Lt = 2 * (yt = _t(it, It[Lt + 8])) + (It = _t(it, It[Lt + 9 + yt])), yt = 0, It = Vm[Lt]; It[K]; ++K) yt += yt + _t(it, It[K]);
            yt += 3 + (8 << Lt);
          } else _t(it, It[Lt + 7]) ? (yt = 7 + 2 * _t(it, 165), yt += _t(it, 145)) : yt = 5 + _t(it, 159);
          else yt = _t(it, It[Lt + 4]) ? 3 + _t(it, It[Lt + 5]) : 2;
          K = J[2];
        } else yt = 1, K = J[1];
        J = W + Ym[D], 0 > (it = c).b && vt(it);
        var Lt, It = it.b, Nt = (Lt = it.Ca >> 1) - (it.I >> It) >> 31;
        --it.b, it.Ca += Nt, it.Ca |= 1, it.I -= (Lt + 1 & Nt) << It, $[J] = ((yt ^ Nt) - Nt) * L[(0 < D) + 0];
      }
      return 16;
    }
    function Gs(c) {
      var g = c.rb[c.sb - 1];
      g.la = 0, g.Na = 0, r(c.zc, 0, 0, c.zc.length), c.ja = 0;
    }
    function Ta(c, g) {
      if (c == null) return 0;
      if (g == null) return bn(c, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!c.cb && !Fo(c, g)) return 0;
      if (t(c.cb), g.ac == null || g.ac(g)) {
        g.ob && (c.L = 0);
        var S = cu[c.L];
        if (c.L == 2 ? (c.yb = 0, c.zb = 0) : (c.yb = g.v - S >> 4, c.zb = g.j - S >> 4, 0 > c.yb && (c.yb = 0), 0 > c.zb && (c.zb = 0)), c.Va = g.o + 15 + S >> 4, c.Hb = g.va + 15 + S >> 4, c.Hb > c.za && (c.Hb = c.za), c.Va > c.Ub && (c.Va = c.Ub), 0 < c.L) {
          var L = c.ed;
          for (S = 0; 4 > S; ++S) {
            var D;
            if (c.Qa.Cb) {
              var $ = c.Qa.Lb[S];
              c.Qa.Fb || ($ += L.Tb);
            } else $ = L.Tb;
            for (D = 0; 1 >= D; ++D) {
              var W = c.gd[S][D], K = $;
              if (L.Pc && (K += L.vd[0], D && (K += L.od[0])), 0 < (K = 0 > K ? 0 : 63 < K ? 63 : K)) {
                var J = K;
                0 < L.wb && (J = 4 < L.wb ? J >> 2 : J >> 1) > 9 - L.wb && (J = 9 - L.wb), 1 > J && (J = 1), W.dd = J, W.tc = 2 * K + J, W.ld = 40 <= K ? 2 : 15 <= K ? 1 : 0;
              } else W.tc = 0;
              W.La = D;
            }
          }
        }
        S = 0;
      } else bn(c, 6, "Frame setup failed"), S = c.a;
      if (S = S == 0) {
        if (S) {
          c.$c = 0, 0 < c.Aa || (c.Ic = h2);
          t: {
            S = c.Ic, L = 4 * (J = c.za);
            var it = 32 * J, yt = J + 1, Lt = 0 < c.L ? J * (0 < c.Aa ? 2 : 1) : 0, It = (c.Aa == 2 ? 2 : 1) * J;
            if ((W = L + 832 + (D = 3 * (16 * S + cu[c.L]) / 2 * it) + ($ = c.Fa != null && 0 < c.Fa.length ? c.Kc.c * c.Kc.i : 0)) != W) S = 0;
            else {
              if (W > c.Vb) {
                if (c.Vb = 0, c.Ec = s(W), c.Fc = 0, c.Ec == null) {
                  S = bn(c, 1, "no memory during frame initialization.");
                  break t;
                }
                c.Vb = W;
              }
              W = c.Ec, K = c.Fc, c.Ac = W, c.Bc = K, K += L, c.Gd = o(it, wr), c.Hd = 0, c.rb = o(yt + 1, To), c.sb = 1, c.wa = Lt ? o(Lt, zr) : null, c.Y = 0, c.D.Nb = 0, c.D.wa = c.wa, c.D.Y = c.Y, 0 < c.Aa && (c.D.Y += J), t(!0), c.oc = W, c.pc = K, K += 832, c.ya = o(It, vr), c.aa = 0, c.D.ya = c.ya, c.D.aa = c.aa, c.Aa == 2 && (c.D.aa += J), c.R = 16 * J, c.B = 8 * J, J = (it = cu[c.L]) * c.R, it = it / 2 * c.B, c.sa = W, c.ta = K + J, c.qa = c.sa, c.ra = c.ta + 16 * S * c.R + it, c.Ha = c.qa, c.Ia = c.ra + 8 * S * c.B + it, c.$c = 0, K += D, c.mb = $ ? W : null, c.nb = $ ? K : null, t(K + $ <= c.Fc + c.Vb), Gs(c), r(c.Ac, c.Bc, 0, L), S = 1;
            }
          }
          if (S) {
            if (g.ka = 0, g.y = c.sa, g.O = c.ta, g.f = c.qa, g.N = c.ra, g.ea = c.Ha, g.Vd = c.Ia, g.fa = c.R, g.Rc = c.B, g.F = null, g.J = 0, !eu) {
              for (S = -255; 255 >= S; ++S) Bn[255 + S] = 0 > S ? -S : S;
              for (S = -1020; 1020 >= S; ++S) Vr[1020 + S] = -128 > S ? -128 : 127 < S ? 127 : S;
              for (S = -112; 112 >= S; ++S) el[112 + S] = -16 > S ? -16 : 15 < S ? 15 : S;
              for (S = -255; 510 >= S; ++S) Ko[255 + S] = 0 > S ? 0 : 255 < S ? 255 : S;
              eu = 1;
            }
            Go = Ma, Gr = hs, Za = Ys, hi = Fa, Ui = Mo, Nn = Vs, Vo = ja, tu = Zs, Qa = Xc, eo = qa, no = Kc, bs = Do, io = za, Yo = Yl, ro = Vl, vs = xr, tl = Ur, Wi = Yc, rr[0] = zi, rr[1] = pt, rr[2] = ve, rr[3] = Li, rr[4] = fs, rr[5] = $r, rr[6] = Ks, rr[7] = Ra, rr[8] = Hc, rr[9] = Wc, ws[0] = _e, ws[1] = zt, ws[2] = Ot, ws[3] = pe, ws[4] = Oe, ws[5] = un, ws[6] = Ee, Yr[0] = ds, Yr[1] = xt, Yr[2] = Gc, Yr[3] = Da, Yr[4] = Js, Yr[5] = Vc, Yr[6] = Ba, S = 1;
          } else S = 0;
        }
        S && (S = function(Nt, Wt) {
          for (Nt.M = 0; Nt.M < Nt.Va; ++Nt.M) {
            var Tt, bt = Nt.Jc[Nt.M & Nt.Xb], St = Nt.m, $t = Nt;
            for (Tt = 0; Tt < $t.za; ++Tt) {
              var Gt = St, Ut = $t, fe = Ut.Ac, se = Ut.Bc + 4 * Tt, Se = Ut.zc, oe = Ut.ya[Ut.aa + Tt];
              if (Ut.Qa.Bb ? oe.$b = _t(Gt, Ut.Pa.jb[0]) ? 2 + _t(Gt, Ut.Pa.jb[2]) : _t(Gt, Ut.Pa.jb[1]) : oe.$b = 0, Ut.kc && (oe.Ad = _t(Gt, Ut.Bd)), oe.Za = !_t(Gt, 145) + 0, oe.Za) {
                var Je = oe.Ob, tn = 0;
                for (Ut = 0; 4 > Ut; ++Ut) {
                  var Ue, qe = Se[0 + Ut];
                  for (Ue = 0; 4 > Ue; ++Ue) {
                    qe = Xm[fe[se + Ue]][qe];
                    for (var an = Vd[_t(Gt, qe[0])]; 0 < an; ) an = Vd[2 * an + _t(Gt, qe[an])];
                    qe = -an, fe[se + Ue] = qe;
                  }
                  i(Je, tn, fe, se, 4), tn += 4, Se[0 + Ut] = qe;
                }
              } else qe = _t(Gt, 156) ? _t(Gt, 128) ? 1 : 3 : _t(Gt, 163) ? 2 : 0, oe.Ob[0] = qe, r(fe, se, qe, 4), r(Se, 0, qe, 4);
              oe.Dd = _t(Gt, 142) ? _t(Gt, 114) ? _t(Gt, 183) ? 1 : 3 : 2 : 0;
            }
            if ($t.m.Ka) return bn(Nt, 7, "Premature end-of-partition0 encountered.");
            for (; Nt.ja < Nt.za; ++Nt.ja) {
              if ($t = bt, Gt = (St = Nt).rb[St.sb - 1], fe = St.rb[St.sb + St.ja], Tt = St.ya[St.aa + St.ja], se = St.kc ? Tt.Ad : 0) Gt.la = fe.la = 0, Tt.Za || (Gt.Na = fe.Na = 0), Tt.Hc = 0, Tt.Gc = 0, Tt.ia = 0;
              else {
                var rn, Re;
                if (Gt = fe, fe = $t, se = St.Pa.Xc, Se = St.ya[St.aa + St.ja], oe = St.pb[Se.$b], Ut = Se.ad, Je = 0, tn = St.rb[St.sb - 1], qe = Ue = 0, r(Ut, Je, 0, 384), Se.Za) var Mn = 0, wi = se[3];
                else {
                  an = s(16);
                  var Rn = Gt.Na + tn.Na;
                  if (Rn = nl(fe, se[1], Rn, oe.Eb, 0, an, 0), Gt.Na = tn.Na = (0 < Rn) + 0, 1 < Rn) Go(an, 0, Ut, Je);
                  else {
                    var xi = an[0] + 3 >> 3;
                    for (an = 0; 256 > an; an += 16) Ut[Je + an] = xi;
                  }
                  Mn = 1, wi = se[0];
                }
                var en = 15 & Gt.la, Oi = 15 & tn.la;
                for (an = 0; 4 > an; ++an) {
                  var Ti = 1 & Oi;
                  for (xi = Re = 0; 4 > xi; ++xi) en = en >> 1 | (Ti = (Rn = nl(fe, wi, Rn = Ti + (1 & en), oe.Sc, Mn, Ut, Je)) > Mn) << 7, Re = Re << 2 | (3 < Rn ? 3 : 1 < Rn ? 2 : Ut[Je + 0] != 0), Je += 16;
                  en >>= 4, Oi = Oi >> 1 | Ti << 7, Ue = (Ue << 8 | Re) >>> 0;
                }
                for (wi = en, Mn = Oi >> 4, rn = 0; 4 > rn; rn += 2) {
                  for (Re = 0, en = Gt.la >> 4 + rn, Oi = tn.la >> 4 + rn, an = 0; 2 > an; ++an) {
                    for (Ti = 1 & Oi, xi = 0; 2 > xi; ++xi) Rn = Ti + (1 & en), en = en >> 1 | (Ti = 0 < (Rn = nl(fe, se[2], Rn, oe.Qc, 0, Ut, Je))) << 3, Re = Re << 2 | (3 < Rn ? 3 : 1 < Rn ? 2 : Ut[Je + 0] != 0), Je += 16;
                    en >>= 2, Oi = Oi >> 1 | Ti << 5;
                  }
                  qe |= Re << 4 * rn, wi |= en << 4 << rn, Mn |= (240 & Oi) << rn;
                }
                Gt.la = wi, tn.la = Mn, Se.Hc = Ue, Se.Gc = qe, Se.ia = 43690 & qe ? 0 : oe.ia, se = !(Ue | qe);
              }
              if (0 < St.L && (St.wa[St.Y + St.ja] = St.gd[Tt.$b][Tt.Za], St.wa[St.Y + St.ja].La |= !se), $t.Ka) return bn(Nt, 7, "Premature end-of-file encountered.");
            }
            if (Gs(Nt), St = Wt, $t = 1, Tt = (bt = Nt).D, Gt = 0 < bt.L && bt.M >= bt.zb && bt.M <= bt.Va, bt.Aa == 0) t: {
              if (Tt.M = bt.M, Tt.uc = Gt, Va(bt, Tt), $t = 1, Tt = (Re = bt.D).Nb, Gt = (qe = cu[bt.L]) * bt.R, fe = qe / 2 * bt.B, an = 16 * Tt * bt.R, xi = 8 * Tt * bt.B, se = bt.sa, Se = bt.ta - Gt + an, oe = bt.qa, Ut = bt.ra - fe + xi, Je = bt.Ha, tn = bt.Ia - fe + xi, Oi = (en = Re.M) == 0, Ue = en >= bt.Va - 1, bt.Aa == 2 && Va(bt, Re), Re.uc) for (Ti = (Rn = bt).D.M, t(Rn.D.uc), Re = Rn.yb; Re < Rn.Hb; ++Re) {
                Mn = Re, wi = Ti;
                var $n = (Yn = (Sn = Rn).D).Nb;
                rn = Sn.R;
                var Yn = Yn.wa[Yn.Y + Mn], fi = Sn.sa, Yi = Sn.ta + 16 * $n * rn + 16 * Mn, Sr = Yn.dd, Un = Yn.tc;
                if (Un != 0) if (t(3 <= Un), Sn.L == 1) 0 < Mn && vs(fi, Yi, rn, Un + 4), Yn.La && Wi(fi, Yi, rn, Un), 0 < wi && ro(fi, Yi, rn, Un + 4), Yn.La && tl(fi, Yi, rn, Un);
                else {
                  var Kr = Sn.B, so = Sn.qa, Xo = Sn.ra + 8 * $n * Kr + 8 * Mn, _s = Sn.Ha, Sn = Sn.Ia + 8 * $n * Kr + 8 * Mn;
                  $n = Yn.ld, 0 < Mn && (tu(fi, Yi, rn, Un + 4, Sr, $n), eo(so, Xo, _s, Sn, Kr, Un + 4, Sr, $n)), Yn.La && (bs(fi, Yi, rn, Un, Sr, $n), Yo(so, Xo, _s, Sn, Kr, Un, Sr, $n)), 0 < wi && (Vo(fi, Yi, rn, Un + 4, Sr, $n), Qa(so, Xo, _s, Sn, Kr, Un + 4, Sr, $n)), Yn.La && (no(fi, Yi, rn, Un, Sr, $n), io(so, Xo, _s, Sn, Kr, Un, Sr, $n));
                }
              }
              if (bt.ia && alert("todo:DitherRow"), St.put != null) {
                if (Re = 16 * en, en = 16 * (en + 1), Oi ? (St.y = bt.sa, St.O = bt.ta + an, St.f = bt.qa, St.N = bt.ra + xi, St.ea = bt.Ha, St.W = bt.Ia + xi) : (Re -= qe, St.y = se, St.O = Se, St.f = oe, St.N = Ut, St.ea = Je, St.W = tn), Ue || (en -= qe), en > St.o && (en = St.o), St.F = null, St.J = null, bt.Fa != null && 0 < bt.Fa.length && Re < en && (St.J = Ha(bt, St, Re, en - Re), St.F = bt.mb, St.F == null && St.F.length == 0)) {
                  $t = bn(bt, 3, "Could not decode alpha data.");
                  break t;
                }
                Re < St.j && (qe = St.j - Re, Re = St.j, t(!(1 & qe)), St.O += bt.R * qe, St.N += bt.B * (qe >> 1), St.W += bt.B * (qe >> 1), St.F != null && (St.J += St.width * qe)), Re < en && (St.O += St.v, St.N += St.v >> 1, St.W += St.v >> 1, St.F != null && (St.J += St.v), St.ka = Re - St.j, St.U = St.va - St.v, St.T = en - Re, $t = St.put(St));
              }
              Tt + 1 != bt.Ic || Ue || (i(bt.sa, bt.ta - Gt, se, Se + 16 * bt.R, Gt), i(bt.qa, bt.ra - fe, oe, Ut + 8 * bt.B, fe), i(bt.Ha, bt.Ia - fe, Je, tn + 8 * bt.B, fe));
            }
            if (!$t) return bn(Nt, 6, "Output aborted.");
          }
          return 1;
        }(c, g)), g.bc != null && g.bc(g), S &= 1;
      }
      return S ? (c.cb = 0, S) : 0;
    }
    function Tn(c, g, S, L, D) {
      D = c[g + S + 32 * L] + (D >> 3), c[g + S + 32 * L] = -256 & D ? 0 > D ? 0 : 255 : D;
    }
    function us(c, g, S, L, D, $) {
      Tn(c, g, 0, S, L + D), Tn(c, g, 1, S, L + $), Tn(c, g, 2, S, L - $), Tn(c, g, 3, S, L - D);
    }
    function ti(c) {
      return (20091 * c >> 16) + c;
    }
    function cs(c, g, S, L) {
      var D, $ = 0, W = s(16);
      for (D = 0; 4 > D; ++D) {
        var K = c[g + 0] + c[g + 8], J = c[g + 0] - c[g + 8], it = (35468 * c[g + 4] >> 16) - ti(c[g + 12]), yt = ti(c[g + 4]) + (35468 * c[g + 12] >> 16);
        W[$ + 0] = K + yt, W[$ + 1] = J + it, W[$ + 2] = J - it, W[$ + 3] = K - yt, $ += 4, g++;
      }
      for (D = $ = 0; 4 > D; ++D) K = (c = W[$ + 0] + 4) + W[$ + 8], J = c - W[$ + 8], it = (35468 * W[$ + 4] >> 16) - ti(W[$ + 12]), Tn(S, L, 0, 0, K + (yt = ti(W[$ + 4]) + (35468 * W[$ + 12] >> 16))), Tn(S, L, 1, 0, J + it), Tn(S, L, 2, 0, J - it), Tn(S, L, 3, 0, K - yt), $++, L += 32;
    }
    function Vs(c, g, S, L) {
      var D = c[g + 0] + 4, $ = 35468 * c[g + 4] >> 16, W = ti(c[g + 4]), K = 35468 * c[g + 1] >> 16;
      us(S, L, 0, D + W, c = ti(c[g + 1]), K), us(S, L, 1, D + $, c, K), us(S, L, 2, D - $, c, K), us(S, L, 3, D - W, c, K);
    }
    function hs(c, g, S, L, D) {
      cs(c, g, S, L), D && cs(c, g + 16, S, L + 4);
    }
    function Ys(c, g, S, L) {
      Gr(c, g + 0, S, L, 1), Gr(c, g + 32, S, L + 128, 1);
    }
    function Fa(c, g, S, L) {
      var D;
      for (c = c[g + 0] + 4, D = 0; 4 > D; ++D) for (g = 0; 4 > g; ++g) Tn(S, L, g, D, c);
    }
    function Mo(c, g, S, L) {
      c[g + 0] && hi(c, g + 0, S, L), c[g + 16] && hi(c, g + 16, S, L + 4), c[g + 32] && hi(c, g + 32, S, L + 128), c[g + 48] && hi(c, g + 48, S, L + 128 + 4);
    }
    function Ma(c, g, S, L) {
      var D, $ = s(16);
      for (D = 0; 4 > D; ++D) {
        var W = c[g + 0 + D] + c[g + 12 + D], K = c[g + 4 + D] + c[g + 8 + D], J = c[g + 4 + D] - c[g + 8 + D], it = c[g + 0 + D] - c[g + 12 + D];
        $[0 + D] = W + K, $[8 + D] = W - K, $[4 + D] = it + J, $[12 + D] = it - J;
      }
      for (D = 0; 4 > D; ++D) W = (c = $[0 + 4 * D] + 3) + $[3 + 4 * D], K = $[1 + 4 * D] + $[2 + 4 * D], J = $[1 + 4 * D] - $[2 + 4 * D], it = c - $[3 + 4 * D], S[L + 0] = W + K >> 3, S[L + 16] = it + J >> 3, S[L + 32] = W - K >> 3, S[L + 48] = it - J >> 3, L += 64;
    }
    function at(c, g, S) {
      var L, D = g - 32, $ = Ei, W = 255 - c[D - 1];
      for (L = 0; L < S; ++L) {
        var K, J = $, it = W + c[g - 1];
        for (K = 0; K < S; ++K) c[g + K] = J[it + c[D + K]];
        g += 32;
      }
    }
    function pt(c, g) {
      at(c, g, 4);
    }
    function xt(c, g) {
      at(c, g, 8);
    }
    function zt(c, g) {
      at(c, g, 16);
    }
    function Ot(c, g) {
      var S;
      for (S = 0; 16 > S; ++S) i(c, g + 32 * S, c, g - 32, 16);
    }
    function pe(c, g) {
      var S;
      for (S = 16; 0 < S; --S) r(c, g, c[g - 1], 16), g += 32;
    }
    function ce(c, g, S) {
      var L;
      for (L = 0; 16 > L; ++L) r(g, S + 32 * L, c, 16);
    }
    function _e(c, g) {
      var S, L = 16;
      for (S = 0; 16 > S; ++S) L += c[g - 1 + 32 * S] + c[g + S - 32];
      ce(L >> 5, c, g);
    }
    function Oe(c, g) {
      var S, L = 8;
      for (S = 0; 16 > S; ++S) L += c[g - 1 + 32 * S];
      ce(L >> 4, c, g);
    }
    function un(c, g) {
      var S, L = 8;
      for (S = 0; 16 > S; ++S) L += c[g + S - 32];
      ce(L >> 4, c, g);
    }
    function Ee(c, g) {
      ce(128, c, g);
    }
    function ae(c, g, S) {
      return c + 2 * g + S + 2 >> 2;
    }
    function ve(c, g) {
      var S, L = g - 32;
      for (L = new Uint8Array([ae(c[L - 1], c[L + 0], c[L + 1]), ae(c[L + 0], c[L + 1], c[L + 2]), ae(c[L + 1], c[L + 2], c[L + 3]), ae(c[L + 2], c[L + 3], c[L + 4])]), S = 0; 4 > S; ++S) i(c, g + 32 * S, L, 0, L.length);
    }
    function Li(c, g) {
      var S = c[g - 1], L = c[g - 1 + 32], D = c[g - 1 + 64], $ = c[g - 1 + 96];
      Bt(c, g + 0, 16843009 * ae(c[g - 1 - 32], S, L)), Bt(c, g + 32, 16843009 * ae(S, L, D)), Bt(c, g + 64, 16843009 * ae(L, D, $)), Bt(c, g + 96, 16843009 * ae(D, $, $));
    }
    function zi(c, g) {
      var S, L = 4;
      for (S = 0; 4 > S; ++S) L += c[g + S - 32] + c[g - 1 + 32 * S];
      for (L >>= 3, S = 0; 4 > S; ++S) r(c, g + 32 * S, L, 4);
    }
    function fs(c, g) {
      var S = c[g - 1 + 0], L = c[g - 1 + 32], D = c[g - 1 + 64], $ = c[g - 1 - 32], W = c[g + 0 - 32], K = c[g + 1 - 32], J = c[g + 2 - 32], it = c[g + 3 - 32];
      c[g + 0 + 96] = ae(L, D, c[g - 1 + 96]), c[g + 1 + 96] = c[g + 0 + 64] = ae(S, L, D), c[g + 2 + 96] = c[g + 1 + 64] = c[g + 0 + 32] = ae($, S, L), c[g + 3 + 96] = c[g + 2 + 64] = c[g + 1 + 32] = c[g + 0 + 0] = ae(W, $, S), c[g + 3 + 64] = c[g + 2 + 32] = c[g + 1 + 0] = ae(K, W, $), c[g + 3 + 32] = c[g + 2 + 0] = ae(J, K, W), c[g + 3 + 0] = ae(it, J, K);
    }
    function Ks(c, g) {
      var S = c[g + 1 - 32], L = c[g + 2 - 32], D = c[g + 3 - 32], $ = c[g + 4 - 32], W = c[g + 5 - 32], K = c[g + 6 - 32], J = c[g + 7 - 32];
      c[g + 0 + 0] = ae(c[g + 0 - 32], S, L), c[g + 1 + 0] = c[g + 0 + 32] = ae(S, L, D), c[g + 2 + 0] = c[g + 1 + 32] = c[g + 0 + 64] = ae(L, D, $), c[g + 3 + 0] = c[g + 2 + 32] = c[g + 1 + 64] = c[g + 0 + 96] = ae(D, $, W), c[g + 3 + 32] = c[g + 2 + 64] = c[g + 1 + 96] = ae($, W, K), c[g + 3 + 64] = c[g + 2 + 96] = ae(W, K, J), c[g + 3 + 96] = ae(K, J, J);
    }
    function $r(c, g) {
      var S = c[g - 1 + 0], L = c[g - 1 + 32], D = c[g - 1 + 64], $ = c[g - 1 - 32], W = c[g + 0 - 32], K = c[g + 1 - 32], J = c[g + 2 - 32], it = c[g + 3 - 32];
      c[g + 0 + 0] = c[g + 1 + 64] = $ + W + 1 >> 1, c[g + 1 + 0] = c[g + 2 + 64] = W + K + 1 >> 1, c[g + 2 + 0] = c[g + 3 + 64] = K + J + 1 >> 1, c[g + 3 + 0] = J + it + 1 >> 1, c[g + 0 + 96] = ae(D, L, S), c[g + 0 + 64] = ae(L, S, $), c[g + 0 + 32] = c[g + 1 + 96] = ae(S, $, W), c[g + 1 + 32] = c[g + 2 + 96] = ae($, W, K), c[g + 2 + 32] = c[g + 3 + 96] = ae(W, K, J), c[g + 3 + 32] = ae(K, J, it);
    }
    function Ra(c, g) {
      var S = c[g + 0 - 32], L = c[g + 1 - 32], D = c[g + 2 - 32], $ = c[g + 3 - 32], W = c[g + 4 - 32], K = c[g + 5 - 32], J = c[g + 6 - 32], it = c[g + 7 - 32];
      c[g + 0 + 0] = S + L + 1 >> 1, c[g + 1 + 0] = c[g + 0 + 64] = L + D + 1 >> 1, c[g + 2 + 0] = c[g + 1 + 64] = D + $ + 1 >> 1, c[g + 3 + 0] = c[g + 2 + 64] = $ + W + 1 >> 1, c[g + 0 + 32] = ae(S, L, D), c[g + 1 + 32] = c[g + 0 + 96] = ae(L, D, $), c[g + 2 + 32] = c[g + 1 + 96] = ae(D, $, W), c[g + 3 + 32] = c[g + 2 + 96] = ae($, W, K), c[g + 3 + 64] = ae(W, K, J), c[g + 3 + 96] = ae(K, J, it);
    }
    function Wc(c, g) {
      var S = c[g - 1 + 0], L = c[g - 1 + 32], D = c[g - 1 + 64], $ = c[g - 1 + 96];
      c[g + 0 + 0] = S + L + 1 >> 1, c[g + 2 + 0] = c[g + 0 + 32] = L + D + 1 >> 1, c[g + 2 + 32] = c[g + 0 + 64] = D + $ + 1 >> 1, c[g + 1 + 0] = ae(S, L, D), c[g + 3 + 0] = c[g + 1 + 32] = ae(L, D, $), c[g + 3 + 32] = c[g + 1 + 64] = ae(D, $, $), c[g + 3 + 64] = c[g + 2 + 64] = c[g + 0 + 96] = c[g + 1 + 96] = c[g + 2 + 96] = c[g + 3 + 96] = $;
    }
    function Hc(c, g) {
      var S = c[g - 1 + 0], L = c[g - 1 + 32], D = c[g - 1 + 64], $ = c[g - 1 + 96], W = c[g - 1 - 32], K = c[g + 0 - 32], J = c[g + 1 - 32], it = c[g + 2 - 32];
      c[g + 0 + 0] = c[g + 2 + 32] = S + W + 1 >> 1, c[g + 0 + 32] = c[g + 2 + 64] = L + S + 1 >> 1, c[g + 0 + 64] = c[g + 2 + 96] = D + L + 1 >> 1, c[g + 0 + 96] = $ + D + 1 >> 1, c[g + 3 + 0] = ae(K, J, it), c[g + 2 + 0] = ae(W, K, J), c[g + 1 + 0] = c[g + 3 + 32] = ae(S, W, K), c[g + 1 + 32] = c[g + 3 + 64] = ae(L, S, W), c[g + 1 + 64] = c[g + 3 + 96] = ae(D, L, S), c[g + 1 + 96] = ae($, D, L);
    }
    function Gc(c, g) {
      var S;
      for (S = 0; 8 > S; ++S) i(c, g + 32 * S, c, g - 32, 8);
    }
    function Da(c, g) {
      var S;
      for (S = 0; 8 > S; ++S) r(c, g, c[g - 1], 8), g += 32;
    }
    function Xs(c, g, S) {
      var L;
      for (L = 0; 8 > L; ++L) r(g, S + 32 * L, c, 8);
    }
    function ds(c, g) {
      var S, L = 8;
      for (S = 0; 8 > S; ++S) L += c[g + S - 32] + c[g - 1 + 32 * S];
      Xs(L >> 4, c, g);
    }
    function Vc(c, g) {
      var S, L = 4;
      for (S = 0; 8 > S; ++S) L += c[g + S - 32];
      Xs(L >> 3, c, g);
    }
    function Js(c, g) {
      var S, L = 4;
      for (S = 0; 8 > S; ++S) L += c[g - 1 + 32 * S];
      Xs(L >> 3, c, g);
    }
    function Ba(c, g) {
      Xs(128, c, g);
    }
    function Ro(c, g, S) {
      var L = c[g - S], D = c[g + 0], $ = 3 * (D - L) + Qc[1020 + c[g - 2 * S] - c[g + S]], W = nu[112 + ($ + 4 >> 3)];
      c[g - S] = Ei[255 + L + nu[112 + ($ + 3 >> 3)]], c[g + 0] = Ei[255 + D - W];
    }
    function Wl(c, g, S, L) {
      var D = c[g + 0], $ = c[g + S];
      return Gi[255 + c[g - 2 * S] - c[g - S]] > L || Gi[255 + $ - D] > L;
    }
    function Hl(c, g, S, L) {
      return 4 * Gi[255 + c[g - S] - c[g + 0]] + Gi[255 + c[g - 2 * S] - c[g + S]] <= L;
    }
    function Gl(c, g, S, L, D) {
      var $ = c[g - 3 * S], W = c[g - 2 * S], K = c[g - S], J = c[g + 0], it = c[g + S], yt = c[g + 2 * S], Lt = c[g + 3 * S];
      return 4 * Gi[255 + K - J] + Gi[255 + W - it] > L ? 0 : Gi[255 + c[g - 4 * S] - $] <= D && Gi[255 + $ - W] <= D && Gi[255 + W - K] <= D && Gi[255 + Lt - yt] <= D && Gi[255 + yt - it] <= D && Gi[255 + it - J] <= D;
    }
    function Vl(c, g, S, L) {
      var D = 2 * L + 1;
      for (L = 0; 16 > L; ++L) Hl(c, g + L, S, D) && Ro(c, g + L, S);
    }
    function xr(c, g, S, L) {
      var D = 2 * L + 1;
      for (L = 0; 16 > L; ++L) Hl(c, g + L * S, 1, D) && Ro(c, g + L * S, 1);
    }
    function Ur(c, g, S, L) {
      var D;
      for (D = 3; 0 < D; --D) Vl(c, g += 4 * S, S, L);
    }
    function Yc(c, g, S, L) {
      var D;
      for (D = 3; 0 < D; --D) xr(c, g += 4, S, L);
    }
    function ps(c, g, S, L, D, $, W, K) {
      for ($ = 2 * $ + 1; 0 < D--; ) {
        if (Gl(c, g, S, $, W)) if (Wl(c, g, S, K)) Ro(c, g, S);
        else {
          var J = c, it = g, yt = S, Lt = J[it - 2 * yt], It = J[it - yt], Nt = J[it + 0], Wt = J[it + yt], Tt = J[it + 2 * yt], bt = 27 * ($t = Qc[1020 + 3 * (Nt - It) + Qc[1020 + Lt - Wt]]) + 63 >> 7, St = 18 * $t + 63 >> 7, $t = 9 * $t + 63 >> 7;
          J[it - 3 * yt] = Ei[255 + J[it - 3 * yt] + $t], J[it - 2 * yt] = Ei[255 + Lt + St], J[it - yt] = Ei[255 + It + bt], J[it + 0] = Ei[255 + Nt - bt], J[it + yt] = Ei[255 + Wt - St], J[it + 2 * yt] = Ei[255 + Tt - $t];
        }
        g += L;
      }
    }
    function nr(c, g, S, L, D, $, W, K) {
      for ($ = 2 * $ + 1; 0 < D--; ) {
        if (Gl(c, g, S, $, W)) if (Wl(c, g, S, K)) Ro(c, g, S);
        else {
          var J = c, it = g, yt = S, Lt = J[it - yt], It = J[it + 0], Nt = J[it + yt], Wt = nu[112 + ((Tt = 3 * (It - Lt)) + 4 >> 3)], Tt = nu[112 + (Tt + 3 >> 3)], bt = Wt + 1 >> 1;
          J[it - 2 * yt] = Ei[255 + J[it - 2 * yt] + bt], J[it - yt] = Ei[255 + Lt + Tt], J[it + 0] = Ei[255 + It - Wt], J[it + yt] = Ei[255 + Nt - bt];
        }
        g += L;
      }
    }
    function ja(c, g, S, L, D, $) {
      ps(c, g, S, 1, 16, L, D, $);
    }
    function Zs(c, g, S, L, D, $) {
      ps(c, g, 1, S, 16, L, D, $);
    }
    function Kc(c, g, S, L, D, $) {
      var W;
      for (W = 3; 0 < W; --W) nr(c, g += 4 * S, S, 1, 16, L, D, $);
    }
    function Do(c, g, S, L, D, $) {
      var W;
      for (W = 3; 0 < W; --W) nr(c, g += 4, 1, S, 16, L, D, $);
    }
    function Xc(c, g, S, L, D, $, W, K) {
      ps(c, g, D, 1, 8, $, W, K), ps(S, L, D, 1, 8, $, W, K);
    }
    function qa(c, g, S, L, D, $, W, K) {
      ps(c, g, 1, D, 8, $, W, K), ps(S, L, 1, D, 8, $, W, K);
    }
    function za(c, g, S, L, D, $, W, K) {
      nr(c, g + 4 * D, D, 1, 8, $, W, K), nr(S, L + 4 * D, D, 1, 8, $, W, K);
    }
    function Yl(c, g, S, L, D, $, W, K) {
      nr(c, g + 4, 1, D, 8, $, W, K), nr(S, L + 4, 1, D, 8, $, W, K);
    }
    function Bo() {
      this.ba = new Xe(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Ge(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function $a() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Ua() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Kl() {
      this.ua = 0, this.Wa = new U(), this.vb = new U(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new _(), this.yc = new A();
    }
    function Jc() {
      this.xb = this.a = 0, this.l = new ls(), this.ca = new Xe(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N(), this.Pb = 0, this.wd = new N(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Kl(), this.ab = 0, this.gc = o(4, Ua), this.Oc = 0;
    }
    function jo() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new ls(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Qs(c, g, S, L, D, $, W) {
      for (c = c == null ? 0 : c[g + 0], g = 0; g < W; ++g) D[$ + g] = c + S[L + g] & 255, c = D[$ + g];
    }
    function Wa(c, g, S, L, D, $, W) {
      var K;
      if (c == null) Qs(null, null, S, L, D, $, W);
      else for (K = 0; K < W; ++K) D[$ + K] = c[g + K] + S[L + K] & 255;
    }
    function gs(c, g, S, L, D, $, W) {
      if (c == null) Qs(null, null, S, L, D, $, W);
      else {
        var K, J = c[g + 0], it = J, yt = J;
        for (K = 0; K < W; ++K) it = yt + (J = c[g + K]) - it, yt = S[L + K] + (-256 & it ? 0 > it ? 0 : 255 : it) & 255, it = J, D[$ + K] = yt;
      }
    }
    function Ha(c, g, S, L) {
      var D = g.width, $ = g.o;
      if (t(c != null && g != null), 0 > S || 0 >= L || S + L > $) return null;
      if (!c.Cc) {
        if (c.ga == null) {
          var W;
          if (c.ga = new jo(), (W = c.ga == null) || (W = g.width * g.o, t(c.Gb.length == 0), c.Gb = s(W), c.Uc = 0, c.Gb == null ? W = 0 : (c.mb = c.Gb, c.nb = c.Uc, c.rc = null, W = 1), W = !W), !W) {
            W = c.ga;
            var K = c.Fa, J = c.P, it = c.qc, yt = c.mb, Lt = c.nb, It = J + 1, Nt = it - 1, Wt = W.l;
            if (t(K != null && yt != null && g != null), xs[0] = null, xs[1] = Qs, xs[2] = Wa, xs[3] = gs, W.ca = yt, W.tb = Lt, W.c = g.width, W.i = g.height, t(0 < W.c && 0 < W.i), 1 >= it) g = 0;
            else if (W.$a = K[J + 0] >> 0 & 3, W.Z = K[J + 0] >> 2 & 3, W.Lc = K[J + 0] >> 4 & 3, J = K[J + 0] >> 6 & 3, 0 > W.$a || 1 < W.$a || 4 <= W.Z || 1 < W.Lc || J) g = 0;
            else if (Wt.put = Ni, Wt.ac = pn, Wt.bc = Bi, Wt.ma = W, Wt.width = g.width, Wt.height = g.height, Wt.Da = g.Da, Wt.v = g.v, Wt.va = g.va, Wt.j = g.j, Wt.o = g.o, W.$a) t: {
              t(W.$a == 1), g = yi();
              e: for (; ; ) {
                if (g == null) {
                  g = 0;
                  break t;
                }
                if (t(W != null), W.mc = g, g.c = W.c, g.i = W.i, g.l = W.l, g.l.ma = W, g.l.width = W.c, g.l.height = W.i, g.a = 0, Q(g.m, K, It, Nt), !tr(W.c, W.i, 1, g, null) || (g.ab == 1 && g.gc[0].hc == 3 && Qi(g.s) ? (W.ic = 1, K = g.c * g.i, g.Ta = null, g.Ua = 0, g.V = s(K), g.Ba = 0, g.V == null ? (g.a = 1, g = 0) : g = 1) : (W.ic = 0, g = Dr(g, W.c)), !g)) break e;
                g = 1;
                break t;
              }
              W.mc = null, g = 0;
            }
            else g = Nt >= W.c * W.i;
            W = !g;
          }
          if (W) return null;
          c.ga.Lc != 1 ? c.Ga = 0 : L = $ - S;
        }
        t(c.ga != null), t(S + L <= $);
        t: {
          if (g = (K = c.ga).c, $ = K.l.o, K.$a == 0) {
            if (It = c.rc, Nt = c.Vc, Wt = c.Fa, J = c.P + 1 + S * g, it = c.mb, yt = c.nb + S * g, t(J <= c.P + c.qc), K.Z != 0) for (t(xs[K.Z] != null), W = 0; W < L; ++W) xs[K.Z](It, Nt, Wt, J, it, yt, g), It = it, Nt = yt, yt += g, J += g;
            else for (W = 0; W < L; ++W) i(it, yt, Wt, J, g), It = it, Nt = yt, yt += g, J += g;
            c.rc = It, c.Vc = Nt;
          } else {
            if (t(K.mc != null), g = S + L, t((W = K.mc) != null), t(g <= W.i), W.C >= g) g = 1;
            else if (K.ic || Ct(), K.ic) {
              K = W.V, It = W.Ba, Nt = W.c;
              var Tt = W.i, bt = (Wt = 1, J = W.$ / Nt, it = W.$ % Nt, yt = W.m, Lt = W.s, W.$), St = Nt * Tt, $t = Nt * g, Gt = Lt.wc, Ut = bt < $t ? yn(Lt, it, J) : null;
              t(bt <= St), t(g <= Tt), t(Qi(Lt));
              e: for (; ; ) {
                for (; !yt.h && bt < $t; ) {
                  if (it & Gt || (Ut = yn(Lt, it, J)), t(Ut != null), st(yt), 256 > (Tt = Qn(Ut.G[0], Ut.H[0], yt))) K[It + bt] = Tt, ++bt, ++it >= Nt && (it = 0, ++J <= g && !(J % 16) && mi(W, J));
                  else {
                    if (!(280 > Tt)) {
                      Wt = 0;
                      break e;
                    }
                    Tt = gi(Tt - 256, yt);
                    var fe, se = Qn(Ut.G[4], Ut.H[4], yt);
                    if (st(yt), !(bt >= (se = ji(Nt, se = gi(se, yt))) && St - bt >= Tt)) {
                      Wt = 0;
                      break e;
                    }
                    for (fe = 0; fe < Tt; ++fe) K[It + bt + fe] = K[It + bt + fe - se];
                    for (bt += Tt, it += Tt; it >= Nt; ) it -= Nt, ++J <= g && !(J % 16) && mi(W, J);
                    bt < $t && it & Gt && (Ut = yn(Lt, it, J));
                  }
                  t(yt.h == G(yt));
                }
                mi(W, J > g ? g : J);
                break e;
              }
              !Wt || yt.h && bt < St ? (Wt = 0, W.a = yt.h ? 5 : 3) : W.$ = bt, g = Wt;
            } else g = Pi(W, W.V, W.Ba, W.c, W.i, g, Br);
            if (!g) {
              L = 0;
              break t;
            }
          }
          S + L >= $ && (c.Cc = 1), L = 1;
        }
        if (!L) return null;
        if (c.Cc && ((L = c.ga) != null && (L.mc = null), c.ga = null, 0 < c.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return c.nb + S * D;
    }
    function w(c, g, S, L, D, $) {
      for (; 0 < D--; ) {
        var W, K = c, J = g + (S ? 1 : 0), it = c, yt = g + (S ? 0 : 3);
        for (W = 0; W < L; ++W) {
          var Lt = it[yt + 4 * W];
          Lt != 255 && (Lt *= 32897, K[J + 4 * W + 0] = K[J + 4 * W + 0] * Lt >> 23, K[J + 4 * W + 1] = K[J + 4 * W + 1] * Lt >> 23, K[J + 4 * W + 2] = K[J + 4 * W + 2] * Lt >> 23);
        }
        g += $;
      }
    }
    function B(c, g, S, L, D) {
      for (; 0 < L--; ) {
        var $;
        for ($ = 0; $ < S; ++$) {
          var W = c[g + 2 * $ + 0], K = 15 & (it = c[g + 2 * $ + 1]), J = 4369 * K, it = (240 & it | it >> 4) * J >> 16;
          c[g + 2 * $ + 0] = (240 & W | W >> 4) * J >> 16 & 240 | (15 & W | W << 4) * J >> 16 >> 4 & 15, c[g + 2 * $ + 1] = 240 & it | K;
        }
        g += D;
      }
    }
    function ut(c, g, S, L, D, $, W, K) {
      var J, it, yt = 255;
      for (it = 0; it < D; ++it) {
        for (J = 0; J < L; ++J) {
          var Lt = c[g + J];
          $[W + 4 * J] = Lt, yt &= Lt;
        }
        g += S, W += K;
      }
      return yt != 255;
    }
    function gt(c, g, S, L, D) {
      var $;
      for ($ = 0; $ < D; ++$) S[L + $] = c[g + $] >> 8;
    }
    function Ct() {
      Hi = w, cn = B, hn = ut, Cn = gt;
    }
    function Mt(c, g, S) {
      F[c] = function(L, D, $, W, K, J, it, yt, Lt, It, Nt, Wt, Tt, bt, St, $t, Gt) {
        var Ut, fe = Gt - 1 >> 1, se = K[J + 0] | it[yt + 0] << 16, Se = Lt[It + 0] | Nt[Wt + 0] << 16;
        t(L != null);
        var oe = 3 * se + Se + 131074 >> 2;
        for (g(L[D + 0], 255 & oe, oe >> 16, Tt, bt), $ != null && (oe = 3 * Se + se + 131074 >> 2, g($[W + 0], 255 & oe, oe >> 16, St, $t)), Ut = 1; Ut <= fe; ++Ut) {
          var Je = K[J + Ut] | it[yt + Ut] << 16, tn = Lt[It + Ut] | Nt[Wt + Ut] << 16, Ue = se + Je + Se + tn + 524296, qe = Ue + 2 * (Je + Se) >> 3;
          oe = qe + se >> 1, se = (Ue = Ue + 2 * (se + tn) >> 3) + Je >> 1, g(L[D + 2 * Ut - 1], 255 & oe, oe >> 16, Tt, bt + (2 * Ut - 1) * S), g(L[D + 2 * Ut - 0], 255 & se, se >> 16, Tt, bt + (2 * Ut - 0) * S), $ != null && (oe = Ue + Se >> 1, se = qe + tn >> 1, g($[W + 2 * Ut - 1], 255 & oe, oe >> 16, St, $t + (2 * Ut - 1) * S), g($[W + 2 * Ut + 0], 255 & se, se >> 16, St, $t + (2 * Ut + 0) * S)), se = Je, Se = tn;
        }
        1 & Gt || (oe = 3 * se + Se + 131074 >> 2, g(L[D + Gt - 1], 255 & oe, oe >> 16, Tt, bt + (Gt - 1) * S), $ != null && (oe = 3 * Se + se + 131074 >> 2, g($[W + Gt - 1], 255 & oe, oe >> 16, St, $t + (Gt - 1) * S)));
      };
    }
    function Zt() {
      Vi[iu] = t2, Vi[ru] = Kd, Vi[Wd] = e2, Vi[su] = Xd, Vi[ou] = Jd, Vi[th] = Zd, Vi[Hd] = n2, Vi[eh] = Kd, Vi[nh] = Xd, Vi[au] = Jd, Vi[ih] = Zd;
    }
    function he(c) {
      return c & ~i2 ? 0 > c ? 0 : 255 : c >> Qd;
    }
    function xe(c, g) {
      return he((19077 * c >> 8) + (26149 * g >> 8) - 14234);
    }
    function Me(c, g, S) {
      return he((19077 * c >> 8) - (6419 * g >> 8) - (13320 * S >> 8) + 8708);
    }
    function Te(c, g) {
      return he((19077 * c >> 8) + (33050 * g >> 8) - 17685);
    }
    function $e(c, g, S, L, D) {
      L[D + 0] = xe(c, S), L[D + 1] = Me(c, g, S), L[D + 2] = Te(c, g);
    }
    function vn(c, g, S, L, D) {
      L[D + 0] = Te(c, g), L[D + 1] = Me(c, g, S), L[D + 2] = xe(c, S);
    }
    function _n(c, g, S, L, D) {
      var $ = Me(c, g, S);
      g = $ << 3 & 224 | Te(c, g) >> 3, L[D + 0] = 248 & xe(c, S) | $ >> 5, L[D + 1] = g;
    }
    function Fn(c, g, S, L, D) {
      var $ = 240 & Te(c, g) | 15;
      L[D + 0] = 240 & xe(c, S) | Me(c, g, S) >> 4, L[D + 1] = $;
    }
    function ei(c, g, S, L, D) {
      L[D + 0] = 255, $e(c, g, S, L, D + 1);
    }
    function zn(c, g, S, L, D) {
      vn(c, g, S, L, D), L[D + 3] = 255;
    }
    function ir(c, g, S, L, D) {
      $e(c, g, S, L, D), L[D + 3] = 255;
    }
    function Ii(c, g) {
      return 0 > c ? 0 : c > g ? g : c;
    }
    function _r(c, g, S) {
      F[c] = function(L, D, $, W, K, J, it, yt, Lt) {
        for (var It = yt + (-2 & Lt) * S; yt != It; ) g(L[D + 0], $[W + 0], K[J + 0], it, yt), g(L[D + 1], $[W + 0], K[J + 0], it, yt + S), D += 2, ++W, ++J, yt += 2 * S;
        1 & Lt && g(L[D + 0], $[W + 0], K[J + 0], it, yt);
      };
    }
    function Xl(c, g, S) {
      return S == 0 ? c == 0 ? g == 0 ? 6 : 5 : g == 0 ? 4 : 0 : S;
    }
    function Ga(c, g, S, L, D) {
      switch (c >>> 30) {
        case 3:
          Gr(g, S, L, D, 0);
          break;
        case 2:
          Nn(g, S, L, D);
          break;
        case 1:
          hi(g, S, L, D);
      }
    }
    function Va(c, g) {
      var S, L, D = g.M, $ = g.Nb, W = c.oc, K = c.pc + 40, J = c.oc, it = c.pc + 584, yt = c.oc, Lt = c.pc + 600;
      for (S = 0; 16 > S; ++S) W[K + 32 * S - 1] = 129;
      for (S = 0; 8 > S; ++S) J[it + 32 * S - 1] = 129, yt[Lt + 32 * S - 1] = 129;
      for (0 < D ? W[K - 1 - 32] = J[it - 1 - 32] = yt[Lt - 1 - 32] = 129 : (r(W, K - 32 - 1, 127, 21), r(J, it - 32 - 1, 127, 9), r(yt, Lt - 32 - 1, 127, 9)), L = 0; L < c.za; ++L) {
        var It = g.ya[g.aa + L];
        if (0 < L) {
          for (S = -1; 16 > S; ++S) i(W, K + 32 * S - 4, W, K + 32 * S + 12, 4);
          for (S = -1; 8 > S; ++S) i(J, it + 32 * S - 4, J, it + 32 * S + 4, 4), i(yt, Lt + 32 * S - 4, yt, Lt + 32 * S + 4, 4);
        }
        var Nt = c.Gd, Wt = c.Hd + L, Tt = It.ad, bt = It.Hc;
        if (0 < D && (i(W, K - 32, Nt[Wt].y, 0, 16), i(J, it - 32, Nt[Wt].f, 0, 8), i(yt, Lt - 32, Nt[Wt].ea, 0, 8)), It.Za) {
          var St = W, $t = K - 32 + 16;
          for (0 < D && (L >= c.za - 1 ? r(St, $t, Nt[Wt].y[15], 4) : i(St, $t, Nt[Wt + 1].y, 0, 4)), S = 0; 4 > S; S++) St[$t + 128 + S] = St[$t + 256 + S] = St[$t + 384 + S] = St[$t + 0 + S];
          for (S = 0; 16 > S; ++S, bt <<= 2) St = W, $t = K + ep[S], rr[It.Ob[S]](St, $t), Ga(bt, Tt, 16 * +S, St, $t);
        } else if (St = Xl(L, D, It.Ob[0]), ws[St](W, K), bt != 0) for (S = 0; 16 > S; ++S, bt <<= 2) Ga(bt, Tt, 16 * +S, W, K + ep[S]);
        for (S = It.Gc, St = Xl(L, D, It.Dd), Yr[St](J, it), Yr[St](yt, Lt), bt = Tt, St = J, $t = it, 255 & (It = S >> 0) && (170 & It ? Za(bt, 256, St, $t) : Ui(bt, 256, St, $t)), It = yt, bt = Lt, 255 & (S >>= 8) && (170 & S ? Za(Tt, 320, It, bt) : Ui(Tt, 320, It, bt)), D < c.Ub - 1 && (i(Nt[Wt].y, 0, W, K + 480, 16), i(Nt[Wt].f, 0, J, it + 224, 8), i(Nt[Wt].ea, 0, yt, Lt + 224, 8)), S = 8 * $ * c.B, Nt = c.sa, Wt = c.ta + 16 * L + 16 * $ * c.R, Tt = c.qa, It = c.ra + 8 * L + S, bt = c.Ha, St = c.Ia + 8 * L + S, S = 0; 16 > S; ++S) i(Nt, Wt + S * c.R, W, K + 32 * S, 16);
        for (S = 0; 8 > S; ++S) i(Tt, It + S * c.B, J, it + 32 * S, 8), i(bt, St + S * c.B, yt, Lt + 32 * S, 8);
      }
    }
    function qo(c, g, S, L, D, $, W, K, J) {
      var it = [0], yt = [0], Lt = 0, It = J != null ? J.kd : 0, Nt = J ?? new $a();
      if (c == null || 12 > S) return 7;
      Nt.data = c, Nt.w = g, Nt.ha = S, g = [g], S = [S], Nt.gb = [Nt.gb];
      t: {
        var Wt = g, Tt = S, bt = Nt.gb;
        if (t(c != null), t(Tt != null), t(bt != null), bt[0] = 0, 12 <= Tt[0] && !e(c, Wt[0], "RIFF")) {
          if (e(c, Wt[0] + 8, "WEBP")) {
            bt = 3;
            break t;
          }
          var St = Xt(c, Wt[0] + 4);
          if (12 > St || 4294967286 < St) {
            bt = 3;
            break t;
          }
          if (It && St > Tt[0] - 8) {
            bt = 7;
            break t;
          }
          bt[0] = St, Wt[0] += 12, Tt[0] -= 12;
        }
        bt = 0;
      }
      if (bt != 0) return bt;
      for (St = 0 < Nt.gb[0], S = S[0]; ; ) {
        t: {
          var $t = c;
          Tt = g, bt = S;
          var Gt = it, Ut = yt, fe = Wt = [0];
          if ((oe = Lt = [Lt])[0] = 0, 8 > bt[0]) bt = 7;
          else {
            if (!e($t, Tt[0], "VP8X")) {
              if (Xt($t, Tt[0] + 4) != 10) {
                bt = 3;
                break t;
              }
              if (18 > bt[0]) {
                bt = 7;
                break t;
              }
              var se = Xt($t, Tt[0] + 8), Se = 1 + te($t, Tt[0] + 12);
              if (2147483648 <= Se * ($t = 1 + te($t, Tt[0] + 15))) {
                bt = 3;
                break t;
              }
              fe != null && (fe[0] = se), Gt != null && (Gt[0] = Se), Ut != null && (Ut[0] = $t), Tt[0] += 18, bt[0] -= 18, oe[0] = 1;
            }
            bt = 0;
          }
        }
        if (Lt = Lt[0], Wt = Wt[0], bt != 0) return bt;
        if (Tt = !!(2 & Wt), !St && Lt) return 3;
        if ($ != null && ($[0] = !!(16 & Wt)), W != null && (W[0] = Tt), K != null && (K[0] = 0), W = it[0], Wt = yt[0], Lt && Tt && J == null) {
          bt = 0;
          break;
        }
        if (4 > S) {
          bt = 7;
          break;
        }
        if (St && Lt || !St && !Lt && !e(c, g[0], "ALPH")) {
          S = [S], Nt.na = [Nt.na], Nt.P = [Nt.P], Nt.Sa = [Nt.Sa];
          t: {
            se = c, bt = g, St = S;
            var oe = Nt.gb;
            Gt = Nt.na, Ut = Nt.P, fe = Nt.Sa, Se = 22, t(se != null), t(St != null), $t = bt[0];
            var Je = St[0];
            for (t(Gt != null), t(fe != null), Gt[0] = null, Ut[0] = null, fe[0] = 0; ; ) {
              if (bt[0] = $t, St[0] = Je, 8 > Je) {
                bt = 7;
                break t;
              }
              var tn = Xt(se, $t + 4);
              if (4294967286 < tn) {
                bt = 3;
                break t;
              }
              var Ue = 8 + tn + 1 & -2;
              if (Se += Ue, 0 < oe && Se > oe) {
                bt = 3;
                break t;
              }
              if (!e(se, $t, "VP8 ") || !e(se, $t, "VP8L")) {
                bt = 0;
                break t;
              }
              if (Je[0] < Ue) {
                bt = 7;
                break t;
              }
              e(se, $t, "ALPH") || (Gt[0] = se, Ut[0] = $t + 8, fe[0] = tn), $t += Ue, Je -= Ue;
            }
          }
          if (S = S[0], Nt.na = Nt.na[0], Nt.P = Nt.P[0], Nt.Sa = Nt.Sa[0], bt != 0) break;
        }
        S = [S], Nt.Ja = [Nt.Ja], Nt.xa = [Nt.xa];
        t: if (oe = c, bt = g, St = S, Gt = Nt.gb[0], Ut = Nt.Ja, fe = Nt.xa, se = bt[0], $t = !e(oe, se, "VP8 "), Se = !e(oe, se, "VP8L"), t(oe != null), t(St != null), t(Ut != null), t(fe != null), 8 > St[0]) bt = 7;
        else {
          if ($t || Se) {
            if (oe = Xt(oe, se + 4), 12 <= Gt && oe > Gt - 12) {
              bt = 3;
              break t;
            }
            if (It && oe > St[0] - 8) {
              bt = 7;
              break t;
            }
            Ut[0] = oe, bt[0] += 8, St[0] -= 8, fe[0] = Se;
          } else fe[0] = 5 <= St[0] && oe[se + 0] == 47 && !(oe[se + 4] >> 5), Ut[0] = St[0];
          bt = 0;
        }
        if (S = S[0], Nt.Ja = Nt.Ja[0], Nt.xa = Nt.xa[0], g = g[0], bt != 0) break;
        if (4294967286 < Nt.Ja) return 3;
        if (K == null || Tt || (K[0] = Nt.xa ? 2 : 1), W = [W], Wt = [Wt], Nt.xa) {
          if (5 > S) {
            bt = 7;
            break;
          }
          K = W, It = Wt, Tt = $, c == null || 5 > S ? c = 0 : 5 <= S && c[g + 0] == 47 && !(c[g + 4] >> 5) ? (St = [0], oe = [0], Gt = [0], Q(Ut = new N(), c, g, S), me(Ut, St, oe, Gt) ? (K != null && (K[0] = St[0]), It != null && (It[0] = oe[0]), Tt != null && (Tt[0] = Gt[0]), c = 1) : c = 0) : c = 0;
        } else {
          if (10 > S) {
            bt = 7;
            break;
          }
          K = Wt, c == null || 10 > S || !Ws(c, g + 3, S - 3) ? c = 0 : (It = c[g + 0] | c[g + 1] << 8 | c[g + 2] << 16, Tt = 16383 & (c[g + 7] << 8 | c[g + 6]), c = 16383 & (c[g + 9] << 8 | c[g + 8]), 1 & It || 3 < (It >> 1 & 7) || !(It >> 4 & 1) || It >> 5 >= Nt.Ja || !Tt || !c ? c = 0 : (W && (W[0] = Tt), K && (K[0] = c), c = 1));
        }
        if (!c || (W = W[0], Wt = Wt[0], Lt && (it[0] != W || yt[0] != Wt))) return 3;
        J != null && (J[0] = Nt, J.offset = g - J.w, t(4294967286 > g - J.w), t(J.offset == J.ha - S));
        break;
      }
      return bt == 0 || bt == 7 && Lt && J == null ? ($ != null && ($[0] |= Nt.na != null && 0 < Nt.na.length), L != null && (L[0] = W), D != null && (D[0] = Wt), 0) : bt;
    }
    function Ya(c, g, S) {
      var L = g.width, D = g.height, $ = 0, W = 0, K = L, J = D;
      if (g.Da = c != null && 0 < c.Da, g.Da && (K = c.cd, J = c.bd, $ = c.v, W = c.j, 11 > S || ($ &= -2, W &= -2), 0 > $ || 0 > W || 0 >= K || 0 >= J || $ + K > L || W + J > D)) return 0;
      if (g.v = $, g.j = W, g.va = $ + K, g.o = W + J, g.U = K, g.T = J, g.da = c != null && 0 < c.da, g.da) {
        if (!et(K, J, S = [c.ib], $ = [c.hb])) return 0;
        g.ib = S[0], g.hb = $[0];
      }
      return g.ob = c != null && c.ob, g.Kb = c == null || !c.Sd, g.da && (g.ob = g.ib < 3 * L / 4 && g.hb < 3 * D / 4, g.Kb = 0), 1;
    }
    function Ka(c) {
      if (c == null) return 2;
      if (11 > c.S) {
        var g = c.f.RGBA;
        g.fb += (c.height - 1) * g.A, g.A = -g.A;
      } else g = c.f.kb, c = c.height, g.O += (c - 1) * g.fa, g.fa = -g.fa, g.N += (c - 1 >> 1) * g.Ab, g.Ab = -g.Ab, g.W += (c - 1 >> 1) * g.Db, g.Db = -g.Db, g.F != null && (g.J += (c - 1) * g.lb, g.lb = -g.lb);
      return 0;
    }
    function zo(c, g, S, L) {
      if (L == null || 0 >= c || 0 >= g) return 2;
      if (S != null) {
        if (S.Da) {
          var D = S.cd, $ = S.bd, W = -2 & S.v, K = -2 & S.j;
          if (0 > W || 0 > K || 0 >= D || 0 >= $ || W + D > c || K + $ > g) return 2;
          c = D, g = $;
        }
        if (S.da) {
          if (!et(c, g, D = [S.ib], $ = [S.hb])) return 2;
          c = D[0], g = $[0];
        }
      }
      L.width = c, L.height = g;
      t: {
        var J = L.width, it = L.height;
        if (c = L.S, 0 >= J || 0 >= it || !(c >= iu && 13 > c)) c = 2;
        else {
          if (0 >= L.Rd && L.sd == null) {
            W = $ = D = g = 0;
            var yt = (K = J * np[c]) * it;
            if (11 > c || ($ = (it + 1) / 2 * (g = (J + 1) / 2), c == 12 && (W = (D = J) * it)), (it = s(yt + 2 * $ + W)) == null) {
              c = 1;
              break t;
            }
            L.sd = it, 11 > c ? ((J = L.f.RGBA).eb = it, J.fb = 0, J.A = K, J.size = yt) : ((J = L.f.kb).y = it, J.O = 0, J.fa = K, J.Fd = yt, J.f = it, J.N = 0 + yt, J.Ab = g, J.Cd = $, J.ea = it, J.W = 0 + yt + $, J.Db = g, J.Ed = $, c == 12 && (J.F = it, J.J = 0 + yt + 2 * $), J.Tc = W, J.lb = D);
          }
          if (g = 1, D = L.S, $ = L.width, W = L.height, D >= iu && 13 > D) if (11 > D) c = L.f.RGBA, g &= (K = Math.abs(c.A)) * (W - 1) + $ <= c.size, g &= K >= $ * np[D], g &= c.eb != null;
          else {
            c = L.f.kb, K = ($ + 1) / 2, yt = (W + 1) / 2, J = Math.abs(c.fa), it = Math.abs(c.Ab);
            var Lt = Math.abs(c.Db), It = Math.abs(c.lb), Nt = It * (W - 1) + $;
            g &= J * (W - 1) + $ <= c.Fd, g &= it * (yt - 1) + K <= c.Cd, g = (g &= Lt * (yt - 1) + K <= c.Ed) & J >= $ & it >= K & Lt >= K, g &= c.y != null, g &= c.f != null, g &= c.ea != null, D == 12 && (g &= It >= $, g &= Nt <= c.Tc, g &= c.F != null);
          }
          else g = 0;
          c = g ? 0 : 2;
        }
      }
      return c != 0 || S != null && S.fd && (c = Ka(L)), c;
    }
    var Vn = 64, $o = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Uo = 24, Wo = 32, Xa = 8, bi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    wt("Predictor0", "PredictorAdd0"), F.Predictor0 = function() {
      return 4278190080;
    }, F.Predictor1 = function(c) {
      return c;
    }, F.Predictor2 = function(c, g, S) {
      return g[S + 0];
    }, F.Predictor3 = function(c, g, S) {
      return g[S + 1];
    }, F.Predictor4 = function(c, g, S) {
      return g[S - 1];
    }, F.Predictor5 = function(c, g, S) {
      return dt(dt(c, g[S + 1]), g[S + 0]);
    }, F.Predictor6 = function(c, g, S) {
      return dt(c, g[S - 1]);
    }, F.Predictor7 = function(c, g, S) {
      return dt(c, g[S + 0]);
    }, F.Predictor8 = function(c, g, S) {
      return dt(g[S - 1], g[S + 0]);
    }, F.Predictor9 = function(c, g, S) {
      return dt(g[S + 0], g[S + 1]);
    }, F.Predictor10 = function(c, g, S) {
      return dt(dt(c, g[S - 1]), dt(g[S + 0], g[S + 1]));
    }, F.Predictor11 = function(c, g, S) {
      var L = g[S + 0];
      return 0 >= Ft(L >> 24 & 255, c >> 24 & 255, (g = g[S - 1]) >> 24 & 255) + Ft(L >> 16 & 255, c >> 16 & 255, g >> 16 & 255) + Ft(L >> 8 & 255, c >> 8 & 255, g >> 8 & 255) + Ft(255 & L, 255 & c, 255 & g) ? L : c;
    }, F.Predictor12 = function(c, g, S) {
      var L = g[S + 0];
      return (Pt((c >> 24 & 255) + (L >> 24 & 255) - ((g = g[S - 1]) >> 24 & 255)) << 24 | Pt((c >> 16 & 255) + (L >> 16 & 255) - (g >> 16 & 255)) << 16 | Pt((c >> 8 & 255) + (L >> 8 & 255) - (g >> 8 & 255)) << 8 | Pt((255 & c) + (255 & L) - (255 & g))) >>> 0;
    }, F.Predictor13 = function(c, g, S) {
      var L = g[S - 1];
      return (qt((c = dt(c, g[S + 0])) >> 24 & 255, L >> 24 & 255) << 24 | qt(c >> 16 & 255, L >> 16 & 255) << 16 | qt(c >> 8 & 255, L >> 8 & 255) << 8 | qt(c >> 0 & 255, L >> 0 & 255)) >>> 0;
    };
    var Zc = F.PredictorAdd0;
    F.PredictorAdd1 = Vt, wt("Predictor2", "PredictorAdd2"), wt("Predictor3", "PredictorAdd3"), wt("Predictor4", "PredictorAdd4"), wt("Predictor5", "PredictorAdd5"), wt("Predictor6", "PredictorAdd6"), wt("Predictor7", "PredictorAdd7"), wt("Predictor8", "PredictorAdd8"), wt("Predictor9", "PredictorAdd9"), wt("Predictor10", "PredictorAdd10"), wt("Predictor11", "PredictorAdd11"), wt("Predictor12", "PredictorAdd12"), wt("Predictor13", "PredictorAdd13");
    var Ja = F.PredictorAdd2;
    we("ColorIndexInverseTransform", "MapARGB", "32b", function(c) {
      return c >> 8 & 255;
    }, function(c) {
      return c;
    }), we("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(c) {
      return c;
    }, function(c) {
      return c >> 8 & 255;
    });
    var Jl, $i = F.ColorIndexInverseTransform, Ho = F.MapARGB, Zl = F.VP8LColorIndexInverseTransformAlpha, Ql = F.MapAlpha, ms = F.VP8LPredictorsAdd = [];
    ms.length = 16, (F.VP8LPredictors = []).length = 16, (F.VP8LPredictorsAdd_C = []).length = 16, (F.VP8LPredictors_C = []).length = 16;
    var to, vi, ci, ys, Wr, Hr, Go, Gr, Nn, Za, hi, Ui, Vo, tu, Qa, eo, no, bs, io, Yo, ro, vs, tl, Wi, Hi, cn, hn, Cn, Bn = s(511), Vr = s(2041), el = s(225), Ko = s(767), eu = 0, Qc = Vr, nu = el, Ei = Ko, Gi = Bn, iu = 0, ru = 1, Wd = 2, su = 3, ou = 4, th = 5, Hd = 6, eh = 7, nh = 8, au = 9, ih = 10, qm = [2, 3, 7], zm = [3, 3, 11], Gd = [280, 256, 256, 256, 40], $m = [0, 1, 1, 1, 0], Um = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Wm = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Hm = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Gm = 8, rh = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], sh = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], nl = null, Vm = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Ym = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Vd = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Km = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Xm = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Jm = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Zm = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], ws = [], rr = [], Yr = [], Qm = 1, Yd = 2, xs = [], Vi = [];
    Mt("UpsampleRgbLinePair", $e, 3), Mt("UpsampleBgrLinePair", vn, 3), Mt("UpsampleRgbaLinePair", ir, 4), Mt("UpsampleBgraLinePair", zn, 4), Mt("UpsampleArgbLinePair", ei, 4), Mt("UpsampleRgba4444LinePair", Fn, 2), Mt("UpsampleRgb565LinePair", _n, 2);
    var t2 = F.UpsampleRgbLinePair, e2 = F.UpsampleBgrLinePair, Kd = F.UpsampleRgbaLinePair, Xd = F.UpsampleBgraLinePair, Jd = F.UpsampleArgbLinePair, Zd = F.UpsampleRgba4444LinePair, n2 = F.UpsampleRgb565LinePair, lu = 16, uu = 1 << lu - 1, il = -227, oh = 482, Qd = 6, i2 = (256 << Qd) - 1, tp = 0, r2 = s(256), s2 = s(256), o2 = s(256), a2 = s(256), l2 = s(oh - il), u2 = s(oh - il);
    _r("YuvToRgbRow", $e, 3), _r("YuvToBgrRow", vn, 3), _r("YuvToRgbaRow", ir, 4), _r("YuvToBgraRow", zn, 4), _r("YuvToArgbRow", ei, 4), _r("YuvToRgba4444Row", Fn, 2), _r("YuvToRgb565Row", _n, 2);
    var ep = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], cu = [0, 2, 8], c2 = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], h2 = 1;
    this.WebPDecodeRGBA = function(c, g, S, L, D) {
      var $ = ru, W = new Bo(), K = new Xe();
      W.ba = K, K.S = $, K.width = [K.width], K.height = [K.height];
      var J = K.width, it = K.height, yt = new xn();
      if (yt == null || c == null) var Lt = 2;
      else t(yt != null), Lt = qo(c, g, S, yt.width, yt.height, yt.Pd, yt.Qd, yt.format, null);
      if (Lt != 0 ? J = 0 : (J != null && (J[0] = yt.width[0]), it != null && (it[0] = yt.height[0]), J = 1), J) {
        K.width = K.width[0], K.height = K.height[0], L != null && (L[0] = K.width), D != null && (D[0] = K.height);
        t: {
          if (L = new ls(), (D = new $a()).data = c, D.w = g, D.ha = S, D.kd = 1, g = [0], t(D != null), ((c = qo(D.data, D.w, D.ha, null, null, null, g, null, D)) == 0 || c == 7) && g[0] && (c = 4), (g = c) == 0) {
            if (t(W != null), L.data = D.data, L.w = D.w + D.offset, L.ha = D.ha - D.offset, L.put = Ni, L.ac = pn, L.bc = Bi, L.ma = W, D.xa) {
              if ((c = yi()) == null) {
                W = 1;
                break t;
              }
              if (function(It, Nt) {
                var Wt = [0], Tt = [0], bt = [0];
                e: for (; ; ) {
                  if (It == null) return 0;
                  if (Nt == null) return It.a = 2, 0;
                  if (It.l = Nt, It.a = 0, Q(It.m, Nt.data, Nt.w, Nt.ha), !me(It.m, Wt, Tt, bt)) {
                    It.a = 3;
                    break e;
                  }
                  if (It.xb = Yd, Nt.width = Wt[0], Nt.height = Tt[0], !tr(Wt[0], Tt[0], 1, It, null)) break e;
                  return 1;
                }
                return t(It.a != 0), 0;
              }(c, L)) {
                if (L = (g = zo(L.width, L.height, W.Oa, W.ba)) == 0) {
                  e: {
                    L = c;
                    n: for (; ; ) {
                      if (L == null) {
                        L = 0;
                        break e;
                      }
                      if (t(L.s.yc != null), t(L.s.Ya != null), t(0 < L.s.Wb), t((S = L.l) != null), t((D = S.ma) != null), L.xb != 0) {
                        if (L.ca = D.ba, L.tb = D.tb, t(L.ca != null), !Ya(D.Oa, S, su)) {
                          L.a = 2;
                          break n;
                        }
                        if (!Dr(L, S.width) || S.da) break n;
                        if ((S.da || Jt(L.ca.S)) && Ct(), 11 > L.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), L.ca.f.kb.F != null && Ct()), L.Pb && 0 < L.s.ua && L.s.vb.X == null && !E(L.s.vb, L.s.Wa.Xa)) {
                          L.a = 1;
                          break n;
                        }
                        L.xb = 0;
                      }
                      if (!Pi(L, L.V, L.Ba, L.c, L.i, S.o, ss)) break n;
                      D.Dc = L.Ma, L = 1;
                      break e;
                    }
                    t(L.a != 0), L = 0;
                  }
                  L = !L;
                }
                L && (g = c.a);
              } else g = c.a;
            } else {
              if ((c = new Oa()) == null) {
                W = 1;
                break t;
              }
              if (c.Fa = D.na, c.P = D.P, c.qc = D.Sa, Fo(c, L)) {
                if ((g = zo(L.width, L.height, W.Oa, W.ba)) == 0) {
                  if (c.Aa = 0, S = W.Oa, t((D = c) != null), S != null) {
                    if (0 < (J = 0 > (J = S.Md) ? 0 : 100 < J ? 255 : 255 * J / 100)) {
                      for (it = yt = 0; 4 > it; ++it) 12 > (Lt = D.pb[it]).lc && (Lt.ia = J * c2[0 > Lt.lc ? 0 : Lt.lc] >> 3), yt |= Lt.ia;
                      yt && (alert("todo:VP8InitRandom"), D.ia = 1);
                    }
                    D.Ga = S.Id, 100 < D.Ga ? D.Ga = 100 : 0 > D.Ga && (D.Ga = 0);
                  }
                  Ta(c, L) || (g = c.a);
                }
              } else g = c.a;
            }
            g == 0 && W.Oa != null && W.Oa.fd && (g = Ka(W.ba));
          }
          W = g;
        }
        $ = W != 0 ? null : 11 > $ ? K.f.RGBA.eb : K.f.kb.y;
      } else $ = null;
      return $;
    };
    var np = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function h(F, M) {
    for (var j = "", P = 0; P < 4; P++) j += String.fromCharCode(F[M++]);
    return j;
  }
  function u(F, M) {
    return (F[M + 0] << 0 | F[M + 1] << 8 | F[M + 2] << 16) >>> 0;
  }
  function d(F, M) {
    return (F[M + 0] << 0 | F[M + 1] << 8 | F[M + 2] << 16 | F[M + 3] << 24) >>> 0;
  }
  new l();
  var p = [0], f = [0], m = [], b = new l(), x = n, y = function(F, M) {
    var j = {}, P = 0, A = !1, T = 0, _ = 0;
    if (j.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(z, G, Y, st) {
      for (var vt = 0; vt < st; vt++) if (z[G + vt] != Y.charCodeAt(vt)) return !0;
      return !1;
    }(F, M, "RIFF", 4)) {
      var Z, V;
      for (d(F, M += 4), M += 8; M < F.length; ) {
        var R = h(F, M), Q = d(F, M += 4);
        M += 4;
        var H = Q + (1 & Q);
        switch (R) {
          case "VP8 ":
          case "VP8L":
            j.frames[P] === void 0 && (j.frames[P] = {}), (N = j.frames[P]).src_off = A ? _ : M - 8, N.src_size = T + Q + 8, P++, A && (A = !1, T = 0, _ = 0);
            break;
          case "VP8X":
            (N = j.header = {}).feature_flags = F[M];
            var ct = M + 4;
            N.canvas_width = 1 + u(F, ct), ct += 3, N.canvas_height = 1 + u(F, ct), ct += 3;
            break;
          case "ALPH":
            A = !0, T = H + 8, _ = M - 8;
            break;
          case "ANIM":
            (N = j.header).bgcolor = d(F, M), ct = M + 4, N.loop_count = (Z = F)[(V = ct) + 0] << 0 | Z[V + 1] << 8, ct += 2;
            break;
          case "ANMF":
            var nt, N;
            (N = j.frames[P] = {}).offset_x = 2 * u(F, M), M += 3, N.offset_y = 2 * u(F, M), M += 3, N.width = 1 + u(F, M), M += 3, N.height = 1 + u(F, M), M += 3, N.duration = u(F, M), M += 3, nt = F[M++], N.dispose = 1 & nt, N.blend = nt >> 1 & 1;
        }
        R != "ANMF" && (M += H);
      }
      return j;
    }
  }(x, 0);
  y.response = x, y.rgbaoutput = !0, y.dataurl = !1;
  var v = y.header ? y.header : null, k = y.frames ? y.frames : null;
  if (v) {
    v.loop_counter = v.loop_count, p = [v.canvas_height], f = [v.canvas_width];
    for (var C = 0; C < k.length && k[C].blend != 0; C++) ;
  }
  var I = k[0], q = b.WebPDecodeRGBA(x, I.src_off, I.src_size, f, p);
  I.rgba = q, I.imgwidth = f[0], I.imgheight = p[0];
  for (var O = 0; O < f[0] * p[0] * 4; O++) m[O] = q[O];
  return this.width = f, this.height = p, this.data = m, this;
}
(function(n) {
  var t = function() {
    return typeof hf == "function";
  }, e = function(p, f, m, b) {
    var x = 4, y = o;
    switch (b) {
      case n.image_compression.FAST:
        x = 1, y = s;
        break;
      case n.image_compression.MEDIUM:
        x = 6, y = a;
        break;
      case n.image_compression.SLOW:
        x = 9, y = l;
    }
    p = i(p, f, m, y);
    var v = hf(p, { level: x });
    return n.__addimage__.arrayBufferToBinaryString(v);
  }, i = function(p, f, m, b) {
    for (var x, y, v, k = p.length / f, C = new Uint8Array(p.length + k), I = u(), q = 0; q < k; q += 1) {
      if (v = q * f, x = p.subarray(v, v + f), b) C.set(b(x, m, y), v + q);
      else {
        for (var O, F = I.length, M = []; O < F; O += 1) M[O] = I[O](x, m, y);
        var j = d(M.concat());
        C.set(M[j], v + q);
      }
      y = x;
    }
    return C;
  }, r = function(p) {
    var f = Array.apply([], p);
    return f.unshift(0), f;
  }, s = function(p, f) {
    var m, b = [], x = p.length;
    b[0] = 1;
    for (var y = 0; y < x; y += 1) m = p[y - f] || 0, b[y + 1] = p[y] - m + 256 & 255;
    return b;
  }, o = function(p, f, m) {
    var b, x = [], y = p.length;
    x[0] = 2;
    for (var v = 0; v < y; v += 1) b = m && m[v] || 0, x[v + 1] = p[v] - b + 256 & 255;
    return x;
  }, a = function(p, f, m) {
    var b, x, y = [], v = p.length;
    y[0] = 3;
    for (var k = 0; k < v; k += 1) b = p[k - f] || 0, x = m && m[k] || 0, y[k + 1] = p[k] + 256 - (b + x >>> 1) & 255;
    return y;
  }, l = function(p, f, m) {
    var b, x, y, v, k = [], C = p.length;
    k[0] = 4;
    for (var I = 0; I < C; I += 1) b = p[I - f] || 0, x = m && m[I] || 0, y = m && m[I - f] || 0, v = h(b, x, y), k[I + 1] = p[I] - v + 256 & 255;
    return k;
  }, h = function(p, f, m) {
    if (p === f && f === m) return p;
    var b = Math.abs(f - m), x = Math.abs(p - m), y = Math.abs(p + f - m - m);
    return b <= x && b <= y ? p : x <= y ? f : m;
  }, u = function() {
    return [r, s, o, a, l];
  }, d = function(p) {
    var f = p.map(function(m) {
      return m.reduce(function(b, x) {
        return b + Math.abs(x);
      }, 0);
    });
    return f.indexOf(Math.min.apply(null, f));
  };
  n.processPNG = function(p, f, m, b) {
    var x, y, v, k, C, I, q, O, F, M, j, P, A, T, _, Z = this.decode.FLATE_DECODE, V = "";
    if (this.__addimage__.isArrayBuffer(p) && (p = new Uint8Array(p)), this.__addimage__.isArrayBufferView(p)) {
      if (p = (v = new Mv(p)).imgData, y = v.bits, x = v.colorSpace, C = v.colors, [4, 6].indexOf(v.colorType) !== -1) {
        if (v.bits === 8) {
          F = (O = v.pixelBitlength == 32 ? new Uint32Array(v.decodePixels().buffer) : v.pixelBitlength == 16 ? new Uint16Array(v.decodePixels().buffer) : new Uint8Array(v.decodePixels().buffer)).length, j = new Uint8Array(F * v.colors), M = new Uint8Array(F);
          var R, Q = v.pixelBitlength - v.bits;
          for (T = 0, _ = 0; T < F; T++) {
            for (A = O[T], R = 0; R < Q; ) j[_++] = A >>> R & 255, R += v.bits;
            M[T] = A >>> R & 255;
          }
        }
        if (v.bits === 16) {
          F = (O = new Uint32Array(v.decodePixels().buffer)).length, j = new Uint8Array(F * (32 / v.pixelBitlength) * v.colors), M = new Uint8Array(F * (32 / v.pixelBitlength)), P = v.colors > 1, T = 0, _ = 0;
          for (var H = 0; T < F; ) A = O[T++], j[_++] = A >>> 0 & 255, P && (j[_++] = A >>> 16 & 255, A = O[T++], j[_++] = A >>> 0 & 255), M[H++] = A >>> 16 & 255;
          y = 8;
        }
        b !== n.image_compression.NONE && t() ? (p = e(j, v.width * v.colors, v.colors, b), q = e(M, v.width, 1, b)) : (p = j, q = M, Z = void 0);
      }
      if (v.colorType === 3 && (x = this.color_spaces.INDEXED, I = v.palette, v.transparency.indexed)) {
        var ct = v.transparency.indexed, nt = 0;
        for (T = 0, F = ct.length; T < F; ++T) nt += ct[T];
        if ((nt /= 255) === F - 1 && ct.indexOf(0) !== -1) k = [ct.indexOf(0)];
        else if (nt !== F) {
          for (O = v.decodePixels(), M = new Uint8Array(O.length), T = 0, F = O.length; T < F; T++) M[T] = ct[O[T]];
          q = e(M, v.width, 1);
        }
      }
      var N = function(z) {
        var G;
        switch (z) {
          case n.image_compression.FAST:
            G = 11;
            break;
          case n.image_compression.MEDIUM:
            G = 13;
            break;
          case n.image_compression.SLOW:
            G = 14;
            break;
          default:
            G = 12;
        }
        return G;
      }(b);
      return Z === this.decode.FLATE_DECODE && (V = "/Predictor " + N + " "), V += "/Colors " + C + " /BitsPerComponent " + y + " /Columns " + v.width, (this.__addimage__.isArrayBuffer(p) || this.__addimage__.isArrayBufferView(p)) && (p = this.__addimage__.arrayBufferToBinaryString(p)), (q && this.__addimage__.isArrayBuffer(q) || this.__addimage__.isArrayBufferView(q)) && (q = this.__addimage__.arrayBufferToBinaryString(q)), { alias: m, data: p, index: f, filter: Z, decodeParameters: V, transparency: k, palette: I, sMask: q, predictor: N, width: v.width, height: v.height, bitsPerComponent: y, colorSpace: x };
    }
  };
})(ke.API), function(n) {
  n.processGIF89A = function(t, e, i, r) {
    var s = new Rv(t), o = s.width, a = s.height, l = [];
    s.decodeAndBlitFrameRGBA(0, l);
    var h = { data: l, width: o, height: a }, u = new Ih(100).encode(h, 100);
    return n.processJPEG.call(this, u, e, i, r);
  }, n.processGIF87A = n.processGIF89A;
}(ke.API), ar.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var t = 0; t < n; t++) {
      var e = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[t] = { red: r, green: i, blue: e, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, ar.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, t = this.width * this.height * 4;
    this.data = new Uint8Array(t), this[n]();
  } catch (e) {
    ln.log("bit decode error:" + e);
  }
}, ar.prototype.bit1 = function() {
  var n, t = Math.ceil(this.width / 8), e = t % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, r = 0; r < t; r++) for (var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 8 * r * 4, a = 0; a < 8 && 8 * r + a < this.width; a++) {
      var l = this.palette[s >> 7 - a & 1];
      this.data[o + 4 * a] = l.blue, this.data[o + 4 * a + 1] = l.green, this.data[o + 4 * a + 2] = l.red, this.data[o + 4 * a + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, ar.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), t = n % 4, e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < n; r++) {
      var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 2 * r * 4, a = s >> 4, l = 15 & s, h = this.palette[a];
      if (this.data[o] = h.blue, this.data[o + 1] = h.green, this.data[o + 2] = h.red, this.data[o + 3] = 255, 2 * r + 1 >= this.width) break;
      h = this.palette[l], this.data[o + 4] = h.blue, this.data[o + 4 + 1] = h.green, this.data[o + 4 + 2] = h.red, this.data[o + 4 + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, ar.prototype.bit8 = function() {
  for (var n = this.width % 4, t = this.height - 1; t >= 0; t--) {
    for (var e = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var r = this.datav.getUint8(this.pos++, !0), s = e * this.width * 4 + 4 * i;
      if (r < this.palette.length) {
        var o = this.palette[r];
        this.data[s] = o.red, this.data[s + 1] = o.green, this.data[s + 2] = o.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, ar.prototype.bit15 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (s & t) / t * 255 | 0, a = (s >> 5 & t) / t * 255 | 0, l = (s >> 10 & t) / t * 255 | 0, h = s >> 15 ? 255 : 0, u = i * this.width * 4 + 4 * r;
      this.data[u] = l, this.data[u + 1] = a, this.data[u + 2] = o, this.data[u + 3] = h;
    }
    this.pos += n;
  }
}, ar.prototype.bit16 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, s = 0; s < this.width; s++) {
      var o = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (o & t) / t * 255 | 0, l = (o >> 5 & e) / e * 255 | 0, h = (o >> 11) / t * 255 | 0, u = r * this.width * 4 + 4 * s;
      this.data[u] = h, this.data[u + 1] = l, this.data[u + 2] = a, this.data[u + 3] = 255;
    }
    this.pos += n;
  }
}, ar.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = t * this.width * 4 + 4 * e;
      this.data[o] = s, this.data[o + 1] = r, this.data[o + 2] = i, this.data[o + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ar.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--) for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
    var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), a = t * this.width * 4 + 4 * e;
    this.data[a] = s, this.data[a + 1] = r, this.data[a + 2] = i, this.data[a + 3] = o;
  }
}, ar.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processBMP = function(t, e, i, r) {
    var s = new ar(t, !1), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Ih(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(ke.API), lg.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processWEBP = function(t, e, i, r) {
    var s = new lg(t), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Ih(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(ke.API), ke.API.processRGBA = function(n, t, e) {
  for (var i = n.data, r = i.length, s = new Uint8Array(r / 4 * 3), o = new Uint8Array(r / 4), a = 0, l = 0, h = 0; h < r; h += 4) {
    var u = i[h], d = i[h + 1], p = i[h + 2], f = i[h + 3];
    s[a++] = u, s[a++] = d, s[a++] = p, o[l++] = f;
  }
  var m = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o), data: m, index: t, alias: e, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, ke.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, ea = ke.API, Lu = ea.getCharWidthsArray = function(n, t) {
  var e, i, r = (t = t || {}).font || this.internal.getFont(), s = t.fontSize || this.internal.getFontSize(), o = t.charSpace || this.internal.getCharSpace(), a = t.widths ? t.widths : r.metadata.Unicode.widths, l = a.fof ? a.fof : 1, h = t.kerning ? t.kerning : r.metadata.Unicode.kerning, u = h.fof ? h.fof : 1, d = t.doKerning !== !1, p = 0, f = n.length, m = 0, b = a[0] || l, x = [];
  for (e = 0; e < f; e++) i = n.charCodeAt(e), typeof r.metadata.widthOfString == "function" ? x.push((r.metadata.widthOfGlyph(r.metadata.characterToGlyph(i)) + o * (1e3 / s) || 0) / 1e3) : (p = d && nn(h[i]) === "object" && !isNaN(parseInt(h[i][m], 10)) ? h[i][m] / u : 0, x.push((a[i] || b) / l + p)), m = i;
  return x;
}, rg = ea.getStringUnitWidth = function(n, t) {
  var e = (t = t || {}).fontSize || this.internal.getFontSize(), i = t.font || this.internal.getFont(), r = t.charSpace || this.internal.getCharSpace();
  return ea.processArabic && (n = ea.processArabic(n)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(n, e, r) / e : Lu.apply(this, arguments).reduce(function(s, o) {
    return s + o;
  }, 0);
}, sg = function(n, t, e, i) {
  for (var r = [], s = 0, o = n.length, a = 0; s !== o && a + t[s] < e; ) a += t[s], s++;
  r.push(n.slice(0, s));
  var l = s;
  for (a = 0; s !== o; ) a + t[s] > i && (r.push(n.slice(l, s)), a = 0, l = s), a += t[s], s++;
  return l !== s && r.push(n.slice(l, s)), r;
}, og = function(n, t, e) {
  e || (e = {});
  var i, r, s, o, a, l, h, u = [], d = [u], p = e.textIndent || 0, f = 0, m = 0, b = n.split(" "), x = Lu.apply(this, [" ", e])[0];
  if (l = e.lineIndent === -1 ? b[0].length + 2 : e.lineIndent || 0) {
    var y = Array(l).join(" "), v = [];
    b.map(function(C) {
      (C = C.split(/\s*\n/)).length > 1 ? v = v.concat(C.map(function(I, q) {
        return (q && I.length ? `
` : "") + I;
      })) : v.push(C[0]);
    }), b = v, l = rg.apply(this, [y, e]);
  }
  for (s = 0, o = b.length; s < o; s++) {
    var k = 0;
    if (i = b[s], l && i[0] == `
` && (i = i.substr(1), k = 1), p + f + (m = (r = Lu.apply(this, [i, e])).reduce(function(C, I) {
      return C + I;
    }, 0)) > t || k) {
      if (m > t) {
        for (a = sg.apply(this, [i, r, t - (p + f), t]), u.push(a.shift()), u = [a.pop()]; a.length; ) d.push([a.shift()]);
        m = r.slice(i.length - (u[0] ? u[0].length : 0)).reduce(function(C, I) {
          return C + I;
        }, 0);
      } else u = [i];
      d.push(u), p = m + l, f = x;
    } else u.push(i), p += f + m, f = x;
  }
  return h = l ? function(C, I) {
    return (I ? y : "") + C.join(" ");
  } : function(C) {
    return C.join(" ");
  }, d.map(h);
}, ea.splitTextToSize = function(n, t, e) {
  var i, r = (e = e || {}).fontSize || this.internal.getFontSize(), s = (function(u) {
    if (u.widths && u.kerning) return { widths: u.widths, kerning: u.kerning };
    var d = this.internal.getFont(u.fontName, u.fontStyle);
    return d.metadata.Unicode ? { widths: d.metadata.Unicode.widths || { 0: 1 }, kerning: d.metadata.Unicode.kerning || {} } : { font: d.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, e);
  i = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var o = 1 * this.internal.scaleFactor * t / r;
  s.textIndent = e.textIndent ? 1 * e.textIndent * this.internal.scaleFactor / r : 0, s.lineIndent = e.lineIndent;
  var a, l, h = [];
  for (a = 0, l = i.length; a < l; a++) h = h.concat(og.apply(this, [i[a], o, s]));
  return h;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var t = "klmnopqrstuvwxyz", e = {}, i = {}, r = 0; r < t.length; r++) e[t[r]] = "0123456789abcdef"[r], i["0123456789abcdef"[r]] = t[r];
  var s = function(d) {
    return "0x" + parseInt(d, 10).toString(16);
  }, o = n.__fontmetrics__.compress = function(d) {
    var p, f, m, b, x = ["{"];
    for (var y in d) {
      if (p = d[y], isNaN(parseInt(y, 10)) ? f = "'" + y + "'" : (y = parseInt(y, 10), f = (f = s(y).slice(2)).slice(0, -1) + i[f.slice(-1)]), typeof p == "number") p < 0 ? (m = s(p).slice(3), b = "-") : (m = s(p).slice(2), b = ""), m = b + m.slice(0, -1) + i[m.slice(-1)];
      else {
        if (nn(p) !== "object") throw new Error("Don't know what to do with value type " + nn(p) + ".");
        m = o(p);
      }
      x.push(f + m);
    }
    return x.push("}"), x.join("");
  }, a = n.__fontmetrics__.uncompress = function(d) {
    if (typeof d != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var p, f, m, b, x = {}, y = 1, v = x, k = [], C = "", I = "", q = d.length - 1, O = 1; O < q; O += 1) (b = d[O]) == "'" ? p ? (m = p.join(""), p = void 0) : p = [] : p ? p.push(b) : b == "{" ? (k.push([v, m]), v = {}, m = void 0) : b == "}" ? ((f = k.pop())[0][f[1]] = v, m = void 0, v = f[0]) : b == "-" ? y = -1 : m === void 0 ? e.hasOwnProperty(b) ? (C += e[b], m = parseInt(C, 16) * y, y = 1, C = "") : C += b : e.hasOwnProperty(b) ? (I += e[b], v[m] = parseInt(I, 16) * y, y = 1, m = void 0, I = "") : I += b;
    return x;
  }, l = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: a("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h = { Unicode: { Courier: l, "Courier-Bold": l, "Courier-BoldOblique": l, "Courier-Oblique": l, Helvetica: l, "Helvetica-Bold": l, "Helvetica-BoldOblique": l, "Helvetica-Oblique": l, "Times-Roman": l, "Times-Bold": l, "Times-BoldItalic": l, "Times-Italic": l } }, u = { Unicode: { "Courier-Oblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": a("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": a("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: a("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: a("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": a("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": a("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(d) {
    var p = d.font, f = u.Unicode[p.postScriptName];
    f && (p.metadata.Unicode = {}, p.metadata.Unicode.widths = f.widths, p.metadata.Unicode.kerning = f.kerning);
    var m = h.Unicode[p.postScriptName];
    m && (p.metadata.Unicode.encoding = m, p.encoding = m.codePages[0]);
  }]);
}(ke.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    for (var i = e.length, r = new Uint8Array(i), s = 0; s < i; s++) r[s] = e.charCodeAt(s);
    return r;
  };
  n.API.events.push(["addFont", function(e) {
    var i = void 0, r = e.font, s = e.instance;
    if (!r.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      if (typeof (i = s.existsFileInVFS(r.postScriptName) === !1 ? s.loadFile(r.postScriptName) : s.getFileFromVFS(r.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      (function(o, a) {
        a = /^\x00\x01\x00\x00/.test(a) ? t(a) : t(Sl(a)), o.metadata = n.API.TTFFont.open(a), o.metadata.Unicode = o.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, o.metadata.glyIdsUsed = [0];
      })(r, i);
    }
  }]);
}(ke), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  function t() {
    return (Le.canvg ? Promise.resolve(Le.canvg) : import("./index.es-DxnvCuNb.js")).catch(function(e) {
      return Promise.reject(new Error("Could not load canvg: " + e));
    }).then(function(e) {
      return e.default ? e.default : e;
    });
  }
  ke.API.addSvgAsImage = function(e, i, r, s, o, a, l, h) {
    if (isNaN(i) || isNaN(r)) throw ln.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(o)) throw ln.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var u = document.createElement("canvas");
    u.width = s, u.height = o;
    var d = u.getContext("2d");
    d.fillStyle = "#fff", d.fillRect(0, 0, u.width, u.height);
    var p = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, f = this;
    return t().then(function(m) {
      return m.fromString(d, e, p);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(m) {
      return m.render(p);
    }).then(function() {
      f.addImage(u.toDataURL("image/jpeg", 1), i, r, s, o, l, h);
    });
  };
}(), ke.API.putTotalPages = function(n) {
  var t, e = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (t = new RegExp(n, "g"), e = this.internal.getNumberOfPages()) : (t = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), e = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++) for (var r = 0; r < this.internal.pages[i].length; r++) this.internal.pages[i][r] = this.internal.pages[i][r].replace(t, e);
  return this;
}, ke.API.viewerPreferences = function(n, t) {
  var e;
  n = n || {}, t = t || !1;
  var i, r, s, o = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, a = Object.keys(o), l = [], h = 0, u = 0, d = 0;
  function p(m, b) {
    var x, y = !1;
    for (x = 0; x < m.length; x += 1) m[x] === b && (y = !0);
    return y;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(o)), this.internal.viewerpreferences.isSubscribed = !1), e = this.internal.viewerpreferences.configuration, n === "reset" || t === !0) {
    var f = a.length;
    for (d = 0; d < f; d += 1) e[a[d]].value = e[a[d]].defaultValue, e[a[d]].explicitSet = !1;
  }
  if (nn(n) === "object") {
    for (r in n) if (s = n[r], p(a, r) && s !== void 0) {
      if (e[r].type === "boolean" && typeof s == "boolean") e[r].value = s;
      else if (e[r].type === "name" && p(e[r].valueSet, s)) e[r].value = s;
      else if (e[r].type === "integer" && Number.isInteger(s)) e[r].value = s;
      else if (e[r].type === "array") {
        for (h = 0; h < s.length; h += 1) if (i = !0, s[h].length === 1 && typeof s[h][0] == "number") l.push(String(s[h] - 1));
        else if (s[h].length > 1) {
          for (u = 0; u < s[h].length; u += 1) typeof s[h][u] != "number" && (i = !1);
          i === !0 && l.push([s[h][0] - 1, s[h][1] - 1].join(" "));
        }
        e[r].value = "[" + l.join(" ") + "]";
      } else e[r].value = e[r].defaultValue;
      e[r].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var m, b = [];
    for (m in e) e[m].explicitSet === !0 && (e[m].type === "name" ? b.push("/" + m + " /" + e[m].value) : b.push("/" + m + " " + e[m].value));
    b.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + b.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = e, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  var t = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', r = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(i)), o = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), a = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), l = unescape(encodeURIComponent("</x:xmpmeta>")), h = s.length + o.length + a.length + r.length + l.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + h + " >>"), this.internal.write("stream"), this.internal.write(r + s + o + a + l), this.internal.write("endstream"), this.internal.write("endobj");
  }, e = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(i, r) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", e), this.internal.events.subscribe("postPutResources", t)), this;
  };
}(ke.API), function(n) {
  var t = n.API, e = t.pdfEscape16 = function(s, o) {
    for (var a, l = o.metadata.Unicode.widths, h = ["", "0", "00", "000", "0000"], u = [""], d = 0, p = s.length; d < p; ++d) {
      if (a = o.metadata.characterToGlyph(s.charCodeAt(d)), o.metadata.glyIdsUsed.push(a), o.metadata.toUnicode[a] = s.charCodeAt(d), l.indexOf(a) == -1 && (l.push(a), l.push([parseInt(o.metadata.widthOfGlyph(a), 10)])), a == "0") return u.join("");
      a = a.toString(16), u.push(h[4 - a.length], a);
    }
    return u.join("");
  }, i = function(s) {
    var o, a, l, h, u, d, p;
    for (u = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, l = [], d = 0, p = (a = Object.keys(s).sort(function(f, m) {
      return f - m;
    })).length; d < p; d++) o = a[d], l.length >= 100 && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar`, l = []), s[o] !== void 0 && s[o] !== null && typeof s[o].toString == "function" && (h = ("0000" + s[o].toString(16)).slice(-4), o = ("0000" + (+o).toString(16)).slice(-4), l.push("<" + o + "><" + h + ">"));
    return l.length && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar
`), u += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "Identity-H") {
        for (var d = a.metadata.Unicode.widths, p = a.metadata.subset.encode(a.metadata.glyIdsUsed, 1), f = "", m = 0; m < p.length; m++) f += String.fromCharCode(p[m]);
        var b = h();
        u({ data: f, addLength1: !0, objectId: b }), l("endobj");
        var x = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: x }), l("endobj");
        var y = h();
        l("<<"), l("/Type /FontDescriptor"), l("/FontName /" + ha(a.fontName)), l("/FontFile2 " + b + " 0 R"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/Flags " + a.metadata.flags), l("/StemV " + a.metadata.stemV), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l(">>"), l("endobj");
        var v = h();
        l("<<"), l("/Type /Font"), l("/BaseFont /" + ha(a.fontName)), l("/FontDescriptor " + y + " 0 R"), l("/W " + n.API.PDFObject.convert(d)), l("/CIDToGIDMap /Identity"), l("/DW 1000"), l("/Subtype /CIDFontType2"), l("/CIDSystemInfo"), l("<<"), l("/Supplement 0"), l("/Registry (Adobe)"), l("/Ordering (" + a.encoding + ")"), l(">>"), l(">>"), l("endobj"), a.objectNumber = h(), l("<<"), l("/Type /Font"), l("/Subtype /Type0"), l("/ToUnicode " + x + " 0 R"), l("/BaseFont /" + ha(a.fontName)), l("/Encoding /" + a.encoding), l("/DescendantFonts [" + v + " 0 R]"), l(">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]), t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "WinAnsiEncoding") {
        for (var d = a.metadata.rawData, p = "", f = 0; f < d.length; f++) p += String.fromCharCode(d[f]);
        var m = h();
        u({ data: p, addLength1: !0, objectId: m }), l("endobj");
        var b = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: b }), l("endobj");
        var x = h();
        l("<<"), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l("/StemV " + a.metadata.stemV), l("/Type /FontDescriptor"), l("/FontFile2 " + m + " 0 R"), l("/Flags 96"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/FontName /" + ha(a.fontName)), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l(">>"), l("endobj"), a.objectNumber = h();
        for (var y = 0; y < a.metadata.hmtx.widths.length; y++) a.metadata.hmtx.widths[y] = parseInt(a.metadata.hmtx.widths[y] * (1e3 / a.metadata.head.unitsPerEm));
        l("<</Subtype/TrueType/Type/Font/ToUnicode " + b + " 0 R/BaseFont/" + ha(a.fontName) + "/FontDescriptor " + x + " 0 R/Encoding/" + a.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(a.metadata.hmtx.widths) + ">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var r = function(s) {
    var o, a = s.text || "", l = s.x, h = s.y, u = s.options || {}, d = s.mutex || {}, p = d.pdfEscape, f = d.activeFontKey, m = d.fonts, b = f, x = "", y = 0, v = "", k = m[b].encoding;
    if (m[b].encoding !== "Identity-H") return { text: a, x: l, y: h, options: u, mutex: d };
    for (v = a, b = f, Array.isArray(a) && (v = a[0]), y = 0; y < v.length; y += 1) m[b].metadata.hasOwnProperty("cmap") && (o = m[b].metadata.cmap.unicode.codeMap[v[y].charCodeAt(0)]), o || v[y].charCodeAt(0) < 256 && m[b].metadata.hasOwnProperty("Unicode") ? x += v[y] : x += "";
    var C = "";
    return parseInt(b.slice(1)) < 14 || k === "WinAnsiEncoding" ? C = p(x, b).split("").map(function(I) {
      return I.charCodeAt(0).toString(16);
    }).join("") : k === "Identity-H" && (C = e(x, m[b])), d.isHex = !0, { text: C, x: l, y: h, options: u, mutex: d };
  };
  t.events.push(["postProcessText", function(s) {
    var o = s.text || "", a = [], l = { text: o, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(o)) {
      var h = 0;
      for (h = 0; h < o.length; h += 1) Array.isArray(o[h]) && o[h].length === 3 ? a.push([r(Object.assign({}, l, { text: o[h][0] })).text, o[h][1], o[h][2]]) : a.push(r(Object.assign({}, l, { text: o[h] })).text);
      s.text = a;
    } else s.text = r(Object.assign({}, l, { text: o })).text;
  }]);
}(ke), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0;
  }, n.addFileToVFS = function(e, i) {
    return t.call(this), this.internal.vFS[e] = i, this;
  }, n.getFileFromVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0 ? this.internal.vFS[e] : null;
  };
}(ke.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(i) {
    var r, s, o, a, l, h, u, d = t, p = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], f = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], m = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, b = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, x = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], y = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), v = !1, k = 0;
    this.__bidiEngine__ = {};
    var C = function(P) {
      var A = P.charCodeAt(), T = A >> 8, _ = b[T];
      return _ !== void 0 ? d[256 * _ + (255 & A)] : T === 252 || T === 253 ? "AL" : y.test(T) ? "L" : T === 8 ? "R" : "N";
    }, I = function(P) {
      for (var A, T = 0; T < P.length; T++) {
        if ((A = C(P.charAt(T))) === "L") return !1;
        if (A === "R") return !0;
      }
      return !1;
    }, q = function(P, A, T, _) {
      var Z, V, R, Q, H = A[_];
      switch (H) {
        case "L":
        case "R":
          v = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          v && (H = "AN");
          break;
        case "AL":
          v = !0, H = "R";
          break;
        case "WS":
          H = "N";
          break;
        case "CS":
          _ < 1 || _ + 1 >= A.length || (Z = T[_ - 1]) !== "EN" && Z !== "AN" || (V = A[_ + 1]) !== "EN" && V !== "AN" ? H = "N" : v && (V = "AN"), H = V === Z ? V : "N";
          break;
        case "ES":
          H = (Z = _ > 0 ? T[_ - 1] : "B") === "EN" && _ + 1 < A.length && A[_ + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (_ > 0 && T[_ - 1] === "EN") {
            H = "EN";
            break;
          }
          if (v) {
            H = "N";
            break;
          }
          for (R = _ + 1, Q = A.length; R < Q && A[R] === "ET"; ) R++;
          H = R < Q && A[R] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (o && !a) {
            for (Q = A.length, R = _ + 1; R < Q && A[R] === "NSM"; ) R++;
            if (R < Q) {
              var ct = P[_], nt = ct >= 1425 && ct <= 2303 || ct === 64286;
              if (Z = A[R], nt && (Z === "R" || Z === "AL")) {
                H = "R";
                break;
              }
            }
          }
          H = _ < 1 || (Z = A[_ - 1]) === "B" ? "N" : T[_ - 1];
          break;
        case "B":
          v = !1, r = !0, H = k;
          break;
        case "S":
          s = !0, H = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          v = !1;
          break;
        case "BN":
          H = "N";
      }
      return H;
    }, O = function(P, A, T) {
      var _ = P.split("");
      return T && F(_, T, { hiLevel: k }), _.reverse(), A && A.reverse(), _.join("");
    }, F = function(P, A, T) {
      var _, Z, V, R, Q, H = -1, ct = P.length, nt = 0, N = [], z = k ? f : p, G = [];
      for (v = !1, r = !1, s = !1, Z = 0; Z < ct; Z++) G[Z] = C(P[Z]);
      for (V = 0; V < ct; V++) {
        if (Q = nt, N[V] = q(P, G, N, V), _ = 240 & (nt = z[Q][m[N[V]]]), nt &= 15, A[V] = R = z[nt][5], _ > 0) if (_ === 16) {
          for (Z = H; Z < V; Z++) A[Z] = 1;
          H = -1;
        } else H = -1;
        if (z[nt][6]) H === -1 && (H = V);
        else if (H > -1) {
          for (Z = H; Z < V; Z++) A[Z] = R;
          H = -1;
        }
        G[V] === "B" && (A[V] = 0), T.hiLevel |= R;
      }
      s && function(Y, st, vt) {
        for (var mt = 0; mt < vt; mt++) if (Y[mt] === "S") {
          st[mt] = k;
          for (var _t = mt - 1; _t >= 0 && Y[_t] === "WS"; _t--) st[_t] = k;
        }
      }(G, A, ct);
    }, M = function(P, A, T, _, Z) {
      if (!(Z.hiLevel < P)) {
        if (P === 1 && k === 1 && !r) return A.reverse(), void (T && T.reverse());
        for (var V, R, Q, H, ct = A.length, nt = 0; nt < ct; ) {
          if (_[nt] >= P) {
            for (Q = nt + 1; Q < ct && _[Q] >= P; ) Q++;
            for (H = nt, R = Q - 1; H < R; H++, R--) V = A[H], A[H] = A[R], A[R] = V, T && (V = T[H], T[H] = T[R], T[R] = V);
            nt = Q;
          }
          nt++;
        }
      }
    }, j = function(P, A, T) {
      var _ = P.split(""), Z = { hiLevel: k };
      return T || (T = []), F(_, T, Z), function(V, R, Q) {
        if (Q.hiLevel !== 0 && u) for (var H, ct = 0; ct < V.length; ct++) R[ct] === 1 && (H = x.indexOf(V[ct])) >= 0 && (V[ct] = x[H + 1]);
      }(_, T, Z), M(2, _, A, T, Z), M(1, _, A, T, Z), _.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(P, A, T) {
      if (function(Z, V) {
        if (V) for (var R = 0; R < Z.length; R++) V[R] = R;
        a === void 0 && (a = I(Z)), h === void 0 && (h = I(Z));
      }(P, A), o || !l || h) if (o && l && a ^ h) k = a ? 1 : 0, P = O(P, A, T);
      else if (!o && l && h) k = a ? 1 : 0, P = j(P, A, T), P = O(P, A);
      else if (!o || a || l || h) {
        if (o && !l && a ^ h) P = O(P, A), a ? (k = 0, P = j(P, A, T)) : (k = 1, P = j(P, A, T), P = O(P, A));
        else if (o && a && !l && h) k = 1, P = j(P, A, T), P = O(P, A);
        else if (!o && !l && a ^ h) {
          var _ = u;
          a ? (k = 1, P = j(P, A, T), k = 0, u = !1, P = j(P, A, T), u = _) : (k = 0, P = j(P, A, T), P = O(P, A), k = 1, u = !1, P = j(P, A, T), u = _, P = O(P, A));
        }
      } else k = 0, P = j(P, A, T);
      else k = a ? 1 : 0, P = j(P, A, T);
      return P;
    }, this.__bidiEngine__.setOptions = function(P) {
      P && (o = P.isInputVisual, l = P.isOutputVisual, a = P.isInputRtl, h = P.isOutputRtl, u = P.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var t = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], e = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(i) {
    var r = i.text, s = (i.x, i.y, i.options || {}), o = (i.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, e.setOptions(s), Object.prototype.toString.call(r) === "[object Array]") {
      var a = 0;
      for (o = [], a = 0; a < r.length; a += 1) Object.prototype.toString.call(r[a]) === "[object Array]" ? o.push([e.doBidiReorder(r[a][0]), r[a][1], r[a][2]]) : o.push([e.doBidiReorder(r[a])]);
      i.text = o;
    } else i.text = e.doBidiReorder(r);
    e.setOptions({ isInputVisual: !0 });
  }]);
}(ke), ke.API.TTFFont = function() {
  function n(t) {
    var e;
    if (this.rawData = t, e = this.contents = new zs(t), this.contents.pos = 4, e.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Jv(this), this.registerTTF();
  }
  return n.open = function(t) {
    return new n(t);
  }, n.prototype.parse = function() {
    return this.directory = new Dv(this.contents), this.head = new jv(this), this.name = new Wv(this), this.cmap = new B1(this), this.toUnicode = {}, this.hhea = new qv(this), this.maxp = new Hv(this), this.hmtx = new Gv(this), this.post = new $v(this), this.os2 = new zv(this), this.loca = new Xv(this), this.glyf = new Vv(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var t, e, i, r, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var o, a, l, h;
      for (h = [], o = 0, a = (l = this.bbox).length; o < a; o++) t = l[o], h.push(Math.round(t * this.scaleFactor));
      return h;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (r = this.post.italic_angle), 32768 & (e = r >> 16) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(t) {
    var e;
    return ((e = this.cmap.unicode) != null ? e.codeMap[t] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(t) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * e;
  }, n.prototype.widthOfString = function(t, e, i) {
    var r, s, o, a;
    for (o = 0, s = 0, a = (t = "" + t).length; 0 <= a ? s < a : s > a; s = 0 <= a ? ++s : --s) r = t.charCodeAt(s), o += this.widthOfGlyph(this.characterToGlyph(r)) + i * (1e3 / e) || 0;
    return o * (e / 1e3);
  }, n.prototype.lineHeight = function(t, e) {
    var i;
    return e == null && (e = !1), i = e ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * t;
  }, n;
}();
var br, zs = function() {
  function n(t) {
    this.data = t ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(t) {
    return this.data[this.pos++] = t;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(t) {
    return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt32 = function() {
    var t;
    return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t;
  }, n.prototype.writeInt32 = function(t) {
    return t < 0 && (t += 4294967296), this.writeUInt32(t);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(t) {
    return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt16 = function() {
    var t;
    return (t = this.readUInt16()) >= 32768 ? t - 65536 : t;
  }, n.prototype.writeInt16 = function(t) {
    return t < 0 && (t += 65536), this.writeUInt16(t);
  }, n.prototype.readString = function(t) {
    var e, i;
    for (i = [], e = 0; 0 <= t ? e < t : e > t; e = 0 <= t ? ++e : --e) i[e] = String.fromCharCode(this.readByte());
    return i.join("");
  }, n.prototype.writeString = function(t) {
    var e, i, r;
    for (r = [], e = 0, i = t.length; 0 <= i ? e < i : e > i; e = 0 <= i ? ++e : --e) r.push(this.writeByte(t.charCodeAt(e)));
    return r;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(t) {
    return this.writeInt16(t);
  }, n.prototype.readLongLong = function() {
    var t, e, i, r, s, o, a, l;
    return t = this.readByte(), e = this.readByte(), i = this.readByte(), r = this.readByte(), s = this.readByte(), o = this.readByte(), a = this.readByte(), l = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ s) + 65536 * (255 ^ o) + 256 * (255 ^ a) + (255 ^ l) + 1) : 72057594037927940 * t + 281474976710656 * e + 1099511627776 * i + 4294967296 * r + 16777216 * s + 65536 * o + 256 * a + l;
  }, n.prototype.writeLongLong = function(t) {
    var e, i;
    return e = Math.floor(t / 4294967296), i = 4294967295 & t, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(t) {
    return this.writeInt32(t);
  }, n.prototype.read = function(t) {
    var e, i;
    for (e = [], i = 0; 0 <= t ? i < t : i > t; i = 0 <= t ? ++i : --i) e.push(this.readByte());
    return e;
  }, n.prototype.write = function(t) {
    var e, i, r, s;
    for (s = [], i = 0, r = t.length; i < r; i++) e = t[i], s.push(this.writeByte(e));
    return s;
  }, n;
}(), Dv = function() {
  var n;
  function t(e) {
    var i, r, s;
    for (this.scalarType = e.readInt(), this.tableCount = e.readShort(), this.searchRange = e.readShort(), this.entrySelector = e.readShort(), this.rangeShift = e.readShort(), this.tables = {}, r = 0, s = this.tableCount; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = { tag: e.readString(4), checksum: e.readInt(), offset: e.readInt(), length: e.readInt() }, this.tables[i.tag] = i;
  }
  return t.prototype.encode = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b;
    for (b in f = Object.keys(e).length, l = Math.log(2), d = 16 * Math.floor(Math.log(f) / l), o = Math.floor(d / l), u = 16 * f - d, (r = new zs()).writeInt(this.scalarType), r.writeShort(f), r.writeShort(d), r.writeShort(o), r.writeShort(u), s = 16 * f, h = r.pos + s, a = null, m = [], e) for (p = e[b], r.writeString(b), r.writeInt(n(p)), r.writeInt(h), r.writeInt(p.length), m = m.concat(p), b === "head" && (a = h), h += p.length; h % 4; ) m.push(0), h++;
    return r.write(m), i = 2981146554 - n(r.data), r.pos = a + 8, r.writeUInt32(i), r.data;
  }, n = function(e) {
    var i, r, s, o;
    for (e = j1.call(e); e.length % 4; ) e.push(0);
    for (s = new zs(e), r = 0, i = 0, o = e.length; i < o; i = i += 4) r += s.readUInt32();
    return 4294967295 & r;
  }, t;
}(), Bv = {}.hasOwnProperty, Rr = function(n, t) {
  for (var e in t) Bv.call(t, e) && (n[e] = t[e]);
  function i() {
    this.constructor = n;
  }
  return i.prototype = t.prototype, n.prototype = new i(), n.__super__ = t.prototype, n;
};
br = function() {
  function n(t) {
    var e;
    this.file = t, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var jv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "head", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.revision = e.readInt(), this.checkSumAdjustment = e.readInt(), this.magicNumber = e.readInt(), this.flags = e.readShort(), this.unitsPerEm = e.readShort(), this.created = e.readLongLong(), this.modified = e.readLongLong(), this.xMin = e.readShort(), this.yMin = e.readShort(), this.xMax = e.readShort(), this.yMax = e.readShort(), this.macStyle = e.readShort(), this.lowestRecPPEM = e.readShort(), this.fontDirectionHint = e.readShort(), this.indexToLocFormat = e.readShort(), this.glyphDataFormat = e.readShort();
  }, t.prototype.encode = function(e) {
    var i;
    return (i = new zs()).writeInt(this.version), i.writeInt(this.revision), i.writeInt(this.checkSumAdjustment), i.writeInt(this.magicNumber), i.writeShort(this.flags), i.writeShort(this.unitsPerEm), i.writeLongLong(this.created), i.writeLongLong(this.modified), i.writeShort(this.xMin), i.writeShort(this.yMin), i.writeShort(this.xMax), i.writeShort(this.yMax), i.writeShort(this.macStyle), i.writeShort(this.lowestRecPPEM), i.writeShort(this.fontDirectionHint), i.writeShort(e), i.writeShort(this.glyphDataFormat), i.data;
  }, t;
}(), ug = function() {
  function n(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b, x, y, v, k;
    switch (this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = e + t.readInt(), d = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (l = 0; l < 256; ++l) this.codeMap[l] = t.readByte();
        break;
      case 4:
        for (f = t.readUInt16(), p = f / 2, t.pos += 6, s = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), t.pos += 2, b = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), h = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), u = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), r = (this.length - t.pos + this.offset) / 2, a = function() {
          var C, I;
          for (I = [], l = C = 0; 0 <= r ? C < r : C > r; l = 0 <= r ? ++C : --C) I.push(t.readUInt16());
          return I;
        }(), l = y = 0, k = s.length; y < k; l = ++y) for (x = s[l], i = v = m = b[l]; m <= x ? v <= x : v >= x; i = m <= x ? ++v : --v) u[l] === 0 ? o = i + h[l] : (o = a[u[l] / 2 + (i - m) - (p - l)] || 0) !== 0 && (o += h[l]), this.codeMap[i] = 65535 & o;
    }
    t.pos = d;
  }
  return n.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b, x, y, v, k, C, I, q, O, F, M, j, P, A, T, _, Z, V, R, Q, H, ct, nt, N, z, G, Y, st, vt, mt, _t, Bt, Rt, te;
    switch (_ = new zs(), o = Object.keys(t).sort(function(Xt, E) {
      return Xt - E;
    }), e) {
      case "macroman":
        for (b = 0, x = function() {
          var Xt = [];
          for (m = 0; m < 256; ++m) Xt.push(0);
          return Xt;
        }(), v = { 0: 0 }, s = {}, Z = 0, H = o.length; Z < H; Z++) v[_t = t[r = o[Z]]] == null && (v[_t] = ++b), s[r] = { old: t[r], new: v[t[r]] }, x[r] = v[t[r]];
        return _.writeUInt16(1), _.writeUInt16(0), _.writeUInt32(12), _.writeUInt16(0), _.writeUInt16(262), _.writeUInt16(0), _.write(x), { charMap: s, subtable: _.data, maxGlyphID: b + 1 };
      case "unicode":
        for (A = [], d = [], k = 0, v = {}, i = {}, y = h = null, V = 0, ct = o.length; V < ct; V++) v[I = t[r = o[V]]] == null && (v[I] = ++k), i[r] = { old: I, new: v[I] }, a = v[I] - r, y != null && a === h || (y && d.push(y), A.push(r), h = a), y = r;
        for (y && d.push(y), d.push(65535), A.push(65535), j = 2 * (M = A.length), F = 2 * Math.pow(Math.log(M) / Math.LN2, 2), p = Math.log(F / 2) / Math.LN2, O = 2 * M - F, l = [], q = [], f = [], m = R = 0, nt = A.length; R < nt; m = ++R) {
          if (P = A[m], u = d[m], P === 65535) {
            l.push(0), q.push(0);
            break;
          }
          if (P - (T = i[P].new) >= 32768) for (l.push(0), q.push(2 * (f.length + M - m)), r = Q = P; P <= u ? Q <= u : Q >= u; r = P <= u ? ++Q : --Q) f.push(i[r].new);
          else l.push(T - P), q.push(0);
        }
        for (_.writeUInt16(3), _.writeUInt16(1), _.writeUInt32(12), _.writeUInt16(4), _.writeUInt16(16 + 8 * M + 2 * f.length), _.writeUInt16(0), _.writeUInt16(j), _.writeUInt16(F), _.writeUInt16(p), _.writeUInt16(O), vt = 0, N = d.length; vt < N; vt++) r = d[vt], _.writeUInt16(r);
        for (_.writeUInt16(0), mt = 0, z = A.length; mt < z; mt++) r = A[mt], _.writeUInt16(r);
        for (Bt = 0, G = l.length; Bt < G; Bt++) a = l[Bt], _.writeUInt16(a);
        for (Rt = 0, Y = q.length; Rt < Y; Rt++) C = q[Rt], _.writeUInt16(C);
        for (te = 0, st = f.length; te < st; te++) b = f[te], _.writeUInt16(b);
        return { charMap: i, subtable: _.data, maxGlyphID: k + 1 };
    }
  }, n;
}(), B1 = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "cmap", t.prototype.parse = function(e) {
    var i, r, s;
    for (e.pos = this.offset, this.version = e.readUInt16(), s = e.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = new ug(e, this.offset), this.tables.push(i), i.isUnicode && this.unicode == null && (this.unicode = i);
    return !0;
  }, t.encode = function(e, i) {
    var r, s;
    return i == null && (i = "macroman"), r = ug.encode(e, i), (s = new zs()).writeUInt16(0), s.writeUInt16(1), r.table = s.data.concat(r.subtable), r;
  }, t;
}(), qv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "hhea", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.ascender = e.readShort(), this.decender = e.readShort(), this.lineGap = e.readShort(), this.advanceWidthMax = e.readShort(), this.minLeftSideBearing = e.readShort(), this.minRightSideBearing = e.readShort(), this.xMaxExtent = e.readShort(), this.caretSlopeRise = e.readShort(), this.caretSlopeRun = e.readShort(), this.caretOffset = e.readShort(), e.pos += 8, this.metricDataFormat = e.readShort(), this.numberOfMetrics = e.readUInt16();
  }, t;
}(), zv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "OS/2", t.prototype.parse = function(e) {
    if (e.pos = this.offset, this.version = e.readUInt16(), this.averageCharWidth = e.readShort(), this.weightClass = e.readUInt16(), this.widthClass = e.readUInt16(), this.type = e.readShort(), this.ySubscriptXSize = e.readShort(), this.ySubscriptYSize = e.readShort(), this.ySubscriptXOffset = e.readShort(), this.ySubscriptYOffset = e.readShort(), this.ySuperscriptXSize = e.readShort(), this.ySuperscriptYSize = e.readShort(), this.ySuperscriptXOffset = e.readShort(), this.ySuperscriptYOffset = e.readShort(), this.yStrikeoutSize = e.readShort(), this.yStrikeoutPosition = e.readShort(), this.familyClass = e.readShort(), this.panose = function() {
      var i, r;
      for (r = [], i = 0; i < 10; ++i) r.push(e.readByte());
      return r;
    }(), this.charRange = function() {
      var i, r;
      for (r = [], i = 0; i < 4; ++i) r.push(e.readInt());
      return r;
    }(), this.vendorID = e.readString(4), this.selection = e.readShort(), this.firstCharIndex = e.readShort(), this.lastCharIndex = e.readShort(), this.version > 0 && (this.ascent = e.readShort(), this.descent = e.readShort(), this.lineGap = e.readShort(), this.winAscent = e.readShort(), this.winDescent = e.readShort(), this.codePageRange = function() {
      var i, r;
      for (r = [], i = 0; i < 2; i = ++i) r.push(e.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = e.readShort(), this.capHeight = e.readShort(), this.defaultChar = e.readShort(), this.breakChar = e.readShort(), this.maxContext = e.readShort();
  }, t;
}(), $v = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "post", t.prototype.parse = function(e) {
    var i, r, s;
    switch (e.pos = this.offset, this.format = e.readInt(), this.italicAngle = e.readInt(), this.underlinePosition = e.readShort(), this.underlineThickness = e.readShort(), this.isFixedPitch = e.readInt(), this.minMemType42 = e.readInt(), this.maxMemType42 = e.readInt(), this.minMemType1 = e.readInt(), this.maxMemType1 = e.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var o;
        for (r = e.readUInt16(), this.glyphNameIndex = [], o = 0; 0 <= r ? o < r : o > r; o = 0 <= r ? ++o : --o) this.glyphNameIndex.push(e.readUInt16());
        for (this.names = [], s = []; e.pos < this.offset + this.length; ) i = e.readByte(), s.push(this.names.push(e.readString(i)));
        return s;
      case 151552:
        return r = e.readUInt16(), this.offsets = e.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var a, l, h;
          for (h = [], o = a = 0, l = this.file.maxp.numGlyphs; 0 <= l ? a < l : a > l; o = 0 <= l ? ++a : --a) h.push(e.readUInt32());
          return h;
        }).call(this);
    }
  }, t;
}(), Uv = function(n, t) {
  this.raw = n, this.length = n.length, this.platformID = t.platformID, this.encodingID = t.encodingID, this.languageID = t.languageID;
}, Wv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "name", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f;
    for (e.pos = this.offset, e.readShort(), i = e.readShort(), l = e.readShort(), r = [], o = 0; 0 <= i ? o < i : o > i; o = 0 <= i ? ++o : --o) r.push({ platformID: e.readShort(), encodingID: e.readShort(), languageID: e.readShort(), nameID: e.readShort(), length: e.readShort(), offset: this.offset + l + e.readShort() });
    for (h = {}, o = d = 0, p = r.length; d < p; o = ++d) s = r[o], e.pos = s.offset, u = e.readString(s.length), a = new Uv(u, s), h[f = s.nameID] == null && (h[f] = []), h[s.nameID].push(a);
    this.strings = h, this.copyright = h[0], this.fontFamily = h[1], this.fontSubfamily = h[2], this.uniqueSubfamily = h[3], this.fontName = h[4], this.version = h[5];
    try {
      this.postscriptName = h[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = h[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = h[7], this.manufacturer = h[8], this.designer = h[9], this.description = h[10], this.vendorUrl = h[11], this.designerUrl = h[12], this.license = h[13], this.licenseUrl = h[14], this.preferredFamily = h[15], this.preferredSubfamily = h[17], this.compatibleFull = h[18], this.sampleText = h[19];
  }, t;
}(), Hv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "maxp", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.numGlyphs = e.readUInt16(), this.maxPoints = e.readUInt16(), this.maxContours = e.readUInt16(), this.maxCompositePoints = e.readUInt16(), this.maxComponentContours = e.readUInt16(), this.maxZones = e.readUInt16(), this.maxTwilightPoints = e.readUInt16(), this.maxStorage = e.readUInt16(), this.maxFunctionDefs = e.readUInt16(), this.maxInstructionDefs = e.readUInt16(), this.maxStackElements = e.readUInt16(), this.maxSizeOfInstructions = e.readUInt16(), this.maxComponentElements = e.readUInt16(), this.maxComponentDepth = e.readUInt16();
  }, t;
}(), Gv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "hmtx", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h;
    for (e.pos = this.offset, this.metrics = [], i = 0, l = this.file.hhea.numberOfMetrics; 0 <= l ? i < l : i > l; i = 0 <= l ? ++i : --i) this.metrics.push({ advance: e.readUInt16(), lsb: e.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var u, d;
      for (d = [], i = u = 0; 0 <= s ? u < s : u > s; i = 0 <= s ? ++u : --u) d.push(e.readInt16());
      return d;
    }(), this.widths = (function() {
      var u, d, p, f;
      for (f = [], u = 0, d = (p = this.metrics).length; u < d; u++) o = p[u], f.push(o.advance);
      return f;
    }).call(this), r = this.widths[this.widths.length - 1], h = [], i = a = 0; 0 <= s ? a < s : a > s; i = 0 <= s ? ++a : --a) h.push(this.widths.push(r));
    return h;
  }, t.prototype.forGlyph = function(e) {
    return e in this.metrics ? this.metrics[e] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[e - this.metrics.length] };
  }, t;
}(), j1 = [].slice, Vv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "glyf", t.prototype.parse = function() {
    return this.cache = {};
  }, t.prototype.glyphFor = function(e) {
    var i, r, s, o, a, l, h, u, d, p;
    return e in this.cache ? this.cache[e] : (o = this.file.loca, i = this.file.contents, r = o.indexOf(e), (s = o.lengthOf(e)) === 0 ? this.cache[e] = null : (i.pos = this.offset + r, a = (l = new zs(i.read(s))).readShort(), u = l.readShort(), p = l.readShort(), h = l.readShort(), d = l.readShort(), this.cache[e] = a === -1 ? new Kv(l, u, p, h, d) : new Yv(l, a, u, p, h, d), this.cache[e]));
  }, t.prototype.encode = function(e, i, r) {
    var s, o, a, l, h;
    for (a = [], o = [], l = 0, h = i.length; l < h; l++) s = e[i[l]], o.push(a.length), s && (a = a.concat(s.encode(r)));
    return o.push(a.length), { table: a, offsets: o };
  }, t;
}(), Yv = function() {
  function n(t, e, i, r, s, o) {
    this.raw = t, this.numberOfContours = e, this.xMin = i, this.yMin = r, this.xMax = s, this.yMax = o, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), Kv = function() {
  function n(t, e, i, r, s) {
    var o, a;
    for (this.raw = t, this.xMin = e, this.yMin = i, this.xMax = r, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], o = this.raw; a = o.readShort(), this.glyphOffsets.push(o.pos), this.glyphIDs.push(o.readUInt16()), 32 & a; ) o.pos += 1 & a ? 4 : 2, 128 & a ? o.pos += 8 : 64 & a ? o.pos += 4 : 8 & a && (o.pos += 2);
  }
  return n.prototype.encode = function() {
    var t, e, i;
    for (e = new zs(j1.call(this.raw.data)), t = 0, i = this.glyphIDs.length; t < i; ++t) e.pos = this.glyphOffsets[t];
    return e.data;
  }, n;
}(), Xv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, br), t.prototype.tag = "loca", t.prototype.parse = function(e) {
    var i, r;
    return e.pos = this.offset, i = this.file.head.indexToLocFormat, this.offsets = i === 0 ? (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 2) o.push(2 * e.readUInt16());
      return o;
    }).call(this) : (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 4) o.push(e.readUInt32());
      return o;
    }).call(this);
  }, t.prototype.indexOf = function(e) {
    return this.offsets[e];
  }, t.prototype.lengthOf = function(e) {
    return this.offsets[e + 1] - this.offsets[e];
  }, t.prototype.encode = function(e, i) {
    for (var r = new Uint32Array(this.offsets.length), s = 0, o = 0, a = 0; a < r.length; ++a) if (r[a] = s, o < i.length && i[o] == a) {
      ++o, r[a] = s;
      var l = this.offsets[a], h = this.offsets[a + 1] - l;
      h > 0 && (s += h);
    }
    for (var u = new Array(4 * r.length), d = 0; d < r.length; ++d) u[4 * d + 3] = 255 & r[d], u[4 * d + 2] = (65280 & r[d]) >> 8, u[4 * d + 1] = (16711680 & r[d]) >> 16, u[4 * d] = (4278190080 & r[d]) >> 24;
    return u;
  }, t;
}(), Jv = function() {
  function n(t) {
    this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var t, e, i, r, s;
    for (e in r = this.font.cmap.tables[0].codeMap, t = {}, s = this.subset) i = s[e], t[e] = r[i];
    return t;
  }, n.prototype.glyphsFor = function(t) {
    var e, i, r, s, o, a, l;
    for (r = {}, o = 0, a = t.length; o < a; o++) r[s = t[o]] = this.font.glyf.glyphFor(s);
    for (s in e = [], r) (i = r[s]) != null && i.compound && e.push.apply(e, i.glyphIDs);
    if (e.length > 0) for (s in l = this.glyphsFor(e)) i = l[s], r[s] = i;
    return r;
  }, n.prototype.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b, x, y;
    for (r in i = B1.encode(this.generateCmap(), "unicode"), o = this.glyphsFor(t), f = { 0: 0 }, y = i.charMap) f[(l = y[r]).old] = l.new;
    for (m in p = i.maxGlyphID, o) m in f || (f[m] = p++);
    return u = function(v) {
      var k, C;
      for (k in C = {}, v) C[v[k]] = k;
      return C;
    }(f), d = Object.keys(u).sort(function(v, k) {
      return v - k;
    }), b = function() {
      var v, k, C;
      for (C = [], v = 0, k = d.length; v < k; v++) a = d[v], C.push(u[a]);
      return C;
    }(), s = this.font.glyf.encode(o, b, f), h = this.font.loca.encode(s.offsets, b), x = { cmap: this.font.cmap.raw(), glyf: s.table, loca: h, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (x["OS/2"] = this.font.os2.raw()), this.font.directory.encode(x);
  }, n;
}();
ke.API.PDFObject = function() {
  var n;
  function t() {
  }
  return n = function(e, i) {
    return (Array(i + 1).join("0") + e).slice(-i);
  }, t.convert = function(e) {
    var i, r, s, o;
    if (Array.isArray(e)) return "[" + function() {
      var a, l, h;
      for (h = [], a = 0, l = e.length; a < l; a++) i = e[a], h.push(t.convert(i));
      return h;
    }().join(" ") + "]";
    if (typeof e == "string") return "/" + e;
    if (e != null && e.isString) return "(" + e + ")";
    if (e instanceof Date) return "(D:" + n(e.getUTCFullYear(), 4) + n(e.getUTCMonth(), 2) + n(e.getUTCDate(), 2) + n(e.getUTCHours(), 2) + n(e.getUTCMinutes(), 2) + n(e.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(e) === "[object Object]") {
      for (r in s = ["<<"], e) o = e[r], s.push("/" + r + " " + t.convert(o));
      return s.push(">>"), s.join(`
`);
    }
    return "" + e;
  }, t;
}();
const Zv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, AcroForm: Lv, AcroFormAppearance: ge, AcroFormButton: qn, AcroFormCheckBox: Nl, AcroFormChoiceField: yo, AcroFormComboBox: vo, AcroFormEditBox: kl, AcroFormListBox: bo, AcroFormPasswordField: Cl, AcroFormPushButton: Al, AcroFormRadioButton: wo, AcroFormTextField: Ds, GState: Ll, ShadingPattern: Es, TilingPattern: fo, default: ke, jsPDF: ke }, Symbol.toStringTag, { value: "Module" }));
var q1 = { exports: {} };
const Qv = /* @__PURE__ */ wy(Zv);
/*!
* 
*               jsPDF AutoTable plugin v3.8.4
*
*               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
*               Licensed under the MIT License.
*               http://opensource.org/licenses/mit-license
*
*/
(function(n, t) {
  (function(i, r) {
    n.exports = r(function() {
      try {
        return Qv;
      } catch {
      }
    }());
  })(typeof globalThis < "u" ? globalThis : typeof co < "u" ? co : typeof window < "u" ? window : typeof self < "u" ? self : co, function(e) {
    return (
      /******/
      function() {
        var i = {
          /***/
          172: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var p = function(f, m) {
                  return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b, x) {
                    b.__proto__ = x;
                  } || function(b, x) {
                    for (var y in x) Object.prototype.hasOwnProperty.call(x, y) && (b[y] = x[y]);
                  }, p(f, m);
                };
                return function(f, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
                  p(f, m);
                  function b() {
                    this.constructor = f;
                  }
                  f.prototype = m === null ? Object.create(m) : (b.prototype = m.prototype, new b());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.CellHookData = l.HookData = void 0;
              var u = (
                /** @class */
                /* @__PURE__ */ function() {
                  function p(f, m, b) {
                    this.table = m, this.pageNumber = m.pageNumber, this.pageCount = this.pageNumber, this.settings = m.settings, this.cursor = b, this.doc = f.getDocument();
                  }
                  return p;
                }()
              );
              l.HookData = u;
              var d = (
                /** @class */
                function(p) {
                  h(f, p);
                  function f(m, b, x, y, v, k) {
                    var C = p.call(this, m, b, k) || this;
                    return C.cell = x, C.row = y, C.column = v, C.section = y.section, C;
                  }
                  return f;
                }(u)
              );
              l.CellHookData = d;
            }
          ),
          /***/
          340: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              var u = h(4), d = h(136), p = h(744), f = h(776), m = h(664), b = h(972);
              function x(y) {
                y.API.autoTable = function() {
                  for (var v = [], k = 0; k < arguments.length; k++)
                    v[k] = arguments[k];
                  var C;
                  v.length === 1 ? C = v[0] : (console.error("Use of deprecated autoTable initiation"), C = v[2] || {}, C.columns = v[0], C.body = v[1]);
                  var I = (0, f.parseInput)(this, C), q = (0, b.createTable)(this, I);
                  return (0, m.drawTable)(this, q), this;
                }, y.API.lastAutoTable = !1, y.API.previousAutoTable = !1, y.API.autoTable.previous = !1, y.API.autoTableText = function(v, k, C, I) {
                  (0, d.default)(v, k, C, I, this);
                }, y.API.autoTableSetDefaults = function(v) {
                  return p.DocHandler.setDefaults(v, this), this;
                }, y.autoTableSetDefaults = function(v, k) {
                  p.DocHandler.setDefaults(v, k);
                }, y.API.autoTableHtmlToJson = function(v, k) {
                  var C;
                  if (k === void 0 && (k = !1), typeof window > "u")
                    return console.error("Cannot run autoTableHtmlToJson in non browser environment"), null;
                  var I = new p.DocHandler(this), q = (0, u.parseHtml)(I, v, window, k, !1), O = q.head, F = q.body, M = ((C = O[0]) === null || C === void 0 ? void 0 : C.map(function(j) {
                    return j.content;
                  })) || [];
                  return { columns: M, rows: F, data: F };
                }, y.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var v = this.lastAutoTable;
                  return v && v.finalY ? v.finalY : 0;
                }, y.API.autoTableAddPageContent = function(v) {
                  return console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead."), y.API.autoTable.globalDefaults || (y.API.autoTable.globalDefaults = {}), y.API.autoTable.globalDefaults.addPageContent = v, this;
                }, y.API.autoTableAddPage = function() {
                  return console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()"), this.addPage(), this;
                };
              }
              l.default = x;
            }
          ),
          /***/
          136: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(u, d, p, f, m) {
                f = f || {};
                var b = 1.15, x = m.internal.scaleFactor, y = m.internal.getFontSize() / x, v = m.getLineHeightFactor ? m.getLineHeightFactor() : b, k = y * v, C = /\r\n|\r|\n/g, I = "", q = 1;
                if ((f.valign === "middle" || f.valign === "bottom" || f.halign === "center" || f.halign === "right") && (I = typeof u == "string" ? u.split(C) : u, q = I.length || 1), p += y * (2 - b), f.valign === "middle" ? p -= q / 2 * k : f.valign === "bottom" && (p -= q * k), f.halign === "center" || f.halign === "right") {
                  var O = y;
                  if (f.halign === "center" && (O *= 0.5), I && q >= 1) {
                    for (var F = 0; F < I.length; F++)
                      m.text(I[F], d - m.getStringUnitWidth(I[F]) * O, p), p += k;
                    return m;
                  }
                  d -= m.getStringUnitWidth(u) * O;
                }
                return f.halign === "justify" ? m.text(u, d, p, {
                  maxWidth: f.maxWidth || 100,
                  align: "justify"
                }) : m.text(u, d, p), m;
              }
              l.default = h;
            }
          ),
          /***/
          420: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getPageAvailableWidth = l.parseSpacing = l.getFillStyle = l.addTableBorder = l.getStringWidth = void 0;
              function h(m, b, x) {
                x.applyStyles(b, !0);
                var y = Array.isArray(m) ? m : [m], v = y.map(function(k) {
                  return x.getTextWidth(k);
                }).reduce(function(k, C) {
                  return Math.max(k, C);
                }, 0);
                return v;
              }
              l.getStringWidth = h;
              function u(m, b, x, y) {
                var v = b.settings.tableLineWidth, k = b.settings.tableLineColor;
                m.applyStyles({ lineWidth: v, lineColor: k });
                var C = d(v, !1);
                C && m.rect(x.x, x.y, b.getWidth(m.pageSize().width), y.y - x.y, C);
              }
              l.addTableBorder = u;
              function d(m, b) {
                var x = m > 0, y = b || b === 0;
                return x && y ? "DF" : x ? "S" : y ? "F" : null;
              }
              l.getFillStyle = d;
              function p(m, b) {
                var x, y, v, k;
                if (m = m || b, Array.isArray(m)) {
                  if (m.length >= 4)
                    return {
                      top: m[0],
                      right: m[1],
                      bottom: m[2],
                      left: m[3]
                    };
                  if (m.length === 3)
                    return {
                      top: m[0],
                      right: m[1],
                      bottom: m[2],
                      left: m[1]
                    };
                  if (m.length === 2)
                    return {
                      top: m[0],
                      right: m[1],
                      bottom: m[0],
                      left: m[1]
                    };
                  m.length === 1 ? m = m[0] : m = b;
                }
                return typeof m == "object" ? (typeof m.vertical == "number" && (m.top = m.vertical, m.bottom = m.vertical), typeof m.horizontal == "number" && (m.right = m.horizontal, m.left = m.horizontal), {
                  left: (x = m.left) !== null && x !== void 0 ? x : b,
                  top: (y = m.top) !== null && y !== void 0 ? y : b,
                  right: (v = m.right) !== null && v !== void 0 ? v : b,
                  bottom: (k = m.bottom) !== null && k !== void 0 ? k : b
                }) : (typeof m != "number" && (m = b), { top: m, right: m, bottom: m, left: m });
              }
              l.parseSpacing = p;
              function f(m, b) {
                var x = p(b.settings.margin, 0);
                return m.pageSize().width - (x.left + x.right);
              }
              l.getPageAvailableWidth = f;
            }
          ),
          /***/
          796: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var f = function(m, b) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(x, y) {
                    x.__proto__ = y;
                  } || function(x, y) {
                    for (var v in y) Object.prototype.hasOwnProperty.call(y, v) && (x[v] = y[v]);
                  }, f(m, b);
                };
                return function(m, b) {
                  if (typeof b != "function" && b !== null)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                  f(m, b);
                  function x() {
                    this.constructor = m;
                  }
                  m.prototype = b === null ? Object.create(b) : (x.prototype = b.prototype, new x());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getTheme = l.defaultStyles = l.HtmlRowInput = void 0;
              var u = (
                /** @class */
                function(f) {
                  h(m, f);
                  function m(b) {
                    var x = f.call(this) || this;
                    return x._element = b, x;
                  }
                  return m;
                }(Array)
              );
              l.HtmlRowInput = u;
              function d(f) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: !1,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / f,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              l.defaultStyles = d;
              function p(f) {
                var m = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return m[f];
              }
              l.getTheme = p;
            }
          ),
          /***/
          903: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseCss = void 0;
              var u = h(420);
              function d(x, y, v, k, C) {
                var I = {}, q = 1.3333333333333333, O = f(y, function(H) {
                  return C.getComputedStyle(H).backgroundColor;
                });
                O != null && (I.fillColor = O);
                var F = f(y, function(H) {
                  return C.getComputedStyle(H).color;
                });
                F != null && (I.textColor = F);
                var M = b(k, v);
                M && (I.cellPadding = M);
                var j = "borderTopColor", P = q * v, A = k.borderTopWidth;
                if (k.borderBottomWidth === A && k.borderRightWidth === A && k.borderLeftWidth === A) {
                  var T = (parseFloat(A) || 0) / P;
                  T && (I.lineWidth = T);
                } else
                  I.lineWidth = {
                    top: (parseFloat(k.borderTopWidth) || 0) / P,
                    right: (parseFloat(k.borderRightWidth) || 0) / P,
                    bottom: (parseFloat(k.borderBottomWidth) || 0) / P,
                    left: (parseFloat(k.borderLeftWidth) || 0) / P
                  }, I.lineWidth.top || (I.lineWidth.right ? j = "borderRightColor" : I.lineWidth.bottom ? j = "borderBottomColor" : I.lineWidth.left && (j = "borderLeftColor"));
                var _ = f(y, function(H) {
                  return C.getComputedStyle(H)[j];
                });
                _ != null && (I.lineColor = _);
                var Z = ["left", "right", "center", "justify"];
                Z.indexOf(k.textAlign) !== -1 && (I.halign = k.textAlign), Z = ["middle", "bottom", "top"], Z.indexOf(k.verticalAlign) !== -1 && (I.valign = k.verticalAlign);
                var V = parseInt(k.fontSize || "");
                isNaN(V) || (I.fontSize = V / q);
                var R = p(k);
                R && (I.fontStyle = R);
                var Q = (k.fontFamily || "").toLowerCase();
                return x.indexOf(Q) !== -1 && (I.font = Q), I;
              }
              l.parseCss = d;
              function p(x) {
                var y = "";
                return (x.fontWeight === "bold" || x.fontWeight === "bolder" || parseInt(x.fontWeight) >= 700) && (y = "bold"), (x.fontStyle === "italic" || x.fontStyle === "oblique") && (y += "italic"), y;
              }
              function f(x, y) {
                var v = m(x, y);
                if (!v)
                  return null;
                var k = v.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!k || !Array.isArray(k))
                  return null;
                var C = [
                  parseInt(k[1]),
                  parseInt(k[2]),
                  parseInt(k[3])
                ], I = parseInt(k[4]);
                return I === 0 || isNaN(C[0]) || isNaN(C[1]) || isNaN(C[2]) ? null : C;
              }
              function m(x, y) {
                var v = y(x);
                return v === "rgba(0, 0, 0, 0)" || v === "transparent" || v === "initial" || v === "inherit" ? x.parentElement == null ? null : m(x.parentElement, y) : v;
              }
              function b(x, y) {
                var v = [
                  x.paddingTop,
                  x.paddingRight,
                  x.paddingBottom,
                  x.paddingLeft
                ], k = 96 / (72 / y), C = (parseInt(x.lineHeight) - parseInt(x.fontSize)) / y / 2, I = v.map(function(O) {
                  return parseInt(O || "0") / k;
                }), q = (0, u.parseSpacing)(I, 0);
                return C > q.top && (q.top = C), C > q.bottom && (q.bottom = C), q;
              }
            }
          ),
          /***/
          744: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.DocHandler = void 0;
              var h = {}, u = (
                /** @class */
                function() {
                  function d(p) {
                    this.jsPDFDocument = p, this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: p.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: p.internal.getFontSize(),
                      fontStyle: p.internal.getFont().fontStyle,
                      font: p.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: p.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: p.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  return d.setDefaults = function(p, f) {
                    f === void 0 && (f = null), f ? f.__autoTableDocumentDefaults = p : h = p;
                  }, d.unifyColor = function(p) {
                    return Array.isArray(p) ? p : typeof p == "number" ? [p, p, p] : typeof p == "string" ? [p] : null;
                  }, d.prototype.applyStyles = function(p, f) {
                    var m, b, x;
                    f === void 0 && (f = !1), p.fontStyle && this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(p.fontStyle);
                    var y = this.jsPDFDocument.internal.getFont(), v = y.fontStyle, k = y.fontName;
                    if (p.font && (k = p.font), p.fontStyle) {
                      v = p.fontStyle;
                      var C = this.getFontList()[k];
                      C && C.indexOf(v) === -1 && (this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(C[0]), v = C[0]);
                    }
                    if (this.jsPDFDocument.setFont(k, v), p.fontSize && this.jsPDFDocument.setFontSize(p.fontSize), !f) {
                      var I = d.unifyColor(p.fillColor);
                      I && (m = this.jsPDFDocument).setFillColor.apply(m, I), I = d.unifyColor(p.textColor), I && (b = this.jsPDFDocument).setTextColor.apply(b, I), I = d.unifyColor(p.lineColor), I && (x = this.jsPDFDocument).setDrawColor.apply(x, I), typeof p.lineWidth == "number" && this.jsPDFDocument.setLineWidth(p.lineWidth);
                    }
                  }, d.prototype.splitTextToSize = function(p, f, m) {
                    return this.jsPDFDocument.splitTextToSize(p, f, m);
                  }, d.prototype.rect = function(p, f, m, b, x) {
                    return this.jsPDFDocument.rect(p, f, m, b, x);
                  }, d.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  }, d.prototype.getTextWidth = function(p) {
                    return this.jsPDFDocument.getTextWidth(p);
                  }, d.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  }, d.prototype.setPage = function(p) {
                    this.jsPDFDocument.setPage(p);
                  }, d.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  }, d.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  }, d.prototype.getGlobalOptions = function() {
                    return h || {};
                  }, d.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  }, d.prototype.pageSize = function() {
                    var p = this.jsPDFDocument.internal.pageSize;
                    return p.width == null && (p = {
                      width: p.getWidth(),
                      height: p.getHeight()
                    }), p;
                  }, d.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  }, d.prototype.getLineHeightFactor = function() {
                    var p = this.jsPDFDocument;
                    return p.getLineHeightFactor ? p.getLineHeightFactor() : 1.15;
                  }, d.prototype.getLineHeight = function(p) {
                    return p / this.scaleFactor() * this.getLineHeightFactor();
                  }, d.prototype.pageNumber = function() {
                    var p = this.jsPDFDocument.internal.getCurrentPageInfo();
                    return p ? p.pageNumber : this.jsPDFDocument.internal.getNumberOfPages();
                  }, d;
                }()
              );
              l.DocHandler = u;
            }
          ),
          /***/
          4: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseHtml = void 0;
              var u = h(903), d = h(796);
              function p(b, x, y, v, k) {
                var C, I;
                v === void 0 && (v = !1), k === void 0 && (k = !1);
                var q;
                typeof x == "string" ? q = y.document.querySelector(x) : q = x;
                var O = Object.keys(b.getFontList()), F = b.scaleFactor(), M = [], j = [], P = [];
                if (!q)
                  return console.error("Html table could not be found with input: ", x), { head: M, body: j, foot: P };
                for (var A = 0; A < q.rows.length; A++) {
                  var T = q.rows[A], _ = (I = (C = T == null ? void 0 : T.parentElement) === null || C === void 0 ? void 0 : C.tagName) === null || I === void 0 ? void 0 : I.toLowerCase(), Z = f(O, F, y, T, v, k);
                  Z && (_ === "thead" ? M.push(Z) : _ === "tfoot" ? P.push(Z) : j.push(Z));
                }
                return { head: M, body: j, foot: P };
              }
              l.parseHtml = p;
              function f(b, x, y, v, k, C) {
                for (var I = new d.HtmlRowInput(v), q = 0; q < v.cells.length; q++) {
                  var O = v.cells[q], F = y.getComputedStyle(O);
                  if (k || F.display !== "none") {
                    var M = void 0;
                    C && (M = (0, u.parseCss)(b, O, x, F, y)), I.push({
                      rowSpan: O.rowSpan,
                      colSpan: O.colSpan,
                      styles: M,
                      _element: O,
                      content: m(O)
                    });
                  }
                }
                var j = y.getComputedStyle(v);
                if (I.length > 0 && (k || j.display !== "none"))
                  return I;
              }
              function m(b) {
                var x = b.cloneNode(!0);
                return x.innerHTML = x.innerHTML.replace(/\n/g, "").replace(/ +/g, " "), x.innerHTML = x.innerHTML.split(/<br.*?>/).map(function(y) {
                  return y.trim();
                }).join(`
`), x.innerText || x.textContent || "";
              }
            }
          ),
          /***/
          776: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseInput = void 0;
              var u = h(4), d = h(356), p = h(420), f = h(744), m = h(792);
              function b(q, O) {
                var F = new f.DocHandler(q), M = F.getDocumentOptions(), j = F.getGlobalOptions();
                (0, m.default)(F, j, M, O);
                var P = (0, d.assign)({}, j, M, O), A;
                typeof window < "u" && (A = window);
                var T = x(j, M, O), _ = y(j, M, O), Z = v(F, P), V = C(F, P, A);
                return {
                  id: O.tableId,
                  content: V,
                  hooks: _,
                  styles: T,
                  settings: Z
                };
              }
              l.parseInput = b;
              function x(q, O, F) {
                for (var M = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                }, j = function(_) {
                  if (_ === "columnStyles") {
                    var Z = q[_], V = O[_], R = F[_];
                    M.columnStyles = (0, d.assign)({}, Z, V, R);
                  } else {
                    var Q = [q, O, F], H = Q.map(function(ct) {
                      return ct[_] || {};
                    });
                    M[_] = (0, d.assign)({}, H[0], H[1], H[2]);
                  }
                }, P = 0, A = Object.keys(M); P < A.length; P++) {
                  var T = A[P];
                  j(T);
                }
                return M;
              }
              function y(q, O, F) {
                for (var M = [q, O, F], j = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                }, P = 0, A = M; P < A.length; P++) {
                  var T = A[P];
                  T.didParseCell && j.didParseCell.push(T.didParseCell), T.willDrawCell && j.willDrawCell.push(T.willDrawCell), T.didDrawCell && j.didDrawCell.push(T.didDrawCell), T.willDrawPage && j.willDrawPage.push(T.willDrawPage), T.didDrawPage && j.didDrawPage.push(T.didDrawPage);
                }
                return j;
              }
              function v(q, O) {
                var F, M, j, P, A, T, _, Z, V, R, Q, H, ct = (0, p.parseSpacing)(O.margin, 40 / q.scaleFactor()), nt = (F = k(q, O.startY)) !== null && F !== void 0 ? F : ct.top, N;
                O.showFoot === !0 ? N = "everyPage" : O.showFoot === !1 ? N = "never" : N = (M = O.showFoot) !== null && M !== void 0 ? M : "everyPage";
                var z;
                O.showHead === !0 ? z = "everyPage" : O.showHead === !1 ? z = "never" : z = (j = O.showHead) !== null && j !== void 0 ? j : "everyPage";
                var G = (P = O.useCss) !== null && P !== void 0 ? P : !1, Y = O.theme || (G ? "plain" : "striped"), st = !!O.horizontalPageBreak, vt = (A = O.horizontalPageBreakRepeat) !== null && A !== void 0 ? A : null;
                return {
                  includeHiddenHtml: (T = O.includeHiddenHtml) !== null && T !== void 0 ? T : !1,
                  useCss: G,
                  theme: Y,
                  startY: nt,
                  margin: ct,
                  pageBreak: (_ = O.pageBreak) !== null && _ !== void 0 ? _ : "auto",
                  rowPageBreak: (Z = O.rowPageBreak) !== null && Z !== void 0 ? Z : "auto",
                  tableWidth: (V = O.tableWidth) !== null && V !== void 0 ? V : "auto",
                  showHead: z,
                  showFoot: N,
                  tableLineWidth: (R = O.tableLineWidth) !== null && R !== void 0 ? R : 0,
                  tableLineColor: (Q = O.tableLineColor) !== null && Q !== void 0 ? Q : 200,
                  horizontalPageBreak: st,
                  horizontalPageBreakRepeat: vt,
                  horizontalPageBreakBehaviour: (H = O.horizontalPageBreakBehaviour) !== null && H !== void 0 ? H : "afterAllRows"
                };
              }
              function k(q, O) {
                var F = q.getLastAutoTable(), M = q.scaleFactor(), j = q.pageNumber(), P = !1;
                if (F && F.startPageNumber) {
                  var A = F.startPageNumber + F.pageNumber - 1;
                  P = A === j;
                }
                return typeof O == "number" ? O : (O == null || O === !1) && P && (F == null ? void 0 : F.finalY) != null ? F.finalY + 20 / M : null;
              }
              function C(q, O, F) {
                var M = O.head || [], j = O.body || [], P = O.foot || [];
                if (O.html) {
                  var A = O.includeHiddenHtml;
                  if (F) {
                    var T = (0, u.parseHtml)(q, O.html, F, A, O.useCss) || {};
                    M = T.head || M, j = T.body || M, P = T.foot || M;
                  } else
                    console.error("Cannot parse html in non browser environment");
                }
                var _ = O.columns || I(M, j, P);
                return {
                  columns: _,
                  head: M,
                  body: j,
                  foot: P
                };
              }
              function I(q, O, F) {
                var M = q[0] || O[0] || F[0] || [], j = [];
                return Object.keys(M).filter(function(P) {
                  return P !== "_element";
                }).forEach(function(P) {
                  var A = 1, T;
                  Array.isArray(M) ? T = M[parseInt(P)] : T = M[P], typeof T == "object" && !Array.isArray(T) && (A = (T == null ? void 0 : T.colSpan) || 1);
                  for (var _ = 0; _ < A; _++) {
                    var Z = void 0;
                    Array.isArray(M) ? Z = j.length : Z = P + (_ > 0 ? "_".concat(_) : "");
                    var V = { dataKey: Z };
                    j.push(V);
                  }
                }), j;
              }
            }
          ),
          /***/
          792: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(d, p, f, m) {
                for (var b = function(k) {
                  k && typeof k != "object" && console.error("The options parameter should be of type object, is: " + typeof k), typeof k.extendWidth < "u" && (k.tableWidth = k.extendWidth ? "auto" : "wrap", console.error("Use of deprecated option: extendWidth, use tableWidth instead.")), typeof k.margins < "u" && (typeof k.margin > "u" && (k.margin = k.margins), console.error("Use of deprecated option: margins, use margin instead.")), k.startY && typeof k.startY != "number" && (console.error("Invalid value for startY option", k.startY), delete k.startY), !k.didDrawPage && (k.afterPageContent || k.beforePageContent || k.afterPageAdd) && (console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead"), k.didDrawPage = function(P) {
                    d.applyStyles(d.userStyles), k.beforePageContent && k.beforePageContent(P), d.applyStyles(d.userStyles), k.afterPageContent && k.afterPageContent(P), d.applyStyles(d.userStyles), k.afterPageAdd && P.pageNumber > 1 && P.afterPageAdd(P), d.applyStyles(d.userStyles);
                  }), [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(P) {
                    k[P] && console.error('The "'.concat(P, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                  }), [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(P) {
                    var A = P[0], T = P[1];
                    k[T] && (console.error("Use of deprecated option ".concat(T, ". Use ").concat(A, " instead")), k[A] = k[T]);
                  }), [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(P) {
                    var A = typeof P == "string" ? P : P[0], T = typeof P == "string" ? P : P[1];
                    typeof k[A] < "u" && (typeof k.styles[T] > "u" && (k.styles[T] = k[A]), console.error("Use of deprecated option: " + A + ", use the style " + T + " instead."));
                  });
                  for (var C = 0, I = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; C < I.length; C++) {
                    var q = I[C];
                    u(k[q] || {});
                  }
                  for (var O = k.columnStyles || {}, F = 0, M = Object.keys(O); F < M.length; F++) {
                    var j = M[F];
                    u(O[j] || {});
                  }
                }, x = 0, y = [p, f, m]; x < y.length; x++) {
                  var v = y[x];
                  b(v);
                }
              }
              l.default = h;
              function u(d) {
                d.rowHeight ? (console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight."), d.minCellHeight || (d.minCellHeight = d.rowHeight)) : d.columnWidth && (console.error("Use of deprecated style columnWidth. It is renamed to cellWidth."), d.cellWidth || (d.cellWidth = d.columnWidth));
              }
            }
          ),
          /***/
          260: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.Column = l.Cell = l.Row = l.Table = void 0;
              var u = h(796), d = h(172), p = h(420), f = (
                /** @class */
                function() {
                  function y(v, k) {
                    this.pageNumber = 1, this.pageCount = 1, this.id = v.id, this.settings = v.settings, this.styles = v.styles, this.hooks = v.hooks, this.columns = k.columns, this.head = k.head, this.body = k.body, this.foot = k.foot;
                  }
                  return y.prototype.getHeadHeight = function(v) {
                    return this.head.reduce(function(k, C) {
                      return k + C.getMaxCellHeight(v);
                    }, 0);
                  }, y.prototype.getFootHeight = function(v) {
                    return this.foot.reduce(function(k, C) {
                      return k + C.getMaxCellHeight(v);
                    }, 0);
                  }, y.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  }, y.prototype.callCellHooks = function(v, k, C, I, q, O) {
                    for (var F = 0, M = k; F < M.length; F++) {
                      var j = M[F], P = new d.CellHookData(v, this, C, I, q, O), A = j(P) === !1;
                      if (C.text = Array.isArray(C.text) ? C.text : [C.text], A)
                        return !1;
                    }
                    return !0;
                  }, y.prototype.callEndPageHooks = function(v, k) {
                    v.applyStyles(v.userStyles);
                    for (var C = 0, I = this.hooks.didDrawPage; C < I.length; C++) {
                      var q = I[C];
                      q(new d.HookData(v, this, k));
                    }
                  }, y.prototype.callWillDrawPageHooks = function(v, k) {
                    for (var C = 0, I = this.hooks.willDrawPage; C < I.length; C++) {
                      var q = I[C];
                      q(new d.HookData(v, this, k));
                    }
                  }, y.prototype.getWidth = function(v) {
                    if (typeof this.settings.tableWidth == "number")
                      return this.settings.tableWidth;
                    if (this.settings.tableWidth === "wrap") {
                      var k = this.columns.reduce(function(I, q) {
                        return I + q.wrappedWidth;
                      }, 0);
                      return k;
                    } else {
                      var C = this.settings.margin;
                      return v - C.left - C.right;
                    }
                  }, y;
                }()
              );
              l.Table = f;
              var m = (
                /** @class */
                function() {
                  function y(v, k, C, I, q) {
                    q === void 0 && (q = !1), this.height = 0, this.raw = v, v instanceof u.HtmlRowInput && (this.raw = v._element, this.element = v._element), this.index = k, this.section = C, this.cells = I, this.spansMultiplePages = q;
                  }
                  return y.prototype.getMaxCellHeight = function(v) {
                    var k = this;
                    return v.reduce(function(C, I) {
                      var q;
                      return Math.max(C, ((q = k.cells[I.index]) === null || q === void 0 ? void 0 : q.height) || 0);
                    }, 0);
                  }, y.prototype.hasRowSpan = function(v) {
                    var k = this;
                    return v.filter(function(C) {
                      var I = k.cells[C.index];
                      return I ? I.rowSpan > 1 : !1;
                    }).length > 0;
                  }, y.prototype.canEntireRowFit = function(v, k) {
                    return this.getMaxCellHeight(k) <= v;
                  }, y.prototype.getMinimumRowHeight = function(v, k) {
                    var C = this;
                    return v.reduce(function(I, q) {
                      var O = C.cells[q.index];
                      if (!O)
                        return 0;
                      var F = k.getLineHeight(O.styles.fontSize), M = O.padding("vertical"), j = M + F;
                      return j > I ? j : I;
                    }, 0);
                  }, y;
                }()
              );
              l.Row = m;
              var b = (
                /** @class */
                function() {
                  function y(v, k, C) {
                    var I, q;
                    this.contentHeight = 0, this.contentWidth = 0, this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.height = 0, this.x = 0, this.y = 0, this.styles = k, this.section = C, this.raw = v;
                    var O = v;
                    v != null && typeof v == "object" && !Array.isArray(v) ? (this.rowSpan = v.rowSpan || 1, this.colSpan = v.colSpan || 1, O = (q = (I = v.content) !== null && I !== void 0 ? I : v.title) !== null && q !== void 0 ? q : v, v._element && (this.raw = v._element)) : (this.rowSpan = 1, this.colSpan = 1);
                    var F = O != null ? "" + O : "", M = /\r\n|\r|\n/g;
                    this.text = F.split(M);
                  }
                  return y.prototype.getTextPos = function() {
                    var v;
                    if (this.styles.valign === "top")
                      v = this.y + this.padding("top");
                    else if (this.styles.valign === "bottom")
                      v = this.y + this.height - this.padding("bottom");
                    else {
                      var k = this.height - this.padding("vertical");
                      v = this.y + k / 2 + this.padding("top");
                    }
                    var C;
                    if (this.styles.halign === "right")
                      C = this.x + this.width - this.padding("right");
                    else if (this.styles.halign === "center") {
                      var I = this.width - this.padding("horizontal");
                      C = this.x + I / 2 + this.padding("left");
                    } else
                      C = this.x + this.padding("left");
                    return { x: C, y: v };
                  }, y.prototype.getContentHeight = function(v, k) {
                    k === void 0 && (k = 1.15);
                    var C = Array.isArray(this.text) ? this.text.length : 1, I = this.styles.fontSize / v * k, q = C * I + this.padding("vertical");
                    return Math.max(q, this.styles.minCellHeight);
                  }, y.prototype.padding = function(v) {
                    var k = (0, p.parseSpacing)(this.styles.cellPadding, 0);
                    return v === "vertical" ? k.top + k.bottom : v === "horizontal" ? k.left + k.right : k[v];
                  }, y;
                }()
              );
              l.Cell = b;
              var x = (
                /** @class */
                function() {
                  function y(v, k, C) {
                    this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.dataKey = v, this.raw = k, this.index = C;
                  }
                  return y.prototype.getMaxCustomCellWidth = function(v) {
                    for (var k = 0, C = 0, I = v.allRows(); C < I.length; C++) {
                      var q = I[C], O = q.cells[this.index];
                      O && typeof O.styles.cellWidth == "number" && (k = Math.max(k, O.styles.cellWidth));
                    }
                    return k;
                  }, y;
                }()
              );
              l.Column = x;
            }
          ),
          /***/
          356: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.assign = void 0;
              function h(u, d, p, f, m) {
                if (u == null)
                  throw new TypeError("Cannot convert undefined or null to object");
                for (var b = Object(u), x = 1; x < arguments.length; x++) {
                  var y = arguments[x];
                  if (y != null)
                    for (var v in y)
                      Object.prototype.hasOwnProperty.call(y, v) && (b[v] = y[v]);
                }
                return b;
              }
              l.assign = h;
            }
          ),
          /***/
          972: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.createTable = void 0;
              var u = h(744), d = h(260), p = h(324), f = h(796), m = h(356);
              function b(q, O) {
                var F = new u.DocHandler(q), M = x(O, F.scaleFactor()), j = new d.Table(O, M);
                return (0, p.calculateWidths)(F, j), F.applyStyles(F.userStyles), j;
              }
              l.createTable = b;
              function x(q, O) {
                var F = q.content, M = C(F.columns);
                if (F.head.length === 0) {
                  var j = v(M, "head");
                  j && F.head.push(j);
                }
                if (F.foot.length === 0) {
                  var j = v(M, "foot");
                  j && F.foot.push(j);
                }
                var P = q.settings.theme, A = q.styles;
                return {
                  columns: M,
                  head: y("head", F.head, M, A, P, O),
                  body: y("body", F.body, M, A, P, O),
                  foot: y("foot", F.foot, M, A, P, O)
                };
              }
              function y(q, O, F, M, j, P) {
                var A = {}, T = O.map(function(_, Z) {
                  for (var V = 0, R = {}, Q = 0, H = 0, ct = 0, nt = F; ct < nt.length; ct++) {
                    var N = nt[ct];
                    if (A[N.index] == null || A[N.index].left === 0)
                      if (H === 0) {
                        var z = void 0;
                        Array.isArray(_) ? z = _[N.index - Q - V] : z = _[N.dataKey];
                        var G = {};
                        typeof z == "object" && !Array.isArray(z) && (G = (z == null ? void 0 : z.styles) || {});
                        var Y = I(q, N, Z, j, M, P, G), st = new d.Cell(z, Y, q);
                        R[N.dataKey] = st, R[N.index] = st, H = st.colSpan - 1, A[N.index] = {
                          left: st.rowSpan - 1,
                          times: H
                        };
                      } else
                        H--, Q++;
                    else
                      A[N.index].left--, H = A[N.index].times, V++;
                  }
                  return new d.Row(_, Z, q, R);
                });
                return T;
              }
              function v(q, O) {
                var F = {};
                return q.forEach(function(M) {
                  if (M.raw != null) {
                    var j = k(O, M.raw);
                    j != null && (F[M.dataKey] = j);
                  }
                }), Object.keys(F).length > 0 ? F : null;
              }
              function k(q, O) {
                if (q === "head") {
                  if (typeof O == "object")
                    return O.header || O.title || null;
                  if (typeof O == "string" || typeof O == "number")
                    return O;
                } else if (q === "foot" && typeof O == "object")
                  return O.footer;
                return null;
              }
              function C(q) {
                return q.map(function(O, F) {
                  var M, j, P;
                  return typeof O == "object" ? P = (j = (M = O.dataKey) !== null && M !== void 0 ? M : O.key) !== null && j !== void 0 ? j : F : P = F, new d.Column(P, O, F);
                });
              }
              function I(q, O, F, M, j, P, A) {
                var T = (0, f.getTheme)(M), _;
                q === "head" ? _ = j.headStyles : q === "body" ? _ = j.bodyStyles : q === "foot" && (_ = j.footStyles);
                var Z = (0, m.assign)({}, T.table, T[q], j.styles, _), V = j.columnStyles[O.dataKey] || j.columnStyles[O.index] || {}, R = q === "body" ? V : {}, Q = q === "body" && F % 2 === 0 ? (0, m.assign)({}, T.alternateRow, j.alternateRowStyles) : {}, H = (0, f.defaultStyles)(P), ct = (0, m.assign)({}, H, Z, Q, R);
                return (0, m.assign)(ct, A);
              }
            }
          ),
          /***/
          664: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.addPage = l.drawTable = void 0;
              var u = h(420), d = h(260), p = h(744), f = h(356), m = h(136), b = h(224);
              function x(V, R) {
                var Q = R.settings, H = Q.startY, ct = Q.margin, nt = {
                  x: ct.left,
                  y: H
                }, N = R.getHeadHeight(R.columns) + R.getFootHeight(R.columns), z = H + ct.bottom + N;
                if (Q.pageBreak === "avoid") {
                  var G = R.body, Y = G.reduce(function(mt, _t) {
                    return mt + _t.height;
                  }, 0);
                  z += Y;
                }
                var st = new p.DocHandler(V);
                (Q.pageBreak === "always" || Q.startY != null && z > st.pageSize().height) && (Z(st), nt.y = ct.top), R.callWillDrawPageHooks(st, nt);
                var vt = (0, f.assign)({}, nt);
                R.startPageNumber = st.pageNumber(), Q.horizontalPageBreak ? y(st, R, vt, nt) : (st.applyStyles(st.userStyles), (Q.showHead === "firstPage" || Q.showHead === "everyPage") && R.head.forEach(function(mt) {
                  return j(st, R, mt, nt, R.columns);
                }), st.applyStyles(st.userStyles), R.body.forEach(function(mt, _t) {
                  var Bt = _t === R.body.length - 1;
                  M(st, R, mt, Bt, vt, nt, R.columns);
                }), st.applyStyles(st.userStyles), (Q.showFoot === "lastPage" || Q.showFoot === "everyPage") && R.foot.forEach(function(mt) {
                  return j(st, R, mt, nt, R.columns);
                })), (0, u.addTableBorder)(st, R, vt, nt), R.callEndPageHooks(st, nt), R.finalY = nt.y, V.lastAutoTable = R, V.previousAutoTable = R, V.autoTable && (V.autoTable.previous = R), st.applyStyles(st.userStyles);
              }
              l.drawTable = x;
              function y(V, R, Q, H) {
                var ct = (0, b.calculateAllColumnsCanFitInPage)(V, R), nt = R.settings;
                if (nt.horizontalPageBreakBehaviour === "afterAllRows")
                  ct.forEach(function(Y, st) {
                    V.applyStyles(V.userStyles), st > 0 ? _(V, R, Q, H, Y.columns, !0) : v(V, R, H, Y.columns), k(V, R, Q, H, Y.columns), I(V, R, H, Y.columns);
                  });
                else
                  for (var N = -1, z = ct[0], G = function() {
                    var Y = N;
                    if (z) {
                      V.applyStyles(V.userStyles);
                      var st = z.columns;
                      N >= 0 ? _(V, R, Q, H, st, !0) : v(V, R, H, st), Y = C(V, R, N + 1, H, st), I(V, R, H, st);
                    }
                    var vt = Y - N;
                    ct.slice(1).forEach(function(mt) {
                      V.applyStyles(V.userStyles), _(V, R, Q, H, mt.columns, !0), C(V, R, N + 1, H, mt.columns, vt), I(V, R, H, mt.columns);
                    }), N = Y;
                  }; N < R.body.length - 1; )
                    G();
              }
              function v(V, R, Q, H) {
                var ct = R.settings;
                V.applyStyles(V.userStyles), (ct.showHead === "firstPage" || ct.showHead === "everyPage") && R.head.forEach(function(nt) {
                  return j(V, R, nt, Q, H);
                });
              }
              function k(V, R, Q, H, ct) {
                V.applyStyles(V.userStyles), R.body.forEach(function(nt, N) {
                  var z = N === R.body.length - 1;
                  M(V, R, nt, z, Q, H, ct);
                });
              }
              function C(V, R, Q, H, ct, nt) {
                V.applyStyles(V.userStyles), nt = nt ?? R.body.length;
                var N = Math.min(Q + nt, R.body.length), z = -1;
                return R.body.slice(Q, N).forEach(function(G, Y) {
                  var st = Q + Y === R.body.length - 1, vt = T(V, R, st, H);
                  G.canEntireRowFit(vt, ct) && (j(V, R, G, H, ct), z = Q + Y);
                }), z;
              }
              function I(V, R, Q, H) {
                var ct = R.settings;
                V.applyStyles(V.userStyles), (ct.showFoot === "lastPage" || ct.showFoot === "everyPage") && R.foot.forEach(function(nt) {
                  return j(V, R, nt, Q, H);
                });
              }
              function q(V, R, Q) {
                var H = Q.getLineHeight(V.styles.fontSize), ct = V.padding("vertical"), nt = Math.floor((R - ct) / H);
                return Math.max(0, nt);
              }
              function O(V, R, Q, H) {
                var ct = {};
                V.spansMultiplePages = !0, V.height = 0;
                for (var nt = 0, N = 0, z = Q.columns; N < z.length; N++) {
                  var G = z[N], Y = V.cells[G.index];
                  if (Y) {
                    Array.isArray(Y.text) || (Y.text = [Y.text]);
                    var st = new d.Cell(Y.raw, Y.styles, Y.section);
                    st = (0, f.assign)(st, Y), st.text = [];
                    var vt = q(Y, R, H);
                    Y.text.length > vt && (st.text = Y.text.splice(vt, Y.text.length));
                    var mt = H.scaleFactor(), _t = H.getLineHeightFactor();
                    Y.contentHeight = Y.getContentHeight(mt, _t), Y.contentHeight >= R && (Y.contentHeight = R, st.styles.minCellHeight -= R), Y.contentHeight > V.height && (V.height = Y.contentHeight), st.contentHeight = st.getContentHeight(mt, _t), st.contentHeight > nt && (nt = st.contentHeight), ct[G.index] = st;
                  }
                }
                var Bt = new d.Row(V.raw, -1, V.section, ct, !0);
                Bt.height = nt;
                for (var Rt = 0, te = Q.columns; Rt < te.length; Rt++) {
                  var G = te[Rt], st = Bt.cells[G.index];
                  st && (st.height = Bt.height);
                  var Y = V.cells[G.index];
                  Y && (Y.height = V.height);
                }
                return Bt;
              }
              function F(V, R, Q, H) {
                var ct = V.pageSize().height, nt = H.settings.margin, N = nt.top + nt.bottom, z = ct - N;
                R.section === "body" && (z -= H.getHeadHeight(H.columns) + H.getFootHeight(H.columns));
                var G = R.getMinimumRowHeight(H.columns, V), Y = G < Q;
                if (G > z)
                  return console.error("Will not be able to print row ".concat(R.index, " correctly since it's minimum height is larger than page height")), !0;
                if (!Y)
                  return !1;
                var st = R.hasRowSpan(H.columns), vt = R.getMaxCellHeight(H.columns) > z;
                return vt ? (st && console.error("The content of row ".concat(R.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.")), !0) : !(st || H.settings.rowPageBreak === "avoid");
              }
              function M(V, R, Q, H, ct, nt, N) {
                var z = T(V, R, H, nt);
                if (Q.canEntireRowFit(z, N))
                  j(V, R, Q, nt, N);
                else if (F(V, Q, z, R)) {
                  var G = O(Q, z, R, V);
                  j(V, R, Q, nt, N), _(V, R, ct, nt, N), M(V, R, G, H, ct, nt, N);
                } else
                  _(V, R, ct, nt, N), M(V, R, Q, H, ct, nt, N);
              }
              function j(V, R, Q, H, ct) {
                H.x = R.settings.margin.left;
                for (var nt = 0, N = ct; nt < N.length; nt++) {
                  var z = N[nt], G = Q.cells[z.index];
                  if (!G) {
                    H.x += z.width;
                    continue;
                  }
                  V.applyStyles(G.styles), G.x = H.x, G.y = H.y;
                  var Y = R.callCellHooks(V, R.hooks.willDrawCell, G, Q, z, H);
                  if (Y === !1) {
                    H.x += z.width;
                    continue;
                  }
                  P(V, G, H);
                  var st = G.getTextPos();
                  (0, m.default)(G.text, st.x, st.y, {
                    halign: G.styles.halign,
                    valign: G.styles.valign,
                    maxWidth: Math.ceil(G.width - G.padding("left") - G.padding("right"))
                  }, V.getDocument()), R.callCellHooks(V, R.hooks.didDrawCell, G, Q, z, H), H.x += z.width;
                }
                H.y += Q.height;
              }
              function P(V, R, Q) {
                var H = R.styles;
                if (V.getDocument().setFillColor(V.getDocument().getFillColor()), typeof H.lineWidth == "number") {
                  var ct = (0, u.getFillStyle)(H.lineWidth, H.fillColor);
                  ct && V.rect(R.x, Q.y, R.width, R.height, ct);
                } else typeof H.lineWidth == "object" && (H.fillColor && V.rect(R.x, Q.y, R.width, R.height, "F"), A(V, R, Q, H.lineWidth));
              }
              function A(V, R, Q, H) {
                var ct, nt, N, z;
                H.top && (ct = Q.x, nt = Q.y, N = Q.x + R.width, z = Q.y, H.right && (N += 0.5 * H.right), H.left && (ct -= 0.5 * H.left), G(H.top, ct, nt, N, z)), H.bottom && (ct = Q.x, nt = Q.y + R.height, N = Q.x + R.width, z = Q.y + R.height, H.right && (N += 0.5 * H.right), H.left && (ct -= 0.5 * H.left), G(H.bottom, ct, nt, N, z)), H.left && (ct = Q.x, nt = Q.y, N = Q.x, z = Q.y + R.height, H.top && (nt -= 0.5 * H.top), H.bottom && (z += 0.5 * H.bottom), G(H.left, ct, nt, N, z)), H.right && (ct = Q.x + R.width, nt = Q.y, N = Q.x + R.width, z = Q.y + R.height, H.top && (nt -= 0.5 * H.top), H.bottom && (z += 0.5 * H.bottom), G(H.right, ct, nt, N, z));
                function G(Y, st, vt, mt, _t) {
                  V.getDocument().setLineWidth(Y), V.getDocument().line(st, vt, mt, _t, "S");
                }
              }
              function T(V, R, Q, H) {
                var ct = R.settings.margin.bottom, nt = R.settings.showFoot;
                return (nt === "everyPage" || nt === "lastPage" && Q) && (ct += R.getFootHeight(R.columns)), V.pageSize().height - H.y - ct;
              }
              function _(V, R, Q, H, ct, nt) {
                ct === void 0 && (ct = []), nt === void 0 && (nt = !1), V.applyStyles(V.userStyles), R.settings.showFoot === "everyPage" && !nt && R.foot.forEach(function(z) {
                  return j(V, R, z, H, ct);
                }), R.callEndPageHooks(V, H);
                var N = R.settings.margin;
                (0, u.addTableBorder)(V, R, Q, H), Z(V), R.pageNumber++, R.pageCount++, H.x = N.left, H.y = N.top, Q.y = N.top, R.callWillDrawPageHooks(V, H), R.settings.showHead === "everyPage" && (R.head.forEach(function(z) {
                  return j(V, R, z, H, ct);
                }), V.applyStyles(V.userStyles));
              }
              l.addPage = _;
              function Z(V) {
                var R = V.pageNumber();
                V.setPage(R + 1);
                var Q = V.pageNumber();
                return Q === R ? (V.addPage(), !0) : !1;
              }
            }
          ),
          /***/
          224: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.calculateAllColumnsCanFitInPage = void 0;
              var u = h(420);
              function d(f, m, b) {
                var x;
                b === void 0 && (b = {});
                var y = (0, u.getPageAvailableWidth)(f, m), v = /* @__PURE__ */ new Map(), k = [], C = [], I = [];
                m.settings.horizontalPageBreakRepeat, Array.isArray(m.settings.horizontalPageBreakRepeat) ? I = m.settings.horizontalPageBreakRepeat : (typeof m.settings.horizontalPageBreakRepeat == "string" || typeof m.settings.horizontalPageBreakRepeat == "number") && (I = [m.settings.horizontalPageBreakRepeat]), I.forEach(function(M) {
                  var j = m.columns.find(function(P) {
                    return P.dataKey === M || P.index === M;
                  });
                  j && !v.has(j.index) && (v.set(j.index, !0), k.push(j.index), C.push(m.columns[j.index]), y -= j.wrappedWidth);
                });
                for (var q = !0, O = (x = b == null ? void 0 : b.start) !== null && x !== void 0 ? x : 0; O < m.columns.length; ) {
                  if (v.has(O)) {
                    O++;
                    continue;
                  }
                  var F = m.columns[O].wrappedWidth;
                  if (q || y >= F)
                    q = !1, k.push(O), C.push(m.columns[O]), y -= F;
                  else
                    break;
                  O++;
                }
                return { colIndexes: k, columns: C, lastIndex: O - 1 };
              }
              function p(f, m) {
                for (var b = [], x = 0; x < m.columns.length; x++) {
                  var y = d(f, m, { start: x });
                  y.columns.length && (b.push(y), x = y.lastIndex);
                }
                return b;
              }
              l.calculateAllColumnsCanFitInPage = p;
            }
          ),
          /***/
          324: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.ellipsize = l.resizeColumns = l.calculateWidths = void 0;
              var u = h(420);
              function d(k, C) {
                p(k, C);
                var I = [], q = 0;
                C.columns.forEach(function(F) {
                  var M = F.getMaxCustomCellWidth(C);
                  M ? F.width = M : (F.width = F.wrappedWidth, I.push(F)), q += F.width;
                });
                var O = C.getWidth(k.pageSize().width) - q;
                O && (O = f(I, O, function(F) {
                  return Math.max(F.minReadableWidth, F.minWidth);
                })), O && (O = f(I, O, function(F) {
                  return F.minWidth;
                })), O = Math.abs(O), !C.settings.horizontalPageBreak && O > 0.1 / k.scaleFactor() && (O = O < 1 ? O : Math.round(O), console.warn("Of the table content, ".concat(O, " units width could not fit page"))), b(C), x(C, k), m(C);
              }
              l.calculateWidths = d;
              function p(k, C) {
                var I = k.scaleFactor(), q = C.settings.horizontalPageBreak, O = (0, u.getPageAvailableWidth)(k, C);
                C.allRows().forEach(function(F) {
                  for (var M = 0, j = C.columns; M < j.length; M++) {
                    var P = j[M], A = F.cells[P.index];
                    if (A) {
                      var T = C.hooks.didParseCell;
                      C.callCellHooks(k, T, A, F, P, null);
                      var _ = A.padding("horizontal");
                      A.contentWidth = (0, u.getStringWidth)(A.text, A.styles, k) + _;
                      var Z = (0, u.getStringWidth)(A.text.join(" ").split(/[^\S\u00A0]+/), A.styles, k);
                      if (A.minReadableWidth = Z + A.padding("horizontal"), typeof A.styles.cellWidth == "number")
                        A.minWidth = A.styles.cellWidth, A.wrappedWidth = A.styles.cellWidth;
                      else if (A.styles.cellWidth === "wrap" || q === !0)
                        A.contentWidth > O ? (A.minWidth = O, A.wrappedWidth = O) : (A.minWidth = A.contentWidth, A.wrappedWidth = A.contentWidth);
                      else {
                        var V = 10 / I;
                        A.minWidth = A.styles.minCellWidth || V, A.wrappedWidth = A.contentWidth, A.minWidth > A.wrappedWidth && (A.wrappedWidth = A.minWidth);
                      }
                    }
                  }
                }), C.allRows().forEach(function(F) {
                  for (var M = 0, j = C.columns; M < j.length; M++) {
                    var P = j[M], A = F.cells[P.index];
                    if (A && A.colSpan === 1)
                      P.wrappedWidth = Math.max(P.wrappedWidth, A.wrappedWidth), P.minWidth = Math.max(P.minWidth, A.minWidth), P.minReadableWidth = Math.max(P.minReadableWidth, A.minReadableWidth);
                    else {
                      var T = C.styles.columnStyles[P.dataKey] || C.styles.columnStyles[P.index] || {}, _ = T.cellWidth || T.minCellWidth;
                      _ && typeof _ == "number" && (P.minWidth = _, P.wrappedWidth = _);
                    }
                    A && (A.colSpan > 1 && !P.minWidth && (P.minWidth = A.minWidth), A.colSpan > 1 && !P.wrappedWidth && (P.wrappedWidth = A.minWidth));
                  }
                });
              }
              function f(k, C, I) {
                for (var q = C, O = k.reduce(function(V, R) {
                  return V + R.wrappedWidth;
                }, 0), F = 0; F < k.length; F++) {
                  var M = k[F], j = M.wrappedWidth / O, P = q * j, A = M.width + P, T = I(M), _ = A < T ? T : A;
                  C -= _ - M.width, M.width = _;
                }
                if (C = Math.round(C * 1e10) / 1e10, C) {
                  var Z = k.filter(function(V) {
                    return C < 0 ? V.width > I(V) : !0;
                  });
                  Z.length && (C = f(Z, C, I));
                }
                return C;
              }
              l.resizeColumns = f;
              function m(k) {
                for (var C = {}, I = 1, q = k.allRows(), O = 0; O < q.length; O++)
                  for (var F = q[O], M = 0, j = k.columns; M < j.length; M++) {
                    var P = j[M], A = C[P.index];
                    if (I > 1)
                      I--, delete F.cells[P.index];
                    else if (A)
                      A.cell.height += F.height, I = A.cell.colSpan, delete F.cells[P.index], A.left--, A.left <= 1 && delete C[P.index];
                    else {
                      var T = F.cells[P.index];
                      if (!T)
                        continue;
                      if (T.height = F.height, T.rowSpan > 1) {
                        var _ = q.length - O, Z = T.rowSpan > _ ? _ : T.rowSpan;
                        C[P.index] = { cell: T, left: Z, row: F };
                      }
                    }
                  }
              }
              function b(k) {
                for (var C = k.allRows(), I = 0; I < C.length; I++)
                  for (var q = C[I], O = null, F = 0, M = 0, j = 0; j < k.columns.length; j++) {
                    var P = k.columns[j];
                    if (M -= 1, M > 1 && k.columns[j + 1])
                      F += P.width, delete q.cells[P.index];
                    else if (O) {
                      var A = O;
                      delete q.cells[P.index], O = null, A.width = P.width + F;
                    } else {
                      var A = q.cells[P.index];
                      if (!A)
                        continue;
                      if (M = A.colSpan, F = 0, A.colSpan > 1) {
                        O = A, F += P.width;
                        continue;
                      }
                      A.width = P.width + F;
                    }
                  }
              }
              function x(k, C) {
                for (var I = { count: 0, height: 0 }, q = 0, O = k.allRows(); q < O.length; q++) {
                  for (var F = O[q], M = 0, j = k.columns; M < j.length; M++) {
                    var P = j[M], A = F.cells[P.index];
                    if (A) {
                      C.applyStyles(A.styles, !0);
                      var T = A.width - A.padding("horizontal");
                      if (A.styles.overflow === "linebreak")
                        A.text = C.splitTextToSize(A.text, T + 1 / C.scaleFactor(), { fontSize: A.styles.fontSize });
                      else if (A.styles.overflow === "ellipsize")
                        A.text = y(A.text, T, A.styles, C, "...");
                      else if (A.styles.overflow === "hidden")
                        A.text = y(A.text, T, A.styles, C, "");
                      else if (typeof A.styles.overflow == "function") {
                        var _ = A.styles.overflow(A.text, T);
                        typeof _ == "string" ? A.text = [_] : A.text = _;
                      }
                      A.contentHeight = A.getContentHeight(C.scaleFactor(), C.getLineHeightFactor());
                      var Z = A.contentHeight / A.rowSpan;
                      A.rowSpan > 1 && I.count * I.height < Z * A.rowSpan ? I = { height: Z, count: A.rowSpan } : I && I.count > 0 && I.height > Z && (Z = I.height), Z > F.height && (F.height = Z);
                    }
                  }
                  I.count--;
                }
              }
              function y(k, C, I, q, O) {
                return k.map(function(F) {
                  return v(F, C, I, q, O);
                });
              }
              l.ellipsize = y;
              function v(k, C, I, q, O) {
                var F = 1e4 * q.scaleFactor();
                if (C = Math.ceil(C * F) / F, C >= (0, u.getStringWidth)(k, I, q))
                  return k;
                for (; C < (0, u.getStringWidth)(k + O, I, q) && !(k.length <= 1); )
                  k = k.substring(0, k.length - 1);
                return k.trim() + O;
              }
            }
          ),
          /***/
          964: (
            /***/
            function(a) {
              if (typeof e > "u") {
                var l = new Error("Cannot find module 'undefined'");
                throw l.code = "MODULE_NOT_FOUND", l;
              }
              a.exports = e;
            }
          )
          /******/
        }, r = {};
        function s(a) {
          var l = r[a];
          if (l !== void 0)
            return l.exports;
          var h = r[a] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return i[a].call(h.exports, h, h.exports, s), h.exports;
        }
        var o = {};
        return function() {
          var a = o;
          Object.defineProperty(a, "__esModule", { value: !0 }), a.Cell = a.Column = a.Row = a.Table = a.CellHookData = a.__drawTable = a.__createTable = a.applyPlugin = void 0;
          var l = s(340), h = s(776), u = s(664), d = s(972), p = s(260);
          Object.defineProperty(a, "Table", { enumerable: !0, get: function() {
            return p.Table;
          } });
          var f = s(172);
          Object.defineProperty(a, "CellHookData", { enumerable: !0, get: function() {
            return f.CellHookData;
          } });
          var m = s(260);
          Object.defineProperty(a, "Cell", { enumerable: !0, get: function() {
            return m.Cell;
          } }), Object.defineProperty(a, "Column", { enumerable: !0, get: function() {
            return m.Column;
          } }), Object.defineProperty(a, "Row", { enumerable: !0, get: function() {
            return m.Row;
          } });
          function b(C) {
            (0, l.default)(C);
          }
          a.applyPlugin = b;
          function x(C, I) {
            var q = (0, h.parseInput)(C, I), O = (0, d.createTable)(C, q);
            (0, u.drawTable)(C, O);
          }
          function y(C, I) {
            var q = (0, h.parseInput)(C, I);
            return (0, d.createTable)(C, q);
          }
          a.__createTable = y;
          function v(C, I) {
            (0, u.drawTable)(C, I);
          }
          a.__drawTable = v;
          try {
            var k = s(964);
            k.jsPDF && (k = k.jsPDF), b(k);
          } catch {
          }
          a.default = x;
        }(), o;
      }()
    );
  });
})(q1);
var tw = q1.exports;
const na = /* @__PURE__ */ Oc(tw), ia = 5, dl = 10, Iu = ",", ra = {
  fillColor: [7, 59, 76],
  fontStyle: "normal"
}, sa = {
  fontSize: 9
}, oa = { left: 10 };
let aa = [];
const ew = (n, t, e = (i) => i.toString()) => {
  var u;
  const { t: i } = A2.global, r = new ke({ orientation: "landscape" });
  let s = 10;
  r.setFontSize(20), r.text(i("pdf.orderSummary"), 10, s), s += 15, r.setFontSize(14), r.text("Your parts", 10, s), s += ia, aa = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity"),
    i("name"),
    `Banding (${pr.join(Iu)})`,
    `Finish (${fr.join(Iu)})`
  ];
  const o = n.parts.map((d) => {
    var m;
    const p = pr.map((b) => d.banding[b] || "-").join(Iu), f = fr.map((b) => d.banding[b] || "-").join(Iu);
    return [
      e(d.l),
      e(d.w),
      e(d.t) || "-",
      ((m = d == null ? void 0 : d.material) == null ? void 0 : m.toUpperCase()) || "-",
      e(d.q),
      d.name || "-",
      p,
      f
    ];
  });
  na(r, {
    startY: s,
    head: [aa],
    body: o,
    margin: oa,
    headStyles: ra,
    styles: sa
  }), s = r.autoTable.previous.finalY + dl, r.setFontSize(14), r.text(i("pdf.stockRequirements"), 10, s), s += ia, aa = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity")
    // 'Cost'
  ];
  const a = n.stock.map((d) => {
    var p;
    return [
      e(d.l),
      e(d.w),
      e(d.t) || "-",
      ((p = d == null ? void 0 : d.material) == null ? void 0 : p.toUpperCase()) || "-",
      e(d.q)
      // stock.cost
    ];
  });
  na(r, {
    startY: s,
    head: [aa],
    body: a,
    margin: oa,
    headStyles: ra,
    styles: sa
  }), s = r.autoTable.previous.finalY + dl, r.setFontSize(14), r.text(i("pdf.rollRequirements"), 10, s), s += ia, aa = [
    i("name"),
    i("material"),
    i("length")
  ];
  const l = n.stock.map((d) => {
    var p, f;
    return [
      ((p = d == null ? void 0 : d.name) == null ? void 0 : p.toUpperCase()) || "-",
      ((f = d == null ? void 0 : d.material) == null ? void 0 : f.toUpperCase()) || "-",
      e(d.analysis.rollLength)
    ];
  });
  if (na(r, {
    startY: s,
    head: [aa],
    body: l,
    margin: oa,
    headStyles: ra,
    styles: sa
  }), s = r.autoTable.previous.finalY + dl, t && Object.values(t)) {
    r.setFontSize(14), r.text("Hardware", 10, s), s += ia;
    const d = Object.values(t).map((p) => [
      p.name.toUpperCase(),
      e(p.q)
      // item.totalCost.toFixed( 2 )
    ]);
    na(r, {
      startY: s,
      head: [[i("pdf.item"), i("quantity")]],
      body: d,
      margin: oa,
      headStyles: ra,
      styles: sa
    }), s = r.autoTable.previous.finalY + dl;
  }
  r.setFontSize(14), r.text(i("pdf.totals"), 10, s), s += ia;
  const h = [
    [i("pdf.totalParts"), e(n.metadata.totalPartsProduced)],
    [i("pdf.partArea"), e(n.metadata.totalPartArea)],
    [i("pdf.totalStockRequired"), e(n.metadata.totalUsedStock)],
    [i("pdf.totalBandingLength"), e(n.metadata.totalBandingLength)],
    [i("pdf.totalFinishArea"), e(n.metadata.totalFinishArea)],
    [i("pdf.totalRollLength"), e(n.metadata.totalRollLength)]
  ];
  if (na(r, {
    startY: s,
    body: h,
    margin: oa,
    headStyles: ra,
    styles: sa
  }), s = r.autoTable.previous.finalY + dl, (u = window == null ? void 0 : window.smartcutImages) != null && u.length) {
    r.addPage();
    let d = 10;
    r.setFontSize(14), r.text(i("pdf.images"), 10, d), d += ia;
    const p = window.smartcutImages.flatMap((f, m) => f.metadata.map((b) => [
      m + 1,
      b.newName
    ]));
    na(r, {
      startY: d,
      body: p,
      head: [[i("pdf.partIndex"), i("pdf.fileName")]],
      margin: oa,
      headStyles: ra,
      styles: sa
    });
  }
  return r.output("datauristring");
};
function nw(n) {
  return C2() ? (P2(n), !0) : !1;
}
function Ad(n) {
  return typeof n == "function" ? n() : Ie(n);
}
const iw = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const rw = Object.prototype.toString, sw = (n) => rw.call(n) === "[object Object]", ow = () => {
};
function aw(n, t) {
  function e(...i) {
    return new Promise((r, s) => {
      Promise.resolve(n(() => t.apply(this, i), { fn: t, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return e;
}
const z1 = (n) => n();
function lw(n = z1) {
  const t = Ce(!0);
  function e() {
    t.value = !1;
  }
  function i() {
    t.value = !0;
  }
  const r = (...s) => {
    t.value && n(...s);
  };
  return { isActive: N2(t), pause: e, resume: i, eventFilter: r };
}
function uw(n) {
  return L2();
}
function cw(n, t, e = {}) {
  const {
    eventFilter: i = z1,
    ...r
  } = e;
  return hr(
    n,
    aw(
      i,
      t
    ),
    r
  );
}
function hw(n, t, e = {}) {
  const {
    eventFilter: i,
    ...r
  } = e, { eventFilter: s, pause: o, resume: a, isActive: l } = lw(i);
  return { stop: cw(
    n,
    t,
    {
      ...r,
      eventFilter: s
    }
  ), pause: o, resume: a, isActive: l };
}
function fw(n, t = !0, e) {
  uw() ? Lo(n, e) : t ? n() : Qr(n);
}
function dw(n) {
  var t;
  const e = Ad(n);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const uc = iw ? window : void 0;
function cg(...n) {
  let t, e, i, r;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([e, i, r] = n, t = uc) : [t, e, i, r] = n, !t)
    return ow;
  Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
  const s = [], o = () => {
    s.forEach((u) => u()), s.length = 0;
  }, a = (u, d, p, f) => (u.addEventListener(d, p, f), () => u.removeEventListener(d, p, f)), l = hr(
    () => [dw(t), Ad(r)],
    ([u, d]) => {
      if (o(), !u)
        return;
      const p = sw(d) ? { ...d } : d;
      s.push(
        ...e.flatMap((f) => i.map((m) => a(u, f, m, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), h = () => {
    l(), o();
  };
  return nw(h), h;
}
const Eu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ou = "__vueuse_ssr_handlers__", pw = /* @__PURE__ */ gw();
function gw() {
  return Ou in Eu || (Eu[Ou] = Eu[Ou] || {}), Eu[Ou];
}
function mw(n, t) {
  return pw[n] || t;
}
function yw(n) {
  return n == null ? "any" : n instanceof Set ? "set" : n instanceof Map ? "map" : n instanceof Date ? "date" : typeof n == "boolean" ? "boolean" : typeof n == "string" ? "string" : typeof n == "object" ? "object" : Number.isNaN(n) ? "any" : "number";
}
const bw = {
  boolean: {
    read: (n) => n === "true",
    write: (n) => String(n)
  },
  object: {
    read: (n) => JSON.parse(n),
    write: (n) => JSON.stringify(n)
  },
  number: {
    read: (n) => Number.parseFloat(n),
    write: (n) => String(n)
  },
  any: {
    read: (n) => n,
    write: (n) => String(n)
  },
  string: {
    read: (n) => n,
    write: (n) => String(n)
  },
  map: {
    read: (n) => new Map(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n.entries()))
  },
  set: {
    read: (n) => new Set(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n))
  },
  date: {
    read: (n) => new Date(n),
    write: (n) => n.toISOString()
  }
}, hg = "vueuse-storage";
function vw(n, t, e, i = {}) {
  var r;
  const {
    flush: s = "pre",
    deep: o = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: h = !1,
    shallow: u,
    window: d = uc,
    eventFilter: p,
    onError: f = (j) => {
      console.error(j);
    },
    initOnMounted: m
  } = i, b = (u ? uo : Ce)(typeof t == "function" ? t() : t);
  if (!e)
    try {
      e = mw("getDefaultStorage", () => {
        var j;
        return (j = uc) == null ? void 0 : j.localStorage;
      })();
    } catch (j) {
      f(j);
    }
  if (!e)
    return b;
  const x = Ad(t), y = yw(x), v = (r = i.serializer) != null ? r : bw[y], { pause: k, resume: C } = hw(
    b,
    () => q(b.value),
    { flush: s, deep: o, eventFilter: p }
  );
  d && a && fw(() => {
    cg(d, "storage", F), cg(d, hg, M), m && F();
  }), m || F();
  function I(j, P) {
    d && d.dispatchEvent(new CustomEvent(hg, {
      detail: {
        key: n,
        oldValue: j,
        newValue: P,
        storageArea: e
      }
    }));
  }
  function q(j) {
    try {
      const P = e.getItem(n);
      if (j == null)
        I(P, null), e.removeItem(n);
      else {
        const A = v.write(j);
        P !== A && (e.setItem(n, A), I(P, A));
      }
    } catch (P) {
      f(P);
    }
  }
  function O(j) {
    const P = j ? j.newValue : e.getItem(n);
    if (P == null)
      return l && x != null && e.setItem(n, v.write(x)), x;
    if (!j && h) {
      const A = v.read(P);
      return typeof h == "function" ? h(A, x) : y === "object" && !Array.isArray(A) ? { ...x, ...A } : A;
    } else return typeof P != "string" ? P : v.read(P);
  }
  function F(j) {
    if (!(j && j.storageArea !== e)) {
      if (j && j.key == null) {
        b.value = x;
        return;
      }
      if (!(j && j.key !== n)) {
        k();
        try {
          (j == null ? void 0 : j.newValue) !== v.write(b.value) && (b.value = O(j));
        } catch (P) {
          f(P);
        } finally {
          j ? Qr(C) : C();
        }
      }
    }
  }
  function M(j) {
    F(j.detail);
  }
  return b;
}
function fg(n, t, e = {}) {
  const { window: i = uc } = e;
  return vw(n, t, i == null ? void 0 : i.localStorage, e);
}
const Xn = [];
for (let n = 0; n < 256; ++n)
  Xn.push((n + 256).toString(16).slice(1));
function ww(n, t = 0) {
  return (Xn[n[t + 0]] + Xn[n[t + 1]] + Xn[n[t + 2]] + Xn[n[t + 3]] + "-" + Xn[n[t + 4]] + Xn[n[t + 5]] + "-" + Xn[n[t + 6]] + Xn[n[t + 7]] + "-" + Xn[n[t + 8]] + Xn[n[t + 9]] + "-" + Xn[n[t + 10]] + Xn[n[t + 11]] + Xn[n[t + 12]] + Xn[n[t + 13]] + Xn[n[t + 14]] + Xn[n[t + 15]]).toLowerCase();
}
let Eh;
const xw = new Uint8Array(16);
function _w() {
  if (!Eh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Eh = crypto.getRandomValues.bind(crypto);
  }
  return Eh(xw);
}
const Sw = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), dg = { randomUUID: Sw };
function kw(n, t, e) {
  if (dg.randomUUID && !t && !n)
    return dg.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || _w)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, ww(i);
}
const Mr = /* @__PURE__ */ Object.create(null);
Mr.open = "0";
Mr.close = "1";
Mr.ping = "2";
Mr.pong = "3";
Mr.message = "4";
Mr.upgrade = "5";
Mr.noop = "6";
const Wu = /* @__PURE__ */ Object.create(null);
Object.keys(Mr).forEach((n) => {
  Wu[Mr[n]] = n;
});
const bf = { type: "error", data: "parser error" }, $1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", U1 = typeof ArrayBuffer == "function", W1 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, Nd = ({ type: n, data: t }, e, i) => $1 && t instanceof Blob ? e ? i(t) : pg(t, i) : U1 && (t instanceof ArrayBuffer || W1(t)) ? e ? i(t) : pg(new Blob([t]), i) : i(Mr[n] + (t || "")), pg = (n, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const i = e.result.split(",")[1];
    t("b" + (i || ""));
  }, e.readAsDataURL(n);
};
function gg(n) {
  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
}
let Oh;
function Aw(n, t) {
  if ($1 && n.data instanceof Blob)
    return n.data.arrayBuffer().then(gg).then(t);
  if (U1 && (n.data instanceof ArrayBuffer || W1(n.data)))
    return t(gg(n.data));
  Nd(n, !1, (e) => {
    Oh || (Oh = new TextEncoder()), t(Oh.encode(e));
  });
}
const mg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bl = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < mg.length; n++)
  bl[mg.charCodeAt(n)] = n;
const Nw = (n) => {
  let t = n.length * 0.75, e = n.length, i, r = 0, s, o, a, l;
  n[n.length - 1] === "=" && (t--, n[n.length - 2] === "=" && t--);
  const h = new ArrayBuffer(t), u = new Uint8Array(h);
  for (i = 0; i < e; i += 4)
    s = bl[n.charCodeAt(i)], o = bl[n.charCodeAt(i + 1)], a = bl[n.charCodeAt(i + 2)], l = bl[n.charCodeAt(i + 3)], u[r++] = s << 2 | o >> 4, u[r++] = (o & 15) << 4 | a >> 2, u[r++] = (a & 3) << 6 | l & 63;
  return h;
}, Cw = typeof ArrayBuffer == "function", Cd = (n, t) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: H1(n, t)
    };
  const e = n.charAt(0);
  return e === "b" ? {
    type: "message",
    data: Pw(n.substring(1), t)
  } : Wu[e] ? n.length > 1 ? {
    type: Wu[e],
    data: n.substring(1)
  } : {
    type: Wu[e]
  } : bf;
}, Pw = (n, t) => {
  if (Cw) {
    const e = Nw(n);
    return H1(e, t);
  } else
    return { base64: !0, data: n };
}, H1 = (n, t) => {
  switch (t) {
    case "blob":
      return n instanceof Blob ? n : new Blob([n]);
    case "arraybuffer":
    default:
      return n instanceof ArrayBuffer ? n : n.buffer;
  }
}, G1 = "", Lw = (n, t) => {
  const e = n.length, i = new Array(e);
  let r = 0;
  n.forEach((s, o) => {
    Nd(s, !1, (a) => {
      i[o] = a, ++r === e && t(i.join(G1));
    });
  });
}, Iw = (n, t) => {
  const e = n.split(G1), i = [];
  for (let r = 0; r < e.length; r++) {
    const s = Cd(e[r], t);
    if (i.push(s), s.type === "error")
      break;
  }
  return i;
};
function Ew() {
  return new TransformStream({
    transform(n, t) {
      Aw(n, (e) => {
        const i = e.length;
        let r;
        if (i < 126)
          r = new Uint8Array(1), new DataView(r.buffer).setUint8(0, i);
        else if (i < 65536) {
          r = new Uint8Array(3);
          const s = new DataView(r.buffer);
          s.setUint8(0, 126), s.setUint16(1, i);
        } else {
          r = new Uint8Array(9);
          const s = new DataView(r.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(i));
        }
        n.data && typeof n.data != "string" && (r[0] |= 128), t.enqueue(r), t.enqueue(e);
      });
    }
  });
}
let Th;
function Tu(n) {
  return n.reduce((t, e) => t + e.length, 0);
}
function Fu(n, t) {
  if (n[0].length === t)
    return n.shift();
  const e = new Uint8Array(t);
  let i = 0;
  for (let r = 0; r < t; r++)
    e[r] = n[0][i++], i === n[0].length && (n.shift(), i = 0);
  return n.length && i < n[0].length && (n[0] = n[0].slice(i)), e;
}
function Ow(n, t) {
  Th || (Th = new TextDecoder());
  const e = [];
  let i = 0, r = -1, s = !1;
  return new TransformStream({
    transform(o, a) {
      for (e.push(o); ; ) {
        if (i === 0) {
          if (Tu(e) < 1)
            break;
          const l = Fu(e, 1);
          s = (l[0] & 128) === 128, r = l[0] & 127, r < 126 ? i = 3 : r === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (Tu(e) < 2)
            break;
          const l = Fu(e, 2);
          r = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (Tu(e) < 8)
            break;
          const l = Fu(e, 8), h = new DataView(l.buffer, l.byteOffset, l.length), u = h.getUint32(0);
          if (u > Math.pow(2, 21) - 1) {
            a.enqueue(bf);
            break;
          }
          r = u * Math.pow(2, 32) + h.getUint32(4), i = 3;
        } else {
          if (Tu(e) < r)
            break;
          const l = Fu(e, r);
          a.enqueue(Cd(s ? l : Th.decode(l), t)), i = 0;
        }
        if (r === 0 || r > n) {
          a.enqueue(bf);
          break;
        }
      }
    }
  });
}
const V1 = 4;
function Dn(n) {
  if (n) return Tw(n);
}
function Tw(n) {
  for (var t in Dn.prototype)
    n[t] = Dn.prototype[t];
  return n;
}
Dn.prototype.on = Dn.prototype.addEventListener = function(n, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(t), this;
};
Dn.prototype.once = function(n, t) {
  function e() {
    this.off(n, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(n, e), this;
};
Dn.prototype.off = Dn.prototype.removeListener = Dn.prototype.removeAllListeners = Dn.prototype.removeEventListener = function(n, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + n];
  if (!e) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var i, r = 0; r < e.length; r++)
    if (i = e[r], i === t || i.fn === t) {
      e.splice(r, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + n], this;
};
Dn.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + n], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (e) {
    e = e.slice(0);
    for (var i = 0, r = e.length; i < r; ++i)
      e[i].apply(this, t);
  }
  return this;
};
Dn.prototype.emitReserved = Dn.prototype.emit;
Dn.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Dn.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const Bc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0), Xi = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), Fw = "arraybuffer";
function Y1(n, ...t) {
  return t.reduce((e, i) => (n.hasOwnProperty(i) && (e[i] = n[i]), e), {});
}
const Mw = Xi.setTimeout, Rw = Xi.clearTimeout;
function jc(n, t) {
  t.useNativeTimers ? (n.setTimeoutFn = Mw.bind(Xi), n.clearTimeoutFn = Rw.bind(Xi)) : (n.setTimeoutFn = Xi.setTimeout.bind(Xi), n.clearTimeoutFn = Xi.clearTimeout.bind(Xi));
}
const Dw = 1.33;
function Bw(n) {
  return typeof n == "string" ? jw(n) : Math.ceil((n.byteLength || n.size) * Dw);
}
function jw(n) {
  let t = 0, e = 0;
  for (let i = 0, r = n.length; i < r; i++)
    t = n.charCodeAt(i), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (i++, e += 4);
  return e;
}
function K1() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function qw(n) {
  let t = "";
  for (let e in n)
    n.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(n[e]));
  return t;
}
function zw(n) {
  let t = {}, e = n.split("&");
  for (let i = 0, r = e.length; i < r; i++) {
    let s = e[i].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
class $w extends Error {
  constructor(t, e, i) {
    super(t), this.description = e, this.context = i, this.type = "TransportError";
  }
}
class Pd extends Dn {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, jc(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, i) {
    return super.emitReserved("error", new $w(t, e, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = Cd(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, e = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(e);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const e = qw(t);
    return e.length ? "?" + e : "";
  }
}
class Uw extends Pd {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || e();
      })), this.writable || (i++, this.once("drain", function() {
        --i || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    Iw(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, Lw(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", e = this.query || {};
    return this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = K1()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.createUri(t, e);
  }
}
let X1 = !1;
try {
  X1 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Ww = X1;
function Hw() {
}
class Gw extends Uw {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const e = location.protocol === "https:";
      let i = location.port;
      i || (i = e ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", e), i.on("error", (r, s) => {
      this.onError("xhr post error", r, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, i) => {
      this.onError("xhr poll error", e, i);
    }), this.pollXhr = t;
  }
}
class Tr extends Dn {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e, i) {
    super(), this.createRequest = t, jc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = e, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const e = Y1(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(e);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let r in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(r) && i.setRequestHeader(r, this._opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var r;
        i.readyState === 3 && ((r = this._opts.cookieJar) === null || r === void 0 || r.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this._onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Tr.requestsCount++, Tr.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = Hw, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Tr.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Tr.requestsCount = 0;
Tr.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", yg);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in Xi ? "pagehide" : "unload";
    addEventListener(n, yg, !1);
  }
}
function yg() {
  for (let n in Tr.requests)
    Tr.requests.hasOwnProperty(n) && Tr.requests[n].abort();
}
const Vw = function() {
  const n = J1({
    xdomain: !1
  });
  return n && n.responseType !== null;
}();
class Yw extends Gw {
  constructor(t) {
    super(t);
    const e = t && t.forceBase64;
    this.supportsBinary = Vw && !e;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new Tr(J1, this.uri(), t);
  }
}
function J1(n) {
  const t = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || Ww))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new Xi[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Z1 = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Kw extends Pd {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), e = this.opts.protocols, i = Z1 ? {} : Y1(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, e, i);
    } catch (r) {
      return this.emitReserved("error", r);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      Nd(i, this.supportsBinary, (s) => {
        try {
          this.doWrite(i, s);
        } catch {
        }
        r && Bc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", e = this.query || {};
    return this.opts.timestampRequests && (e[this.opts.timestampParam] = K1()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e);
  }
}
const Fh = Xi.WebSocket || Xi.MozWebSocket;
class Xw extends Kw {
  createSocket(t, e, i) {
    return Z1 ? new Fh(t, e, i) : e ? new Fh(t, e) : new Fh(t);
  }
  doWrite(t, e) {
    this.ws.send(e);
  }
}
class Jw extends Pd {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const e = Ow(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(e).getReader(), r = Ew();
        r.readable.pipeTo(t.writable), this._writer = r.writable.getWriter();
        const s = () => {
          i.read().then(({ done: a, value: l }) => {
            a || (this.onPacket(l), s());
          }).catch((a) => {
          });
        };
        s();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      this._writer.write(i).then(() => {
        r && Bc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const Zw = {
  websocket: Xw,
  webtransport: Jw,
  polling: Yw
}, Qw = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, t3 = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function vf(n) {
  if (n.length > 8e3)
    throw "URI too long";
  const t = n, e = n.indexOf("["), i = n.indexOf("]");
  e != -1 && i != -1 && (n = n.substring(0, e) + n.substring(e, i).replace(/:/g, ";") + n.substring(i, n.length));
  let r = Qw.exec(n || ""), s = {}, o = 14;
  for (; o--; )
    s[t3[o]] = r[o] || "";
  return e != -1 && i != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = e3(s, s.path), s.queryKey = n3(s, s.query), s;
}
function e3(n, t) {
  const e = /\/{2,9}/g, i = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function n3(n, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, r, s) {
    r && (e[r] = s);
  }), e;
}
const wf = typeof addEventListener == "function" && typeof removeEventListener == "function", Hu = [];
wf && addEventListener("offline", () => {
  Hu.forEach((n) => n());
}, !1);
class Bs extends Dn {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e) {
    if (super(), this.binaryType = Fw, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (e = t, t = null), t) {
      const i = vf(t);
      e.hostname = i.host, e.secure = i.protocol === "https" || i.protocol === "wss", e.port = i.port, i.query && (e.query = i.query);
    } else e.host && (e.hostname = vf(e.host).host);
    jc(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, e.transports.forEach((i) => {
      const r = i.prototype.name;
      this.transports.push(r), this._transportsByName[r] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = zw(this.opts.query)), wf && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, Hu.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = V1, e.transport = t, this.id && (e.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && Bs.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const e = this.createTransport(t);
    e.open(), this.setTransport(e);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (e) => this._onClose("transport close", e));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", Bs.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this._onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const r = this.writeBuffer[i].data;
      if (r && (e += Bw(r)), i > 0 && e > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, Bc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, e, i, r) {
    if (typeof e == "function" && (r = e, e = void 0), typeof i == "function" && (r = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: i
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), r && this.once("flush", r), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, i = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (Bs.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), wf && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = Hu.indexOf(this._offlineEventListener);
        i !== -1 && Hu.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
Bs.protocol = V1;
class i3 extends Bs {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let e = this.createTransport(t), i = !1;
    Bs.priorWebsocketSuccess = !1;
    const r = () => {
      i || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (d) => {
        if (!i)
          if (d.type === "pong" && d.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Bs.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (u(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const p = new Error("probe error");
            p.transport = e.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function s() {
      i || (i = !0, u(), e.close(), e = null);
    }
    const o = (d) => {
      const p = new Error("probe error: " + d);
      p.transport = e.name, s(), this.emitReserved("upgradeError", p);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function h(d) {
      e && d.name !== e.name && s();
    }
    const u = () => {
      e.removeListener("open", r), e.removeListener("error", o), e.removeListener("close", a), this.off("close", l), this.off("upgrading", h);
    };
    e.once("open", r), e.once("error", o), e.once("close", a), this.once("close", l), this.once("upgrading", h), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      i || e.open();
    }, 200) : e.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const e = [];
    for (let i = 0; i < t.length; i++)
      ~this.transports.indexOf(t[i]) && e.push(t[i]);
    return e;
  }
}
let r3 = class extends i3 {
  constructor(t, e = {}) {
    const i = typeof t == "object" ? t : e;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((r) => Zw[r]).filter((r) => !!r)), super(t, i);
  }
};
function s3(n, t = "", e) {
  let i = n;
  e = e || typeof location < "u" && location, n == null && (n = e.protocol + "//" + e.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = e.protocol + n : n = e.host + n), /^(https?|wss?):\/\//.test(n) || (typeof e < "u" ? n = e.protocol + "//" + n : n = "https://" + n), i = vf(n)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + s + ":" + i.port + t, i.href = i.protocol + "://" + s + (e && e.port === i.port ? "" : ":" + i.port), i;
}
const o3 = typeof ArrayBuffer == "function", a3 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Q1 = Object.prototype.toString, l3 = typeof Blob == "function" || typeof Blob < "u" && Q1.call(Blob) === "[object BlobConstructor]", u3 = typeof File == "function" || typeof File < "u" && Q1.call(File) === "[object FileConstructor]";
function Ld(n) {
  return o3 && (n instanceof ArrayBuffer || a3(n)) || l3 && n instanceof Blob || u3 && n instanceof File;
}
function Gu(n, t) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let e = 0, i = n.length; e < i; e++)
      if (Gu(n[e]))
        return !0;
    return !1;
  }
  if (Ld(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return Gu(n.toJSON(), !0);
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e) && Gu(n[e]))
      return !0;
  return !1;
}
function c3(n) {
  const t = [], e = n.data, i = n;
  return i.data = xf(e, t), i.attachments = t.length, { packet: i, buffers: t };
}
function xf(n, t) {
  if (!n)
    return n;
  if (Ld(n)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(n), e;
  } else if (Array.isArray(n)) {
    const e = new Array(n.length);
    for (let i = 0; i < n.length; i++)
      e[i] = xf(n[i], t);
    return e;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const e = {};
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = xf(n[i], t));
    return e;
  }
  return n;
}
function h3(n, t) {
  return n.data = _f(n.data, t), delete n.attachments, n;
}
function _f(n, t) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < t.length)
      return t[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let e = 0; e < n.length; e++)
      n[e] = _f(n[e], t);
  else if (typeof n == "object")
    for (const e in n)
      Object.prototype.hasOwnProperty.call(n, e) && (n[e] = _f(n[e], t));
  return n;
}
const f3 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], d3 = 5;
var ze;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(ze || (ze = {}));
class p3 {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === ze.EVENT || t.type === ze.ACK) && Gu(t) ? this.encodeAsBinary({
      type: t.type === ze.EVENT ? ze.BINARY_EVENT : ze.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === ze.BINARY_EVENT || t.type === ze.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = c3(t), i = this.encodeAsString(e.packet), r = e.buffers;
    return r.unshift(i), r;
  }
}
function bg(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
class Id extends Dn {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const i = e.type === ze.BINARY_EVENT;
      i || e.type === ze.BINARY_ACK ? (e.type = i ? ze.EVENT : ze.ACK, this.reconstructor = new g3(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (Ld(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (ze[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === ze.BINARY_EVENT || i.type === ze.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const o = t.substring(s, e);
      if (o != Number(o) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(o);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      i.nsp = t.substring(s, e);
    } else
      i.nsp = "/";
    const r = t.charAt(e + 1);
    if (r !== "" && Number(r) == r) {
      const s = e + 1;
      for (; ++e; ) {
        const o = t.charAt(e);
        if (o == null || Number(o) != o) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      i.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (Id.isPayloadValid(i.type, s))
        i.data = s;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case ze.CONNECT:
        return bg(e);
      case ze.DISCONNECT:
        return e === void 0;
      case ze.CONNECT_ERROR:
        return typeof e == "string" || bg(e);
      case ze.EVENT:
      case ze.BINARY_EVENT:
        return Array.isArray(e) && (typeof e[0] == "number" || typeof e[0] == "string" && f3.indexOf(e[0]) === -1);
      case ze.ACK:
      case ze.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class g3 {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = h3(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const m3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Decoder: Id, Encoder: p3, get PacketType() {
  return ze;
}, protocol: d3 }, Symbol.toStringTag, { value: "Module" }));
function ur(n, t, e) {
  return n.on(t, e), function() {
    n.off(t, e);
  };
}
const y3 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class tm extends Dn {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      ur(t, "open", this.onopen.bind(this)),
      ur(t, "packet", this.onpacket.bind(this)),
      ur(t, "error", this.onerror.bind(this)),
      ur(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    var i, r, s;
    if (y3.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const o = {
      type: ze.EVENT,
      data: e
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const u = this.ids++, d = e.pop();
      this._registerAckCallback(u, d), o.id = u;
    }
    const a = (r = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || r === void 0 ? void 0 : r.writable, l = this.connected && !(!((s = this.io.engine) === null || s === void 0) && s._hasPingExpired());
    return this.flags.volatile && !a || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var i;
    const r = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (r === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      e.call(this, new Error("operation has timed out"));
    }, r), o = (...a) => {
      this.io.clearTimeoutFn(s), e.apply(this, a);
    };
    o.withError = !0, this.acks[t] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    return new Promise((i, r) => {
      const s = (o, a) => o ? r(o) : i(a);
      s.withError = !0, e.push(s), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((r, ...s) => i !== this._queue[0] ? void 0 : (r !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(r)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: ze.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((i) => String(i.id) === t)) {
        const i = this.acks[t];
        delete this.acks[t], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case ze.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case ze.EVENT:
        case ze.BINARY_EVENT:
          this.onevent(t);
          break;
        case ze.ACK:
        case ze.BINARY_ACK:
          this.onack(t);
          break;
        case ze.DISCONNECT:
          this.ondisconnect();
          break;
        case ze.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const i of e)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let i = !1;
    return function(...r) {
      i || (i = !0, e.packet({
        type: ze.ACK,
        id: t,
        data: r
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (delete this.acks[t.id], e.withError && t.data.unshift(null), e.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: ze.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const i of e)
        i.apply(this, t.data);
    }
  }
}
function Na(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
Na.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * n);
    n = Math.floor(t * 10) & 1 ? n + e : n - e;
  }
  return Math.min(n, this.max) | 0;
};
Na.prototype.reset = function() {
  this.attempts = 0;
};
Na.prototype.setMin = function(n) {
  this.ms = n;
};
Na.prototype.setMax = function(n) {
  this.max = n;
};
Na.prototype.setJitter = function(n) {
  this.jitter = n;
};
class Sf extends Dn {
  constructor(t, e) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, jc(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((i = e.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Na({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const r = e.parser || m3;
    this.encoder = new r.Encoder(), this.decoder = new r.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new r3(this.uri, this.opts);
    const e = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const r = ur(e, "open", function() {
      i.onopen(), t && t();
    }), s = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), t ? t(a) : this.maybeReconnectOnOpen();
    }, o = ur(e, "error", s);
    if (this._timeout !== !1) {
      const a = this._timeout, l = this.setTimeoutFn(() => {
        r(), s(new Error("timeout")), e.close();
      }, a);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(r), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      ur(t, "ping", this.onping.bind(this)),
      ur(t, "data", this.ondata.bind(this)),
      ur(t, "error", this.onerror.bind(this)),
      ur(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      ur(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    Bc(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new tm(this, t, e), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const i of e)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let i = 0; i < e.length; i++)
      this.engine.write(e[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, e) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((r) => {
          r ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", r)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const pl = {};
function Vu(n, t) {
  typeof n == "object" && (t = n, n = void 0), t = t || {};
  const e = s3(n, t.path || "/socket.io"), i = e.source, r = e.id, s = e.path, o = pl[r] && s in pl[r].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
  let l;
  return a ? l = new Sf(i, t) : (pl[r] || (pl[r] = new Sf(i, t)), l = pl[r]), e.query && !t.query && (t.query = e.queryKey), l.socket(e.path, t);
}
Object.assign(Vu, {
  Manager: Sf,
  Socket: tm,
  io: Vu,
  connect: Vu
});
var b3 = typeof global == "object" && global && global.Object === Object && global, v3 = typeof self == "object" && self && self.Object === Object && self, Ed = b3 || v3 || Function("return this")(), xa = Ed.Symbol, em = Object.prototype, w3 = em.hasOwnProperty, x3 = em.toString, gl = xa ? xa.toStringTag : void 0;
function _3(n) {
  var t = w3.call(n, gl), e = n[gl];
  try {
    n[gl] = void 0;
    var i = !0;
  } catch {
  }
  var r = x3.call(n);
  return i && (t ? n[gl] = e : delete n[gl]), r;
}
var S3 = Object.prototype, k3 = S3.toString;
function A3(n) {
  return k3.call(n);
}
var N3 = "[object Null]", C3 = "[object Undefined]", vg = xa ? xa.toStringTag : void 0;
function nm(n) {
  return n == null ? n === void 0 ? C3 : N3 : vg && vg in Object(n) ? _3(n) : A3(n);
}
function P3(n) {
  return n != null && typeof n == "object";
}
var L3 = "[object Symbol]";
function Od(n) {
  return typeof n == "symbol" || P3(n) && nm(n) == L3;
}
function I3(n, t) {
  for (var e = -1, i = n == null ? 0 : n.length, r = Array(i); ++e < i; )
    r[e] = t(n[e], e, n);
  return r;
}
var Td = Array.isArray, E3 = 1 / 0, wg = xa ? xa.prototype : void 0, xg = wg ? wg.toString : void 0;
function im(n) {
  if (typeof n == "string")
    return n;
  if (Td(n))
    return I3(n, im) + "";
  if (Od(n))
    return xg ? xg.call(n) : "";
  var t = n + "";
  return t == "0" && 1 / n == -E3 ? "-0" : t;
}
function cc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
var O3 = "[object AsyncFunction]", T3 = "[object Function]", F3 = "[object GeneratorFunction]", M3 = "[object Proxy]";
function R3(n) {
  if (!cc(n))
    return !1;
  var t = nm(n);
  return t == T3 || t == F3 || t == O3 || t == M3;
}
var Mh = Ed["__core-js_shared__"], _g = function() {
  var n = /[^.]+$/.exec(Mh && Mh.keys && Mh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function D3(n) {
  return !!_g && _g in n;
}
var B3 = Function.prototype, j3 = B3.toString;
function q3(n) {
  if (n != null) {
    try {
      return j3.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var z3 = /[\\^$.*+?()[\]{}|]/g, $3 = /^\[object .+?Constructor\]$/, U3 = Function.prototype, W3 = Object.prototype, H3 = U3.toString, G3 = W3.hasOwnProperty, V3 = RegExp(
  "^" + H3.call(G3).replace(z3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Y3(n) {
  if (!cc(n) || D3(n))
    return !1;
  var t = R3(n) ? V3 : $3;
  return t.test(q3(n));
}
function K3(n, t) {
  return n == null ? void 0 : n[t];
}
function Fd(n, t) {
  var e = K3(n, t);
  return Y3(e) ? e : void 0;
}
var Sg = function() {
  try {
    var n = Fd(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), X3 = 9007199254740991, J3 = /^(?:0|[1-9]\d*)$/;
function Z3(n, t) {
  var e = typeof n;
  return t = t ?? X3, !!t && (e == "number" || e != "symbol" && J3.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function Q3(n, t, e) {
  t == "__proto__" && Sg ? Sg(n, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : n[t] = e;
}
function rm(n, t) {
  return n === t || n !== n && t !== t;
}
var tx = Object.prototype, ex = tx.hasOwnProperty;
function nx(n, t, e) {
  var i = n[t];
  (!(ex.call(n, t) && rm(i, e)) || e === void 0 && !(t in n)) && Q3(n, t, e);
}
var ix = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rx = /^\w*$/;
function sx(n, t) {
  if (Td(n))
    return !1;
  var e = typeof n;
  return e == "number" || e == "symbol" || e == "boolean" || n == null || Od(n) ? !0 : rx.test(n) || !ix.test(n) || t != null && n in Object(t);
}
var Il = Fd(Object, "create");
function ox() {
  this.__data__ = Il ? Il(null) : {}, this.size = 0;
}
function ax(n) {
  var t = this.has(n) && delete this.__data__[n];
  return this.size -= t ? 1 : 0, t;
}
var lx = "__lodash_hash_undefined__", ux = Object.prototype, cx = ux.hasOwnProperty;
function hx(n) {
  var t = this.__data__;
  if (Il) {
    var e = t[n];
    return e === lx ? void 0 : e;
  }
  return cx.call(t, n) ? t[n] : void 0;
}
var fx = Object.prototype, dx = fx.hasOwnProperty;
function px(n) {
  var t = this.__data__;
  return Il ? t[n] !== void 0 : dx.call(t, n);
}
var gx = "__lodash_hash_undefined__";
function mx(n, t) {
  var e = this.__data__;
  return this.size += this.has(n) ? 0 : 1, e[n] = Il && t === void 0 ? gx : t, this;
}
function Po(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Po.prototype.clear = ox;
Po.prototype.delete = ax;
Po.prototype.get = hx;
Po.prototype.has = px;
Po.prototype.set = mx;
function yx() {
  this.__data__ = [], this.size = 0;
}
function qc(n, t) {
  for (var e = n.length; e--; )
    if (rm(n[e][0], t))
      return e;
  return -1;
}
var bx = Array.prototype, vx = bx.splice;
function wx(n) {
  var t = this.__data__, e = qc(t, n);
  if (e < 0)
    return !1;
  var i = t.length - 1;
  return e == i ? t.pop() : vx.call(t, e, 1), --this.size, !0;
}
function xx(n) {
  var t = this.__data__, e = qc(t, n);
  return e < 0 ? void 0 : t[e][1];
}
function _x(n) {
  return qc(this.__data__, n) > -1;
}
function Sx(n, t) {
  var e = this.__data__, i = qc(e, n);
  return i < 0 ? (++this.size, e.push([n, t])) : e[i][1] = t, this;
}
function Ca(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Ca.prototype.clear = yx;
Ca.prototype.delete = wx;
Ca.prototype.get = xx;
Ca.prototype.has = _x;
Ca.prototype.set = Sx;
var kx = Fd(Ed, "Map");
function Ax() {
  this.size = 0, this.__data__ = {
    hash: new Po(),
    map: new (kx || Ca)(),
    string: new Po()
  };
}
function Nx(n) {
  var t = typeof n;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? n !== "__proto__" : n === null;
}
function zc(n, t) {
  var e = n.__data__;
  return Nx(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function Cx(n) {
  var t = zc(this, n).delete(n);
  return this.size -= t ? 1 : 0, t;
}
function Px(n) {
  return zc(this, n).get(n);
}
function Lx(n) {
  return zc(this, n).has(n);
}
function Ix(n, t) {
  var e = zc(this, n), i = e.size;
  return e.set(n, t), this.size += e.size == i ? 0 : 1, this;
}
function Oo(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Oo.prototype.clear = Ax;
Oo.prototype.delete = Cx;
Oo.prototype.get = Px;
Oo.prototype.has = Lx;
Oo.prototype.set = Ix;
var Ex = "Expected a function";
function Md(n, t) {
  if (typeof n != "function" || t != null && typeof t != "function")
    throw new TypeError(Ex);
  var e = function() {
    var i = arguments, r = t ? t.apply(this, i) : i[0], s = e.cache;
    if (s.has(r))
      return s.get(r);
    var o = n.apply(this, i);
    return e.cache = s.set(r, o) || s, o;
  };
  return e.cache = new (Md.Cache || Oo)(), e;
}
Md.Cache = Oo;
var Ox = 500;
function Tx(n) {
  var t = Md(n, function(i) {
    return e.size === Ox && e.clear(), i;
  }), e = t.cache;
  return t;
}
var Fx = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Mx = /\\(\\)?/g, Rx = Tx(function(n) {
  var t = [];
  return n.charCodeAt(0) === 46 && t.push(""), n.replace(Fx, function(e, i, r, s) {
    t.push(r ? s.replace(Mx, "$1") : i || e);
  }), t;
});
function Dx(n) {
  return n == null ? "" : im(n);
}
function sm(n, t) {
  return Td(n) ? n : sx(n, t) ? [n] : Rx(Dx(n));
}
var Bx = 1 / 0;
function om(n) {
  if (typeof n == "string" || Od(n))
    return n;
  var t = n + "";
  return t == "0" && 1 / n == -Bx ? "-0" : t;
}
function jx(n, t) {
  t = sm(t, n);
  for (var e = 0, i = t.length; n != null && e < i; )
    n = n[om(t[e++])];
  return e && e == i ? n : void 0;
}
function xo(n, t, e) {
  var i = n == null ? void 0 : jx(n, t);
  return i === void 0 ? e : i;
}
function qx(n, t, e, i) {
  if (!cc(n))
    return n;
  t = sm(t, n);
  for (var r = -1, s = t.length, o = s - 1, a = n; a != null && ++r < s; ) {
    var l = om(t[r]), h = e;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return n;
    if (r != o) {
      var u = a[l];
      h = void 0, h === void 0 && (h = cc(u) ? u : Z3(t[r + 1]) ? [] : {});
    }
    nx(a, l, h), a = a[l];
  }
  return n;
}
function kg(n, t, e) {
  return n == null ? n : qx(n, t, e);
}
var kf = "http://www.w3.org/1999/xhtml";
const Ag = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: kf,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function am(n) {
  var t = n += "", e = t.indexOf(":");
  return e >= 0 && (t = n.slice(0, e)) !== "xmlns" && (n = n.slice(e + 1)), Ag.hasOwnProperty(t) ? { space: Ag[t], local: n } : n;
}
function zx(n) {
  return function() {
    var t = this.ownerDocument, e = this.namespaceURI;
    return e === kf && t.documentElement.namespaceURI === kf ? t.createElement(n) : t.createElementNS(e, n);
  };
}
function $x(n) {
  return function() {
    return this.ownerDocument.createElementNS(n.space, n.local);
  };
}
function lm(n) {
  var t = am(n);
  return (t.local ? $x : zx)(t);
}
function Ux() {
}
function um(n) {
  return n == null ? Ux : function() {
    return this.querySelector(n);
  };
}
function Wx(n) {
  typeof n != "function" && (n = um(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = new Array(o), l, h, u = 0; u < o; ++u)
      (l = s[u]) && (h = n.call(l, l.__data__, u, s)) && ("__data__" in l && (h.__data__ = l.__data__), a[u] = h);
  return new ki(i, this._parents);
}
function cm(n) {
  return n == null ? [] : Array.isArray(n) ? n : Array.from(n);
}
function Hx() {
  return [];
}
function Gx(n) {
  return n == null ? Hx : function() {
    return this.querySelectorAll(n);
  };
}
function Vx(n) {
  return function() {
    return cm(n.apply(this, arguments));
  };
}
function Yx(n) {
  typeof n == "function" ? n = Vx(n) : n = Gx(n);
  for (var t = this._groups, e = t.length, i = [], r = [], s = 0; s < e; ++s)
    for (var o = t[s], a = o.length, l, h = 0; h < a; ++h)
      (l = o[h]) && (i.push(n.call(l, l.__data__, h, o)), r.push(l));
  return new ki(i, r);
}
function Kx(n) {
  return function() {
    return this.matches(n);
  };
}
function hm(n) {
  return function(t) {
    return t.matches(n);
  };
}
var Xx = Array.prototype.find;
function Jx(n) {
  return function() {
    return Xx.call(this.children, n);
  };
}
function Zx() {
  return this.firstElementChild;
}
function Qx(n) {
  return this.select(n == null ? Zx : Jx(typeof n == "function" ? n : hm(n)));
}
var t4 = Array.prototype.filter;
function e4() {
  return Array.from(this.children);
}
function n4(n) {
  return function() {
    return t4.call(this.children, n);
  };
}
function i4(n) {
  return this.selectAll(n == null ? e4 : n4(typeof n == "function" ? n : hm(n)));
}
function r4(n) {
  typeof n != "function" && (n = Kx(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = [], l, h = 0; h < o; ++h)
      (l = s[h]) && n.call(l, l.__data__, h, s) && a.push(l);
  return new ki(i, this._parents);
}
function fm(n) {
  return new Array(n.length);
}
function s4() {
  return new ki(this._enter || this._groups.map(fm), this._parents);
}
function hc(n, t) {
  this.ownerDocument = n.ownerDocument, this.namespaceURI = n.namespaceURI, this._next = null, this._parent = n, this.__data__ = t;
}
hc.prototype = {
  constructor: hc,
  appendChild: function(n) {
    return this._parent.insertBefore(n, this._next);
  },
  insertBefore: function(n, t) {
    return this._parent.insertBefore(n, t);
  },
  querySelector: function(n) {
    return this._parent.querySelector(n);
  },
  querySelectorAll: function(n) {
    return this._parent.querySelectorAll(n);
  }
};
function o4(n) {
  return function() {
    return n;
  };
}
function a4(n, t, e, i, r, s) {
  for (var o = 0, a, l = t.length, h = s.length; o < h; ++o)
    (a = t[o]) ? (a.__data__ = s[o], i[o] = a) : e[o] = new hc(n, s[o]);
  for (; o < l; ++o)
    (a = t[o]) && (r[o] = a);
}
function l4(n, t, e, i, r, s, o) {
  var a, l, h = /* @__PURE__ */ new Map(), u = t.length, d = s.length, p = new Array(u), f;
  for (a = 0; a < u; ++a)
    (l = t[a]) && (p[a] = f = o.call(l, l.__data__, a, t) + "", h.has(f) ? r[a] = l : h.set(f, l));
  for (a = 0; a < d; ++a)
    f = o.call(n, s[a], a, s) + "", (l = h.get(f)) ? (i[a] = l, l.__data__ = s[a], h.delete(f)) : e[a] = new hc(n, s[a]);
  for (a = 0; a < u; ++a)
    (l = t[a]) && h.get(p[a]) === l && (r[a] = l);
}
function u4(n) {
  return n.__data__;
}
function c4(n, t) {
  if (!arguments.length) return Array.from(this, u4);
  var e = t ? l4 : a4, i = this._parents, r = this._groups;
  typeof n != "function" && (n = o4(n));
  for (var s = r.length, o = new Array(s), a = new Array(s), l = new Array(s), h = 0; h < s; ++h) {
    var u = i[h], d = r[h], p = d.length, f = h4(n.call(u, u && u.__data__, h, i)), m = f.length, b = a[h] = new Array(m), x = o[h] = new Array(m), y = l[h] = new Array(p);
    e(u, d, b, x, y, f, t);
    for (var v = 0, k = 0, C, I; v < m; ++v)
      if (C = b[v]) {
        for (v >= k && (k = v + 1); !(I = x[k]) && ++k < m; ) ;
        C._next = I || null;
      }
  }
  return o = new ki(o, i), o._enter = a, o._exit = l, o;
}
function h4(n) {
  return typeof n == "object" && "length" in n ? n : Array.from(n);
}
function f4() {
  return new ki(this._exit || this._groups.map(fm), this._parents);
}
function d4(n, t, e) {
  var i = this.enter(), r = this, s = this.exit();
  return typeof n == "function" ? (i = n(i), i && (i = i.selection())) : i = i.append(n + ""), t != null && (r = t(r), r && (r = r.selection())), e == null ? s.remove() : e(s), i && r ? i.merge(r).order() : r;
}
function p4(n) {
  for (var t = n.selection ? n.selection() : n, e = this._groups, i = t._groups, r = e.length, s = i.length, o = Math.min(r, s), a = new Array(r), l = 0; l < o; ++l)
    for (var h = e[l], u = i[l], d = h.length, p = a[l] = new Array(d), f, m = 0; m < d; ++m)
      (f = h[m] || u[m]) && (p[m] = f);
  for (; l < r; ++l)
    a[l] = e[l];
  return new ki(a, this._parents);
}
function g4() {
  for (var n = this._groups, t = -1, e = n.length; ++t < e; )
    for (var i = n[t], r = i.length - 1, s = i[r], o; --r >= 0; )
      (o = i[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function m4(n) {
  n || (n = y4);
  function t(d, p) {
    return d && p ? n(d.__data__, p.__data__) : !d - !p;
  }
  for (var e = this._groups, i = e.length, r = new Array(i), s = 0; s < i; ++s) {
    for (var o = e[s], a = o.length, l = r[s] = new Array(a), h, u = 0; u < a; ++u)
      (h = o[u]) && (l[u] = h);
    l.sort(t);
  }
  return new ki(r, this._parents).order();
}
function y4(n, t) {
  return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function b4() {
  var n = arguments[0];
  return arguments[0] = this, n.apply(null, arguments), this;
}
function v4() {
  return Array.from(this);
}
function w4() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length; r < s; ++r) {
      var o = i[r];
      if (o) return o;
    }
  return null;
}
function x4() {
  let n = 0;
  for (const t of this) ++n;
  return n;
}
function _4() {
  return !this.node();
}
function S4(n) {
  for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
    for (var r = t[e], s = 0, o = r.length, a; s < o; ++s)
      (a = r[s]) && n.call(a, a.__data__, s, r);
  return this;
}
function k4(n) {
  return function() {
    this.removeAttribute(n);
  };
}
function A4(n) {
  return function() {
    this.removeAttributeNS(n.space, n.local);
  };
}
function N4(n, t) {
  return function() {
    this.setAttribute(n, t);
  };
}
function C4(n, t) {
  return function() {
    this.setAttributeNS(n.space, n.local, t);
  };
}
function P4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttribute(n) : this.setAttribute(n, e);
  };
}
function L4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e);
  };
}
function I4(n, t) {
  var e = am(n);
  if (arguments.length < 2) {
    var i = this.node();
    return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e);
  }
  return this.each((t == null ? e.local ? A4 : k4 : typeof t == "function" ? e.local ? L4 : P4 : e.local ? C4 : N4)(e, t));
}
function dm(n) {
  return n.ownerDocument && n.ownerDocument.defaultView || n.document && n || n.defaultView;
}
function E4(n) {
  return function() {
    this.style.removeProperty(n);
  };
}
function O4(n, t, e) {
  return function() {
    this.style.setProperty(n, t, e);
  };
}
function T4(n, t, e) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.style.removeProperty(n) : this.style.setProperty(n, i, e);
  };
}
function F4(n, t, e) {
  return arguments.length > 1 ? this.each((t == null ? E4 : typeof t == "function" ? T4 : O4)(n, t, e ?? "")) : M4(this.node(), n);
}
function M4(n, t) {
  return n.style.getPropertyValue(t) || dm(n).getComputedStyle(n, null).getPropertyValue(t);
}
function R4(n) {
  return function() {
    delete this[n];
  };
}
function D4(n, t) {
  return function() {
    this[n] = t;
  };
}
function B4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? delete this[n] : this[n] = e;
  };
}
function j4(n, t) {
  return arguments.length > 1 ? this.each((t == null ? R4 : typeof t == "function" ? B4 : D4)(n, t)) : this.node()[n];
}
function pm(n) {
  return n.trim().split(/^|\s+/);
}
function Rd(n) {
  return n.classList || new gm(n);
}
function gm(n) {
  this._node = n, this._names = pm(n.getAttribute("class") || "");
}
gm.prototype = {
  add: function(n) {
    var t = this._names.indexOf(n);
    t < 0 && (this._names.push(n), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(n) {
    var t = this._names.indexOf(n);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(n) {
    return this._names.indexOf(n) >= 0;
  }
};
function mm(n, t) {
  for (var e = Rd(n), i = -1, r = t.length; ++i < r; ) e.add(t[i]);
}
function ym(n, t) {
  for (var e = Rd(n), i = -1, r = t.length; ++i < r; ) e.remove(t[i]);
}
function q4(n) {
  return function() {
    mm(this, n);
  };
}
function z4(n) {
  return function() {
    ym(this, n);
  };
}
function $4(n, t) {
  return function() {
    (t.apply(this, arguments) ? mm : ym)(this, n);
  };
}
function U4(n, t) {
  var e = pm(n + "");
  if (arguments.length < 2) {
    for (var i = Rd(this.node()), r = -1, s = e.length; ++r < s; ) if (!i.contains(e[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? $4 : t ? q4 : z4)(e, t));
}
function W4() {
  this.textContent = "";
}
function H4(n) {
  return function() {
    this.textContent = n;
  };
}
function G4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function V4(n) {
  return arguments.length ? this.each(n == null ? W4 : (typeof n == "function" ? G4 : H4)(n)) : this.node().textContent;
}
function Y4() {
  this.innerHTML = "";
}
function K4(n) {
  return function() {
    this.innerHTML = n;
  };
}
function X4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function J4(n) {
  return arguments.length ? this.each(n == null ? Y4 : (typeof n == "function" ? X4 : K4)(n)) : this.node().innerHTML;
}
function Z4() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Q4() {
  return this.each(Z4);
}
function t_() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function e_() {
  return this.each(t_);
}
function n_(n) {
  var t = typeof n == "function" ? n : lm(n);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function i_() {
  return null;
}
function r_(n, t) {
  var e = typeof n == "function" ? n : lm(n), i = t == null ? i_ : typeof t == "function" ? t : um(t);
  return this.select(function() {
    return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null);
  });
}
function s_() {
  var n = this.parentNode;
  n && n.removeChild(this);
}
function o_() {
  return this.each(s_);
}
function a_() {
  var n = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function l_() {
  var n = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function u_(n) {
  return this.select(n ? l_ : a_);
}
function c_(n) {
  return arguments.length ? this.property("__data__", n) : this.node().__data__;
}
function h_(n) {
  return function(t) {
    n.call(this, t, this.__data__);
  };
}
function f_(n) {
  return n.trim().split(/^|\s+/).map(function(t) {
    var e = "", i = t.indexOf(".");
    return i >= 0 && (e = t.slice(i + 1), t = t.slice(0, i)), { type: t, name: e };
  });
}
function d_(n) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var e = 0, i = -1, r = t.length, s; e < r; ++e)
        s = t[e], (!n.type || s.type === n.type) && s.name === n.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++i] = s;
      ++i ? t.length = i : delete this.__on;
    }
  };
}
function p_(n, t, e) {
  return function() {
    var i = this.__on, r, s = h_(t);
    if (i) {
      for (var o = 0, a = i.length; o < a; ++o)
        if ((r = i[o]).type === n.type && r.name === n.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = e), r.value = t;
          return;
        }
    }
    this.addEventListener(n.type, s, e), r = { type: n.type, name: n.name, value: t, listener: s, options: e }, i ? i.push(r) : this.__on = [r];
  };
}
function g_(n, t, e) {
  var i = f_(n + ""), r, s = i.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, h = a.length, u; l < h; ++l)
        for (r = 0, u = a[l]; r < s; ++r)
          if ((o = i[r]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (a = t ? p_ : d_, r = 0; r < s; ++r) this.each(a(i[r], t, e));
  return this;
}
function bm(n, t, e) {
  var i = dm(n), r = i.CustomEvent;
  typeof r == "function" ? r = new r(t, e) : (r = i.document.createEvent("Event"), e ? (r.initEvent(t, e.bubbles, e.cancelable), r.detail = e.detail) : r.initEvent(t, !1, !1)), n.dispatchEvent(r);
}
function m_(n, t) {
  return function() {
    return bm(this, n, t);
  };
}
function y_(n, t) {
  return function() {
    return bm(this, n, t.apply(this, arguments));
  };
}
function b_(n, t) {
  return this.each((typeof t == "function" ? y_ : m_)(n, t));
}
function* v_() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length, o; r < s; ++r)
      (o = i[r]) && (yield o);
}
var vm = [null];
function ki(n, t) {
  this._groups = n, this._parents = t;
}
function w_() {
  return this;
}
ki.prototype = {
  constructor: ki,
  select: Wx,
  selectAll: Yx,
  selectChild: Qx,
  selectChildren: i4,
  filter: r4,
  data: c4,
  enter: s4,
  exit: f4,
  join: d4,
  merge: p4,
  selection: w_,
  order: g4,
  sort: m4,
  call: b4,
  nodes: v4,
  node: w4,
  size: x4,
  empty: _4,
  each: S4,
  attr: I4,
  style: F4,
  property: j4,
  classed: U4,
  text: V4,
  html: J4,
  raise: Q4,
  lower: e_,
  append: n_,
  insert: r_,
  remove: o_,
  clone: u_,
  datum: c_,
  on: g_,
  dispatch: b_,
  [Symbol.iterator]: v_
};
function x_(n) {
  return typeof n == "string" ? new ki([[document.querySelector(n)]], [document.documentElement]) : new ki([[n]], vm);
}
function __(n) {
  return typeof n == "string" ? new ki([document.querySelectorAll(n)], [document.documentElement]) : new ki([cm(n)], vm);
}
function Yu(n, t) {
  return n == null || t == null ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function S_(n, t) {
  return n == null || t == null ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
}
function wm(n) {
  let t, e, i;
  n.length !== 2 ? (t = Yu, e = (a, l) => Yu(n(a), l), i = (a, l) => n(a) - l) : (t = n === Yu || n === S_ ? n : k_, e = n, i = n);
  function r(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) < 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function s(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) <= 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function o(a, l, h = 0, u = a.length) {
    const d = r(a, l, h, u - 1);
    return d > h && i(a[d - 1], l) > -i(a[d], l) ? d - 1 : d;
  }
  return { left: r, center: o, right: s };
}
function k_() {
  return 0;
}
function A_(n) {
  return n === null ? NaN : +n;
}
const N_ = wm(Yu), C_ = N_.right;
wm(A_).center;
const P_ = Math.sqrt(50), L_ = Math.sqrt(10), I_ = Math.sqrt(2);
function fc(n, t, e) {
  const i = (t - n) / Math.max(0, e), r = Math.floor(Math.log10(i)), s = i / Math.pow(10, r), o = s >= P_ ? 10 : s >= L_ ? 5 : s >= I_ ? 2 : 1;
  let a, l, h;
  return r < 0 ? (h = Math.pow(10, -r) / o, a = Math.round(n * h), l = Math.round(t * h), a / h < n && ++a, l / h > t && --l, h = -h) : (h = Math.pow(10, r) * o, a = Math.round(n / h), l = Math.round(t / h), a * h < n && ++a, l * h > t && --l), l < a && 0.5 <= e && e < 2 ? fc(n, t, e * 2) : [a, l, h];
}
function E_(n, t, e) {
  if (t = +t, n = +n, e = +e, !(e > 0)) return [];
  if (n === t) return [n];
  const i = t < n, [r, s, o] = i ? fc(t, n, e) : fc(n, t, e);
  if (!(s >= r)) return [];
  const a = s - r + 1, l = new Array(a);
  if (i)
    if (o < 0) for (let h = 0; h < a; ++h) l[h] = (s - h) / -o;
    else for (let h = 0; h < a; ++h) l[h] = (s - h) * o;
  else if (o < 0) for (let h = 0; h < a; ++h) l[h] = (r + h) / -o;
  else for (let h = 0; h < a; ++h) l[h] = (r + h) * o;
  return l;
}
function Af(n, t, e) {
  return t = +t, n = +n, e = +e, fc(n, t, e)[2];
}
function O_(n, t, e) {
  t = +t, n = +n, e = +e;
  const i = t < n, r = i ? Af(t, n, e) : Af(n, t, e);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function T_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(n);
      break;
    default:
      this.range(t).domain(n);
      break;
  }
  return this;
}
function F_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof n == "function" ? this.interpolator(n) : this.range(n);
      break;
    }
    default: {
      this.domain(n), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
function Dd(n, t, e) {
  n.prototype = t.prototype = e, e.constructor = n;
}
function xm(n, t) {
  var e = Object.create(n.prototype);
  for (var i in t) e[i] = t[i];
  return e;
}
function Ul() {
}
var El = 0.7, dc = 1 / El, ya = "\\s*([+-]?\\d+)\\s*", Ol = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Fr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", M_ = /^#([0-9a-f]{3,8})$/, R_ = new RegExp(`^rgb\\(${ya},${ya},${ya}\\)$`), D_ = new RegExp(`^rgb\\(${Fr},${Fr},${Fr}\\)$`), B_ = new RegExp(`^rgba\\(${ya},${ya},${ya},${Ol}\\)$`), j_ = new RegExp(`^rgba\\(${Fr},${Fr},${Fr},${Ol}\\)$`), q_ = new RegExp(`^hsl\\(${Ol},${Fr},${Fr}\\)$`), z_ = new RegExp(`^hsla\\(${Ol},${Fr},${Fr},${Ol}\\)$`), Ng = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Dd(Ul, _a, {
  copy(n) {
    return Object.assign(new this.constructor(), this, n);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Cg,
  // Deprecated! Use color.formatHex.
  formatHex: Cg,
  formatHex8: $_,
  formatHsl: U_,
  formatRgb: Pg,
  toString: Pg
});
function Cg() {
  return this.rgb().formatHex();
}
function $_() {
  return this.rgb().formatHex8();
}
function U_() {
  return _m(this).formatHsl();
}
function Pg() {
  return this.rgb().formatRgb();
}
function _a(n) {
  var t, e;
  return n = (n + "").trim().toLowerCase(), (t = M_.exec(n)) ? (e = t[1].length, t = parseInt(t[1], 16), e === 6 ? Lg(t) : e === 3 ? new Si(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : e === 8 ? Mu(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : e === 4 ? Mu(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = R_.exec(n)) ? new Si(t[1], t[2], t[3], 1) : (t = D_.exec(n)) ? new Si(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = B_.exec(n)) ? Mu(t[1], t[2], t[3], t[4]) : (t = j_.exec(n)) ? Mu(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = q_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, 1) : (t = z_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, t[4]) : Ng.hasOwnProperty(n) ? Lg(Ng[n]) : n === "transparent" ? new Si(NaN, NaN, NaN, 0) : null;
}
function Lg(n) {
  return new Si(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function Mu(n, t, e, i) {
  return i <= 0 && (n = t = e = NaN), new Si(n, t, e, i);
}
function W_(n) {
  return n instanceof Ul || (n = _a(n)), n ? (n = n.rgb(), new Si(n.r, n.g, n.b, n.opacity)) : new Si();
}
function Pn(n, t, e, i) {
  return arguments.length === 1 ? W_(n) : new Si(n, t, e, i ?? 1);
}
function Si(n, t, e, i) {
  this.r = +n, this.g = +t, this.b = +e, this.opacity = +i;
}
Dd(Si, Pn, xm(Ul, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new Si(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? El : Math.pow(El, n), new Si(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Si(_o(this.r), _o(this.g), _o(this.b), pc(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ig,
  // Deprecated! Use color.formatHex.
  formatHex: Ig,
  formatHex8: H_,
  formatRgb: Eg,
  toString: Eg
}));
function Ig() {
  return `#${po(this.r)}${po(this.g)}${po(this.b)}`;
}
function H_() {
  return `#${po(this.r)}${po(this.g)}${po(this.b)}${po((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Eg() {
  const n = pc(this.opacity);
  return `${n === 1 ? "rgb(" : "rgba("}${_o(this.r)}, ${_o(this.g)}, ${_o(this.b)}${n === 1 ? ")" : `, ${n})`}`;
}
function pc(n) {
  return isNaN(n) ? 1 : Math.max(0, Math.min(1, n));
}
function _o(n) {
  return Math.max(0, Math.min(255, Math.round(n) || 0));
}
function po(n) {
  return n = _o(n), (n < 16 ? "0" : "") + n.toString(16);
}
function Og(n, t, e, i) {
  return i <= 0 ? n = t = e = NaN : e <= 0 || e >= 1 ? n = t = NaN : t <= 0 && (n = NaN), new dr(n, t, e, i);
}
function _m(n) {
  if (n instanceof dr) return new dr(n.h, n.s, n.l, n.opacity);
  if (n instanceof Ul || (n = _a(n)), !n) return new dr();
  if (n instanceof dr) return n;
  n = n.rgb();
  var t = n.r / 255, e = n.g / 255, i = n.b / 255, r = Math.min(t, e, i), s = Math.max(t, e, i), o = NaN, a = s - r, l = (s + r) / 2;
  return a ? (t === s ? o = (e - i) / a + (e < i) * 6 : e === s ? o = (i - t) / a + 2 : o = (t - e) / a + 4, a /= l < 0.5 ? s + r : 2 - s - r, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new dr(o, a, l, n.opacity);
}
function G_(n, t, e, i) {
  return arguments.length === 1 ? _m(n) : new dr(n, t, e, i ?? 1);
}
function dr(n, t, e, i) {
  this.h = +n, this.s = +t, this.l = +e, this.opacity = +i;
}
Dd(dr, G_, xm(Ul, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new dr(this.h, this.s, this.l * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? El : Math.pow(El, n), new dr(this.h, this.s, this.l * n, this.opacity);
  },
  rgb() {
    var n = this.h % 360 + (this.h < 0) * 360, t = isNaN(n) || isNaN(this.s) ? 0 : this.s, e = this.l, i = e + (e < 0.5 ? e : 1 - e) * t, r = 2 * e - i;
    return new Si(
      Rh(n >= 240 ? n - 240 : n + 120, r, i),
      Rh(n, r, i),
      Rh(n < 120 ? n + 240 : n - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new dr(Tg(this.h), Ru(this.s), Ru(this.l), pc(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const n = pc(this.opacity);
    return `${n === 1 ? "hsl(" : "hsla("}${Tg(this.h)}, ${Ru(this.s) * 100}%, ${Ru(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`;
  }
}));
function Tg(n) {
  return n = (n || 0) % 360, n < 0 ? n + 360 : n;
}
function Ru(n) {
  return Math.max(0, Math.min(1, n || 0));
}
function Rh(n, t, e) {
  return (n < 60 ? t + (e - t) * n / 60 : n < 180 ? e : n < 240 ? t + (e - t) * (240 - n) / 60 : t) * 255;
}
const Bd = (n) => () => n;
function V_(n, t) {
  return function(e) {
    return n + e * t;
  };
}
function Y_(n, t, e) {
  return n = Math.pow(n, e), t = Math.pow(t, e) - n, e = 1 / e, function(i) {
    return Math.pow(n + i * t, e);
  };
}
function K_(n) {
  return (n = +n) == 1 ? Sm : function(t, e) {
    return e - t ? Y_(t, e, n) : Bd(isNaN(t) ? e : t);
  };
}
function Sm(n, t) {
  var e = t - n;
  return e ? V_(n, e) : Bd(isNaN(n) ? t : n);
}
const Fg = function n(t) {
  var e = K_(t);
  function i(r, s) {
    var o = e((r = Pn(r)).r, (s = Pn(s)).r), a = e(r.g, s.g), l = e(r.b, s.b), h = Sm(r.opacity, s.opacity);
    return function(u) {
      return r.r = o(u), r.g = a(u), r.b = l(u), r.opacity = h(u), r + "";
    };
  }
  return i.gamma = n, i;
}(1);
function X_(n, t) {
  t || (t = []);
  var e = n ? Math.min(t.length, n.length) : 0, i = t.slice(), r;
  return function(s) {
    for (r = 0; r < e; ++r) i[r] = n[r] * (1 - s) + t[r] * s;
    return i;
  };
}
function J_(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function Z_(n, t) {
  var e = t ? t.length : 0, i = n ? Math.min(e, n.length) : 0, r = new Array(i), s = new Array(e), o;
  for (o = 0; o < i; ++o) r[o] = $c(n[o], t[o]);
  for (; o < e; ++o) s[o] = t[o];
  return function(a) {
    for (o = 0; o < i; ++o) s[o] = r[o](a);
    return s;
  };
}
function Q_(n, t) {
  var e = /* @__PURE__ */ new Date();
  return n = +n, t = +t, function(i) {
    return e.setTime(n * (1 - i) + t * i), e;
  };
}
function gc(n, t) {
  return n = +n, t = +t, function(e) {
    return n * (1 - e) + t * e;
  };
}
function tS(n, t) {
  var e = {}, i = {}, r;
  (n === null || typeof n != "object") && (n = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in n ? e[r] = $c(n[r], t[r]) : i[r] = t[r];
  return function(s) {
    for (r in e) i[r] = e[r](s);
    return i;
  };
}
var Nf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Dh = new RegExp(Nf.source, "g");
function eS(n) {
  return function() {
    return n;
  };
}
function nS(n) {
  return function(t) {
    return n(t) + "";
  };
}
function iS(n, t) {
  var e = Nf.lastIndex = Dh.lastIndex = 0, i, r, s, o = -1, a = [], l = [];
  for (n = n + "", t = t + ""; (i = Nf.exec(n)) && (r = Dh.exec(t)); )
    (s = r.index) > e && (s = t.slice(e, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, l.push({ i: o, x: gc(i, r) })), e = Dh.lastIndex;
  return e < t.length && (s = t.slice(e), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? nS(l[0].x) : eS(t) : (t = l.length, function(h) {
    for (var u = 0, d; u < t; ++u) a[(d = l[u]).i] = d.x(h);
    return a.join("");
  });
}
function $c(n, t) {
  var e = typeof t, i;
  return t == null || e === "boolean" ? Bd(t) : (e === "number" ? gc : e === "string" ? (i = _a(t)) ? (t = i, Fg) : iS : t instanceof _a ? Fg : t instanceof Date ? Q_ : J_(t) ? X_ : Array.isArray(t) ? Z_ : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? tS : gc)(n, t);
}
function km(n, t) {
  return n = +n, t = +t, function(e) {
    return Math.round(n * (1 - e) + t * e);
  };
}
function rS(n) {
  return function() {
    return n;
  };
}
function sS(n) {
  return +n;
}
var Mg = [0, 1];
function Fs(n) {
  return n;
}
function Cf(n, t) {
  return (t -= n = +n) ? function(e) {
    return (e - n) / t;
  } : rS(isNaN(t) ? NaN : 0.5);
}
function oS(n, t) {
  var e;
  return n > t && (e = n, n = t, t = e), function(i) {
    return Math.max(n, Math.min(t, i));
  };
}
function aS(n, t, e) {
  var i = n[0], r = n[1], s = t[0], o = t[1];
  return r < i ? (i = Cf(r, i), s = e(o, s)) : (i = Cf(i, r), s = e(s, o)), function(a) {
    return s(i(a));
  };
}
function lS(n, t, e) {
  var i = Math.min(n.length, t.length) - 1, r = new Array(i), s = new Array(i), o = -1;
  for (n[i] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o < i; )
    r[o] = Cf(n[o], n[o + 1]), s[o] = e(t[o], t[o + 1]);
  return function(a) {
    var l = C_(n, a, 1, i) - 1;
    return s[l](r[l](a));
  };
}
function uS(n, t) {
  return t.domain(n.domain()).range(n.range()).interpolate(n.interpolate()).clamp(n.clamp()).unknown(n.unknown());
}
function cS() {
  var n = Mg, t = Mg, e = $c, i, r, s, o = Fs, a, l, h;
  function u() {
    var p = Math.min(n.length, t.length);
    return o !== Fs && (o = oS(n[0], n[p - 1])), a = p > 2 ? lS : aS, l = h = null, d;
  }
  function d(p) {
    return p == null || isNaN(p = +p) ? s : (l || (l = a(n.map(i), t, e)))(i(o(p)));
  }
  return d.invert = function(p) {
    return o(r((h || (h = a(t, n.map(i), gc)))(p)));
  }, d.domain = function(p) {
    return arguments.length ? (n = Array.from(p, sS), u()) : n.slice();
  }, d.range = function(p) {
    return arguments.length ? (t = Array.from(p), u()) : t.slice();
  }, d.rangeRound = function(p) {
    return t = Array.from(p), e = km, u();
  }, d.clamp = function(p) {
    return arguments.length ? (o = p ? !0 : Fs, u()) : o !== Fs;
  }, d.interpolate = function(p) {
    return arguments.length ? (e = p, u()) : e;
  }, d.unknown = function(p) {
    return arguments.length ? (s = p, d) : s;
  }, function(p, f) {
    return i = p, r = f, u();
  };
}
function hS() {
  return cS()(Fs, Fs);
}
function fS(n) {
  return Math.abs(n = Math.round(n)) >= 1e21 ? n.toLocaleString("en").replace(/,/g, "") : n.toString(10);
}
function mc(n, t) {
  if ((e = (n = t ? n.toExponential(t - 1) : n.toExponential()).indexOf("e")) < 0) return null;
  var e, i = n.slice(0, e);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +n.slice(e + 1)
  ];
}
function Sa(n) {
  return n = mc(Math.abs(n)), n ? n[1] : NaN;
}
function dS(n, t) {
  return function(e, i) {
    for (var r = e.length, s = [], o = 0, a = n[0], l = 0; r > 0 && a > 0 && (l + a + 1 > i && (a = Math.max(1, i - l)), s.push(e.substring(r -= a, r + a)), !((l += a + 1) > i)); )
      a = n[o = (o + 1) % n.length];
    return s.reverse().join(t);
  };
}
function pS(n) {
  return function(t) {
    return t.replace(/[0-9]/g, function(e) {
      return n[+e];
    });
  };
}
var gS = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function yc(n) {
  if (!(t = gS.exec(n))) throw new Error("invalid format: " + n);
  var t;
  return new jd({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
yc.prototype = jd.prototype;
function jd(n) {
  this.fill = n.fill === void 0 ? " " : n.fill + "", this.align = n.align === void 0 ? ">" : n.align + "", this.sign = n.sign === void 0 ? "-" : n.sign + "", this.symbol = n.symbol === void 0 ? "" : n.symbol + "", this.zero = !!n.zero, this.width = n.width === void 0 ? void 0 : +n.width, this.comma = !!n.comma, this.precision = n.precision === void 0 ? void 0 : +n.precision, this.trim = !!n.trim, this.type = n.type === void 0 ? "" : n.type + "";
}
jd.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function mS(n) {
  t: for (var t = n.length, e = 1, i = -1, r; e < t; ++e)
    switch (n[e]) {
      case ".":
        i = r = e;
        break;
      case "0":
        i === 0 && (i = e), r = e;
        break;
      default:
        if (!+n[e]) break t;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? n.slice(0, i) + n.slice(r + 1) : n;
}
var Am;
function yS(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1], s = r - (Am = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = i.length;
  return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + mc(n, Math.max(0, t + s - 1))[0];
}
function Rg(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const Dg = {
  "%": (n, t) => (n * 100).toFixed(t),
  b: (n) => Math.round(n).toString(2),
  c: (n) => n + "",
  d: fS,
  e: (n, t) => n.toExponential(t),
  f: (n, t) => n.toFixed(t),
  g: (n, t) => n.toPrecision(t),
  o: (n) => Math.round(n).toString(8),
  p: (n, t) => Rg(n * 100, t),
  r: Rg,
  s: yS,
  X: (n) => Math.round(n).toString(16).toUpperCase(),
  x: (n) => Math.round(n).toString(16)
};
function Bg(n) {
  return n;
}
var jg = Array.prototype.map, qg = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function bS(n) {
  var t = n.grouping === void 0 || n.thousands === void 0 ? Bg : dS(jg.call(n.grouping, Number), n.thousands + ""), e = n.currency === void 0 ? "" : n.currency[0] + "", i = n.currency === void 0 ? "" : n.currency[1] + "", r = n.decimal === void 0 ? "." : n.decimal + "", s = n.numerals === void 0 ? Bg : pS(jg.call(n.numerals, String)), o = n.percent === void 0 ? "%" : n.percent + "", a = n.minus === void 0 ? "−" : n.minus + "", l = n.nan === void 0 ? "NaN" : n.nan + "";
  function h(d) {
    d = yc(d);
    var p = d.fill, f = d.align, m = d.sign, b = d.symbol, x = d.zero, y = d.width, v = d.comma, k = d.precision, C = d.trim, I = d.type;
    I === "n" ? (v = !0, I = "g") : Dg[I] || (k === void 0 && (k = 12), C = !0, I = "g"), (x || p === "0" && f === "=") && (x = !0, p = "0", f = "=");
    var q = b === "$" ? e : b === "#" && /[boxX]/.test(I) ? "0" + I.toLowerCase() : "", O = b === "$" ? i : /[%p]/.test(I) ? o : "", F = Dg[I], M = /[defgprs%]/.test(I);
    k = k === void 0 ? 6 : /[gprs]/.test(I) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function j(P) {
      var A = q, T = O, _, Z, V;
      if (I === "c")
        T = F(P) + T, P = "";
      else {
        P = +P;
        var R = P < 0 || 1 / P < 0;
        if (P = isNaN(P) ? l : F(Math.abs(P), k), C && (P = mS(P)), R && +P == 0 && m !== "+" && (R = !1), A = (R ? m === "(" ? m : a : m === "-" || m === "(" ? "" : m) + A, T = (I === "s" ? qg[8 + Am / 3] : "") + T + (R && m === "(" ? ")" : ""), M) {
          for (_ = -1, Z = P.length; ++_ < Z; )
            if (V = P.charCodeAt(_), 48 > V || V > 57) {
              T = (V === 46 ? r + P.slice(_ + 1) : P.slice(_)) + T, P = P.slice(0, _);
              break;
            }
        }
      }
      v && !x && (P = t(P, 1 / 0));
      var Q = A.length + P.length + T.length, H = Q < y ? new Array(y - Q + 1).join(p) : "";
      switch (v && x && (P = t(H + P, H.length ? y - T.length : 1 / 0), H = ""), f) {
        case "<":
          P = A + P + T + H;
          break;
        case "=":
          P = A + H + P + T;
          break;
        case "^":
          P = H.slice(0, Q = H.length >> 1) + A + P + T + H.slice(Q);
          break;
        default:
          P = H + A + P + T;
          break;
      }
      return s(P);
    }
    return j.toString = function() {
      return d + "";
    }, j;
  }
  function u(d, p) {
    var f = h((d = yc(d), d.type = "f", d)), m = Math.max(-8, Math.min(8, Math.floor(Sa(p) / 3))) * 3, b = Math.pow(10, -m), x = qg[8 + m / 3];
    return function(y) {
      return f(b * y) + x;
    };
  }
  return {
    format: h,
    formatPrefix: u
  };
}
var Du, qd, Nm;
vS({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function vS(n) {
  return Du = bS(n), qd = Du.format, Nm = Du.formatPrefix, Du;
}
function Cm(n) {
  return Math.max(0, -Sa(Math.abs(n)));
}
function wS(n, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Sa(t) / 3))) * 3 - Sa(Math.abs(n)));
}
function xS(n, t) {
  return n = Math.abs(n), t = Math.abs(t) - n, Math.max(0, Sa(t) - Sa(n)) + 1;
}
function _S(n, t, e, i) {
  var r = O_(n, t, e), s;
  switch (i = yc(i ?? ",f"), i.type) {
    case "s": {
      var o = Math.max(Math.abs(n), Math.abs(t));
      return i.precision == null && !isNaN(s = wS(r, o)) && (i.precision = s), Nm(i, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(s = xS(r, Math.max(Math.abs(n), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(s = Cm(r)) && (i.precision = s - (i.type === "%") * 2);
      break;
    }
  }
  return qd(i);
}
function Pm(n) {
  var t = n.domain;
  return n.ticks = function(e) {
    var i = t();
    return E_(i[0], i[i.length - 1], e ?? 10);
  }, n.tickFormat = function(e, i) {
    var r = t();
    return _S(r[0], r[r.length - 1], e ?? 10, i);
  }, n.nice = function(e) {
    e == null && (e = 10);
    var i = t(), r = 0, s = i.length - 1, o = i[r], a = i[s], l, h, u = 10;
    for (a < o && (h = o, o = a, a = h, h = r, r = s, s = h); u-- > 0; ) {
      if (h = Af(o, a, e), h === l)
        return i[r] = o, i[s] = a, t(i);
      if (h > 0)
        o = Math.floor(o / h) * h, a = Math.ceil(a / h) * h;
      else if (h < 0)
        o = Math.ceil(o * h) / h, a = Math.floor(a * h) / h;
      else
        break;
      l = h;
    }
    return n;
  }, n;
}
function Lm() {
  var n = hS();
  return n.copy = function() {
    return uS(n, Lm());
  }, T_.apply(n, arguments), Pm(n);
}
function SS() {
  var n = 0, t = 1, e, i, r, s, o = Fs, a = !1, l;
  function h(d) {
    return d == null || isNaN(d = +d) ? l : o(r === 0 ? 0.5 : (d = (s(d) - e) * r, a ? Math.max(0, Math.min(1, d)) : d));
  }
  h.domain = function(d) {
    return arguments.length ? ([n, t] = d, e = s(n = +n), i = s(t = +t), r = e === i ? 0 : 1 / (i - e), h) : [n, t];
  }, h.clamp = function(d) {
    return arguments.length ? (a = !!d, h) : a;
  }, h.interpolator = function(d) {
    return arguments.length ? (o = d, h) : o;
  };
  function u(d) {
    return function(p) {
      var f, m;
      return arguments.length ? ([f, m] = p, o = d(f, m), h) : [o(0), o(1)];
    };
  }
  return h.range = u($c), h.rangeRound = u(km), h.unknown = function(d) {
    return arguments.length ? (l = d, h) : l;
  }, function(d) {
    return s = d, e = d(n), i = d(t), r = e === i ? 0 : 1 / (i - e), h;
  };
}
function kS(n, t) {
  return t.domain(n.domain()).interpolator(n.interpolator()).clamp(n.clamp()).unknown(n.unknown());
}
function Im() {
  var n = Pm(SS()(Fs));
  return n.copy = function() {
    return kS(n, Im());
  }, F_.apply(n, arguments);
}
function AS(n) {
  return n;
}
var Ku = 1, Xu = 2, Pf = 3, vl = 4, zg = 1e-6;
function NS(n) {
  return "translate(" + n + ",0)";
}
function CS(n) {
  return "translate(0," + n + ")";
}
function PS(n) {
  return (t) => +n(t);
}
function LS(n, t) {
  return t = Math.max(0, n.bandwidth() - t * 2) / 2, n.round() && (t = Math.round(t)), (e) => +n(e) + t;
}
function IS() {
  return !this.__axis;
}
function Uc(n, t) {
  var e = [], i = null, r = null, s = 6, o = 6, a = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, h = n === Ku || n === vl ? -1 : 1, u = n === vl || n === Xu ? "x" : "y", d = n === Ku || n === Pf ? NS : CS;
  function p(f) {
    var m = i ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), b = r ?? (t.tickFormat ? t.tickFormat.apply(t, e) : AS), x = Math.max(s, 0) + a, y = t.range(), v = +y[0] + l, k = +y[y.length - 1] + l, C = (t.bandwidth ? LS : PS)(t.copy(), l), I = f.selection ? f.selection() : f, q = I.selectAll(".domain").data([null]), O = I.selectAll(".tick").data(m, t).order(), F = O.exit(), M = O.enter().append("g").attr("class", "tick"), j = O.select("line"), P = O.select("text");
    q = q.merge(q.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), O = O.merge(M), j = j.merge(M.append("line").attr("stroke", "currentColor").attr(u + "2", h * s)), P = P.merge(M.append("text").attr("fill", "currentColor").attr(u, h * x).attr("dy", n === Ku ? "0em" : n === Pf ? "0.71em" : "0.32em")), f !== I && (q = q.transition(f), O = O.transition(f), j = j.transition(f), P = P.transition(f), F = F.transition(f).attr("opacity", zg).attr("transform", function(A) {
      return isFinite(A = C(A)) ? d(A + l) : this.getAttribute("transform");
    }), M.attr("opacity", zg).attr("transform", function(A) {
      var T = this.parentNode.__axis;
      return d((T && isFinite(T = T(A)) ? T : C(A)) + l);
    })), F.remove(), q.attr("d", n === vl || n === Xu ? o ? "M" + h * o + "," + v + "H" + l + "V" + k + "H" + h * o : "M" + l + "," + v + "V" + k : o ? "M" + v + "," + h * o + "V" + l + "H" + k + "V" + h * o : "M" + v + "," + l + "H" + k), O.attr("opacity", 1).attr("transform", function(A) {
      return d(C(A) + l);
    }), j.attr(u + "2", h * s), P.attr(u, h * x).text(b), I.filter(IS).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", n === Xu ? "start" : n === vl ? "end" : "middle"), I.each(function() {
      this.__axis = C;
    });
  }
  return p.scale = function(f) {
    return arguments.length ? (t = f, p) : t;
  }, p.ticks = function() {
    return e = Array.from(arguments), p;
  }, p.tickArguments = function(f) {
    return arguments.length ? (e = f == null ? [] : Array.from(f), p) : e.slice();
  }, p.tickValues = function(f) {
    return arguments.length ? (i = f == null ? null : Array.from(f), p) : i && i.slice();
  }, p.tickFormat = function(f) {
    return arguments.length ? (r = f, p) : r;
  }, p.tickSize = function(f) {
    return arguments.length ? (s = o = +f, p) : s;
  }, p.tickSizeInner = function(f) {
    return arguments.length ? (s = +f, p) : s;
  }, p.tickSizeOuter = function(f) {
    return arguments.length ? (o = +f, p) : o;
  }, p.tickPadding = function(f) {
    return arguments.length ? (a = +f, p) : a;
  }, p.offset = function(f) {
    return arguments.length ? (l = +f, p) : l;
  }, p;
}
function ES(n) {
  return Uc(Ku, n);
}
function OS(n) {
  return Uc(Xu, n);
}
function TS(n) {
  return Uc(Pf, n);
}
function FS(n) {
  return Uc(vl, n);
}
const Lf = Math.PI, If = 2 * Lf, lo = 1e-6, MS = If - lo;
function Em(n) {
  this._ += n[0];
  for (let t = 1, e = n.length; t < e; ++t)
    this._ += arguments[t] + n[t];
}
function RS(n) {
  let t = Math.floor(n);
  if (!(t >= 0)) throw new Error(`invalid digits: ${n}`);
  if (t > 15) return Em;
  const e = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, s = i.length; r < s; ++r)
      this._ += Math.round(arguments[r] * e) / e + i[r];
  };
}
class zd {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Em : RS(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, i, r) {
    this._append`Q${+t},${+e},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, e, i, r, s, o) {
    this._append`C${+t},${+e},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, e, i, r, s) {
    if (t = +t, e = +e, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = i - t, h = r - e, u = o - t, d = a - e, p = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (p > lo) if (!(Math.abs(d * l - h * u) > lo) || !s)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let f = i - o, m = r - a, b = l * l + h * h, x = f * f + m * m, y = Math.sqrt(b), v = Math.sqrt(p), k = s * Math.tan((Lf - Math.acos((b + p - x) / (2 * y * v))) / 2), C = k / v, I = k / y;
      Math.abs(C - 1) > lo && this._append`L${t + C * u},${e + C * d}`, this._append`A${s},${s},0,0,${+(d * f > u * m)},${this._x1 = t + I * l},${this._y1 = e + I * h}`;
    }
  }
  arc(t, e, i, r, s, o) {
    if (t = +t, e = +e, i = +i, o = !!o, i < 0) throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(r), l = i * Math.sin(r), h = t + a, u = e + l, d = 1 ^ o, p = o ? r - s : s - r;
    this._x1 === null ? this._append`M${h},${u}` : (Math.abs(this._x1 - h) > lo || Math.abs(this._y1 - u) > lo) && this._append`L${h},${u}`, i && (p < 0 && (p = p % If + If), p > MS ? this._append`A${i},${i},0,1,${d},${t - a},${e - l}A${i},${i},0,1,${d},${this._x1 = h},${this._y1 = u}` : p > lo && this._append`A${i},${i},0,${+(p >= Lf)},${d},${this._x1 = t + i * Math.cos(s)},${this._y1 = e + i * Math.sin(s)}`);
  }
  rect(t, e, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
}
function Om() {
  return new zd();
}
Om.prototype = zd.prototype;
function Ki(n) {
  return function() {
    return n;
  };
}
const $g = Math.abs, oi = Math.atan2, oo = Math.cos, DS = Math.max, Bh = Math.min, kr = Math.sin, Er = Math.sqrt, _i = 1e-12, ka = Math.PI, bc = ka / 2, Tm = 2 * ka;
function BS(n) {
  return n > 1 ? 0 : n < -1 ? ka : Math.acos(n);
}
function Ug(n) {
  return n >= 1 ? bc : n <= -1 ? -bc : Math.asin(n);
}
function Fm(n) {
  let t = 3;
  return n.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const i = Math.floor(e);
      if (!(i >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = i;
    }
    return n;
  }, () => new zd(t);
}
function jS(n) {
  return n.innerRadius;
}
function qS(n) {
  return n.outerRadius;
}
function zS(n) {
  return n.startAngle;
}
function $S(n) {
  return n.endAngle;
}
function US(n) {
  return n && n.padAngle;
}
function WS(n, t, e, i, r, s, o, a) {
  var l = e - n, h = i - t, u = o - r, d = a - s, p = d * l - u * h;
  if (!(p * p < _i))
    return p = (u * (t - s) - d * (n - r)) / p, [n + p * l, t + p * h];
}
function Bu(n, t, e, i, r, s, o) {
  var a = n - e, l = t - i, h = (o ? s : -s) / Er(a * a + l * l), u = h * l, d = -h * a, p = n + u, f = t + d, m = e + u, b = i + d, x = (p + m) / 2, y = (f + b) / 2, v = m - p, k = b - f, C = v * v + k * k, I = r - s, q = p * b - m * f, O = (k < 0 ? -1 : 1) * Er(DS(0, I * I * C - q * q)), F = (q * k - v * O) / C, M = (-q * v - k * O) / C, j = (q * k + v * O) / C, P = (-q * v + k * O) / C, A = F - x, T = M - y, _ = j - x, Z = P - y;
  return A * A + T * T > _ * _ + Z * Z && (F = j, M = P), {
    cx: F,
    cy: M,
    x01: -u,
    y01: -d,
    x11: F * (r / I - 1),
    y11: M * (r / I - 1)
  };
}
function HS() {
  var n = jS, t = qS, e = Ki(0), i = null, r = zS, s = $S, o = US, a = null, l = Fm(h);
  function h() {
    var u, d, p = +n.apply(this, arguments), f = +t.apply(this, arguments), m = r.apply(this, arguments) - bc, b = s.apply(this, arguments) - bc, x = $g(b - m), y = b > m;
    if (a || (a = u = l()), f < p && (d = f, f = p, p = d), !(f > _i)) a.moveTo(0, 0);
    else if (x > Tm - _i)
      a.moveTo(f * oo(m), f * kr(m)), a.arc(0, 0, f, m, b, !y), p > _i && (a.moveTo(p * oo(b), p * kr(b)), a.arc(0, 0, p, b, m, y));
    else {
      var v = m, k = b, C = m, I = b, q = x, O = x, F = o.apply(this, arguments) / 2, M = F > _i && (i ? +i.apply(this, arguments) : Er(p * p + f * f)), j = Bh($g(f - p) / 2, +e.apply(this, arguments)), P = j, A = j, T, _;
      if (M > _i) {
        var Z = Ug(M / p * kr(F)), V = Ug(M / f * kr(F));
        (q -= Z * 2) > _i ? (Z *= y ? 1 : -1, C += Z, I -= Z) : (q = 0, C = I = (m + b) / 2), (O -= V * 2) > _i ? (V *= y ? 1 : -1, v += V, k -= V) : (O = 0, v = k = (m + b) / 2);
      }
      var R = f * oo(v), Q = f * kr(v), H = p * oo(I), ct = p * kr(I);
      if (j > _i) {
        var nt = f * oo(k), N = f * kr(k), z = p * oo(C), G = p * kr(C), Y;
        if (x < ka)
          if (Y = WS(R, Q, z, G, nt, N, H, ct)) {
            var st = R - Y[0], vt = Q - Y[1], mt = nt - Y[0], _t = N - Y[1], Bt = 1 / kr(BS((st * mt + vt * _t) / (Er(st * st + vt * vt) * Er(mt * mt + _t * _t))) / 2), Rt = Er(Y[0] * Y[0] + Y[1] * Y[1]);
            P = Bh(j, (p - Rt) / (Bt - 1)), A = Bh(j, (f - Rt) / (Bt + 1));
          } else
            P = A = 0;
      }
      O > _i ? A > _i ? (T = Bu(z, G, R, Q, f, A, y), _ = Bu(nt, N, H, ct, f, A, y), a.moveTo(T.cx + T.x01, T.cy + T.y01), A < j ? a.arc(T.cx, T.cy, A, oi(T.y01, T.x01), oi(_.y01, _.x01), !y) : (a.arc(T.cx, T.cy, A, oi(T.y01, T.x01), oi(T.y11, T.x11), !y), a.arc(0, 0, f, oi(T.cy + T.y11, T.cx + T.x11), oi(_.cy + _.y11, _.cx + _.x11), !y), a.arc(_.cx, _.cy, A, oi(_.y11, _.x11), oi(_.y01, _.x01), !y))) : (a.moveTo(R, Q), a.arc(0, 0, f, v, k, !y)) : a.moveTo(R, Q), !(p > _i) || !(q > _i) ? a.lineTo(H, ct) : P > _i ? (T = Bu(H, ct, nt, N, p, -P, y), _ = Bu(R, Q, z, G, p, -P, y), a.lineTo(T.cx + T.x01, T.cy + T.y01), P < j ? a.arc(T.cx, T.cy, P, oi(T.y01, T.x01), oi(_.y01, _.x01), !y) : (a.arc(T.cx, T.cy, P, oi(T.y01, T.x01), oi(T.y11, T.x11), !y), a.arc(0, 0, p, oi(T.cy + T.y11, T.cx + T.x11), oi(_.cy + _.y11, _.cx + _.x11), y), a.arc(_.cx, _.cy, P, oi(_.y11, _.x11), oi(_.y01, _.x01), !y))) : a.arc(0, 0, p, I, C, y);
    }
    if (a.closePath(), u) return a = null, u + "" || null;
  }
  return h.centroid = function() {
    var u = (+n.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - ka / 2;
    return [oo(d) * u, kr(d) * u];
  }, h.innerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Ki(+u), h) : n;
  }, h.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Ki(+u), h) : t;
  }, h.cornerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Ki(+u), h) : e;
  }, h.padRadius = function(u) {
    return arguments.length ? (i = u == null ? null : typeof u == "function" ? u : Ki(+u), h) : i;
  }, h.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ki(+u), h) : r;
  }, h.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : Ki(+u), h) : s;
  }, h.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Ki(+u), h) : o;
  }, h.context = function(u) {
    return arguments.length ? (a = u ?? null, h) : a;
  }, h;
}
const GS = {
  draw(n, t) {
    const e = Er(t / ka);
    n.moveTo(e, 0), n.arc(0, 0, e, 0, Tm);
  }
}, VS = {
  draw(n, t) {
    const e = Er(t), i = -e / 2;
    n.rect(i, i, e, e);
  }
}, jh = Er(3), YS = {
  draw(n, t) {
    const e = -Er(t / (jh * 3));
    n.moveTo(0, e * 2), n.lineTo(-jh * e, -e), n.lineTo(jh * e, -e), n.closePath();
  }
};
function KS(n, t) {
  let e = null, i = Fm(r);
  n = typeof n == "function" ? n : Ki(n || GS), t = typeof t == "function" ? t : Ki(t === void 0 ? 64 : +t);
  function r() {
    let s;
    if (e || (e = s = i()), n.apply(this, arguments).draw(e, +t.apply(this, arguments)), s) return e = null, s + "" || null;
  }
  return r.type = function(s) {
    return arguments.length ? (n = typeof s == "function" ? s : Ki(s), r) : n;
  }, r.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Ki(+s), r) : t;
  }, r.context = function(s) {
    return arguments.length ? (e = s ?? null, r) : e;
  }, r;
}
const je = {
  precisionFixed: Cm,
  format: qd,
  select: x_,
  selectAll: __,
  scaleLinear: Lm,
  scaleSequential: Im,
  axisTop: ES,
  axisBottom: TS,
  axisRight: OS,
  axisLeft: FS,
  symbol: KS,
  path: Om,
  arc: HS,
  symbolTriangle: YS,
  symbolSquare: VS
};
function la(n) {
  return typeof n == "string" && n.length === 6 && !isNaN(+("0x" + n.replace("#", "")));
}
class XS {
  constructor({
    elementID: t,
    env: e = "production",
    main: i = !0,
    units: r = "decimal",
    decimalPlaces: s = 2,
    fractionRoundTo: o = 0,
    saw: a = null,
    app: l = !1,
    embed: h = !1,
    height: u = 0,
    width: d = 0,
    flipY: p = !1,
    flipX: f = !1,
    colors: m = {
      partA: "#1d9bc4",
      partB: "#127da1",
      partHover: "#29c778",
      partSelected: "#1bc319",
      stock: "#ffd166",
      text: "#ffffff"
    },
    options: b = {
      disableClick: !1,
      enableStretch: !0
    },
    vueComponent: x
  }) {
    tt(this, "env");
    tt(this, "main");
    //is this the main vis or not
    tt(this, "units", "decimal");
    tt(this, "decimalPlaces");
    tt(this, "fractionRoundTo");
    tt(this, "formatNumber", (t) => re(
      t,
      this.units,
      this.decimalPlaces ?? 2,
      !1,
      this.fractionRoundTo ?? 0
    ).toString());
    tt(this, "saw");
    tt(this, "stockType");
    tt(this, "numUniqueShapes");
    tt(this, "app");
    tt(this, "embed");
    tt(this, "height");
    tt(this, "width");
    tt(this, "device");
    tt(this, "vueComponent");
    tt(this, "elWidth");
    tt(this, "elHeight");
    tt(this, "w");
    tt(this, "h");
    tt(this, "padding");
    tt(this, "mobileBreakpoint");
    //scales
    tt(this, "xScale", je.scaleLinear());
    tt(this, "yScale", je.scaleLinear());
    tt(this, "yPositionScale", je.scaleLinear());
    tt(this, "xPositionScale", je.scaleLinear());
    tt(this, "yAxisScale", je.scaleLinear());
    tt(this, "measurementScale", je.scaleLinear());
    tt(this, "xAxis");
    tt(this, "yAxis");
    tt(this, "stretched");
    tt(this, "shapeXAxis");
    tt(this, "shapeYAxis");
    tt(this, "cutMeasurementXAxes");
    tt(this, "cutMeasurementYAxes");
    tt(this, "axisSpacing");
    tt(this, "flipY");
    tt(this, "flipX");
    tt(this, "colors");
    tt(this, "options");
    tt(this, "moveMode");
    tt(this, "moveRotation");
    tt(this, "moving");
    tt(this, "shape");
    tt(this, "shapeColorScale");
    tt(this, "scoreColorScale");
    tt(this, "hasTouch");
    tt(this, "highlightguillotine");
    tt(this, "debug", "");
    //groups | guillotine | positions
    tt(this, "elementID");
    //the id of the element to draw the vis in
    tt(this, "el");
    tt(this, "htmlEl");
    tt(this, "svgCanvas");
    tt(this, "axisGroup");
    tt(this, "stockGroup");
    tt(this, "stockWrappers");
    tt(this, "stock");
    tt(this, "shapeGroup");
    tt(this, "shapeWrappers");
    tt(this, "shapes");
    tt(this, "shapeIDText");
    tt(this, "shapeNameText");
    tt(this, "shapeLengthText");
    tt(this, "shapeWidthText");
    tt(this, "groupGroup");
    tt(this, "groups");
    tt(this, "bandingGroup");
    tt(this, "bandingWrappers");
    tt(this, "banding");
    tt(this, "segmentGroup");
    tt(this, "segments");
    tt(this, "segment");
    tt(this, "positionGroup");
    tt(this, "position");
    tt(this, "dotGroup");
    tt(this, "placementPositionGroup");
    tt(this, "dot");
    tt(this, "cutGroup");
    tt(this, "cuts");
    tt(this, "cut");
    if (!t) throw new Error("elementID is required");
    if (this.el = je.select(t), this.el === null) return;
    const y = this.el.node();
    if (y !== null) {
      this.htmlEl = y, this.vueComponent = x, this.env = Ve.call(this.vueComponent, ["env"]) === "development" ? "development" : "production", this.debug = this.env === "development" ? "groups" : "", this.app = l || !1, this.embed = h || !1, this.height = u, this.width = d, this.device = l ? "app" : "desktop", this.stretched = !1, this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.w = 0, this.h = 0, this.padding = 0, this.mobileBreakpoint = 450, this.main = i, this.saw = a, this.cutMeasurementXAxes = [], this.cutMeasurementYAxes = [], this.axisSpacing = 16, this.flipY = p, this.flipX = f, m = {
        ...m
      };
      for (const [v, k] of Object.entries(m))
        k && (m[v] = k.replace("#", ""));
      this.colors = {
        partA: la(m == null ? void 0 : m.partA) ? Pn("#" + m.partA) : Pn("#1d9bc4"),
        partB: la(m == null ? void 0 : m.partB) ? Pn("#" + m.partB) : Pn("#127da1"),
        partHover: la(m == null ? void 0 : m.partHover) ? Pn("#" + m.partHover) : Pn("#29c778"),
        partSelected: la(m == null ? void 0 : m.partSelected) ? Pn("#" + m.partSelected) : Pn("#1bc319"),
        stock: la(m == null ? void 0 : m.stock) ? Pn("#" + m.stock) : Pn("#ffd166"),
        text: la(m == null ? void 0 : m.text) ? Pn("#" + m.text) : Pn("#ffffff")
      }, this.shapeColorScale = je.scaleSequential([
        this.colors.partA,
        this.colors.partB
      ]), this.env = e, this.moveMode = !1, this.moving = !1, this.moveRotation = !1, this.units = r, this.decimalPlaces = s, this.fractionRoundTo = o, this.hasTouch = !1, this.options = b, this.init();
    }
  }
  /**
      * sets up the various wrappers - only needs to be called once
      * the z index is set by the order drawn
      */
  init() {
    if (!this.el) return !1;
    if ((this.decimalPlaces === null || this.decimalPlaces === void 0 || isNaN(this.decimalPlaces)) && (this.decimalPlaces = 2), (this.fractionRoundTo === null || this.fractionRoundTo === void 0 || isNaN(this.fractionRoundTo)) && (this.fractionRoundTo = 0), !this.svgCanvas) {
      if (this.htmlEl.querySelector("svg") === null) {
        const e = this.el.append("svg").attr("class", "vis");
        if (e === null) return;
        e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").attr("id", "stripes").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(90)").attr("id", "grain-l").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("id", "grain-w").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), this.svgCanvas = e;
      }
      this.axisGroup = this.svgCanvas.append("g").attr("class", "axis-group"), this.stockGroup = this.svgCanvas.append("g").attr("class", "stock-group"), this.shapeGroup = this.svgCanvas.append("g").attr("class", "shapes"), this.bandingGroup = this.svgCanvas.append("g").attr("class", "banding-group"), this.segmentGroup = this.svgCanvas.append("g").attr("class", "segments").attr("display", "none"), this.groupGroup = this.svgCanvas.append("g").attr("class", "groups").attr("display", "none"), this.positionGroup = this.svgCanvas.append("g").attr("class", "positions"), this.dotGroup = this.svgCanvas.append("g").attr("class", "dots"), this.env === "development" && (this.placementPositionGroup = this.svgCanvas.append("g").attr("class", "placements")), this.cutGroup = this.svgCanvas.append("g").attr("class", "cuts");
    }
    this.elWidth > 0 && this.updateSize(!0), this.hasTouch = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
  updateUnits(t, e, i) {
    t && (this.units = t), e && (this.decimalPlaces = e), i && (this.fractionRoundTo = i), this.refreshShapes(), this.refreshStock();
  }
  trimNameToFit(t, e) {
    function i(r, s, o) {
      const a = o[s], l = je.select(a);
      l.text(r.name);
      let h = l.text();
      const u = l.node();
      if (!u) return;
      let d = u.getComputedTextLength();
      const p = this.getWidthAttribute(r) - 20;
      for (; d > p && h.length > 0; )
        h = h.slice(0, -1), l.text(h.length ? h + "..." : ""), d = l.node().getComputedTextLength();
    }
    t.each(i.bind(e));
  }
  getShapeColor(t) {
    var e;
    if (this.env === "development")
      switch (this.debug) {
        case "guillotine":
          if (t.guillotineData.firstShape)
            return Pn(252, 3, 182);
          if (t.addedAsGroup)
            return Pn(43, 156, 16);
          if (typeof t.guillotineData.myPhase == "number") {
            const i = [0, 115, 255], r = [176, 255, 231];
            return `rgb(${i.map((o, a) => Math.round(o + t.guillotineData.myPhase / 5 * (r[a] - o))).join(",")})`;
          }
          break;
        case "groups":
          if (t.addedAsGroup !== !1)
            return Pn(43, 156, 16);
          break;
        case "priorityShapes":
          if (t != null && t.priority && ((e = t.priority) != null && e[t.stock.parentID]))
            return Pn(139, 171, 46);
          break;
        case "score":
          return this.scoreColorScale(t.bestScore.total);
      }
    return this.shapeColorScale(t.parentID - 1);
  }
  setDevice() {
    if (!(!this.htmlEl || this.htmlEl.style.display === "none") && this.htmlEl.offsetWidth) {
      if (this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.elWidth === 0) return !1;
      this.main ? this.elWidth <= this.mobileBreakpoint || this.app ? (this.device = "mobile", this.padding = 0) : (this.device = "desktop", this.padding = 50) : this.padding = 0, this.w = this.elWidth;
    }
  }
  //find the largest dimensions of all the stock (not just the active one)
  findLargestStockDimensions() {
    const t = Ve.call(this.vueComponent, ["stockList"]).filter((r) => r.used);
    if (!(t != null && t.length)) return [null, null];
    const e = t.reduce((r, s) => r.l > s.l ? r : s), i = t.reduce((r, s) => r.w > s.w ? r : s);
    return [e, i];
  }
  debounce(t, e, i = !1) {
    let r;
    return (...s) => new Promise((o) => {
      const a = () => {
        r = null, i || o(t.apply(this, s));
      };
      clearTimeout(r), i && !r && o(t.apply(this, s)), r = setTimeout(a, e);
    });
  }
  updateSize(t = !1) {
    return this.debounce(this._updateSize.bind(this), 10, t)();
  }
  requiresStretch(t, e = null) {
    return t ? (e === null && (e = t.w / t.l), e < 0.15) : !1;
  }
  setAspectRatio(t) {
    if (t) {
      this.w = this.elWidth;
      const e = t.w / t.l;
      this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.requiresStretch(t, e) && this.options.enableStretch ? (this.h = this.htmlEl.clientWidth * 0.15 + this.padding * 2, this.stretched = !0) : (this.h = this.xScale(t.getShortSide()) + this.padding, this.stretched = !1), this.yScale.domain([0, t.w]).range([this.padding, this.h - this.padding]), this.yAxisScale.domain(this.flipY ? [0, t.w] : [t.w, 0]).range([this.padding, this.h - this.padding]), this.yPositionScale.domain([0, t.w]).range(this.flipY ? [this.padding, this.h - this.padding] : [this.h - this.padding, this.padding]), e > 2 && (this.w = this.htmlEl.clientWidth / e + this.padding * 2, this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.h = this.xScale(t.getShortSide()) + this.padding), this.xPositionScale.domain([0, t.l]).range(this.flipX ? [this.w - this.padding, this.padding] : [this.padding, this.w - this.padding]), this.measurementScale.domain([0, t.l]).range([0, this.w - this.padding * 2]), this.w > 0 && this.h > 0 && (e > 2 ? this.el.style("width", this.w + "px") : this.el.style("width", ""), this.el.style("height", this.h + "px"));
    }
  }
  _updateSize() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    this.vueComponent && "suppressResizeObserver" in this.vueComponent && (this.vueComponent.suppressResizeObserver = !0);
    const t = Ve.call(this.vueComponent, ["stockList"]), e = Ve.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length) || !(e != null && e.length)) return !1;
    this.setDevice(), this.refreshStock(), this.refreshShapes(), this.env === "development" && this.refreshPlacementPositions();
  }
  refreshCuts() {
    const t = Ve.call(this.vueComponent, ["activeCuts"]);
    this.resetSegments(), this.initCuts(t);
  }
  refreshStock() {
    const t = Ve.call(this.vueComponent, ["stockList"]);
    if (!(t != null && t.length)) return !1;
    const e = Ve.call(this.vueComponent, ["activeStock"]);
    this.initStock(e), this.refreshCuts();
    const i = Ve.call(this.vueComponent, ["activeSegments"]);
    this.initSegments(i), this.resetPositions(), typeof this.vueComponent.toggleSegments == "function" && this.vueComponent.toggleSegments(!1);
  }
  refreshShapes() {
    const t = Ve.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length)) return !1;
    this.resetPositions();
    const e = Ve.call(this.vueComponent, ["activeShapes"]);
    this.initShapes(e, t);
  }
  refreshPlacementPositions() {
    const t = Ve.call(this.vueComponent, ["placementPositions"]);
    if (!(t != null && t.length)) return !1;
    this.resetPlacementPositions();
    const e = t.filter((i) => i.stockID === Ve.call(this.vueComponent, ["activeStock"]).id);
    this.initPlacementPositions(e);
  }
  recreateUerGroups(t) {
    t.filter((r) => r.inUserGroup);
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r].addedAsGroup, a = t.filter((l) => l.addedAsGroup === o);
      e.push(a), r += a.length;
    }
    const i = [];
    e.forEach((r) => {
      const s = Math.min(...r.map((u) => u.x)), o = Math.min(...r.map((u) => u.y)), a = Math.max(...r.map((u) => u.x + u.l)) - s, l = Math.max(...r.map((u) => u.y + u.w)) - o, h = {
        x: s,
        y: o,
        l: a,
        w: l,
        shapes: r
      };
      i.push(h);
    }), this.initGroups(i);
  }
  //init or update the stock
  initStock(t) {
    if (this.resetStock(), this.setAspectRatio(t), !t || !(t != null && t.w) || !(t != null && t.l) || !this.elWidth)
      return !1;
    this.stockType = t.type;
    let e;
    if (typeof t == "object" && (e = [t]), this.device === "desktop" && this.main) {
      this.xAxis = this.axisGroup.append("g").attr("transform", `translate(0, ${this.padding})`).attr("class", "axis stock x").call(je.axisTop(this.xScale).ticks(5).tickSize(5)).selectAll("text").attr("dy", -5);
      const i = this.requiresStretch(t);
      (!i || i && this.stretched) && (this.yAxis = this.axisGroup.append("g").attr(
        "transform",
        `translate(${this.w - this.padding}, 0)`
      ).attr("class", "axis stock y").call(je.axisRight(this.yAxisScale).ticks(5).tickSize(5)).selectAll("text").attr("dx", 5));
    }
    this.stockGroup.data(e).attr(
      "transform",
      () => `translate(${this.padding},${this.padding})`
    ), this.stockGroup.append("rect").attr("class", "background stock").style("fill", this.colors.stock).attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr("x", (i) => {
      i.x = 0;
      const r = i.x;
      i.x = 0;
      const s = this.getRectangleCoordinate(i, "x") - this.padding;
      return i.x = r, s;
    }).attr("y", (i) => {
      i.y = 0;
      const r = i.y;
      i.y = 0;
      const s = this.getRectangleCoordinate(i, "y") - this.padding;
      return i.y = r, s;
    }), this.stock = this.stockGroup.append("rect").attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr(
      "x",
      (i) => this.getRectangleCoordinate(i, "x") - this.padding
    ).attr(
      "y",
      (i) => this.getRectangleCoordinate(i, "y") - this.padding
    ).attr("class", "stock-pattern").style("fill", (i) => i != null && i.grain ? `url(#grain-${i.grain.toLowerCase()})` : "url(#stripes)");
  }
  getWidthAttribute(t) {
    return this.xScale(t.l) - this.padding;
  }
  getHeightAttribute(t) {
    return this.yScale(t.w) - this.padding;
  }
  //init or update the shapes
  initShapes(t, e) {
    var i, r, s;
    if (this.resetShapes(), !(!t || !t.length || !this.elWidth)) {
      if (this.numUniqueShapes = e.filter((o) => !o.duplicate).length, this.shapeColorScale.domain([0, this.numUniqueShapes]), (i = this == null ? void 0 : this.vueComponent) != null && i.gs) {
        Ze.call(this.vueComponent, ["shapeColors"], {});
        for (let o = t.length; o--; ) {
          const a = t[o];
          a.parentID && Ve.call(this.vueComponent, ["shapeColors", a.parentID]) || a.parentID && Ze.call(this.vueComponent, ["shapeColors", a.parentID], _a(this.shapeColorScale(parseInt(a.parentID) - 1)).formatHex());
        }
      }
      if (this.env === "development") {
        let o = 1 / 0, a = -1 / 0;
        for (const u of t) {
          const d = (r = u == null ? void 0 : u.bestScore) == null ? void 0 : r.total;
          if (d !== 0 && d !== null && d !== void 0) {
            o = d, a = d;
            break;
          }
        }
        const l = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p === 0 || p === null || p === void 0 ? u : p < u ? p : u;
        }, o), h = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p == null ? u : p > u ? p : u;
        }, a);
        this.scoreColorScale = je.scaleSequential([Pn(251, 224, 255), Pn(122, 0, 138)]).domain([l, h]);
      }
      if (!t || !t.length || (this.shapeWrappers = this.shapeGroup.selectAll("g").data(t).join("g").attr("class", "shape-group"), !this.shapeWrappers.size())) return !1;
      if (this.shapes = this.shapeWrappers.append("rect").attr("class", "shape").attr("fill", (o) => this.getShapeColor(o)).attr("stroke-width", () => this.env === "development" ? 3 : 0).attr("width", (o) => this.getWidthAttribute(o)).attr("height", (o) => this.getHeightAttribute(o)), this.main) {
        const o = [];
        t.forEach((a) => {
          if (a != null && a._banding)
            for (const [l, h] of Object.entries(a._banding)) {
              if (!h || ["a", "b", "c", "d"].includes(l)) continue;
              let u = l;
              if (a.rot)
                switch (l) {
                  case "x1":
                    u = "y1";
                    break;
                  case "x2":
                    u = "y2";
                    break;
                  case "y1":
                    u = "x2";
                    break;
                  case "y2":
                    u = "x1";
                    break;
                }
              switch (u) {
                case "x1":
                  o.push({
                    x1: a.x,
                    x2: a.x,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x1"
                  });
                  break;
                case "x2":
                  o.push({
                    x1: a.x + a.l,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x2"
                  });
                  break;
                case "y1":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y,
                    type: "y1"
                  });
                  break;
                case "y2":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y + a.w,
                    y2: a.y + a.w,
                    type: "y2"
                  });
                  break;
              }
            }
        }), this.bandingWrappers = this.bandingGroup.selectAll("g").data(o).join("line").attr("class", "banding").attr(
          "x1",
          (a) => this.xPositionScale(a.x1) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "x2",
          (a) => this.xPositionScale(a.x2) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "y1",
          (a) => this.yPositionScale(a.y1) + this.getBandingAdjustment(a.type, "y")
        ).attr(
          "y2",
          (a) => this.yPositionScale(a.y2) + this.getBandingAdjustment(a.type, "y")
        ).attr("stroke-width", 2).attr("stroke", "white"), this.shapeIDText = this.shapeWrappers.append("text").attr("class", "shape-text id").text((a) => {
          var l, h;
          if (this.env === "development")
            switch (this.debug) {
              case "guillotine": {
                const u = a.guillotineData.myStripDirection, d = a.addedAsGroup;
                let p = "";
                return u === "l" ? p = `→ ${a.parentID}` : u === "w" && (p = `↑ ${a.parentID}`), (h = a == null ? void 0 : a.priotity) != null && h[(l = a == null ? void 0 : a.stock) == null ? void 0 : l.parentID] && (p += "P"), d && (p += "G"), p.length ? p : this.shapeNameText;
              }
              case "groups":
                {
                  const u = a.addedAsGroup;
                  if (u) return u.split(".")[0].toUpperCase();
                }
                break;
              case "positions":
                return a.id;
            }
          return a.parentID ? a.parentID : a.getParentID();
        }).classed("hidden", (a, l, h) => {
          const u = h[l].getBBox();
          return u.width >= this.measurementScale(a.l) || u.height >= this.yScale(a.w) - this.padding;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeNameText = this.shapeWrappers.append("text").attr("class", "shape-text name").text((a) => !(a != null && a.name) || typeof (a == null ? void 0 : a.name) != "string" ? null : a.name.toUpperCase().trim()).call(this.trimNameToFit, this).classed("hidden", (a, l, h) => h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 40).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeLengthText = this.shapeWrappers.append("text").attr("class", "shape-text length").text((a) => this.debug === "guillotine" ? "" : re(
          a.l,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          var d;
          return this.app ? this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50 : ((d = a == null ? void 0 : a.stock) == null ? void 0 : d.type) === "linear" ? !1 : h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 30;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeWidthText = this.shapeWrappers.append("text").attr("class", "shape-text width").text((a) => this.debug === "guillotine" ? "" : re(
          a.w,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          if (this.app)
            return this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50;
          const u = h[l].getBBox();
          return this.measurementScale(a.l) < 30 || u.height >= this.measurementScale(a.w);
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      }
      (this.main || this.app) && !((s = this == null ? void 0 : this.options) != null && s.disableClick) && (this.shapes.on("mousedown", (o, a) => {
        var l, h, u, d, p;
        if (this.moving) return !1;
        if (this.env === "development") {
          if (console.clear(), a) {
            let f = ["id", "placementOrder", "priority", "addedAsGroup"];
            this.debug === "guillotine" ? f = [
              "id",
              "placementOrder",
              "priority",
              "guillotineData.myPhase",
              "guillotineData.myStripDirection",
              "guillotineData.myStripParent",
              "guillotineData.firstShape",
              "addedAsGroup"
            ] : this.debug === "groups" && (f = [
              "id",
              "addedAsGroup"
            ]), console.table(f.reduce((m, b) => {
              const x = Wg(a, b);
              return m[b] = Array.isArray(x) ? x.join(", ") : x, m;
            }, {}));
          }
          if (this.debug === "guillotine") {
            this.shapeWrappers.selectAll(".highlight-a").classed("highlight-a", !1), this.shapeWrappers.selectAll(".highlight-b").classed("highlight-b", !1), this.shapeWrappers.selectAll(".highlight-c").classed("highlight-c", !1);
            const f = (l = a.guillotineData) == null ? void 0 : l.myStripParent, m = (u = (h = t.find((b) => b.id === f)) == null ? void 0 : h.guillotineData) == null ? void 0 : u.myStripParent;
            f && this.shapeWrappers.filter((y) => y.id === f || y.addedAsGroup === f).select("rect").classed("highlight-a", !0), m && this.shapeWrappers.filter((y) => y.id === m || y.addedAsGroup === f).select("rect").classed("highlight-b", !0);
          }
        }
        if (this.app || this.embed) {
          const f = {
            name: a.name,
            id: a.id,
            x: a.x,
            y: a.y,
            l: a.l,
            w: a.w,
            banding: a != null && a.banding && typeof a.banding == "object" ? a.banding : null,
            rot: a.rot,
            stock: (d = a == null ? void 0 : a.stock) == null ? void 0 : d.id,
            color: (p = this.getShapeColor(a)) == null ? void 0 : p.toString(),
            notes: a == null ? void 0 : a.notes
          }, m = new CustomEvent("partClick", {
            detail: f
          });
          if (this.env === "development" && console.log(f), this.htmlEl.dispatchEvent(m), this.app) return !1;
        }
        if (this.device === "desktop" && (this.resetCutMeasurementAxes(), this.addShapeAxes(a)), this.moveMode) {
          const f = ba.call(this.vueComponent, "partsBin");
          f && f.addToPartBin(a);
        } else
          this.findShape(a.id);
      }), !this.app && !this.hasTouch && this.shapes.on(
        "mouseover",
        (o) => {
          this != null && this.moveMode && this.moving || (je.select(o.target).classed("hover", !0), je.select(o.target).classed("selected") || je.select(o.target).style(
            "fill",
            this.colors.partHover.toString()
          ));
        },
        {
          passive: !0
        }
      ).on(
        "mouseout",
        (o, a) => {
          var l;
          je.select(o.target).classed("hover", !1), je.select(o.target).classed("selected") || je.select(o.target).style(
            "fill",
            (l = this.getShapeColor(a)) == null ? void 0 : l.toString()
          );
        },
        {
          passive: !0
        }
      )), this.setShapePosition();
    }
  }
  findShapeElement(t) {
    const e = this.shapeWrappers.filter((i) => i.id === t);
    return e.empty() ? null : e.node();
  }
  findShape(t) {
    const e = this.findShapeElement(t), i = Ve.call(this.vueComponent, ["shapeList"]).find((r) => r.id === t);
    e && this.selectShape(e, i);
  }
  selectShape(t, e) {
    Ze.call(this.vueComponent, ["examineShape"], e), this.shapes.classed("selected", !1), this.shapes.style("fill", (r) => this.getShapeColor(r));
    const i = je.select(t).select("rect");
    i && (i.classed("selected", !0), i.style("fill", this.colors.partSelected.toString()));
  }
  /**
      * update SHAPE visibility - used for replay
      * @param {Number} number
      */
  updateShapeVisibility(t) {
    var e;
    (e = this == null ? void 0 : this.shapeWrappers) == null || e.style("visibility", (i) => (i == null ? void 0 : i.placementOrder) >= t ? "hidden" : "visible");
  }
  isCutComplete(t, e, i) {
    return t.guillotineData.parentSegmentID === e && i && t.guillotineData.segmentCutOrder < i;
  }
  isCutInsideSegment(t, e) {
    var i;
    return ((i = t.guillotineData) == null ? void 0 : i.parentSegmentID) !== null && !(t != null && t.isTrim) ? t.guillotineData.parentSegmentID === e : !1;
  }
  //update CUT visibility
  updateCutVisibility(t, e = null, i = "") {
    var h, u, d, p, f, m, b, x, y;
    if (e === null || t == null || this != null && this.cuts.empty()) return;
    this.resetShapeAxes(), this.resetCutMeasurementAxes(), je.select(this.cuts.nodes()[e].parentNode).raise();
    const r = (h = t.guillotineData) == null ? void 0 : h.parentSegmentID, s = this.getHalfBladeWidth(t.stock), o = t.dimension === "l" ? "y" : "x", a = (u = t == null ? void 0 : t.stock) == null ? void 0 : u.trim, l = i === "ptx" ? "ptxOrder" : "order";
    if ((((d = t == null ? void 0 : t.stock) == null ? void 0 : d.cutType) === "guillotine" || ((p = t == null ? void 0 : t.stock) == null ? void 0 : p.cutType) === "beam") && r !== null && typeof r < "u") {
      if (this.cuts.style("visibility", (v) => typeof t.guillotineData[l] == "number" && v.guillotineData[l] <= t.guillotineData[l] || !i && v.guillotineData.parentSegmentID === r ? "visible" : "hidden"), this.cuts.classed("highlight", (v) => t.stock.cutType === "guillotine" && v.isTrim ? v.type === t.type : v.guillotineData[l] === t.guillotineData[l]), this.cuts.classed("ptx-dummy", (v) => v.guillotineData.ptxDummyCut), !i) {
        const v = (f = t == null ? void 0 : t.guillotineData) == null ? void 0 : f.segmentCutOrder;
        if (v == null)
          return;
        this.cuts.classed("completed", (O) => this.isCutComplete(O, r, v)), this.cuts.classed("inside-segment", (O) => this.isCutInsideSegment(O, r));
        let k, C;
        const I = this.getCutSegments(t);
        if (I === !1) return;
        const q = (b = I == null ? void 0 : I.siblings) == null ? void 0 : b[(m = I.main) != null && m.hasBeamTrim ? v - 1 : v];
        q && ((t == null ? void 0 : t.dimension) === "l" ? k = [
          [
            q.y,
            q.y + q.w
          ],
          [
            t.y1 + s,
            (I == null ? void 0 : I.main.y) + (I == null ? void 0 : I.main.w)
          ]
        ] : (t == null ? void 0 : t.dimension) === "w" && (k = [
          [
            q.x,
            q.x + q.l
          ],
          [
            t.x1 + s,
            (I == null ? void 0 : I.main.x) + (I == null ? void 0 : I.main.l)
          ]
        ]), (t == null ? void 0 : t.dimension) === "l" ? C = [(x = t == null ? void 0 : t.distances) == null ? void 0 : x.bottom, t == null ? void 0 : t.distances.top] : (t == null ? void 0 : t.dimension) === "w" && (C = [t == null ? void 0 : t.distances.left, (y = t == null ? void 0 : t.distances) == null ? void 0 : y.right]), this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(k, C, o));
      }
    } else {
      this.cuts.style("visibility", (k, C) => C <= e ? "visible" : "hidden");
      let v;
      if ((t == null ? void 0 : t.dimension) === "l" ? v = [
        [0 + (a.y1 ?? 0), t.y1 - s],
        [
          t.y1 + s,
          t.stock.w - (a != null && a.y2 ? a.y2 : 0)
        ]
      ] : (t == null ? void 0 : t.dimension) === "w" && (v = [
        [0 + (a.x1 ?? 0), t.x1 - s],
        [
          t.x1 + s,
          t.stock.l - (a != null && a.x2 ? a.x2 : 0)
        ]
      ]), v != null && v.length) {
        const k = [
          v[0][1] - v[0][0],
          v[1][1] - v[1][0]
        ];
        this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(v, k, o);
      }
      this.cuts.classed(
        "highlight",
        (k, C) => C === e
      );
    }
    this.cuts.attr("stroke-width", (v, k) => {
      var q;
      let C = Math.ceil(this.measurementScale(this.getBladeWidth(v.stock)));
      const I = (q = t == null ? void 0 : t.guillotineData) == null ? void 0 : q.segmentCutOrder;
      return (this.isCutComplete(v, r, I) || this.isCutInsideSegment(v, r)) && (C += 1), k === e && Math.ceil(this.measurementScale(this.getBladeWidth(v.stock))) < 5 && (C = 5), C;
    });
  }
  //highlight a specific cut (by order or index), segments and related measurements
  showCut(t, e = null, i = "") {
    var h;
    if (e === null) return !1;
    if (this.updateCutVisibility(t, e, i), i === "ptx") {
      this.resetSegments();
      return;
    }
    const r = this.getCutSegments(t);
    if (r === !1) return;
    const { main: s, siblings: o } = r;
    if (!((h = t == null ? void 0 : t.guillotineData) != null && h.parentSegmentID))
      return this.initSegments([s]);
    const a = o == null ? void 0 : o.length;
    let l = [];
    if (a) {
      for (let d = a; d--; )
        o[d] && (o[d].completed = !1);
      if (t.guillotineData.segmentCutOrder === void 0 || t.guillotineData.segmentCutOrder === null)
        return;
      const u = t.guillotineData.segmentCutOrder;
      for (let d = 0; d < a; d++)
        d < u && (o[d].completed = !0);
      l.push(...o), l = l.filter((d) => d);
    }
    l.length && (this.resetSegments(), this.initSegments(l));
  }
  /**
      * toggle the visibility of the shapes
      * @param {Boolean} show
      */
  toggleShapes(t = !1) {
    t ? (this.shapeGroup.attr("display", "block"), this.bandingGroup.attr("display", "block")) : (this.shapeGroup.attr("display", "none"), this.bandingGroup.attr("display", "none"));
  }
  /**
      * add measurements to an axis
      * @param {Array} measurements array of arrays
      * @param {Array} values array of values
      * @param {String} axis x | y
      */
  addCutMeasurementAxes(t, e, i) {
    !i || !(t != null && t.length) || t.forEach((r, s) => {
      const o = r[0], a = r[1];
      if (i === "x") {
        const l = je.scaleLinear().domain([o, a]).range([
          this.xPositionScale(o),
          this.xPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(0, ${this.h - this.padding + this.axisSpacing})`
        ).attr("class", "axis measurement x").call(je.axisBottom(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ), this.cutMeasurementXAxes.push(u);
      } else {
        const l = je.scaleLinear().domain([o, a]).range([
          this.yPositionScale(o),
          this.yPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(${this.padding - this.axisSpacing}, 0)`
        ).attr("class", "axis measurement y").call(je.axisLeft(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ).attr(
          "dx",
          (d, p, f) => f[p].getBBox().width / 4
        ).attr(
          "transform",
          (d, p, f) => "rotate(90) translate(" + f[p].getBBox().width / 4 + ")"
        ), this.cutMeasurementYAxes.push(u);
      }
    });
  }
  /**
      * add the shape axes
      * @param {Shape} shape
      */
  addShapeAxes(t) {
    var l;
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
    const e = t.x, i = t.x + t.l, r = je.scaleLinear().domain([e, i]).range([this.xPositionScale(e), this.xPositionScale(i)]), s = t.y, o = t.y + t.w, a = je.scaleLinear().domain([s, o]).range([this.yPositionScale(s), this.yPositionScale(o)]);
    this.shapeXAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(0, ${this.h - this.padding + this.axisSpacing})`
    ).attr("class", "axis shape x").call(je.axisBottom(r).tickValues(r.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeXAxis.selectAll("text").attr("dx", (h, u, d) => {
      const p = d[u];
      if (p === null) return;
      const f = p.getBBox();
      return u === 0 ? -f.width / 2 : f.width / 2;
    }), ((l = t == null ? void 0 : t.stock) == null ? void 0 : l.type) !== "linear" && (this.shapeYAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(${this.padding - this.axisSpacing}, 0)`
    ).attr("class", "axis shape y").call(je.axisLeft(a).tickValues(a.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeYAxis.selectAll("text").attr("x", 0).attr("y", 0).attr(
      "dy",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.height) + 2;
      }
    ).attr(
      "dx",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2;
      }
    ).attr("transform", (h, u, d) => {
      var p, f, m, b, x, y, v, k;
      return this.flipY ? u === 0 ? "rotate(90) translate(-" + ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2 + ")" : "rotate(90) translate(" + ((b = (m = d[u]) == null ? void 0 : m.getBBox()) == null ? void 0 : b.width) / 2 + ")" : u === 0 ? "rotate(90) translate(" + ((y = (x = d[u]) == null ? void 0 : x.getBBox()) == null ? void 0 : y.width) / 2 + ")" : "rotate(90) translate(-" + ((k = (v = d[u]) == null ? void 0 : v.getBBox()) == null ? void 0 : k.width) / 2 + ")";
    }));
  }
  getBandingAdjustment(t, e) {
    switch (t) {
      case "y1":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? 1 : -1;
        break;
      case "y2":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? -1 : 1;
        break;
      case "x1":
        if (e === "x") return this.flipX ? -1 : 1;
        if (e === "y") return 0;
        break;
      case "x2":
        if (e === "x") return this.flipX ? 1 : -1;
        if (e === "y") return 0;
        break;
    }
    return 0;
  }
  getRectangleCoordinate(t, e, i, r) {
    let s;
    if (e === "x") {
      let o;
      switch (i) {
        case "center":
          o = this.xPositionScale(t.x + t.l / 2), r && (o += r);
          break;
        case "right":
          o = this.xPositionScale(t.x + t.l), r && (o -= r);
          break;
        case "left":
        default:
          o = this.xPositionScale(this.flipX ? t.x - t.l : t.x), r && (o -= r);
      }
      s = o;
    } else if (e === "y") {
      let o;
      switch (i) {
        case "center":
          o = this.yPositionScale(t.y + t.w / 2), r && (o += r);
          break;
        case "bottom":
          o = this.yPositionScale(this.flipY ? t.y + t.w : t.y), r && (o += r);
          break;
        case "top":
        default:
          o = this.yPositionScale(this.flipY ? t.y : t.y + t.w), r && (o -= r);
      }
      s = o;
    }
    return s;
  }
  getRotatedSide(t) {
    switch (t) {
      case "x1":
      case "l1":
        return "w1";
      case "x2":
      case "l2":
        return "w2";
      case "y1":
      case "w1":
        return "l2";
      case "y2":
      case "w2":
        return "l1";
    }
  }
  /**
      * update the position of the shapes and the content within
      */
  setShapePosition() {
    if (!this.shapes) return !1;
    this.shapes.attr("x", (t) => this.getRectangleCoordinate(t, "x")).attr("y", (t) => this.getRectangleCoordinate(t, "y")).attr("width", (t) => this.getWidthAttribute(t)).attr("height", (t) => this.getHeightAttribute(t)), this.main && (this.shapeIDText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t) => this.getRectangleCoordinate(t, "y", "center")).attr("dy", 1), this.shapeNameText && this.shapeNameText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "bottom",
      -(i[e].getBBox().height / 2 + 1)
    )), this.shapeLengthText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "top",
      -(i[e].getBBox().height / 2 + 2)
    )), this.shapeWidthText.attr(
      "transform",
      (t, e, i) => `translate(${this.getRectangleCoordinate(
        t,
        "x",
        "left",
        -(i[e].getBBox().height / 2 + 2)
      )},${this.getRectangleCoordinate(t, "y", "center")}) ${this.device === "mobile" ? "rotate(90)" : "rotate(-90)"}`
    ));
  }
  //init or update the cuts
  initCuts(t) {
    if (this.resetCuts(), !t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.cuts = this.cutGroup.selectAll("line").data(t).join("line").attr("class", "cut").attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    }).attr("x1", (e) => this.xPositionScale(e.getVisCoords("x1"))).attr("x2", (e) => this.xPositionScale(e.getVisCoords("x2"))).attr("y1", (e) => this.yPositionScale(e.getVisCoords("y1"))).attr("y2", (e) => this.yPositionScale(e.getVisCoords("y2"))).classed("trim", (e) => e.isTrim);
  }
  //init or update the segments
  initSegments(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetSegments(), this.segments = this.segmentGroup.selectAll("rect").data(t).join("rect").attr("class", "segment").style("opacity", (e) => {
      if ((e == null ? void 0 : e.offcut) === !0) return 0.5;
    }).classed("offcut", (e) => e.offcut).classed("merged", (e) => e.merged).classed("near", (e) => e.shapePosition === "near").classed("far", (e) => e.shapePosition === "far").classed("completed", (e) => e.completed).attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.segmentGroup.selectAll("text").data(t).join("text").attr("class", "segment-text").attr("x", (e) => this.getRectangleCoordinate(e, "x", "center")).attr("y", (e) => this.getRectangleCoordinate(e, "y", "center")).attr("text-anchor", "middle").text((e) => {
      if (this.env !== "development" || e.offcut) return null;
      if (e.cutDirection === "l")
        return this.env === "development" ? `→ ${e.id}` : "→";
      if (e.cutDirection === "w")
        return this.env === "development" ? `↑ ${e.id}` : "↑";
    }).attr("dominant-baseline", "middle"), !this.app && this.env === "development" && this.segments.on("mousedown", function(e, i) {
      const r = structuredClone(i);
      console.log([
        "id",
        "x",
        "y",
        "l",
        "w",
        "cutDirection",
        "cutPreference"
      ].reduce((o, a) => (o[a] = Wg(r, a), o), {}));
    });
  }
  initGroups(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetGroups(), this.groups = this.groupGroup.selectAll("rect").data(t).join("rect").attr("class", "group").attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.groupGroup.attr("display", "block");
  }
  //get relevant segments for a specific cut
  getCutSegments(t) {
    var o, a, l, h;
    const e = (o = t == null ? void 0 : t.guillotineData) == null ? void 0 : o.parentSegmentID, i = ((l = (a = this.vueComponent) == null ? void 0 : a.gs) == null ? void 0 : l.activeSegments) ?? ((h = this.vueComponent) == null ? void 0 : h.activeSegments);
    if (!i.length) return !1;
    let r;
    if (e ? r = i.find((u) => u.id === e) : r = i.find((u) => u.segmentType === "root"), r === void 0) return !1;
    const s = r == null ? void 0 : r.children;
    if (s != null && s.length) {
      const u = s.map((p) => {
        const f = i.find((m) => m.x === p.x && m.y === p.y && m.l === p.l && m.w === p.w);
        return f !== void 0 ? f : null;
      }).filter((p) => p !== null);
      return {
        main: r,
        siblings: u
      };
    }
    return !1;
  }
  /**
      * toggle the visibility of the segments
      * @param {Boolean} show
      */
  toggleSegments(t = !0) {
    t ? this.segmentGroup.attr("display", "block") : this.segmentGroup.attr("display", "none");
  }
  /**
      * show a list of possible movement positions
      */
  initPositions(t, e) {
    if (!e || !t || !this.main) return !1;
    let i;
    if (e.trimDimensions(), !t.willItFit(e, t.rot)) return !1;
    e.removeTrim();
    const r = Ve.call(this.vueComponent, ["shapeList"]).filter((l) => {
      var h;
      return l.added && ((h = l == null ? void 0 : l.stock) == null ? void 0 : h.id) === e.id;
    }), s = Dy(
      null,
      r,
      e
    );
    let o;
    if (e.cutType === "efficiency") {
      if (this.env === "development") {
        const l = Y0(r, e);
        this.positionGroup.selectAll("line").remove();
        const h = l.flatMap((u) => Object.values(u.rays));
        this.positionGroup.selectAll("line").data(h).enter().append("line").attr("x1", (u) => this.xPositionScale(u.x1)).attr("x2", (u) => this.xPositionScale(u.x2)).attr("y1", (u) => this.yPositionScale(u.y1)).attr("y2", (u) => this.yPositionScale(u.y2)).attr("stroke", "rgba(245, 66, 227, 0.5)").attr("stroke-width", 2).on("mousedown", (u, d) => console.log(d));
      }
      o = By(
        e,
        r
      );
    }
    const a = new Io();
    for (const l of s.toArray()) {
      const h = K0(t, l, e);
      h && a.addPoints(h.toArray());
    }
    if (o) {
      const l = o.toArray();
      for (const h of l) {
        const u = My(t, h, e);
        u && a.addPoints(u.toArray());
      }
    }
    e.cutType === "efficiency" ? ([
      new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Hn(
        e.l - t.l - (e.trim.x2 ?? 0),
        0 + (e.trim.y1 ?? 0)
      ),
      new Hn(
        0 + (e.trim.x1 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      ),
      new Hn(
        e.l - t.l - (e.trim.x2 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      )
    ].forEach((l) => a.addPoint(l)), i = a.toArray()) : (a.addPoint(new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0))), i = a.toArray());
    for (let l = i.length; l--; ) {
      const h = i[l];
      t.x = h.x, t.y = h.y;
      for (const u of r)
        if (this.collision(t, u, e)) {
          i.splice(l, 1);
          break;
        }
    }
    return this.positionGroup.selectAll("rect").data(i).join("rect").attr("data-id", (l, h) => h).attr("class", "shape ghost").attr("x", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("y", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y"))).attr("width", this.getWidthAttribute(t)).attr("height", this.getHeightAttribute(t)).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = ba.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), this.hasTouch || this.positionGroup.selectAll("rect").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), je.select(this).classed("hover", !0), je.select(this).raise();
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), je.select(this).classed("hover", !1);
      },
      {
        passive: !0
      }
    ), this.dotGroup.selectAll("circle").data(i).join("circle").attr("data-id", (l, h) => h).attr("class", "dot").classed("raycast", (l) => this.env !== "development" ? !1 : l.raycast).attr("cx", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("cy", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y", "bottom"))).attr("r", 8).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = ba.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), t.x = 0, t.y = 0, this.hasTouch || this.dotGroup.selectAll("circle").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), je.select(this).classed("hover", !0);
        const h = je.select(this).attr("data-id"), u = je.select(`.ghost[data-id="${h}"]`);
        u.raise(), u.classed("highlight", !0);
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), je.select(this).classed("hover", !1);
        const h = je.select(this).attr("data-id");
        je.select(`.ghost[data-id="${h}"]`).classed(
          "highlight",
          !1
        );
      },
      {
        passive: !0
      }
    ), !!(i != null && i.length);
  }
  /**
      * show a list of placement positions
      */
  initPlacementPositions(t) {
    if (!(this.env !== "development" || this.debug !== "positions")) {
      if (!(t != null && t.length)) return !1;
      this.placementPositionGroup.selectAll("circle").data(t).join("circle").attr("data-id", (e, i) => i).attr("class", "dot").attr("cx", (e) => this.xPositionScale(e.x)).attr("cy", (e) => this.yPositionScale(e.y)).attr("r", 3).on("mousedown", (e) => {
        e.stopPropagation();
      });
    }
  }
  /**
      * toggle the visibility of the cuts
      * @param {Boolean} show
      */
  toggleCuts(t = !0) {
    t ? this.cutGroup.attr("display", "block") : this.cutGroup.attr("display", "none");
  }
  clearSelection() {
    var t;
    this != null && this.shapes && (this.shapes.classed("selected", !1), this.shapes.classed("hover", !1), this.shapes.style("fill", (e) => this.getShapeColor(e))), this != null && this.cuts && (this.cuts.classed("selected", !1), this.cuts.classed("highlight", !1), this.cuts.classed("inside-segment", !1), this.cuts.style("visibility", "visible"), this.cuts.attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    })), (t = this == null ? void 0 : this.shapes) != null && t.length && this.shapes.classed("selected", !1);
  }
  /**
      * add padding
      * this.padding will be 0 when necessary
      * @param {number} value
      */
  addPadding(t) {
    return t + this.padding;
  }
  /**
      * @param {Container} container
      * @returns {number} blade width
      */
  getBladeWidth(t = null) {
    var e, i;
    return Dt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.bladeWidth) ? (i = this.saw) == null ? void 0 : i.bladeWidth : Dt(t) && t !== null ? t.getBladeWidth() : 0;
  }
  getHalfBladeWidth(t = null) {
    const e = this.getBladeWidth(t);
    return e !== void 0 && e > 0 ? e / 2 : 0;
  }
  resetShapes() {
    this.shapeGroup && this.shapeGroup.selectAll("*").remove(), this.bandingGroup && this.bandingGroup.selectAll("*").remove(), this.resetShapeAxes();
  }
  resetShapeAxes() {
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
  }
  resetStock() {
    this.stockGroup && this.stockGroup.selectAll("*").remove(), this.axisGroup && this.axisGroup.selectAll("*").remove(), this.resetStockAxes();
  }
  resetStockAxes() {
    this.xAxis && this.xAxis.remove(), this.yAxis && this.yAxis.remove();
  }
  resetCuts() {
    this.cutGroup && this.cutGroup.selectAll("*").remove(), this.resetCutMeasurementAxes();
  }
  resetSegments() {
    this.segmentGroup && this.segmentGroup.selectAll("*").remove();
  }
  resetGroups() {
    this.groupGroup && this.groupGroup.selectAll("*").remove();
  }
  resetCutMeasurementAxes() {
    var t, e;
    (t = this.cutMeasurementXAxes) != null && t.length && (this.cutMeasurementXAxes.forEach((i) => i.remove()), this.cutMeasurementXAxes.length = 0), (e = this.cutMeasurementYAxes) != null && e.length && (this.cutMeasurementYAxes.forEach((i) => i.remove()), this.cutMeasurementYAxes.length = 0);
  }
  resetPositions() {
    this.positionGroup && this.positionGroup.selectAll("*").remove(), this.dotGroup && this.dotGroup.selectAll("*").remove();
  }
  resetPlacementPositions() {
    this.placementPositionGroup && this.dotGroup.selectAll("*").remove();
  }
  reset() {
    this.resetPositions(), this.resetPlacementPositions(), this.resetShapes(), this.resetStock(), this.resetCuts(), this.resetSegments();
  }
  /**
      * detect collision - required for move mode
      * @param {object} thisShape
      * @param {object} testShape
      * @param {object} container
      * @returns {boolean} true if collision
      */
  collision(t, e, i) {
    if (t.id === e.id)
      throw new Error("collision comparing to self");
    return (
      // 1 left
      t.x < e.x + e.l + this.getBladeWidth(i) && // 2 right
      t.x + t.l + this.getBladeWidth(i) > e.x && // 3 bottom
      t.y < e.y + e.w + this.getBladeWidth(i) && // 4 top
      t.y + t.w + this.getBladeWidth(i) > e.y
    );
  }
}
function Wg(n, t) {
  return t.split(".").reduce((e, i) => e[i], n);
}
function JS(n = "issues", t, e, i = null) {
  var s;
  if (!t || !((s = t == null ? void 0 : t[n]) != null && s.length)) return !1;
  if (t[n].map((o) => o.field).flat().includes(e))
    return i ? t[n].map((a) => a.subField).flat().includes(i) : !0;
}
function ZS(n) {
  if (!fa(n)) return !1;
  const t = Object.getOwnPropertyDescriptor(n, "value");
  return (t == null ? void 0 : t.configurable) === !1;
}
function Ze(n, t) {
  var l;
  if (!(n != null && n[0]) || !this) return !1;
  const e = (h) => fa(h) ? ZS(h) ? "shallowRef" : "ref" : bp(h) ? "reactive" : !I2(h) && typeof h == "object" ? "raw" : "ref";
  let i, r, s;
  if ("gs" in this && typeof ((l = this.gs) == null ? void 0 : l[n[0]]) < "u")
    i = this.gs, r = xo(this.gs, n), s = n[n.length - 1];
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    i = this, r = xo(this, n), s = n[n.length - 1];
  else
    return !1;
  if (fa(r))
    return r.value = t, !0;
  const o = e(r || t);
  let a = t;
  switch (o) {
    case "shallowRef":
      a = uo(t);
      break;
    case "raw":
      typeof t == "object" && t !== null && t.constructor !== Object && t.constructor !== Array ? a = da(t) : Array.isArray(t) ? a = da(t.map((h) => typeof h == "object" && h !== null && h.constructor !== Object ? h : JSON.parse(JSON.stringify(h)))) : a = typeof t == "object" ? da(JSON.parse(JSON.stringify(t))) : da(t);
      break;
    case "ref":
      fa(t) ? a = t : a = Ce(t);
      break;
    case "reactive":
      a = bp(t) ? t : Ar(t);
      break;
  }
  if (n.length > 1) {
    const h = n.slice(0, -1), u = xo(i, h);
    if (fa(u))
      return kg(u.value, s, a), !0;
  }
  return kg(i, n, a), !0;
}
function Ve(n) {
  var e;
  if (!(n != null && n[0]) || !this) return null;
  let t;
  if ("gs" in this && typeof ((e = this == null ? void 0 : this.gs) == null ? void 0 : e[n[0]]) < "u")
    t = xo(this.gs, n);
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    t = xo(this, n);
  else
    return console.warn("getData path not found", n), null;
  return fa(t) || t && typeof t == "object" && "value" in t ? t.value : t;
}
function Zk(n) {
  var t;
  if (!(n != null && n[0])) return null;
  if ("optionsStore" in this && typeof ((t = this == null ? void 0 : this.optionsStore) == null ? void 0 : t[n[0]]) < "u")
    return xo(this.optionsStore, n);
  if (typeof (this == null ? void 0 : this[n[0]]) < "u") return xo(this, n);
}
function vc(n) {
  n.queue = 0, n.stockCount = 0, n.shapeCount = 0, n.resultCount = 0, n.complete = !1;
}
function QS(n, t) {
  return n != null && n.length ? n.find((e) => e.id === t) : null;
}
function t6(n, t, e = "") {
  if (!(n != null && n.length) || !t) return [];
  const i = n.filter((r) => {
    var s, o, a;
    if (e) {
      if (e === "ptx") return (((a = r == null ? void 0 : r.stock) == null ? void 0 : a.id) ?? (r == null ? void 0 : r.stockId)) === t.id;
    } else return (((s = r == null ? void 0 : r.stock) == null ? void 0 : s.id) ?? (r == null ? void 0 : r.stockId)) === t.id && !((o = r == null ? void 0 : r.guillotineData) != null && o.ptxDummyCut);
  });
  return i.sort((r, s) => {
    var o, a;
    return ((o = r == null ? void 0 : r.guillotineData) == null ? void 0 : o.order) - ((a = s == null ? void 0 : s.guillotineData) == null ? void 0 : a.order);
  }), i;
}
function e6(n) {
  return n != null && n.length ? n.filter((t) => t.used === !0) : [];
}
function n6(n = !1) {
  let t = Ve.call(this, ["inputStock"]);
  if (!(t != null && t.length)) return [{ message: "No stock input" }];
  const e = Ve.call(this, ["stockList"]);
  e && (e.length = 0);
  const i = [];
  n && (t = [t[0]]);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    !(s != null && s.q) && !s.autoAdd && !n || i.push(...this.createStock(s, r));
  }
  return i;
}
function i6() {
  const n = Ve.call(this, ["vis"]);
  if (!n) return;
  const t = Ve.call(this, ["shapeList"]);
  if (!(t != null && t.length)) return !1;
  n.resetPositions(), n.resetShapes();
  const e = Ve.call(this, ["activeShapes"]);
  n.initShapes(e, t);
  const i = ba.call(this, "PartsBin");
  i && i.clear(!1);
}
function r6() {
  const n = Ve.call(this, ["vis"]);
  if (!n) return;
  const t = Ve.call(this, ["stockList"]);
  if (!(t != null && t.length)) return !1;
  const e = Ve.call(this, ["activeStock"]);
  n.initStock(e);
  const i = Ve.call(this, ["activeCuts"]);
  n.initCuts(i);
  const r = Ve.call(this, ["activeSegments"]);
  n.initSegments(r), n.resetPositions(), typeof this.toggleSegments == "function" && this.toggleSegments(!1), this != null && this.cutMode && (this == null || this.showCut(0));
}
function s6() {
  var t;
  const n = ((t = this == null ? void 0 : this.gs) == null ? void 0 : t.vis) ?? (this == null ? void 0 : this.vis);
  n && (n.clearSelection(), n.resetShapeAxes(), n.resetCutMeasurementAxes(), n.resetPositions());
}
function o6(n) {
  Ve.call(this, ["examineShape"]) && (this.examineShape = null), Ze.call(this, ["activeStockId"], n);
}
function Hg() {
  return this != null && this.$parent ? this.$parent : null;
}
function ba(n, t = 0) {
  var r;
  let e = this;
  for (let s = 0; s < t; s++) {
    if (!Hg.call(e))
      return null;
    e = Hg.call(e);
  }
  const i = (r = e == null ? void 0 : e.$refs) == null ? void 0 : r[n];
  return i || null;
}
function a6(n = void 0) {
  return this.socket = Vu(n, {
    withCredentials: !0,
    //this is required to send passport user data
    autoConnect: !1
  }), this.socket.on("connect", () => {
    Ze.call(this, ["connected"], !0);
  }), this.socket.on("maintenance", () => {
    Ze.call(this, ["maintenanceMode"], !0), this.socket.disconnect(), this.env === "development" && console.log("SmartCut - maintenance mode flag received from server");
  }), this.socket.on("connect_error", (t) => {
    Ze.call(this, ["connected"], !1), console.warn(`SmartCut - socket connect_error: ${t.message}`), typeof alert < "u" && alert("We are having trouble connecting to the server. Please try again later."), this.socket.close();
  }), this.socket.on("message", (t) => console.log(t)), this.socket.on("user", (t) => {
    Ze.call(this, ["user"], t);
  }), this.socket.on("queued", () => {
    Ze.call(this, ["progress", "queue"], 1);
  }), this.socket.on("jobInProgess", (t) => (alert(`You already have a job in progress, please wait for it to finish

Job ID: ${t}`), !1)), this.socket.on("jobStart", () => Ze.call(this, ["progress", "queue"], 2)), this.socket.on("progress", (t) => {
    const e = t.data;
    if (typeof e.shapeCount < "u" && Ze.call(this, ["progress", "shapeCount"], e.shapeCount), typeof e.stockCount < "u" && Ze.call(this, ["progress", "stockCount"], e.stockCount), !e.stockCount && !e.shapeCount) {
      const i = Ve.call(this, ["progress", "resultCount"]);
      Ze.call(this, ["progress", "resultCount"], i + 1);
    }
  }), this.socket.on("upgrade", () => {
    "showUpgradeModal" in this && typeof this.showUpgradeModal == "function" && this.showUpgradeModal(), Ze.call(this, ["thinking"], !1);
  }), this.socket.on("error", (t) => {
    var i;
    Ze.call(this, ["thinking"], !1);
    const e = Ve.call(this, ["reset"]);
    typeof e == "function" && e(), console.error("SmartCut error:", t), (i = window == null ? void 0 : window.top) == null || i.postMessage(
      {
        type: "scError",
        message: t
      },
      "*"
    ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage(t), typeof this.showModalMessage == "function" && this.showModalMessage({
      heading: "Issue",
      main: t ? `<p>${t}</p>` : "<p>We are having trouble connecting to the server.</p><p>Please try again later and let us know.</p>"
    });
  }), this.socket.on("result", (t) => {
    var l, h, u, d, p, f, m, b, x, y;
    this.socket.disconnect();
    const e = t.result;
    if (Ze.call(this, ["metadata"], e.metadata ?? {}), Ze.call(this, ["unusableShapes"], e.unusableShapes ?? []), Ze.call(this, ["unavailableStock"], e.unavailableStock ?? []), !((l = e.shapeList) != null && l.length) || !((h = e.stockList) != null && h.length)) {
      const v = Ve.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let k = "<p>We did not manage to fit any parts.</p>";
        (u = e == null ? void 0 : e.unusableShapes) != null && u.length ? (k = "<p>No parts were usable.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "Parts unusable",
          main: k,
          buttonText: "Show me",
          buttonCallback: (C) => {
            C.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (k += "<p>Please double check your list.</p>", this.$nextTick(() => {
          this.showModalMessage({
            heading: "Parts unusable",
            main: k
          });
        }));
      }
      return (d = window == null ? void 0 : window.top) == null || d.postMessage(
        {
          type: "scError",
          message: "No parts were added - please double check your list."
        },
        "*"
      ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage("No parts were added - please double check your list."), Ze.call(this, ["thinking"], !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0), !1;
    }
    e.shapeList.find((v) => !v.added) && typeof this.showModalMessage == "function" && this.$nextTick(() => {
      this.showModalMessage({
        heading: "Parts not used",
        main: "<p>We did not use all your parts.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>",
        buttonText: "Show me",
        buttonCallback: (v) => {
          v.showInputPanel(
            "parts",
            "inputs-unusable-parts"
          );
        }
      });
    }), Ze.call(this, ["progress", "complete"], !0), Ze.call(this, ["jobId"], t == null ? void 0 : t.jobId), typeof this.toggleWidget == "function" && (this.toggleWidget("updateStock", !1), this.toggleWidget("options", !1), this.toggleWidget("offcuts", !1), this.toggleWidget("results", !1), this.toggleWidget("cutlist", !1), this.toggleWidget("export", !1), this.toggleWidget("labels", !1));
    let i;
    e != null && e.saw && (i = new js(
      e == null ? void 0 : e.saw,
      ((p = e == null ? void 0 : e.saw) == null ? void 0 : p.stockType) ?? ((m = (f = e.stockList) == null ? void 0 : f[0]) == null ? void 0 : m.type)
    ), Ze.call(this, ["saw"], i));
    const r = Bb({
      saw: i,
      stockList: e.stockList,
      removeScores: !0,
      preventAutoRotation: !0
    });
    Ze.call(this, ["stockList"], r);
    const s = Ve.call(this, ["usedStock"]);
    s.length && Ze.call(this, ["activeStockId"], s[0].id), Ze.call(
      this,
      ["shapeList"],
      jb({
        shapeList: e.shapeList,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.cutList && Ze.call(
      this,
      ["cutList"],
      qb({
        cutList: e.cutList,
        stockList: r
      })
    ), e != null && e.segmentList && Ze.call(
      this,
      ["segmentList"],
      zb({
        segmentList: e.segmentList,
        stockList: r
      })
    ), e != null && e.offcuts && Ze.call(
      this,
      ["offcuts"],
      Ub({
        offcuts: e.offcuts,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.metadata && Ze.call(this, ["metadata"], e.metadata), (b = e == null ? void 0 : e.evolutionVisData) != null && b.length ? Ze.call(this, ["evolutionVisData"], e.evolutionVisData) : typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "evolution", !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "workbench", !0), Ze.call(this, ["thinking"], !1);
    const o = ba.call(this, "inputs");
    if (o && (o != null && o.success) && (o.success = !1), Ve.call(this, ["addedShapes"]).length === 0) {
      const v = Ve.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let k = "<p>We could not fit any parts.</p>";
        (x = e == null ? void 0 : e.unusableShapes) != null && x.length ? (k += "<p>Some parts were not usable - click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "No layouts",
          main: k,
          buttonText: "More info",
          buttonCallback: (C) => {
            C.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (k += "<p>Please double check your list.</p>", this.showModalMessage({
          heading: "No layouts",
          main: k
        }));
      }
      (y = window == null ? void 0 : window.top) == null || y.postMessage(
        {
          type: "scError",
          message: "No parts were added."
        },
        "*"
      ), console.warn("No parts were added."), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0);
    }
  }), this.socket;
}
function l6(n) {
  return !n || !Co(n, !0) ? "" : Object.values(n).filter((t) => t).join("|");
}
function $d(n, t, e = "Options") {
  if (!e && `${t}` in n && typeof n[t] == "object") return !0;
  const i = `${t}${e}`;
  return !!(e && i in n && typeof n[i] == "object");
}
function Ud(n) {
  return `${n}Options`;
}
function u6(n, t, e) {
  const i = Ud(t);
  for (const r in n[i]) {
    const s = Object.keys(n[i][r]);
    for (const o of s)
      e.includes(o) || o in n[i][r] && delete n[i][r][o];
    for (const o of e)
      (r === "all" || !(o in n[i][r])) && (n[i][r][o] = "");
  }
}
function c6(n, t, e = !0) {
  if (!$d(n, t, "Options")) return;
  const i = n[t], r = Object.keys(i);
  for (const s of r)
    Mm(n, t, s, e);
  e && Rm(n, t, "all");
}
function Mm(n, t, e, i = !0) {
  i && Rm(n, t, e), e !== "all" && $d(n, t) && (n[t][e] = !1);
}
function Rm(n, t, e) {
  if (!$d(n, t, "Options")) return;
  const r = n[`${t}Options`][e];
  if (typeof r != "object" || r === null) return;
  Object.keys(r).forEach((o) => r[o] = "");
}
function Dm(n, t, e, i, r, s) {
  var u;
  const o = t + "Options";
  if (!((u = n == null ? void 0 : n[o]) != null && u[e]) || !(i in n[o][e])) return;
  Tl(n, t, e, !1), n[o][e][i] = r;
  const a = n[o][e], l = Object.values(a || {}).filter((d) => d);
  if (!Array.isArray(l)) return;
  const h = wc(n, t, e, s);
  Tl(n, t, e, !!Jn(h));
}
function h6(n, t, e, i, r = [], s) {
  const o = t + "Options";
  if (!n[o] || typeof n[o] != "object") return;
  const a = Object.keys(n[o]);
  if (!a.length) return;
  const l = wc(n, t, "all", s), h = n[o][e], u = Object.values(h || {}).filter((d) => d);
  for (const d of a)
    d !== "all" && (r.includes(d) || (Dm(n, t, d, e, i, s), Array.isArray(u) || Tl(n, t, d, !1), Tl(n, t, d, !!Jn(l))));
}
function Tl(n, t, e, i) {
  var o;
  if (e === "all") return;
  const r = Ud(t), s = l6((o = n == null ? void 0 : n[r]) == null ? void 0 : o[e]);
  i ? n[t][e] = s || !0 : n[t][e] = !1;
}
function wc(n, t, e, i) {
  var l;
  const r = t + "Options";
  if (!((l = n == null ? void 0 : n[r]) != null && l[e])) return !1;
  const s = n[r][e], o = Object.values(s || {}).filter((h) => h);
  if (!Array.isArray(o) || !i || typeof i != "function")
    return !1;
  const a = i(t, o);
  return t === "banding" && p1(e) && Jn(a) ? Ob(n, e, a) / 1e3 : a;
}
function Qk(n) {
  n != null && n.type && delete n.type, f6.call(this, n);
}
function f6(n) {
  if (!(n != null && n.banding) || typeof n.banding != "object") return;
  const t = Object.keys(n.banding);
  if (!t.length) return;
  const e = ["labels", "pricing"];
  if (!t.every((i) => e.includes(i)))
    console.warn("SmartCut - legacy banding data provided - please update to use { labels: string[], pricing: Record<string, number> }");
  else return;
  n.banding = {
    labels: Object.keys(n.banding),
    pricing: n.bandingPricing
  };
}
function d6(n) {
  if (n != null && n.enable) return;
  n.enable = {};
  const t = {
    showDiagram: { new: "diagram", map: "equal" },
    enableFocus: { new: "focus", map: "equal" },
    enableMachining: { new: "machining", map: "equal" },
    enableCSVImport: { new: "csvImport", map: "equal" },
    showProgressNumber: { new: "progressNumber", map: "equal" },
    disableBanding: { new: "banding", map: "reverse" },
    disableFinish: { new: "finish", map: "reverse" },
    disableOrientation: { new: "orientation", map: "reverse" },
    disableClick: { new: "click", map: "reverse" },
    disablePartName: { new: "partName", map: "reverse" }
  };
  for (const e of Object.keys(t))
    e in n && (n.enable[t[e].new] = t[e].map === "reverse" ? !n[e] : n[e], delete n[e]);
  console.log(n);
}
function Ef(n = 0, t, e = null, i = null, r = null) {
  if (!cr(e) && !ho || i === "stock") return !1;
  let s, o;
  if (cr(e) ? s = e.orientationLock : ho(e) ? s = e.direction : i === "shape" && (s = r), n === 0 || ho(e))
    switch (t) {
      case "n":
        o = s === "w" || r === "w";
        break;
      case "l":
      case "y":
        o = s === "w" || r === "w";
        break;
      case "w":
        o = s === "l" || r === "l";
        break;
      default:
        o = r === "w";
    }
  else if (n === 1)
    o = e.w > e.l;
  else if (n === 2)
    switch (t) {
      case "n":
        o = e.w > e.l;
        break;
      case "y":
      case "l":
        o = e.w > e.l;
        break;
      case "w":
        o = e.l >= e.w;
        break;
      default:
        o = !1;
    }
  return o;
}
function Gg(n, t, e = null, i = null, r = null) {
  if (!cr(e) || i === "shape") return !1;
  let s;
  return n === 0 || n === 1 ? Ef(n, t, e, i, r) ? "cc" : !1 : n === 2 ? t === "w" ? e.l < e.w ? "c" : "cc" : !1 : s;
}
function p6(n) {
  n.banding && (n.banding = xc(n.banding, "cc")), n.trim && (n.trim = xc(n.trim, "cc"));
}
function g6(n, t = 0) {
  return t && (t === 1 || t === 2) && (n.preventAutoRotation = !0, t === 2 && n.l < n.w && p6(n)), n;
}
function xc(n, t = "cc", e = {
  x1: "y1",
  x2: "y2",
  y1: "x1",
  y2: "x2"
}, i = {
  a: "d",
  b: "a",
  c: "b",
  d: "c"
}) {
  const r = {
    x1: null,
    x2: null,
    y1: null,
    y2: null
  };
  if (t === "c") {
    for (const [s, o] of Object.entries(e))
      r[o] = n[s];
    for (const [s, o] of Object.entries(i))
      o in n && (r[o] = n[s]);
  } else if (t === "cc") {
    for (const [s, o] of Object.entries(e))
      r[s] = n[o];
    for (const [s, o] of Object.entries(i))
      o in n && (r[s] = n[o]);
  }
  return console.log(r), r;
}
const m6 = {
  name: "StockNavigation",
  props: {
    stockList: {
      type: Array,
      default: () => []
    },
    primaryColor: {
      type: String,
      default: ""
    },
    secondaryColor: {
      type: String,
      default: ""
    },
    activeStockId: {
      type: String,
      default: null
    }
  },
  emits: ["show-stock"],
  methods: {
    showStock(n) {
      this.$emit("show-stock", n);
    }
  }
}, Pa = (n, t) => {
  const e = n.__vccOpts || n;
  for (const [i, r] of t)
    e[i] = r;
  return e;
}, y6 = { id: "mini-stock-nav" }, b6 = ["onMousedown"], v6 = { class: "id" };
function w6(n, t, e, i, r, s) {
  return ee(), de("div", y6, [
    (ee(!0), de(Zn, null, Lr(e.stockList, (o, a) => (ee(), de("button", {
      key: a,
      class: di(["nav-button", { selected: o.id === e.activeStockId }]),
      type: "button",
      style: jn({
        backgroundColor: o.id === e.activeStockId ? "#" + e.secondaryColor : "#" + e.primaryColor
      }),
      onMousedown: (l) => s.showStock(o.id)
    }, [
      be("div", v6, mn(a + 1), 1),
      Xg(be("div", { class: "stack legibility" }, mn(o.stack), 513), [
        [Jg, typeof o.stack == "number" && o.stack > 1]
      ])
    ], 46, b6))), 128))
  ]);
}
const x6 = /* @__PURE__ */ Pa(m6, [["render", w6]]), _6 = {
  name: "Spinner",
  props: {
    size: {
      type: Number,
      default: 100
    },
    showNumber: {
      type: Boolean,
      default: !0
    },
    number: {
      type: Number,
      default: 0
    },
    complete: {
      type: Boolean,
      default: !1
    }
  }
}, S6 = { id: "spinner" }, k6 = ["width", "height"], A6 = {
  key: 2,
  id: "spinner-number",
  class: "stock-number"
};
function N6(n, t, e, i, r, s) {
  return ee(), de("div", S6, [
    e.complete ? Pe("", !0) : (ee(), de("svg", {
      key: 0,
      class: "loading",
      style: jn({ width: e.size + "px", height: e.size + "px" }),
      width: e.size,
      height: e.size,
      viewBox: "0 0 300 300"
    }, t[0] || (t[0] = [
      E2('<rect class="square s1" x="0" y="0"></rect><rect class="square s2" x="100" y="0"></rect><rect class="square s3" x="200" y="0"></rect><rect class="square s4" x="0" y="100"></rect><rect class="square s5" x="200" y="100"></rect><rect class="square s6" x="0" y="200"></rect><rect class="square s7" x="100" y="200"></rect>', 7)
    ]), 12, k6)),
    e.complete ? (ee(), de("svg", {
      key: 1,
      class: "complete",
      style: jn({ width: e.size + "px", height: e.size + "px" }),
      viewBox: "0 0 448 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, t[1] || (t[1] = [
      be("path", { d: "m203.3 331.3c-6.2 6.3-16.4 6.3-22.6 0l-64-64c-6.3-6.2-6.3-16.4 0-22.6 6.2-6.3 16.4-6.3 22.6 0l52.7 52.7 116.7-116.7c6.2-6.3 16.4-6.3 22.6 0 6.3 6.2 6.3 16.4 0 22.6zm-203.3-235.3c0-35.35 28.65-64 64-64h320c35.3 0 64 28.65 64 64v320c0 35.3-28.7 64-64 64h-320c-35.35 0-64-28.7-64-64zm32 0v320c0 17.7 14.33 32 32 32h320c17.7 0 32-14.3 32-32v-320c0-17.67-14.3-32-32-32h-320c-17.67 0-32 14.33-32 32z" }, null, -1)
    ]), 4)) : Pe("", !0),
    e.showNumber ? (ee(), de("div", A6, mn(e.number), 1)) : Pe("", !0)
  ]);
}
const Vg = /* @__PURE__ */ Pa(_6, [["render", N6]]);
function C6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "decimal" : "text" : n === "float" ? "decimal" : n === "integer" ? "numeric" : "text";
}
function P6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "number" : "text" : n === "checkbox" ? "checkbox" : n === "float" || n === "integer" ? "number" : "text";
}
function L6(n, t = null, e = "decimal") {
  switch (n) {
    case "float":
    case "integer":
    case "string":
      return n;
    case "unitDependent":
      return e === "decimal" ? "float" : "string";
    case "checkbox":
      return t || "boolean";
    case "select":
      return t || "string";
    default:
      return "string";
  }
}
function I6(n) {
  return !!n;
}
function E6(n, t) {
  return t ? t.split(".").reduce((i, r) => i && i[r] !== "undefined" ? i[r] : void 0, n) : null;
}
function O6(n, t, e, i = !0) {
  const r = t.split(".");
  let s = n;
  for (let o = 0; o < r.length - 1; o++)
    s[r[o]] || (s[r[o]] = {}), s = s[r[o]];
  (i || !Dt(s[r[r.length - 1]])) && (s[r[r.length - 1]] = e);
}
function T6(n, t, e, i, r = !0) {
  var o;
  if (!n || !e || !i || !((o = n == null ? void 0 : n[t]) != null && o[e])) return;
  const s = n[t][e].find((a) => a.id === i);
  if (s)
    return r ? s.enabled = !0 : s.enabled = !1, !0;
}
function F6(n, t, e) {
  var i;
  return (i = n == null ? void 0 : n[t]) != null && i[e] ? n[t][e].filter((r) => r.enabled === !0).map((r) => r.id) : [];
}
function M6(n, t, e, i, r = []) {
  const s = F6(n, e, i);
  if (!s.length) return [];
  const o = t.filter((l) => s.includes(l.id) || l.custom === !0), a = o.filter((l) => (l == null ? void 0 : l.fieldMap) && !l.fieldMap.startsWith("customData."));
  if (s.length !== a.length) {
    const l = new Set(a.map((u) => u.id)), h = o.map((u) => u.id).filter((u) => !l.has(u)).map((u) => `'${u}'`);
    console.warn(`Inputs - these fields do not have a field definition - ${h.join()}`);
  }
  return r.length && o.sort((l, h) => {
    const u = r.indexOf(l.id), d = r.indexOf(h.id);
    return u === -1 ? 1 : d === -1 ? -1 : u - d;
  }), o;
}
const R6 = ["id"], D6 = {
  key: 0,
  class: "delete",
  viewBox: "0 0 512 512",
  xmlns: "http://www.w3.org/2000/svg"
}, B6 = /* @__PURE__ */ is({
  __name: "OrientationButton",
  props: {
    id: { default: "" },
    orientationModel: { default: 0 },
    rectangleType: { default: null },
    rectangle: { default: () => null },
    shapeOrientation: { default: "" },
    stockGrain: { default: "n" },
    buttonBackground: { default: "#848484" },
    iconColor: { default: "#FFFFFF" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["updateOrientation"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = Ce(0), s = sn(() => {
      if (!e.rectangle) return ["l", "w"];
      if (ho(e.rectangle)) return ["l", "w"];
      let y = ["", "l", "w"];
      return e.rectangle.multiEdit && (y = [" ", "", "l", "w"]), o.value && (y = y.filter((v) => v !== "w")), y;
    }), o = sn(() => {
      var y, v, k, C;
      return cr(e.rectangle) || Uu(e.rectangle) ? e.rectangle.isSquare() : e.rectangleType && ((y = e.rectangle) != null && y.l) && ((v = e.rectangle) != null && v.w) ? ((k = e.rectangle) == null ? void 0 : k.l) === ((C = e.rectangle) == null ? void 0 : C.w) : !1;
    }), a = () => {
      if (!cr(e.rectangle)) return "";
      let y = "";
      switch (e.orientationModel) {
        case 0:
          y = f.value;
          break;
        case 1:
          e.stockGrain === "y" || e.stockGrain === "n" ? y = e.rectangle.l >= e.rectangle.w ? "l" : "w" : e.rectangle.l >= e.rectangle.w ? y = e.stockGrain : y = y = e.stockGrain === "l" ? "w" : "l";
          break;
        case 2:
          y = e.rectangle.l >= e.rectangle.w ? "l" : "w";
          break;
      }
      return y;
    }, l = (y) => s.value.findIndex((k) => k === y), h = () => {
      if (e.disabled || s.value.length <= 1) return;
      let y = null;
      if ([1, 2].includes(e.orientationModel))
        if (f.value === "") {
          const v = a();
          y = s.value.findIndex((k) => k === v);
        } else
          y = s.value.findIndex((v) => v === "");
      else e.orientationModel === 0 && (y = l(f.value) + 1, y > s.value.length - 1 && (y = 0));
      r.value = y;
    }, u = (y) => {
      (y.key === "Enter" || y.key === " ") && h();
    }, d = (y) => {
      i("updateOrientation", y);
    }, p = () => {
      const y = f.value;
      switch (e.orientationModel) {
        case 0:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        case 1:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        case 2:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        default:
          return "default";
      }
    }, f = sn(() => {
      let y = "";
      return ho(e.rectangle) ? y = e.rectangle.direction : cr(e.rectangle) ? y = e.rectangle.orientationLock : Uu(e.rectangle) && (y = e.rectangle.grain), y;
    }), m = sn(() => ho(e.rectangle) || !e.rectangle ? {
      l: null,
      w: null
    } : {
      l: e.rectangle.l,
      w: e.rectangle.w
    }), b = sn(() => Ef(
      e.orientationModel,
      e.stockGrain,
      e.rectangle,
      e.rectangleType,
      e.shapeOrientation
    )), x = sn(() => {
      var C;
      if (!e.rectangle)
        return e.shapeOrientation ? "noGrain" : "freeRotation";
      if (Uu(e.rectangle) || e.rectangleType === "stock")
        return {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom"
        }[e.rectangle.grain] || "noGrain";
      const y = {
        n: { " ": "delete", l: "leftRight", w: "leftRight", default: "freeRotation" },
        y: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        l: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        w: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        default: { " ": "delete", l: "leftRight", w: "topBottom", default: "freeRotation" }
      }, v = e.stockGrain || "default";
      let k = "default";
      return cr(e.rectangle) || e.rectangleType === "shape" ? k = p() : ho(e.rectangle) && (k = e.rectangle.direction || "default"), ((C = y[v]) == null ? void 0 : C[k]) || y[v].default;
    });
    return hr(r, (y) => {
      d(s.value[y]);
    }, { immediate: !1 }), hr(m, () => {
      if (!e.rectangle || e.orientationModel === 0 || !cr(e.rectangle)) return;
      const y = a();
      f.value && f.value !== y && d(y);
    }, { immediate: !1 }), Lo(() => {
      document.addEventListener("keydown", u), cr(e.rectangle) ? r.value = l(a()) : r.value = l(f.value);
    }), Of(() => {
      document.removeEventListener("keydown", u);
    }), (y, v) => (ee(), de("div", {
      id: y.id,
      class: di(["orientation-button", { rot: b.value, square: o.value, disabled: y.disabled, [x.value]: !0 }]),
      tabindex: "0",
      "aria-label": "Part orientation",
      style: jn({
        backgroundColor: y.buttonBackground
      }),
      onClick: h
    }, [
      x.value === "delete" ? (ee(), de("svg", D6, v[0] || (v[0] = [
        be("path", { d: "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z" }, null, -1)
      ]))) : Pe("", !0),
      x.value === "freeRotation" ? (ee(), de("svg", {
        key: 1,
        class: "arrow",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 67 63",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[1] || (v[1] = [
        be("g", null, [
          be("path", { d: "m9.296 31.378c0-3.305.67-6.455 1.88-9.322 3.642-8.621 12.179-14.678 22.12-14.678 10.63 0 19.656 6.927 22.806 16.509" }),
          be("path", { d: "m57.296 31.378c0 13.246-10.754 24-24 24-10.631 0-19.656-6.926-22.806-16.508" }),
          be("path", { d: "m61.183 5.408-4.622 17.851-18.347-1.838" }),
          be("path", { d: "m5.408 57.349 4.622-17.851 18.348 1.838" })
        ], -1)
      ]), 4)) : Pe("", !0),
      x.value === "leftRight" ? (ee(), de("svg", {
        key: 2,
        class: "arrow",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 72 39",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[2] || (v[2] = [
        be("g", null, [
          be("path", { d: "m5.408 19.408h61.095" }),
          be("g", null, [
            be("path", { d: "m52.695 5.408 13.808 14-13.808 14" }),
            be("path", { d: "m17.408 33.408-12-14 12-14" })
          ])
        ], -1)
      ]), 4)) : Pe("", !0),
      x.value === "topBottom" ? (ee(), de("svg", {
        key: 3,
        class: "arrow",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 39 72",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[3] || (v[3] = [
        be("g", null, [
          be("path", { d: "m19.408 66.503v-61.095" }),
          be("g", null, [
            be("path", { d: "m5.408 19.216 14-13.808 14 13.808" }),
            be("path", { d: "m33.408 54.503-14 12-14-12" })
          ])
        ], -1)
      ]), 4)) : Pe("", !0),
      x.value === "grainLeftRight" ? (ee(), de("svg", {
        key: 4,
        class: "grain",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 106 64",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[4] || (v[4] = [
        be("g", null, [
          be("path", { d: "m3 3h99.887" }),
          be("path", { d: "m3.113 32h99.887" }),
          be("path", { d: "m3.113 61h99.887" })
        ], -1)
      ]), 4)) : Pe("", !0),
      x.value === "grainTopBottom" ? (ee(), de("svg", {
        key: 5,
        class: "grain",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 64 106",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[5] || (v[5] = [
        be("g", null, [
          be("path", { d: "m61 3v99.887" }),
          be("path", { d: "m32 3.113v99.887" }),
          be("path", { d: "m3 3.113v99.887" })
        ], -1)
      ]), 4)) : Pe("", !0)
    ], 14, R6));
  }
}), j6 = ["id"], q6 = /* @__PURE__ */ is({
  __name: "BandingButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    orientationModel: { default: 0 },
    stockGrain: { default: "n" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = Ce({
      x1: !1,
      x2: !1,
      y1: !1,
      y2: !1
    });
    hr(() => e.inputShape.orientationLock, () => {
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 }), hr([
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.banding;
      },
      () => e.orientationModel,
      () => e.stockGrain,
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.orientationLock;
      }
    ], () => {
      var u;
      if (!((u = e.inputShape) != null && u.banding)) return;
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 });
    const s = sn(() => r.value), o = (l) => {
      (l.key === "Enter" || l.key === " ") && a();
    }, a = () => {
      e.disabled || i("clicked");
    };
    return Lo(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.addEventListener("keydown", o);
    }), Of(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.removeEventListener("keydown", o);
    }), (l, h) => (ee(), de("div", {
      id: l.id,
      class: di(["banding-button", { open: l.open, disabled: l.disabled }]),
      tabindex: "0",
      onClick: a
    }, [
      be("div", {
        class: di(["outer", {
          x1: s.value.x1,
          x2: s.value.x2,
          y1: s.value.y1,
          y2: s.value.y2
        }])
      }, h[0] || (h[0] = [
        be("div", { class: "inner" }, null, -1)
      ]), 2)
    ], 10, j6));
  }
}), z6 = ["unitDependent", "string", "integer", "float", "checkbox", "select"], $6 = {
  name: "CustomInput",
  props: {
    type: {
      type: String,
      default: "string",
      validator(n) {
        return z6.includes(n);
      }
    },
    value: {
      type: [String, Boolean, Number],
      default: null
    },
    //element id
    id: {
      type: String,
      default: ""
    },
    focus: {
      type: Boolean,
      default: !1
    },
    enableLabel: {
      type: Boolean,
      default: !0
    },
    labelPosition: {
      type: String,
      default: "first",
      validator(n) {
        return ["first", "last"].includes(n);
      }
    },
    //used for select / checkbox
    output: {
      type: String,
      default: "string",
      validator(n) {
        return ["string", "integer", "float", "boolean"].includes(n);
      }
    },
    options: {
      type: Array,
      default: () => []
    },
    selectFirstOptionDisabled: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: !0
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: !1
    },
    default: {
      type: [String, Number, Boolean],
      default: ""
    },
    units: {
      type: String,
      default: "decimal",
      validator(n) {
        return ["decimal", "fraction"].includes(n);
      }
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    custom: {
      type: Boolean,
      default: !1
    },
    multiEdit: {
      type: Boolean,
      default: !1
    },
    allowBlank: {
      type: Boolean,
      default: !1
    },
    text: {
      type: Object,
      default: () => ({
        select: "Select",
        delete: "Delete"
      })
    },
    issue: {
      type: Boolean,
      default: !1
    },
    warning: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update", "default"],
  computed: {
    thisId() {
      return this.custom ? "custom-" + this.id : this.id;
    },
    inputType() {
      return P6(this.type, this.units);
    },
    inputMode() {
      return C6(this.type, this.units);
    },
    outputType() {
      return L6(this.type, this.output, this.units);
    }
  },
  watch: {
    options: {
      handler() {
        this.value && (this.options.find((n) => n.value == this.value) || this.updateValue(""));
      },
      deep: !1,
      immediate: !1
    }
    /* value: {
    	handler( value )
    	{
    		console.log( 'value changed', value )
    	},
    	deep: false,
    	immediate: true
    } */
  },
  created() {
    this.setDefault();
  },
  mounted() {
    const n = ba.call(this, "input");
    n && this.focus && this.$nextTick(() => n.focus());
  },
  methods: {
    getType() {
      return this.type === "unitDependent" ? this.units === "fraction" ? "string" : "float" : this.type;
    },
    handleInput(n) {
      let t = n.target.value;
      switch ((t === "" || t === null) && this.allowBlank && this.updateValue(null), this.getType()) {
        case "integer":
          t = t.replace(/[^0-9-]/g, ""), t = parseInt(t);
          break;
        case "float":
          t = t.replace(/[^0-9.-]/g, ""), t = parseFloat(t);
          break;
      }
      if ((this.getType() === "integer" || this.getType() === "float") && isNaN(t))
        return this.updateValue(null);
      typeof this.min == "number" && t < this.min && (t = this.min), typeof this.max == "number" && t > this.max && (t = this.max), this.updateValue(t);
    },
    updateValue(n, t = "update") {
      if (n === null) return this.$emit(t, n);
      if (this.type === "unitDependent" || this.output === "unitDependent") {
        if (this.units === "fraction")
          return n = n.replace(/[^0-9/ ]+/g, "").replace(/\s{2,}/g, " ").trim(), this.$emit(t, n);
        if (this.units === "decimal")
          return this.$emit(t, parseFloat(n));
      }
      switch (this.outputType) {
        case "string":
          return this.$emit(t, n);
        case "integer":
          return this.$emit(t, parseInt(n));
        case "float":
          return this.$emit(t, parseFloat(n));
        case "boolean":
          return this.$emit(t, I6(n));
        default:
          return this.$emit(t, n);
      }
    },
    setDefault() {
      !Dt(this.value) && Dt(this.default) && this.updateValue(this.default);
    }
  }
}, U6 = ["for"], W6 = ["id", "inputmode", "type", "value", "placeholder", "disabled", "readonly", "min", "max", "aria-label"], H6 = ["id", "disabled", "checked", "aria-label"], G6 = ["id", "value", "disabled", "aria-label"], V6 = ["disabled", "selected"], Y6 = {
  key: 0,
  value: " "
}, K6 = ["hidden", "value"], X6 = ["for"];
function J6(n, t, e, i, r, s) {
  var o, a, l, h;
  return ee(), de(Zn, null, [
    e.label && e.enableLabel && e.labelPosition === "first" ? (ee(), de("label", {
      key: 0,
      for: s.thisId
    }, mn(e.label), 9, U6)) : Pe("", !0),
    e.type === "string" || e.type === "integer" || e.type === "float" || e.type === "unitDependent" ? (ee(), de("input", {
      key: 1,
      id: s.thisId,
      ref: "input",
      inputmode: s.inputMode,
      type: s.inputType,
      value: e.value,
      placeholder: e.placeholder,
      disabled: e.disabled,
      readonly: e.readonly,
      class: di({ issue: e.issue, warning: e.warning }),
      min: e.min,
      max: e.max,
      "aria-label": e.label,
      onChange: t[0] || (t[0] = (...u) => s.handleInput && s.handleInput(...u))
    }, null, 42, W6)) : Pe("", !0),
    e.type === "checkbox" ? (ee(), de("input", {
      key: 2,
      id: s.thisId,
      ref: "input",
      type: "checkbox",
      disabled: e.readonly || e.disabled,
      checked: e.value === e.trueValue,
      "aria-label": e.label,
      class: di({ issue: e.issue, warning: e.warning }),
      onChange: t[1] || (t[1] = (u) => s.updateValue(u.target.checked ? e.trueValue : e.falseValue))
    }, null, 42, H6)) : Pe("", !0),
    e.type === "select" ? (ee(), de("select", {
      key: 3,
      id: s.thisId,
      ref: "input",
      value: e.value,
      disabled: e.readonly || e.disabled,
      "aria-label": e.label,
      class: di({ issue: e.issue, warning: e.warning }),
      onChange: t[2] || (t[2] = (u) => s.updateValue(u.target.value))
    }, [
      be("option", {
        value: "",
        disabled: e.selectFirstOptionDisabled,
        selected: !e.value
      }, mn(((a = (o = e.text) == null ? void 0 : o.select) == null ? void 0 : a.toUpperCase()) ?? "SELECT"), 9, V6),
      e.multiEdit ? (ee(), de("option", Y6, mn(((h = (l = e.text) == null ? void 0 : l.delete) == null ? void 0 : h.toUpperCase()) ?? "DELETE"), 1)) : Pe("", !0),
      (ee(!0), de(Zn, null, Lr(e.options, (u) => {
        var d, p, f;
        return ee(), de("option", {
          key: u.value,
          hidden: u.hidden,
          value: u.value
        }, mn(((d = u == null ? void 0 : u.label) == null ? void 0 : d.toUpperCase()) ?? ((f = (p = u == null ? void 0 : u.value) == null ? void 0 : p.toString()) == null ? void 0 : f.toUpperCase())), 9, K6);
      }), 128))
    ], 42, G6)) : Pe("", !0),
    e.label && e.enableLabel && e.labelPosition === "last" ? (ee(), de("label", {
      key: 4,
      for: e.id
    }, mn(e.label), 9, X6)) : Pe("", !0)
  ], 64);
}
const wl = /* @__PURE__ */ Pa($6, [["render", J6]]), Z6 = {
  key: 0,
  class: "inputs"
}, Q6 = { class: "label" }, tk = { class: "label" }, ek = { class: "label" }, nk = ["onClick"], ik = { class: "price" }, rk = ["aria-label"], Yg = /* @__PURE__ */ is({
  __name: "ExtrasInputs",
  props: {
    translate: { type: Boolean, default: !0 },
    shape: {},
    shapeIndex: { default: 0 },
    extraType: {},
    extraLabel: {},
    extraKeys: {},
    allOptions: {},
    pricing: { default: () => ({}) },
    labels: {},
    userFriendlyFieldMap: {},
    partColumns: {},
    orientationModel: { default: 0 },
    getPrice: {},
    formatPrice: {},
    getAvailablePricingOptions: {}
  },
  emits: ["update-all", "set"],
  setup(n, { emit: t }) {
    const e = n, i = t, { t: r } = Zg({
      inheritLocale: !0,
      useScope: "global"
    }), s = Ce(!1), o = sn(() => e.extraType + "Options"), a = sn(() => {
      var x;
      if (!((x = e.allOptions) != null && x.length)) return "auto";
      const m = e.allOptions.length;
      return m ? `repeat(${m + 3 - 1}, minmax(20px, max-content)) 1fr` : "auto";
    }), l = (m, b) => {
      i("update-all", e.shape, e.extraType, m, b);
    }, h = (m, b, x) => {
      i("set", e.shape, e.extraType, m, b, x);
    }, u = (m, b, x, y, v) => {
      var q;
      if (!m) return [];
      const k = (q = b == null ? void 0 : b[x]) == null ? void 0 : q[y];
      if (!k)
        return console.error(`ExtrasInputs: cannot find pricing options for ${x} > ${y}`), [];
      const C = Object.values(k);
      if (!C.length)
        return console.error(`ExtrasInputs: cannot find pricing options for ${x} > ${y}`), [];
      const I = C.filter((O) => typeof O == "string");
      return e.getAvailablePricingOptions ? e.getAvailablePricingOptions(m, I, v) : (console.error("ExtrasInputs: cannot find pricing function in parent"), []);
    }, d = (m) => {
      if (!e.pricing || !Object.values(e.pricing).length) return "";
      if (!e.getPrice)
        return console.error("ExtrasInputs: cannot find getExtrasPrice or formatPrice in parent"), "";
      const b = e.getPrice(e.shape, e.extraType, m);
      return b ? e.formatPrice(b) : "";
    }, p = () => {
      const m = [];
      e.extraType in e.shape || m.push({ message: `The extra type '${e.extraType}' does not exist in the shape.` }), o.value in e.shape || m.push({ message: `The options key '${o.value}' does not exist in the shape.` }), m.length && (s.value = !0, console.error("pre-flight issues found in ExtrasInputs: " + m.map((b) => b.message).join(" ")));
    }, f = (m) => Jb(m);
    return Lo(() => p()), (m, b) => {
      var y, v, k, C, I, q, O, F;
      const x = Fl("font-awesome-icon");
      return s.value ? Pe("", !0) : (ee(), de("div", {
        key: 0,
        class: di(["extras group", [m.extraType]]),
        style: jn({ "grid-column-end": "span " + (m.partColumns + 1) })
      }, [
        m.allOptions.length === 1 && m.allOptions[0].length === 1 ? (ee(), de("div", Z6, [
          be("div", Q6, mn(f((v = (y = m.allOptions) == null ? void 0 : y[0]) == null ? void 0 : v[0])), 1),
          (k = m.shape) != null && k[o.value] && "all" in m.shape[o.value] ? (ee(), Wn(wl, {
            key: 0,
            id: `${m.extraType}-all-${m.shapeIndex}`,
            type: "checkbox",
            label: f(Ie(r)("all")),
            "true-value": (I = (C = m.allOptions) == null ? void 0 : C[0]) == null ? void 0 : I[0],
            "false-value": "",
            value: (O = m.shape[o.value].all) == null ? void 0 : O[(q = m.labels) == null ? void 0 : q[0]],
            onUpdate: b[0] || (b[0] = (M) => {
              var j, P;
              h("all", (j = m.labels) == null ? void 0 : j[0], M), l((P = m.labels) == null ? void 0 : P[0], M);
            })
          }, null, 8, ["id", "label", "true-value", "value"])) : Pe("", !0),
          (ee(!0), de(Zn, null, Lr(m.extraKeys, (M) => {
            var j, P, A, T, _, Z;
            return ee(), de(Zn, { key: M }, [
              (j = m.labels) != null && j[0] && ((A = (P = m.shape) == null ? void 0 : P[o.value]) != null && A[M]) && m.labels[0] in m.shape[o.value][M] ? (ee(), Wn(wl, {
                key: 0,
                id: `${m.extraType}-${M}-${m.shapeIndex}`,
                type: "checkbox",
                label: f(Ie(r)((T = m.userFriendlyFieldMap) == null ? void 0 : T[M])),
                "true-value": (Z = (_ = m.allOptions) == null ? void 0 : _[0]) == null ? void 0 : Z[0],
                "false-value": "",
                value: m.shape[o.value][M][m.labels[0]],
                onUpdate: (V) => h(M, m.labels[0], V)
              }, null, 8, ["id", "label", "true-value", "value", "onUpdate"])) : Pe("", !0)
            ], 64);
          }), 128))
        ])) : (ee(), de("div", {
          key: 1,
          class: "grid inputs",
          style: jn({
            "grid-template-columns": a.value
          })
        }, [
          (F = m.shape) != null && F[o.value] && "all" in m.shape[o.value] ? (ee(), de(Zn, { key: 0 }, [
            be("div", tk, mn(f(Ie(r)("all"))), 1),
            (ee(!0), de(Zn, null, Lr(m.allOptions, (M, j) => {
              var P, A;
              return ee(), Wn(wl, {
                id: `${m.extraType}-all-${m.labels[j]}-${j}-${m.shapeIndex}`,
                key: `${m.extraType}-all-${m.labels[j]}-${j}-${m.shapeIndex}`,
                type: "select",
                disabled: u(m.pricing, m.shape, o.value, "all", j).length === 0,
                options: u(m.pricing, m.shape, o.value, "all", j).map((T) => ({ value: T, label: T })),
                text: { select: "✘" },
                "select-first-option-disabled": !1,
                value: (A = m.shape[o.value].all) == null ? void 0 : A[(P = m.labels) == null ? void 0 : P[j]],
                onUpdate: (T) => {
                  var _, Z;
                  h("all", (_ = m.labels) == null ? void 0 : _[j], T), l((Z = m.labels) == null ? void 0 : Z[j], T);
                }
              }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
            }), 128)),
            b[2] || (b[2] = be("div", null, null, -1)),
            b[3] || (b[3] = be("div", null, null, -1))
          ], 64)) : Pe("", !0),
          (ee(!0), de(Zn, null, Lr(m.extraKeys, (M) => {
            var j, P;
            return ee(), de(Zn, { key: M }, [
              (j = m.shape) != null && j[o.value] && M in m.shape[o.value] ? (ee(), de(Zn, { key: 0 }, [
                be("div", ek, mn(f(Ie(r)((P = m.userFriendlyFieldMap) == null ? void 0 : P[M]))), 1),
                (ee(!0), de(Zn, null, Lr(m.allOptions, (A, T) => {
                  var _;
                  return ee(), Wn(wl, {
                    id: `${m.extraType}-${M}-${m.labels[T]}-${T}-${m.shapeIndex}`,
                    key: `${m.extraType}-${M}-${m.labels[T]}-${T}-${m.shapeIndex}`,
                    type: "select",
                    disabled: u(m.pricing, m.shape, o.value, M, T).length === 0,
                    options: u(m.pricing, m.shape, o.value, M, T).map((Z) => ({
                      value: Z,
                      label: Z
                    })),
                    text: { select: "✘" },
                    "select-first-option-disabled": !1,
                    value: m.shape[o.value][M][(_ = m.labels) == null ? void 0 : _[T]],
                    onUpdate: (Z) => {
                      var V;
                      return h(M, (V = m.labels) == null ? void 0 : V[T], Z);
                    }
                  }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
                }), 128))
              ], 64)) : Pe("", !0),
              be("div", {
                class: "delete",
                onClick: () => Ie(Mm)(m.shape, m.extraType, M)
              }, [
                Ln(x, { icon: ["fass", "trash"] })
              ], 8, nk),
              be("div", ik, mn(d(M) || Ie(r)("N/A")), 1)
            ], 64);
          }), 128))
        ], 4)),
        be("button", {
          type: "button",
          class: "delete icon-left",
          "aria-label": Ie(r)(`delete ${m.extraLabel}`),
          onClick: b[1] || (b[1] = () => Ie(c6)(m.shape, m.extraType, !0))
        }, [
          Ln(x, { icon: ["fass", "trash"] }),
          qu(" " + mn(Ie(r)(`delete ${m.extraLabel}`)), 1)
        ], 8, rk)
      ], 6));
    };
  }
}), sk = ["id", "disabled"], ok = { class: "icon" }, ak = /* @__PURE__ */ is({
  __name: "FinishButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = () => {
      e.disabled || i("clicked");
    };
    return (s, o) => {
      var l, h, u, d;
      const a = Fl("font-awesome-icon");
      return ee(), de("button", {
        id: s.id,
        class: di(["finish-button", {
          "face-a": (h = (l = s.inputShape) == null ? void 0 : l.finish) == null ? void 0 : h.a,
          "face-b": (d = (u = s.inputShape) == null ? void 0 : u.finish) == null ? void 0 : d.b,
          selected: s.open
        }]),
        type: "button",
        tabindex: "0",
        disabled: s.disabled,
        onClick: r
      }, [
        be("div", ok, [
          Ln(a, { icon: ["fass", "spray-can"] })
        ]),
        o[0] || (o[0] = be("div", { class: "indicator" }, null, -1))
      ], 10, sk);
    };
  }
}), lk = is({
  name: "MachiningButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    },
    id: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["open"],
  computed: {
    hasMachining() {
      return d1(this.inputShape);
    },
    disabledOrReadonly() {
      var n;
      return this.disabled || !!((n = this.inputShape) != null && n.readonly);
    }
  },
  methods: {
    openMachining() {
      this.disabled || this.$emit("open");
    }
  }
}), uk = ["id", "disabled"];
function ck(n, t, e, i, r, s) {
  const o = Fl("font-awesome-icon");
  return ee(), de("button", {
    id: n.id,
    class: di(["machining-button", { "has-machining": n.hasMachining }]),
    type: "button",
    disabled: n.disabled,
    onClick: t[0] || (t[0] = (...a) => n.openMachining && n.openMachining(...a))
  }, [
    Ln(o, { icon: ["fass", "hammer"] })
  ], 10, uk);
}
const hk = /* @__PURE__ */ Pa(lk, [["render", ck]]), fk = { id: "uploader" }, dk = {
  key: 0,
  class: "debug"
}, pk = {
  key: 1,
  class: "selected-files"
}, gk = ["src"], mk = ["onClick"], yk = /* @__PURE__ */ is({
  __name: "ImageUpload",
  props: {
    shapeId: {
      type: String,
      required: !0
    },
    prefix: {
      type: String,
      required: !0
    },
    uniqueId: {
      type: String,
      required: !0
    },
    env: {
      type: String,
      required: !1,
      default: "production"
    },
    maxImages: {
      type: Number,
      required: !1,
      default: 5
    },
    images: {
      type: Array,
      required: !0
    }
  },
  emits: ["update", "remove"],
  setup(n, { emit: t }) {
    const e = go(() => import("./ObjectViewer-CjFIJYjx.js")), i = Ce(null), r = Ce(!0), s = Ce({
      shapeId: "",
      files: [],
      previewUrls: [],
      metadata: []
    }), o = n, a = t, l = (m) => ["image/jpeg", "image/jpg", "image/png"].includes(m.type), h = () => {
      var m;
      (m = i.value) == null || m.click();
    }, u = (m) => {
      const b = m.target, x = b.files;
      if (!x) return;
      const y = Array.from(x), v = y.filter((M) => !l(M));
      if (v.length > 0) {
        const M = v.map((j) => j.name).join(", ");
        alert(`Invalid file type(s): ${M}
Only JPG and PNG files are allowed.`), b.value = "";
        return;
      }
      const k = s.value.files || [];
      if (k.length + y.length > o.maxImages) {
        alert(`Maximum ${o.maxImages} images allowed per shape.`), b.value = "";
        return;
      }
      const I = [...k, ...y], q = d(I), O = I.map((M, j) => ({
        originalName: M.name,
        newName: `${o.prefix}-${j + 1}-${o.uniqueId}${p(M.name)}`
      })), F = {
        shapeId: o.shapeId,
        files: I,
        previewUrls: q,
        metadata: O
      };
      s.value = F, a("update", F), b.value = "";
    }, d = (m) => m.map((b) => URL.createObjectURL(b)), p = (m) => m.substring(m.lastIndexOf(".")), f = (m) => {
      URL.revokeObjectURL(s.value.previewUrls[m]);
      const b = [...s.value.files], x = [...s.value.previewUrls], y = [...s.value.metadata];
      if (b.splice(m, 1), x.splice(m, 1), y.splice(m, 1), b.length === 0)
        s.value = {
          shapeId: o.shapeId,
          files: [],
          previewUrls: [],
          metadata: []
        }, a("remove", o.shapeId);
      else {
        const v = {
          shapeId: o.shapeId,
          files: b,
          previewUrls: x,
          metadata: y
        };
        s.value = v, a("update", v);
      }
    };
    return O2(() => {
      var m;
      (m = s.value) != null && m.previewUrls && s.value.previewUrls.forEach((b) => URL.revokeObjectURL(b));
    }), Lo(() => {
      s.value.shapeId = o.shapeId;
      const m = o.images.find((b) => b.shapeId === o.shapeId);
      if (m) {
        const b = d(m.files);
        s.value = {
          ...m,
          previewUrls: b
        };
      }
    }), (m, b) => {
      var y;
      const x = Fl("font-awesome-icon");
      return ee(), de("div", fk, [
        n.env === "development" && r.value ? (ee(), de("div", dk, [
          Ln(Ie(e), {
            data: [s.value],
            paths: ["imageData"]
          }, null, 8, ["data"])
        ])) : Pe("", !0),
        be("input", {
          ref_key: "fileInput",
          ref: i,
          type: "file",
          accept: ".jpg,.jpeg,.png",
          class: "hidden",
          multiple: "",
          onChange: u
        }, null, 544),
        be("button", {
          type: "button",
          class: "upload-button",
          onClick: h
        }, [
          Ln(x, { icon: ["fass", "files"] })
        ]),
        (y = s.value.files) != null && y.length ? (ee(), de("div", pk, [
          (ee(!0), de(Zn, null, Lr(s.value.files, (v, k) => (ee(), de("div", {
            key: k,
            class: "selected-file"
          }, [
            be("img", {
              src: s.value.previewUrls[k],
              alt: "Preview"
            }, null, 8, gk),
            be("button", {
              class: "remove-file",
              type: "button",
              onClick: (C) => f(k)
            }, [
              Ln(x, { icon: ["fass", "trash"] })
            ], 8, mk)
          ]))), 128))
        ])) : Pe("", !0)
      ]);
    };
  }
}), bk = /* @__PURE__ */ Pa(yk, [["__scopeId", "data-v-b59be53a"]]), vk = {
  key: 0,
  class: "debug"
}, wk = { key: 2 }, xk = {
  key: 0,
  class: "row table-heading"
}, _k = {
  key: 0,
  class: "cell center"
}, Sk = {
  key: 1,
  class: "cell delete"
}, kk = { class: "cell" }, Ak = ["id", "disabled", "onClick"], Nk = {
  key: 0,
  class: "cell center"
}, Ck = ["onClick"], Pk = {
  key: 1,
  class: "cell"
}, Lk = ["disabled", "aria-label", "onClick"], Ik = { class: "button-wrapper main" }, Ek = ["aria-label"], Ok = ["aria-label", "disabled"], Tk = ["aria-label"], Fk = { id: "part-count" }, Mk = {
  key: 3,
  id: "messages"
}, Rk = {
  key: 0,
  class: "heading"
}, Dk = { class: "content" }, Bk = {
  key: 4,
  id: "progress"
}, jk = {
  id: "diagram",
  class: "diagram production"
}, qk = {
  key: 0,
  id: "stack"
}, zk = !0, Bm = /* @__PURE__ */ is({
  __name: "CheckoutCalculator",
  props: {
    debug: {
      type: Boolean,
      default: !1
    },
    units: {
      type: String,
      default: "decimal"
    },
    stock: {
      type: Array,
      default: () => []
    },
    findExtrasPrice: {
      type: Function,
      required: !0
    },
    formatPrice: {
      type: Function,
      required: !0
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["inputs-changed", "calculating", "result", "log", "error"],
  setup(n, { expose: t, emit: e }) {
    const i = go(() => import("./Machining-F08WWUem.js")), r = go(() => import("./ImportCSV-DcLG7dxv.js")), s = go(() => import("./ObjectViewer-CjFIJYjx.js")), o = n, a = e, { t: l, locale: h } = Zg({
      locale: "en_US",
      useScope: "global"
    }), u = "production", d = window.location.hostname;
    let p = null, f = null;
    const m = Ce(!1), b = Ce(!1), x = Ce(!0), y = fg("Checkout/currentURL", window.location.href), v = Ce(window.innerWidth), k = kw(), C = Ce([]), I = Ce(!1), q = Ce(!1), O = Ce(!1), F = Ce(!1), M = Ce(0), j = Ce(!1), P = Ce(!1), A = Ce(Qb()), T = {
      enable: {
        diagram: !0,
        focus: !0,
        click: !0,
        partName: !0,
        progressNumber: !0,
        orientation: !0,
        banding: !1,
        finish: !1,
        machining: !1,
        csvImport: !1,
        imageUpload: !1
      },
      decimalPlaces: 2,
      stackHeight: 100,
      maxParts: null,
      locale: "en_US",
      orientationModel: 0,
      customFields: [],
      fieldOrder: [],
      units: "decimal",
      minDimension: 0,
      stockSelection: null,
      cutPreference: null,
      bladeWidth: null,
      stockType: null,
      minSpacing: 0,
      stockGrain: null
    }, _ = Ar(T), Z = Ce(null), V = Ar({
      bladeWidth: 1,
      cutPreference: "l",
      cutType: "guillotine",
      stockType: "sheet",
      stackHeight: 0,
      options: {
        stockSelection: "efficiency",
        minSpacing: 0
      }
    }), R = fg(
      "Checkout/inputShapes",
      [],
      {
        serializer: {
          read: (at) => {
            if (!at) return [];
            const pt = at ? JSON.parse(at) : [];
            return Db(pt, o.units);
          },
          write: (at) => JSON.stringify(at)
        },
        listenToStorageChanges: !1
      }
    ), Q = Ce([]), H = uo([]), ct = uo([]), nt = uo([]), N = uo([]), z = Ce({
      parts: [],
      stock: []
    }), G = Ce(null), Y = Ce(null), st = Ce(null), vt = sn(() => ct.value.filter((at) => at.added)), mt = sn(() => ct.value.filter((at) => at.added && !at.duplicate)), _t = sn(() => mt.value.filter((at) => at.added)), Bt = sn(() => H.value.filter((at) => at.used && !at.duplicate)), Rt = sn(() => Bt.value.filter((at) => at.used).map((at) => (at.q = Bt.value.filter((pt) => pt.parentID === at.parentID).reduce(
      (pt, xt) => pt + (typeof (xt == null ? void 0 : xt.stack) == "number" && xt.stack > 0 ? xt.stack : 1),
      0
    ), at))), te = sn(() => e6(H.value)), Xt = sn(() => st.value ? QS(H.value, st.value) : null), E = sn(() => Zb(H.value)), ft = sn(() => ct.value.filter((at) => {
      var pt, xt;
      return at.added && ((pt = at == null ? void 0 : at.stock) == null ? void 0 : pt.id) === ((xt = Xt.value) == null ? void 0 : xt.id);
    })), U = sn(() => t6(nt.value, Xt.value)), et = sn(() => R.value.reduce((at, pt) => at + pt.q, 0)), X = Ce(!1), rt = Ce(""), wt = Ce(""), kt = Ar({
      banding: null,
      finish: null,
      info: null,
      imageUpload: null
    }), dt = Ce([]), Pt = Ce([]), qt = Ce([]), Ft = Ce(!1), Vt = Ar({
      units: "decimal",
      faces: { enabled: !0 },
      holes: { enabled: !1 },
      corners: {
        enabled: !1,
        types: []
      },
      banding: { enabled: !1 },
      hingeHoles: { enabled: !1 },
      shelfHoles: { enabled: !1 }
    }), ne = Ar({
      labels: [],
      pricing: {},
      options: {},
      keys: pr
    }), ie = Ar({
      labels: [],
      pricing: {},
      options: {},
      keys: ["a", "b"]
    }), ue = Ce({
      queue: 0,
      stockCount: 0,
      shapeCount: 0,
      complete: !1
    }), we = Ar({
      partA: "#118ab2",
      partB: null,
      partHover: null,
      partSelected: null,
      stock: "#ffd166",
      button: "#118ab2",
      buttonText: "#ffffff",
      text: "#ffffff"
    });
    let Qt = null;
    const Ke = Ce(!1), ht = Ce(!1), jt = Ar({
      disableClick: !1,
      enableStretch: !0
    }), Kt = uo(null), Ht = Ar({
      parts: {
        sheet: [
          { id: "material", enabled: !1 },
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "t", enabled: !1 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "banding", enabled: !1 },
          { id: "finish", enabled: !1 },
          { id: "machining", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        linear: [
          { id: "l", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "finish", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        roll: [
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "imageUpload", enabled: !1 }
        ]
      }
    }), Ae = Ce([]), Jt = sn(() => {
      var pt;
      return [...[
        {
          id: "material",
          fieldMap: "material",
          label: l("material"),
          w: "minmax(20px, max-content)",
          type: "select",
          output: "string",
          default: (pt = dt.value[0]) == null ? void 0 : pt.name,
          options: dt.value.map((xt) => ({
            value: xt.name,
            label: xt.name
          }))
        },
        {
          id: "t",
          fieldMap: "t",
          w: "minmax(20px, max-content)",
          type: "select",
          output: o.units === "decimal" ? "float" : "string",
          label: l("thickness")
        },
        {
          id: "l",
          fieldMap: "l",
          type: "unitDependent",
          label: l("length"),
          min: 0
        },
        {
          id: "w",
          fieldMap: "w",
          type: "unitDependent",
          label: l("width"),
          min: 0
        },
        {
          id: "q",
          fieldMap: "q",
          type: "integer",
          default: 1,
          label: l("quantity"),
          min: 0
        },
        {
          id: "name",
          fieldMap: "name",
          type: "string",
          label: l("name")
        },
        {
          id: "orientationLock",
          w: "32px",
          label: l("orientation"),
          fieldMap: "orientationLock"
        },
        {
          id: "banding",
          w: "32px",
          label: l("banding"),
          fieldMap: "bandingOptions"
        },
        {
          id: "finish",
          type: "checkbox",
          w: "32px",
          label: l("finish"),
          fieldMap: "finish"
        },
        {
          id: "machining",
          w: "32px",
          label: l("machining"),
          fieldMap: "machining"
        },
        {
          id: "imageUpload",
          w: "32px",
          label: l("image upload"),
          fieldMap: "imageUpload"
        }
      ], ...Ae.value];
    }), Yt = sn(() => M6(
      Ht,
      Jt.value,
      "parts",
      V.stockType,
      _.fieldOrder
    )), le = sn(() => {
      let at = Yt.value.length;
      return R.value.length > 1 && at++, at;
    }), Xe = sn(() => {
      const at = {
        id: "34px",
        del: "30px",
        info: "30px"
      }, pt = [];
      for (const xt of Yt.value)
        xt.id !== "trim" && pt.push(xt.w ?? "minmax(20px, 1fr)");
      return pt.unshift(at.id), R.value.length > 1 && pt.push(at.del), pt.join(" ");
    }), xn = sn(() => ({
      fontSize: "11px",
      textAlign: "right",
      width: "100%",
      height: "auto",
      position: "relative",
      display: "flex",
      visibility: "visible",
      opacity: "1",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingRight: "10px",
      marginTop: "10px",
      marginBottom: "2px",
      userSelect: "none",
      alignItems: "center"
    })), Ge = sn(() => ({
      width: "auto",
      height: "auto",
      display: "inline-block",
      position: "relative",
      visibility: "visible",
      opacity: "1",
      color: "#4e4e4e"
    })), Ne = (at, pt) => {
      let xt;
      return function(...Ot) {
        const pe = () => {
          clearTimeout(xt), at(...Ot);
        };
        clearTimeout(xt), xt = setTimeout(pe, pt);
      };
    }, Be = (at, pt) => E6(at, pt), Di = (at, pt, xt, zt = !0) => {
      O6(at, pt, xt, zt);
    }, pn = (at) => {
      if (o.debug && a("log", ["checkout init...", at]), at != null && at.options) {
        const pt = at.options;
        d6(pt), [
          "stockType",
          "cutPreference",
          "bladeWidth"
        ].forEach((Ot) => {
          Ot in pt || a("error", `${Ot} is a required option`);
        });
        const zt = {
          stockType: () => {
            const Ot = ["sheet", "linear", "roll"];
            Ot.includes(pt.stockType) || console.warn(`${pt.stockType} is not a valid stockType, expected ${Ot.join("|")}`), V.stockType = pt.stockType;
          },
          stockSelection: () => {
            const Ot = ["efficiency", "smallest"];
            pt != null && pt.stockSelection && !Ot.includes(pt.stockSelection) ? console.warn(`${pt.stockSelection} is not a valid stockSelection, expected ${Ot.join("|")}`) : V.options.stockSelection = pt.stockSelection;
          },
          minSpacing: () => {
            V.options.minSpacing = pt.minSpacing;
          },
          cutPreference: () => {
            const Ot = ["efficiency", "length", "width", "beam"];
            if (Ot.includes(pt.cutPreference)) {
              const { cutType: pe, cutPreference: ce } = nf(pt.cutPreference);
              V.cutType = pe, V.cutPreference = ce, V.stackHeight = pt.stackHeight, pt.stockType === "linear" && (V.cutType = null, V.cutPreference = null), pt.cutPreference === "beam" && (V.stackHeight = pt.stackHeight);
            } else
              console.warn(`SmartCut - ${pt.cutPreference} is not one of ${Ot.join("|")}`);
          },
          bladeWidth: () => {
            pt.bladeWidth >= 0 ? V.bladeWidth = pt.bladeWidth : console.warn(`SmartCut - you provided an incorrect blade width of: ${pt.bladeWidth}`);
          },
          colors: () => {
            for (const [Ot, pe] of Object.entries(pt == null ? void 0 : pt.colors))
              pe && (we[Ot] = pe);
          },
          maxParts: () => {
            _.maxParts = pt.maxParts;
          },
          enable: () => {
            me("banding", gn(pt, ["enable", "banding"]) ?? T.enable.banding), me("name", gn(pt, ["enable", "partName"]) ?? T.enable.partName), me("finish", gn(pt, ["enable", "finish"]) ?? T.enable.finish), me("orientationLock", gn(pt, ["enable", "orientation"]) ?? T.enable.orientation), me("machining", gn(pt, ["enable", "machining"]) ?? T.enable.machining), me("imageUpload", gn(pt, ["enable", "imageUpload"]) ?? T.enable.imageUpload), P.value = gn(pt, ["enable", "csvImport"]) ?? T.enable.csvImport, jt.disableClick = gn(pt, ["enable", "click"]) ?? !T.enable.click;
          },
          locale: () => {
            h.value = pt.locale;
          },
          customFields: () => {
            var pe;
            if (!Array.isArray(pt.customFields) || !((pe = pt.customFields) != null && pe.length)) return;
            const Ot = [];
            pt.customFields.forEach((ce, _e) => {
              Ot.push(ce), Ot[_e].custom = !0;
              const Oe = gi(ce.id);
              Ot[_e].id = Oe, Ot[_e].fieldMap = "customData." + Oe, ce.type === "checkbox" && (Ot[_e].w = "32px"), ce.type === "select" && (Ot[_e].output = ce.output ?? "string", Ot[_e].options = ce.options);
            }), Ae.value = Ot, R.value.forEach((ce) => {
              ce.customData = pt.customFields.reduce((_e, Oe) => {
                const un = gi(Oe.id);
                return _e[un] = ce.customData[un] || Oe.default || "", _e;
              }, {});
            });
          }
        };
        for (const Ot in pt) {
          if (Ot === "enable")
            for (const pe in _.enable)
              pe in pt.enable && (_.enable[pe] = pt.enable[pe]);
          _[Ot] = pt[Ot], Ot in zt && zt[Ot]();
        }
      }
      Vs("banding", at), Vs("finish", at), ji(at), Qi(at), q.value = !0, Qr(() => {
        Ke.value || ti(), Dr() || alert("The SmartCut credit seems to have been tampered with - this is against our terms of service. Please contact support.");
      }), window.smartcutCheckout = { init: pn };
    }, Ni = (at) => {
      if (!Q.value.length) return "n";
      const pt = at.material, xt = at.t, zt = Q.value.filter((Ot) => Ot.material === pt && Ot.t === xt);
      return zt.length ? Gb(zt) : "n";
    }, Bi = (at, pt) => {
      at.orientationLock = pt;
    }, me = (at, pt = !1) => {
      T6(Ht, "parts", V.stockType, at, pt);
    }, gi = (at) => at ? $l(at).toLowerCase() : null, ji = (at) => {
      var pt, xt, zt, Ot, pe;
      if (gn(_, ["enable", "machining"]) && at != null && at.machining) {
        for (const ce in Vt)
          at.machining[ce] && (Vt[ce] = at.machining[ce]);
        if (["holes", "hingeHoles"].forEach((ce) => {
          var _e, Oe;
          (_e = at == null ? void 0 : at.machining) != null && _e[ce] && (Vt[ce].enabled = (Oe = at == null ? void 0 : at.machining) == null ? void 0 : Oe[ce].enabled);
        }), (zt = (xt = (pt = at == null ? void 0 : at.machining) == null ? void 0 : pt.corners) == null ? void 0 : xt.types) != null && zt.length && (Vt.corners.enabled = !0, Vt.corners.types = at.machining.corners.types), at.banding && ((pe = (Ot = at == null ? void 0 : at.options) == null ? void 0 : Ot.enable) != null && pe.banding)) {
          if (!ne) return;
          Vt.banding = {
            enabled: !0
          }, ne.options.length && (Vt.banding.options = ne.options), ne.labels.length && (Vt.banding.labels = ne.labels), Co(ne.pricing) && (Vt.banding.pricing = ne.pricing);
        }
      }
    }, Qn = (at = null) => {
      Y.value = at, at && at.l && at.w ? Ft.value = !0 : alert("Please enter dimensions first");
    }, An = () => {
      Ft.value = !1, document.exitFullscreen && document.exitFullscreen();
    }, yn = (at = []) => {
      if (Pt.value = [], qt.value = [], me("t", !1), !!at.length) {
        for (const pt of at)
          if (pt != null && pt.t)
            if (typeof pt.t == "string" && pt.t.includes(",")) {
              const xt = mi(pt.t, !0);
              xt.length === 2 ? (Ci(xt), me("t", !0), pt.t = Pt.value[0]) : a("error", "bonded thickness found which does not have 2 options");
            } else Pt.value.includes(pt.t) || Pt.value.push(pt.t);
        Pt.value.length > 1 && me("t", !0);
      }
    }, ui = (at) => ss(at).thicknesses.map((xt) => ({
      label: xt == null ? void 0 : xt.toString(),
      value: xt
    })), ss = (at) => {
      var Ot;
      if (!at) return { thicknesses: [], bondedThicknesses: [] };
      if (!((Ot = dt.value) != null && Ot.length))
        return {
          thicknesses: Pt.value,
          bondedThicknesses: []
        };
      if (!at.material) return { thicknesses: [], bondedThicknesses: [] };
      const pt = dt.value.find((pe) => pe.name === at.material);
      if (!pt) return { thicknesses: [], bondedThicknesses: [] };
      const xt = [...pt.thicknesses], zt = [];
      for (let pe = 0; pe < xt.length; pe++) {
        const ce = xt[pe], _e = mi(ce), Oe = [];
        if (_e.length) {
          for (const un of _e)
            xt[pe] = re(un), Oe.push(pe);
          pe++;
        }
        Oe.length && zt.push(Oe);
      }
      return {
        thicknesses: xt,
        bondedThicknesses: zt
      };
    }, Qi = (at) => {
      var pt;
      if ((pt = at == null ? void 0 : at.stock) != null && pt.some((xt) => xt == null ? void 0 : xt.material)) {
        dt.value = [], Pt.value = [], qt.value = [];
        const xt = /* @__PURE__ */ new Map();
        at.stock.forEach((zt) => {
          var pe;
          if (!zt.material) return;
          const Ot = zt.material.toUpperCase();
          if (xt.has(Ot) || xt.set(Ot, /* @__PURE__ */ new Set()), zt.t != null) {
            const ce = Number(zt.t);
            isNaN(ce) || (pe = xt.get(Ot)) == null || pe.add(ce);
          }
        }), dt.value = Array.from(xt.entries()).map(([zt, Ot]) => ({
          name: zt,
          thicknesses: Array.from(Ot).sort((ce, _e) => ce - _e)
        })), dt.value.length > 1 && me("material", !0);
      } else
        yn(at.stock);
    }, Ci = (at, pt = null) => {
      if (!Array.isArray(at)) {
        a("error", "addBondedThicknesses expects an array");
        return;
      }
      const xt = [];
      for (let zt = 0; zt < at.length; zt++) {
        let Ot = at[zt];
        o.units === "decimal" && (Ot = parseFloat(Ot)), Pt.value.push(Ot), pt && pt.thicknesses.push(Ot), xt.push(Pt.value.length - 1);
      }
      qt.value.push(xt);
    }, mi = (at, pt = !1) => {
      if (typeof at == "string" && at.includes(",")) {
        const xt = at.split(",");
        return pt ? xt.map((zt) => re(zt)) : xt;
      }
      return [];
    }, Pi = () => {
      ht.value ? yi() : qi();
    }, qi = () => {
      document.getElementById("smartcut-checkout").requestFullscreen(), ht.value = !0;
    }, yi = () => {
      document.exitFullscreen && document.exitFullscreen(), ht.value = !1;
    };
    p = Ne(() => {
      v.value = window.innerWidth;
    }, 30);
    const Dr = () => {
      var zt, Ot;
      if ((Ot = (zt = Kt.value) == null ? void 0 : zt.api) != null && Ot.whiteLabel) return !0;
      let at = !0;
      const pt = document.querySelector("#smartcut-app #credit"), xt = document.querySelector("#smartcut-app #credit a");
      return [pt, xt].forEach((pe, ce) => {
        if (!pe) return at = !1;
        const _e = window.getComputedStyle(pe);
        if (_e.display === "none" || _e.display === "hidden" || _e.opacity === "0" || _e.color === "transparent" || _e.position !== "relative" || ce === 1 && _e.color !== "#4e4e4e" && _e.color !== "rgb(78, 78, 78)")
          return at = !1;
      }), x.value = at, at;
    }, Br = (at, pt, xt, zt, Ot) => {
      Dm(
        at,
        pt,
        xt,
        zt,
        Ot,
        o.findExtrasPrice
      );
    }, jr = (at, pt, xt, zt) => {
      h6(
        at,
        pt,
        xt,
        zt,
        pt === "banding" ? ql : [],
        o.findExtrasPrice
      );
    }, er = (at, pt) => {
      const xt = pt === "banding" ? ne == null ? void 0 : ne.labels : ie == null ? void 0 : ie.labels;
      u6(at, pt, xt);
      const zt = Ud(pt);
      if (at != null && at[zt])
        for (const Ot in at[zt]) {
          const pe = wc(at, pt, Ot, o.findExtrasPrice);
          Tl(at, pt, Ot, !!pe);
        }
    }, qr = (at) => {
      const pt = Object.keys(at);
      return Math.max(...pt.map((zt) => zt.split("|").length));
    }, Us = (at) => {
      const pt = [], xt = Object.keys(at), zt = qr(at);
      for (let Ot = zt; Ot--; ) pt.push(/* @__PURE__ */ new Set());
      for (const Ot of xt)
        Ot.split("|").forEach((ce, _e) => pt[_e].add(ce));
      for (let Ot = 0; Ot < zt; Ot++)
        pt[Ot] = Array.from(pt[Ot]);
      return pt;
    }, os = (at, pt = [], xt) => {
      if (!at) return [];
      if (xt > 0 && !pt[xt - 1]) return [];
      const zt = /* @__PURE__ */ new Set();
      for (const Ot of Object.keys(at)) {
        const pe = Ot.split("|");
        if (pe.length > xt) {
          let ce = !0;
          for (let _e = 0; _e < xt; _e++)
            if (pt[_e] && pe[_e] !== pt[_e]) {
              ce = !1;
              break;
            }
          ce && zt.add(pe[xt]);
        }
      }
      return Array.from(zt);
    }, as = (at, pt, xt) => wc(
      at,
      pt,
      xt,
      o.findExtrasPrice
    ), zr = (at = "issues", pt, xt) => JS(at, pt, xt), To = (at) => {
      const pt = C.value.findIndex((xt) => xt.shapeId === at.shapeId);
      pt !== -1 ? C.value[pt] = at : C.value.push(at), window.smartcutImages = C.value, console.log("Updated images:", C.value);
    }, La = (at) => {
      C.value = C.value.filter((pt) => pt.shapeId !== at), window.smartcutImages = C.value, console.log("updated images", C.value);
    }, vr = (at = 1) => {
      for (let pt = at; pt--; ) {
        let xt;
        if (R.value.length > 0) {
          const zt = R.value[R.value.length - 1];
          xt = wr({
            material: zt.material,
            t: zt.t
          });
        } else
          xt = wr();
        R.value.push(xt);
      }
    }, Ia = (at) => {
      var xt;
      if (o.readonly || R.value.length === 1) return;
      const pt = R.value[at].listId;
      R.value.splice(at, 1), ((xt = Y.value) == null ? void 0 : xt.listId) === pt && (Y.value = null), vc(ue);
    }, wr = ({
      l: at = null,
      w: pt = V.stockType === "linear" ? ((Li) => (Li = Q.value[0]) == null ? void 0 : Li.w)() : null,
      t: xt = Pt.value.length ? Pt.value[0] : null,
      q: zt = 1,
      material: Ot = ((zi) => (zi = dt.value) == null ? void 0 : zi.length)() === 1 ? dt.value[0].name : "",
      name: pe = null,
      orientationLock: ce = _.orientationModel === 2 ? "l" : null,
      bandingOptions: _e = null,
      finishOptions: Oe = null,
      banding: un = null,
      finish: Ee = null,
      customData: ae = null,
      readonly: ve = !1
    } = {}) => {
      var Ks, $r;
      const fs = new vd({
        id: (R.value.length + 1).toString(),
        units: o.units,
        l: at,
        w: pt,
        t: xt,
        q: zt,
        material: Ot,
        name: pe,
        orientationLock: ce,
        banding: un,
        bandingOptions: _e,
        finish: Ee,
        finishOptions: Oe,
        customData: ae,
        readonly: ve
      });
      return (Ks = ne == null ? void 0 : ne.labels) != null && Ks.length && er(fs, "banding"), ($r = ie == null ? void 0 : ie.labels) != null && $r.length && er(fs, "finish"), fs;
    }, Ea = ({
      name: at = "",
      l: pt = null,
      w: xt = null,
      t: zt = null,
      material: Ot = "",
      q: pe = 1,
      trim: ce = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      grain: _e = "",
      cost: Oe = 0,
      allowExactFitShapes: un = !1,
      notes: Ee = ""
    }) => new m1({
      id: (Q.value.length + 1).toString(),
      name: at,
      units: o.units,
      l: pt,
      w: xt,
      t: zt,
      material: Ot,
      q: pe,
      autoAdd: !0,
      trim: ce,
      grain: _e,
      cost: Oe,
      allowExactFitShapes: un,
      notes: Ee
    }), ls = (at, pt) => {
      const xt = re(at.l), zt = re(at.w), Ot = at.t ? re(at.t) : null, pe = new js(V), ce = new es({
        id: (pt + 1).toString() + ".0",
        name: at != null && at.name ? at.name : `${xt}x${zt}`,
        l: xt,
        w: zt,
        t: Ot,
        saw: pe,
        material: at.material,
        grain: at.grain,
        autoAdd: !0,
        cost: at == null ? void 0 : at.cost,
        trim: at.trim,
        allowExactFitShapes: at.allowExactFitShapes,
        type: V.stockType,
        notes: at == null ? void 0 : at.notes
      });
      return H.value.push(ce), ce.issues;
    }, Oa = () => {
      var pt, xt;
      const at = [];
      for (let zt = 0; zt < R.value.length; zt++) {
        const Ot = R.value[zt];
        if (re(Ot.l) < re(_.minDimension) && Ot.issues.push({
          message: l("Part") + ` ${zt + 1}: ` + l("Minimum dimension is") + ` ${_.minDimension}`,
          field: ["l"],
          index: zt
        }), re(Ot.w) < re(_.minDimension) && Ot.issues.push({
          message: l("Part") + ` ${zt + 1}: ` + l("Minimum dimension is") + ` ${_.minDimension}`,
          field: ["w"],
          index: zt
        }), (pt = Ot == null ? void 0 : Ot.issues) != null && pt.length && at.push(...Ot.issues.map((_e) => (_e.message = l("Part") + ` ${zt + 1}: ${_e.message}`, _e))), !Ot.l || !Ot.w || !Ot.q) continue;
        const pe = {
          id: (zt + 1).toString() + ".0",
          l: re(Ot == null ? void 0 : Ot.l),
          w: re(Ot == null ? void 0 : Ot.w),
          t: Ot != null && Ot.t ? re(Ot.t) : null,
          material: Ot != null && Ot.material ? Ot.material : null,
          q: typeof Ot.q != "number" ? parseInt(Ot.q) : Ot.q,
          name: Ot.name,
          orientationLock: Ot.orientationLock,
          banding: Ot.banding,
          finish: Ot.finish,
          machining: Ot.machining,
          customData: Ot.customData
        }, ce = new ns(g6(pe, _.orientationModel));
        ct.value.push(ce), (xt = ce == null ? void 0 : ce.issues) != null && xt.length && at.push(...ce.issues);
      }
      return Ws(), at;
    }, bn = (at) => {
      o6.call({ activeStockId: st }, at);
    }, Ws = () => {
      Pt.value.length && ct.value.forEach((at) => {
        if (!at.t) return;
        const pt = Pt.value.findIndex(
          (Ot) => re(Ot) === at.t
        ), xt = qt.value.find((Ot) => Ot.includes(pt));
        if (!xt) return;
        const zt = Math.min(
          ...xt.map((Ot) => Pt.value[Ot])
        );
        at.t > zt && (at.q = at.q * (at.t / zt), at.t = zt);
      });
    }, Fo = () => {
      r6.call({
        vis: Qt,
        stockList: H,
        activeStock: Xt,
        activeCuts: U
      }), i6.call({
        vis: Qt,
        shapeList: ct,
        activeShapes: ft
      }, mt.value.length);
    }, Hs = () => {
      vc(ue), H.value = [], ct.value = [], nt.value = [], M.value = 0;
    }, Gs = () => {
      R.value.length = 0, vr(1);
    }, Ta = () => {
      var zt, Ot, pe;
      if (us(), _.maxParts && et.value > _.maxParts) {
        Tn(l("The maximum number of parts is") + " " + _.maxParts);
        return;
      }
      if (a("calculating"), O.value) return !1;
      O.value = !0, F.value = !1;
      const at = [];
      let pt = 0;
      for (const ce of R.value)
        at.push(...ce.validate(
          Q.value,
          pt,
          V.stockType,
          null,
          !1
        )), pt++;
      if (at.length) {
        console.warn(at), Tn({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.map( i => i.message ).slice( 0, 5 )
        }), O.value = !1;
        return;
      }
      if (Hs(), at.push(...n6.call({
        inputStock: Q,
        stockList: H,
        createStock: ls
      }, !1)), at.length) {
        Tn({
          heading: `Stock issue${at.length > 1 ? "s" : ""}`,
          main: `${at.length} issue${at.length > 1 ? "s" : ""} found with stock inputs`,
          list: at.map((ce) => ce.message)
        }), O.value = !1;
        return;
      }
      if (at.push(...Oa()), at.length) {
        Tn({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.slice( 0, 5 )
        }), O.value = !1;
        return;
      }
      if (Z.value = new js(
        V,
        (V == null ? void 0 : V.stockType) ?? ((zt = H.value) == null ? void 0 : zt[0].type)
      ), Z.value.issues.length) {
        Tn({
          heading: `Saw issue${Z.value.issues.length > 1 ? "s" : ""}`,
          main: `${Z.value.issues.length} issue${Z.value.issues.length > 1 ? "s" : ""} found with saw inputs`
          // list: saw.value.issues.slice( 0, 5 )
        }), O.value = !1;
        return;
      }
      if (!((Ot = H.value) != null && Ot.length)) {
        Tn({
          heading: "No stock",
          main: "No stock items were found",
          list: []
        }), O.value = !1;
        return;
      }
      if (!((pe = ct.value) != null && pe.length)) {
        Tn({
          heading: "No parts",
          main: "No parts in list",
          list: []
        }), O.value = !1;
        return;
      }
      o.debug && console.log(
        "SmartCut - calculating",
        "stock",
        H.value.map((ce) => ce.dimensions()),
        "parts",
        ct.value.map((ce) => ce.dimensions())
      ), f.connect();
      const xt = {
        inputs: {
          parts: R.value,
          stock: Q.value,
          saw: Z.value
        },
        saw: Z.value,
        shapeList: ct.value,
        stockList: H.value,
        enableEvo: j.value,
        domain: d
      };
      f.compress(!0).emit("calculate", xt);
    }, Tn = (at = {
      main: null,
      heading: null,
      list: []
    }) => {
      var pt;
      typeof at == "object" ? (wt.value = l(at == null ? void 0 : at.main), rt.value = l(at.heading), at != null && at.list && Array.isArray(at.list) && ((pt = at.list) != null && pt.length) && at.list.forEach((xt) => {
        xt && (wt.value += `

${l(xt)}`);
      })) : wt.value = l(at), X.value = !0;
    }, us = () => {
      X.value = !1, wt.value = "", rt.value = "";
    }, ti = () => {
      const at = {
        elementID: "#diagram",
        env: u,
        main: !0,
        units: o.units,
        decimalPlaces: _.decimalPlaces,
        saw: V,
        app: !1,
        embed: !0,
        colors: we,
        options: jt,
        vueComponent: {
          env: u,
          stockList: H,
          shapeList: ct,
          activeStock: Xt,
          activeShapes: ft,
          activeCuts: U
        }
      };
      Qt = new XS(at), Qt.initStock(Xt.value), Qt.initShapes(ft.value, ct.value), Qt.initCuts(U.value), Ke.value = !0;
    }, cs = async (at = !1) => {
      if (!Qt) return !1;
      await Qt.updateSize(at), s6.call({ vis: Qt });
    }, Vs = (at, pt) => {
      var Ee;
      if (me(at, !1), !at || !pt || !(pt != null && pt[at]) || !gn(_, ["enable", at])) return;
      const xt = [at, "pricing"];
      if (!ac(pt, xt)) {
        a("error", `${xt.join(".")} not found in sent data`);
        return;
      }
      const zt = gn(pt, xt);
      if (typeof zt != "object") {
        a("error", `${xt.join(".")} data must be an object`);
        return;
      }
      if (!Co(zt)) {
        a("error", `if provided, ${xt.join(".")} data must contain some values`);
        return;
      }
      const Ot = Object.keys(zt), pe = Object.values(zt);
      if (!Ot.length) {
        a("error", `no ${xt.join(".")} pricing found`);
        return;
      }
      const ce = /,/;
      for (const ae of Ot)
        if (ce.test(ae)) {
          a("error", `${xt} keys must not contain commas and should only be separated by a pipe (|)`);
          return;
        }
      if (pe.some((ae) => isNaN(ae))) {
        a("error", `${xt} values must be a number`);
        return;
      }
      const _e = qr(zt), Oe = [at, "labels"];
      let un = [];
      if (ac(pt, Oe))
        un = gn(pt, Oe);
      else {
        a("error", `${Oe.join(".")} not found`);
        return;
      }
      if (!un) {
        a("error", `${Oe.join(".")} data not provided`);
        return;
      }
      if (!Array.isArray(un)) {
        a("error", `${Oe.join(".")} data must be an array`);
        return;
      }
      if (!(un != null && un.length)) {
        a("error", `if provided, ${Oe.join(".")} data must contain values`);
        return;
      }
      if (un.length !== _e) {
        a("error", `${Oe.join(".")} length (${un.length}) must match the number of levels in ${xt.join(".")} (${_e})`);
        return;
      }
      switch (at) {
        case "banding":
          ne.labels = un, ne.pricing = zt, ne.options = Us(zt);
          break;
        case "finish":
          ie.labels = un, ie.pricing = zt, ie.options = Us(zt);
          break;
      }
      if (me(at, !0), !!((Ee = R.value) != null && Ee.length))
        for (const ae of R.value)
          er(ae, at);
    }, hs = (at, pt) => {
      if (!pt) return;
      at !== "info" && Object.keys(kt).forEach((zt) => {
        zt !== at && zt !== "info" && (kt[zt] = null);
      });
      const xt = R.value.indexOf(pt);
      kt[at] === xt ? (Y.value = null, kt[at] = null) : (Y.value = pt, kt[at] = xt);
    }, Ys = (at) => {
      a("log", ["SmartCut - load event received"]), Fa(at.detail);
    }, Fa = (at) => {
      a("log", ["SmartCut - loading parts..."]), Qr(() => {
        var xt, zt, Ot;
        if (!at || !((zt = (xt = at == null ? void 0 : at.inputs) == null ? void 0 : xt.parts) != null && zt.length)) return;
        R.value = [];
        let pt = 0;
        for (const pe of at.inputs.parts) {
          const ce = wr(pe);
          ce ? (R.value.push(ce), (Ot = ce.issues) != null && Ot.length && a("log", [`SmartCut - issues found while importing part at index ${pt}`, ce.issues])) : a("log", [`SmartCut - error loading part at index ${pt}`, pe]), pt++;
        }
        a("log", [`SmartCut - loaded ${R.value.length} parts`]);
      });
    }, Mo = (at) => {
      R.value.length = 0, Qr(() => {
        var pt, xt;
        for (const zt of at)
          zt.t = ((xt = (pt = Q.value) == null ? void 0 : pt[0]) == null ? void 0 : xt.t) ?? null, R.value.push(wr(zt));
      });
    };
    hr(() => o.stock, (at) => {
      if (Hs(), Array.isArray(at) || console.warn("SmartCut - stock must be passed as an array"), !!(at != null && at.length)) {
        Q.value = [], dt.value.length || yn(at);
        for (const pt of at) {
          pt.type = V.stockType;
          const xt = Ea(pt);
          Q.value.push(xt);
        }
        Q.value.length && (R.value.length ? Qr(() => {
          R.value.forEach((pt) => {
            if (pt.material) {
              const xt = dt.value.find((zt) => zt.name === pt.material);
              xt && (xt.thicknesses.includes(re(pt.t)) || (pt.t = xt.thicknesses[0]), pt.t == null && (pt.t = xt.thicknesses[0]));
            } else
              pt.t = Q.value[0].t;
          });
        }) : Qr(() => vr(1)));
      }
    }, { immediate: !0 }), hr(R, (at) => {
      a("inputs-changed"), at.forEach((pt) => {
        var zt;
        V.stockType === "linear" && (pt.w = (zt = Q.value[0]) == null ? void 0 : zt.w);
        const xt = dt.value.find((Ot) => Ot.name === pt.material);
        xt && (xt.thicknesses.includes(re(pt.t)) || (pt.t = xt.thicknesses[0]));
      });
    }, { deep: !0 }), hr(M, (at) => {
      if (!at) return;
      Ke.value && cs(), G.value || a("error", "SmartCut - no metadata received from server"), Ws();
      const pt = {
        jobId: M.value,
        metadata: G.value,
        parts: _t.value.map((xt) => {
          var zt, Ot;
          return {
            l: xt.l,
            w: xt.w,
            t: xt == null ? void 0 : xt.t,
            material: xt.material,
            orientationLock: xt.orientationLock,
            q: (Ot = (zt = G.value) == null ? void 0 : zt.addedPartTally) == null ? void 0 : Ot[xt.parentID],
            name: xt.name,
            banding: xt.banding,
            finish: xt.finish,
            customData: xt.customData
          };
        }),
        stock: Rt.value.map((xt) => {
          var zt, Ot;
          return {
            name: xt == null ? void 0 : xt.name,
            l: xt.l,
            w: xt.w,
            t: xt == null ? void 0 : xt.t,
            material: xt.material,
            q: (Ot = (zt = G.value) == null ? void 0 : zt.usedStockTally) == null ? void 0 : Ot[xt.parentID],
            trim: xt == null ? void 0 : xt.trim,
            cost: xt == null ? void 0 : xt.cost,
            analysis: xt == null ? void 0 : xt.analysis,
            type: xt == null ? void 0 : xt.type
          };
        }),
        offcuts: N.value.map((xt) => ({
          l: xt.l,
          w: xt.w,
          t: (xt == null ? void 0 : xt.t) ?? null,
          q: xt.q
        })),
        inputs: {
          parts: z.value.parts.map((xt) => {
            const zt = { ...xt };
            return delete zt.listId, zt;
          })
        }
      };
      if (G.value.unplacedParts.length) {
        const xt = G.value.unplacedParts.map((zt) => zt.id).join();
        Tn(l("The following parts did not fit") + ": " + xt);
      }
      a("result", pt);
    }), hr(v, () => {
      Ke.value && cs();
    }), hr(st, () => {
      Ke.value && Qr(() => Fo());
    });
    const Ma = () => {
      f && (f.disconnect(), f = null);
    };
    return Lo(() => {
      if (I.value) return;
      const at = new URL(window.location.href), pt = at.searchParams.toString(), xt = at.origin + at.pathname + (pt ? `?${pt}` : "");
      y.value !== xt && (R.value.length = 0, vr(1)), y.value = xt, h.value = _.locale;
      const zt = {
        socket: null,
        connected: m,
        maintenanceMode: b,
        jobId: M,
        progress: ue,
        thinking: O,
        user: Kt,
        saw: Z,
        stockList: H,
        shapeList: ct,
        cutList: nt,
        offcuts: N,
        metadata: G,
        usedStock: te,
        addedShapes: vt,
        activeStockId: st
      };
      f = a6.call(zt, "https://api.cutlistevo.com/"), f.connect(), f.emit("getUserFromDomain"), window.addEventListener("resize", p, { passive: !0 }), window.addEventListener("smartcut/load", Ys), I.value = !0, o.debug && a("log", [
        "SmartCut - ready...",
        "fields:",
        Yt.value.map((Ot) => Ot.id)
      ]), typeof window < "u" && (window.smartcutCheckout = { init: pn });
    }), Of(() => {
      window.removeEventListener("resize", p), window.removeEventListener("smartcut/load", Ys), Ma(), delete window.smartcutCheckout;
    }), t({
      init: pn,
      getAvailablePricingOptions: os,
      getExtrasPrice: as,
      formatPrice: o.formatPrice,
      findExtrasPrice: o.findExtrasPrice,
      inputShapes: R,
      initExtrasOptions: er,
      createShapeInput: wr
    }), (at, pt) => {
      var zt, Ot, pe, ce, _e, Oe, un;
      const xt = Fl("font-awesome-icon");
      return ee(), de(Zn, null, [
        Ie(u) === "development" && zk ? (ee(), de("div", vk, [
          pt[5] || (pt[5] = be("div", null, "Developer information", -1)),
          Ln(Ie(s), {
            data: [Ht],
            paths: ["allFields"]
          }, null, 8, ["data"]),
          Ln(Ie(s), {
            data: [Jt.value],
            paths: ["fieldDefinitions"]
          }, null, 8, ["data"])
        ])) : Pe("", !0),
        Ft.value && ((zt = Y.value) != null && zt.machining) ? (ee(), Wn(Ie(i), {
          key: 1,
          shape: Y.value,
          "onUpdate:shape": pt[0] || (pt[0] = (Ee) => Y.value = Ee),
          translate: !0,
          options: Vt,
          env: Ie(u),
          "find-extras-price": n.findExtrasPrice,
          "get-extras-price": as,
          "get-available-pricing-options": os,
          "format-price": n.formatPrice,
          onClose: An
        }, null, 8, ["shape", "options", "env", "find-extras-price", "format-price"])) : Pe("", !0),
        q.value ? Pe("", !0) : (ee(), de("div", wk, [
          Ln(Vg, {
            size: 50,
            "show-number": !1
          })
        ])),
        q.value ? (ee(), de("div", {
          key: 3,
          id: "smartcut-checkout",
          class: di({ fullscreen: ht.value })
        }, [
          A.value && !n.readonly ? (ee(), de("div", {
            key: 0,
            id: "smartcut-full-screen",
            class: "icon-left",
            onClick: pt[1] || (pt[1] = (Ee) => Pi())
          }, [
            Ln(xt, { icon: ["fasr", "expand"] }),
            qu(" " + mn(Ie(l)("full screen")), 1)
          ])) : Pe("", !0),
          (pe = (Ot = Kt.value) == null ? void 0 : Ot.api) != null && pe.whiteLabel ? Pe("", !0) : (ee(), de("div", {
            key: 1,
            id: "credit",
            style: jn(xn.value)
          }, [
            be("a", {
              title: "SmartCut | Cut list optimization software",
              style: jn(Ge.value),
              target: "_blank",
              href: "https://smartcut.dev/"
            }, mn(Ie(l)("Powered by SmartCut")), 5)
          ], 4)),
          be("div", {
            id: "part-input",
            class: "inputs no-margin-top grid-table",
            style: jn({ "grid-template-columns": Xe.value })
          }, [
            Ie(R).length ? (ee(), de("div", xk, [
              pt[6] || (pt[6] = be("div", { class: "cell id" }, null, -1)),
              (ee(!0), de(Zn, null, Lr(Yt.value, (Ee) => (ee(), de("div", {
                key: Ee.id,
                class: di(["cell", { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Ee.id) || Ee.type === "checkbox" }])
              }, mn(Ee.label), 3))), 128)),
              Ie(u) === "development" ? (ee(), de("div", _k, " Info ")) : Pe("", !0),
              Ie(R).length > 1 ? (ee(), de("div", Sk)) : Pe("", !0)
            ])) : Pe("", !0),
            (ee(!0), de(Zn, null, Lr(Ie(R), (Ee, ae) => (ee(), de("div", {
              key: ae,
              class: "row inputs"
            }, [
              be("div", kk, [
                be("div", {
                  class: "id",
                  style: jn({
                    background: we.partA,
                    color: we.text
                  })
                }, mn(ae + 1), 5)
              ]),
              (ee(!0), de(Zn, null, Lr(Yt.value, (ve) => (ee(), de("div", {
                key: ve.fieldMap,
                class: di(["cell", [`${ve.id}`, { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(ve.id) || ve.type === "checkbox" }]])
              }, [
                ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(ve.id) ? ve.id === "orientationLock" ? (ee(), Wn(B6, {
                  key: 1,
                  id: "orientation-" + ae,
                  rectangle: Ee,
                  disabled: n.readonly,
                  "stock-grain": Ni(Ee),
                  "button-background": we.button,
                  "icon-color": we.buttonText,
                  "orientation-model": _.orientationModel,
                  onUpdateOrientation: (Li) => Bi(Ee, Li)
                }, null, 8, ["id", "rectangle", "disabled", "stock-grain", "button-background", "icon-color", "orientation-model", "onUpdateOrientation"])) : ve.id === "banding" ? (ee(), Wn(q6, {
                  key: 2,
                  id: "banding-" + ae,
                  "input-shape": Ee,
                  disabled: n.readonly,
                  "stock-grain": Ni(Ee),
                  open: kt.banding === ae,
                  "orientation-model": _.orientationModel,
                  onClicked: (Li) => hs("banding", Ee)
                }, null, 8, ["id", "input-shape", "disabled", "stock-grain", "open", "orientation-model", "onClicked"])) : ve.id === "finish" ? (ee(), Wn(ak, {
                  key: 3,
                  id: "finish-" + ae,
                  "input-shape": Ee,
                  disabled: n.readonly,
                  open: kt.finish === ae,
                  onClicked: (Li) => hs("finish", Ee)
                }, null, 8, ["id", "input-shape", "disabled", "open", "onClicked"])) : ve.fieldMap === "machining" && A.value ? (ee(), Wn(hk, {
                  key: 4,
                  id: "machining-" + ae,
                  disabled: n.readonly,
                  "input-shape": Ee,
                  onOpen: (Li) => Qn(Ee)
                }, null, 8, ["id", "disabled", "input-shape", "onOpen"])) : ve.fieldMap === "imageUpload" ? (ee(), de("button", {
                  key: 5,
                  id: "image-upload-" + ae,
                  type: "button",
                  disabled: n.readonly,
                  class: di({ selected: kt.info === ae }),
                  onClick: (Li) => hs("imageUpload", Ee)
                }, [
                  Ln(xt, { icon: ["fass", "image"] })
                ], 10, Ak)) : Pe("", !0) : (ee(), Wn(wl, {
                  key: 0,
                  id: ve.id + "-" + ae,
                  focus: !n.readonly && _.enable.focus && ae === Ie(R).length - 1 && ve.id === "l",
                  warning: zr("warnings", Ee, ve.fieldMap),
                  issue: zr("issues", Ee, ve.fieldMap),
                  type: ve.type,
                  output: ve.output,
                  label: ve.label,
                  units: n.units,
                  readonly: n.readonly,
                  placeholder: ve == null ? void 0 : ve.placeholder,
                  options: ve.id === "t" ? ui(Ee) : ve == null ? void 0 : ve.options,
                  "true-value": ve == null ? void 0 : ve.trueValue,
                  "false-value": ve == null ? void 0 : ve.falseValue,
                  default: ve == null ? void 0 : ve.default,
                  min: typeof (ve == null ? void 0 : ve.min) == "number" ? ve.min : null,
                  max: typeof (ve == null ? void 0 : ve.max) == "number" ? ve.max : null,
                  custom: ve == null ? void 0 : ve.custom,
                  value: Be(Ee, ve == null ? void 0 : ve.fieldMap),
                  text: {
                    delete: Ie(l)("delete"),
                    select: Ie(l)("select")
                  },
                  onUpdate: (Li) => {
                    ve.fieldMap && Di(Ee, ve.fieldMap, Li);
                  }
                }, null, 8, ["id", "focus", "warning", "issue", "type", "output", "label", "units", "readonly", "placeholder", "options", "true-value", "false-value", "default", "min", "max", "custom", "value", "text", "onUpdate"]))
              ], 2))), 128)),
              Ie(u) === "development" ? (ee(), de("div", Nk, [
                be("button", {
                  type: "button",
                  class: di({ selected: kt.info === ae }),
                  onClick: (ve) => hs("info", Ee)
                }, " i ", 10, Ck)
              ])) : Pe("", !0),
              Ie(R).length > 1 ? (ee(), de("div", Pk, [
                be("button", {
                  type: "button",
                  disabled: n.readonly,
                  class: "delete",
                  "aria-label": Ie(l)("remove part"),
                  onClick: (ve) => Ia(ae)
                }, [
                  Ln(xt, { icon: ["fass", "trash"] })
                ], 8, Lk)
              ])) : Pe("", !0),
              kt.banding === ae && ne.options.length > 0 ? (ee(), Wn(Yg, {
                key: 2,
                env: Ie(u),
                shape: Ee,
                "shape-index": ae,
                "extra-type": "banding",
                "extra-label": "banding",
                "extra-keys": ne.keys,
                "all-options": ne.options,
                pricing: ne.pricing,
                labels: ne.labels,
                "user-friendly-field-map": Ie(sf),
                "part-columns": le.value,
                "get-price": as,
                "format-price": n.formatPrice,
                "orientation-model": _.orientationModel,
                "get-available-pricing-options": os,
                onUpdateAll: jr,
                onSet: Br
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : Pe("", !0),
              kt.finish === ae && ie.options.length > 0 ? (ee(), Wn(Yg, {
                key: 3,
                env: Ie(u),
                shape: Ee,
                "shape-index": ae,
                "extra-type": "finish",
                "extra-label": "finish",
                "extra-keys": ie.keys,
                "all-options": ie.options,
                pricing: ie.pricing,
                labels: ie.labels,
                "user-friendly-field-map": Ie(sf),
                "part-columns": le.value,
                "get-price": as,
                "format-price": n.formatPrice,
                "orientation-model": _.orientationModel,
                "get-available-pricing-options": os,
                onUpdateAll: jr,
                onSet: Br
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : Pe("", !0),
              kt.info === ae ? (ee(), de("div", {
                key: 4,
                id: "shape-info",
                style: jn({ "grid-column-end": "span " + (le.value + 1) })
              }, [
                Ln(Ie(s), {
                  data: [Ee == null ? void 0 : Ee.machining],
                  paths: ["machining"]
                }, null, 8, ["data"])
              ], 4)) : Pe("", !0),
              kt.imageUpload === ae ? (ee(), Wn(bk, {
                key: 5,
                prefix: (ae + 1).toString(),
                "unique-id": Ie(k),
                "shape-id": Ee.listId,
                env: Ie(u),
                style: jn({ "grid-column-end": "span " + (le.value + 1) }),
                images: C.value,
                onUpdate: To,
                onRemove: La
              }, null, 8, ["prefix", "unique-id", "shape-id", "env", "style", "images"])) : Pe("", !0)
            ]))), 128))
          ], 4),
          be("div", Ik, [
            n.readonly ? Pe("", !0) : (ee(), de("button", {
              key: 0,
              type: "button",
              "aria-label": Ie(l)("add part"),
              style: jn({ background: we.button, color: we.buttonText }),
              class: "add c-btn icon-left",
              onClick: pt[2] || (pt[2] = (Ee) => vr(1))
            }, [
              Ln(xt, { icon: ["fasr", "plus-large"] }),
              qu(" " + mn(Ie(l)("add part")), 1)
            ], 12, Ek)),
            be("button", {
              id: "calculate-button",
              type: "button",
              class: "c-btn calculate icon-left",
              "aria-label": Ie(l)("calculate"),
              style: jn({
                background: we.button,
                color: we.buttonText
              }),
              disabled: !((ce = Q.value) != null && ce.length) || O.value,
              onClick: pt[3] || (pt[3] = (Ee) => Ta())
            }, [
              Ln(xt, { icon: ["fass", "calculator"] }),
              qu(mn(Ie(l)("calculate")), 1)
            ], 12, Ok),
            n.readonly ? Pe("", !0) : (ee(), de("button", {
              key: 1,
              type: "button",
              class: "c-btn clear",
              "aria-label": Ie(l)("clear"),
              onClick: pt[4] || (pt[4] = (Ee) => Gs())
            }, [
              Ln(xt, { icon: ["fass", "trash"] })
            ], 8, Tk)),
            be("div", Fk, mn(et.value) + mn(_ != null && _.maxParts ? "/" + _.maxParts : ""), 1)
          ]),
          P.value && !n.readonly ? (ee(), Wn(Ie(r), {
            key: 2,
            ref: "import",
            units: n.units,
            "custom-fields": Ae.value,
            "banding-options": ne.options,
            "banding-labels": ne.labels,
            "finish-options": ie.options,
            "finish-labels": ie.labels,
            options: {
              locale: _.locale
            },
            onImport: Mo
          }, null, 8, ["units", "custom-fields", "banding-options", "banding-labels", "finish-options", "finish-labels", "options"])) : Pe("", !0),
          X.value ? (ee(), de("div", Mk, [
            rt.value ? (ee(), de("div", Rk, mn(rt.value), 1)) : Pe("", !0),
            be("pre", Dk, mn(wt.value), 1)
          ])) : Pe("", !0),
          (_.enable.diagram ? O.value && !ue.value.complete : O.value || ue.value.complete) ? (ee(), de("div", Bk, [
            Ln(Vg, {
              size: 50,
              number: ue.value.shapeCount,
              complete: ue.value.complete,
              "show-number": _.enable.progressNumber
            }, null, 8, ["number", "complete", "show-number"])
          ])) : Pe("", !0),
          Xg(be("div", jk, [
            ((_e = Xt.value) == null ? void 0 : _e.type) !== "roll" ? (ee(), de("div", qk, mn((Oe = Xt.value) != null && Oe.stack ? (un = Xt.value) == null ? void 0 : un.stack : 1), 1)) : Pe("", !0)
          ], 512), [
            [Jg, _.enable.diagram && M.value > 0]
          ]),
          _.enable.diagram && Ke.value && te.value.length > 1 && M.value > 0 && ue.value.complete ? (ee(), Wn(x6, {
            key: 5,
            ref: "stockNavigation",
            "active-stock-id": st.value,
            "stock-list": E.value,
            "stock-count": H.value.length,
            "viewport-width": v.value,
            onShowStock: bn
          }, null, 8, ["active-stock-id", "stock-list", "stock-count", "viewport-width"])) : Pe("", !0)
        ], 2)) : Pe("", !0)
      ], 64);
    };
  }
});
function Kg(n) {
  const t = n;
  t.__i18n = t.__i18n || [], t.__i18n.push({
    locale: "",
    resource: {
      en_US: {
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Length" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Width" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Thickness" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "T" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Name" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantity" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Material" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machining" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grain" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add part" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Remove part" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calculate" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Full screen" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Banding" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete banding" } },
        finish: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Finish" } },
        "image upload": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image upload" } },
        "delete finish": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete finish" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Select" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "All" } },
        a: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        b: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "B" } },
        c: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        d: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "D" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Drop CSV file here" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Powered by SmartCut" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part issue" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue with part inputs" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts in list" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No quantity of parts found" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts were added - please double check your list." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The following parts did not fit" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The maximum number of parts is" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No valid parts found" } },
        Hardware: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware" } },
        "Hardware total": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware total" } },
        Panels: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Panels" } },
        pdf: {
          orderSummary: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Order summary" } },
          stockRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Stock requirements" } },
          rollRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Roll requirements" } },
          totals: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Totals" } },
          item: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Item" } },
          totalParts: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total parts" } },
          partArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part area" } },
          images: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Images" } },
          totalStockRequired: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total stock required" } },
          totalBandingLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total banding length" } },
          totalFinishArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total finish area" } },
          totalRollLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total roll length" } },
          partIndex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part index" } },
          fileName: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "File name" } },
          link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Link" } }
        }
      },
      ca: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Llarg" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ample" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gruix" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantitat" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanitzat" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gir" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Afegeix" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantell" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina cantell" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Neteja" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Peça" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les peces següents no encaixaven" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número màxim de peces és" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desenvolupat per SmartCut" } }
      },
      es_ES: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largo" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ancho" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grueso" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nombre" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantidad" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanizado" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Giro" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Añade" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Canto" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina canto" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Borra" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pieza" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Las siguientes piezas no encajaban" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número máximo de piezas es" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No se encontraron piezas válidas" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Carga el archivo CSV aquí" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desarrollado por SmartCut" } }
      },
      fr_FR: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Longueur" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largeur" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Epaisseur" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "ep" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantité" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Qt" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Matèriel" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machinage" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sens de fil" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ajouter pièce" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer pièce" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Optimiser" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Plein écran" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Chants" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer chants" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sélectionner" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Effacer" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tous" } },
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        "Powered by SmartCut": { t: 0, b: { static: "", t: 2, i: [] } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Télécharger CSV" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce erreur" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur avec l'importation de pièces" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce dans la liste" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune quantité trouvé pour certaines pièces" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce n'a été ajoutée - veuillez vérifier votre liste." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les pièces suivantes ne s'adaptent pas" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Le nombre maximum de pièces est" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce valide trouvée" } }
      }
    }
  });
}
typeof Kg == "function" && Kg(Bm);
const $k = /* @__PURE__ */ Pa(Bm, [["__scopeId", "data-v-4e2d4f92"]]);
function ju(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, r, s) {
      function o(h, u) {
        if (!r[h]) {
          if (!i[h]) {
            var d = typeof ju == "function" && ju;
            if (!u && d) return d(h, !0);
            if (a) return a(h, !0);
            var p = new Error("Cannot find module '" + h + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var f = r[h] = { exports: {} };
          i[h][0].call(f.exports, function(m) {
            var b = i[h][1][m];
            return o(b || m);
          }, f, f.exports, e, i, r, s);
        }
        return r[h].exports;
      }
      for (var a = typeof ju == "function" && ju, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ 1: [function(e, i, r) {
      var s = e("./utils"), o = e("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(l) {
        for (var h, u, d, p, f, m, b, x = [], y = 0, v = l.length, k = v, C = s.getTypeOf(l) !== "string"; y < l.length; ) k = v - y, d = C ? (h = l[y++], u = y < v ? l[y++] : 0, y < v ? l[y++] : 0) : (h = l.charCodeAt(y++), u = y < v ? l.charCodeAt(y++) : 0, y < v ? l.charCodeAt(y++) : 0), p = h >> 2, f = (3 & h) << 4 | u >> 4, m = 1 < k ? (15 & u) << 2 | d >> 6 : 64, b = 2 < k ? 63 & d : 64, x.push(a.charAt(p) + a.charAt(f) + a.charAt(m) + a.charAt(b));
        return x.join("");
      }, r.decode = function(l) {
        var h, u, d, p, f, m, b = 0, x = 0, y = "data:";
        if (l.substr(0, y.length) === y) throw new Error("Invalid base64 input, it looks like a data url.");
        var v, k = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && k--, l.charAt(l.length - 2) === a.charAt(64) && k--, k % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (v = o.uint8array ? new Uint8Array(0 | k) : new Array(0 | k); b < l.length; ) h = a.indexOf(l.charAt(b++)) << 2 | (p = a.indexOf(l.charAt(b++))) >> 4, u = (15 & p) << 4 | (f = a.indexOf(l.charAt(b++))) >> 2, d = (3 & f) << 6 | (m = a.indexOf(l.charAt(b++))), v[x++] = h, f !== 64 && (v[x++] = u), m !== 64 && (v[x++] = d);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, r) {
      var s = e("./external"), o = e("./stream/DataWorker"), a = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function h(u, d, p, f, m) {
        this.compressedSize = u, this.uncompressedSize = d, this.crc32 = p, this.compression = f, this.compressedContent = m;
      }
      h.prototype = { getContentWorker: function() {
        var u = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, h.createWorkerFrom = function(u, d, p) {
        return u.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, i.exports = h;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, r) {
      var s = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, r) {
      var s = e("./utils"), o = function() {
        for (var a, l = [], h = 0; h < 256; h++) {
          a = h;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[h] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? function(h, u, d, p) {
          var f = o, m = p + d;
          h ^= -1;
          for (var b = p; b < m; b++) h = h >>> 8 ^ f[255 & (h ^ u[b])];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : function(h, u, d, p) {
          var f = o, m = p + d;
          h ^= -1;
          for (var b = p; b < m; b++) h = h >>> 8 ^ f[255 & (h ^ u.charCodeAt(b))];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, r) {
      r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, i, r) {
      var s = null;
      s = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), a = e("./utils"), l = e("./stream/GenericWorker"), h = s ? "uint8array" : "array";
      function u(d, p) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = p, this.meta = {};
      }
      r.magic = "\b\0", a.inherits(u, l), u.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(h, d.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(p) {
          d.push({ data: p, meta: d.meta });
        };
      }, r.compressWorker = function(d) {
        return new u("Deflate", d);
      }, r.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, r) {
      function s(f, m) {
        var b, x = "";
        for (b = 0; b < m; b++) x += String.fromCharCode(255 & f), f >>>= 8;
        return x;
      }
      function o(f, m, b, x, y, v) {
        var k, C, I = f.file, q = f.compression, O = v !== h.utf8encode, F = a.transformTo("string", v(I.name)), M = a.transformTo("string", h.utf8encode(I.name)), j = I.comment, P = a.transformTo("string", v(j)), A = a.transformTo("string", h.utf8encode(j)), T = M.length !== I.name.length, _ = A.length !== j.length, Z = "", V = "", R = "", Q = I.dir, H = I.date, ct = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        m && !b || (ct.crc32 = f.crc32, ct.compressedSize = f.compressedSize, ct.uncompressedSize = f.uncompressedSize);
        var nt = 0;
        m && (nt |= 8), O || !T && !_ || (nt |= 2048);
        var N = 0, z = 0;
        Q && (N |= 16), y === "UNIX" ? (z = 798, N |= function(Y, st) {
          var vt = Y;
          return Y || (vt = st ? 16893 : 33204), (65535 & vt) << 16;
        }(I.unixPermissions, Q)) : (z = 20, N |= function(Y) {
          return 63 & (Y || 0);
        }(I.dosPermissions)), k = H.getUTCHours(), k <<= 6, k |= H.getUTCMinutes(), k <<= 5, k |= H.getUTCSeconds() / 2, C = H.getUTCFullYear() - 1980, C <<= 4, C |= H.getUTCMonth() + 1, C <<= 5, C |= H.getUTCDate(), T && (V = s(1, 1) + s(u(F), 4) + M, Z += "up" + s(V.length, 2) + V), _ && (R = s(1, 1) + s(u(P), 4) + A, Z += "uc" + s(R.length, 2) + R);
        var G = "";
        return G += `
\0`, G += s(nt, 2), G += q.magic, G += s(k, 2), G += s(C, 2), G += s(ct.crc32, 4), G += s(ct.compressedSize, 4), G += s(ct.uncompressedSize, 4), G += s(F.length, 2), G += s(Z.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + G + F + Z, dirRecord: d.CENTRAL_FILE_HEADER + s(z, 2) + G + s(P.length, 2) + "\0\0\0\0" + s(N, 4) + s(x, 4) + F + Z + P };
      }
      var a = e("../utils"), l = e("../stream/GenericWorker"), h = e("../utf8"), u = e("../crc32"), d = e("../signature");
      function p(f, m, b, x) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = m, this.zipPlatform = b, this.encodeFileName = x, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(p, l), p.prototype.push = function(f) {
        var m = f.meta.percent || 0, b = this.entriesCount, x = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, l.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: b ? (m + 100 * (b - x - 1)) / b : 100 } }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var m = this.streamFiles && !f.file.dir;
        if (m) {
          var b = o(f, m, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: b.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var m = this.streamFiles && !f.file.dir, b = o(f, m, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(b.dirRecord), m) this.push({ data: function(x) {
          return d.DATA_DESCRIPTOR + s(x.crc32, 4) + s(x.compressedSize, 4) + s(x.uncompressedSize, 4);
        }(f), meta: { percent: 100 } });
        else for (this.push({ data: b.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, m = 0; m < this.dirRecords.length; m++) this.push({ data: this.dirRecords[m], meta: { percent: 100 } });
        var b = this.bytesWritten - f, x = function(y, v, k, C, I) {
          var q = a.transformTo("string", I(C));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(y, 2) + s(y, 2) + s(v, 4) + s(k, 4) + s(q.length, 2) + q;
        }(this.dirRecords.length, b, f, this.zipComment, this.encodeFileName);
        this.push({ data: x, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var m = this;
        return f.on("data", function(b) {
          m.processChunk(b);
        }), f.on("end", function() {
          m.closedSource(m.previous.streamInfo), m._sources.length ? m.prepareNextSource() : m.end();
        }), f.on("error", function(b) {
          m.error(b);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(f) {
        var m = this._sources;
        if (!l.prototype.error.call(this, f)) return !1;
        for (var b = 0; b < m.length; b++) try {
          m[b].error(f);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var f = this._sources, m = 0; m < f.length; m++) f[m].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, r) {
      var s = e("../compressions"), o = e("./ZipFileWorker");
      r.generateWorker = function(a, l, h) {
        var u = new o(l.streamFiles, h, l.platform, l.encodeFileName), d = 0;
        try {
          a.forEach(function(p, f) {
            d++;
            var m = function(v, k) {
              var C = v || k, I = s[C];
              if (!I) throw new Error(C + " is not a valid compression method !");
              return I;
            }(f.options.compression, l.compression), b = f.options.compressionOptions || l.compressionOptions || {}, x = f.dir, y = f.date;
            f._compressWorker(m, b).withStreamInfo("file", { name: p, dir: x, date: y, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(u);
          }), u.entriesCount = d;
        } catch (p) {
          u.error(p);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, r) {
      function s() {
        if (!(this instanceof s)) return new s();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this) typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (s.prototype = e("./object")).loadAsync = e("./load"), s.support = e("./support"), s.defaults = e("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = e("./external"), i.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, r) {
      var s = e("./utils"), o = e("./external"), a = e("./utf8"), l = e("./zipEntries"), h = e("./stream/Crc32Probe"), u = e("./nodejsUtils");
      function d(p) {
        return new o.Promise(function(f, m) {
          var b = p.decompressed.getContentWorker().pipe(new h());
          b.on("error", function(x) {
            m(x);
          }).on("end", function() {
            b.streamInfo.crc32 !== p.decompressed.crc32 ? m(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      i.exports = function(p, f) {
        var m = this;
        return f = s.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), u.isNode && u.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", p, !0, f.optimizedBinaryString, f.base64).then(function(b) {
          var x = new l(f);
          return x.load(b), x;
        }).then(function(b) {
          var x = [o.Promise.resolve(b)], y = b.files;
          if (f.checkCRC32) for (var v = 0; v < y.length; v++) x.push(d(y[v]));
          return o.Promise.all(x);
        }).then(function(b) {
          for (var x = b.shift(), y = x.files, v = 0; v < y.length; v++) {
            var k = y[v], C = k.fileNameStr, I = s.resolve(k.fileNameStr);
            m.file(I, k.decompressed, { binary: !0, optimizedBinaryString: !0, date: k.date, dir: k.dir, comment: k.fileCommentStr.length ? k.fileCommentStr : null, unixPermissions: k.unixPermissions, dosPermissions: k.dosPermissions, createFolders: f.createFolders }), k.dir || (m.file(I).unsafeOriginalName = C);
          }
          return x.zipComment.length && (m.comment = x.zipComment), m;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, r) {
      var s = e("../utils"), o = e("../stream/GenericWorker");
      function a(l, h) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(h);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var h = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          h.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          h.isPaused ? this.generatedError = u : h.error(u);
        }).on("end", function() {
          h.isPaused ? h._upstreamEnded = !0 : h.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, r) {
      var s = e("readable-stream").Readable;
      function o(a, l, h) {
        s.call(this, l), this._helper = a;
        var u = this;
        a.on("data", function(d, p) {
          u.push(d) || u._helper.pause(), h && h(p);
        }).on("error", function(d) {
          u.emit("error", d);
        }).on("end", function() {
          u.push(null);
        });
      }
      e("../utils").inherits(o, s), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, r) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, o);
        if (typeof s == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(s, o);
      }, allocBuffer: function(s) {
        if (Buffer.alloc) return Buffer.alloc(s);
        var o = new Buffer(s);
        return o.fill(0), o;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(e, i, r) {
      function s(I, q, O) {
        var F, M = a.getTypeOf(q), j = a.extend(O || {}, u);
        j.date = j.date || /* @__PURE__ */ new Date(), j.compression !== null && (j.compression = j.compression.toUpperCase()), typeof j.unixPermissions == "string" && (j.unixPermissions = parseInt(j.unixPermissions, 8)), j.unixPermissions && 16384 & j.unixPermissions && (j.dir = !0), j.dosPermissions && 16 & j.dosPermissions && (j.dir = !0), j.dir && (I = y(I)), j.createFolders && (F = x(I)) && v.call(this, F, !0);
        var P = M === "string" && j.binary === !1 && j.base64 === !1;
        O && O.binary !== void 0 || (j.binary = !P), (q instanceof d && q.uncompressedSize === 0 || j.dir || !q || q.length === 0) && (j.base64 = !1, j.binary = !0, q = "", j.compression = "STORE", M = "string");
        var A = null;
        A = q instanceof d || q instanceof l ? q : m.isNode && m.isStream(q) ? new b(I, q) : a.prepareContent(I, q, j.binary, j.optimizedBinaryString, j.base64);
        var T = new p(I, A, j);
        this.files[I] = T;
      }
      var o = e("./utf8"), a = e("./utils"), l = e("./stream/GenericWorker"), h = e("./stream/StreamHelper"), u = e("./defaults"), d = e("./compressedObject"), p = e("./zipObject"), f = e("./generate"), m = e("./nodejsUtils"), b = e("./nodejs/NodejsStreamInputAdapter"), x = function(I) {
        I.slice(-1) === "/" && (I = I.substring(0, I.length - 1));
        var q = I.lastIndexOf("/");
        return 0 < q ? I.substring(0, q) : "";
      }, y = function(I) {
        return I.slice(-1) !== "/" && (I += "/"), I;
      }, v = function(I, q) {
        return q = q !== void 0 ? q : u.createFolders, I = y(I), this.files[I] || s.call(this, I, null, { dir: !0, createFolders: q }), this.files[I];
      };
      function k(I) {
        return Object.prototype.toString.call(I) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(I) {
        var q, O, F;
        for (q in this.files) F = this.files[q], (O = q.slice(this.root.length, q.length)) && q.slice(0, this.root.length) === this.root && I(O, F);
      }, filter: function(I) {
        var q = [];
        return this.forEach(function(O, F) {
          I(O, F) && q.push(F);
        }), q;
      }, file: function(I, q, O) {
        if (arguments.length !== 1) return I = this.root + I, s.call(this, I, q, O), this;
        if (k(I)) {
          var F = I;
          return this.filter(function(j, P) {
            return !P.dir && F.test(j);
          });
        }
        var M = this.files[this.root + I];
        return M && !M.dir ? M : null;
      }, folder: function(I) {
        if (!I) return this;
        if (k(I)) return this.filter(function(M, j) {
          return j.dir && I.test(M);
        });
        var q = this.root + I, O = v.call(this, q), F = this.clone();
        return F.root = O.name, F;
      }, remove: function(I) {
        I = this.root + I;
        var q = this.files[I];
        if (q || (I.slice(-1) !== "/" && (I += "/"), q = this.files[I]), q && !q.dir) delete this.files[I];
        else for (var O = this.filter(function(M, j) {
          return j.name.slice(0, I.length) === I;
        }), F = 0; F < O.length; F++) delete this.files[O[F].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(I) {
        var q, O = {};
        try {
          if ((O = a.extend(I || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = O.type.toLowerCase(), O.compression = O.compression.toUpperCase(), O.type === "binarystring" && (O.type = "string"), !O.type) throw new Error("No output type specified.");
          a.checkSupport(O.type), O.platform !== "darwin" && O.platform !== "freebsd" && O.platform !== "linux" && O.platform !== "sunos" || (O.platform = "UNIX"), O.platform === "win32" && (O.platform = "DOS");
          var F = O.comment || this.comment || "";
          q = f.generateWorker(this, O, F);
        } catch (M) {
          (q = new l("error")).error(M);
        }
        return new h(q, O.type || "string", O.mimeType);
      }, generateAsync: function(I, q) {
        return this.generateInternalStream(I).accumulate(q);
      }, generateNodeStream: function(I, q) {
        return (I = I || {}).type || (I.type = "nodebuffer"), this.generateInternalStream(I).toNodejsStream(q);
      } };
      i.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, r) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
        for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l];
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === l && this.data[p + 1] === h && this.data[p + 2] === u && this.data[p + 3] === d) return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.readData(4);
        return l === p[0] && h === p[1] && u === p[2] && d === p[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, r) {
      var s = e("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, h = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--) h = (h << 8) + this.byteAt(l);
        return this.index += a, h;
      }, readString: function(a) {
        return s.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, r) {
      var s = e("./Uint8ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, r) {
      var s = e("./ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, r) {
      var s = e("../utils"), o = e("../support"), a = e("./ArrayReader"), l = e("./StringReader"), h = e("./NodeBufferReader"), u = e("./Uint8ArrayReader");
      i.exports = function(d) {
        var p = s.getTypeOf(d);
        return s.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new h(d) : o.uint8array ? new u(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../crc32");
      function a() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(a, s), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var h = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = h + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var h = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          h.dataIsReady = !0, h.data = u, h.max = u && u.length || 0, h.type = s.getTypeOf(u), h.isPaused || h._tickAndRepeat();
        }, function(u) {
          h.error(u);
        });
      }
      s.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, h = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, h);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, h);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, h);
        }
        return this.index = h, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, r) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o]) for (var l = 0; l < this._listeners[o].length; l++) this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = s;
    }, {}], 29: [function(e, i, r) {
      var s = e("../utils"), o = e("./ConvertWorker"), a = e("./GenericWorker"), l = e("../base64"), h = e("../support"), u = e("../external"), d = null;
      if (h.nodestream) try {
        d = e("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(m, b) {
        return new u.Promise(function(x, y) {
          var v = [], k = m._internalType, C = m._outputType, I = m._mimeType;
          m.on("data", function(q, O) {
            v.push(q), b && b(O);
          }).on("error", function(q) {
            v = [], y(q);
          }).on("end", function() {
            try {
              var q = function(O, F, M) {
                switch (O) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", F), M);
                  case "base64":
                    return l.encode(F);
                  default:
                    return s.transformTo(O, F);
                }
              }(C, function(O, F) {
                var M, j = 0, P = null, A = 0;
                for (M = 0; M < F.length; M++) A += F[M].length;
                switch (O) {
                  case "string":
                    return F.join("");
                  case "array":
                    return Array.prototype.concat.apply([], F);
                  case "uint8array":
                    for (P = new Uint8Array(A), M = 0; M < F.length; M++) P.set(F[M], j), j += F[M].length;
                    return P;
                  case "nodebuffer":
                    return Buffer.concat(F);
                  default:
                    throw new Error("concat : unsupported type '" + O + "'");
                }
              }(k, v), I);
              x(q);
            } catch (O) {
              y(O);
            }
            v = [];
          }).resume();
        });
      }
      function f(m, b, x) {
        var y = b;
        switch (b) {
          case "blob":
          case "arraybuffer":
            y = "uint8array";
            break;
          case "base64":
            y = "string";
        }
        try {
          this._internalType = y, this._outputType = b, this._mimeType = x, s.checkSupport(y), this._worker = m.pipe(new o(y)), m.lock();
        } catch (v) {
          this._worker = new a("error"), this._worker.error(v);
        }
      }
      f.prototype = { accumulate: function(m) {
        return p(this, m);
      }, on: function(m, b) {
        var x = this;
        return m === "data" ? this._worker.on(m, function(y) {
          b.call(x, y.data, y.meta);
        }) : this._worker.on(m, function() {
          s.delay(b, arguments, x);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(m) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, m);
      } }, i.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, r) {
      if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") r.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          r.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(s), r.blob = o.getBlob("application/zip").size === 0;
          } catch {
            r.blob = !1;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch {
        r.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, r) {
      for (var s = e("./utils"), o = e("./support"), a = e("./nodejsUtils"), l = e("./stream/GenericWorker"), h = new Array(256), u = 0; u < 256; u++) h[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      h[254] = h[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      r.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : function(m) {
          var b, x, y, v, k, C = m.length, I = 0;
          for (v = 0; v < C; v++) (64512 & (x = m.charCodeAt(v))) == 55296 && v + 1 < C && (64512 & (y = m.charCodeAt(v + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (y - 56320), v++), I += x < 128 ? 1 : x < 2048 ? 2 : x < 65536 ? 3 : 4;
          for (b = o.uint8array ? new Uint8Array(I) : new Array(I), v = k = 0; k < I; v++) (64512 & (x = m.charCodeAt(v))) == 55296 && v + 1 < C && (64512 & (y = m.charCodeAt(v + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (y - 56320), v++), x < 128 ? b[k++] = x : (x < 2048 ? b[k++] = 192 | x >>> 6 : (x < 65536 ? b[k++] = 224 | x >>> 12 : (b[k++] = 240 | x >>> 18, b[k++] = 128 | x >>> 12 & 63), b[k++] = 128 | x >>> 6 & 63), b[k++] = 128 | 63 & x);
          return b;
        }(f);
      }, r.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : function(m) {
          var b, x, y, v, k = m.length, C = new Array(2 * k);
          for (b = x = 0; b < k; ) if ((y = m[b++]) < 128) C[x++] = y;
          else if (4 < (v = h[y])) C[x++] = 65533, b += v - 1;
          else {
            for (y &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && b < k; ) y = y << 6 | 63 & m[b++], v--;
            1 < v ? C[x++] = 65533 : y < 65536 ? C[x++] = y : (y -= 65536, C[x++] = 55296 | y >> 10 & 1023, C[x++] = 56320 | 1023 & y);
          }
          return C.length !== x && (C.subarray ? C = C.subarray(0, x) : C.length = x), s.applyFromCharCode(C);
        }(f = s.transformTo(o.uint8array ? "uint8array" : "array", f));
      }, s.inherits(d, l), d.prototype.processChunk = function(f) {
        var m = s.transformTo(o.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var b = m;
            (m = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), m.set(b, this.leftOver.length);
          } else m = this.leftOver.concat(m);
          this.leftOver = null;
        }
        var x = function(v, k) {
          var C;
          for ((k = k || v.length) > v.length && (k = v.length), C = k - 1; 0 <= C && (192 & v[C]) == 128; ) C--;
          return C < 0 || C === 0 ? k : C + h[v[C]] > k ? C : k;
        }(m), y = m;
        x !== m.length && (o.uint8array ? (y = m.subarray(0, x), this.leftOver = m.subarray(x, m.length)) : (y = m.slice(0, x), this.leftOver = m.slice(x, m.length))), this.push({ data: r.utf8decode(y), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, r.Utf8DecodeWorker = d, s.inherits(p, l), p.prototype.processChunk = function(f) {
        this.push({ data: r.utf8encode(f.data), meta: f.meta });
      }, r.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, r) {
      var s = e("./support"), o = e("./base64"), a = e("./nodejsUtils"), l = e("./external");
      function h(b) {
        return b;
      }
      function u(b, x) {
        for (var y = 0; y < b.length; ++y) x[y] = 255 & b.charCodeAt(y);
        return x;
      }
      e("setimmediate"), r.newBlob = function(b, x) {
        r.checkSupport("blob");
        try {
          return new Blob([b], { type: x });
        } catch {
          try {
            var y = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return y.append(b), y.getBlob(x);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(b, x, y) {
        var v = [], k = 0, C = b.length;
        if (C <= y) return String.fromCharCode.apply(null, b);
        for (; k < C; ) x === "array" || x === "nodebuffer" ? v.push(String.fromCharCode.apply(null, b.slice(k, Math.min(k + y, C)))) : v.push(String.fromCharCode.apply(null, b.subarray(k, Math.min(k + y, C)))), k += y;
        return v.join("");
      }, stringifyByChar: function(b) {
        for (var x = "", y = 0; y < b.length; y++) x += String.fromCharCode(b[y]);
        return x;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(b) {
        var x = 65536, y = r.getTypeOf(b), v = !0;
        if (y === "uint8array" ? v = d.applyCanBeUsed.uint8array : y === "nodebuffer" && (v = d.applyCanBeUsed.nodebuffer), v) for (; 1 < x; ) try {
          return d.stringifyByChunk(b, y, x);
        } catch {
          x = Math.floor(x / 2);
        }
        return d.stringifyByChar(b);
      }
      function f(b, x) {
        for (var y = 0; y < b.length; y++) x[y] = b[y];
        return x;
      }
      r.applyFromCharCode = p;
      var m = {};
      m.string = { string: h, array: function(b) {
        return u(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return m.string.uint8array(b).buffer;
      }, uint8array: function(b) {
        return u(b, new Uint8Array(b.length));
      }, nodebuffer: function(b) {
        return u(b, a.allocBuffer(b.length));
      } }, m.array = { string: p, array: h, arraybuffer: function(b) {
        return new Uint8Array(b).buffer;
      }, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return a.newBufferFrom(b);
      } }, m.arraybuffer = { string: function(b) {
        return p(new Uint8Array(b));
      }, array: function(b) {
        return f(new Uint8Array(b), new Array(b.byteLength));
      }, arraybuffer: h, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return a.newBufferFrom(new Uint8Array(b));
      } }, m.uint8array = { string: p, array: function(b) {
        return f(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return b.buffer;
      }, uint8array: h, nodebuffer: function(b) {
        return a.newBufferFrom(b);
      } }, m.nodebuffer = { string: p, array: function(b) {
        return f(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return m.nodebuffer.uint8array(b).buffer;
      }, uint8array: function(b) {
        return f(b, new Uint8Array(b.length));
      }, nodebuffer: h }, r.transformTo = function(b, x) {
        if (x = x || "", !b) return x;
        r.checkSupport(b);
        var y = r.getTypeOf(x);
        return m[y][b](x);
      }, r.resolve = function(b) {
        for (var x = b.split("/"), y = [], v = 0; v < x.length; v++) {
          var k = x[v];
          k === "." || k === "" && v !== 0 && v !== x.length - 1 || (k === ".." ? y.pop() : y.push(k));
        }
        return y.join("/");
      }, r.getTypeOf = function(b) {
        return typeof b == "string" ? "string" : Object.prototype.toString.call(b) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(b) ? "nodebuffer" : s.uint8array && b instanceof Uint8Array ? "uint8array" : s.arraybuffer && b instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, r.checkSupport = function(b) {
        if (!s[b.toLowerCase()]) throw new Error(b + " is not supported by this platform");
      }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(b) {
        var x, y, v = "";
        for (y = 0; y < (b || "").length; y++) v += "\\x" + ((x = b.charCodeAt(y)) < 16 ? "0" : "") + x.toString(16).toUpperCase();
        return v;
      }, r.delay = function(b, x, y) {
        setImmediate(function() {
          b.apply(y || null, x || []);
        });
      }, r.inherits = function(b, x) {
        function y() {
        }
        y.prototype = x.prototype, b.prototype = new y();
      }, r.extend = function() {
        var b, x, y = {};
        for (b = 0; b < arguments.length; b++) for (x in arguments[b]) Object.prototype.hasOwnProperty.call(arguments[b], x) && y[x] === void 0 && (y[x] = arguments[b][x]);
        return y;
      }, r.prepareContent = function(b, x, y, v, k) {
        return l.Promise.resolve(x).then(function(C) {
          return s.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(I, q) {
            var O = new FileReader();
            O.onload = function(F) {
              I(F.target.result);
            }, O.onerror = function(F) {
              q(F.target.error);
            }, O.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var I = r.getTypeOf(C);
          return I ? (I === "arraybuffer" ? C = r.transformTo("uint8array", C) : I === "string" && (k ? C = o.decode(C) : y && v !== !0 && (C = function(q) {
            return u(q, s.uint8array ? new Uint8Array(q.length) : new Array(q.length));
          }(C))), C) : l.Promise.reject(new Error("Can't read the data of '" + b + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./signature"), l = e("./zipEntry"), h = e("./support");
      function u(d) {
        this.files = [], this.loadOptions = d;
      }
      u.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(d) + ")");
        }
      }, isSignature: function(d, p) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var m = this.reader.readString(4) === p;
        return this.reader.setIndex(f), m;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), p = h.uint8array ? "uint8array" : "array", f = o.transformTo(p, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, p, f, m = this.zip64EndOfCentralSize - 44; 0 < m; ) d = this.reader.readInt(2), p = this.reader.readInt(4), f = this.reader.readData(p), this.zip64ExtensibleData[d] = { id: d, length: p, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, p;
        for (d = 0; d < this.files.length; d++) p = this.files[d], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (d < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var p = d;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var m = p - f;
        if (0 < m) this.isSignature(p, a.CENTRAL_FILE_HEADER) || (this.reader.zero = m);
        else if (m < 0) throw new Error("Corrupted zip: missing " + Math.abs(m) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = s(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./compressedObject"), l = e("./crc32"), h = e("./utf8"), u = e("./compressions"), d = e("./support");
      function p(f, m) {
        this.options = f, this.loadOptions = m;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var m, b;
        if (f.skip(22), this.fileNameLength = f.readInt(2), b = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((m = function(x) {
          for (var y in u) if (Object.prototype.hasOwnProperty.call(u, y) && u[y].magic === x) return u[y];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, m, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var m = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        f.skip(m), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = s(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var m, b, x, y = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < y; ) m = f.readInt(2), b = f.readInt(2), x = f.readData(b), this.extraFields[m] = { id: m, length: b, value: x };
        f.setIndex(y);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = h.utf8decode(this.fileName), this.fileCommentStr = h.utf8decode(this.fileComment);
        else {
          var m = this.findExtraFieldUnicodePath();
          if (m !== null) this.fileNameStr = m;
          else {
            var b = o.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(b);
          }
          var x = this.findExtraFieldUnicodeComment();
          if (x !== null) this.fileCommentStr = x;
          else {
            var y = o.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(y);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var m = s(f.value);
          return m.readInt(1) !== 1 || l(this.fileName) !== m.readInt(4) ? null : h.utf8decode(m.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var m = s(f.value);
          return m.readInt(1) !== 1 || l(this.fileComment) !== m.readInt(4) ? null : h.utf8decode(m.readData(f.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, r) {
      function s(m, b, x) {
        this.name = m, this.dir = x.dir, this.date = x.date, this.comment = x.comment, this.unixPermissions = x.unixPermissions, this.dosPermissions = x.dosPermissions, this._data = b, this._dataBinary = x.binary, this.options = { compression: x.compression, compressionOptions: x.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), a = e("./stream/DataWorker"), l = e("./utf8"), h = e("./compressedObject"), u = e("./stream/GenericWorker");
      s.prototype = { internalStream: function(m) {
        var b = null, x = "string";
        try {
          if (!m) throw new Error("No output type specified.");
          var y = (x = m.toLowerCase()) === "string" || x === "text";
          x !== "binarystring" && x !== "text" || (x = "string"), b = this._decompressWorker();
          var v = !this._dataBinary;
          v && !y && (b = b.pipe(new l.Utf8EncodeWorker())), !v && y && (b = b.pipe(new l.Utf8DecodeWorker()));
        } catch (k) {
          (b = new u("error")).error(k);
        }
        return new o(b, x, "");
      }, async: function(m, b) {
        return this.internalStream(m).accumulate(b);
      }, nodeStream: function(m, b) {
        return this.internalStream(m || "nodebuffer").toNodejsStream(b);
      }, _compressWorker: function(m, b) {
        if (this._data instanceof h && this._data.compression.magic === m.magic) return this._data.getCompressedWorker();
        var x = this._decompressWorker();
        return this._dataBinary || (x = x.pipe(new l.Utf8EncodeWorker())), h.createWorkerFrom(x, m, b);
      }, _decompressWorker: function() {
        return this._data instanceof h ? this._data.getContentWorker() : this._data instanceof u ? this._data : new a(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++) s.prototype[d[f]] = p;
      i.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, r) {
      (function(s) {
        var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
        if (l) {
          var h = 0, u = new l(m), d = s.document.createTextNode("");
          u.observe(d, { characterData: !0 }), o = function() {
            d.data = h = ++h % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0) o = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
          var b = s.document.createElement("script");
          b.onreadystatechange = function() {
            m(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
          }, s.document.documentElement.appendChild(b);
        } : function() {
          setTimeout(m, 0);
        };
        else {
          var p = new s.MessageChannel();
          p.port1.onmessage = m, o = function() {
            p.port2.postMessage(0);
          };
        }
        var f = [];
        function m() {
          var b, x;
          a = !0;
          for (var y = f.length; y; ) {
            for (x = f, f = [], b = -1; ++b < y; ) x[b]();
            y = f.length;
          }
          a = !1;
        }
        i.exports = function(b) {
          f.push(b) !== 1 || a || o();
        };
      }).call(this, typeof co < "u" ? co : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, r) {
      var s = e("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], h = ["FULFILLED"], u = ["PENDING"];
      function d(y) {
        if (typeof y != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, y !== o && b(this, y);
      }
      function p(y, v, k) {
        this.promise = y, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof k == "function" && (this.onRejected = k, this.callRejected = this.otherCallRejected);
      }
      function f(y, v, k) {
        s(function() {
          var C;
          try {
            C = v(k);
          } catch (I) {
            return a.reject(y, I);
          }
          C === y ? a.reject(y, new TypeError("Cannot resolve promise with itself")) : a.resolve(y, C);
        });
      }
      function m(y) {
        var v = y && y.then;
        if (y && (typeof y == "object" || typeof y == "function") && typeof v == "function") return function() {
          v.apply(y, arguments);
        };
      }
      function b(y, v) {
        var k = !1;
        function C(O) {
          k || (k = !0, a.reject(y, O));
        }
        function I(O) {
          k || (k = !0, a.resolve(y, O));
        }
        var q = x(function() {
          v(I, C);
        });
        q.status === "error" && C(q.value);
      }
      function x(y, v) {
        var k = {};
        try {
          k.value = y(v), k.status = "success";
        } catch (C) {
          k.status = "error", k.value = C;
        }
        return k;
      }
      (i.exports = d).prototype.finally = function(y) {
        if (typeof y != "function") return this;
        var v = this.constructor;
        return this.then(function(k) {
          return v.resolve(y()).then(function() {
            return k;
          });
        }, function(k) {
          return v.resolve(y()).then(function() {
            throw k;
          });
        });
      }, d.prototype.catch = function(y) {
        return this.then(null, y);
      }, d.prototype.then = function(y, v) {
        if (typeof y != "function" && this.state === h || typeof v != "function" && this.state === l) return this;
        var k = new this.constructor(o);
        return this.state !== u ? f(k, this.state === h ? y : v, this.outcome) : this.queue.push(new p(k, y, v)), k;
      }, p.prototype.callFulfilled = function(y) {
        a.resolve(this.promise, y);
      }, p.prototype.otherCallFulfilled = function(y) {
        f(this.promise, this.onFulfilled, y);
      }, p.prototype.callRejected = function(y) {
        a.reject(this.promise, y);
      }, p.prototype.otherCallRejected = function(y) {
        f(this.promise, this.onRejected, y);
      }, a.resolve = function(y, v) {
        var k = x(m, v);
        if (k.status === "error") return a.reject(y, k.value);
        var C = k.value;
        if (C) b(y, C);
        else {
          y.state = h, y.outcome = v;
          for (var I = -1, q = y.queue.length; ++I < q; ) y.queue[I].callFulfilled(v);
        }
        return y;
      }, a.reject = function(y, v) {
        y.state = l, y.outcome = v;
        for (var k = -1, C = y.queue.length; ++k < C; ) y.queue[k].callRejected(v);
        return y;
      }, d.resolve = function(y) {
        return y instanceof this ? y : a.resolve(new this(o), y);
      }, d.reject = function(y) {
        var v = new this(o);
        return a.reject(v, y);
      }, d.all = function(y) {
        var v = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var k = y.length, C = !1;
        if (!k) return this.resolve([]);
        for (var I = new Array(k), q = 0, O = -1, F = new this(o); ++O < k; ) M(y[O], O);
        return F;
        function M(j, P) {
          v.resolve(j).then(function(A) {
            I[P] = A, ++q !== k || C || (C = !0, a.resolve(F, I));
          }, function(A) {
            C || (C = !0, a.reject(F, A));
          });
        }
      }, d.race = function(y) {
        var v = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var k = y.length, C = !1;
        if (!k) return this.resolve([]);
        for (var I = -1, q = new this(o); ++I < k; ) O = y[I], v.resolve(O).then(function(F) {
          C || (C = !0, a.resolve(q, F));
        }, function(F) {
          C || (C = !0, a.reject(q, F));
        });
        var O;
        return q;
      };
    }, { immediate: 36 }], 38: [function(e, i, r) {
      var s = {};
      (0, e("./lib/utils/common").assign)(s, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, r) {
      var s = e("./zlib/deflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/messages"), h = e("./zlib/zstream"), u = Object.prototype.toString, d = 0, p = -1, f = 0, m = 8;
      function b(y) {
        if (!(this instanceof b)) return new b(y);
        this.options = o.assign({ level: p, method: m, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, y || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var k = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (k !== d) throw new Error(l[k]);
        if (v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var C;
          if (C = typeof v.dictionary == "string" ? a.string2buf(v.dictionary) : u.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (k = s.deflateSetDictionary(this.strm, C)) !== d) throw new Error(l[k]);
          this._dict_set = !0;
        }
      }
      function x(y, v) {
        var k = new b(v);
        if (k.push(y, !0), k.err) throw k.msg || l[k.err];
        return k.result;
      }
      b.prototype.push = function(y, v) {
        var k, C, I = this.strm, q = this.options.chunkSize;
        if (this.ended) return !1;
        C = v === ~~v ? v : v === !0 ? 4 : 0, typeof y == "string" ? I.input = a.string2buf(y) : u.call(y) === "[object ArrayBuffer]" ? I.input = new Uint8Array(y) : I.input = y, I.next_in = 0, I.avail_in = I.input.length;
        do {
          if (I.avail_out === 0 && (I.output = new o.Buf8(q), I.next_out = 0, I.avail_out = q), (k = s.deflate(I, C)) !== 1 && k !== d) return this.onEnd(k), !(this.ended = !0);
          I.avail_out !== 0 && (I.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(I.output, I.next_out))) : this.onData(o.shrinkBuf(I.output, I.next_out)));
        } while ((0 < I.avail_in || I.avail_out === 0) && k !== 1);
        return C === 4 ? (k = s.deflateEnd(this.strm), this.onEnd(k), this.ended = !0, k === d) : C !== 2 || (this.onEnd(d), !(I.avail_out = 0));
      }, b.prototype.onData = function(y) {
        this.chunks.push(y);
      }, b.prototype.onEnd = function(y) {
        y === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, r.Deflate = b, r.deflate = x, r.deflateRaw = function(y, v) {
        return (v = v || {}).raw = !0, x(y, v);
      }, r.gzip = function(y, v) {
        return (v = v || {}).gzip = !0, x(y, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, r) {
      var s = e("./zlib/inflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/constants"), h = e("./zlib/messages"), u = e("./zlib/zstream"), d = e("./zlib/gzheader"), p = Object.prototype.toString;
      function f(b) {
        if (!(this instanceof f)) return new f(b);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
        var x = this.options;
        x.raw && 0 <= x.windowBits && x.windowBits < 16 && (x.windowBits = -x.windowBits, x.windowBits === 0 && (x.windowBits = -15)), !(0 <= x.windowBits && x.windowBits < 16) || b && b.windowBits || (x.windowBits += 32), 15 < x.windowBits && x.windowBits < 48 && !(15 & x.windowBits) && (x.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var y = s.inflateInit2(this.strm, x.windowBits);
        if (y !== l.Z_OK) throw new Error(h[y]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      function m(b, x) {
        var y = new f(x);
        if (y.push(b, !0), y.err) throw y.msg || h[y.err];
        return y.result;
      }
      f.prototype.push = function(b, x) {
        var y, v, k, C, I, q, O = this.strm, F = this.options.chunkSize, M = this.options.dictionary, j = !1;
        if (this.ended) return !1;
        v = x === ~~x ? x : x === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof b == "string" ? O.input = a.binstring2buf(b) : p.call(b) === "[object ArrayBuffer]" ? O.input = new Uint8Array(b) : O.input = b, O.next_in = 0, O.avail_in = O.input.length;
        do {
          if (O.avail_out === 0 && (O.output = new o.Buf8(F), O.next_out = 0, O.avail_out = F), (y = s.inflate(O, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && M && (q = typeof M == "string" ? a.string2buf(M) : p.call(M) === "[object ArrayBuffer]" ? new Uint8Array(M) : M, y = s.inflateSetDictionary(this.strm, q)), y === l.Z_BUF_ERROR && j === !0 && (y = l.Z_OK, j = !1), y !== l.Z_STREAM_END && y !== l.Z_OK) return this.onEnd(y), !(this.ended = !0);
          O.next_out && (O.avail_out !== 0 && y !== l.Z_STREAM_END && (O.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (k = a.utf8border(O.output, O.next_out), C = O.next_out - k, I = a.buf2string(O.output, k), O.next_out = C, O.avail_out = F - C, C && o.arraySet(O.output, O.output, k, C, 0), this.onData(I)) : this.onData(o.shrinkBuf(O.output, O.next_out)))), O.avail_in === 0 && O.avail_out === 0 && (j = !0);
        } while ((0 < O.avail_in || O.avail_out === 0) && y !== l.Z_STREAM_END);
        return y === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (y = s.inflateEnd(this.strm), this.onEnd(y), this.ended = !0, y === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(O.avail_out = 0));
      }, f.prototype.onData = function(b) {
        this.chunks.push(b);
      }, f.prototype.onEnd = function(b) {
        b === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, r.Inflate = f, r.inflate = m, r.inflateRaw = function(b, x) {
        return (x = x || {}).raw = !0, m(b, x);
      }, r.ungzip = m;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      r.assign = function(l) {
        for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
          var u = h.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var d in u) u.hasOwnProperty(d) && (l[d] = u[d]);
          }
        }
        return l;
      }, r.shrinkBuf = function(l, h) {
        return l.length === h ? l : l.subarray ? l.subarray(0, h) : (l.length = h, l);
      };
      var o = { arraySet: function(l, h, u, d, p) {
        if (h.subarray && l.subarray) l.set(h.subarray(u, u + d), p);
        else for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        var h, u, d, p, f, m;
        for (h = d = 0, u = l.length; h < u; h++) d += l[h].length;
        for (m = new Uint8Array(d), h = p = 0, u = l.length; h < u; h++) f = l[h], m.set(f, p), p += f.length;
        return m;
      } }, a = { arraySet: function(l, h, u, d, p) {
        for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      r.setTyped = function(l) {
        l ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, a));
      }, r.setTyped(s);
    }, {}], 42: [function(e, i, r) {
      var s = e("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), h = 0; h < 256; h++) l[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      function u(d, p) {
        if (p < 65537 && (d.subarray && a || !d.subarray && o)) return String.fromCharCode.apply(null, s.shrinkBuf(d, p));
        for (var f = "", m = 0; m < p; m++) f += String.fromCharCode(d[m]);
        return f;
      }
      l[254] = l[254] = 1, r.string2buf = function(d) {
        var p, f, m, b, x, y = d.length, v = 0;
        for (b = 0; b < y; b++) (64512 & (f = d.charCodeAt(b))) == 55296 && b + 1 < y && (64512 & (m = d.charCodeAt(b + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (m - 56320), b++), v += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (p = new s.Buf8(v), b = x = 0; x < v; b++) (64512 & (f = d.charCodeAt(b))) == 55296 && b + 1 < y && (64512 & (m = d.charCodeAt(b + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (m - 56320), b++), f < 128 ? p[x++] = f : (f < 2048 ? p[x++] = 192 | f >>> 6 : (f < 65536 ? p[x++] = 224 | f >>> 12 : (p[x++] = 240 | f >>> 18, p[x++] = 128 | f >>> 12 & 63), p[x++] = 128 | f >>> 6 & 63), p[x++] = 128 | 63 & f);
        return p;
      }, r.buf2binstring = function(d) {
        return u(d, d.length);
      }, r.binstring2buf = function(d) {
        for (var p = new s.Buf8(d.length), f = 0, m = p.length; f < m; f++) p[f] = d.charCodeAt(f);
        return p;
      }, r.buf2string = function(d, p) {
        var f, m, b, x, y = p || d.length, v = new Array(2 * y);
        for (f = m = 0; f < y; ) if ((b = d[f++]) < 128) v[m++] = b;
        else if (4 < (x = l[b])) v[m++] = 65533, f += x - 1;
        else {
          for (b &= x === 2 ? 31 : x === 3 ? 15 : 7; 1 < x && f < y; ) b = b << 6 | 63 & d[f++], x--;
          1 < x ? v[m++] = 65533 : b < 65536 ? v[m++] = b : (b -= 65536, v[m++] = 55296 | b >> 10 & 1023, v[m++] = 56320 | 1023 & b);
        }
        return u(v, m);
      }, r.utf8border = function(d, p) {
        var f;
        for ((p = p || d.length) > d.length && (p = d.length), f = p - 1; 0 <= f && (192 & d[f]) == 128; ) f--;
        return f < 0 || f === 0 ? p : f + l[d[f]] > p ? f : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, r) {
      i.exports = function(s, o, a, l) {
        for (var h = 65535 & s | 0, u = s >>> 16 & 65535 | 0, d = 0; a !== 0; ) {
          for (a -= d = 2e3 < a ? 2e3 : a; u = u + (h = h + o[l++] | 0) | 0, --d; ) ;
          h %= 65521, u %= 65521;
        }
        return h | u << 16 | 0;
      };
    }, {}], 44: [function(e, i, r) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, r) {
      var s = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var h = 0; h < 8; h++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, h) {
        var u = s, d = h + l;
        o ^= -1;
        for (var p = h; p < d; p++) o = o >>> 8 ^ u[255 & (o ^ a[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, r) {
      var s, o = e("../utils/common"), a = e("./trees"), l = e("./adler32"), h = e("./crc32"), u = e("./messages"), d = 0, p = 4, f = 0, m = -2, b = -1, x = 4, y = 2, v = 8, k = 9, C = 286, I = 30, q = 19, O = 2 * C + 1, F = 15, M = 3, j = 258, P = j + M + 1, A = 42, T = 113, _ = 1, Z = 2, V = 3, R = 4;
      function Q(E, ft) {
        return E.msg = u[ft], ft;
      }
      function H(E) {
        return (E << 1) - (4 < E ? 9 : 0);
      }
      function ct(E) {
        for (var ft = E.length; 0 <= --ft; ) E[ft] = 0;
      }
      function nt(E) {
        var ft = E.state, U = ft.pending;
        U > E.avail_out && (U = E.avail_out), U !== 0 && (o.arraySet(E.output, ft.pending_buf, ft.pending_out, U, E.next_out), E.next_out += U, ft.pending_out += U, E.total_out += U, E.avail_out -= U, ft.pending -= U, ft.pending === 0 && (ft.pending_out = 0));
      }
      function N(E, ft) {
        a._tr_flush_block(E, 0 <= E.block_start ? E.block_start : -1, E.strstart - E.block_start, ft), E.block_start = E.strstart, nt(E.strm);
      }
      function z(E, ft) {
        E.pending_buf[E.pending++] = ft;
      }
      function G(E, ft) {
        E.pending_buf[E.pending++] = ft >>> 8 & 255, E.pending_buf[E.pending++] = 255 & ft;
      }
      function Y(E, ft) {
        var U, et, X = E.max_chain_length, rt = E.strstart, wt = E.prev_length, kt = E.nice_match, dt = E.strstart > E.w_size - P ? E.strstart - (E.w_size - P) : 0, Pt = E.window, qt = E.w_mask, Ft = E.prev, Vt = E.strstart + j, ne = Pt[rt + wt - 1], ie = Pt[rt + wt];
        E.prev_length >= E.good_match && (X >>= 2), kt > E.lookahead && (kt = E.lookahead);
        do
          if (Pt[(U = ft) + wt] === ie && Pt[U + wt - 1] === ne && Pt[U] === Pt[rt] && Pt[++U] === Pt[rt + 1]) {
            rt += 2, U++;
            do
              ;
            while (Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && Pt[++rt] === Pt[++U] && rt < Vt);
            if (et = j - (Vt - rt), rt = Vt - j, wt < et) {
              if (E.match_start = ft, kt <= (wt = et)) break;
              ne = Pt[rt + wt - 1], ie = Pt[rt + wt];
            }
          }
        while ((ft = Ft[ft & qt]) > dt && --X != 0);
        return wt <= E.lookahead ? wt : E.lookahead;
      }
      function st(E) {
        var ft, U, et, X, rt, wt, kt, dt, Pt, qt, Ft = E.w_size;
        do {
          if (X = E.window_size - E.lookahead - E.strstart, E.strstart >= Ft + (Ft - P)) {
            for (o.arraySet(E.window, E.window, Ft, Ft, 0), E.match_start -= Ft, E.strstart -= Ft, E.block_start -= Ft, ft = U = E.hash_size; et = E.head[--ft], E.head[ft] = Ft <= et ? et - Ft : 0, --U; ) ;
            for (ft = U = Ft; et = E.prev[--ft], E.prev[ft] = Ft <= et ? et - Ft : 0, --U; ) ;
            X += Ft;
          }
          if (E.strm.avail_in === 0) break;
          if (wt = E.strm, kt = E.window, dt = E.strstart + E.lookahead, Pt = X, qt = void 0, qt = wt.avail_in, Pt < qt && (qt = Pt), U = qt === 0 ? 0 : (wt.avail_in -= qt, o.arraySet(kt, wt.input, wt.next_in, qt, dt), wt.state.wrap === 1 ? wt.adler = l(wt.adler, kt, qt, dt) : wt.state.wrap === 2 && (wt.adler = h(wt.adler, kt, qt, dt)), wt.next_in += qt, wt.total_in += qt, qt), E.lookahead += U, E.lookahead + E.insert >= M) for (rt = E.strstart - E.insert, E.ins_h = E.window[rt], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[rt + 1]) & E.hash_mask; E.insert && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[rt + M - 1]) & E.hash_mask, E.prev[rt & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = rt, rt++, E.insert--, !(E.lookahead + E.insert < M)); ) ;
        } while (E.lookahead < P && E.strm.avail_in !== 0);
      }
      function vt(E, ft) {
        for (var U, et; ; ) {
          if (E.lookahead < P) {
            if (st(E), E.lookahead < P && ft === d) return _;
            if (E.lookahead === 0) break;
          }
          if (U = 0, E.lookahead >= M && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + M - 1]) & E.hash_mask, U = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), U !== 0 && E.strstart - U <= E.w_size - P && (E.match_length = Y(E, U)), E.match_length >= M) if (et = a._tr_tally(E, E.strstart - E.match_start, E.match_length - M), E.lookahead -= E.match_length, E.match_length <= E.max_lazy_match && E.lookahead >= M) {
            for (E.match_length--; E.strstart++, E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + M - 1]) & E.hash_mask, U = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart, --E.match_length != 0; ) ;
            E.strstart++;
          } else E.strstart += E.match_length, E.match_length = 0, E.ins_h = E.window[E.strstart], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + 1]) & E.hash_mask;
          else et = a._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++;
          if (et && (N(E, !1), E.strm.avail_out === 0)) return _;
        }
        return E.insert = E.strstart < M - 1 ? E.strstart : M - 1, ft === p ? (N(E, !0), E.strm.avail_out === 0 ? V : R) : E.last_lit && (N(E, !1), E.strm.avail_out === 0) ? _ : Z;
      }
      function mt(E, ft) {
        for (var U, et, X; ; ) {
          if (E.lookahead < P) {
            if (st(E), E.lookahead < P && ft === d) return _;
            if (E.lookahead === 0) break;
          }
          if (U = 0, E.lookahead >= M && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + M - 1]) & E.hash_mask, U = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), E.prev_length = E.match_length, E.prev_match = E.match_start, E.match_length = M - 1, U !== 0 && E.prev_length < E.max_lazy_match && E.strstart - U <= E.w_size - P && (E.match_length = Y(E, U), E.match_length <= 5 && (E.strategy === 1 || E.match_length === M && 4096 < E.strstart - E.match_start) && (E.match_length = M - 1)), E.prev_length >= M && E.match_length <= E.prev_length) {
            for (X = E.strstart + E.lookahead - M, et = a._tr_tally(E, E.strstart - 1 - E.prev_match, E.prev_length - M), E.lookahead -= E.prev_length - 1, E.prev_length -= 2; ++E.strstart <= X && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + M - 1]) & E.hash_mask, U = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), --E.prev_length != 0; ) ;
            if (E.match_available = 0, E.match_length = M - 1, E.strstart++, et && (N(E, !1), E.strm.avail_out === 0)) return _;
          } else if (E.match_available) {
            if ((et = a._tr_tally(E, 0, E.window[E.strstart - 1])) && N(E, !1), E.strstart++, E.lookahead--, E.strm.avail_out === 0) return _;
          } else E.match_available = 1, E.strstart++, E.lookahead--;
        }
        return E.match_available && (et = a._tr_tally(E, 0, E.window[E.strstart - 1]), E.match_available = 0), E.insert = E.strstart < M - 1 ? E.strstart : M - 1, ft === p ? (N(E, !0), E.strm.avail_out === 0 ? V : R) : E.last_lit && (N(E, !1), E.strm.avail_out === 0) ? _ : Z;
      }
      function _t(E, ft, U, et, X) {
        this.good_length = E, this.max_lazy = ft, this.nice_length = U, this.max_chain = et, this.func = X;
      }
      function Bt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * O), this.dyn_dtree = new o.Buf16(2 * (2 * I + 1)), this.bl_tree = new o.Buf16(2 * (2 * q + 1)), ct(this.dyn_ltree), ct(this.dyn_dtree), ct(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(F + 1), this.heap = new o.Buf16(2 * C + 1), ct(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * C + 1), ct(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Rt(E) {
        var ft;
        return E && E.state ? (E.total_in = E.total_out = 0, E.data_type = y, (ft = E.state).pending = 0, ft.pending_out = 0, ft.wrap < 0 && (ft.wrap = -ft.wrap), ft.status = ft.wrap ? A : T, E.adler = ft.wrap === 2 ? 0 : 1, ft.last_flush = d, a._tr_init(ft), f) : Q(E, m);
      }
      function te(E) {
        var ft = Rt(E);
        return ft === f && function(U) {
          U.window_size = 2 * U.w_size, ct(U.head), U.max_lazy_match = s[U.level].max_lazy, U.good_match = s[U.level].good_length, U.nice_match = s[U.level].nice_length, U.max_chain_length = s[U.level].max_chain, U.strstart = 0, U.block_start = 0, U.lookahead = 0, U.insert = 0, U.match_length = U.prev_length = M - 1, U.match_available = 0, U.ins_h = 0;
        }(E.state), ft;
      }
      function Xt(E, ft, U, et, X, rt) {
        if (!E) return m;
        var wt = 1;
        if (ft === b && (ft = 6), et < 0 ? (wt = 0, et = -et) : 15 < et && (wt = 2, et -= 16), X < 1 || k < X || U !== v || et < 8 || 15 < et || ft < 0 || 9 < ft || rt < 0 || x < rt) return Q(E, m);
        et === 8 && (et = 9);
        var kt = new Bt();
        return (E.state = kt).strm = E, kt.wrap = wt, kt.gzhead = null, kt.w_bits = et, kt.w_size = 1 << kt.w_bits, kt.w_mask = kt.w_size - 1, kt.hash_bits = X + 7, kt.hash_size = 1 << kt.hash_bits, kt.hash_mask = kt.hash_size - 1, kt.hash_shift = ~~((kt.hash_bits + M - 1) / M), kt.window = new o.Buf8(2 * kt.w_size), kt.head = new o.Buf16(kt.hash_size), kt.prev = new o.Buf16(kt.w_size), kt.lit_bufsize = 1 << X + 6, kt.pending_buf_size = 4 * kt.lit_bufsize, kt.pending_buf = new o.Buf8(kt.pending_buf_size), kt.d_buf = 1 * kt.lit_bufsize, kt.l_buf = 3 * kt.lit_bufsize, kt.level = ft, kt.strategy = rt, kt.method = U, te(E);
      }
      s = [new _t(0, 0, 0, 0, function(E, ft) {
        var U = 65535;
        for (U > E.pending_buf_size - 5 && (U = E.pending_buf_size - 5); ; ) {
          if (E.lookahead <= 1) {
            if (st(E), E.lookahead === 0 && ft === d) return _;
            if (E.lookahead === 0) break;
          }
          E.strstart += E.lookahead, E.lookahead = 0;
          var et = E.block_start + U;
          if ((E.strstart === 0 || E.strstart >= et) && (E.lookahead = E.strstart - et, E.strstart = et, N(E, !1), E.strm.avail_out === 0) || E.strstart - E.block_start >= E.w_size - P && (N(E, !1), E.strm.avail_out === 0)) return _;
        }
        return E.insert = 0, ft === p ? (N(E, !0), E.strm.avail_out === 0 ? V : R) : (E.strstart > E.block_start && (N(E, !1), E.strm.avail_out), _);
      }), new _t(4, 4, 8, 4, vt), new _t(4, 5, 16, 8, vt), new _t(4, 6, 32, 32, vt), new _t(4, 4, 16, 16, mt), new _t(8, 16, 32, 32, mt), new _t(8, 16, 128, 128, mt), new _t(8, 32, 128, 256, mt), new _t(32, 128, 258, 1024, mt), new _t(32, 258, 258, 4096, mt)], r.deflateInit = function(E, ft) {
        return Xt(E, ft, v, 15, 8, 0);
      }, r.deflateInit2 = Xt, r.deflateReset = te, r.deflateResetKeep = Rt, r.deflateSetHeader = function(E, ft) {
        return E && E.state ? E.state.wrap !== 2 ? m : (E.state.gzhead = ft, f) : m;
      }, r.deflate = function(E, ft) {
        var U, et, X, rt;
        if (!E || !E.state || 5 < ft || ft < 0) return E ? Q(E, m) : m;
        if (et = E.state, !E.output || !E.input && E.avail_in !== 0 || et.status === 666 && ft !== p) return Q(E, E.avail_out === 0 ? -5 : m);
        if (et.strm = E, U = et.last_flush, et.last_flush = ft, et.status === A) if (et.wrap === 2) E.adler = 0, z(et, 31), z(et, 139), z(et, 8), et.gzhead ? (z(et, (et.gzhead.text ? 1 : 0) + (et.gzhead.hcrc ? 2 : 0) + (et.gzhead.extra ? 4 : 0) + (et.gzhead.name ? 8 : 0) + (et.gzhead.comment ? 16 : 0)), z(et, 255 & et.gzhead.time), z(et, et.gzhead.time >> 8 & 255), z(et, et.gzhead.time >> 16 & 255), z(et, et.gzhead.time >> 24 & 255), z(et, et.level === 9 ? 2 : 2 <= et.strategy || et.level < 2 ? 4 : 0), z(et, 255 & et.gzhead.os), et.gzhead.extra && et.gzhead.extra.length && (z(et, 255 & et.gzhead.extra.length), z(et, et.gzhead.extra.length >> 8 & 255)), et.gzhead.hcrc && (E.adler = h(E.adler, et.pending_buf, et.pending, 0)), et.gzindex = 0, et.status = 69) : (z(et, 0), z(et, 0), z(et, 0), z(et, 0), z(et, 0), z(et, et.level === 9 ? 2 : 2 <= et.strategy || et.level < 2 ? 4 : 0), z(et, 3), et.status = T);
        else {
          var wt = v + (et.w_bits - 8 << 4) << 8;
          wt |= (2 <= et.strategy || et.level < 2 ? 0 : et.level < 6 ? 1 : et.level === 6 ? 2 : 3) << 6, et.strstart !== 0 && (wt |= 32), wt += 31 - wt % 31, et.status = T, G(et, wt), et.strstart !== 0 && (G(et, E.adler >>> 16), G(et, 65535 & E.adler)), E.adler = 1;
        }
        if (et.status === 69) if (et.gzhead.extra) {
          for (X = et.pending; et.gzindex < (65535 & et.gzhead.extra.length) && (et.pending !== et.pending_buf_size || (et.gzhead.hcrc && et.pending > X && (E.adler = h(E.adler, et.pending_buf, et.pending - X, X)), nt(E), X = et.pending, et.pending !== et.pending_buf_size)); ) z(et, 255 & et.gzhead.extra[et.gzindex]), et.gzindex++;
          et.gzhead.hcrc && et.pending > X && (E.adler = h(E.adler, et.pending_buf, et.pending - X, X)), et.gzindex === et.gzhead.extra.length && (et.gzindex = 0, et.status = 73);
        } else et.status = 73;
        if (et.status === 73) if (et.gzhead.name) {
          X = et.pending;
          do {
            if (et.pending === et.pending_buf_size && (et.gzhead.hcrc && et.pending > X && (E.adler = h(E.adler, et.pending_buf, et.pending - X, X)), nt(E), X = et.pending, et.pending === et.pending_buf_size)) {
              rt = 1;
              break;
            }
            rt = et.gzindex < et.gzhead.name.length ? 255 & et.gzhead.name.charCodeAt(et.gzindex++) : 0, z(et, rt);
          } while (rt !== 0);
          et.gzhead.hcrc && et.pending > X && (E.adler = h(E.adler, et.pending_buf, et.pending - X, X)), rt === 0 && (et.gzindex = 0, et.status = 91);
        } else et.status = 91;
        if (et.status === 91) if (et.gzhead.comment) {
          X = et.pending;
          do {
            if (et.pending === et.pending_buf_size && (et.gzhead.hcrc && et.pending > X && (E.adler = h(E.adler, et.pending_buf, et.pending - X, X)), nt(E), X = et.pending, et.pending === et.pending_buf_size)) {
              rt = 1;
              break;
            }
            rt = et.gzindex < et.gzhead.comment.length ? 255 & et.gzhead.comment.charCodeAt(et.gzindex++) : 0, z(et, rt);
          } while (rt !== 0);
          et.gzhead.hcrc && et.pending > X && (E.adler = h(E.adler, et.pending_buf, et.pending - X, X)), rt === 0 && (et.status = 103);
        } else et.status = 103;
        if (et.status === 103 && (et.gzhead.hcrc ? (et.pending + 2 > et.pending_buf_size && nt(E), et.pending + 2 <= et.pending_buf_size && (z(et, 255 & E.adler), z(et, E.adler >> 8 & 255), E.adler = 0, et.status = T)) : et.status = T), et.pending !== 0) {
          if (nt(E), E.avail_out === 0) return et.last_flush = -1, f;
        } else if (E.avail_in === 0 && H(ft) <= H(U) && ft !== p) return Q(E, -5);
        if (et.status === 666 && E.avail_in !== 0) return Q(E, -5);
        if (E.avail_in !== 0 || et.lookahead !== 0 || ft !== d && et.status !== 666) {
          var kt = et.strategy === 2 ? function(dt, Pt) {
            for (var qt; ; ) {
              if (dt.lookahead === 0 && (st(dt), dt.lookahead === 0)) {
                if (Pt === d) return _;
                break;
              }
              if (dt.match_length = 0, qt = a._tr_tally(dt, 0, dt.window[dt.strstart]), dt.lookahead--, dt.strstart++, qt && (N(dt, !1), dt.strm.avail_out === 0)) return _;
            }
            return dt.insert = 0, Pt === p ? (N(dt, !0), dt.strm.avail_out === 0 ? V : R) : dt.last_lit && (N(dt, !1), dt.strm.avail_out === 0) ? _ : Z;
          }(et, ft) : et.strategy === 3 ? function(dt, Pt) {
            for (var qt, Ft, Vt, ne, ie = dt.window; ; ) {
              if (dt.lookahead <= j) {
                if (st(dt), dt.lookahead <= j && Pt === d) return _;
                if (dt.lookahead === 0) break;
              }
              if (dt.match_length = 0, dt.lookahead >= M && 0 < dt.strstart && (Ft = ie[Vt = dt.strstart - 1]) === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt]) {
                ne = dt.strstart + j;
                do
                  ;
                while (Ft === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt] && Ft === ie[++Vt] && Vt < ne);
                dt.match_length = j - (ne - Vt), dt.match_length > dt.lookahead && (dt.match_length = dt.lookahead);
              }
              if (dt.match_length >= M ? (qt = a._tr_tally(dt, 1, dt.match_length - M), dt.lookahead -= dt.match_length, dt.strstart += dt.match_length, dt.match_length = 0) : (qt = a._tr_tally(dt, 0, dt.window[dt.strstart]), dt.lookahead--, dt.strstart++), qt && (N(dt, !1), dt.strm.avail_out === 0)) return _;
            }
            return dt.insert = 0, Pt === p ? (N(dt, !0), dt.strm.avail_out === 0 ? V : R) : dt.last_lit && (N(dt, !1), dt.strm.avail_out === 0) ? _ : Z;
          }(et, ft) : s[et.level].func(et, ft);
          if (kt !== V && kt !== R || (et.status = 666), kt === _ || kt === V) return E.avail_out === 0 && (et.last_flush = -1), f;
          if (kt === Z && (ft === 1 ? a._tr_align(et) : ft !== 5 && (a._tr_stored_block(et, 0, 0, !1), ft === 3 && (ct(et.head), et.lookahead === 0 && (et.strstart = 0, et.block_start = 0, et.insert = 0))), nt(E), E.avail_out === 0)) return et.last_flush = -1, f;
        }
        return ft !== p ? f : et.wrap <= 0 ? 1 : (et.wrap === 2 ? (z(et, 255 & E.adler), z(et, E.adler >> 8 & 255), z(et, E.adler >> 16 & 255), z(et, E.adler >> 24 & 255), z(et, 255 & E.total_in), z(et, E.total_in >> 8 & 255), z(et, E.total_in >> 16 & 255), z(et, E.total_in >> 24 & 255)) : (G(et, E.adler >>> 16), G(et, 65535 & E.adler)), nt(E), 0 < et.wrap && (et.wrap = -et.wrap), et.pending !== 0 ? f : 1);
      }, r.deflateEnd = function(E) {
        var ft;
        return E && E.state ? (ft = E.state.status) !== A && ft !== 69 && ft !== 73 && ft !== 91 && ft !== 103 && ft !== T && ft !== 666 ? Q(E, m) : (E.state = null, ft === T ? Q(E, -3) : f) : m;
      }, r.deflateSetDictionary = function(E, ft) {
        var U, et, X, rt, wt, kt, dt, Pt, qt = ft.length;
        if (!E || !E.state || (rt = (U = E.state).wrap) === 2 || rt === 1 && U.status !== A || U.lookahead) return m;
        for (rt === 1 && (E.adler = l(E.adler, ft, qt, 0)), U.wrap = 0, qt >= U.w_size && (rt === 0 && (ct(U.head), U.strstart = 0, U.block_start = 0, U.insert = 0), Pt = new o.Buf8(U.w_size), o.arraySet(Pt, ft, qt - U.w_size, U.w_size, 0), ft = Pt, qt = U.w_size), wt = E.avail_in, kt = E.next_in, dt = E.input, E.avail_in = qt, E.next_in = 0, E.input = ft, st(U); U.lookahead >= M; ) {
          for (et = U.strstart, X = U.lookahead - (M - 1); U.ins_h = (U.ins_h << U.hash_shift ^ U.window[et + M - 1]) & U.hash_mask, U.prev[et & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = et, et++, --X; ) ;
          U.strstart = et, U.lookahead = M - 1, st(U);
        }
        return U.strstart += U.lookahead, U.block_start = U.strstart, U.insert = U.lookahead, U.lookahead = 0, U.match_length = U.prev_length = M - 1, U.match_available = 0, E.next_in = kt, E.input = dt, E.avail_in = wt, U.wrap = rt, f;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, r) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, r) {
      i.exports = function(s, o) {
        var a, l, h, u, d, p, f, m, b, x, y, v, k, C, I, q, O, F, M, j, P, A, T, _, Z;
        a = s.state, l = s.next_in, _ = s.input, h = l + (s.avail_in - 5), u = s.next_out, Z = s.output, d = u - (o - s.avail_out), p = u + (s.avail_out - 257), f = a.dmax, m = a.wsize, b = a.whave, x = a.wnext, y = a.window, v = a.hold, k = a.bits, C = a.lencode, I = a.distcode, q = (1 << a.lenbits) - 1, O = (1 << a.distbits) - 1;
        t: do {
          k < 15 && (v += _[l++] << k, k += 8, v += _[l++] << k, k += 8), F = C[v & q];
          e: for (; ; ) {
            if (v >>>= M = F >>> 24, k -= M, (M = F >>> 16 & 255) === 0) Z[u++] = 65535 & F;
            else {
              if (!(16 & M)) {
                if (!(64 & M)) {
                  F = C[(65535 & F) + (v & (1 << M) - 1)];
                  continue e;
                }
                if (32 & M) {
                  a.mode = 12;
                  break t;
                }
                s.msg = "invalid literal/length code", a.mode = 30;
                break t;
              }
              j = 65535 & F, (M &= 15) && (k < M && (v += _[l++] << k, k += 8), j += v & (1 << M) - 1, v >>>= M, k -= M), k < 15 && (v += _[l++] << k, k += 8, v += _[l++] << k, k += 8), F = I[v & O];
              n: for (; ; ) {
                if (v >>>= M = F >>> 24, k -= M, !(16 & (M = F >>> 16 & 255))) {
                  if (!(64 & M)) {
                    F = I[(65535 & F) + (v & (1 << M) - 1)];
                    continue n;
                  }
                  s.msg = "invalid distance code", a.mode = 30;
                  break t;
                }
                if (P = 65535 & F, k < (M &= 15) && (v += _[l++] << k, (k += 8) < M && (v += _[l++] << k, k += 8)), f < (P += v & (1 << M) - 1)) {
                  s.msg = "invalid distance too far back", a.mode = 30;
                  break t;
                }
                if (v >>>= M, k -= M, (M = u - d) < P) {
                  if (b < (M = P - M) && a.sane) {
                    s.msg = "invalid distance too far back", a.mode = 30;
                    break t;
                  }
                  if (T = y, (A = 0) === x) {
                    if (A += m - M, M < j) {
                      for (j -= M; Z[u++] = y[A++], --M; ) ;
                      A = u - P, T = Z;
                    }
                  } else if (x < M) {
                    if (A += m + x - M, (M -= x) < j) {
                      for (j -= M; Z[u++] = y[A++], --M; ) ;
                      if (A = 0, x < j) {
                        for (j -= M = x; Z[u++] = y[A++], --M; ) ;
                        A = u - P, T = Z;
                      }
                    }
                  } else if (A += x - M, M < j) {
                    for (j -= M; Z[u++] = y[A++], --M; ) ;
                    A = u - P, T = Z;
                  }
                  for (; 2 < j; ) Z[u++] = T[A++], Z[u++] = T[A++], Z[u++] = T[A++], j -= 3;
                  j && (Z[u++] = T[A++], 1 < j && (Z[u++] = T[A++]));
                } else {
                  for (A = u - P; Z[u++] = Z[A++], Z[u++] = Z[A++], Z[u++] = Z[A++], 2 < (j -= 3); ) ;
                  j && (Z[u++] = Z[A++], 1 < j && (Z[u++] = Z[A++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < h && u < p);
        l -= j = k >> 3, v &= (1 << (k -= j << 3)) - 1, s.next_in = l, s.next_out = u, s.avail_in = l < h ? h - l + 5 : 5 - (l - h), s.avail_out = u < p ? p - u + 257 : 257 - (u - p), a.hold = v, a.bits = k;
      };
    }, {}], 49: [function(e, i, r) {
      var s = e("../utils/common"), o = e("./adler32"), a = e("./crc32"), l = e("./inffast"), h = e("./inftrees"), u = 1, d = 2, p = 0, f = -2, m = 1, b = 852, x = 592;
      function y(A) {
        return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((65280 & A) << 8) + ((255 & A) << 24);
      }
      function v() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function k(A) {
        var T;
        return A && A.state ? (T = A.state, A.total_in = A.total_out = T.total = 0, A.msg = "", T.wrap && (A.adler = 1 & T.wrap), T.mode = m, T.last = 0, T.havedict = 0, T.dmax = 32768, T.head = null, T.hold = 0, T.bits = 0, T.lencode = T.lendyn = new s.Buf32(b), T.distcode = T.distdyn = new s.Buf32(x), T.sane = 1, T.back = -1, p) : f;
      }
      function C(A) {
        var T;
        return A && A.state ? ((T = A.state).wsize = 0, T.whave = 0, T.wnext = 0, k(A)) : f;
      }
      function I(A, T) {
        var _, Z;
        return A && A.state ? (Z = A.state, T < 0 ? (_ = 0, T = -T) : (_ = 1 + (T >> 4), T < 48 && (T &= 15)), T && (T < 8 || 15 < T) ? f : (Z.window !== null && Z.wbits !== T && (Z.window = null), Z.wrap = _, Z.wbits = T, C(A))) : f;
      }
      function q(A, T) {
        var _, Z;
        return A ? (Z = new v(), (A.state = Z).window = null, (_ = I(A, T)) !== p && (A.state = null), _) : f;
      }
      var O, F, M = !0;
      function j(A) {
        if (M) {
          var T;
          for (O = new s.Buf32(512), F = new s.Buf32(32), T = 0; T < 144; ) A.lens[T++] = 8;
          for (; T < 256; ) A.lens[T++] = 9;
          for (; T < 280; ) A.lens[T++] = 7;
          for (; T < 288; ) A.lens[T++] = 8;
          for (h(u, A.lens, 0, 288, O, 0, A.work, { bits: 9 }), T = 0; T < 32; ) A.lens[T++] = 5;
          h(d, A.lens, 0, 32, F, 0, A.work, { bits: 5 }), M = !1;
        }
        A.lencode = O, A.lenbits = 9, A.distcode = F, A.distbits = 5;
      }
      function P(A, T, _, Z) {
        var V, R = A.state;
        return R.window === null && (R.wsize = 1 << R.wbits, R.wnext = 0, R.whave = 0, R.window = new s.Buf8(R.wsize)), Z >= R.wsize ? (s.arraySet(R.window, T, _ - R.wsize, R.wsize, 0), R.wnext = 0, R.whave = R.wsize) : (Z < (V = R.wsize - R.wnext) && (V = Z), s.arraySet(R.window, T, _ - Z, V, R.wnext), (Z -= V) ? (s.arraySet(R.window, T, _ - Z, Z, 0), R.wnext = Z, R.whave = R.wsize) : (R.wnext += V, R.wnext === R.wsize && (R.wnext = 0), R.whave < R.wsize && (R.whave += V))), 0;
      }
      r.inflateReset = C, r.inflateReset2 = I, r.inflateResetKeep = k, r.inflateInit = function(A) {
        return q(A, 15);
      }, r.inflateInit2 = q, r.inflate = function(A, T) {
        var _, Z, V, R, Q, H, ct, nt, N, z, G, Y, st, vt, mt, _t, Bt, Rt, te, Xt, E, ft, U, et, X = 0, rt = new s.Buf8(4), wt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0) return f;
        (_ = A.state).mode === 12 && (_.mode = 13), Q = A.next_out, V = A.output, ct = A.avail_out, R = A.next_in, Z = A.input, H = A.avail_in, nt = _.hold, N = _.bits, z = H, G = ct, ft = p;
        t: for (; ; ) switch (_.mode) {
          case m:
            if (_.wrap === 0) {
              _.mode = 13;
              break;
            }
            for (; N < 16; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            if (2 & _.wrap && nt === 35615) {
              rt[_.check = 0] = 255 & nt, rt[1] = nt >>> 8 & 255, _.check = a(_.check, rt, 2, 0), N = nt = 0, _.mode = 2;
              break;
            }
            if (_.flags = 0, _.head && (_.head.done = !1), !(1 & _.wrap) || (((255 & nt) << 8) + (nt >> 8)) % 31) {
              A.msg = "incorrect header check", _.mode = 30;
              break;
            }
            if ((15 & nt) != 8) {
              A.msg = "unknown compression method", _.mode = 30;
              break;
            }
            if (N -= 4, E = 8 + (15 & (nt >>>= 4)), _.wbits === 0) _.wbits = E;
            else if (E > _.wbits) {
              A.msg = "invalid window size", _.mode = 30;
              break;
            }
            _.dmax = 1 << E, A.adler = _.check = 1, _.mode = 512 & nt ? 10 : 12, N = nt = 0;
            break;
          case 2:
            for (; N < 16; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            if (_.flags = nt, (255 & _.flags) != 8) {
              A.msg = "unknown compression method", _.mode = 30;
              break;
            }
            if (57344 & _.flags) {
              A.msg = "unknown header flags set", _.mode = 30;
              break;
            }
            _.head && (_.head.text = nt >> 8 & 1), 512 & _.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, _.check = a(_.check, rt, 2, 0)), N = nt = 0, _.mode = 3;
          case 3:
            for (; N < 32; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            _.head && (_.head.time = nt), 512 & _.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, rt[2] = nt >>> 16 & 255, rt[3] = nt >>> 24 & 255, _.check = a(_.check, rt, 4, 0)), N = nt = 0, _.mode = 4;
          case 4:
            for (; N < 16; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            _.head && (_.head.xflags = 255 & nt, _.head.os = nt >> 8), 512 & _.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, _.check = a(_.check, rt, 2, 0)), N = nt = 0, _.mode = 5;
          case 5:
            if (1024 & _.flags) {
              for (; N < 16; ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              _.length = nt, _.head && (_.head.extra_len = nt), 512 & _.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, _.check = a(_.check, rt, 2, 0)), N = nt = 0;
            } else _.head && (_.head.extra = null);
            _.mode = 6;
          case 6:
            if (1024 & _.flags && (H < (Y = _.length) && (Y = H), Y && (_.head && (E = _.head.extra_len - _.length, _.head.extra || (_.head.extra = new Array(_.head.extra_len)), s.arraySet(_.head.extra, Z, R, Y, E)), 512 & _.flags && (_.check = a(_.check, Z, Y, R)), H -= Y, R += Y, _.length -= Y), _.length)) break t;
            _.length = 0, _.mode = 7;
          case 7:
            if (2048 & _.flags) {
              if (H === 0) break t;
              for (Y = 0; E = Z[R + Y++], _.head && E && _.length < 65536 && (_.head.name += String.fromCharCode(E)), E && Y < H; ) ;
              if (512 & _.flags && (_.check = a(_.check, Z, Y, R)), H -= Y, R += Y, E) break t;
            } else _.head && (_.head.name = null);
            _.length = 0, _.mode = 8;
          case 8:
            if (4096 & _.flags) {
              if (H === 0) break t;
              for (Y = 0; E = Z[R + Y++], _.head && E && _.length < 65536 && (_.head.comment += String.fromCharCode(E)), E && Y < H; ) ;
              if (512 & _.flags && (_.check = a(_.check, Z, Y, R)), H -= Y, R += Y, E) break t;
            } else _.head && (_.head.comment = null);
            _.mode = 9;
          case 9:
            if (512 & _.flags) {
              for (; N < 16; ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              if (nt !== (65535 & _.check)) {
                A.msg = "header crc mismatch", _.mode = 30;
                break;
              }
              N = nt = 0;
            }
            _.head && (_.head.hcrc = _.flags >> 9 & 1, _.head.done = !0), A.adler = _.check = 0, _.mode = 12;
            break;
          case 10:
            for (; N < 32; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            A.adler = _.check = y(nt), N = nt = 0, _.mode = 11;
          case 11:
            if (_.havedict === 0) return A.next_out = Q, A.avail_out = ct, A.next_in = R, A.avail_in = H, _.hold = nt, _.bits = N, 2;
            A.adler = _.check = 1, _.mode = 12;
          case 12:
            if (T === 5 || T === 6) break t;
          case 13:
            if (_.last) {
              nt >>>= 7 & N, N -= 7 & N, _.mode = 27;
              break;
            }
            for (; N < 3; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            switch (_.last = 1 & nt, N -= 1, 3 & (nt >>>= 1)) {
              case 0:
                _.mode = 14;
                break;
              case 1:
                if (j(_), _.mode = 20, T !== 6) break;
                nt >>>= 2, N -= 2;
                break t;
              case 2:
                _.mode = 17;
                break;
              case 3:
                A.msg = "invalid block type", _.mode = 30;
            }
            nt >>>= 2, N -= 2;
            break;
          case 14:
            for (nt >>>= 7 & N, N -= 7 & N; N < 32; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            if ((65535 & nt) != (nt >>> 16 ^ 65535)) {
              A.msg = "invalid stored block lengths", _.mode = 30;
              break;
            }
            if (_.length = 65535 & nt, N = nt = 0, _.mode = 15, T === 6) break t;
          case 15:
            _.mode = 16;
          case 16:
            if (Y = _.length) {
              if (H < Y && (Y = H), ct < Y && (Y = ct), Y === 0) break t;
              s.arraySet(V, Z, R, Y, Q), H -= Y, R += Y, ct -= Y, Q += Y, _.length -= Y;
              break;
            }
            _.mode = 12;
            break;
          case 17:
            for (; N < 14; ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            if (_.nlen = 257 + (31 & nt), nt >>>= 5, N -= 5, _.ndist = 1 + (31 & nt), nt >>>= 5, N -= 5, _.ncode = 4 + (15 & nt), nt >>>= 4, N -= 4, 286 < _.nlen || 30 < _.ndist) {
              A.msg = "too many length or distance symbols", _.mode = 30;
              break;
            }
            _.have = 0, _.mode = 18;
          case 18:
            for (; _.have < _.ncode; ) {
              for (; N < 3; ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              _.lens[wt[_.have++]] = 7 & nt, nt >>>= 3, N -= 3;
            }
            for (; _.have < 19; ) _.lens[wt[_.have++]] = 0;
            if (_.lencode = _.lendyn, _.lenbits = 7, U = { bits: _.lenbits }, ft = h(0, _.lens, 0, 19, _.lencode, 0, _.work, U), _.lenbits = U.bits, ft) {
              A.msg = "invalid code lengths set", _.mode = 30;
              break;
            }
            _.have = 0, _.mode = 19;
          case 19:
            for (; _.have < _.nlen + _.ndist; ) {
              for (; _t = (X = _.lencode[nt & (1 << _.lenbits) - 1]) >>> 16 & 255, Bt = 65535 & X, !((mt = X >>> 24) <= N); ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              if (Bt < 16) nt >>>= mt, N -= mt, _.lens[_.have++] = Bt;
              else {
                if (Bt === 16) {
                  for (et = mt + 2; N < et; ) {
                    if (H === 0) break t;
                    H--, nt += Z[R++] << N, N += 8;
                  }
                  if (nt >>>= mt, N -= mt, _.have === 0) {
                    A.msg = "invalid bit length repeat", _.mode = 30;
                    break;
                  }
                  E = _.lens[_.have - 1], Y = 3 + (3 & nt), nt >>>= 2, N -= 2;
                } else if (Bt === 17) {
                  for (et = mt + 3; N < et; ) {
                    if (H === 0) break t;
                    H--, nt += Z[R++] << N, N += 8;
                  }
                  N -= mt, E = 0, Y = 3 + (7 & (nt >>>= mt)), nt >>>= 3, N -= 3;
                } else {
                  for (et = mt + 7; N < et; ) {
                    if (H === 0) break t;
                    H--, nt += Z[R++] << N, N += 8;
                  }
                  N -= mt, E = 0, Y = 11 + (127 & (nt >>>= mt)), nt >>>= 7, N -= 7;
                }
                if (_.have + Y > _.nlen + _.ndist) {
                  A.msg = "invalid bit length repeat", _.mode = 30;
                  break;
                }
                for (; Y--; ) _.lens[_.have++] = E;
              }
            }
            if (_.mode === 30) break;
            if (_.lens[256] === 0) {
              A.msg = "invalid code -- missing end-of-block", _.mode = 30;
              break;
            }
            if (_.lenbits = 9, U = { bits: _.lenbits }, ft = h(u, _.lens, 0, _.nlen, _.lencode, 0, _.work, U), _.lenbits = U.bits, ft) {
              A.msg = "invalid literal/lengths set", _.mode = 30;
              break;
            }
            if (_.distbits = 6, _.distcode = _.distdyn, U = { bits: _.distbits }, ft = h(d, _.lens, _.nlen, _.ndist, _.distcode, 0, _.work, U), _.distbits = U.bits, ft) {
              A.msg = "invalid distances set", _.mode = 30;
              break;
            }
            if (_.mode = 20, T === 6) break t;
          case 20:
            _.mode = 21;
          case 21:
            if (6 <= H && 258 <= ct) {
              A.next_out = Q, A.avail_out = ct, A.next_in = R, A.avail_in = H, _.hold = nt, _.bits = N, l(A, G), Q = A.next_out, V = A.output, ct = A.avail_out, R = A.next_in, Z = A.input, H = A.avail_in, nt = _.hold, N = _.bits, _.mode === 12 && (_.back = -1);
              break;
            }
            for (_.back = 0; _t = (X = _.lencode[nt & (1 << _.lenbits) - 1]) >>> 16 & 255, Bt = 65535 & X, !((mt = X >>> 24) <= N); ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            if (_t && !(240 & _t)) {
              for (Rt = mt, te = _t, Xt = Bt; _t = (X = _.lencode[Xt + ((nt & (1 << Rt + te) - 1) >> Rt)]) >>> 16 & 255, Bt = 65535 & X, !(Rt + (mt = X >>> 24) <= N); ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              nt >>>= Rt, N -= Rt, _.back += Rt;
            }
            if (nt >>>= mt, N -= mt, _.back += mt, _.length = Bt, _t === 0) {
              _.mode = 26;
              break;
            }
            if (32 & _t) {
              _.back = -1, _.mode = 12;
              break;
            }
            if (64 & _t) {
              A.msg = "invalid literal/length code", _.mode = 30;
              break;
            }
            _.extra = 15 & _t, _.mode = 22;
          case 22:
            if (_.extra) {
              for (et = _.extra; N < et; ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              _.length += nt & (1 << _.extra) - 1, nt >>>= _.extra, N -= _.extra, _.back += _.extra;
            }
            _.was = _.length, _.mode = 23;
          case 23:
            for (; _t = (X = _.distcode[nt & (1 << _.distbits) - 1]) >>> 16 & 255, Bt = 65535 & X, !((mt = X >>> 24) <= N); ) {
              if (H === 0) break t;
              H--, nt += Z[R++] << N, N += 8;
            }
            if (!(240 & _t)) {
              for (Rt = mt, te = _t, Xt = Bt; _t = (X = _.distcode[Xt + ((nt & (1 << Rt + te) - 1) >> Rt)]) >>> 16 & 255, Bt = 65535 & X, !(Rt + (mt = X >>> 24) <= N); ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              nt >>>= Rt, N -= Rt, _.back += Rt;
            }
            if (nt >>>= mt, N -= mt, _.back += mt, 64 & _t) {
              A.msg = "invalid distance code", _.mode = 30;
              break;
            }
            _.offset = Bt, _.extra = 15 & _t, _.mode = 24;
          case 24:
            if (_.extra) {
              for (et = _.extra; N < et; ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              _.offset += nt & (1 << _.extra) - 1, nt >>>= _.extra, N -= _.extra, _.back += _.extra;
            }
            if (_.offset > _.dmax) {
              A.msg = "invalid distance too far back", _.mode = 30;
              break;
            }
            _.mode = 25;
          case 25:
            if (ct === 0) break t;
            if (Y = G - ct, _.offset > Y) {
              if ((Y = _.offset - Y) > _.whave && _.sane) {
                A.msg = "invalid distance too far back", _.mode = 30;
                break;
              }
              st = Y > _.wnext ? (Y -= _.wnext, _.wsize - Y) : _.wnext - Y, Y > _.length && (Y = _.length), vt = _.window;
            } else vt = V, st = Q - _.offset, Y = _.length;
            for (ct < Y && (Y = ct), ct -= Y, _.length -= Y; V[Q++] = vt[st++], --Y; ) ;
            _.length === 0 && (_.mode = 21);
            break;
          case 26:
            if (ct === 0) break t;
            V[Q++] = _.length, ct--, _.mode = 21;
            break;
          case 27:
            if (_.wrap) {
              for (; N < 32; ) {
                if (H === 0) break t;
                H--, nt |= Z[R++] << N, N += 8;
              }
              if (G -= ct, A.total_out += G, _.total += G, G && (A.adler = _.check = _.flags ? a(_.check, V, G, Q - G) : o(_.check, V, G, Q - G)), G = ct, (_.flags ? nt : y(nt)) !== _.check) {
                A.msg = "incorrect data check", _.mode = 30;
                break;
              }
              N = nt = 0;
            }
            _.mode = 28;
          case 28:
            if (_.wrap && _.flags) {
              for (; N < 32; ) {
                if (H === 0) break t;
                H--, nt += Z[R++] << N, N += 8;
              }
              if (nt !== (4294967295 & _.total)) {
                A.msg = "incorrect length check", _.mode = 30;
                break;
              }
              N = nt = 0;
            }
            _.mode = 29;
          case 29:
            ft = 1;
            break t;
          case 30:
            ft = -3;
            break t;
          case 31:
            return -4;
          case 32:
          default:
            return f;
        }
        return A.next_out = Q, A.avail_out = ct, A.next_in = R, A.avail_in = H, _.hold = nt, _.bits = N, (_.wsize || G !== A.avail_out && _.mode < 30 && (_.mode < 27 || T !== 4)) && P(A, A.output, A.next_out, G - A.avail_out) ? (_.mode = 31, -4) : (z -= A.avail_in, G -= A.avail_out, A.total_in += z, A.total_out += G, _.total += G, _.wrap && G && (A.adler = _.check = _.flags ? a(_.check, V, G, A.next_out - G) : o(_.check, V, G, A.next_out - G)), A.data_type = _.bits + (_.last ? 64 : 0) + (_.mode === 12 ? 128 : 0) + (_.mode === 20 || _.mode === 15 ? 256 : 0), (z == 0 && G === 0 || T === 4) && ft === p && (ft = -5), ft);
      }, r.inflateEnd = function(A) {
        if (!A || !A.state) return f;
        var T = A.state;
        return T.window && (T.window = null), A.state = null, p;
      }, r.inflateGetHeader = function(A, T) {
        var _;
        return A && A.state && 2 & (_ = A.state).wrap ? ((_.head = T).done = !1, p) : f;
      }, r.inflateSetDictionary = function(A, T) {
        var _, Z = T.length;
        return A && A.state ? (_ = A.state).wrap !== 0 && _.mode !== 11 ? f : _.mode === 11 && o(1, T, Z, 0) !== _.check ? -3 : P(A, T, Z, Z) ? (_.mode = 31, -4) : (_.havedict = 1, p) : f;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, r) {
      var s = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(u, d, p, f, m, b, x, y) {
        var v, k, C, I, q, O, F, M, j, P = y.bits, A = 0, T = 0, _ = 0, Z = 0, V = 0, R = 0, Q = 0, H = 0, ct = 0, nt = 0, N = null, z = 0, G = new s.Buf16(16), Y = new s.Buf16(16), st = null, vt = 0;
        for (A = 0; A <= 15; A++) G[A] = 0;
        for (T = 0; T < f; T++) G[d[p + T]]++;
        for (V = P, Z = 15; 1 <= Z && G[Z] === 0; Z--) ;
        if (Z < V && (V = Z), Z === 0) return m[b++] = 20971520, m[b++] = 20971520, y.bits = 1, 0;
        for (_ = 1; _ < Z && G[_] === 0; _++) ;
        for (V < _ && (V = _), A = H = 1; A <= 15; A++) if (H <<= 1, (H -= G[A]) < 0) return -1;
        if (0 < H && (u === 0 || Z !== 1)) return -1;
        for (Y[1] = 0, A = 1; A < 15; A++) Y[A + 1] = Y[A] + G[A];
        for (T = 0; T < f; T++) d[p + T] !== 0 && (x[Y[d[p + T]]++] = T);
        if (O = u === 0 ? (N = st = x, 19) : u === 1 ? (N = o, z -= 257, st = a, vt -= 257, 256) : (N = l, st = h, -1), A = _, q = b, Q = T = nt = 0, C = -1, I = (ct = 1 << (R = V)) - 1, u === 1 && 852 < ct || u === 2 && 592 < ct) return 1;
        for (; ; ) {
          for (F = A - Q, j = x[T] < O ? (M = 0, x[T]) : x[T] > O ? (M = st[vt + x[T]], N[z + x[T]]) : (M = 96, 0), v = 1 << A - Q, _ = k = 1 << R; m[q + (nt >> Q) + (k -= v)] = F << 24 | M << 16 | j | 0, k !== 0; ) ;
          for (v = 1 << A - 1; nt & v; ) v >>= 1;
          if (v !== 0 ? (nt &= v - 1, nt += v) : nt = 0, T++, --G[A] == 0) {
            if (A === Z) break;
            A = d[p + x[T]];
          }
          if (V < A && (nt & I) !== C) {
            for (Q === 0 && (Q = V), q += _, H = 1 << (R = A - Q); R + Q < Z && !((H -= G[R + Q]) <= 0); ) R++, H <<= 1;
            if (ct += 1 << R, u === 1 && 852 < ct || u === 2 && 592 < ct) return 1;
            m[C = nt & I] = V << 24 | R << 16 | q - b | 0;
          }
        }
        return nt !== 0 && (m[q + nt] = A - Q << 24 | 64 << 16 | 0), y.bits = V, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, r) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, r) {
      var s = e("../utils/common"), o = 0, a = 1;
      function l(X) {
        for (var rt = X.length; 0 <= --rt; ) X[rt] = 0;
      }
      var h = 0, u = 29, d = 256, p = d + 1 + u, f = 30, m = 19, b = 2 * p + 1, x = 15, y = 16, v = 7, k = 256, C = 16, I = 17, q = 18, O = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], F = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], M = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], P = new Array(2 * (p + 2));
      l(P);
      var A = new Array(2 * f);
      l(A);
      var T = new Array(512);
      l(T);
      var _ = new Array(256);
      l(_);
      var Z = new Array(u);
      l(Z);
      var V, R, Q, H = new Array(f);
      function ct(X, rt, wt, kt, dt) {
        this.static_tree = X, this.extra_bits = rt, this.extra_base = wt, this.elems = kt, this.max_length = dt, this.has_stree = X && X.length;
      }
      function nt(X, rt) {
        this.dyn_tree = X, this.max_code = 0, this.stat_desc = rt;
      }
      function N(X) {
        return X < 256 ? T[X] : T[256 + (X >>> 7)];
      }
      function z(X, rt) {
        X.pending_buf[X.pending++] = 255 & rt, X.pending_buf[X.pending++] = rt >>> 8 & 255;
      }
      function G(X, rt, wt) {
        X.bi_valid > y - wt ? (X.bi_buf |= rt << X.bi_valid & 65535, z(X, X.bi_buf), X.bi_buf = rt >> y - X.bi_valid, X.bi_valid += wt - y) : (X.bi_buf |= rt << X.bi_valid & 65535, X.bi_valid += wt);
      }
      function Y(X, rt, wt) {
        G(X, wt[2 * rt], wt[2 * rt + 1]);
      }
      function st(X, rt) {
        for (var wt = 0; wt |= 1 & X, X >>>= 1, wt <<= 1, 0 < --rt; ) ;
        return wt >>> 1;
      }
      function vt(X, rt, wt) {
        var kt, dt, Pt = new Array(x + 1), qt = 0;
        for (kt = 1; kt <= x; kt++) Pt[kt] = qt = qt + wt[kt - 1] << 1;
        for (dt = 0; dt <= rt; dt++) {
          var Ft = X[2 * dt + 1];
          Ft !== 0 && (X[2 * dt] = st(Pt[Ft]++, Ft));
        }
      }
      function mt(X) {
        var rt;
        for (rt = 0; rt < p; rt++) X.dyn_ltree[2 * rt] = 0;
        for (rt = 0; rt < f; rt++) X.dyn_dtree[2 * rt] = 0;
        for (rt = 0; rt < m; rt++) X.bl_tree[2 * rt] = 0;
        X.dyn_ltree[2 * k] = 1, X.opt_len = X.static_len = 0, X.last_lit = X.matches = 0;
      }
      function _t(X) {
        8 < X.bi_valid ? z(X, X.bi_buf) : 0 < X.bi_valid && (X.pending_buf[X.pending++] = X.bi_buf), X.bi_buf = 0, X.bi_valid = 0;
      }
      function Bt(X, rt, wt, kt) {
        var dt = 2 * rt, Pt = 2 * wt;
        return X[dt] < X[Pt] || X[dt] === X[Pt] && kt[rt] <= kt[wt];
      }
      function Rt(X, rt, wt) {
        for (var kt = X.heap[wt], dt = wt << 1; dt <= X.heap_len && (dt < X.heap_len && Bt(rt, X.heap[dt + 1], X.heap[dt], X.depth) && dt++, !Bt(rt, kt, X.heap[dt], X.depth)); ) X.heap[wt] = X.heap[dt], wt = dt, dt <<= 1;
        X.heap[wt] = kt;
      }
      function te(X, rt, wt) {
        var kt, dt, Pt, qt, Ft = 0;
        if (X.last_lit !== 0) for (; kt = X.pending_buf[X.d_buf + 2 * Ft] << 8 | X.pending_buf[X.d_buf + 2 * Ft + 1], dt = X.pending_buf[X.l_buf + Ft], Ft++, kt === 0 ? Y(X, dt, rt) : (Y(X, (Pt = _[dt]) + d + 1, rt), (qt = O[Pt]) !== 0 && G(X, dt -= Z[Pt], qt), Y(X, Pt = N(--kt), wt), (qt = F[Pt]) !== 0 && G(X, kt -= H[Pt], qt)), Ft < X.last_lit; ) ;
        Y(X, k, rt);
      }
      function Xt(X, rt) {
        var wt, kt, dt, Pt = rt.dyn_tree, qt = rt.stat_desc.static_tree, Ft = rt.stat_desc.has_stree, Vt = rt.stat_desc.elems, ne = -1;
        for (X.heap_len = 0, X.heap_max = b, wt = 0; wt < Vt; wt++) Pt[2 * wt] !== 0 ? (X.heap[++X.heap_len] = ne = wt, X.depth[wt] = 0) : Pt[2 * wt + 1] = 0;
        for (; X.heap_len < 2; ) Pt[2 * (dt = X.heap[++X.heap_len] = ne < 2 ? ++ne : 0)] = 1, X.depth[dt] = 0, X.opt_len--, Ft && (X.static_len -= qt[2 * dt + 1]);
        for (rt.max_code = ne, wt = X.heap_len >> 1; 1 <= wt; wt--) Rt(X, Pt, wt);
        for (dt = Vt; wt = X.heap[1], X.heap[1] = X.heap[X.heap_len--], Rt(X, Pt, 1), kt = X.heap[1], X.heap[--X.heap_max] = wt, X.heap[--X.heap_max] = kt, Pt[2 * dt] = Pt[2 * wt] + Pt[2 * kt], X.depth[dt] = (X.depth[wt] >= X.depth[kt] ? X.depth[wt] : X.depth[kt]) + 1, Pt[2 * wt + 1] = Pt[2 * kt + 1] = dt, X.heap[1] = dt++, Rt(X, Pt, 1), 2 <= X.heap_len; ) ;
        X.heap[--X.heap_max] = X.heap[1], function(ie, ue) {
          var we, Qt, Ke, ht, jt, Kt, Ht = ue.dyn_tree, Ae = ue.max_code, Jt = ue.stat_desc.static_tree, Yt = ue.stat_desc.has_stree, le = ue.stat_desc.extra_bits, Xe = ue.stat_desc.extra_base, xn = ue.stat_desc.max_length, Ge = 0;
          for (ht = 0; ht <= x; ht++) ie.bl_count[ht] = 0;
          for (Ht[2 * ie.heap[ie.heap_max] + 1] = 0, we = ie.heap_max + 1; we < b; we++) xn < (ht = Ht[2 * Ht[2 * (Qt = ie.heap[we]) + 1] + 1] + 1) && (ht = xn, Ge++), Ht[2 * Qt + 1] = ht, Ae < Qt || (ie.bl_count[ht]++, jt = 0, Xe <= Qt && (jt = le[Qt - Xe]), Kt = Ht[2 * Qt], ie.opt_len += Kt * (ht + jt), Yt && (ie.static_len += Kt * (Jt[2 * Qt + 1] + jt)));
          if (Ge !== 0) {
            do {
              for (ht = xn - 1; ie.bl_count[ht] === 0; ) ht--;
              ie.bl_count[ht]--, ie.bl_count[ht + 1] += 2, ie.bl_count[xn]--, Ge -= 2;
            } while (0 < Ge);
            for (ht = xn; ht !== 0; ht--) for (Qt = ie.bl_count[ht]; Qt !== 0; ) Ae < (Ke = ie.heap[--we]) || (Ht[2 * Ke + 1] !== ht && (ie.opt_len += (ht - Ht[2 * Ke + 1]) * Ht[2 * Ke], Ht[2 * Ke + 1] = ht), Qt--);
          }
        }(X, rt), vt(Pt, ne, X.bl_count);
      }
      function E(X, rt, wt) {
        var kt, dt, Pt = -1, qt = rt[1], Ft = 0, Vt = 7, ne = 4;
        for (qt === 0 && (Vt = 138, ne = 3), rt[2 * (wt + 1) + 1] = 65535, kt = 0; kt <= wt; kt++) dt = qt, qt = rt[2 * (kt + 1) + 1], ++Ft < Vt && dt === qt || (Ft < ne ? X.bl_tree[2 * dt] += Ft : dt !== 0 ? (dt !== Pt && X.bl_tree[2 * dt]++, X.bl_tree[2 * C]++) : Ft <= 10 ? X.bl_tree[2 * I]++ : X.bl_tree[2 * q]++, Pt = dt, ne = (Ft = 0) === qt ? (Vt = 138, 3) : dt === qt ? (Vt = 6, 3) : (Vt = 7, 4));
      }
      function ft(X, rt, wt) {
        var kt, dt, Pt = -1, qt = rt[1], Ft = 0, Vt = 7, ne = 4;
        for (qt === 0 && (Vt = 138, ne = 3), kt = 0; kt <= wt; kt++) if (dt = qt, qt = rt[2 * (kt + 1) + 1], !(++Ft < Vt && dt === qt)) {
          if (Ft < ne) for (; Y(X, dt, X.bl_tree), --Ft != 0; ) ;
          else dt !== 0 ? (dt !== Pt && (Y(X, dt, X.bl_tree), Ft--), Y(X, C, X.bl_tree), G(X, Ft - 3, 2)) : Ft <= 10 ? (Y(X, I, X.bl_tree), G(X, Ft - 3, 3)) : (Y(X, q, X.bl_tree), G(X, Ft - 11, 7));
          Pt = dt, ne = (Ft = 0) === qt ? (Vt = 138, 3) : dt === qt ? (Vt = 6, 3) : (Vt = 7, 4);
        }
      }
      l(H);
      var U = !1;
      function et(X, rt, wt, kt) {
        G(X, (h << 1) + (kt ? 1 : 0), 3), function(dt, Pt, qt, Ft) {
          _t(dt), z(dt, qt), z(dt, ~qt), s.arraySet(dt.pending_buf, dt.window, Pt, qt, dt.pending), dt.pending += qt;
        }(X, rt, wt);
      }
      r._tr_init = function(X) {
        U || (function() {
          var rt, wt, kt, dt, Pt, qt = new Array(x + 1);
          for (dt = kt = 0; dt < u - 1; dt++) for (Z[dt] = kt, rt = 0; rt < 1 << O[dt]; rt++) _[kt++] = dt;
          for (_[kt - 1] = dt, dt = Pt = 0; dt < 16; dt++) for (H[dt] = Pt, rt = 0; rt < 1 << F[dt]; rt++) T[Pt++] = dt;
          for (Pt >>= 7; dt < f; dt++) for (H[dt] = Pt << 7, rt = 0; rt < 1 << F[dt] - 7; rt++) T[256 + Pt++] = dt;
          for (wt = 0; wt <= x; wt++) qt[wt] = 0;
          for (rt = 0; rt <= 143; ) P[2 * rt + 1] = 8, rt++, qt[8]++;
          for (; rt <= 255; ) P[2 * rt + 1] = 9, rt++, qt[9]++;
          for (; rt <= 279; ) P[2 * rt + 1] = 7, rt++, qt[7]++;
          for (; rt <= 287; ) P[2 * rt + 1] = 8, rt++, qt[8]++;
          for (vt(P, p + 1, qt), rt = 0; rt < f; rt++) A[2 * rt + 1] = 5, A[2 * rt] = st(rt, 5);
          V = new ct(P, O, d + 1, p, x), R = new ct(A, F, 0, f, x), Q = new ct(new Array(0), M, 0, m, v);
        }(), U = !0), X.l_desc = new nt(X.dyn_ltree, V), X.d_desc = new nt(X.dyn_dtree, R), X.bl_desc = new nt(X.bl_tree, Q), X.bi_buf = 0, X.bi_valid = 0, mt(X);
      }, r._tr_stored_block = et, r._tr_flush_block = function(X, rt, wt, kt) {
        var dt, Pt, qt = 0;
        0 < X.level ? (X.strm.data_type === 2 && (X.strm.data_type = function(Ft) {
          var Vt, ne = 4093624447;
          for (Vt = 0; Vt <= 31; Vt++, ne >>>= 1) if (1 & ne && Ft.dyn_ltree[2 * Vt] !== 0) return o;
          if (Ft.dyn_ltree[18] !== 0 || Ft.dyn_ltree[20] !== 0 || Ft.dyn_ltree[26] !== 0) return a;
          for (Vt = 32; Vt < d; Vt++) if (Ft.dyn_ltree[2 * Vt] !== 0) return a;
          return o;
        }(X)), Xt(X, X.l_desc), Xt(X, X.d_desc), qt = function(Ft) {
          var Vt;
          for (E(Ft, Ft.dyn_ltree, Ft.l_desc.max_code), E(Ft, Ft.dyn_dtree, Ft.d_desc.max_code), Xt(Ft, Ft.bl_desc), Vt = m - 1; 3 <= Vt && Ft.bl_tree[2 * j[Vt] + 1] === 0; Vt--) ;
          return Ft.opt_len += 3 * (Vt + 1) + 5 + 5 + 4, Vt;
        }(X), dt = X.opt_len + 3 + 7 >>> 3, (Pt = X.static_len + 3 + 7 >>> 3) <= dt && (dt = Pt)) : dt = Pt = wt + 5, wt + 4 <= dt && rt !== -1 ? et(X, rt, wt, kt) : X.strategy === 4 || Pt === dt ? (G(X, 2 + (kt ? 1 : 0), 3), te(X, P, A)) : (G(X, 4 + (kt ? 1 : 0), 3), function(Ft, Vt, ne, ie) {
          var ue;
          for (G(Ft, Vt - 257, 5), G(Ft, ne - 1, 5), G(Ft, ie - 4, 4), ue = 0; ue < ie; ue++) G(Ft, Ft.bl_tree[2 * j[ue] + 1], 3);
          ft(Ft, Ft.dyn_ltree, Vt - 1), ft(Ft, Ft.dyn_dtree, ne - 1);
        }(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, qt + 1), te(X, X.dyn_ltree, X.dyn_dtree)), mt(X), kt && _t(X);
      }, r._tr_tally = function(X, rt, wt) {
        return X.pending_buf[X.d_buf + 2 * X.last_lit] = rt >>> 8 & 255, X.pending_buf[X.d_buf + 2 * X.last_lit + 1] = 255 & rt, X.pending_buf[X.l_buf + X.last_lit] = 255 & wt, X.last_lit++, rt === 0 ? X.dyn_ltree[2 * wt]++ : (X.matches++, rt--, X.dyn_ltree[2 * (_[wt] + d + 1)]++, X.dyn_dtree[2 * N(rt)]++), X.last_lit === X.lit_bufsize - 1;
      }, r._tr_align = function(X) {
        G(X, 2, 3), Y(X, k, P), function(rt) {
          rt.bi_valid === 16 ? (z(rt, rt.bi_buf), rt.bi_buf = 0, rt.bi_valid = 0) : 8 <= rt.bi_valid && (rt.pending_buf[rt.pending++] = 255 & rt.bi_buf, rt.bi_buf >>= 8, rt.bi_valid -= 8);
        }(X);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, r) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, r) {
      (function(s) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, h, u, d, p = 1, f = {}, m = !1, b = o.document, x = Object.getPrototypeOf && Object.getPrototypeOf(o);
            x = x && x.setTimeout ? x : o, l = {}.toString.call(o.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                v(C);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var C = !0, I = o.onmessage;
                return o.onmessage = function() {
                  C = !1;
                }, o.postMessage("", "*"), o.onmessage = I, C;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), function(C) {
              o.postMessage(d + C, "*");
            }) : o.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(C) {
              v(C.data);
            }, function(C) {
              u.port2.postMessage(C);
            }) : b && "onreadystatechange" in b.createElement("script") ? (h = b.documentElement, function(C) {
              var I = b.createElement("script");
              I.onreadystatechange = function() {
                v(C), I.onreadystatechange = null, h.removeChild(I), I = null;
              }, h.appendChild(I);
            }) : function(C) {
              setTimeout(v, 0, C);
            }, x.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var I = new Array(arguments.length - 1), q = 0; q < I.length; q++) I[q] = arguments[q + 1];
              var O = { callback: C, args: I };
              return f[p] = O, l(p), p++;
            }, x.clearImmediate = y;
          }
          function y(C) {
            delete f[C];
          }
          function v(C) {
            if (m) setTimeout(v, 0, C);
            else {
              var I = f[C];
              if (I) {
                m = !0;
                try {
                  (function(q) {
                    var O = q.callback, F = q.args;
                    switch (F.length) {
                      case 0:
                        O();
                        break;
                      case 1:
                        O(F[0]);
                        break;
                      case 2:
                        O(F[0], F[1]);
                        break;
                      case 3:
                        O(F[0], F[1], F[2]);
                        break;
                      default:
                        O.apply(a, F);
                    }
                  })(I);
                } finally {
                  y(C), m = !1;
                }
              }
            }
          }
          function k(C) {
            C.source === o && typeof C.data == "string" && C.data.indexOf(d) === 0 && v(+C.data.slice(d.length));
          }
        })(typeof self > "u" ? s === void 0 ? this : s : self);
      }).call(this, typeof co < "u" ? co : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jm);
var Uk = jm.exports;
const Wk = /* @__PURE__ */ Oc(Uk), Hk = {
  key: 0,
  class: "debug"
}, Gk = !1, Vk = /* @__PURE__ */ is({
  __name: "WordPress",
  setup(n) {
    const t = ["banding", "finish", "cutLength", "perPart", "rollLength", "surcharge", "machining", "stock", "custom"], e = (ht) => t.includes(ht), i = go(() => import("./FormulaPricing-CNFiat2l.js")), r = go(() => import("./ObjectViewer-CjFIJYjx.js")), s = "production", o = {}, a = {};
    let l;
    const h = {
      banding: null,
      finish: null
    };
    let u = null, d = [], p = null, f = {};
    const m = Ce(!1), b = Ce("manual"), x = Ce(""), y = Ce([]), v = Ce(null), k = Ce(!0), C = Ce(null), I = Ce(null), q = Ce(!1), O = Ce(null), F = sn(() => window.smartcutConfig.settings.units ?? "decimal");
    T2("calculator", () => O.value);
    const M = (ht) => {
      m.value && console.log("SmartCut -", ...ht);
    }, j = (ht) => {
      console.error(`SmartCut - ${ht}`);
    }, P = (ht = !1) => {
      q.value = !0, ["checkout", "intro_text", "offcuts", "banding_key"].forEach((Kt) => {
        const Ht = o[Kt];
        Ht && (Ht.style.display = "block");
      }), Ft() && (o.pricing_table.style.display = "table"), ht ? T(!0) : _(), R();
    }, A = (ht = !0, jt = !0) => {
      q.value = !1, ["checkout", "intro_text", "offcuts", "banding_key", "pricing_table"].forEach((Ht) => {
        const Ae = o[Ht];
        Ae && (Ae.style.display = "none");
      }), jt === !0 ? V() : jt === !1 && R(), ht ? T() : ht === !1 && _();
    }, T = (ht = !1) => {
      o.quantity.style.display = "inline-block", o.quantity.readOnly = ht;
    }, _ = () => {
      q.value !== !1 && (Q(1), o.quantity.style.display = "none", o.quantity.readOnly = !0);
    }, Z = (ht, jt) => {
      if (isNaN(jt)) throw new Error("Price must be a number");
      if (!e(ht)) return;
      const Ht = {
        custom: {
          visible: null,
          hidden: "smartcut-custom-price"
        },
        perPart: {
          hidden: "smartcut-per-part-price",
          visible: "per_part_price"
        },
        rollLength: {
          hidden: null,
          visible: "roll_length_price"
        },
        banding: {
          hidden: "smartcut-banding-price",
          visible: "banding_total_price"
        },
        finish: {
          hidden: "smartcut-finish-price",
          visible: "finish_total_price"
        },
        machining: {
          hidden: "smartcut-machining-price",
          visible: "machining_total_price"
        },
        surcharge: {
          hidden: "smartcut-cut-to-size-surcharge",
          visible: "surcharge_price"
        },
        cutLength: {
          hidden: "smartcut-cut-length-price",
          visible: "cut_length_price"
        },
        stock: {
          hidden: null,
          visible: "stock_total_price"
        }
      }[ht];
      Ht != null && Ht.hidden && a[Ht.hidden] && et(Ht.hidden, jt), Ht != null && Ht.visible && o[Ht.visible] && (o[Ht.visible].innerText = mt(jt));
    }, V = () => {
      if (!o.cart_button) {
        j("Cart button not found");
        return;
      }
      o.cart_button.disabled = !1;
    }, R = () => {
      if (q.value !== !1) {
        if (!o.cart_button) {
          j("Cart button not found");
          return;
        }
        o.cart_button.disabled = !0;
      }
    }, Q = (ht, jt = 0) => {
      if (!o.quantity) {
        j("Quantity field not found when trying to set");
        return;
      }
      o.quantity.value = ht.toFixed(jt);
    }, H = (ht) => {
      M(["setting variation price", ht]);
      const jt = document.querySelector(".woocommerce-variation-price .smartcut-price-selector");
      jt && (jt.innerText = mt(ht)), v.value.display_price = ht;
    }, ct = () => {
      if (!(window != null && window.smartcutConfig)) {
        j("SmartCut config not found");
        return;
      }
      const ht = window.smartcutConfig;
      l = ht.settings;
      const jt = te(gn(window, ["smartcutConfig", "banding_data"])), Kt = te(gn(window, ["smartcutConfig", "finish_data"])), Ht = {
        debug: l.debug,
        units: l.units,
        locale: ht.locale,
        decimalPlaces: 2,
        //saw
        stockType: l.stock_type,
        bladeWidth: l.blade_width,
        cutPreference: l.cut_preference,
        stackHeight: l.stack_height,
        stockSelection: l.stock_selection,
        stockGrain: l.stock_grain,
        minSpacing: l.min_spacing,
        maxParts: l.max_parts ?? null,
        orientationModel: l.orientation_model,
        minDimension: l.min_dimension,
        enable: {
          banding: !l.disable_banding,
          finish: !l.disable_finish,
          orientation: !l.disable_orientation,
          diagram: !l.hide_diagram,
          focus: !0,
          machining: l.enable_machining,
          csvImport: l.enable_import,
          click: !0,
          partName: !l.disable_part_name,
          progressNumber: l.pricing_strategy !== "part_area",
          imageUpload: l.enable_image_upload
        },
        colors: {
          partA: (l == null ? void 0 : l.part_a_color) ?? "#1d9bc4",
          partB: (l == null ? void 0 : l.part_b_color) ?? "#065d7a",
          partHover: (l == null ? void 0 : l.part_hover_color) ?? "#f8b029",
          partSelected: (l == null ? void 0 : l.part_selected_color) ?? "#5bc85b",
          stock: (l == null ? void 0 : l.stock_color) ?? "#ffd166",
          button: (l == null ? void 0 : l.button_color) ?? "#118ab2",
          buttonText: (l == null ? void 0 : l.button_text_color) ?? "#ffffff",
          text: (l == null ? void 0 : l.text_color) ?? "#ffffff"
        }
      };
      m.value = Ht.debug;
      const Ae = {
        units: "decimal",
        faces: {
          enabled: l.machining_sides
        },
        holes: {
          enabled: l.machining_holes,
          defaultDiameter: l.machining_holes_default_diameter,
          diameters: l.machining_holes_diameters.split(",").map((Yt) => Yt.trim()).filter(Boolean),
          minDiameter: l.machining_holes_min_diameter,
          maxDiameter: l.machining_holes_max_diameter,
          enableDepth: l.machining_holes_depth,
          depths: l.machining_holes_depths.split(",").map((Yt) => Yt.trim()).filter(Boolean),
          defaultDepth: l.machining_holes_default_depth,
          minDepth: l.machining_holes_min_depth,
          maxDepth: l.machining_holes_max_depth
        },
        hingeHoles: {
          enabled: l.machining_hinge_holes,
          minimumHoleDistance: l.machining_hinge_holes_minimum_hole_distance,
          defaultDistanceFromEdge: l.machining_hinge_holes_default_distance_from_edge,
          defaultOuterSpacing: l.machining_hinge_holes_default_outer_spacing,
          defaultHingeLength: l.machining_hinge_holes_default_hinge_length
        },
        corners: {
          enabled: l.machining_radius_corners || l.machining_bevel_corners,
          types: [
            l.machining_radius_corners ? "radius" : null,
            l.machining_bevel_corners ? "bevel" : null
          ].filter(Boolean),
          minValue: l.machining_corners_min_value,
          maxValue: l.machining_corners_max_value,
          enableBanding: l.machining_corners_enable_banding
        }
      };
      k.value = kt(), k.value ? T(!0) : _(), u.type === "variable" ? A(!1, !1) : P(k.value);
      const Jt = {
        type: u.type,
        stock: y.value,
        variations: d ?? null,
        options: Ht,
        banding: jt,
        finish: Kt,
        machining: Ae
      };
      Qr(() => {
        O.value && O.value.init(Jt);
      }), Jt.type === "variable" && (M(["setting variable product form listeners"]), jQuery(function(Yt) {
        Yt(".variations_form").on("reset_data", () => A(!1, !1)).on("found_variation", (le, Xe) => ue(le, Xe));
      }));
    }, nt = (ht) => {
      const jt = (ht == null ? void 0 : ht.multiple_sizes) === !0;
      u = {
        type: ht == null ? void 0 : ht.product_type,
        multiple_sizes: jt,
        size: ht != null && ht.size ? ht.size.split(" | ") : [],
        l: !jt && (ht != null && ht.l) ? parseFloat(ht.l) : null,
        w: !jt && (ht != null && ht.w) ? parseFloat(ht.w) : null,
        t: (ht == null ? void 0 : ht.t) ?? null,
        price: parseFloat(ht == null ? void 0 : ht.price) ?? null,
        stock_name: ht.stock_name
      }, u.multiple_sizes || (u.l || j("product 'length' attribute not available"), u.w || j("product 'width' attribute not available"));
    }, N = (ht) => {
      b.value = gn(window, ["smartcutConfig", "settings", "enable_formula"]) === !0 ? "formula" : "manual", x.value = gn(window, ["smartcutConfig", "settings", "formula_url"]), M([`Input type: ${b.value}`]), M([`Input type: ${b.value}`]), f = {
        thousands_separator: ht == null ? void 0 : ht.thousands_separator,
        decimal_separator: ht == null ? void 0 : ht.decimal_separator,
        number_of_decimals: ht == null ? void 0 : ht.number_of_decimals,
        currency_symbol: ht == null ? void 0 : ht.currency_symbol,
        currency_position: ht == null ? void 0 : ht.currency_position
      };
    }, z = () => {
      const ht = {
        checkout: "#smartcut-app",
        intro_text: "#smartcut-intro-text",
        pricing_table: "#smartcut-pricing-table",
        offcuts: "#include_offcuts_field",
        banding_key: "#smartcut-banding-key",
        finish_key: "#smartcut-finish-key",
        banding_total_price: "#smartcut-banding-total bdi .smartcut-price-selector",
        finish_total_price: "#smartcut-finish-total bdi .smartcut-price-selector",
        cut_length_price: "#smartcut-cut-length-total bdi .smartcut-price-selector",
        per_part_price: "#smartcut-per-part-total bdi .smartcut-price-selector",
        roll_length_price: "#smartcut-roll-length-total bdi .smartcut-price-selector",
        surcharge_price: "#smartcut-surcharge-total bdi .smartcut-price-selector",
        machining_total_price: "#smartcut-machining-total bdi .smartcut-price-selector",
        stock_total_price: "#smartcut-stock-total bdi .smartcut-price-selector",
        quantity: ".smartcut-stock-quantity",
        //this is the add to cart quantity element(s)
        cart_button: ".single_add_to_cart_button"
      };
      for (const [jt, Kt] of Object.entries(ht))
        o[jt] = document.querySelector(Kt);
      if (!o.checkout)
        return j("checkout iframe not found");
      if (!o.quantity)
        return j("quantity field not found");
      if (!o.cart_button)
        return j("cart button not found");
      o.quantity.readOnly = !0, R();
    }, G = () => ({
      x1: l.stock_trim_x1 ?? 0,
      x2: l.stock_trim_x2 ?? 0,
      y1: l.stock_type === "linear" ? 0 : l.stock_trim_y1 ?? 0,
      y2: l.stock_type === "linear" ? 0 : l.stock_trim_y2 ?? 0
    }), Y = (ht = null, jt = null, Kt = null, Ht = null, Ae = null) => {
      let Jt;
      if (Ae && typeof Ae == "object") {
        Jt = [];
        for (const [le, Xe] of Object.entries(Ae))
          le !== "attribute_size" && le !== "attribute_thickness" && Jt.push(`${le.replace("attribute_", "")}: ${Xe}`);
        Jt = Jt.join(" - ");
      }
      return {
        name: u.stock_name,
        type: l.stock_type,
        l: ht,
        w: jt,
        t: Kt,
        grain: l.stock_grain,
        cost: parseFloat((Ht == null ? void 0 : Ht.toString()) || "0"),
        trim: G(),
        allowExactFitShapes: !0,
        notes: Jt
      };
    }, st = () => {
      u != null && u.stock_name || j("product name not specified"), y.value = [], u.multiple_sizes ? u.size.forEach((ht) => {
        const [jt, Kt] = ht.split("x"), Ht = Y(
          parseFloat(jt),
          parseFloat(Kt),
          u == null ? void 0 : u.t,
          ht.price
        );
        y.value.push(Ht);
      }) : y.value.push(Y(
        u.l,
        u.w,
        u == null ? void 0 : u.t,
        u == null ? void 0 : u.price
      ));
    }, vt = (ht, jt) => {
      const Kt = ht.split(".");
      return Kt[0] = Kt[0].replace(/\B(?=(\d{3})+(?!\d))/g, jt), Kt.join(".");
    }, mt = (ht = 0, jt = "") => {
      if (!ht)
        return jt ? Bt("0.00") : "0.00";
      typeof ht == "string" && (ht = parseFloat(ht));
      const Kt = ht.toFixed(f.number_of_decimals).replace(".", f.decimal_separator), Ht = vt(Kt, f.thousands_separator);
      return jt ? Bt(Ht) : Ht;
    }, _t = (ht) => {
      if (ht == null) return "";
      typeof ht == "string" && (ht = parseFloat(ht));
      const Kt = ht % 1 !== 0 ? f.number_of_decimals : 0, Ht = ht.toFixed(Kt).replace(".", f.decimal_separator);
      return vt(Ht, f.thousands_separator);
    }, Bt = (ht) => {
      switch (f.currency_position) {
        case "left":
          return `${f.currency_symbol}${ht}`;
        case "right":
          return `${ht}${f.currency_symbol}`;
        default:
          return `${f.currency_symbol}${ht}`;
      }
    }, Rt = (ht) => {
      const jt = (Kt) => b1($l(Kt), 100).replace("|", "_");
      return Array.isArray(ht) ? ht.map(jt).join(",") : jt(ht);
    }, te = (ht) => {
      if (!ht) return null;
      const jt = {
        labels: [],
        pricing: {}
      }, Kt = Object.values(ht);
      for (const Ht of Kt)
        Ht != null && Ht.variations ? (jt.labels.push(...Object.keys(Ht.options)), Object.values(Ht.variations).forEach((Ae) => {
          const { options: Jt } = Ae, Yt = Object.values(Jt).map((le) => Rt(le)).join("|");
          jt.pricing[Yt] = parseInt(Ae.price);
        })) : Ht != null && Ht.options && Object.keys(Ht.options).forEach((Ae) => {
          jt.pricing[Rt(Ae)] = parseInt(Ht.price);
        });
      return jt.labels.length || jt.labels.push("type"), jt;
    }, Xt = (ht, jt) => {
      if (!jt.length || !ac(h, [ht])) return null;
      const Kt = gn(h, [ht]);
      if (!Co(Kt)) return null;
      const Ae = Object.values(Kt).map((Jt) => Jt != null && Jt.variations ? Object.values(Jt.variations).map((Yt) => (Yt.type = "variable", Yt)) : (Jt.type = "simple", Jt)).flat().find((Jt) => {
        let Yt;
        return Jt.type === "simple" ? Yt = Object.keys(Jt.options) : Yt = Object.values(Jt.options), Yt ? Yt.every((le, Xe) => Rt(le) === Rt(jt[Xe])) : !1;
      });
      return Ae != null && Ae.price ? parseFloat(Ae.price) : null;
    }, E = (ht) => {
      let jt = 0;
      if (typeof ht == "object") {
        for (let [Kt, Ht] of Object.entries(ht)) {
          typeof Ht == "string" && (Ht = parseFloat(Ht));
          const Ae = Kt.split("|"), Jt = Xt("finish", Ae);
          if (Jt === null) continue;
          const le = Number(Ht) / 1e6 * parseFloat(Jt.toString());
          jt += le;
        }
        if ("min_finish_charge" in l) {
          const Kt = parseFloat(l == null ? void 0 : l.min_finish_charge);
          if (Kt > 0 && jt > 0 && jt < Kt)
            return Kt;
        }
      }
      return jt;
    }, ft = (ht) => {
      let jt = 0;
      if (typeof ht == "object") {
        for (let [Kt, Ht] of Object.entries(ht)) {
          typeof Ht == "string" && (Ht = parseFloat(Ht));
          const Ae = Kt.split("|"), Jt = Xt("banding", Ae);
          if (Jt === null) continue;
          const Yt = Ht / (l.units === "fraction" ? 12 : 1e3) * parseFloat(Jt.toString());
          jt += Yt;
        }
        if ("min_banding_charge" in l) {
          const Kt = parseFloat(l == null ? void 0 : l.min_banding_charge);
          if (Kt > 0 && jt > 0 && jt < Kt)
            return Kt;
        }
      }
      return jt;
    }, U = (ht) => (p.holes ?? 0) * (ht.metadata.numHoles ?? 0) + (p.corners ?? 0) * (ht.metadata.numCorners ?? 0), et = (ht, jt) => {
      rt(ht) ? a[ht].value = jt : j(`Attempting to set input but key '${ht}' does not exist`);
    }, X = (ht) => {
      if (rt(ht))
        return a[ht].value;
      j(`Attempting to get input but key '${ht}' does not exist`);
    }, rt = (ht) => ht in a && a[ht] instanceof HTMLInputElement, wt = () => {
      Q(1), R(), et("smartcut-cut-to-size-surcharge", 0);
      for (const ht of t) Z(ht, 0);
      for (const ht in a)
        ht !== "smartcut-hardware-price" && et(ht, null);
    }, kt = () => {
      var ht;
      if (((ht = window.smartcutConfig) == null ? void 0 : ht.product_type) === "variable")
        return !1;
      switch (l.pricing_strategy) {
        case "full_stock":
        case "part_area":
        case "full_stock_plus_cut_length":
        case "full_stock_plus_num_parts":
          return !0;
        case "roll_length":
        case "cut_length":
          return !1;
        default:
          return !1;
      }
    }, dt = (ht) => {
      if (ac(l, ["enable", ht]) && gn(l, ["enable", ht]) === !1)
        return !1;
      const jt = gn(h, [ht]);
      return !!(jt && Object.values(jt).length);
    }, Pt = () => l.enable_machining === !0, qt = () => !((l == null ? void 0 : l.surcharge_type) === "none" || !(l != null && l.surcharge) || l.surcharge === "0.00"), Ft = () => !!(l.pricing_strategy === "full_stock_plus_cut_length" || l.pricing_strategy === "full_stock_plus_num_parts" || l.pricing_strategy === "roll_length" || qt() || dt("banding") || dt("finish") || Pt()), Vt = (ht) => {
      var Kt;
      let jt = (Kt = ht == null ? void 0 : ht.attributes) == null ? void 0 : Kt.attribute_size;
      return jt || (jt = u == null ? void 0 : u.size), jt;
    }, ne = (ht) => /\d+x\d+/.test(ht), ie = () => {
      window.smartcutConfig.input_fields.forEach((ht) => {
        const jt = ht.replaceAll("_", "-");
        a[jt] = document.getElementById(jt);
      });
    }, ue = (ht, jt) => {
      wt(), v.value = jt, M(["variation selected", jt.attributes]), y.value = [];
      const Kt = gn(jt, ["attributes", "attribute_thickness"]);
      if (u.selected_thickness = Kt, u.multiple_sizes) {
        const Ht = Vt(jt);
        if (M([`variation found with size: ${Ht} & thickness: ${Kt}`]), !Ht)
          return A(!1), j("The size of this multiple size product could not be found");
        if (Array.isArray(Ht) ? P(!1) : ne(Ht) ? A(!0, !0) : P(!1), d != null && d.length && Kt) {
          let Ae;
          if (Array.isArray(Ht)) {
            const Jt = d.find((Yt) => Yt.attributes.thickness === Kt);
            if (!Jt)
              return j(`variation not found for thickness ${Kt}`);
            Ae = Ht.map((Yt) => ({
              size: Yt,
              l: Yt.split("x")[0],
              w: Yt.split("x")[1],
              t: Kt,
              price: Jt == null ? void 0 : Jt.price
            }));
          } else
            Ae = d.filter((Jt) => {
              var Yt, le;
              return /\d+x\d+/.test((Yt = Jt == null ? void 0 : Jt.attributes) == null ? void 0 : Yt.size) ? Kt === ((le = Jt == null ? void 0 : Jt.attributes) == null ? void 0 : le.thickness) : !1;
            }).map((Jt) => {
              var Xe, xn, Ge, Ne;
              const Yt = d.find((Be) => {
                var Di, pn;
                return Kt === ((Di = Be == null ? void 0 : Be.attributes) == null ? void 0 : Di.thickness) && Ht === ((pn = Be == null ? void 0 : Be.attributes) == null ? void 0 : pn.size);
              });
              Yt || j(`exactMatchVariation not found for thickness ${Kt}, size: ${Ht} in variations`);
              let le = !(Yt != null && Yt.price) || parseFloat(Yt.price) === 0 ? (Jt == null ? void 0 : Jt.price) ?? "0" : Yt == null ? void 0 : Yt.price;
              return M([
                `size attribute: '${(Xe = Jt == null ? void 0 : Jt.attributes) == null ? void 0 : Xe.size}'`,
                `price for 'thickness ${Kt}, size: ${Ht}' detected as ${le}`
              ]), {
                size: (xn = Jt == null ? void 0 : Jt.attributes) == null ? void 0 : xn.size,
                l: (Ge = Jt == null ? void 0 : Jt.attributes) == null ? void 0 : Ge.size.split("x")[0],
                w: (Ne = Jt == null ? void 0 : Jt.attributes) == null ? void 0 : Ne.size.split("x")[1],
                t: u.selected_thickness,
                price: le
              };
            });
          q.value === !0 && Ae.forEach((Jt) => {
            const Yt = Y(
              Jt.l,
              Jt.w,
              Jt.t,
              Jt.price,
              jt == null ? void 0 : jt.attributes
            );
            y.value.push(Yt);
          });
        }
      } else {
        const Ht = d.find((Ae) => Ae.attributes.thickness === Kt);
        if (!Ht) return j(`variation not found for thickness ${Kt}`);
        y.value.push(Y(
          u.l,
          u.w,
          Kt,
          Ht.price,
          jt == null ? void 0 : jt.attributes
        )), P(!1);
      }
    }, we = async (ht) => {
      var Ae, Jt;
      wt();
      let jt = 0;
      const Kt = kt();
      if (Kt || Q(1), M(["result event received", ht]), !(ht != null && ht.jobId)) return;
      switch (I.value = da(ht.metadata), l.pricing_strategy) {
        case "full_stock": {
          M(["calculating cost by full sheet"]), Kt ? Q(ht.metadata.totalUsedStock) : jt = parseFloat(ht.metadata.totalStockCost), V();
          break;
        }
        case "part_area": {
          M(["calculating cost by part area in meters / sq feet"]);
          const Yt = l.units === "fraction" ? ht.metadata.totalPartArea / 144 : ht.metadata.totalPartArea / 1e6;
          M([`part area in square ${l.units === "fraction" ? "feet" : "meters"}`, Yt]), Kt ? Q(Yt, 2) : (M([`totalPrice is area: ${Yt} * price: ${v.value.display_price}`]), jt = Yt * parseFloat(v.value.display_price)), V();
          break;
        }
        case "cut_length": {
          M(["calculating cost by cut length in feet / meters"]);
          const Yt = ht.metadata.totalCutLength / (l.units === "fraction" ? 12 : 1e3);
          Q(Yt, 2), V();
          break;
        }
        case "full_stock_plus_cut_length": {
          M(["calculating cost by full sheet plus cut length"]), Kt ? Q(ht.metadata.totalUsedStock) : jt = parseFloat(ht.metadata.totalStockCost);
          const le = ht.metadata.totalCutLength / (l.units === "fraction" ? 12 : 1e3) * l.cut_length_price;
          Z("cutLength", le), jt += le, V();
          break;
        }
        case "full_stock_plus_num_parts": {
          if (M(["calculating cost by full sheet plus number of parts"]), Kt)
            Q(ht.metadata.totalUsedStock);
          else {
            const le = parseFloat(ht.metadata.totalStockCost);
            Z("stock", le), jt = le;
          }
          const Yt = ht.metadata.totalPartsProduced * l.per_part_price;
          Z("perPart", Yt), jt += Yt, V();
          break;
        }
        case "roll_length": {
          M(["calculating cost by roll length"]);
          const Yt = ht.stock.reduce((le, Xe) => {
            const xn = Xe.analysis.rollLength / (l.units === "fraction" ? 12 : 1e3) * Xe.cost;
            return le + xn;
          }, 0);
          Z("rollLength", Yt), jt += Yt, V();
          break;
        }
      }
      if (!Kt) {
        if (!ht.metadata.totalStockCost)
          return j("Total stock cost not returned for a multiple size product");
        M([`total cost is ${jt}`]), Z("custom", jt);
      }
      if (dt("banding") && ((Ae = ht == null ? void 0 : ht.metadata) != null && Ae.bandingLengthByType)) {
        const Yt = ft(ht.metadata.bandingLengthByType);
        Z("banding", Yt), jt += Yt;
      }
      if (dt("finish") && ((Jt = ht == null ? void 0 : ht.metadata) != null && Jt.bandingLengthByType)) {
        const Yt = E(ht.metadata.finishAreaByType);
        Z("finish", Yt), jt += Yt;
      }
      if (b.value === "formula") {
        const Yt = parseFloat(X("smartcut-hardware-price"));
        isNaN(Yt) || (jt += Yt);
      }
      if (Pt()) {
        const Yt = U(ht);
        Z("machining", Yt), jt += Yt;
      }
      if (qt() && (l != null && l.surcharge)) {
        let Yt = 0;
        (l == null ? void 0 : l.surcharge_type) === "per_sheet" ? Yt = parseFloat(l == null ? void 0 : l.surcharge) * parseFloat(ht.metadata.totalUsedStock) : Yt = parseFloat(l == null ? void 0 : l.surcharge), Z("surcharge", Yt), M(["added surcharge", Yt]), jt += Yt;
      }
      v.value && H(jt);
      const Ht = {
        "smartcut-job-id": ht == null ? void 0 : ht.jobId,
        "smartcut-dimensions": ht == null ? void 0 : ht.parts.map((Yt) => `${Yt == null ? void 0 : Yt.l}x${Yt == null ? void 0 : Yt.w} [${Yt == null ? void 0 : Yt.q}]`).join(", "),
        "smartcut-total-cut-length": ht.metadata.totalCutLength,
        "smartcut-part-area": ht.metadata.totalPartArea,
        "smartcut-total-cuts": ht.metadata.totalCuts,
        "smartcut-total-parts": ht.metadata.totalPartsProduced,
        "smartcut-machining": ht.metadata.hasMachining
      };
      if (Object.entries(Ht).forEach(([Yt, le]) => {
        et(Yt, le);
      }), a != null && a["smartcut-stock-summary"]) {
        const Yt = ht.stock.map((le) => `${le == null ? void 0 : le.l}x${le == null ? void 0 : le.w}${le != null && le.t ? "x" + le.t : ""} [${le == null ? void 0 : le.q}]`).join(", ");
        et("smartcut-stock-summary", Yt);
      }
      await Qt(ht);
    }, Qt = async (ht) => {
      const Kt = ew(ht, C.value, _t).split(",")[1], Ht = new Wk();
      Ht.file("order-summary.pdf", Kt);
      const Ae = await Ht.generateAsync({ type: "blob" }), Jt = new File([Ae], "order-summary.zip", { type: "application/zip" });
      if (!rt("smartcut-order-summary")) return;
      const Yt = a["smartcut-order-summary"].closest("form");
      if (!Yt) return;
      const le = new DataTransfer();
      le.items.add(Jt);
      const Xe = Yt.querySelector('[name="smartcut_order_summary"]');
      Xe instanceof HTMLInputElement && (Xe.files = le.files);
    }, Ke = (ht, jt) => {
      R(), C.value = da(ht), et("smartcut-hardware-price", jt);
    };
    return Lo(() => {
      console.log("💥 Powered by https://smartcut.dev", window.smartcutConfig.version), M(["Launching WordPress checkout..."]), h.banding = gn(window, ["smartcutConfig", "banding_data"]), h.finish = gn(window, ["smartcutConfig", "finish_data"]), p = gn(window, ["smartcutConfig", "machining_pricing"]), d = gn(window, ["smartcutConfig", "variations"]), z(), ie(), nt(window.smartcutConfig), N(window.smartcutConfig), ct(), st(), [
        "div.quantity > input.plus",
        "div.quantity > input.minus",
        "div.quantity .qty-plus",
        "div.quantity .qty-minus"
      ].forEach((Kt) => {
        const Ht = document.querySelector(Kt);
        Ht && (Ht.style.display = "none");
      });
      const jt = new CustomEvent("smartcut/ready");
      window.dispatchEvent(jt), M(["Wordpress checkout ready"]);
    }), (ht, jt) => (ee(), de(Zn, null, [
      Ie(s) === "development" && Gk ? (ee(), de("div", Hk, [
        jt[0] || (jt[0] = be("div", null, "WP - developer information", -1)),
        Ln(Ie(r), {
          data: [Ie(u)],
          paths: ["product"]
        }, null, 8, ["data"]),
        Ln(Ie(r), {
          data: [y.value],
          paths: ["stock"]
        }, null, 8, ["data"]),
        Ln(Ie(r), {
          data: [h],
          paths: ["extrasData"]
        }, null, 8, ["data"])
      ])) : Pe("", !0),
      b.value === "formula" && x.value ? (ee(), Wn(Ie(i), {
        key: 1,
        ref: "formulapricing",
        units: F.value,
        "format-price": mt,
        url: x.value,
        debug: m.value,
        onHardwareResult: Ke,
        onPanelResult: R
      }, null, 8, ["units", "url", "debug"])) : Pe("", !0),
      b.value === "manual" || b.value === "formula" && x.value ? (ee(), Wn($k, {
        key: 2,
        ref_key: "calculator",
        ref: O,
        readonly: b.value === "formula",
        debug: m.value,
        stock: y.value,
        "find-extras-price": Xt,
        "format-price": mt,
        units: F.value,
        onLog: M,
        onError: j,
        onResult: we,
        onInputsChanged: R
      }, null, 8, ["readonly", "debug", "stock", "units"])) : Pe("", !0)
    ], 64));
  }
}), Yk = /* @__PURE__ */ is({
  __name: "Launch",
  props: {
    type: { default: "" }
  },
  setup(n) {
    const t = go(() => import("./Vanilla-ivnDJEY-.js")), e = {
      wordpress: Vk,
      vanilla: t
    }, i = n, r = sn(() => {
      const s = i.type.toLowerCase();
      return e[s] || null;
    });
    return (s, o) => (ee(), Wn(F2(r.value), { ref: "checkout" }, null, 512));
  }
}), tA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: Yk }, Symbol.toStringTag, { value: "Module" }));
export {
  $k as C,
  wl as I,
  tA as L,
  Pa as _,
  co as a,
  nn as b,
  ac as c,
  Oc as d,
  je as e,
  re as f,
  gn as g,
  pr as h,
  d1 as i,
  Zk as j,
  h1 as k,
  Yg as l,
  Qk as m,
  h6 as n,
  Yy as o,
  Mm as r,
  Dm as s,
  sf as u,
  Dt as v
};
