var S2 = Object.defineProperty;
var k2 = (n, t, e) => t in n ? S2(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var tt = (n, t, e) => k2(n, typeof t != "symbol" ? t + "" : t, e);
import { i as A2, u as Pe, o as No, n as Qr, r as Ae, a as N2, w as fr, g as C2, b as P2, c as L2, s as oo, d as ga, e as bp, f as Ar, m as ma, h as I2, j as ee, k as he, F as Qn, l as Lr, p as di, q as jn, t as me, v as gn, x as Xg, y as Jg, z as E2, A as Ne, B as is, C as rn, D as Of, E as Zg, G as Fl, H as Wn, I as Cn, J as qu, K as O2, L as ho, M as T2, N as F2 } from "./main-DGfvXlug.js";
let xu;
const M2 = new Uint8Array(16);
function R2() {
  if (!xu && (xu = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !xu))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return xu(M2);
}
const Xn = [];
for (let n = 0; n < 256; ++n)
  Xn.push((n + 256).toString(16).slice(1));
function D2(n, t = 0) {
  return Xn[n[t + 0]] + Xn[n[t + 1]] + Xn[n[t + 2]] + Xn[n[t + 3]] + "-" + Xn[n[t + 4]] + Xn[n[t + 5]] + "-" + Xn[n[t + 6]] + Xn[n[t + 7]] + "-" + Xn[n[t + 8]] + Xn[n[t + 9]] + "-" + Xn[n[t + 10]] + Xn[n[t + 11]] + Xn[n[t + 12]] + Xn[n[t + 13]] + Xn[n[t + 14]] + Xn[n[t + 15]];
}
const B2 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vp = {
  randomUUID: B2
};
function Qg(n, t, e) {
  if (vp.randomUUID && !t && !n)
    return vp.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || R2)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, D2(i);
}
const fa = 1e-10, j2 = 10, q2 = Number.MAX_SAFE_INTEGER, z2 = 4294967295, Zn = (n) => typeof n == "number" && Number.isFinite(n), zu = (n) => Array.isArray(n) && n.length > 0;
function ll(n, t, e = fa) {
  if (n === t) return 0;
  if (Number.isInteger(n) && Number.isInteger(t))
    return n > t ? 1 : -1;
  const i = n - t;
  return Math.abs(i) < e ? 0 : i;
}
const $2 = {
  greaterThan: (n, t, e = fa) => !Zn(n) || !Zn(t) ? !1 : ll(n, t, e) > 0,
  greaterThanOrEqualTo: (n, t, e = fa) => !Zn(n) || !Zn(t) ? !1 : ll(n, t, e) >= 0,
  lessThan: (n, t, e = fa) => !Zn(n) || !Zn(t) ? !1 : ll(n, t, e) < 0,
  lessThanOrEqualTo: (n, t, e = fa) => !Zn(n) || !Zn(t) ? !1 : ll(n, t, e) <= 0,
  equalTo: (n, t, e = fa) => !Zn(n) || !Zn(t) ? !1 : ll(n, t, e) === 0
};
function U2(n) {
  return Zn(n) ? Number.isInteger(n) ? n : Number(n.toFixed(j2)) : !1;
}
function W2(n) {
  if (!Zn(n) || n < 0 || n > q2)
    throw new Error("Invalid length parameter");
  return Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / (z2 + 1) * n);
}
function H2(n, t) {
  if (!zu(n))
    throw new Error("Invalid array parameter");
  if (!Zn(t) || t < 0 || t > n.length)
    throw new Error("Invalid size parameter");
  const e = n.slice(), i = n.length - t;
  for (let r = n.length - 1; r >= i; r--) {
    const s = Math.floor(Math.random() * (r + 1));
    [e[r], e[s]] = [e[s], e[r]];
  }
  return e.slice(i);
}
class _u {
  static calculateMean(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    return t.reduce((e, i) => e + i, 0) / t.length;
  }
  static calculateStandardDeviation(t, e = null) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const i = e ?? this.calculateMean(t), r = t.reduce((s, o) => {
      const a = o - i;
      return s + a * a;
    }, 0) / t.length;
    return Math.sqrt(r);
  }
  static calculateCoefficientOfVariation(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const e = this.calculateMean(t);
    if (e === 0)
      throw new Error("Mean is zero, coefficient of variation undefined");
    return this.calculateStandardDeviation(t, e) / e;
  }
}
const Ue = {
  ...$2,
  isNumber: Zn,
  round: U2,
  getRandom: W2,
  getRandomSample: H2,
  calculateStandardDeviation: _u.calculateStandardDeviation.bind(_u),
  calculateCoefficientOfVariation: _u.calculateCoefficientOfVariation.bind(_u)
}, Ju = {
  //sort by width then length - use .sort(sortHeightDescWidthDesc)
  WDLD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
  },
  WALA(n, t) {
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
  },
  //sort by length d then width d
  LDWD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
  },
  LAWA(n, t) {
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
  },
  //sort by width d
  WD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.w === t.w) return 0;
  },
  LD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.l === t.l) return 0;
  },
  LDIDA(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  WDIDA(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  //sort by proportion
  /* sortProportion: function(a, b) {
  
  		if (a.proportion < b.proportion) return 1;
  		if (a.proportion > b.proportion) return -1;
  
  		if (a.proportion === b.proportion) return a.index - b.index;
  
  	} */
  //area descending
  AD(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
  },
  AA(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) return 0;
  },
  AAID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  ADID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  //by id ascending
  ID(n, t) {
    if (!n.id || !t.id) return 0;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  IDDesc(n, t) {
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(i[0]) - parseInt(e[0]) : parseInt(i[1]) - parseInt(e[1]);
  },
  StockID(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  StockIDAD(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    const r = n.getArea(), s = t.getArea();
    if (r < s) return 1;
    if (r > s) return -1;
  },
  parentID(n, t) {
    return n.parentID - t.parentID;
  },
  YX(n, t) {
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
    if (n.y === t.y) return 0;
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
  },
  XY(n, t) {
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
    if (n.x === t.x) return 0;
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
  },
  subset(n, t) {
    if (n.totalLength < t.totalLength) return 1;
    if (n.totalLength > t.totalLength) return -1;
    if (n.area === t.area) return 0;
    if (n.area < t.area) return 1;
    if (n.area > t.area) return -1;
  },
  placementOrder(n, t) {
    return (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  typePlacementOrder(n, t) {
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  stockIDTypePlacementOrder(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  offcutPlacementOrder(n, t) {
    var r, s;
    if (!((r = n == null ? void 0 : n.stock) != null && r.id) || !((s = t == null ? void 0 : t.stock) != null && s.id)) return 0;
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : e[1] !== i[1] ? parseInt(e[1]) - parseInt(i[1]) : (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  groupPlacementOrder(n, t) {
    if (n.placementOrder > t.placementOrder) return 1;
    if (n.placementOrder < t.placementOrder) return -1;
    if (n.groupPlacementOrder === t.groupPlacementOrder) return 0;
    if (n.groupPlacementOrder > t.groupPlacementOrder) return 1;
    if (n.groupPlacementOrder < t.groupPlacementOrder) return -1;
  },
  swapFirstTwo(n) {
    const t = n[1];
    n[1] = n[0], n[0] = t;
  },
  //Fisher-Yates shuffle
  shuffle(n) {
    for (let t = n.length - 1; t > 0; t--) {
      const e = Math.floor(Math.random() * (t + 1));
      [n[t], n[e]] = [n[e], n[t]];
    }
  },
  /**
      * generator function which accepts a dimension to cater for shape rotation lock
      */
  fillThenArea(n) {
    return function(t, e) {
      return t.getLongSide(n) > e.getLongSide(n) ? -1 : t.getLongSide(n) < e.getLongSide(n) ? 1 : t.getArea() > e.getArea() ? -1 : t.getArea() < e.getArea() ? 1 : 0;
    };
  },
  aspect(n, t) {
    const e = n.getAspect(), i = t.getAspect();
    return e > i ? -1 : e < i ? 1 : 0;
  }
};
function G2(n) {
  if (n === "l") return "x";
  if (n === "w") return "y";
}
function xo(n) {
  return n ? n === "l" ? "w" : "l" : null;
}
function V2(n) {
  return n ? n === "x" ? "y" : "x" : null;
}
class ya {
  constructor(t) {
    tt(this, "x1");
    tt(this, "x2");
    tt(this, "y1");
    tt(this, "y2");
    tt(this, "dimension");
    tt(this, "direction");
    tt(this, "shapeCollisions");
    tt(this, "origin");
    tt(this, "type");
    this.x1 = t.x1, this.x2 = t.x2, this.y1 = t.y1, this.y2 = t.y2, this.dimension = Y2(this), this.direction = K2(this), this.type = t != null && t.type ? t.type : null, this.origin = t != null && t.origin ? t.origin : null;
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
}
function Ns(n, t, e, i, r = null, s = null) {
  return new ya({ x1: n, y1: t, x2: e, y2: i, origin: r, type: s });
}
function Y2(n) {
  return typeof n > "u" || !Ue.isNumber(n.x1) || !Ue.isNumber(n.x2) || !Ue.isNumber(n.y1) || !Ue.isNumber(n.y2) ? null : n.x1 === n.x2 && n.y1 !== n.y2 ? "w" : n.y1 === n.y2 && n.x1 !== n.x2 ? "l" : null;
}
function K2(n) {
  return typeof n > "u" || !Ue.isNumber(n.x1) || !Ue.isNumber(n.x2) || !Ue.isNumber(n.y1) || !Ue.isNumber(n.y2) ? null : n.x1 < n.x2 ? "lr" : n.x1 > n.x2 ? "rl" : n.y1 < n.y2 ? "bt" : n.y1 > n.y2 ? "tb" : null;
}
function X2(n, t) {
  const e = n.getCorners(), i = {};
  return e.bottomLeft.x > 0 && e.bottomLeft.y > 0 && (i.bottomLeftDown = Ns(
    e.bottomLeft.x,
    e.bottomLeft.y,
    e.bottomLeft.x,
    0,
    "bottomLeft",
    "bottomLeftDown"
  ), i.bottomLeftLeft = Ns(
    e.bottomLeft.x,
    e.bottomLeft.y,
    0,
    e.bottomLeft.y,
    "bottomLeft",
    "bottomLeftLeft"
  )), e.topLeft.x > 0 && e.topLeft.y < t.w && (i.topLeftLeft = Ns(
    e.topLeft.x,
    e.topLeft.y,
    0,
    e.topLeft.y,
    "topLeft",
    "topLeftLeft"
  ), i.topLeftTop = Ns(
    e.topLeft.x,
    e.topLeft.y,
    e.topLeft.x,
    t.w,
    "topLeft",
    "topLeftTop"
  )), e.topRight.y < t.w && e.topRight.x < t.l && (i.topRightTop = Ns(
    e.topRight.x,
    e.topRight.y,
    e.topRight.x,
    t.w,
    "topRight",
    "topRightTop"
  ), i.topRightRight = Ns(
    e.topRight.x,
    e.topRight.y,
    t.l,
    e.topRight.y,
    "topRight",
    "topRightRight"
  )), e.bottomRight.x < t.l && e.bottomRight.y > 0 && (i.bottomRightRight = Ns(
    e.bottomRight.x,
    e.bottomRight.y,
    t.l,
    e.bottomRight.y,
    "bottomRight",
    "bottomRightRight"
  ), i.bottomRightDown = Ns(
    e.bottomRight.x,
    e.bottomRight.y,
    e.bottomRight.x,
    0,
    "bottomRight",
    "bottomRightDown"
  )), i;
}
var t0 = Object.defineProperty, J2 = Object.getOwnPropertyNames, Et = (n, t) => t0(n, "name", { value: t, configurable: !0 }), Z2 = (n, t) => function() {
  return t || (0, n[J2(n)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Tf = (n, t) => {
  for (var e in t)
    t0(n, e, { get: t[e], enumerable: !0 });
}, Q2 = Z2({
  "(disabled):util"() {
  }
}), Zu = {};
Tf(Zu, {
  addChainableMethod: () => Hf,
  addLengthGuard: () => Dl,
  addMethod: () => $f,
  addProperty: () => zf,
  checkError: () => Ri,
  compareByInspect: () => nc,
  eql: () => C0,
  expectTypes: () => a0,
  flag: () => Fe,
  getActual: () => Sc,
  getMessage: () => Rf,
  getName: () => Ac,
  getOperator: () => Kf,
  getOwnEnumerableProperties: () => Yf,
  getOwnEnumerablePropertySymbols: () => Vf,
  getPathInfo: () => qf,
  hasProperty: () => kc,
  inspect: () => $e,
  isNaN: () => ic,
  isNumeric: () => Gn,
  isProxyEnabled: () => Rl,
  isRegExp: () => rc,
  objDisplay: () => fo,
  overwriteChainableMethod: () => Gf,
  overwriteMethod: () => Wf,
  overwriteProperty: () => Uf,
  proxify: () => Pa,
  test: () => Ff,
  transferFlags: () => yr,
  type: () => sn
});
var Ri = {};
Tf(Ri, {
  compatibleConstructor: () => i0,
  compatibleInstance: () => n0,
  compatibleMessage: () => r0,
  getConstructorName: () => s0,
  getMessage: () => o0
});
function _c(n) {
  return n instanceof Error || Object.prototype.toString.call(n) === "[object Error]";
}
Et(_c, "isErrorInstance");
function e0(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
Et(e0, "isRegExp");
function n0(n, t) {
  return _c(t) && n === t;
}
Et(n0, "compatibleInstance");
function i0(n, t) {
  return _c(t) ? n.constructor === t.constructor || n instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? n.constructor === t || n instanceof t : !1;
}
Et(i0, "compatibleConstructor");
function r0(n, t) {
  const e = typeof n == "string" ? n : n.message;
  return e0(t) ? t.test(e) : typeof t == "string" ? e.indexOf(t) !== -1 : !1;
}
Et(r0, "compatibleMessage");
function s0(n) {
  let t = n;
  return _c(n) ? t = n.constructor.name : typeof n == "function" && (t = n.name, t === "" && (t = new n().name || t)), t;
}
Et(s0, "getConstructorName");
function o0(n) {
  let t = "";
  return n && n.message ? t = n.message : typeof n == "string" && (t = n), t;
}
Et(o0, "getMessage");
function Fe(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    i[t] = e;
  else
    return i[t];
}
Et(Fe, "flag");
function Ff(n, t) {
  var e = Fe(n, "negate"), i = t[0];
  return e ? !i : i;
}
Et(Ff, "test");
function sn(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
Et(sn, "type");
var ty = "captureStackTrace" in Error, wo, Ye = (wo = class extends Error {
  constructor(e = "Unspecified AssertionError", i, r) {
    super(e);
    tt(this, "message");
    this.message = e, ty && Error.captureStackTrace(this, r || wo);
    for (const s in i)
      s in this || (this[s] = i[s]);
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, Et(wo, "AssertionError"), wo);
function a0(n, t) {
  var e = Fe(n, "message"), i = Fe(n, "ssfi");
  e = e ? e + ": " : "", n = Fe(n, "object"), t = t.map(function(o) {
    return o.toLowerCase();
  }), t.sort();
  var r = t.map(function(o, a) {
    var l = ~["a", "e", "i", "o", "u"].indexOf(o.charAt(0)) ? "an" : "a", h = t.length > 1 && a === t.length - 1 ? "or " : "";
    return h + l + " " + o;
  }).join(", "), s = sn(n).toLowerCase();
  if (!t.some(function(o) {
    return s === o;
  }))
    throw new Ye(
      e + "object tested must be " + r + ", but " + s + " given",
      void 0,
      i
    );
}
Et(a0, "expectTypes");
function Sc(n, t) {
  return t.length > 4 ? t[4] : n._obj;
}
Et(Sc, "getActual");
var wp = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, ey = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, _a = "…";
function l0(n, t) {
  const e = wp[ey[t]] || wp[t] || "";
  return e ? `\x1B[${e[0]}m${String(n)}\x1B[${e[1]}m` : String(n);
}
Et(l0, "colorise");
function u0({
  showHidden: n = !1,
  depth: t = 2,
  colors: e = !1,
  customInspect: i = !0,
  showProxy: r = !1,
  maxArrayLength: s = 1 / 0,
  breakLength: o = 1 / 0,
  seen: a = [],
  // eslint-disable-next-line no-shadow
  truncate: l = 1 / 0,
  stylize: h = String
} = {}, u) {
  const d = {
    showHidden: !!n,
    depth: Number(t),
    colors: !!e,
    customInspect: !!i,
    showProxy: !!r,
    maxArrayLength: Number(s),
    breakLength: Number(o),
    truncate: Number(l),
    seen: a,
    inspect: u,
    stylize: h
  };
  return d.colors && (d.stylize = l0), d;
}
Et(u0, "normaliseOptions");
function c0(n) {
  return n >= "\uD800" && n <= "\uDBFF";
}
Et(c0, "isHighSurrogate");
function rs(n, t, e = _a) {
  n = String(n);
  const i = e.length, r = n.length;
  if (i > t && r > i)
    return e;
  if (r > t && r > i) {
    let s = t - i;
    return s > 0 && c0(n[s - 1]) && (s = s - 1), `${n.slice(0, s)}${e}`;
  }
  return n;
}
Et(rs, "truncate");
function Zi(n, t, e, i = ", ") {
  e = e || t.inspect;
  const r = n.length;
  if (r === 0)
    return "";
  const s = t.truncate;
  let o = "", a = "", l = "";
  for (let h = 0; h < r; h += 1) {
    const u = h + 1 === n.length, d = h + 2 === n.length;
    l = `${_a}(${n.length - h})`;
    const p = n[h];
    t.truncate = s - o.length - (u ? 0 : i.length);
    const f = a || e(p, t) + (u ? "" : i), m = o.length + f.length, b = m + l.length;
    if (u && m > s && o.length + l.length <= s || !u && !d && b > s || (a = u ? "" : e(n[h + 1], t) + (d ? "" : i), !u && d && b > s && m + a.length > s))
      break;
    if (o += f, !u && !d && m + a.length >= s) {
      l = `${_a}(${n.length - h - 1})`;
      break;
    }
    l = "";
  }
  return `${o}${l}`;
}
Et(Zi, "inspectList");
function h0(n) {
  return n.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? n : JSON.stringify(n).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
Et(h0, "quoteComplexKey");
function Sa([n, t], e) {
  return e.truncate -= 2, typeof n == "string" ? n = h0(n) : typeof n != "number" && (n = `[${e.inspect(n, e)}]`), e.truncate -= n.length, t = e.inspect(t, e), `${n}: ${t}`;
}
Et(Sa, "inspectProperty");
function f0(n, t) {
  const e = Object.keys(n).slice(n.length);
  if (!n.length && !e.length)
    return "[]";
  t.truncate -= 4;
  const i = Zi(n, t);
  t.truncate -= i.length;
  let r = "";
  return e.length && (r = Zi(e.map((s) => [s, n[s]]), t, Sa)), `[ ${i}${r ? `, ${r}` : ""} ]`;
}
Et(f0, "inspectArray");
var ny = /* @__PURE__ */ Et((n) => typeof Buffer == "function" && n instanceof Buffer ? "Buffer" : n[Symbol.toStringTag] ? n[Symbol.toStringTag] : n.constructor.name, "getArrayName");
function Nr(n, t) {
  const e = ny(n);
  t.truncate -= e.length + 4;
  const i = Object.keys(n).slice(n.length);
  if (!n.length && !i.length)
    return `${e}[]`;
  let r = "";
  for (let o = 0; o < n.length; o++) {
    const a = `${t.stylize(rs(n[o], t.truncate), "number")}${o === n.length - 1 ? "" : ", "}`;
    if (t.truncate -= a.length, n[o] !== n.length && t.truncate <= 3) {
      r += `${_a}(${n.length - n[o] + 1})`;
      break;
    }
    r += a;
  }
  let s = "";
  return i.length && (s = Zi(i.map((o) => [o, n[o]]), t, Sa)), `${e}[ ${r}${s ? `, ${s}` : ""} ]`;
}
Et(Nr, "inspectTypedArray");
function d0(n, t) {
  const e = n.toJSON();
  if (e === null)
    return "Invalid Date";
  const i = e.split("T"), r = i[0];
  return t.stylize(`${r}T${rs(i[1], t.truncate - r.length - 1)}`, "date");
}
Et(d0, "inspectDate");
function qh(n, t) {
  const e = n[Symbol.toStringTag] || "Function", i = n.name;
  return i ? t.stylize(`[${e} ${rs(i, t.truncate - 11)}]`, "special") : t.stylize(`[${e}]`, "special");
}
Et(qh, "inspectFunction");
function p0([n, t], e) {
  return e.truncate -= 4, n = e.inspect(n, e), e.truncate -= n.length, t = e.inspect(t, e), `${n} => ${t}`;
}
Et(p0, "inspectMapEntry");
function g0(n) {
  const t = [];
  return n.forEach((e, i) => {
    t.push([i, e]);
  }), t;
}
Et(g0, "mapToEntries");
function m0(n, t) {
  return n.size - 1 <= 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${Zi(g0(n), t, p0)} }`);
}
Et(m0, "inspectMap");
var iy = Number.isNaN || ((n) => n !== n);
function zh(n, t) {
  return iy(n) ? t.stylize("NaN", "number") : n === 1 / 0 ? t.stylize("Infinity", "number") : n === -1 / 0 ? t.stylize("-Infinity", "number") : n === 0 ? t.stylize(1 / n === 1 / 0 ? "+0" : "-0", "number") : t.stylize(rs(String(n), t.truncate), "number");
}
Et(zh, "inspectNumber");
function $h(n, t) {
  let e = rs(n.toString(), t.truncate - 1);
  return e !== _a && (e += "n"), t.stylize(e, "bigint");
}
Et($h, "inspectBigInt");
function y0(n, t) {
  const e = n.toString().split("/")[2], i = t.truncate - (2 + e.length), r = n.source;
  return t.stylize(`/${rs(r, i)}/${e}`, "regexp");
}
Et(y0, "inspectRegExp");
function b0(n) {
  const t = [];
  return n.forEach((e) => {
    t.push(e);
  }), t;
}
Et(b0, "arrayFromSet");
function v0(n, t) {
  return n.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${Zi(b0(n), t)} }`);
}
Et(v0, "inspectSet");
var xp = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), ry = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, sy = 16, oy = 4;
function w0(n) {
  return ry[n] || `\\u${`0000${n.charCodeAt(0).toString(sy)}`.slice(-oy)}`;
}
Et(w0, "escape");
function Uh(n, t) {
  return xp.test(n) && (n = n.replace(xp, w0)), t.stylize(`'${rs(n, t.truncate - 2)}'`, "string");
}
Et(Uh, "inspectString");
function Wh(n) {
  return "description" in Symbol.prototype ? n.description ? `Symbol(${n.description})` : "Symbol()" : n.toString();
}
Et(Wh, "inspectSymbol");
var x0 = /* @__PURE__ */ Et(() => "Promise{…}", "getPromiseValue");
try {
  const { getPromiseDetails: n, kPending: t, kRejected: e } = process.binding("util");
  Array.isArray(n(Promise.resolve())) && (x0 = /* @__PURE__ */ Et((i, r) => {
    const [s, o] = n(i);
    return s === t ? "Promise{<pending>}" : `Promise${s === e ? "!" : ""}{${r.inspect(o, r)}}`;
  }, "getPromiseValue"));
} catch {
}
var ay = x0;
function xl(n, t) {
  const e = Object.getOwnPropertyNames(n), i = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n) : [];
  if (e.length === 0 && i.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const r = Zi(e.map((a) => [a, n[a]]), t, Sa), s = Zi(i.map((a) => [a, n[a]]), t, Sa);
  t.seen.pop();
  let o = "";
  return r && s && (o = ", "), `{ ${r}${o}${s} }`;
}
Et(xl, "inspectObject");
var mh = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function _0(n, t) {
  let e = "";
  return mh && mh in n && (e = n[mh]), e = e || n.constructor.name, (!e || e === "_class") && (e = "<Anonymous Class>"), t.truncate -= e.length, `${e}${xl(n, t)}`;
}
Et(_0, "inspectClass");
function S0(n, t) {
  return n.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${Zi(n, t)} ]`);
}
Et(S0, "inspectArguments");
var ly = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function k0(n, t) {
  const e = Object.getOwnPropertyNames(n).filter((o) => ly.indexOf(o) === -1), i = n.name;
  t.truncate -= i.length;
  let r = "";
  if (typeof n.message == "string" ? r = rs(n.message, t.truncate) : e.unshift("message"), r = r ? `: ${r}` : "", t.truncate -= r.length + 5, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const s = Zi(e.map((o) => [o, n[o]]), t, Sa);
  return `${i}${r}${s ? ` { ${s} }` : ""}`;
}
Et(k0, "inspectObject");
function A0([n, t], e) {
  return e.truncate -= 3, t ? `${e.stylize(String(n), "yellow")}=${e.stylize(`"${t}"`, "string")}` : `${e.stylize(String(n), "yellow")}`;
}
Et(A0, "inspectAttribute");
function Qu(n, t) {
  return Zi(n, t, Mf, `
`);
}
Et(Qu, "inspectHTMLCollection");
function Mf(n, t) {
  const e = n.getAttributeNames(), i = n.tagName.toLowerCase(), r = t.stylize(`<${i}`, "special"), s = t.stylize(">", "special"), o = t.stylize(`</${i}>`, "special");
  t.truncate -= i.length * 2 + 5;
  let a = "";
  e.length > 0 && (a += " ", a += Zi(e.map((u) => [u, n.getAttribute(u)]), t, A0, " ")), t.truncate -= a.length;
  const l = t.truncate;
  let h = Qu(n.children, t);
  return h && h.length > l && (h = `${_a}(${n.children.length})`), `${r}${a}${s}${h}${o}`;
}
Et(Mf, "inspectHTML");
var uy = typeof Symbol == "function" && typeof Symbol.for == "function", yh = uy ? Symbol.for("chai/inspect") : "@@chai/inspect", ba = !1;
try {
  const n = Q2();
  ba = n.inspect ? n.inspect.custom : !1;
} catch {
  ba = !1;
}
var _p = /* @__PURE__ */ new WeakMap(), Sp = {}, kp = {
  undefined: (n, t) => t.stylize("undefined", "undefined"),
  null: (n, t) => t.stylize("null", "null"),
  boolean: (n, t) => t.stylize(String(n), "boolean"),
  Boolean: (n, t) => t.stylize(String(n), "boolean"),
  number: zh,
  Number: zh,
  bigint: $h,
  BigInt: $h,
  string: Uh,
  String: Uh,
  function: qh,
  Function: qh,
  symbol: Wh,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: Wh,
  Array: f0,
  Date: d0,
  Map: m0,
  Set: v0,
  RegExp: y0,
  Promise: ay,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (n, t) => t.stylize("WeakSet{…}", "special"),
  WeakMap: (n, t) => t.stylize("WeakMap{…}", "special"),
  Arguments: S0,
  Int8Array: Nr,
  Uint8Array: Nr,
  Uint8ClampedArray: Nr,
  Int16Array: Nr,
  Uint16Array: Nr,
  Int32Array: Nr,
  Uint32Array: Nr,
  Float32Array: Nr,
  Float64Array: Nr,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: k0,
  HTMLCollection: Qu,
  NodeList: Qu
}, cy = /* @__PURE__ */ Et((n, t, e) => yh in n && typeof n[yh] == "function" ? n[yh](t) : ba && ba in n && typeof n[ba] == "function" ? n[ba](t.depth, t) : "inspect" in n && typeof n.inspect == "function" ? n.inspect(t.depth, t) : "constructor" in n && _p.has(n.constructor) ? _p.get(n.constructor)(n, t) : Sp[e] ? Sp[e](n, t) : "", "inspectCustom"), hy = Object.prototype.toString;
function tc(n, t = {}) {
  const e = u0(t, tc), { customInspect: i } = e;
  let r = n === null ? "null" : typeof n;
  if (r === "object" && (r = hy.call(n).slice(8, -1)), r in kp)
    return kp[r](n, e);
  if (i && n) {
    const o = cy(n, e, r);
    if (o)
      return typeof o == "string" ? o : tc(o, e);
  }
  const s = n ? Object.getPrototypeOf(n) : !1;
  return s === Object.prototype || s === null ? xl(n, e) : n && typeof HTMLElement == "function" && n instanceof HTMLElement ? Mf(n, e) : "constructor" in n ? n.constructor !== Object ? _0(n, e) : xl(n, e) : n === Object(n) ? xl(n, e) : e.stylize(String(n), r);
}
Et(tc, "inspect");
var pi = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function $e(n, t, e, i) {
  var r = {
    colors: i,
    depth: typeof e > "u" ? 2 : e,
    showHidden: t,
    truncate: pi.truncateThreshold ? pi.truncateThreshold : 1 / 0
  };
  return tc(n, r);
}
Et($e, "inspect");
function fo(n) {
  var t = $e(n), e = Object.prototype.toString.call(n);
  if (pi.truncateThreshold && t.length >= pi.truncateThreshold) {
    if (e === "[object Function]")
      return !n.name || n.name === "" ? "[Function]" : "[Function: " + n.name + "]";
    if (e === "[object Array]")
      return "[ Array(" + n.length + ") ]";
    if (e === "[object Object]") {
      var i = Object.keys(n), r = i.length > 2 ? i.splice(0, 2).join(", ") + ", ..." : i.join(", ");
      return "{ Object (" + r + ") }";
    } else
      return t;
  } else
    return t;
}
Et(fo, "objDisplay");
function Rf(n, t) {
  var e = Fe(n, "negate"), i = Fe(n, "object"), r = t[3], s = Sc(n, t), o = e ? t[2] : t[1], a = Fe(n, "message");
  return typeof o == "function" && (o = o()), o = o || "", o = o.replace(/#\{this\}/g, function() {
    return fo(i);
  }).replace(/#\{act\}/g, function() {
    return fo(s);
  }).replace(/#\{exp\}/g, function() {
    return fo(r);
  }), a ? a + ": " + o : o;
}
Et(Rf, "getMessage");
function yr(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), e = arguments.length === 3 ? e : !0;
  for (var r in i)
    (e || r !== "object" && r !== "ssfi" && r !== "lockSsfi" && r != "message") && (t.__flags[r] = i[r]);
}
Et(yr, "transferFlags");
function Hh(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
Et(Hh, "type");
function Df() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
Et(Df, "FakeMap");
Df.prototype = {
  get: /* @__PURE__ */ Et(function(t) {
    return t[this._key];
  }, "get"),
  set: /* @__PURE__ */ Et(function(t, e) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: e,
      configurable: !0
    });
  }, "set")
};
var N0 = typeof WeakMap == "function" ? WeakMap : Df;
function Gh(n, t, e) {
  if (!e || _o(n) || _o(t))
    return null;
  var i = e.get(n);
  if (i) {
    var r = i.get(t);
    if (typeof r == "boolean")
      return r;
  }
  return null;
}
Et(Gh, "memoizeCompare");
function ml(n, t, e, i) {
  if (!(!e || _o(n) || _o(t))) {
    var r = e.get(n);
    r ? r.set(t, i) : (r = new N0(), r.set(t, i), e.set(n, r));
  }
}
Et(ml, "memoizeSet");
var C0 = Ml;
function Ml(n, t, e) {
  if (e && e.comparator)
    return Vh(n, t, e);
  var i = Bf(n, t);
  return i !== null ? i : Vh(n, t, e);
}
Et(Ml, "deepEqual");
function Bf(n, t) {
  return n === t ? n !== 0 || 1 / n === 1 / t : n !== n && // eslint-disable-line no-self-compare
  t !== t ? !0 : _o(n) || _o(t) ? !1 : null;
}
Et(Bf, "simpleEqual");
function Vh(n, t, e) {
  e = e || {}, e.memoize = e.memoize === !1 ? !1 : e.memoize || new N0();
  var i = e && e.comparator, r = Gh(n, t, e.memoize);
  if (r !== null)
    return r;
  var s = Gh(t, n, e.memoize);
  if (s !== null)
    return s;
  if (i) {
    var o = i(n, t);
    if (o === !1 || o === !0)
      return ml(n, t, e.memoize, o), o;
    var a = Bf(n, t);
    if (a !== null)
      return a;
  }
  var l = Hh(n);
  if (l !== Hh(t))
    return ml(n, t, e.memoize, !1), !1;
  ml(n, t, e.memoize, !0);
  var h = P0(n, t, l, e);
  return ml(n, t, e.memoize, h), h;
}
Et(Vh, "extensiveDeepEqual");
function P0(n, t, e, i) {
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Ml(n.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return n === t;
    case "Error":
      return jf(n, t, ["name", "message", "code"], i);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Fs(n, t, i);
    case "RegExp":
      return L0(n, t);
    case "Generator":
      return I0(n, t, i);
    case "DataView":
      return Fs(new Uint8Array(n.buffer), new Uint8Array(t.buffer), i);
    case "ArrayBuffer":
      return Fs(new Uint8Array(n), new Uint8Array(t), i);
    case "Set":
      return Yh(n, t, i);
    case "Map":
      return Yh(n, t, i);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return n.equals(t);
    case "Temporal.Duration":
      return n.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return n.toString() === t.toString();
    default:
      return O0(n, t, i);
  }
}
Et(P0, "extensiveDeepEqualByType");
function L0(n, t) {
  return n.toString() === t.toString();
}
Et(L0, "regexpEqual");
function Yh(n, t, e) {
  try {
    if (n.size !== t.size)
      return !1;
    if (n.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var i = [], r = [];
  return n.forEach(/* @__PURE__ */ Et(function(o, a) {
    i.push([o, a]);
  }, "gatherEntries")), t.forEach(/* @__PURE__ */ Et(function(o, a) {
    r.push([o, a]);
  }, "gatherEntries")), Fs(i.sort(), r.sort(), e);
}
Et(Yh, "entriesEqual");
function Fs(n, t, e) {
  var i = n.length;
  if (i !== t.length)
    return !1;
  if (i === 0)
    return !0;
  for (var r = -1; ++r < i; )
    if (Ml(n[r], t[r], e) === !1)
      return !1;
  return !0;
}
Et(Fs, "iterableEqual");
function I0(n, t, e) {
  return Fs(ec(n), ec(t), e);
}
Et(I0, "generatorEqual");
function E0(n) {
  return typeof Symbol < "u" && typeof n == "object" && typeof Symbol.iterator < "u" && typeof n[Symbol.iterator] == "function";
}
Et(E0, "hasIteratorFunction");
function Kh(n) {
  if (E0(n))
    try {
      return ec(n[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
Et(Kh, "getIteratorEntries");
function ec(n) {
  for (var t = n.next(), e = [t.value]; t.done === !1; )
    t = n.next(), e.push(t.value);
  return e;
}
Et(ec, "getGeneratorEntries");
function Xh(n) {
  var t = [];
  for (var e in n)
    t.push(e);
  return t;
}
Et(Xh, "getEnumerableKeys");
function Jh(n) {
  for (var t = [], e = Object.getOwnPropertySymbols(n), i = 0; i < e.length; i += 1) {
    var r = e[i];
    Object.getOwnPropertyDescriptor(n, r).enumerable && t.push(r);
  }
  return t;
}
Et(Jh, "getEnumerableSymbols");
function jf(n, t, e, i) {
  var r = e.length;
  if (r === 0)
    return !0;
  for (var s = 0; s < r; s += 1)
    if (Ml(n[e[s]], t[e[s]], i) === !1)
      return !1;
  return !0;
}
Et(jf, "keysEqual");
function O0(n, t, e) {
  var i = Xh(n), r = Xh(t), s = Jh(n), o = Jh(t);
  if (i = i.concat(s), r = r.concat(o), i.length && i.length === r.length)
    return Fs(Zh(i).sort(), Zh(r).sort()) === !1 ? !1 : jf(n, t, i, e);
  var a = Kh(n), l = Kh(t);
  return a.length && a.length === l.length ? (a.sort(), l.sort(), Fs(a, l, e)) : i.length === 0 && a.length === 0 && r.length === 0 && l.length === 0;
}
Et(O0, "objectEqual");
function _o(n) {
  return n === null || typeof n != "object";
}
Et(_o, "isPrimitive");
function Zh(n) {
  return n.map(/* @__PURE__ */ Et(function(e) {
    return typeof e == "symbol" ? e.toString() : e;
  }, "mapSymbol"));
}
Et(Zh, "mapSymbols");
function kc(n, t) {
  return typeof n > "u" || n === null ? !1 : t in Object(n);
}
Et(kc, "hasProperty");
function T0(n) {
  return n.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((i) => {
    if (i === "constructor" || i === "__proto__" || i === "prototype")
      return {};
    const s = /^\[(\d+)\]$/.exec(i);
    let o = null;
    return s ? o = { i: parseFloat(s[1]) } : o = { p: i.replace(/\\([.[\]])/g, "$1") }, o;
  });
}
Et(T0, "parsePath");
function Qh(n, t, e) {
  let i = n, r = null;
  e = typeof e > "u" ? t.length : e;
  for (let s = 0; s < e; s++) {
    const o = t[s];
    i && (typeof o.p > "u" ? i = i[o.i] : i = i[o.p], s === e - 1 && (r = i));
  }
  return r;
}
Et(Qh, "internalGetPathValue");
function qf(n, t) {
  const e = T0(t), i = e[e.length - 1], r = {
    parent: e.length > 1 ? Qh(n, e, e.length - 1) : n,
    name: i.p || i.i,
    value: Qh(n, e)
  };
  return r.exists = kc(r.parent, r.name), r;
}
Et(qf, "getPathInfo");
function at(n, t, e, i) {
  return Fe(this, "ssfi", e || at), Fe(this, "lockSsfi", i), Fe(this, "object", n), Fe(this, "message", t), Fe(this, "eql", pi.deepEqual || C0), Pa(this);
}
Et(at, "Assertion");
Object.defineProperty(at, "includeStack", {
  get: function() {
    return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), pi.includeStack;
  },
  set: function(n) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), pi.includeStack = n;
  }
});
Object.defineProperty(at, "showDiff", {
  get: function() {
    return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), pi.showDiff;
  },
  set: function(n) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), pi.showDiff = n;
  }
});
at.addProperty = function(n, t) {
  zf(this.prototype, n, t);
};
at.addMethod = function(n, t) {
  $f(this.prototype, n, t);
};
at.addChainableMethod = function(n, t, e) {
  Hf(this.prototype, n, t, e);
};
at.overwriteProperty = function(n, t) {
  Uf(this.prototype, n, t);
};
at.overwriteMethod = function(n, t) {
  Wf(this.prototype, n, t);
};
at.overwriteChainableMethod = function(n, t, e) {
  Gf(this.prototype, n, t, e);
};
at.prototype.assert = function(n, t, e, i, r, s) {
  var o = Ff(this, arguments);
  if (s !== !1 && (s = !0), i === void 0 && r === void 0 && (s = !1), pi.showDiff !== !0 && (s = !1), !o) {
    t = Rf(this, arguments);
    var a = Sc(this, arguments), l = {
      actual: a,
      expected: i,
      showDiff: s
    }, h = Kf(this, arguments);
    throw h && (l.operator = h), new Ye(
      t,
      l,
      pi.includeStack ? this.assert : Fe(this, "ssfi")
    );
  }
};
Object.defineProperty(
  at.prototype,
  "_obj",
  {
    get: function() {
      return Fe(this, "object");
    },
    set: function(n) {
      Fe(this, "object", n);
    }
  }
);
function Rl() {
  return pi.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
Et(Rl, "isProxyEnabled");
function zf(n, t, e) {
  e = e === void 0 ? function() {
  } : e, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ Et(function i() {
        !Rl() && !Fe(this, "lockSsfi") && Fe(this, "ssfi", i);
        var r = e.call(this);
        if (r !== void 0)
          return r;
        var s = new at();
        return yr(this, s), s;
      }, "propertyGetter"),
      configurable: !0
    }
  );
}
Et(zf, "addProperty");
var fy = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Dl(n, t, e) {
  return fy.configurable && Object.defineProperty(n, "length", {
    get: function() {
      throw Error(e ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".');
    }
  }), n;
}
Et(Dl, "addLengthGuard");
function F0(n) {
  var t = Object.getOwnPropertyNames(n);
  function e(r) {
    t.indexOf(r) === -1 && t.push(r);
  }
  Et(e, "addProperty");
  for (var i = Object.getPrototypeOf(n); i !== null; )
    Object.getOwnPropertyNames(i).forEach(e), i = Object.getPrototypeOf(i);
  return t;
}
Et(F0, "getProperties");
var Ap = ["__flags", "__methods", "_obj", "assert"];
function Pa(n, t) {
  return Rl() ? new Proxy(n, {
    get: /* @__PURE__ */ Et(function e(i, r) {
      if (typeof r == "string" && pi.proxyExcludedKeys.indexOf(r) === -1 && !Reflect.has(i, r)) {
        if (t)
          throw Error("Invalid Chai property: " + t + "." + r + '. See docs for proper usage of "' + t + '".');
        var s = null, o = 4;
        throw F0(i).forEach(function(a) {
          if (!Object.prototype.hasOwnProperty(a) && Ap.indexOf(a) === -1) {
            var l = M0(
              r,
              a,
              o
            );
            l < o && (s = a, o = l);
          }
        }), Error(s !== null ? "Invalid Chai property: " + r + '. Did you mean "' + s + '"?' : "Invalid Chai property: " + r);
      }
      return Ap.indexOf(r) === -1 && !Fe(i, "lockSsfi") && Fe(i, "ssfi", e), Reflect.get(i, r);
    }, "proxyGetter")
  }) : n;
}
Et(Pa, "proxify");
function M0(n, t, e) {
  if (Math.abs(n.length - t.length) >= e)
    return e;
  for (var i = [], r = 0; r <= n.length; r++)
    i[r] = Array(t.length + 1).fill(0), i[r][0] = r;
  for (var s = 0; s < t.length; s++)
    i[0][s] = s;
  for (var r = 1; r <= n.length; r++)
    for (var o = n.charCodeAt(r - 1), s = 1; s <= t.length; s++) {
      if (Math.abs(r - s) >= e) {
        i[r][s] = e;
        continue;
      }
      i[r][s] = Math.min(
        i[r - 1][s] + 1,
        i[r][s - 1] + 1,
        i[r - 1][s - 1] + (o === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  return i[n.length][t.length];
}
Et(M0, "stringDistanceCapped");
function $f(n, t, e) {
  var i = /* @__PURE__ */ Et(function() {
    Fe(this, "lockSsfi") || Fe(this, "ssfi", i);
    var r = e.apply(this, arguments);
    if (r !== void 0)
      return r;
    var s = new at();
    return yr(this, s), s;
  }, "methodWrapper");
  Dl(i, t, !1), n[t] = Pa(i, t);
}
Et($f, "addMethod");
function Uf(n, t, e) {
  var i = Object.getOwnPropertyDescriptor(n, t), r = /* @__PURE__ */ Et(function() {
  }, "_super");
  i && typeof i.get == "function" && (r = i.get), Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ Et(function s() {
        !Rl() && !Fe(this, "lockSsfi") && Fe(this, "ssfi", s);
        var o = Fe(this, "lockSsfi");
        Fe(this, "lockSsfi", !0);
        var a = e(r).call(this);
        if (Fe(this, "lockSsfi", o), a !== void 0)
          return a;
        var l = new at();
        return yr(this, l), l;
      }, "overwritingPropertyGetter"),
      configurable: !0
    }
  );
}
Et(Uf, "overwriteProperty");
function Wf(n, t, e) {
  var i = n[t], r = /* @__PURE__ */ Et(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  i && typeof i == "function" && (r = i);
  var s = /* @__PURE__ */ Et(function() {
    Fe(this, "lockSsfi") || Fe(this, "ssfi", s);
    var o = Fe(this, "lockSsfi");
    Fe(this, "lockSsfi", !0);
    var a = e(r).apply(this, arguments);
    if (Fe(this, "lockSsfi", o), a !== void 0)
      return a;
    var l = new at();
    return yr(this, l), l;
  }, "overwritingMethodWrapper");
  Dl(s, t, !1), n[t] = Pa(s, t);
}
Et(Wf, "overwriteMethod");
var dy = typeof Object.setPrototypeOf == "function", Np = /* @__PURE__ */ Et(function() {
}, "testFn"), py = Object.getOwnPropertyNames(Np).filter(function(n) {
  var t = Object.getOwnPropertyDescriptor(Np, n);
  return typeof t != "object" ? !0 : !t.configurable;
}), gy = Function.prototype.call, my = Function.prototype.apply;
function Hf(n, t, e, i) {
  typeof i != "function" && (i = /* @__PURE__ */ Et(function() {
  }, "chainingBehavior"));
  var r = {
    method: e,
    chainingBehavior: i
  };
  n.__methods || (n.__methods = {}), n.__methods[t] = r, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ Et(function() {
        r.chainingBehavior.call(this);
        var o = /* @__PURE__ */ Et(function() {
          Fe(this, "lockSsfi") || Fe(this, "ssfi", o);
          var h = r.method.apply(this, arguments);
          if (h !== void 0)
            return h;
          var u = new at();
          return yr(this, u), u;
        }, "chainableMethodWrapper");
        if (Dl(o, t, !0), dy) {
          var a = Object.create(this);
          a.call = gy, a.apply = my, Object.setPrototypeOf(o, a);
        } else {
          var l = Object.getOwnPropertyNames(n);
          l.forEach(function(h) {
            if (py.indexOf(h) === -1) {
              var u = Object.getOwnPropertyDescriptor(n, h);
              Object.defineProperty(o, h, u);
            }
          });
        }
        return yr(this, o), Pa(o);
      }, "chainableMethodGetter"),
      configurable: !0
    }
  );
}
Et(Hf, "addChainableMethod");
function Gf(n, t, e, i) {
  var r = n.__methods[t], s = r.chainingBehavior;
  r.chainingBehavior = /* @__PURE__ */ Et(function() {
    var l = i(s).call(this);
    if (l !== void 0)
      return l;
    var h = new at();
    return yr(this, h), h;
  }, "overwritingChainableMethodGetter");
  var o = r.method;
  r.method = /* @__PURE__ */ Et(function() {
    var l = e(o).apply(this, arguments);
    if (l !== void 0)
      return l;
    var h = new at();
    return yr(this, h), h;
  }, "overwritingChainableMethodWrapper");
}
Et(Gf, "overwriteChainableMethod");
function nc(n, t) {
  return $e(n) < $e(t) ? -1 : 1;
}
Et(nc, "compareByInspect");
function Vf(n) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(n).filter(function(t) {
    return Object.getOwnPropertyDescriptor(n, t).enumerable;
  });
}
Et(Vf, "getOwnEnumerablePropertySymbols");
function Yf(n) {
  return Object.keys(n).concat(Vf(n));
}
Et(Yf, "getOwnEnumerableProperties");
function R0(n) {
  return n !== n;
}
Et(R0, "_isNaN");
var ic = Number.isNaN || R0;
function D0(n) {
  var t = sn(n), e = ["Array", "Object", "Function"];
  return e.indexOf(t) !== -1;
}
Et(D0, "isObjectType");
function Kf(n, t) {
  var e = Fe(n, "operator"), i = Fe(n, "negate"), r = t[3], s = i ? t[2] : t[1];
  if (e)
    return e;
  if (typeof s == "function" && (s = s()), s = s || "", !!s && !/\shave\s/.test(s)) {
    var o = D0(r);
    return /\snot\s/.test(s) ? o ? "notDeepStrictEqual" : "notStrictEqual" : o ? "deepStrictEqual" : "strictEqual";
  }
}
Et(Kf, "getOperator");
function Ac(n) {
  return n.name;
}
Et(Ac, "getName");
function rc(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
Et(rc, "isRegExp");
function Gn(n) {
  return ["Number", "BigInt"].includes(sn(n));
}
Et(Gn, "isNumeric");
var { flag: Nt } = Zu;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(n) {
  at.addProperty(n);
});
at.addProperty("not", function() {
  Nt(this, "negate", !0);
});
at.addProperty("deep", function() {
  Nt(this, "deep", !0);
});
at.addProperty("nested", function() {
  Nt(this, "nested", !0);
});
at.addProperty("own", function() {
  Nt(this, "own", !0);
});
at.addProperty("ordered", function() {
  Nt(this, "ordered", !0);
});
at.addProperty("any", function() {
  Nt(this, "any", !0), Nt(this, "all", !1);
});
at.addProperty("all", function() {
  Nt(this, "all", !0), Nt(this, "any", !1);
});
var Cp = {
  function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function Xf(n, t) {
  t && Nt(this, "message", t), n = n.toLowerCase();
  var e = Nt(this, "object"), i = ~["a", "e", "i", "o", "u"].indexOf(n.charAt(0)) ? "an " : "a ";
  const r = sn(e).toLowerCase();
  Cp.function.includes(n) ? this.assert(
    Cp[n].includes(r),
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  ) : this.assert(
    n === r,
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  );
}
Et(Xf, "an");
at.addChainableMethod("an", Xf);
at.addChainableMethod("a", Xf);
function B0(n, t) {
  return ic(n) && ic(t) || n === t;
}
Et(B0, "SameValueZero");
function Bl() {
  Nt(this, "contains", !0);
}
Et(Bl, "includeChainingBehavior");
function jl(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = sn(e).toLowerCase(), r = Nt(this, "message"), s = Nt(this, "negate"), o = Nt(this, "ssfi"), a = Nt(this, "deep"), l = a ? "deep " : "", h = a ? Nt(this, "eql") : B0;
  r = r ? r + ": " : "";
  var u = !1;
  switch (i) {
    case "string":
      u = e.indexOf(n) !== -1;
      break;
    case "weakset":
      if (a)
        throw new Ye(
          r + "unable to use .deep.include with WeakSet",
          void 0,
          o
        );
      u = e.has(n);
      break;
    case "map":
      e.forEach(function(m) {
        u = u || h(m, n);
      });
      break;
    case "set":
      a ? e.forEach(function(m) {
        u = u || h(m, n);
      }) : u = e.has(n);
      break;
    case "array":
      a ? u = e.some(function(m) {
        return h(m, n);
      }) : u = e.indexOf(n) !== -1;
      break;
    default:
      if (n !== Object(n))
        throw new Ye(
          r + "the given combination of arguments (" + i + " and " + sn(n).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + sn(n).toLowerCase(),
          void 0,
          o
        );
      var d = Object.keys(n), p = null, f = 0;
      if (d.forEach(function(m) {
        var b = new at(e);
        if (yr(this, b, !0), Nt(b, "lockSsfi", !0), !s || d.length === 1) {
          b.property(m, n[m]);
          return;
        }
        try {
          b.property(m, n[m]);
        } catch (x) {
          if (!Ri.compatibleConstructor(x, Ye))
            throw x;
          p === null && (p = x), f++;
        }
      }, this), s && d.length > 1 && f === d.length)
        throw p;
      return;
  }
  this.assert(
    u,
    "expected #{this} to " + l + "include " + $e(n),
    "expected #{this} to not " + l + "include " + $e(n)
  );
}
Et(jl, "include");
at.addChainableMethod("include", jl, Bl);
at.addChainableMethod("contain", jl, Bl);
at.addChainableMethod("contains", jl, Bl);
at.addChainableMethod("includes", jl, Bl);
at.addProperty("ok", function() {
  this.assert(
    Nt(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
at.addProperty("true", function() {
  this.assert(
    Nt(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !Nt(this, "negate")
  );
});
at.addProperty("numeric", function() {
  const n = Nt(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(sn(n)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !Nt(this, "negate")
  );
});
at.addProperty("callable", function() {
  const n = Nt(this, "object"), t = Nt(this, "ssfi"), e = Nt(this, "message"), i = e ? `${e}: ` : "", r = Nt(this, "negate"), s = r ? `${i}expected ${$e(n)} not to be a callable function` : `${i}expected ${$e(n)} to be a callable function`, o = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(sn(n));
  if (o && r || !o && !r)
    throw new Ye(
      s,
      void 0,
      t
    );
});
at.addProperty("false", function() {
  this.assert(
    Nt(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!Nt(this, "negate")
  );
});
at.addProperty("null", function() {
  this.assert(
    Nt(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
at.addProperty("undefined", function() {
  this.assert(
    Nt(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
at.addProperty("NaN", function() {
  this.assert(
    ic(Nt(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function Jf() {
  var n = Nt(this, "object");
  this.assert(
    n != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
Et(Jf, "assertExist");
at.addProperty("exist", Jf);
at.addProperty("exists", Jf);
at.addProperty("empty", function() {
  var n = Nt(this, "object"), t = Nt(this, "ssfi"), e = Nt(this, "message"), i;
  switch (e = e ? e + ": " : "", sn(n).toLowerCase()) {
    case "array":
    case "string":
      i = n.length;
      break;
    case "map":
    case "set":
      i = n.size;
      break;
    case "weakmap":
    case "weakset":
      throw new Ye(
        e + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function":
      var r = e + ".empty was passed a function " + Ac(n);
      throw new Ye(r.trim(), void 0, t);
    default:
      if (n !== Object(n))
        throw new Ye(
          e + ".empty was passed non-string primitive " + $e(n),
          void 0,
          t
        );
      i = Object.keys(n).length;
  }
  this.assert(
    i === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function Zf() {
  var n = Nt(this, "object"), t = sn(n);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
Et(Zf, "checkArguments");
at.addProperty("arguments", Zf);
at.addProperty("Arguments", Zf);
function Nc(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object");
  if (Nt(this, "deep")) {
    var i = Nt(this, "lockSsfi");
    Nt(this, "lockSsfi", !0), this.eql(n), Nt(this, "lockSsfi", i);
  } else
    this.assert(
      n === e,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      n,
      this._obj,
      !0
    );
}
Et(Nc, "assertEqual");
at.addMethod("equal", Nc);
at.addMethod("equals", Nc);
at.addMethod("eq", Nc);
function Qf(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "eql");
  this.assert(
    e(n, Nt(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    n,
    this._obj,
    !0
  );
}
Et(Qf, "assertEql");
at.addMethod("eql", Qf);
at.addMethod("eqls", Qf);
function Cc(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "doLength"), r = Nt(this, "message"), s = r ? r + ": " : "", o = Nt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase();
  if (i && a !== "map" && a !== "set" && new at(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    throw new Ye(s + "the argument to above must be a date", void 0, o);
  if (!Gn(n) && (i || Gn(e)))
    throw new Ye(s + "the argument to above must be a number", void 0, o);
  if (!i && a !== "date" && !Gn(e)) {
    var h = a === "string" ? "'" + e + "'" : e;
    throw new Ye(s + "expected " + h + " to be a number or a date", void 0, o);
  }
  if (i) {
    var u = "length", d;
    a === "map" || a === "set" ? (u = "size", d = e.size) : d = e.length, this.assert(
      d > n,
      "expected #{this} to have a " + u + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + u + " above #{exp}",
      n,
      d
    );
  } else
    this.assert(
      e > n,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n
    );
}
Et(Cc, "assertAbove");
at.addMethod("above", Cc);
at.addMethod("gt", Cc);
at.addMethod("greaterThan", Cc);
function Pc(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "doLength"), r = Nt(this, "message"), s = r ? r + ": " : "", o = Nt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new at(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to least must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to least must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f >= n,
      "expected #{this} to have a " + p + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e >= n,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n
    );
}
Et(Pc, "assertLeast");
at.addMethod("least", Pc);
at.addMethod("gte", Pc);
at.addMethod("greaterThanOrEqual", Pc);
function Lc(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "doLength"), r = Nt(this, "message"), s = r ? r + ": " : "", o = Nt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new at(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to below must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to below must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f < n,
      "expected #{this} to have a " + p + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e < n,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n
    );
}
Et(Lc, "assertBelow");
at.addMethod("below", Lc);
at.addMethod("lt", Lc);
at.addMethod("lessThan", Lc);
function Ic(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "doLength"), r = Nt(this, "message"), s = r ? r + ": " : "", o = Nt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new at(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to most must be a date";
  else if (!Gn(n) && (i || Gn(e)))
    h = s + "the argument to most must be a number";
  else if (!i && a !== "date" && !Gn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ye(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f <= n,
      "expected #{this} to have a " + p + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + p + " above #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e <= n,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n
    );
}
Et(Ic, "assertMost");
at.addMethod("most", Ic);
at.addMethod("lte", Ic);
at.addMethod("lessThanOrEqual", Ic);
at.addMethod("within", function(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Nt(this, "doLength"), s = Nt(this, "message"), o = s ? s + ": " : "", a = Nt(this, "ssfi"), l = sn(i).toLowerCase(), h = sn(n).toLowerCase(), u = sn(t).toLowerCase(), d, p = !0, f = h === "date" && u === "date" ? n.toISOString() + ".." + t.toISOString() : n + ".." + t;
  if (r && l !== "map" && l !== "set" && new at(i, s, a, !0).to.have.property("length"), !r && l === "date" && (h !== "date" || u !== "date"))
    d = o + "the arguments to within must be dates";
  else if ((!Gn(n) || !Gn(t)) && (r || Gn(i)))
    d = o + "the arguments to within must be numbers";
  else if (!r && l !== "date" && !Gn(i)) {
    var m = l === "string" ? "'" + i + "'" : i;
    d = o + "expected " + m + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Ye(d, void 0, a);
  if (r) {
    var b = "length", x;
    l === "map" || l === "set" ? (b = "size", x = i.size) : x = i.length, this.assert(
      x >= n && x <= t,
      "expected #{this} to have a " + b + " within " + f,
      "expected #{this} to not have a " + b + " within " + f
    );
  } else
    this.assert(
      i >= n && i <= t,
      "expected #{this} to be within " + f,
      "expected #{this} to not be within " + f
    );
});
function td(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "ssfi"), r = Nt(this, "message");
  try {
    var s = e instanceof n;
  } catch (a) {
    throw a instanceof TypeError ? (r = r ? r + ": " : "", new Ye(
      r + "The instanceof assertion needs a constructor but " + sn(n) + " was given.",
      void 0,
      i
    )) : a;
  }
  var o = Ac(n);
  o == null && (o = "an unnamed constructor"), this.assert(
    s,
    "expected #{this} to be an instance of " + o,
    "expected #{this} to not be an instance of " + o
  );
}
Et(td, "assertInstanceOf");
at.addMethod("instanceof", td);
at.addMethod("instanceOf", td);
function ed(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "nested"), r = Nt(this, "own"), s = Nt(this, "message"), o = Nt(this, "object"), a = Nt(this, "ssfi"), l = typeof n;
  if (s = s ? s + ": " : "", i) {
    if (l !== "string")
      throw new Ye(
        s + "the argument to property must be a string when using nested syntax",
        void 0,
        a
      );
  } else if (l !== "string" && l !== "number" && l !== "symbol")
    throw new Ye(
      s + "the argument to property must be a string, number, or symbol",
      void 0,
      a
    );
  if (i && r)
    throw new Ye(
      s + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      a
    );
  if (o == null)
    throw new Ye(
      s + "Target cannot be null or undefined.",
      void 0,
      a
    );
  var h = Nt(this, "deep"), u = Nt(this, "negate"), d = i ? qf(o, n) : null, p = i ? d.value : o[n], f = h ? Nt(this, "eql") : (x, y) => x === y, m = "";
  h && (m += "deep "), r && (m += "own "), i && (m += "nested "), m += "property ";
  var b;
  r ? b = Object.prototype.hasOwnProperty.call(o, n) : i ? b = d.exists : b = kc(o, n), (!u || arguments.length === 1) && this.assert(
    b,
    "expected #{this} to have " + m + $e(n),
    "expected #{this} to not have " + m + $e(n)
  ), arguments.length > 1 && this.assert(
    b && f(t, p),
    "expected #{this} to have " + m + $e(n) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + m + $e(n) + " of #{act}",
    t,
    p
  ), Nt(this, "object", p);
}
Et(ed, "assertProperty");
at.addMethod("property", ed);
function nd(n, t, e) {
  Nt(this, "own", !0), ed.apply(this, arguments);
}
Et(nd, "assertOwnProperty");
at.addMethod("ownProperty", nd);
at.addMethod("haveOwnProperty", nd);
function id(n, t, e) {
  typeof t == "string" && (e = t, t = null), e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Object.getOwnPropertyDescriptor(Object(i), n), s = Nt(this, "eql");
  r && t ? this.assert(
    s(t, r),
    "expected the own property descriptor for " + $e(n) + " on #{this} to match " + $e(t) + ", got " + $e(r),
    "expected the own property descriptor for " + $e(n) + " on #{this} to not match " + $e(t),
    t,
    r,
    !0
  ) : this.assert(
    r,
    "expected #{this} to have an own property descriptor for " + $e(n),
    "expected #{this} to not have an own property descriptor for " + $e(n)
  ), Nt(this, "object", r);
}
Et(id, "assertOwnPropertyDescriptor");
at.addMethod("ownPropertyDescriptor", id);
at.addMethod("haveOwnPropertyDescriptor", id);
function rd() {
  Nt(this, "doLength", !0);
}
Et(rd, "assertLengthChain");
function sd(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = sn(e).toLowerCase(), r = Nt(this, "message"), s = Nt(this, "ssfi"), o = "length", a;
  switch (i) {
    case "map":
    case "set":
      o = "size", a = e.size;
      break;
    default:
      new at(e, r, s, !0).to.have.property("length"), a = e.length;
  }
  this.assert(
    a == n,
    "expected #{this} to have a " + o + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + o + " of #{act}",
    n,
    a
  );
}
Et(sd, "assertLength");
at.addChainableMethod("length", sd, rd);
at.addChainableMethod("lengthOf", sd, rd);
function od(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object");
  this.assert(
    n.exec(e),
    "expected #{this} to match " + n,
    "expected #{this} not to match " + n
  );
}
Et(od, "assertMatch");
at.addMethod("match", od);
at.addMethod("matches", od);
at.addMethod("string", function(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "message"), r = Nt(this, "ssfi");
  new at(e, i, r, !0).is.a("string"), this.assert(
    ~e.indexOf(n),
    "expected #{this} to contain " + $e(n),
    "expected #{this} to not contain " + $e(n)
  );
});
function ad(n) {
  var t = Nt(this, "object"), e = sn(t), i = sn(n), r = Nt(this, "ssfi"), s = Nt(this, "deep"), o, a = "", l, h = !0, u = Nt(this, "message");
  u = u ? u + ": " : "";
  var d = u + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (e === "Map" || e === "Set")
    a = s ? "deeply " : "", l = [], t.forEach(function(v, k) {
      l.push(k);
    }), i !== "Array" && (n = Array.prototype.slice.call(arguments));
  else {
    switch (l = Yf(t), i) {
      case "Array":
        if (arguments.length > 1)
          throw new Ye(d, void 0, r);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new Ye(d, void 0, r);
        n = Object.keys(n);
        break;
      default:
        n = Array.prototype.slice.call(arguments);
    }
    n = n.map(function(v) {
      return typeof v == "symbol" ? v : String(v);
    });
  }
  if (!n.length)
    throw new Ye(u + "keys required", void 0, r);
  var p = n.length, f = Nt(this, "any"), m = Nt(this, "all"), b = n, x = s ? Nt(this, "eql") : (v, k) => v === k;
  if (!f && !m && (m = !0), f && (h = b.some(function(v) {
    return l.some(function(k) {
      return x(v, k);
    });
  })), m && (h = b.every(function(v) {
    return l.some(function(k) {
      return x(v, k);
    });
  }), Nt(this, "contains") || (h = h && n.length == l.length)), p > 1) {
    n = n.map(function(v) {
      return $e(v);
    });
    var y = n.pop();
    m && (o = n.join(", ") + ", and " + y), f && (o = n.join(", ") + ", or " + y);
  } else
    o = $e(n[0]);
  o = (p > 1 ? "keys " : "key ") + o, o = (Nt(this, "contains") ? "contain " : "have ") + o, this.assert(
    h,
    "expected #{this} to " + a + o,
    "expected #{this} to not " + a + o,
    b.slice(0).sort(nc),
    l.sort(nc),
    !0
  );
}
Et(ad, "assertKeys");
at.addMethod("keys", ad);
at.addMethod("key", ad);
function Ec(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Nt(this, "ssfi"), s = Nt(this, "message"), o = Nt(this, "negate") || !1;
  new at(i, s, r, !0).is.a("function"), (rc(n) || typeof n == "string") && (t = n, n = null);
  let a, l = !1;
  try {
    i();
  } catch (v) {
    l = !0, a = v;
  }
  var h = n === void 0 && t === void 0, u = !!(n && t), d = !1, p = !1;
  if (h || !h && !o) {
    var f = "an error";
    n instanceof Error ? f = "#{exp}" : n && (f = Ri.getConstructorName(n));
    let v = a;
    if (a instanceof Error)
      v = a.toString();
    else if (typeof a == "string")
      v = a;
    else if (a && (typeof a == "object" || typeof a == "function"))
      try {
        v = Ri.getConstructorName(a);
      } catch {
      }
    this.assert(
      l,
      "expected #{this} to throw " + f,
      "expected #{this} to not throw an error but #{act} was thrown",
      n && n.toString(),
      v
    );
  }
  if (n && a) {
    if (n instanceof Error) {
      var m = Ri.compatibleInstance(a, n);
      m === o && (u && o ? d = !0 : this.assert(
        o,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (a && !o ? " but #{act} was thrown" : ""),
        n.toString(),
        a.toString()
      ));
    }
    var b = Ri.compatibleConstructor(a, n);
    b === o && (u && o ? d = !0 : this.assert(
      o,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
      n instanceof Error ? n.toString() : n && Ri.getConstructorName(n),
      a instanceof Error ? a.toString() : a && Ri.getConstructorName(a)
    ));
  }
  if (a && t !== void 0 && t !== null) {
    var x = "including";
    rc(t) && (x = "matching");
    var y = Ri.compatibleMessage(a, t);
    y === o && (u && o ? p = !0 : this.assert(
      o,
      "expected #{this} to throw error " + x + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + x + " #{exp}",
      t,
      Ri.getMessage(a)
    ));
  }
  d && p && this.assert(
    o,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
    n instanceof Error ? n.toString() : n && Ri.getConstructorName(n),
    a instanceof Error ? a.toString() : a && Ri.getConstructorName(a)
  ), Nt(this, "object", a);
}
Et(Ec, "assertThrows");
at.addMethod("throw", Ec);
at.addMethod("throws", Ec);
at.addMethod("Throw", Ec);
function ld(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "itself"), r = typeof e == "function" && !i ? e.prototype[n] : e[n];
  this.assert(
    typeof r == "function",
    "expected #{this} to respond to " + $e(n),
    "expected #{this} to not respond to " + $e(n)
  );
}
Et(ld, "respondTo");
at.addMethod("respondTo", ld);
at.addMethod("respondsTo", ld);
at.addProperty("itself", function() {
  Nt(this, "itself", !0);
});
function ud(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = n(e);
  this.assert(
    i,
    "expected #{this} to satisfy " + fo(n),
    "expected #{this} to not satisfy" + fo(n),
    !Nt(this, "negate"),
    i
  );
}
Et(ud, "satisfy");
at.addMethod("satisfy", ud);
at.addMethod("satisfies", ud);
function cd(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Nt(this, "message"), s = Nt(this, "ssfi");
  new at(i, r, s, !0).is.numeric;
  let o = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new Ye(r ? `${r}: ${o}` : o, void 0, s);
  if (new at(t, r, s, !0).is.numeric, o = "A `expected` value is required for `closeTo`", n == null)
    throw new Ye(r ? `${r}: ${o}` : o, void 0, s);
  new at(n, r, s, !0).is.numeric;
  const a = /* @__PURE__ */ Et((l) => l < 0n ? -l : l, "abs");
  this.assert(
    a(i - n) <= t,
    "expected #{this} to be close to " + n + " +/- " + t,
    "expected #{this} not to be close to " + n + " +/- " + t
  );
}
Et(cd, "closeTo");
at.addMethod("closeTo", cd);
at.addMethod("approximately", cd);
function j0(n, t, e, i, r) {
  let s = Array.from(t), o = Array.from(n);
  if (!i) {
    if (o.length !== s.length)
      return !1;
    s = s.slice();
  }
  return o.every(function(a, l) {
    if (r)
      return e ? e(a, s[l]) : a === s[l];
    if (!e) {
      var h = s.indexOf(a);
      return h === -1 ? !1 : (i || s.splice(h, 1), !0);
    }
    return s.some(function(u, d) {
      return e(a, u) ? (i || s.splice(d, 1), !0) : !1;
    });
  });
}
Et(j0, "isSubsetOf");
at.addMethod("members", function(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "message"), r = Nt(this, "ssfi");
  new at(e, i, r, !0).to.be.iterable, new at(n, i, r, !0).to.be.iterable;
  var s = Nt(this, "contains"), o = Nt(this, "ordered"), a, l, h;
  s ? (a = o ? "an ordered superset" : "a superset", l = "expected #{this} to be " + a + " of #{exp}", h = "expected #{this} to not be " + a + " of #{exp}") : (a = o ? "ordered members" : "members", l = "expected #{this} to have the same " + a + " as #{exp}", h = "expected #{this} to not have the same " + a + " as #{exp}");
  var u = Nt(this, "deep") ? Nt(this, "eql") : void 0;
  this.assert(
    j0(n, e, u, s, o),
    l,
    h,
    n,
    e,
    !0
  );
});
at.addProperty("iterable", function(n) {
  n && Nt(this, "message", n);
  var t = Nt(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function q0(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "object"), i = Nt(this, "message"), r = Nt(this, "ssfi"), s = Nt(this, "contains"), o = Nt(this, "deep"), a = Nt(this, "eql");
  new at(n, i, r, !0).to.be.an("array"), s ? this.assert(
    n.some(function(l) {
      return e.indexOf(l) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    n,
    e
  ) : o ? this.assert(
    n.some(function(l) {
      return a(e, l);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    n,
    e
  ) : this.assert(
    n.indexOf(e) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    n,
    e
  );
}
Et(q0, "oneOf");
at.addMethod("oneOf", q0);
function hd(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Nt(this, "message"), s = Nt(this, "ssfi");
  new at(i, r, s, !0).is.a("function");
  var o;
  t ? (new at(n, r, s, !0).to.have.property(t), o = n[t]) : (new at(n, r, s, !0).is.a("function"), o = n()), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  Nt(this, "deltaMsgObj", l), Nt(this, "initialDeltaValue", o), Nt(this, "finalDeltaValue", a), Nt(this, "deltaBehavior", "change"), Nt(this, "realDelta", a !== o), this.assert(
    o !== a,
    "expected " + l + " to change",
    "expected " + l + " to not change"
  );
}
Et(hd, "assertChanges");
at.addMethod("change", hd);
at.addMethod("changes", hd);
function fd(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Nt(this, "message"), s = Nt(this, "ssfi");
  new at(i, r, s, !0).is.a("function");
  var o;
  t ? (new at(n, r, s, !0).to.have.property(t), o = n[t]) : (new at(n, r, s, !0).is.a("function"), o = n()), new at(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  Nt(this, "deltaMsgObj", l), Nt(this, "initialDeltaValue", o), Nt(this, "finalDeltaValue", a), Nt(this, "deltaBehavior", "increase"), Nt(this, "realDelta", a - o), this.assert(
    a - o > 0,
    "expected " + l + " to increase",
    "expected " + l + " to not increase"
  );
}
Et(fd, "assertIncreases");
at.addMethod("increase", fd);
at.addMethod("increases", fd);
function dd(n, t, e) {
  e && Nt(this, "message", e);
  var i = Nt(this, "object"), r = Nt(this, "message"), s = Nt(this, "ssfi");
  new at(i, r, s, !0).is.a("function");
  var o;
  t ? (new at(n, r, s, !0).to.have.property(t), o = n[t]) : (new at(n, r, s, !0).is.a("function"), o = n()), new at(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  Nt(this, "deltaMsgObj", l), Nt(this, "initialDeltaValue", o), Nt(this, "finalDeltaValue", a), Nt(this, "deltaBehavior", "decrease"), Nt(this, "realDelta", o - a), this.assert(
    a - o < 0,
    "expected " + l + " to decrease",
    "expected " + l + " to not decrease"
  );
}
Et(dd, "assertDecreases");
at.addMethod("decrease", dd);
at.addMethod("decreases", dd);
function z0(n, t) {
  t && Nt(this, "message", t);
  var e = Nt(this, "deltaMsgObj"), i = Nt(this, "initialDeltaValue"), r = Nt(this, "finalDeltaValue"), s = Nt(this, "deltaBehavior"), o = Nt(this, "realDelta"), a;
  s === "change" ? a = Math.abs(r - i) === Math.abs(n) : a = o === Math.abs(n), this.assert(
    a,
    "expected " + e + " to " + s + " by " + n,
    "expected " + e + " to not " + s + " by " + n
  );
}
Et(z0, "assertDelta");
at.addMethod("by", z0);
at.addProperty("extensible", function() {
  var n = Nt(this, "object"), t = n === Object(n) && Object.isExtensible(n);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
at.addProperty("sealed", function() {
  var n = Nt(this, "object"), t = n === Object(n) ? Object.isSealed(n) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
at.addProperty("frozen", function() {
  var n = Nt(this, "object"), t = n === Object(n) ? Object.isFrozen(n) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
at.addProperty("finite", function(n) {
  var t = Nt(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Ms(n, t) {
  return new at(n, t);
}
Et(Ms, "expect");
Ms.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "expect.fail()", new Ye(e, {
    actual: n,
    expected: t,
    operator: i
  }, Ms.fail);
};
var $0 = {};
Tf($0, {
  Should: () => by,
  should: () => yy
});
function pd() {
  function n() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new at(this.valueOf(), null, n) : new at(this, null, n);
  }
  Et(n, "shouldGetter");
  function t(i) {
    Object.defineProperty(this, "should", {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  Et(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: n,
    configurable: !0
  });
  var e = {};
  return e.fail = function(i, r, s, o) {
    throw arguments.length < 2 && (s = i, i = void 0), s = s || "should.fail()", new Ye(s, {
      actual: i,
      expected: r,
      operator: o
    }, e.fail);
  }, e.equal = function(i, r, s) {
    new at(i, s).to.equal(r);
  }, e.Throw = function(i, r, s, o) {
    new at(i, o).to.Throw(r, s);
  }, e.exist = function(i, r) {
    new at(i, r).to.exist;
  }, e.not = {}, e.not.equal = function(i, r, s) {
    new at(i, s).to.not.equal(r);
  }, e.not.Throw = function(i, r, s, o) {
    new at(i, o).to.not.Throw(r, s);
  }, e.not.exist = function(i, r) {
    new at(i, r).to.not.exist;
  }, e.throw = e.Throw, e.not.throw = e.not.Throw, e;
}
Et(pd, "loadShould");
var yy = pd, by = pd;
function st(n, t) {
  var e = new at(null, null, st, !0);
  e.assert(
    n,
    t,
    "[ negation message unavailable ]"
  );
}
Et(st, "assert");
st.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "assert.fail()", new Ye(e, {
    actual: n,
    expected: t,
    operator: i
  }, st.fail);
};
st.isOk = function(n, t) {
  new at(n, t, st.isOk, !0).is.ok;
};
st.isNotOk = function(n, t) {
  new at(n, t, st.isNotOk, !0).is.not.ok;
};
st.equal = function(n, t, e) {
  var i = new at(n, e, st.equal, !0);
  i.assert(
    t == Fe(i, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    n,
    !0
  );
};
st.notEqual = function(n, t, e) {
  var i = new at(n, e, st.notEqual, !0);
  i.assert(
    t != Fe(i, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    n,
    !0
  );
};
st.strictEqual = function(n, t, e) {
  new at(n, e, st.strictEqual, !0).to.equal(t);
};
st.notStrictEqual = function(n, t, e) {
  new at(n, e, st.notStrictEqual, !0).to.not.equal(t);
};
st.deepEqual = st.deepStrictEqual = function(n, t, e) {
  new at(n, e, st.deepEqual, !0).to.eql(t);
};
st.notDeepEqual = function(n, t, e) {
  new at(n, e, st.notDeepEqual, !0).to.not.eql(t);
};
st.isAbove = function(n, t, e) {
  new at(n, e, st.isAbove, !0).to.be.above(t);
};
st.isAtLeast = function(n, t, e) {
  new at(n, e, st.isAtLeast, !0).to.be.least(t);
};
st.isBelow = function(n, t, e) {
  new at(n, e, st.isBelow, !0).to.be.below(t);
};
st.isAtMost = function(n, t, e) {
  new at(n, e, st.isAtMost, !0).to.be.most(t);
};
st.isTrue = function(n, t) {
  new at(n, t, st.isTrue, !0).is.true;
};
st.isNotTrue = function(n, t) {
  new at(n, t, st.isNotTrue, !0).to.not.equal(!0);
};
st.isFalse = function(n, t) {
  new at(n, t, st.isFalse, !0).is.false;
};
st.isNotFalse = function(n, t) {
  new at(n, t, st.isNotFalse, !0).to.not.equal(!1);
};
st.isNull = function(n, t) {
  new at(n, t, st.isNull, !0).to.equal(null);
};
st.isNotNull = function(n, t) {
  new at(n, t, st.isNotNull, !0).to.not.equal(null);
};
st.isNaN = function(n, t) {
  new at(n, t, st.isNaN, !0).to.be.NaN;
};
st.isNotNaN = function(n, t) {
  new at(n, t, st.isNotNaN, !0).not.to.be.NaN;
};
st.exists = function(n, t) {
  new at(n, t, st.exists, !0).to.exist;
};
st.notExists = function(n, t) {
  new at(n, t, st.notExists, !0).to.not.exist;
};
st.isUndefined = function(n, t) {
  new at(n, t, st.isUndefined, !0).to.equal(void 0);
};
st.isDefined = function(n, t) {
  new at(n, t, st.isDefined, !0).to.not.equal(void 0);
};
st.isCallable = function(n, t) {
  new at(n, t, st.isCallable, !0).is.callable;
};
st.isNotCallable = function(n, t) {
  new at(n, t, st.isNotCallable, !0).is.not.callable;
};
st.isObject = function(n, t) {
  new at(n, t, st.isObject, !0).to.be.a("object");
};
st.isNotObject = function(n, t) {
  new at(n, t, st.isNotObject, !0).to.not.be.a("object");
};
st.isArray = function(n, t) {
  new at(n, t, st.isArray, !0).to.be.an("array");
};
st.isNotArray = function(n, t) {
  new at(n, t, st.isNotArray, !0).to.not.be.an("array");
};
st.isString = function(n, t) {
  new at(n, t, st.isString, !0).to.be.a("string");
};
st.isNotString = function(n, t) {
  new at(n, t, st.isNotString, !0).to.not.be.a("string");
};
st.isNumber = function(n, t) {
  new at(n, t, st.isNumber, !0).to.be.a("number");
};
st.isNotNumber = function(n, t) {
  new at(n, t, st.isNotNumber, !0).to.not.be.a("number");
};
st.isNumeric = function(n, t) {
  new at(n, t, st.isNumeric, !0).is.numeric;
};
st.isNotNumeric = function(n, t) {
  new at(n, t, st.isNotNumeric, !0).is.not.numeric;
};
st.isFinite = function(n, t) {
  new at(n, t, st.isFinite, !0).to.be.finite;
};
st.isBoolean = function(n, t) {
  new at(n, t, st.isBoolean, !0).to.be.a("boolean");
};
st.isNotBoolean = function(n, t) {
  new at(n, t, st.isNotBoolean, !0).to.not.be.a("boolean");
};
st.typeOf = function(n, t, e) {
  new at(n, e, st.typeOf, !0).to.be.a(t);
};
st.notTypeOf = function(n, t, e) {
  new at(n, e, st.notTypeOf, !0).to.not.be.a(t);
};
st.instanceOf = function(n, t, e) {
  new at(n, e, st.instanceOf, !0).to.be.instanceOf(t);
};
st.notInstanceOf = function(n, t, e) {
  new at(n, e, st.notInstanceOf, !0).to.not.be.instanceOf(t);
};
st.include = function(n, t, e) {
  new at(n, e, st.include, !0).include(t);
};
st.notInclude = function(n, t, e) {
  new at(n, e, st.notInclude, !0).not.include(t);
};
st.deepInclude = function(n, t, e) {
  new at(n, e, st.deepInclude, !0).deep.include(t);
};
st.notDeepInclude = function(n, t, e) {
  new at(n, e, st.notDeepInclude, !0).not.deep.include(t);
};
st.nestedInclude = function(n, t, e) {
  new at(n, e, st.nestedInclude, !0).nested.include(t);
};
st.notNestedInclude = function(n, t, e) {
  new at(n, e, st.notNestedInclude, !0).not.nested.include(t);
};
st.deepNestedInclude = function(n, t, e) {
  new at(n, e, st.deepNestedInclude, !0).deep.nested.include(t);
};
st.notDeepNestedInclude = function(n, t, e) {
  new at(n, e, st.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
st.ownInclude = function(n, t, e) {
  new at(n, e, st.ownInclude, !0).own.include(t);
};
st.notOwnInclude = function(n, t, e) {
  new at(n, e, st.notOwnInclude, !0).not.own.include(t);
};
st.deepOwnInclude = function(n, t, e) {
  new at(n, e, st.deepOwnInclude, !0).deep.own.include(t);
};
st.notDeepOwnInclude = function(n, t, e) {
  new at(n, e, st.notDeepOwnInclude, !0).not.deep.own.include(t);
};
st.match = function(n, t, e) {
  new at(n, e, st.match, !0).to.match(t);
};
st.notMatch = function(n, t, e) {
  new at(n, e, st.notMatch, !0).to.not.match(t);
};
st.property = function(n, t, e) {
  new at(n, e, st.property, !0).to.have.property(t);
};
st.notProperty = function(n, t, e) {
  new at(n, e, st.notProperty, !0).to.not.have.property(t);
};
st.propertyVal = function(n, t, e, i) {
  new at(n, i, st.propertyVal, !0).to.have.property(t, e);
};
st.notPropertyVal = function(n, t, e, i) {
  new at(n, i, st.notPropertyVal, !0).to.not.have.property(t, e);
};
st.deepPropertyVal = function(n, t, e, i) {
  new at(n, i, st.deepPropertyVal, !0).to.have.deep.property(t, e);
};
st.notDeepPropertyVal = function(n, t, e, i) {
  new at(n, i, st.notDeepPropertyVal, !0).to.not.have.deep.property(t, e);
};
st.ownProperty = function(n, t, e) {
  new at(n, e, st.ownProperty, !0).to.have.own.property(t);
};
st.notOwnProperty = function(n, t, e) {
  new at(n, e, st.notOwnProperty, !0).to.not.have.own.property(t);
};
st.ownPropertyVal = function(n, t, e, i) {
  new at(n, i, st.ownPropertyVal, !0).to.have.own.property(t, e);
};
st.notOwnPropertyVal = function(n, t, e, i) {
  new at(n, i, st.notOwnPropertyVal, !0).to.not.have.own.property(t, e);
};
st.deepOwnPropertyVal = function(n, t, e, i) {
  new at(n, i, st.deepOwnPropertyVal, !0).to.have.deep.own.property(t, e);
};
st.notDeepOwnPropertyVal = function(n, t, e, i) {
  new at(n, i, st.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, e);
};
st.nestedProperty = function(n, t, e) {
  new at(n, e, st.nestedProperty, !0).to.have.nested.property(t);
};
st.notNestedProperty = function(n, t, e) {
  new at(n, e, st.notNestedProperty, !0).to.not.have.nested.property(t);
};
st.nestedPropertyVal = function(n, t, e, i) {
  new at(n, i, st.nestedPropertyVal, !0).to.have.nested.property(t, e);
};
st.notNestedPropertyVal = function(n, t, e, i) {
  new at(n, i, st.notNestedPropertyVal, !0).to.not.have.nested.property(t, e);
};
st.deepNestedPropertyVal = function(n, t, e, i) {
  new at(n, i, st.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, e);
};
st.notDeepNestedPropertyVal = function(n, t, e, i) {
  new at(n, i, st.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, e);
};
st.lengthOf = function(n, t, e) {
  new at(n, e, st.lengthOf, !0).to.have.lengthOf(t);
};
st.hasAnyKeys = function(n, t, e) {
  new at(n, e, st.hasAnyKeys, !0).to.have.any.keys(t);
};
st.hasAllKeys = function(n, t, e) {
  new at(n, e, st.hasAllKeys, !0).to.have.all.keys(t);
};
st.containsAllKeys = function(n, t, e) {
  new at(n, e, st.containsAllKeys, !0).to.contain.all.keys(t);
};
st.doesNotHaveAnyKeys = function(n, t, e) {
  new at(n, e, st.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
st.doesNotHaveAllKeys = function(n, t, e) {
  new at(n, e, st.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
st.hasAnyDeepKeys = function(n, t, e) {
  new at(n, e, st.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
st.hasAllDeepKeys = function(n, t, e) {
  new at(n, e, st.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
st.containsAllDeepKeys = function(n, t, e) {
  new at(n, e, st.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
st.doesNotHaveAnyDeepKeys = function(n, t, e) {
  new at(n, e, st.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
st.doesNotHaveAllDeepKeys = function(n, t, e) {
  new at(n, e, st.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
st.throws = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null);
  var r = new at(n, i, st.throws, !0).to.throw(t, e);
  return Fe(r, "object");
};
st.doesNotThrow = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null), new at(n, i, st.doesNotThrow, !0).to.not.throw(t, e);
};
st.operator = function(n, t, e, i) {
  var r;
  switch (t) {
    case "==":
      r = n == e;
      break;
    case "===":
      r = n === e;
      break;
    case ">":
      r = n > e;
      break;
    case ">=":
      r = n >= e;
      break;
    case "<":
      r = n < e;
      break;
    case "<=":
      r = n <= e;
      break;
    case "!=":
      r = n != e;
      break;
    case "!==":
      r = n !== e;
      break;
    default:
      throw i = i && i + ": ", new Ye(
        i + 'Invalid operator "' + t + '"',
        void 0,
        st.operator
      );
  }
  var s = new at(r, i, st.operator, !0);
  s.assert(
    Fe(s, "object") === !0,
    "expected " + $e(n) + " to be " + t + " " + $e(e),
    "expected " + $e(n) + " to not be " + t + " " + $e(e)
  );
};
st.closeTo = function(n, t, e, i) {
  new at(n, i, st.closeTo, !0).to.be.closeTo(t, e);
};
st.approximately = function(n, t, e, i) {
  new at(n, i, st.approximately, !0).to.be.approximately(t, e);
};
st.sameMembers = function(n, t, e) {
  new at(n, e, st.sameMembers, !0).to.have.same.members(t);
};
st.notSameMembers = function(n, t, e) {
  new at(n, e, st.notSameMembers, !0).to.not.have.same.members(t);
};
st.sameDeepMembers = function(n, t, e) {
  new at(n, e, st.sameDeepMembers, !0).to.have.same.deep.members(t);
};
st.notSameDeepMembers = function(n, t, e) {
  new at(n, e, st.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
st.sameOrderedMembers = function(n, t, e) {
  new at(n, e, st.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
st.notSameOrderedMembers = function(n, t, e) {
  new at(n, e, st.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
st.sameDeepOrderedMembers = function(n, t, e) {
  new at(n, e, st.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
st.notSameDeepOrderedMembers = function(n, t, e) {
  new at(n, e, st.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
st.includeMembers = function(n, t, e) {
  new at(n, e, st.includeMembers, !0).to.include.members(t);
};
st.notIncludeMembers = function(n, t, e) {
  new at(n, e, st.notIncludeMembers, !0).to.not.include.members(t);
};
st.includeDeepMembers = function(n, t, e) {
  new at(n, e, st.includeDeepMembers, !0).to.include.deep.members(t);
};
st.notIncludeDeepMembers = function(n, t, e) {
  new at(n, e, st.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
st.includeOrderedMembers = function(n, t, e) {
  new at(n, e, st.includeOrderedMembers, !0).to.include.ordered.members(t);
};
st.notIncludeOrderedMembers = function(n, t, e) {
  new at(n, e, st.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
st.includeDeepOrderedMembers = function(n, t, e) {
  new at(n, e, st.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
st.notIncludeDeepOrderedMembers = function(n, t, e) {
  new at(n, e, st.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
st.oneOf = function(n, t, e) {
  new at(n, e, st.oneOf, !0).to.be.oneOf(t);
};
st.isIterable = function(n, t) {
  if (n == null || !n[Symbol.iterator])
    throw t = t ? `${t} expected ${$e(n)} to be an iterable` : `expected ${$e(n)} to be an iterable`, new Ye(
      t,
      void 0,
      st.isIterable
    );
};
st.changes = function(n, t, e, i) {
  arguments.length === 3 && typeof t == "function" && (i = e, e = null), new at(n, i, st.changes, !0).to.change(t, e);
};
st.changesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new at(n, r, st.changesBy, !0).to.change(t, e).by(i);
};
st.doesNotChange = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new at(n, i, st.doesNotChange, !0).to.not.change(t, e);
};
st.changesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new at(n, r, st.changesButNotBy, !0).to.change(t, e).but.not.by(i);
};
st.increases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new at(n, i, st.increases, !0).to.increase(t, e);
};
st.increasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new at(n, r, st.increasesBy, !0).to.increase(t, e).by(i);
};
st.doesNotIncrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new at(n, i, st.doesNotIncrease, !0).to.not.increase(t, e);
};
st.increasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new at(n, r, st.increasesButNotBy, !0).to.increase(t, e).but.not.by(i);
};
st.decreases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new at(n, i, st.decreases, !0).to.decrease(t, e);
};
st.decreasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new at(n, r, st.decreasesBy, !0).to.decrease(t, e).by(i);
};
st.doesNotDecrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new at(n, i, st.doesNotDecrease, !0).to.not.decrease(t, e);
};
st.doesNotDecreaseBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  return new at(n, r, st.doesNotDecreaseBy, !0).to.not.decrease(t, e).by(i);
};
st.decreasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new at(n, r, st.decreasesButNotBy, !0).to.decrease(t, e).but.not.by(i);
};
st.ifError = function(n) {
  if (n)
    throw n;
};
st.isExtensible = function(n, t) {
  new at(n, t, st.isExtensible, !0).to.be.extensible;
};
st.isNotExtensible = function(n, t) {
  new at(n, t, st.isNotExtensible, !0).to.not.be.extensible;
};
st.isSealed = function(n, t) {
  new at(n, t, st.isSealed, !0).to.be.sealed;
};
st.isNotSealed = function(n, t) {
  new at(n, t, st.isNotSealed, !0).to.not.be.sealed;
};
st.isFrozen = function(n, t) {
  new at(n, t, st.isFrozen, !0).to.be.frozen;
};
st.isNotFrozen = function(n, t) {
  new at(n, t, st.isNotFrozen, !0).to.not.be.frozen;
};
st.isEmpty = function(n, t) {
  new at(n, t, st.isEmpty, !0).to.be.empty;
};
st.isNotEmpty = function(n, t) {
  new at(n, t, st.isNotEmpty, !0).to.not.be.empty;
};
(/* @__PURE__ */ Et(function n(t, e) {
  return st[e] = st[t], n;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var Pp = [];
function vy(n) {
  const t = {
    AssertionError: Ye,
    util: Zu,
    config: pi,
    expect: Ms,
    assert: st,
    Assertion: at,
    ...$0
  };
  return ~Pp.indexOf(n) || (n(t, Zu), Pp.push(n)), t;
}
Et(vy, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var ao = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oc(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function wy(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(e, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), e;
}
var tf = { exports: {} }, bh, Lp;
function xy() {
  if (Lp) return bh;
  Lp = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  bh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var m = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (m ? "s" : "");
  }
  return bh;
}
function _y(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = s, e.enable = r, e.enabled = o, e.humanize = xy(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, m;
    function b(...x) {
      if (!b.enabled)
        return;
      const y = b, v = Number(/* @__PURE__ */ new Date()), k = v - (d || v);
      y.diff = k, y.prev = d, y.curr = v, d = v, x[0] = e.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let C = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (q, T) => {
        if (q === "%%")
          return "%";
        C++;
        const F = e.formatters[T];
        if (typeof F == "function") {
          const M = x[C];
          q = F.call(y, M), x.splice(C, 1), C--;
        }
        return q;
      }), e.formatArgs.call(y, x), (y.log || e.log).apply(y, x);
    }
    return b.namespace = u, b.useColors = e.useColors(), b.color = e.selectColor(u), b.extend = i, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, m = e.enabled(u)), m),
      set: (x) => {
        p = x;
      }
    }), typeof e.init == "function" && e.init(b), b;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? e.skips.push(new RegExp("^" + u.slice(1) + "$")) : e.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [
      ...e.names.map(a),
      ...e.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = e.skips.length; d < p; d++)
      if (e.skips[d].test(u))
        return !1;
    for (d = 0, p = e.names.length; d < p; d++)
      if (e.names[d].test(u))
        return !0;
    return !1;
  }
  function a(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var Sy = _y;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = Sy(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(tf, tf.exports);
var ky = tf.exports;
const U0 = /* @__PURE__ */ Oc(ky), Ay = {
  cacheResults: !0,
  successMetric: "efficiency",
  calculateCuts: !0,
  stack: !0,
  findDuplicatePatterns: !0,
  //dev specific
  captureProfile: !1,
  runTests: !1,
  throwErrorsOnFailedTests: !1,
  // recordPlacementPositions: isDevOrTest ? true : false,
  sample: {
    enable: !0,
    groupSize: 6,
    efficiency: 4,
    guillotine: 2
  },
  priority: {
    enable: !0,
    variationThreshold: 0.3
  },
  secondRun: {
    enabled: !1,
    efficiencyCutoff: 0.5,
    stack: !1
  },
  efficiency: {
    tidy: !1,
    //[] issue with picking winner when tidy is enabled
    rayCasting: !0
  },
  groups: {
    shapeAreaCutOff: 0.7,
    tolerance: 0.04,
    guillotine: {
      strips: !0,
      segments: !0,
      runWithout: !1
    },
    efficiency: {
      firstShapes: !0,
      position: !0,
      limit: 100
    }
  },
  guillotine: {
    viableShapeArea: 0.5,
    secondPass: !0,
    strips: {
      rearrange: !0,
      efficiencyThreshold: 0.7
    },
    stripShapes: {
      allocation: !0,
      iterations: 6,
      numPriorityShapes: 1
    }
  },
  subset: {
    shuffles: 80,
    //this is the default - can be overwritten (for example when creating groups)
    guillotine: {
      shuffles: 80
    },
    efficiency: {
      limit: 0.5
    }
  },
  evo: {
    disable: !1,
    stockLimit: 40
  }
};
pi.showDiff = !0;
const Ip = U0("tests");
U0("timers");
function W0() {
  return typeof process < "u" && (process != null && process.env), !1;
}
function H0(n, t = null) {
  if (n != null && n.length && W0() && Ay.runTests)
    for (const e of n)
      try {
        e();
      } catch (i) {
        t ? Ip(t, i.message) : Ip(i.message);
      }
}
var ef = { exports: {} }, vh, Ep;
function Ny() {
  if (Ep) return vh;
  Ep = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  vh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var m = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (m ? "s" : "");
  }
  return vh;
}
function Cy(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = s, e.enable = r, e.enabled = o, e.humanize = Ny(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, m;
    function b(...x) {
      if (!b.enabled)
        return;
      const y = b, v = Number(/* @__PURE__ */ new Date()), k = v - (d || v);
      y.diff = k, y.prev = d, y.curr = v, d = v, x[0] = e.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
      let C = 0;
      x[0] = x[0].replace(/%([a-zA-Z%])/g, (q, T) => {
        if (q === "%%")
          return "%";
        C++;
        const F = e.formatters[T];
        if (typeof F == "function") {
          const M = x[C];
          q = F.call(y, M), x.splice(C, 1), C--;
        }
        return q;
      }), e.formatArgs.call(y, x), (y.log || e.log).apply(y, x);
    }
    return b.namespace = u, b.useColors = e.useColors(), b.color = e.selectColor(u), b.extend = i, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, m = e.enabled(u)), m),
      set: (x) => {
        p = x;
      }
    }), typeof e.init == "function" && e.init(b), b;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? e.skips.push(new RegExp("^" + u.slice(1) + "$")) : e.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [
      ...e.names.map(a),
      ...e.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = e.skips.length; d < p; d++)
      if (e.skips[d].test(u))
        return !1;
    for (d = 0, p = e.names.length; d < p; d++)
      if (e.names[d].test(u))
        return !0;
    return !1;
  }
  function a(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var Py = Cy;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = Py(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(ef, ef.exports);
var Ly = ef.exports;
const Qi = /* @__PURE__ */ Oc(Ly);
Qi.colors = [
  2,
  3,
  4,
  5,
  7,
  9,
  10,
  11,
  14,
  159
];
Qi("logs");
Qi("cuts");
Qi("guillotine");
Qi("results");
Qi("scoring");
Qi("calculations");
Qi("subset");
Qi("secondRun");
Qi("stack");
const Iy = Qi("errors");
Qi("allStock");
Iy.color = 1;
function Ey(n) {
  if (n != null && n.dimension)
    switch (n.dimension) {
      case "l":
        return n.x2 - n.x1;
      case "w":
        return n.y2 - n.y1;
    }
  switch (n.type) {
    case "top":
    case "bottom":
      return n.x2 - n.x1;
    case "left":
    case "right":
      return n.y2 - n.y1;
  }
  return 0;
}
class Tc extends ya {
  //used to mark for removal
  constructor(e) {
    var i, r, s, o;
    e.x2 < e.x1 && ([e.x1, e.x2] = [e.x2, e.x1]), e.y2 < e.y1 && ([e.y1, e.y2] = [e.y2, e.y1]);
    super(e);
    tt(this, "stock");
    tt(this, "stockId");
    tt(this, "guillotine");
    tt(this, "guillotineData");
    tt(this, "isTrim");
    tt(this, "distances");
    tt(this, "beamTrimX1");
    tt(this, "beamTrimY1");
    tt(this, "type", null);
    tt(this, "remove");
    qt(e == null ? void 0 : e.stock) && (((r = (i = e.stock) == null ? void 0 : i.constructor) == null ? void 0 : r.name) === "Stock" ? this.stock = e.stock : this.stock = new es(e.stock), this.stockId = this.stock.id), this.stockId = (s = e == null ? void 0 : e.stock) == null ? void 0 : s.id, this.type = e.type ?? null, this.guillotine = e.guillotine, this.guillotineData = qt(e.guillotineData) ? e.guillotineData : {}, this.guillotineData.ptxDummyCut = (e == null ? void 0 : e.ptxDummyCut) || ((o = e == null ? void 0 : e.guillotineData) == null ? void 0 : o.ptxDummyCut) || !1, this.isTrim = qt(e.isTrim) ? e.isTrim : !1, this.distances = qt(e.distances) ? e.distances : {}, this.beamTrimX1 = e.beamTrimX1, this.beamTrimY1 = e.beamTrimY1;
  }
  //compress for saving / transfer
  compress() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.shapeCollisions, delete this.stock;
  }
  clone() {
    const e = structuredClone(this);
    return new Tc(e);
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
  trim() {
    this.dimension === "l" ? (this.x1 = this.x1 < 0 ? 0 : this.x1, this.x2 = this.x2 > this.stock.l ? this.stock.l : this.x2) : this.dimension === "w" && (this.y1 = this.y1 < 0 ? 0 : this.y1, this.y2 = this.y2 > this.stock.w ? this.stock.w : this.y2);
  }
  lookupDirectionByType(e) {
    const r = {
      top: "l",
      bottom: "l",
      left: "w",
      right: "w"
    }[e];
    if (r) return r;
    throw new Error("no direction found in lookupDirectionByType");
  }
  isInsideStock() {
    switch (this.type) {
      case "bottom":
        return Ue.greaterThan(
          this.y1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "left":
        return Ue.greaterThan(
          this.x1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "top":
        return Ue.lessThan(
          this.y1 - this.stock.getBladeWidth() / 2,
          this.stock.w
        );
      case "right":
        return Ue.lessThan(
          this.x1 - this.stock.getBladeWidth() / 2,
          this.stock.l
        );
      default:
        return !0;
    }
  }
  /**
      * the cuts are visualised differently from their exact dimensions
      * @param {string} coord
      */
  getVisCoords(e) {
    return this[e];
  }
  getLength() {
    return Ey(this);
  }
  getArea() {
    if (!this.stock) return 0;
    const e = this.getLength();
    return e ? e * this.stock.getBladeWidth() : 0;
  }
}
const Oy = {
  tb: {
    bottomLeft: {
      top: "topRight",
      topLeft: "topLeft"
    },
    bottomRight: {
      top: "topLeft",
      topRight: "topRight"
    }
  },
  bt: {
    topLeft: {
      bottom: "bottomRight",
      bottomLeft: "bottomLeft"
    },
    topRight: {
      bottom: "bottomLeft",
      bottomRight: "bottomRight"
    }
  },
  lr: {
    topRight: {
      left: "bottomLeft",
      topLeft: "topLeft"
    },
    bottomRight: {
      left: "topLeft",
      bottomLeft: "bottomLeft"
    }
  },
  rl: {
    topLeft: {
      right: "bottomRight",
      topRight: "topRight"
    },
    bottomLeft: {
      right: "topRight",
      bottomRight: "bottomRight"
    }
  }
}, Su = {
  topLeft: {
    top: ["topRight"],
    default: ["topRight"]
  },
  bottomRight: {
    right: ["topRight"],
    default: ["topRight"]
  }
}, ku = {
  topRight: {
    top: ["topLeft"],
    right: ["bottomRight"],
    default: ["topLeft", "bottomRight"]
  },
  topLeft: {
    top: ["topRight"],
    left: ["bottomLeft"],
    default: ["topRight", "bottomLeft"]
  },
  bottomRight: {
    bottom: ["bottomLeft"],
    right: ["topRight"],
    default: ["bottomLeft", "topRight"]
  },
  bottomLeft: {
    bottom: ["bottomRight"],
    left: ["topLeft"],
    default: ["bottomRight", "topLeft"]
  }
};
class Hn {
  constructor(t, e, i = null) {
    tt(this, "x");
    tt(this, "y");
    tt(this, "z");
    tt(this, "a");
    //shape id
    tt(this, "b");
    //shape id
    tt(this, "direction");
    //direction of the raay
    tt(this, "type");
    //[] need to type
    tt(this, "corner");
    //originating corner of this point
    tt(this, "grid");
    //if a grid point, which grid position
    tt(this, "stockID");
    tt(this, "raycast");
    tt(this, "collision");
    tt(this, "tooClose");
    tt(this, "adjustedForMinSpacing");
    this.x = parseFloat(t), this.y = parseFloat(e), this.z = parseFloat(i) || 0, this.validate();
  }
  /**
   * clone with the ability to change the coordinates
   * NOTE: looks odd for performance reasons
   */
  clone(t = null, e = null) {
    const i = new Hn(t ?? this.x, e ?? this.y);
    for (const r in this)
      r !== "x" && r !== "y" && (i[r] = this[r]);
    return i;
  }
  validate() {
    if (isNaN(this.x) || isNaN(this.y))
      throw new Error("invalid point coordinates");
  }
  coords() {
    return {
      x: this.x,
      y: this.y
    };
  }
  collidesWith(t) {
    return this.x >= t.x && this.x <= t.x + t.l && this.y >= t.y && this.y <= t.y + t.w;
  }
  isIdenticalTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * given a point from a shape corner or a ray, get the available positions for this shape
   * @returns the position of the shape relative to the point e.g. bottomRight means the shape is placed to the bottom right of the point
   * @remarks does not cater for diagonals
   */
  //[x] needs to cater for raycast coords, which don't originate from a shape corner
  //[x] cater for raycast corners and grid
  getAvailableShapePositions(t) {
    const e = /* @__PURE__ */ new Set();
    if (this.raycast) {
      const i = Oy[this.direction];
      return i && i[this.corner] && i[this.corner][this.grid] && e.add(i[this.corner][this.grid]), e;
    }
    return (t == null ? void 0 : t.cutType) !== "efficiency" ? (Su[this.corner] && (this.grid ? Su[this.corner][this.grid] && Su[this.corner][this.grid].forEach((i) => e.add(i)) : Su[this.corner].default.forEach((i) => e.add(i))), e) : (ku[this.corner] && (this.grid ? ku[this.corner][this.grid] && ku[this.corner][this.grid].forEach((i) => e.add(i)) : ku[this.corner].default.forEach((i) => e.add(i))), e);
  }
}
class Co {
  constructor(t = []) {
    tt(this, "points", /* @__PURE__ */ new Map());
    t.forEach((e) => this.addPoint(e));
  }
  addPoint(t, e = null) {
    if (this.contains(t)) {
      const i = this.getPoint(t);
      i.type === "group" && !e && (i.type = void 0);
      return;
    }
    t.validate(), e && (t.type = e), this.points.set(this.createKey(t), t);
  }
  addPoints(t, e = null) {
    for (const i of t) {
      if (!i) return;
      i.validate(), this.addPoint(i, e);
    }
  }
  createKey(t) {
    return `${t.x},${t.y}`;
  }
  getPoint(t) {
    return this.points.get(this.createKey(t));
  }
  deletePoint(t) {
    t.validate(), this.points.delete(this.createKey(t));
  }
  deletePoints(t) {
    for (const e of t)
      e.validate(), this.deletePoint(e);
  }
  clear() {
    this.points.clear();
  }
  toArray() {
    return Array.from(this.points.values());
  }
  contains(t) {
    return this.points.has(this.createKey(t));
  }
}
function Je(n, t, e, i, r) {
  const s = Ty[n](t, e);
  return i && (s.corner = i), r && (s.direction = r), s;
}
const Ty = {
  bottom: (n, t) => {
    const e = n.clone(n.x, n.y - t);
    return e.grid = "bottom", e;
  },
  bottomLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y - t);
    return e.grid = "bottomLeft", e;
  },
  bottomRight: (n, t) => {
    const e = n.clone(n.x + t, n.y - t);
    return e.grid = "bottomRight", e;
  },
  left: (n, t) => {
    const e = n.clone(n.x - t, n.y);
    return e.grid = "left", e;
  },
  centre: (n) => {
    const t = n.clone(n.x, n.y);
    return t.grid = "centre", t;
  },
  right: (n, t) => {
    const e = n.clone(n.x + t, n.y);
    return e.grid = "right", e;
  },
  top: (n, t) => {
    const e = n.clone(n.x, n.y + t);
    return e.grid = "top", e;
  },
  topLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y + t);
    return e.grid = "topLeft", e;
  },
  topRight: (n, t) => {
    const e = n.clone(n.x + t, n.y + t);
    return e.grid = "topRight", e;
  }
};
function Fy(n, t, e) {
  var o, a, l, h, u, d;
  const i = new Co(), r = e.toArray().sort(G0), s = t.getBladeWidth();
  if (r.forEach((p) => {
    const f = p.corner, m = p.type;
    if (!s)
      i.addPoint(p);
    else
      switch (f) {
        case "topRight":
          i.addPoint(
            Je("top", p, s, f),
            m
          ), i.addPoint(
            Je("right", p, s, f),
            m
          );
          break;
        case "topLeft":
          i.addPoint(
            Je("top", p, s, f),
            m
          ), i.addPoint(
            Je("left", p, s, f),
            m
          );
          break;
        case "bottomRight":
          i.addPoint(
            Je("bottom", p, s, f),
            m
          ), i.addPoint(
            Je("right", p, s, f),
            m
          );
          break;
        case "bottomLeft":
          i.addPoint(
            Je("bottom", p, s, f),
            m
          ), i.addPoint(
            Je("left", p, s, f),
            m
          );
          break;
      }
    const b = i.toArray();
    if (s)
      for (let x = b.length; x--; ) {
        const y = b[x];
        e.contains(y) && i.deletePoint(y);
      }
    else
      for (let x = b.length; x--; ) {
        const y = b[x];
        for (let v = n.length; v--; ) {
          const k = n[v];
          if (y.x === k.x && y.y === k.y) {
            i.deletePoint(y);
            break;
          }
        }
      }
  }), s) {
    const p = /* @__PURE__ */ new Set();
    let f, m, b, x;
    ((o = t == null ? void 0 : t.constructor) == null ? void 0 : o.name) === "Stock" && (t != null && t.trimmed) || ((a = t == null ? void 0 : t.constructor) == null ? void 0 : a.name) === "Segment" ? (f = t.x, m = t.y, b = t.x + t.l, x = t.y + t.w) : (f = t.x + ((l = t == null ? void 0 : t.trim) == null ? void 0 : l.x1), m = t.y + ((h = t == null ? void 0 : t.trim) == null ? void 0 : h.y1), b = t.x + t.l - ((u = t == null ? void 0 : t.trim) == null ? void 0 : u.x2), x = t.y + t.w - ((d = t == null ? void 0 : t.trim) == null ? void 0 : d.y2));
    let y = i.toArray();
    for (let v = y.length; v--; ) {
      const k = y[v];
      (Ue.lessThan(k.x, f) || Ue.lessThan(k.y, m) || Ue.greaterThan(k.x, b) || Ue.greaterThan(k.y, x)) && y.splice(v, 1);
    }
    i.clear(), i.addPoints(y), p.clear(), y = i.toArray();
    for (let v = y.length; v--; ) {
      const k = y[v];
      for (let C = n.length; C--; ) {
        const E = n[C];
        if (k.collidesWith(E)) {
          i.deletePoint(k);
          break;
        }
      }
    }
  }
  return i;
}
function My(n, t, e) {
  let i = [];
  const r = n.getMinSpacing(e), s = t.corner, o = t.direction;
  if (t.type === "shape")
    switch (s) {
      case "topLeft":
        o === "rl" && (i.push(Je("right", t, r, s, o)), i.push(Je("topRight", t, r, s, o))), o === "bt" && (i.push(Je("bottom", t, r, s, o)), i.push(Je("bottomLeft", t, r, s, o)));
        break;
      case "topRight":
        o === "lr" && (i.push(Je("left", t, r, s, o)), i.push(Je("topLeft", t, r, s, o))), o === "bt" && (i.push(Je("bottom", t, r, s, o)), i.push(Je("bottomRight", t, r, s, o)));
        break;
      case "bottomRight":
        o === "lr" && (i.push(Je("left", t, r, s, o)), i.push(Je("bottomLeft", t, r, s, o))), o === "tb" && (i.push(Je("top", t, r, s, o)), i.push(Je("topRight", t, r, s, o)));
        break;
      case "bottomLeft":
        o === "rl" && (i.push(Je("right", t, r, s, o)), i.push(Je("bottomRight", t, r, s, o))), o === "tb" && (i.push(Je("top", t, r, s, o)), i.push(Je("topLeft", t, r, s, o)));
        break;
    }
  else if (t.type === "edge")
    switch (o) {
      case "rl":
      case "lr":
        i.push(Je("top", t, 0)), i.push(Je("centre", t, 0)), i.push(Je("bottom", t, 0));
        break;
      case "tb":
      case "bt":
        i.push(Je("left", t, 0)), i.push(Je("right", t, 0)), i.push(Je("centre", t, 0));
        break;
    }
  if (i = i.filter((l) => l.x >= 0 && l.y >= 0), !i.length) return null;
  const a = new Co();
  for (const l of i)
    l.raycast = !0, a.addPoints(K0(n, l, e).toArray());
  return X0(n, e, a), a;
}
function Ry(n, t) {
  const e = new Co();
  return n.sort(G0), n.forEach((i) => {
    Pr(i) ? (e.addPoints(i.getCoords(t)), i.shapes.forEach((r) => {
      const s = r.getCoords(t);
      e.addPoints(s, "group");
    })) : e.addPoints(i.getCoords(t));
  }), e.points.forEach((i) => {
    i.stockID = t.getStock().id;
  }), e;
}
function Dy(n = [], t, e) {
  const i = Ry(
    n === null ? t : n,
    e
  );
  return Fy(
    t,
    e,
    i
  );
}
function G0(n, t) {
  return n.y === t.y ? t.x - n.x : t.y - n.y;
}
function V0(n, t, e, i, r, s) {
  n.a = t.id, n.b = e ? e.id : null, n.direction = i, n.raycast = !0, n.type = r, n.corner = s;
}
function By(n, t) {
  if (n.saw.cutType !== "efficiency" || t.length <= 1) return null;
  let e = new Co();
  const i = Y0(t, n);
  for (const a of t)
    for (const l of i) {
      if (l.shape.id === a.id) continue;
      const h = Object.values(l.rays);
      for (const u of h)
        jy(
          u,
          l.shape,
          a,
          e
        );
    }
  const s = n.saw.efficiencyOptions.primaryCompression === "x" ? "lr" : "tb", o = t.reduce((a, l) => (s === "tb" ? a.x + a.l > l.x + l.l : a.y + a.w > l.y + l.w) ? a : l);
  return i.filter(({ shape: a }) => a.id === o.id).forEach(({ shape: a, rays: l }) => {
    const h = Object.values(l);
    for (const u of h) {
      const d = new Hn(u.x2, u.y2);
      s === u.direction && (V0(d, a, null, u.direction, "edge"), e.addPoint(d));
    }
  }), e = qy(e), e;
}
function Y0(n, t) {
  return n.map((e) => {
    const i = X2(e, t);
    return {
      shape: e,
      rays: i
    };
  });
}
function jy(n, t, e, i) {
  switch (n.direction) {
    case "rl":
      Au(
        n,
        t,
        e,
        i,
        e.x + e.l
      );
      break;
    case "lr":
      Au(
        n,
        t,
        e,
        i,
        e.x
      );
      break;
    case "tb":
      Au(
        n,
        t,
        e,
        i,
        e.y + e.w
      );
      break;
    case "bt":
      Au(
        n,
        t,
        e,
        i,
        e.y
      );
      break;
  }
}
function Au(n, t, e, i, r) {
  const s = n.dimension === "w", o = s ? "y" : "x", a = s ? "x" : "y", l = s ? "l" : "w";
  if (n[`${a}1`] >= e[a] && n[`${a}1`] <= e[a] + e[l]) {
    const h = n.direction === "lr" && n[`${o}1`] <= r && n[`${o}2`] >= r, u = n.direction === "rl" && n[`${o}1`] >= r && n[`${o}2`] <= r, d = n.direction === "bt" && n[`${o}1`] <= r && n[`${o}2`] >= r, p = n.direction === "tb" && n[`${o}1`] >= r && n[`${o}2`] <= r;
    if (h || u || d || p) {
      const m = s ? n[`${a}1`] : r, b = s ? r : n[`${a}1`], x = new Hn(m, b), y = n.origin;
      V0(x, t, e, n.direction, "shape", y), i.addPoint(x);
    }
  }
}
function qy(n) {
  const t = new Co();
  return n.points.size === 0 || new Set(n.toArray().map((i) => i.a)).forEach((i) => {
    const r = n.toArray().filter((s) => s.a === i);
    ["right", "left", "top", "bottom"].forEach((s) => {
      const o = zy(
        r,
        s
      );
      o && t.addPoint(o);
    });
  }), t;
}
function zy(n, t) {
  return n.length === 0 ? null : n.reduce((e, i) => {
    switch (t) {
      case "left":
        return !e || i.x < e.x ? i : e;
      case "right":
        return !e || i.x > e.x ? i : e;
      case "top":
        return !e || i.y > e.y ? i : e;
      case "bottom":
        return !e || i.y < e.y ? i : e;
      default:
        return null;
    }
  }, null);
}
function K0(n, t, e) {
  const i = new Co(), r = t.getAvailableShapePositions(e);
  for (const s of r) {
    let o;
    switch (o = $y(t, n, e), s) {
      case "bottomLeft":
        o = o.clone(o.x - n.l, o.y - n.w), o.shapePosition = "bottomLeft";
        break;
      case "bottomRight":
        o = o.clone(o.x, o.y - n.w), o.shapePosition = "bottomRight";
        break;
      case "topLeft":
        o = o.clone(o.x - n.l, o.y), o.shapePosition = "topLeft";
        break;
      case "topRight":
        o = o.clone(o.x, o.y), o.shapePosition = "topRight";
        break;
    }
    i.addPoint(o);
  }
  return X0(n, e, i), i;
}
function $y(n, t, e) {
  if (e.saw.cutType !== "efficiency") return n;
  const i = t.getMinSpacing(e), r = e.getBladeWidth();
  if (!i || i === r) return n;
  let s;
  if (!n.grid) return n;
  switch (n.grid) {
    case "bottom":
      s = n.clone(n.x, n.y - i + r);
      break;
    case "top":
      s = n.clone(n.x, n.y + i - r);
      break;
    case "left":
      s = n.clone(n.x - i + r, n.y);
      break;
    case "right":
      s = n.clone(n.x + i - r, n.y);
      break;
  }
  return s ? (s.x < 0 && (s.x = 0), s.y < 0 && (s.y = 0), s.adjustedForMinSpacing = !0, s) : n;
}
function X0(n, t, e) {
  var l, h, u, d, p, f;
  let i, r, s, o;
  ((l = t == null ? void 0 : t.constructor) == null ? void 0 : l.name) === "Stock" && (t != null && t.trimmed) || ((h = t == null ? void 0 : t.constructor) == null ? void 0 : h.name) === "Segment" ? (i = 0, r = 0, s = t.x + t.l - n.l, o = t.y + t.w - n.w) : (i = (u = t == null ? void 0 : t.trim) == null ? void 0 : u.x1, r = (d = t == null ? void 0 : t.trim) == null ? void 0 : d.y1, s = t.l - ((p = t == null ? void 0 : t.trim) == null ? void 0 : p.x2) - n.l, o = t.w - ((f = t == null ? void 0 : t.trim) == null ? void 0 : f.y2) - n.w);
  const a = e.toArray();
  for (let m = a.length; m--; ) {
    const b = a[m];
    (Ue.lessThan(b.x, i) || Ue.lessThan(b.y, r) || Ue.greaterThan(b.x, s) || Ue.greaterThan(b.y, o) || b.x < 0 || b.y < 0) && e.deletePoint(b);
  }
}
/**
* @license Fraction.js v4.3.7 31/08/2023
* https://www.xarg.org/2014/03/rational-numbers-in-javascript/
*
* Copyright (c) 2023, Robert Eisele (robert@raw.org)
* Dual licensed under the MIT or GPL Version 2 licenses.
**/
var Uy = 2e3, pe = {
  s: 1,
  n: 0,
  d: 1
};
function Jr(n, t) {
  if (isNaN(n = parseInt(n, 10)))
    throw $u();
  return n * t;
}
function bn(n, t) {
  if (t === 0)
    throw gd();
  var e = Object.create(Ls.prototype);
  e.s = n < 0 ? -1 : 1, n = n < 0 ? -n : n;
  var i = va(n, t);
  return e.n = n / i, e.d = t / i, e;
}
function Op(n) {
  for (var t = {}, e = n, i = 2, r = 4; r <= e; ) {
    for (; e % i === 0; )
      e /= i, t[i] = (t[i] || 0) + 1;
    r += 1 + 2 * i++;
  }
  return e !== n ? e > 1 && (t[e] = (t[e] || 0) + 1) : t[n] = (t[n] || 0) + 1, t;
}
var Mi = function(n, t) {
  var e = 0, i = 1, r = 1, s = 0, o = 0, a = 0, l = 1, h = 1, u = 0, d = 1, p = 1, f = 1, m = 1e7, b;
  if (n != null) if (t !== void 0) {
    if (e = n, i = t, r = e * i, e % 1 !== 0 || i % 1 !== 0)
      throw Vy();
  } else
    switch (typeof n) {
      case "object": {
        if ("d" in n && "n" in n)
          e = n.n, i = n.d, "s" in n && (e *= n.s);
        else if (0 in n)
          e = n[0], 1 in n && (i = n[1]);
        else
          throw $u();
        r = e * i;
        break;
      }
      case "number": {
        if (n < 0 && (r = n, n = -n), n % 1 === 0)
          e = n;
        else if (n > 0) {
          for (n >= 1 && (h = Math.pow(10, Math.floor(1 + Math.log(n) / Math.LN10)), n /= h); d <= m && f <= m; )
            if (b = (u + p) / (d + f), n === b) {
              d + f <= m ? (e = u + p, i = d + f) : f > d ? (e = p, i = f) : (e = u, i = d);
              break;
            } else
              n > b ? (u += p, d += f) : (p += u, f += d), d > m ? (e = p, i = f) : (e = u, i = d);
          e *= h;
        } else (isNaN(n) || isNaN(t)) && (i = e = NaN);
        break;
      }
      case "string": {
        if (d = n.match(/\d+|./g), d === null)
          throw $u();
        if (d[u] === "-" ? (r = -1, u++) : d[u] === "+" && u++, d.length === u + 1 ? o = Jr(d[u++], r) : d[u + 1] === "." || d[u] === "." ? (d[u] !== "." && (s = Jr(d[u++], r)), u++, (u + 1 === d.length || d[u + 1] === "(" && d[u + 3] === ")" || d[u + 1] === "'" && d[u + 3] === "'") && (o = Jr(d[u], r), l = Math.pow(10, d[u].length), u++), (d[u] === "(" && d[u + 2] === ")" || d[u] === "'" && d[u + 2] === "'") && (a = Jr(d[u + 1], r), h = Math.pow(10, d[u + 1].length) - 1, u += 3)) : d[u + 1] === "/" || d[u + 1] === ":" ? (o = Jr(d[u], r), l = Jr(d[u + 2], 1), u += 3) : d[u + 3] === "/" && d[u + 1] === " " && (s = Jr(d[u], r), o = Jr(d[u + 2], r), l = Jr(d[u + 4], 1), u += 5), d.length <= u) {
          i = l * h, r = /* void */
          e = a + i * s + h * o;
          break;
        }
      }
      default:
        throw $u();
    }
  if (i === 0)
    throw gd();
  pe.s = r < 0 ? -1 : 1, pe.n = Math.abs(e), pe.d = Math.abs(i);
};
function Wy(n, t, e) {
  for (var i = 1; t > 0; n = n * n % e, t >>= 1)
    t & 1 && (i = i * n % e);
  return i;
}
function Hy(n, t) {
  for (; t % 2 === 0; t /= 2)
    ;
  for (; t % 5 === 0; t /= 5)
    ;
  if (t === 1)
    return 0;
  for (var e = 10 % t, i = 1; e !== 1; i++)
    if (e = e * 10 % t, i > Uy)
      return 0;
  return i;
}
function Gy(n, t, e) {
  for (var i = 1, r = Wy(10, e, t), s = 0; s < 300; s++) {
    if (i === r)
      return s;
    i = i * 10 % t, r = r * 10 % t;
  }
  return 0;
}
function va(n, t) {
  if (!n)
    return t;
  if (!t)
    return n;
  for (; ; ) {
    if (n %= t, !n)
      return t;
    if (t %= n, !t)
      return n;
  }
}
function Ls(n, t) {
  if (Mi(n, t), this instanceof Ls)
    n = va(pe.d, pe.n), this.s = pe.s, this.n = pe.n / n, this.d = pe.d / n;
  else
    return bn(pe.s * pe.n, pe.d);
}
var gd = function() {
  return new Error("Division by Zero");
}, $u = function() {
  return new Error("Invalid argument");
}, Vy = function() {
  return new Error("Parameters must be integer");
};
Ls.prototype = {
  s: 1,
  n: 0,
  d: 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return bn(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return bn(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(n, t) {
    return Mi(n, t), bn(
      this.s * this.n * pe.d + pe.s * this.d * pe.n,
      this.d * pe.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(n, t) {
    return Mi(n, t), bn(
      this.s * this.n * pe.d - pe.s * this.d * pe.n,
      this.d * pe.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(n, t) {
    return Mi(n, t), bn(
      this.s * pe.s * this.n * pe.n,
      this.d * pe.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(n, t) {
    return Mi(n, t), bn(
      this.s * pe.s * this.n * pe.d,
      this.d * pe.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return bn(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  mod: function(n, t) {
    if (isNaN(this.n) || isNaN(this.d))
      return new Ls(NaN);
    if (n === void 0)
      return bn(this.s * this.n % this.d, 1);
    if (Mi(n, t), pe.n === 0 && this.d === 0)
      throw gd();
    return bn(
      this.s * (pe.d * this.n) % (pe.n * this.d),
      pe.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(n, t) {
    return Mi(n, t), bn(va(pe.n, this.n) * va(pe.d, this.d), pe.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(n, t) {
    return Mi(n, t), pe.n === 0 && this.n === 0 ? bn(0, 1) : bn(pe.n * this.n, va(pe.n, this.n) * va(pe.d, this.d));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Ls(NaN) : bn(Math.ceil(n * this.s * this.n / this.d), n);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Ls(NaN) : bn(Math.floor(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Ls(NaN) : bn(Math.round(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  roundTo: function(n, t) {
    return Mi(n, t), bn(this.s * Math.round(this.n * pe.d / (this.d * pe.n)) * pe.n, pe.d);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return bn(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(n, t) {
    if (Mi(n, t), pe.d === 1)
      return pe.s < 0 ? bn(Math.pow(this.s * this.d, pe.n), Math.pow(this.n, pe.n)) : bn(Math.pow(this.s * this.n, pe.n), Math.pow(this.d, pe.n));
    if (this.s < 0) return null;
    var e = Op(this.n), i = Op(this.d), r = 1, s = 1;
    for (var o in e)
      if (o !== "1") {
        if (o === "0") {
          r = 0;
          break;
        }
        if (e[o] *= pe.n, e[o] % pe.d === 0)
          e[o] /= pe.d;
        else return null;
        r *= Math.pow(o, e[o]);
      }
    for (var o in i)
      if (o !== "1") {
        if (i[o] *= pe.n, i[o] % pe.d === 0)
          i[o] /= pe.d;
        else return null;
        s *= Math.pow(o, i[o]);
      }
    return pe.s < 0 ? bn(s, r) : bn(r, s);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(n, t) {
    return Mi(n, t), this.s * this.n * pe.d === pe.s * pe.n * this.d;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  compare: function(n, t) {
    Mi(n, t);
    var e = this.s * this.n * pe.d - pe.s * pe.n * this.d;
    return (0 < e) - (e < 0);
  },
  simplify: function(n) {
    if (isNaN(this.n) || isNaN(this.d))
      return this;
    n = n || 1e-3;
    for (var t = this.abs(), e = t.toContinued(), i = 1; i < e.length; i++) {
      for (var r = bn(e[i - 1], 1), s = i - 2; s >= 0; s--)
        r = r.inverse().add(e[s]);
      if (Math.abs(r.sub(t).valueOf()) < n)
        return r.mul(this.s);
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(n, t) {
    return Mi(n, t), !(!(pe.n * this.d) || this.n * pe.d % (pe.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return this.s * this.n / this.d;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  toFraction: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, e += " ", i %= r), e += i, e += "/", e += r), e;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, i %= r), e += "\\frac{", e += i, e += "}{", e += r, e += "}"), e;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    var n, t = this.n, e = this.d, i = [];
    if (isNaN(t) || isNaN(e))
      return i;
    do
      i.push(Math.floor(t / e)), n = t % e, t = e, e = n;
    while (t !== 1);
    return i;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(n) {
    var t = this.n, e = this.d;
    if (isNaN(t) || isNaN(e))
      return "NaN";
    n = n || 15;
    var i = Hy(t, e), r = Gy(t, e, i), s = this.s < 0 ? "-" : "";
    if (s += t / e | 0, t %= e, t *= 10, t && (s += "."), i) {
      for (var o = r; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += "(";
      for (var o = i; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += ")";
    } else
      for (var o = n; t && o--; )
        s += t / e | 0, t %= e, t *= 10;
    return s;
  }
};
function Yy(n) {
  if (!n) return null;
  if (n = n.toString().trim(), typeof navigator > "u" || typeof navigator.language > "u")
    return parseFloat(n);
  const { thousandsSeparator: t, decimalSeparator: e } = Ky();
  return n = Array.from(n, (i) => i === t ? "" : i === e ? "." : i).join(""), parseFloat(n);
}
function Ky() {
  const n = navigator.language, t = 123456789e-2.toLocaleString(n), e = t.replace(/\d/g, ""), i = Array.from(new Set(e.split("")));
  let r = "", s = "";
  if (i.length === 1)
    s = i[0];
  else if (i.length === 2) {
    const o = t[t.length - 3];
    i.includes(o) ? (s = o, r = i.find((a) => a !== o)) : (s = i[1], r = i[0]);
  }
  return { thousandsSeparator: r, decimalSeparator: s };
}
function J0(n) {
  if (!n || typeof n == "number") return !1;
  n = n.toString().replace(/[^0-9/ ]/g, "");
  const t = /\b\d+\/\d+\b/g;
  return n.match(t);
}
function Xy(n, t = !1) {
  if (!qt(n)) return null;
  if (n === 0) return "0";
  let e = n.toString().trim();
  if (!e) return null;
  if (J0(n))
    return e = e.replace(/[^0-9/,. -]/g, "").replace(/  +/g, " "), e;
  {
    e = e.replace(/[^0-9,. -]/g, ""), e.startsWith(".") && (e = "0" + e);
    let i;
    return t ? i = Yy(e) : i = parseFloat(e), i ? i.toString() : null;
  }
}
function ul(n) {
  let t;
  try {
    t = new Ls(n);
  } catch {
    console.log(`issue parsing ${n} to new Fraction()`), t = 0;
  }
  return t;
}
function ne(n, t = "decimal", e = !1, i = !1, r = 0) {
  if (!qt(n) || !t) return null;
  if (t !== "decimal" && t !== "fraction")
    return console.error("incorrect conversion type specified for convertUnit"), null;
  try {
    const s = Xy(n, i);
    if (!s) return 0;
    let o;
    if (t === "fraction")
      if (J0(s))
        o = ul(s);
      else {
        const a = parseFloat(s);
        Number.isInteger(a) ? o = ul(s) : o = ul(a);
      }
    else o = ul(s);
    switch (t) {
      case "fraction":
        if (r > 0) {
          const a = o.valueOf(), l = Math.round(a * r) / r;
          o = ul(l);
        }
        return o.toFraction(!0);
      case "decimal":
        if (e === !1 || typeof e != "number")
          return o.valueOf();
        {
          const a = o.valueOf();
          return a === 0 ? 0 : parseFloat(a.toFixed(e));
        }
      default:
        return 0;
    }
  } catch (s) {
    return console.error(s), 0;
  }
}
function Jy(n) {
  let t = n;
  return typeof n != "number" && (t = parseFloat(n)), t % 1 !== 0;
}
const ai = {
  customData: (n, t = null) => {
    const e = [];
    return typeof n != "object" ? (e.push({ message: "Custom data must be an object." }), e) : (Object.entries(n).forEach(([i, r]) => {
      qt(r) && (["string", "number", "boolean"].includes(typeof r) || e.push({
        message: `Custom data ${i} must be a string, number or boolean.`,
        index: t
      }));
    }), e);
  },
  banding: (n, t = null) => {
    const e = [];
    if (!qt(n)) return [];
    if (typeof n != "object")
      return e.push({
        message: "Banding must be an object.",
        field: ["banding"],
        index: t
      }), e;
    Object.entries(n).forEach(([i, r]) => {
      qt(r) && r !== !0 && r !== !1 && e.push({
        message: `Banding ${i} must be a boolean.`,
        field: ["banding"],
        index: t
      });
    });
  },
  //when trim provided as number
  partTrim(n, t, e = null) {
    t = ne(t);
    const i = ne(n.l), r = ne(n.w), s = i - t * 2, o = r - t * 2;
    return s < 0 || o < 0 ? [
      {
        message: `When applying trim of ${t}, part is ${s} x ${o}.`,
        field: ["trim"],
        index: e
      }
    ] : [];
  },
  //when trim provided as object
  trim: (n, t = null) => {
    const e = [];
    if (!qt(n.trim)) return e;
    if (gr.forEach((i) => {
      qt(n.trim[i]) || (n.trim[i] = 0);
    }), !ts(n) || ts(n) && !(n != null && n.trimmed)) {
      const i = ["l", "w"], [r, s] = i.map((d) => ne(n[d])), [o, a, l, h] = gr.map((d) => ne(n.trim[d]));
      Object.entries({ x1: o, x2: a, y1: l, y2: h }).forEach(([d, p]) => {
        isNaN(p) && e.push({
          message: `The value of trim ${sf[d]} is not understood.`,
          field: ["trim"],
          index: t
        });
      }), r && s && r > 0 && s > 0 && (o + a >= n.l && e.push({
        message: `Trim W1 + W2 = ${o + a}, which is greater than or equal to total length of ${r}.`,
        field: ["trim"],
        subField: ["x1", "x2"],
        index: t
      }), l + h >= n.w && e.push({
        message: `Trim L1 + L2 = ${l + h}, which is greater than or equal to total width of ${s}.`,
        field: ["trim"],
        subField: ["y1", "y2"],
        index: t
      }));
    }
    return e;
  },
  x: (n, t = null) => {
    const e = [];
    return qt(n) ? (n = ne(n), isNaN(n) ? (e.push({ message: `X value is not understood, got ${n}`, index: t }), e) : (n < 0 && e.push({ message: `X must be greater than or equal to zero, got ${n}` }), e)) : e;
  },
  y: (n, t = null) => {
    const e = [];
    return qt(n) && (n = ne(n), isNaN(n) && e.push({ message: `Y value is not understood, got ${n}`, index: t }), n < 0 && e.push({ message: `Y must be greater than or equal to zero, got ${n}`, index: t })), e;
  },
  l: (n, t = null, e = 0) => {
    const i = [];
    return qt(n) ? (n = ne(n), isNaN(n) ? (i.push({
      message: `Length value is not understood, got ${n}`,
      field: ["l"],
      index: t
    }), i) : (n < e && i.push({
      message: `Length must be greater than or equal to ${e}, got ${n}`,
      field: ["l"],
      index: t
    }), i)) : (i.push({
      message: "Length is required.",
      field: ["l"],
      index: t
    }), i);
  },
  w: (n, t = null, e = 0) => {
    const i = [];
    return qt(n) ? (n = ne(n), isNaN(n) ? (i.push({
      message: `Width value is not understood, got ${n}`,
      field: ["w"],
      index: t
    }), i) : (n < e && i.push({
      message: `Width must be greater than or equal to ${e}, got ${n}`,
      field: ["w"],
      index: t
    }), i)) : (i.push({
      message: "Width is required.",
      field: ["w"],
      index: t
    }), i);
  },
  t: (n, t = null) => {
    const e = [];
    return !qt(n) || n === "" ? e : (n = ne(n), isNaN(n) ? (e.push({
      message: `Thickness value is not understood, got ${n}`,
      field: ["t"],
      index: t
    }), e) : (n && n <= 0 && e.push({
      message: `Thickness must be greater than zero, got ${n}`,
      field: ["t"],
      index: t
    }), e));
  },
  q: (n, t = null, e = null) => {
    const i = [];
    return qt(n) ? (n = parseInt(n), isNaN(n) ? (i.push({
      message: `Quantity value is not understood, got ${n}`,
      field: ["q"],
      index: e
    }), i) : (Jy(n) && i.push({
      message: "Quantity should be an integer.",
      field: ["q"],
      index: e
    }), n <= 0 && (t || i.push({
      message: `Quantity should be greater than or equal to zero, got ${n}`,
      field: ["q"],
      index: e
    })), i)) : (i.push({
      message: "Quantity should be set.",
      field: ["q"],
      index: e
    }), i);
  },
  orientationLock: (n, t = null) => {
    const e = [];
    return qt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Orientation lock must be l or w, got ${n}`,
      field: ["orientationLock"],
      index: t
    })), e;
  },
  grain: (n, t = null) => {
    const e = [];
    return qt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Grain must be l or w, got ${n}`,
      index: t
    })), e;
  },
  stockMatch: (n, t, e, i = 0, r = null) => {
    if (!n.q) return [];
    if (n.applyPartTrim(i), n.issues.length) return [];
    const s = Hb([n], t, e);
    if (!s) return [];
    const o = [];
    if (s.unusableShapes.length) {
      const a = s.unusableShapes[0], l = a.stockMatch;
      if (!l.fit) {
        const h = a.getTrimmedDimensions();
        o.push({
          message: `${h.l.toFixed(0)}x${h.w.toFixed(0)} will not fit on any stock - check trim, dimensions & orientation lock.`,
          field: ["l", "w"],
          index: r
        });
      }
      l.material || o.push({
        message: "No matching stock material found.",
        field: ["material"],
        index: r
      }), l.thickness || o.push({
        message: "No matching stock thickness found.",
        field: ["t"],
        index: r
      }), !l.width && e === "linear" && o.push({
        message: "No matching stock width found - required for linear calculations.",
        field: ["w"],
        index: r
      });
    }
    return o;
  },
  machining: (n, t = null) => {
    n.machining.validateEverything(n, t);
  }
};
function nf(n) {
  let t, e;
  switch (n) {
    case "l":
    case "length":
      t = "guillotine", e = "l";
      break;
    case "w":
    case "width":
      t = "guillotine", e = "w";
      break;
    case "flex":
      t = "guillotine", e = "flex";
      break;
    case "efficiency":
      t = "efficiency", e = "none";
      break;
    case "beam":
      t = "beam", e = "l";
      break;
    default:
      t = null, e = null;
      break;
  }
  return {
    cutPreference: e,
    cutType: t
  };
}
var Z0 = typeof global == "object" && global && global.Object === Object && global, Zy = typeof self == "object" && self && self.Object === Object && self, md = Z0 || Zy || Function("return this")(), sc = md.Symbol, Q0 = Object.prototype, Qy = Q0.hasOwnProperty, t5 = Q0.toString, cl = sc ? sc.toStringTag : void 0;
function e5(n) {
  var t = Qy.call(n, cl), e = n[cl];
  try {
    n[cl] = void 0;
    var i = !0;
  } catch {
  }
  var r = t5.call(n);
  return i && (t ? n[cl] = e : delete n[cl]), r;
}
var n5 = Object.prototype, i5 = n5.toString;
function r5(n) {
  return i5.call(n);
}
var s5 = "[object Null]", o5 = "[object Undefined]", Tp = sc ? sc.toStringTag : void 0;
function yd(n) {
  return n == null ? n === void 0 ? o5 : s5 : Tp && Tp in Object(n) ? e5(n) : r5(n);
}
function bd(n) {
  return n != null && typeof n == "object";
}
var a5 = Array.isArray;
function Fc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
function t1(n) {
  return n;
}
var l5 = "[object AsyncFunction]", u5 = "[object Function]", c5 = "[object GeneratorFunction]", h5 = "[object Proxy]";
function e1(n) {
  if (!Fc(n))
    return !1;
  var t = yd(n);
  return t == u5 || t == c5 || t == l5 || t == h5;
}
var wh = md["__core-js_shared__"], Fp = function() {
  var n = /[^.]+$/.exec(wh && wh.keys && wh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function f5(n) {
  return !!Fp && Fp in n;
}
var d5 = Function.prototype, p5 = d5.toString;
function g5(n) {
  if (n != null) {
    try {
      return p5.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var m5 = /[\\^$.*+?()[\]{}|]/g, y5 = /^\[object .+?Constructor\]$/, b5 = Function.prototype, v5 = Object.prototype, w5 = b5.toString, x5 = v5.hasOwnProperty, _5 = RegExp(
  "^" + w5.call(x5).replace(m5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function S5(n) {
  if (!Fc(n) || f5(n))
    return !1;
  var t = e1(n) ? _5 : y5;
  return t.test(g5(n));
}
function k5(n, t) {
  return n == null ? void 0 : n[t];
}
function A5(n, t) {
  var e = k5(n, t);
  return S5(e) ? e : void 0;
}
function N5(n, t, e) {
  switch (e.length) {
    case 0:
      return n.call(t);
    case 1:
      return n.call(t, e[0]);
    case 2:
      return n.call(t, e[0], e[1]);
    case 3:
      return n.call(t, e[0], e[1], e[2]);
  }
  return n.apply(t, e);
}
var C5 = 800, P5 = 16, L5 = Date.now;
function I5(n) {
  var t = 0, e = 0;
  return function() {
    var i = L5(), r = P5 - (i - e);
    if (e = i, r > 0) {
      if (++t >= C5)
        return arguments[0];
    } else
      t = 0;
    return n.apply(void 0, arguments);
  };
}
function E5(n) {
  return function() {
    return n;
  };
}
var Mp = function() {
  try {
    var n = A5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), O5 = Mp ? function(n, t) {
  return Mp(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: E5(t),
    writable: !0
  });
} : t1, T5 = I5(O5), F5 = 9007199254740991, M5 = /^(?:0|[1-9]\d*)$/;
function n1(n, t) {
  var e = typeof n;
  return t = t ?? F5, !!t && (e == "number" || e != "symbol" && M5.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function i1(n, t) {
  return n === t || n !== n && t !== t;
}
var Rp = Math.max;
function R5(n, t, e) {
  return t = Rp(t === void 0 ? n.length - 1 : t, 0), function() {
    for (var i = arguments, r = -1, s = Rp(i.length - t, 0), o = Array(s); ++r < s; )
      o[r] = i[t + r];
    r = -1;
    for (var a = Array(t + 1); ++r < t; )
      a[r] = i[r];
    return a[t] = e(o), N5(n, this, a);
  };
}
function D5(n, t) {
  return T5(R5(n, t, t1), n + "");
}
var B5 = 9007199254740991;
function r1(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= B5;
}
function s1(n) {
  return n != null && r1(n.length) && !e1(n);
}
function j5(n, t, e) {
  if (!Fc(e))
    return !1;
  var i = typeof t;
  return (i == "number" ? s1(e) && n1(t, e.length) : i == "string" && t in e) ? i1(e[t], n) : !1;
}
var q5 = Object.prototype;
function z5(n) {
  var t = n && n.constructor, e = typeof t == "function" && t.prototype || q5;
  return n === e;
}
function $5(n, t) {
  for (var e = -1, i = Array(n); ++e < n; )
    i[e] = t(e);
  return i;
}
var U5 = "[object Arguments]";
function Dp(n) {
  return bd(n) && yd(n) == U5;
}
var o1 = Object.prototype, W5 = o1.hasOwnProperty, H5 = o1.propertyIsEnumerable, G5 = Dp(/* @__PURE__ */ function() {
  return arguments;
}()) ? Dp : function(n) {
  return bd(n) && W5.call(n, "callee") && !H5.call(n, "callee");
};
function V5() {
  return !1;
}
var a1 = typeof exports == "object" && exports && !exports.nodeType && exports, Bp = a1 && typeof module == "object" && module && !module.nodeType && module, Y5 = Bp && Bp.exports === a1, jp = Y5 ? md.Buffer : void 0, K5 = jp ? jp.isBuffer : void 0, X5 = K5 || V5, J5 = "[object Arguments]", Z5 = "[object Array]", Q5 = "[object Boolean]", tb = "[object Date]", eb = "[object Error]", nb = "[object Function]", ib = "[object Map]", rb = "[object Number]", sb = "[object Object]", ob = "[object RegExp]", ab = "[object Set]", lb = "[object String]", ub = "[object WeakMap]", cb = "[object ArrayBuffer]", hb = "[object DataView]", fb = "[object Float32Array]", db = "[object Float64Array]", pb = "[object Int8Array]", gb = "[object Int16Array]", mb = "[object Int32Array]", yb = "[object Uint8Array]", bb = "[object Uint8ClampedArray]", vb = "[object Uint16Array]", wb = "[object Uint32Array]", cn = {};
cn[fb] = cn[db] = cn[pb] = cn[gb] = cn[mb] = cn[yb] = cn[bb] = cn[vb] = cn[wb] = !0;
cn[J5] = cn[Z5] = cn[cb] = cn[Q5] = cn[hb] = cn[tb] = cn[eb] = cn[nb] = cn[ib] = cn[rb] = cn[sb] = cn[ob] = cn[ab] = cn[lb] = cn[ub] = !1;
function xb(n) {
  return bd(n) && r1(n.length) && !!cn[yd(n)];
}
function _b(n) {
  return function(t) {
    return n(t);
  };
}
var l1 = typeof exports == "object" && exports && !exports.nodeType && exports, _l = l1 && typeof module == "object" && module && !module.nodeType && module, Sb = _l && _l.exports === l1, xh = Sb && Z0.process, qp = function() {
  try {
    var n = _l && _l.require && _l.require("util").types;
    return n || xh && xh.binding && xh.binding("util");
  } catch {
  }
}(), zp = qp && qp.isTypedArray, kb = zp ? _b(zp) : xb;
function Ab(n, t) {
  var e = a5(n), i = !e && G5(n), r = !e && !i && X5(n), s = !e && !i && !r && kb(n), o = e || i || r || s, a = o ? $5(n.length, String) : [], l = a.length;
  for (var h in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (h == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (h == "offset" || h == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || // Skip index properties.
    n1(h, l)) || a.push(h);
  return a;
}
function Nb(n) {
  var t = [];
  if (n != null)
    for (var e in Object(n))
      t.push(e);
  return t;
}
var Cb = Object.prototype, Pb = Cb.hasOwnProperty;
function Lb(n) {
  if (!Fc(n))
    return Nb(n);
  var t = z5(n), e = [];
  for (var i in n)
    i == "constructor" && (t || !Pb.call(n, i)) || e.push(i);
  return e;
}
function Ib(n) {
  return s1(n) ? Ab(n) : Lb(n);
}
var u1 = Object.prototype, Eb = u1.hasOwnProperty, yl = D5(function(n, t) {
  n = Object(n);
  var e = -1, i = t.length, r = i > 2 ? t[2] : void 0;
  for (r && j5(t[0], t[1], r) && (i = 1); ++e < i; )
    for (var s = t[e], o = Ib(s), a = -1, l = o.length; ++a < l; ) {
      var h = o[a], u = n[h];
      (u === void 0 || i1(u, u1[h]) && !Eb.call(n, h)) && (n[h] = s[h]);
    }
  return n;
});
function Ob(n, t, e) {
  if (!ql.includes(t) || !n.machining.corners) return 0;
  const i = c1(n, t);
  return e * i;
}
function c1(n, t) {
  if (!ql.includes(t) || !n.machining.corners) return 0;
  const e = n.machining.corners.find((r) => r.getCorner() === t);
  return e ? e.getLength() : 0;
}
function h1(n, t, e, i) {
  Object.keys(t).forEach((r) => {
    var s, o;
    r in n && ((s = t[r]) != null && s.min && ne(n[r]) < ne(t[r].min) ? e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be less than ${t[r].min}.`,
      fields: [r]
    }) : (o = t[r]) != null && o.max && ne(n[r]) > ne(t[r].max) && e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be greater than ${t[r].max}.`,
      fields: [r]
    }));
  });
}
class rf {
  constructor({ x: t, y: e, diameter: i, depth: r = 0, face: s = 0, type: o = null }) {
    tt(this, "x");
    tt(this, "y");
    tt(this, "diameter");
    tt(this, "depth");
    tt(this, "face");
    tt(this, "valid");
    tt(this, "type");
    this.x = t, this.y = e, this.diameter = i, this.depth = r, this.face = s, this.type = o;
  }
  getFace() {
    return dr[this.face];
  }
  getXDrawPosition(t) {
    let e = 0;
    const i = ne(this.x);
    return t.rot ? e = t.l - ne(this.y) + ("x" in t ? ne(t.x) : 0) : e = i + ("x" in t ? ne(t.x) : 0), e;
  }
  getYDrawPosition(t, e, i) {
    let r = t.rot ? ne(this.x) : ne(this.y);
    return r += "y" in t ? ne(t.y) : 0, e === 1 && (i ? r = ne(i.w) - r : r = ne(t.w) - r), r;
  }
  shouldShow(t, e) {
    return this.face === e || this.isThroughShape(t) === !0;
  }
  isThroughShape(t) {
    return !this.depth || ne(this.depth) >= ne(t.t);
  }
  getDistanceToEdge(t) {
    const e = this.x, i = this.y, r = this.diameter / 2, s = ne(t.getLongSide()), o = ne(t.getShortSide()), a = t.machining.corners.map((m) => m.type ? m.size : 0), l = [
      {
        edge: "left",
        distance: e - r
      },
      {
        edge: "right",
        distance: s - e - r
      },
      {
        edge: "bottom",
        distance: o - i - r
      },
      {
        edge: "top",
        distance: i - r
      }
    ], h = t.machining.corners.map((m, b) => {
      const x = b === 0 || b === 3, y = b < 2, v = x ? e : s - e;
      let k = null;
      this.face === 0 ? k = y ? i : o - i : this.face === 1 && (k = y ? o - i : i);
      const C = Math.sqrt(v * v + k * k);
      return {
        c: m,
        distance: C
      };
    }), u = Math.min(...l.map((m) => m.distance)), d = Math.min(...h.map((m) => m.distance)), p = h.findIndex((m) => m.distance === d), f = t.machining.corners[p];
    if (f && f.type === "radius") {
      let m = p === 0 || p === 3 ? 0 : s, b = p < 2 ? 0 : o;
      const x = p < 2;
      m += p === 0 || p === 3 ? a[p] : -a[p], b += x ? a[p] : -a[p];
      const v = e - m, k = p < 2;
      let C;
      this.face === 0 ? C = k ? i : o - i : this.face === 1 && (C = k ? o - i : i);
      const E = C - b, q = Math.sqrt(v * v + E * E), T = a[p] - q - r;
      let F = !1;
      return f.index === 0 ? F = e <= m && C <= b : f.index === 1 ? F = e >= m && C <= b : f.index === 2 ? F = e >= m && C >= b : f.index === 3 && (F = e <= m && C >= b), F && T < u ? T : u;
    } else if (f && f.type === "bevel") {
      let m, b, x;
      f.index === 0 ? (m = 1, b = 1, x = -f.size) : f.index === 1 ? (m = 1, b = -1, x = -s + f.size) : f.index === 2 ? (m = 1, b = 1, x = -s - o + f.size) : f.index === 3 && (m = -1, b = 1, x = -o + f.size);
      const y = f.index === 0 ? 1 : -1, v = (m * e + b * i + x) / Math.sqrt(m * m + b * b) * y - r;
      return v < u ? v : u;
    } else
      return u;
  }
  validate(t, e, i = null) {
    const r = [];
    if (!qt(this.x) || !qt(this.y) || !qt(this.diameter)) {
      const o = {
        index: e,
        message: "X, Y & diameter are all required.",
        fields: []
      };
      this.x || o.fields.push("x"), this.y || o.fields.push("y"), this.diameter || o.fields.push("diameter"), r.push(o);
    }
    return ne(this.diameter) <= 0 && r.push({
      index: e,
      message: "Diameter cannot be negative or zero.",
      fields: ["diameter"]
    }), ne(this.depth) < 0 && r.push({
      index: e,
      message: "Depth cannot be negative.",
      fields: ["depth"]
    }), "t" in t && ne(t.t) > 0 && ne(this.depth) > ne(t.t) && r.push({
      index: e,
      message: "Depth cannot be greater than part thickness.",
      fields: ["depth"]
    }), (!("t" in t) || !t.t) && ne(this.depth) > 0 && r.push({
      index: e,
      message: "Part thickness is not defined.",
      fields: ["depth"]
    }), this.getDistanceToEdge(t) < 0 && r.push({
      index: e,
      message: "Outside of part."
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class $p {
  constructor({
    position: t = null,
    //from left or bottom
    edge: e = "x1",
    face: i = 0,
    numHoles: r = null,
    diameter: s = 0,
    depth: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    hingeLength: h = 0,
    minimumHoleDistance: u = 0,
    positionLimit: d = 0
  }, p) {
    tt(this, "position");
    tt(this, "edge");
    tt(this, "face");
    tt(this, "numHoles");
    tt(this, "holes", []);
    tt(this, "diameter");
    tt(this, "depth");
    tt(this, "distanceFromEdge");
    //from edge to center of hole
    tt(this, "outerSpacing");
    //from edge to center of hole
    tt(this, "hingeLength");
    tt(this, "minimumHoleDistance");
    tt(this, "positionLimit");
    tt(this, "valid");
    this.position = t, this.edge = e, this.face = i, this.numHoles = r, this.diameter = s, this.depth = o, this.distanceFromEdge = a, this.outerSpacing = l, this.hingeLength = h, this.minimumHoleDistance = u, this.positionLimit = d, p && this.createHoles(p);
  }
  getFace() {
    return dr[this.face];
  }
  getHoleSpacing() {
    const t = ne(this.hingeLength) - ne(this.outerSpacing) * 2, e = this.numHoles - 1;
    return t / e;
  }
  getHoleXPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
        i = this.distanceFromEdge;
        break;
      case "x2":
        i = t.getLongSide() - ne(this.distanceFromEdge);
        break;
      case "y1":
      case "y2":
        i = ne(this.position) + ne(this.outerSpacing) + r * e;
        break;
    }
    return i;
  }
  getHoleYPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
      case "x2":
        i = ne(this.position) + ne(this.outerSpacing) + r * e;
        break;
      case "y1":
        i = ne(this.distanceFromEdge);
        break;
      case "y2":
        i = t.getShortSide() - ne(this.distanceFromEdge);
        break;
    }
    return i;
  }
  createHoles(t) {
    this.holes = [];
    for (let e = 0; e < this.numHoles; e++) {
      const i = new rf({
        x: this.getHoleXPosition(t, e),
        y: this.getHoleYPosition(t, e),
        diameter: this.diameter,
        depth: this.depth,
        face: this.face,
        type: "hinge"
      });
      this.holes.push(i);
    }
    return this.holes;
  }
  validate(t, e, i = null) {
    const r = [];
    return this.holes.forEach((s, o) => {
      const a = s.validate(t, o).map((l) => (l.index = e, l.message = `Hole ${o + 1}: ${l.message}`, l));
      r.push(...a);
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class Up {
  constructor({ type: t = "radius", size: e, index: i }) {
    tt(this, "type");
    tt(this, "size");
    tt(this, "index");
    tt(this, "valid");
    this.type = t, this.size = e, this.index = i;
  }
  getLength() {
    return this.type === "radius" ? Math.PI * this.size / 2 : this.type === "bevel" ? Math.sqrt(2) * this.size : 0;
  }
  getCorner() {
    return ["a", "b", "c", "d"][this.index];
  }
  isPresent() {
    return (this.valid === !0 || this.valid === void 0) && this.type !== null && this.size > 0;
  }
  validate(t, e) {
    const i = t.getShortSide(), r = [];
    if (this.type === null) {
      this.size = null;
      const s = this.getCorner();
      t.banding[s] = !1;
    }
    return this.type && ne(this.size) <= 0 && r.push({
      index: e,
      message: "Corner size cannot be zero or negative"
    }), this.type && ne(this.size) > i / 2 && (this.size = i / 2), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class f1 {
  //shelfHoles?: ShelfHoles[] = [];
  constructor({
    holes: t = [],
    hingeHoles: e = [],
    corners: i = []
  } = {}) {
    tt(this, "holes", []);
    tt(this, "corners", []);
    tt(this, "hingeHoles", []);
    i && i.length === 4 ? this.corners = i.map((r) => new Up(r)) : [0, 1, 2, 3].forEach((r) => {
      this.corners.push(new Up({
        type: null,
        size: null,
        index: r
      }));
    }), t && (this.holes = t.map((r) => new rf(r))), e && (this.hingeHoles = e.map((r) => new $p(r)));
  }
  validateEverything(t, e = null) {
    const i = this.validate(t, "holes"), r = this.validate(t, "hingeHoles"), s = this.validate(t, "corners");
    t.issues.push(...i.map((o) => mr(t) ? { message: `Part ${t.id} hole issue: ${o.message}`, index: e } : { message: `Hole issue: ${o.message}`, index: e })), t.issues.push(...r.map((o) => mr(t) ? { message: `Part ${t.id} hinge hole issue: ${o.message}`, index: e } : { message: `Hinge hole issue: ${o.message}`, index: e })), t.issues.push(...s.map((o) => mr(t) ? { message: `Part ${t.id} corner issue: ${o.message}`, index: e } : { message: `Corner issue: ${o.message}`, index: e }));
  }
  validate(t, e, i = null) {
    if (!t) return [];
    if (!e) return [];
    const r = [];
    return r.push(...this.validateAll(t, e, i)), r;
  }
  validateAll(t, e, i = null) {
    if (!t) return [];
    const r = [];
    return this[e].forEach((s, o) => r.push(...s.validate(t, o, i))), r;
  }
  createHole(t, e, i, r = 0, s = 0) {
    const o = new rf({
      x: t,
      y: e,
      diameter: i,
      depth: r,
      face: s
    });
    return this.holes.push(o), o;
  }
  createHingeHoles({
    numHoles: t,
    position: e,
    diameter: i,
    depth: r = 0,
    edge: s = "x1",
    face: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    minimumHoleDistance: h = 0,
    hingeLength: u = 0
  }) {
    const d = new $p({
      numHoles: t,
      position: e,
      //from left or bottom
      edge: s,
      face: o,
      diameter: i,
      depth: r,
      distanceFromEdge: a,
      outerSpacing: l,
      minimumHoleDistance: h,
      hingeLength: u
    });
    return this.hingeHoles.push(d), d;
  }
  updateHingeHoles(t) {
    this.hingeHoles.forEach((e) => e.createHoles(t));
  }
  getAllHingeHoles(t) {
    const e = [];
    return this.hingeHoles.forEach((i) => {
      i.holes.length ? e.push(...i.holes) : (i.createHoles(t), e.push(...i.holes));
    }), e;
  }
  getNumHoles() {
    return this.holes.length + this.hingeHoles.reduce(
      (t, e) => t + e.numHoles,
      0
    );
  }
  getNumCorners() {
    return this.corners.filter((t) => t.type !== null).length;
  }
}
function d1(n) {
  var t, e, i, r, s, o, a, l;
  return !n || !(n != null && n.machining) ? !1 : (e = (t = n.machining) == null ? void 0 : t.holes) != null && e.length || (r = (i = n.machining) == null ? void 0 : i.hingeHoles) != null && r.length ? !0 : (o = (s = n.machining) == null ? void 0 : s.corners) != null && o.length ? (l = (a = n.machining) == null ? void 0 : a.corners) == null ? void 0 : l.some((h) => h.type && h.size) : !1;
}
function Tb(n) {
  var t, e, i, r;
  if ("machining" in n) {
    if (!d1(n)) {
      n.machining = null;
      return;
    }
    (t = n.machining.holes) != null && t.length || (n.machining.holes = null), (e = n.machining.hingeHoles) != null && e.length || (n.machining.hingeHoles = null), (r = (i = n.machining) == null ? void 0 : i.corners) != null && r.some((s) => s.type && s.size) || (n.machining.corners = null);
  }
}
class Fb {
  constructor(t = null) {
    tt(this, "id");
    //api
    tt(this, "listId");
    tt(this, "shapeListIds", []);
    tt(this, "shapes");
    tt(this, "direction");
    tt(this, "q");
    tt(this, "duplicate", !1);
    tt(this, "issues", []);
    tt(this, "stockMatch");
    var e;
    this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Math.ceil(Math.random() * 1e16), this.id = t == null ? void 0 : t.id, this.shapes = qt(t == null ? void 0 : t.shapes) ? t.shapes.map((i) => i.toString()) : [], this.shapeListIds = qt(t == null ? void 0 : t.shapeListIds) ? t.shapeListIds : [], this.direction = qt(t == null ? void 0 : t.direction) ? t.direction : "l", this.q = qt(t == null ? void 0 : t.q) ? t.q : 1, qt(t == null ? void 0 : t.shapeList) && ((e = t.shapeList) != null && e.length) && this.validate(t.shapeList);
  }
  validate(t = []) {
    var o, a;
    if (this.issues = [], !(t != null && t.length))
      throw new Error("shapeList is required to validate user group");
    const e = this.findShapes(t);
    if (!e.length)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    const i = e[0];
    if (mr(i)) {
      if (!(this != null && this.shapes) || ((o = this.shapes) == null ? void 0 : o.length) < 2)
        return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    } else if (!(this != null && this.shapeListIds) || ((a = this.shapeListIds) == null ? void 0 : a.length) < 2)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    if (e.forEach((l, h) => {
      !l.isSquare() && !["l", "w"].includes(l.orientationLock) && this.issues.push({ message: `Part in position ${h + 1} must have orientation lock set to be part of a group.` });
    }), this.issues.length) return this.issues;
    const r = xo(this.direction), s = i.getTrimmedDimensions(!0)[r];
    return e.forEach((l, h) => {
      if (l.id === i.id) return;
      const u = l.getTrimmedDimensions(!0)[r];
      Ue.equalTo(u, s) || this.issues.push({ message: `Part in position ${h + 1} final ${r === "l" ? "length" : "width"} is not correct for the group. Expected ${s} and is ${u}. Check the dimensions, trim & orientation lock.` });
    }), this.issues;
  }
  findShapes(t = []) {
    var i, r;
    if (!t.length) return [];
    let e = [];
    if (hr(t[0])) {
      if (!((i = this.shapeListIds) != null && i.length)) return [];
      if (e = this.shapeListIds.map((s) => t.find((o) => o.listId === s)).filter((s) => s), !e.length)
        throw new Error("could not map group shapes to shape list");
      return e;
    } else {
      if (!((r = this.shapes) != null && r.length)) return [];
      const s = /* @__PURE__ */ new Set();
      e = this.shapes.map((o) => {
        const a = t.find((l) => l.parentID === o && !l.inUserGroup && !s.has(l.id));
        return a ? (s.add(a.id), a) : null;
      }).filter((o) => o);
    }
    if (!e.length)
      throw new Error("could not map group shapes to shape list");
    return e;
  }
  populateParentID(t) {
    var e;
    t != null && t.length && (e = this == null ? void 0 : this.shapeListIds) != null && e.length && (this.shapes = this.shapeListIds.map((i) => (t.findIndex((s) => s.listId === i) + 1).toString()));
  }
  //create a group from a user group
  createGroup(t = 0, e = 0, i = [], r = null) {
    if (!(i != null && i.length))
      throw new Error("some parts are required to create a user group");
    if (!mr(i[0]))
      throw new Error("shapeList must be of type Shape[]");
    const s = this.findShapes(i);
    if (!s.length) return !1;
    const o = s[0];
    s.forEach((u) => {
      const d = i.findIndex((p) => !p.inUserGroup && p.parentID === u.parentID);
      if (d === -1)
        throw new Error("shape not found in shapeList while creating user group.");
      i.splice(d, 1), u.setRotationToOrientationLockWithoutContainer(), u.inUserGroup = !0;
    });
    let a = 0, l = 0;
    this.direction === "l" ? l = o.w : a = o.l;
    let h;
    try {
      const u = {
        id: `ug${t}.${e}`,
        shapes: s,
        l: a,
        w: l,
        t: o == null ? void 0 : o.t,
        material: o == null ? void 0 : o.material,
        // joinDimension:
        //     referenceShape.l === l ? referenceShape.l : referenceShape.w,
        direction: this.direction,
        preventAutoRotation: !0,
        container: r,
        type: "user"
      };
      h = new zs(u);
    } catch (u) {
      return console.error(u), !1;
    }
    return h.parentID = `ug${t}`, r && h.updateShapeSpacing(r), h;
  }
}
const gr = ["y1", "y2", "x1", "x2"], ql = ["a", "b", "c", "d"], Es = [...gr, ...ql], dr = ["a", "b"];
function p1(n) {
  return ql.includes(n);
}
function Mb(n) {
  return Es.includes(n);
}
const sf = {
  x: "x",
  y: "y",
  l: "length",
  w: "width",
  t: "thickness",
  q: "quantity",
  orientationLock: "rotation",
  name: "name",
  material: "material",
  banding: "banding",
  finish: "finish",
  cost: "cost",
  grain: "grain",
  trim: "trim",
  x1: "w1",
  x2: "w2",
  y1: "l1",
  y2: "l2",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  all: "all"
};
function Rb(n) {
  return gr.map((t) => n[t] ?? null);
}
function So(n) {
  if (!qt(n) || typeof n != "object") return {};
  n = { ...n };
  for (const [t, e] of Object.entries(n))
    t !== "_id" && t.startsWith("_") && (n[t.substring(1)] = e, delete n[t]);
  return n;
}
function Db(n, t = null) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    var i;
    return delete e.id, t ? e.units = t : e.units || (e.units = ((i = this == null ? void 0 : this.optionsStore) == null ? void 0 : i.units) ?? "decimal"), new vd(e);
  });
}
function Bb({
  stockList: n,
  removeScores: t = !1,
  saw: e = null,
  preventAutoRotation: i = !1,
  preventGrainRotation: r = !1
}) {
  return !n || !(n != null && n.length) ? [] : n.filter((s) => s).map((s) => {
    e && (s.saw = e), i && (s.preventAutoRotation = !0), r && (s.preventGrainRotation = !0);
    const o = new es(s);
    if (o.issues.length)
      throw new Error(
        `Issues found when attempting to recreate stock list - ${o.issues.map((a) => a.message).join()}`,
        { cause: o.issues }
      );
    return t && delete o.algoBenchmark, o;
  }).sort(Ju.ID);
}
function jb({
  shapeList: n,
  stockList: t,
  preventAutoRotation: e = !1
}) {
  if (typeof t > "u")
    throw new Error("recreateShapeList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.filter((i) => i).map((i) => {
    var o;
    e && (i.preventAutoRotation = !0);
    let r;
    if (Vb(i) && ((o = i == null ? void 0 : i.shapes) != null && o.length)) {
      i.shapes = i.shapes.map((a) => new ns(a));
      try {
        r = new zs(i);
      } catch {
        throw new Error("error creating group from shape data");
      }
    } else
      r = new ns(i);
    if (r.issues.length)
      throw new Error(`Issues found when attempting to recreate shape list - ${r.issues.join()}`);
    const s = t.find((a) => {
      var l;
      return a.id === (((l = i == null ? void 0 : i.stock) == null ? void 0 : l.id) ?? (i == null ? void 0 : i.stockId));
    });
    return r.stock = s, r;
  }).sort(Ju.ID);
}
function qb({
  cutList: n,
  stockList: t
}) {
  if (typeof t > "u")
    throw new Error("recreateCutList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = new Tc(e), r = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return i.stock = r, i;
  });
}
function zb({
  segmentList: n,
  stockList: t
}) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return e.stock = i, new y1(e);
  });
}
function g1(n = null, t = null, e = null) {
  if (!n) throw new Error("no container supplied to willItFit");
  if (!t) throw new Error("no shape supplied to willItFit");
  const i = t.rot;
  function r(p = !1, f = "l") {
    var m, b;
    return Ue.equalTo(
      t[p ? xo(f) : f],
      n[f]
    ) || Ue.lessThanOrEqualTo(t[p ? xo(f) : f], n[f] - (of(n) ? (b = (m = n == null ? void 0 : n.saw) == null ? void 0 : m.options) == null ? void 0 : b.minSpacing : 0));
  }
  function s(p = !0) {
    return t.forceRotate(i), p;
  }
  const o = t.getNecessaryOrientation(n);
  let a = null;
  if (o && (a = o === "l" ? 0 : 1), t.orientationLock) {
    if (qt(e) && e !== a)
      return s(!1);
    t.forceRotate(a);
  } else qt(e) && t.forceRotate(e);
  if (a && t.rot !== a)
    return s(!1);
  const l = r(!1, "l"), h = r(!1, "w"), u = r(!0, "l"), d = r(!0, "w");
  return qt(e) || o ? s(l && h) : s(l && h || u && d);
}
function oc(n, t, e = "decimal", i = !1) {
  return qt(n == null ? void 0 : n[t]) ? ne(n[t], e, !1, i) : null;
}
class m1 {
  constructor(t, e = !1) {
    tt(this, "readonly");
    tt(this, "id");
    tt(this, "listId");
    tt(this, "units", "decimal");
    tt(this, "l");
    tt(this, "w");
    tt(this, "t");
    tt(this, "q");
    tt(this, "name");
    tt(this, "material");
    tt(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    tt(this, "cost", null);
    tt(this, "grain", "");
    tt(this, "selected", !1);
    //used for multiple editing
    tt(this, "multiEdit", !1);
    //is this the multi-select stock
    tt(this, "type", null);
    tt(this, "autoAdd", !1);
    tt(this, "used");
    tt(this, "saw");
    tt(this, "preventGrainRotation");
    tt(this, "allowExactFitShapes");
    tt(this, "issues", []);
    tt(this, "warnings", []);
    tt(this, "notes", "");
    var s, o;
    t = So(t), qt(t.units) || console.warn("Attempting to create InputStock without units"), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((a) => {
      this[a] = oc(t, a, this.units, e);
    }), this.q = qt(t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.autoAdd = qt(t.autoAdd) ? t.autoAdd : !1, this.name = qt(t.name) ? $l(t.name).toUpperCase() : "", this.material = qt(t.material) ? t.material.trim().toUpperCase() : "";
    const r = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }, r.forEach((a) => {
      this.trim[a] = oc(t.trim, a, this.units, e);
    }), this.cost = qt(t.cost) ? t.cost : null, t.grain = (s = t == null ? void 0 : t.grain) == null ? void 0 : s.toLowerCase(), (t == null ? void 0 : t.grain) === " " && (t.grain = ""), this.grain = t.grain, this.multiEdit = t.multiEdit, this.type = t.type, this.allowExactFitShapes = qt(t == null ? void 0 : t.allowExactFitShapes) ? t.allowExactFitShapes : !1, this.preventGrainRotation = !0, this.notes = t != null && t.notes ? (o = t.notes) == null ? void 0 : o.replace(/,/g, "") : "";
  }
  //change the units of the stock
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? ne(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = qt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  //change the type of stock
  changeType(t) {
    switch (t !== "sheet" && (this.grain = ""), t) {
      case "linear":
        this.trim.y1 = 0, this.trim.y2 = 0;
        break;
      case "roll":
        this.trim.x1 = 0, this.trim.x2 = 0, this.trim.y1 = 0, this.trim.y2 = 0, this.t = null;
        break;
    }
  }
  //create an id from an index
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  isSquare() {
    return this.l === this.w;
  }
  getWarnings() {
    this.warnings = [], ["q"].forEach((t) => this.warnings.push(...ai[t](this[t])));
  }
  validate() {
    return this.issues = [], ["l", "w", "t"].forEach((t) => this.issues.push(...ai[t](this[t]))), this.issues.push(...ai.trim(this)), this.getWarnings(), this.issues;
  }
}
class vd {
  constructor(t, e = !1) {
    tt(this, "readonly");
    tt(this, "id");
    tt(this, "listId");
    tt(this, "units", "decimal");
    tt(this, "l");
    tt(this, "w");
    tt(this, "t");
    tt(this, "q", 1);
    tt(this, "name", "");
    tt(this, "material", "");
    tt(this, "cost");
    tt(this, "orientationLock");
    tt(this, "selectedMaterial");
    tt(this, "selected", !1);
    //used for multiple editing
    tt(this, "multiEdit", !1);
    tt(this, "issues", []);
    tt(this, "warnings", []);
    tt(this, "notes", "");
    tt(this, "stockLock");
    tt(this, "stockMatch");
    tt(this, "customData");
    //objects
    tt(this, "machining");
    tt(this, "trim", Object.fromEntries(
      gr.map((t) => [t, 0])
    ));
    tt(this, "banding", Object.fromEntries(
      Es.map((t) => [t, !1])
    ));
    tt(this, "bandingOptions", Object.fromEntries([
      ...Es,
      "all"
    ].map((t) => [t, {}])));
    tt(this, "finish", Object.fromEntries(
      dr.map((t) => [t, ""])
    ));
    tt(this, "finishOptions", Object.fromEntries(
      dr.map((t) => [t, {}])
    ));
    var r, s, o, a, l;
    t = t = So(t), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((h) => {
      this[h] = oc(t, h, this.units, e);
    }), this.q = qt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.name = qt(t.name) ? $l(t.name).toUpperCase() : "", this.material = qt(t.material) ? t.material.trim().toUpperCase() : "", this.multiEdit = t.multiEdit, this.notes = t != null && t.notes ? (r = t.notes) == null ? void 0 : r.replace(/,/g, "") : "", this.stockLock = (t == null ? void 0 : t.stockLock) ?? [];
    for (const h of Object.keys(this.trim))
      this.trim[h] = oc(t.trim, h, this.units, e);
    for (const h of Object.keys(this.banding))
      this.banding[h] = qt((s = t == null ? void 0 : t.banding) == null ? void 0 : s[h]) ? t.banding[h] : !1;
    for (const h of Object.keys(this.bandingOptions))
      this.bandingOptions[h] = qt((o = t == null ? void 0 : t.bandingOptions) == null ? void 0 : o[h]) ? t.bandingOptions[h] : {};
    for (const h of Object.keys(this.finish))
      this.finish[h] = qt((a = t == null ? void 0 : t.finish) == null ? void 0 : a[h]) ? t.finish[h] : "";
    for (const h of Object.keys(this.finishOptions))
      this.finishOptions[h] = qt((l = t == null ? void 0 : t.finishOptions) == null ? void 0 : l[h]) ? t.finishOptions[h] : {};
    this.orientationLock = qt(t.orientationLock) ? t.orientationLock.toLowerCase() : "", this.machining = new f1(t.machining ?? {
      holes: [],
      hingeHoles: [],
      corners: []
    }), this.customData = (t == null ? void 0 : t.customData) ?? {};
  }
  /**
   * change the units of the shape
   * @param {String} newUnits
   */
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? ne(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = qt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  isSquare() {
    return this.l === this.w;
  }
  /**
   * change the type of the stock
   * @param {String} newType
   */
  changeStockType(t) {
    switch (t) {
      case "sheet":
      case "roll":
        this.orientationLock = "", t === "roll" && (this.t = null);
        break;
      case "linear":
        this.orientationLock = "", this.banding = Object.fromEntries(
          Es.map((e) => [e, !1])
        );
        break;
    }
  }
  /**
   * create an id from an index
   * @param {Integer} index
   * @param {Integer} secondaryIndex
   */
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  getLongSide() {
    return ne(this.l) > ne(this.w) ? ne(this.l) : ne(this.w);
  }
  getShortSide() {
    return ne(this.l) < ne(this.w) ? ne(this.l) : ne(this.w);
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      name: this.name,
      listId: this.listId,
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      name: this.name,
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: ne(this.l), w: ne(this.w) };
    return t && (e = this.getRotatedDimensions()), {
      name: this.name,
      listId: this.listId,
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2),
      orientationLock: this.orientationLock
    };
  }
  //used to apply a single trim value to all sides
  applyPartTrim(t, e) {
    if (!this.readonly)
      if (t = ne(t), this.trim) {
        for (const i in this.trim)
          this.trim[i] = t;
        e === "linear" && (this.trim.y1 = 0, this.trim.y2 = 0);
      } else
        this.trim = {
          x1: t,
          x2: t,
          y1: e !== "linear" ? t : 0,
          y2: e !== "linear" ? t : 0
        };
  }
  /**
   * to align with Shape
   * @remarks input shapes are always 0
   */
  get rot() {
    return 0;
  }
  validate(t, e, i, r = 0, s = !1) {
    return this.issues = [], ["l", "w", "t"].forEach((o) => {
      const a = ai[o](this[o], e);
      a.length && this.issues.push(...a);
    }), r = ne(r), this.issues.push(...ai.partTrim(this, r, e)), this.issues.push(...ai.trim(this, e)), ai.machining(this, e), this.getWarnings(t, e, i, r, s), this.issues;
  }
  getWarnings(t, e = null, i, r = 0, s = !1) {
    this.warnings = [], ["q"].forEach((o) => {
      this.warnings.push(...ai[o](this[o], e));
    }), t.length && !s && this.warnings.push(...ai.stockMatch(this, t, i, r, e));
  }
}
class zl {
  constructor(t) {
    tt(this, "id");
    tt(this, "parentID");
    tt(this, "name");
    tt(this, "x");
    tt(this, "y");
    tt(this, "l");
    tt(this, "w");
    tt(this, "t");
    tt(this, "q");
    tt(this, "material");
    tt(this, "grain");
    tt(this, "orientationLock");
    tt(this, "duplicate");
    tt(this, "trimmed");
    tt(this, "preventAutoRotation");
    tt(this, "preventGrainRotation");
    tt(this, "units");
    tt(this, "issues", []);
    tt(this, "stock");
    tt(this, "stockId");
    //used when object is compressed
    tt(this, "cost");
    tt(this, "offcut");
    tt(this, "notes");
    //for user notes
    tt(this, "proximity");
    //objects
    tt(this, "_trim", Object.fromEntries(
      gr.map((t) => [t, 0])
    ));
    tt(this, "customData");
    this.initRectangle(t);
  }
  validateRectangle(t) {
    Pr(this) || ["x", "y", "l", "w", "t"].forEach((e) => {
      this.createIssues(ai[e](t[e]));
    }), ts(this) && "q" in t && this.createIssues(ai.q((t == null ? void 0 : t.q) ?? 0, t.autoAdd)), "q" in t && this.isShape() && !this.isGroup() && !this.isUserGroup() && this.createIssues(ai.q((t == null ? void 0 : t.q) ?? 0)), "customData" in t && this.createIssues(ai.customData((t == null ? void 0 : t.customData) ?? {}));
  }
  initRectangle(t, e = !1) {
    var r, s, o;
    if (!e) {
      if (this.validateRectangle(t), this.issues.length) return;
      this.id = qt(t.id) ? t.id.toString() : this.id || null, this.setParentID(), qt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? this.q = parseInt(t.q) : this.q = t.q : this.q = 0, this.name = qt(t.name) && ((r = t == null ? void 0 : t.name) != null && r.length) ? (s = b1($l(t == null ? void 0 : t.name))) == null ? void 0 : s.toUpperCase() : null, qt(t == null ? void 0 : t.cost) ? typeof t.cost == "string" ? this.cost = parseFloat(t.cost) : typeof t.cost == "number" && (this.cost = t.cost) : this.cost = 0, this.material = qt(t.material) ? t.material.trim().toLowerCase() : null, this.duplicate = qt(t == null ? void 0 : t.duplicate) ? t.duplicate : !1, this.grain = typeof t.grain < "u" && qt(t == null ? void 0 : t.grain) ? t.grain.toLowerCase() : null, this.trimmed = qt(t == null ? void 0 : t.trimmed) ? t.trimmed : !1, this.offcut = qt(t == null ? void 0 : t.offcut) ? t.offcut : !1, this.notes = typeof (t == null ? void 0 : t.notes) == "string" && t.notes.length ? t.notes.replace(/,/g, "").substring(0, 200) : "", this.customData = (t == null ? void 0 : t.customData) ?? {}, this.proximity = {
        rectangle: null,
        distance: null
      };
      try {
        this.trim = t == null ? void 0 : t.trim;
      } catch (a) {
        if ((o = a == null ? void 0 : a.cause) != null && o.issues) this.issues.push(...a.cause.issues);
        else throw new Error("error when attempting to set trim");
      }
    }
    [
      {
        key: "x",
        default: 0,
        required: !1
      },
      {
        key: "y",
        default: 0,
        required: !1
      },
      {
        key: "l",
        default: null,
        required: !0
      },
      {
        key: "w",
        default: 1,
        //for linear
        required: !0
      },
      {
        key: "t",
        default: null,
        required: !1
      }
    ].forEach((a) => {
      let l = t[a.key];
      if (!qt(l))
        return this[a.key] = this[a.key] || a.default;
      typeof l == "string" && (l = ne(l)), this[a.key] = l;
    }), !(t != null && t.preventAutoRotation) && !t.trimmed && this.w > this.l && ([this.l, this.w] = [this.w, this.l], this.grain && !(t != null && t.preventGrainRotation) && (this.grain = xo(this.grain))), qt(t == null ? void 0 : t.stock) && (ts(t.stock) ? this.stock = t.stock : this.stock = new es(t.stock), this.stockId = this.stock.id);
  }
  updateRectangle(t) {
    t.preventAutoRotation = !0, this.initRectangle(t, !0);
  }
  set trim(t) {
    if (this._trim = Object.fromEntries(
      gr.map((e) => [e, 0])
    ), !!ko(t, !0))
      for (const e of gr) {
        let i;
        if (typeof t[e] == "string") {
          const r = ne(t[e]);
          isNaN(r) || r < 0 ? (this.issues.push(
            this.createIssue(
              `${t[e] ?? "N/A"} is not a valid value for trim: ${e}`
            )
          ), i = 0) : i = r;
        } else
          i = t[e];
        this._trim[e] = i;
      }
  }
  get trim() {
    return this._trim;
  }
  get rot() {
    return this.w > this.l ? 1 : 0;
  }
  setParentID() {
    this.parentID = this.getParentID();
  }
  getParentID() {
    return this.id ? this.parentID ? this.parentID : typeof this.id != "number" && this.id.includes(".") ? this.id.split(".")[0] : typeof this.id != "number" && !this.id.includes(".") ? null : this != null && this.id ? this.id.toString() : null : null;
  }
  getCopyNumber() {
    return typeof this.id != "number" && this.id.includes(".") ? parseInt(this.id.split(".")[1]) : 0;
  }
  createIssues(t) {
    t != null && t.length && t.forEach((e) => {
      this.issues.push(this.createIssue(e.message, e.field));
    });
  }
  createIssue(t, e = null) {
    var o;
    let i = "";
    const r = this.getClass();
    switch (r) {
      case "Shape":
        i = "part";
        break;
      case "Stock":
        i = "stock";
        break;
      default:
        i = r.toLowerCase();
        break;
    }
    const s = (o = this == null ? void 0 : this.name) != null && o.length ? this.name.toUpperCase() : this.parentID;
    return s ? {
      message: `${t} [${i.charAt(0).toUpperCase() + i.slice(1)} ${s}]`,
      field: e
    } : { message: t, field: e };
  }
  dimensions() {
    return {
      id: this.id,
      l: this.l,
      w: this.w,
      t: this.t
    };
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  coords() {
    return {
      id: this.id,
      x: this.x,
      y: this.y
    };
  }
  hasCoords(t, e) {
    return this.x === t && this.y === e;
  }
  getAspect() {
    return this.l > this.w ? this.w / this.l : this.l / this.w;
  }
  getPerimeter() {
    return this.w * 2 + this.l * 2;
  }
  getLongSide() {
    return this.l > this.w ? this.l : this.w;
  }
  getShortSide() {
    return this.l < this.w ? this.l : this.w;
  }
  getSides() {
    return [
      this.getSide("bottom"),
      this.getSide("right"),
      this.getSide("top"),
      this.getSide("left")
    ];
  }
  getSide(t) {
    switch (t) {
      case "bottom":
        return new ya({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y,
          type: "bottom"
          // parentID: this.id
        });
      case "right":
        return new ya({
          x1: this.x + this.l,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y + this.w,
          type: "right"
          // parentID: this.id
        });
      case "top":
        return new ya({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y + this.w,
          y2: this.y + this.w,
          type: "top"
          // parentID: this.id
        });
      case "left":
        return new ya({
          x1: this.x,
          x2: this.x,
          y1: this.y,
          y2: this.y + this.w,
          type: "left"
          // parentID: this.id
        });
    }
  }
  getTopPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y + this.w + ((this.stock.getBladeWidth() || e) ?? 0) : this.y + this.w;
  }
  getRightPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x + this.l + ((this.stock.getBladeWidth() || e) ?? 0) : this.x + this.l;
  }
  getBottomPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y - ((this.stock.getBladeWidth() || e) ?? 0) : this.y;
  }
  getLeftPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x - ((this.stock.getBladeWidth() || e) ?? 0) : this.x;
  }
  sharesSide(t, e = 0, i = null) {
    switch (i) {
      case "left":
        return t.x + t.l + e === this.x;
      case "right":
        return t.x === this.x + this.l + e;
      case "bottom":
        return t.y + t.w + e === this.y;
      case "top":
        return t.y === this.y + this.w + e;
    }
    return !1;
  }
  sameSide(t, e = null) {
    switch (e) {
      case "left":
        return t.x === this.x;
      case "right":
        return t.x + t.l === this.x + this.l;
      case "bottom":
        return t.y === this.y;
      case "top":
        return t.y + t.w === this.y + this.w;
    }
    return !1;
  }
  //considers if the shape can rotate
  getLongestDimension(t) {
    return this.orientationLock ? this[t] : this.getLongSide();
  }
  getArea() {
    return this.w * this.l;
  }
  getCoords(t, e = !1) {
    const i = new Hn(this.x + this.l, this.y);
    i.corner = "bottomRight";
    const r = new Hn(this.x, this.y + this.w);
    if (r.corner = "topLeft", (t == null ? void 0 : t.cutType) !== "efficiency" && !e)
      return [r, i];
    const s = new Hn(this.x, this.y);
    s.corner = "bottomLeft";
    const o = new Hn(this.x + this.l, this.y + this.w);
    return o.corner = "topRight", [s, r, o, i];
  }
  getCorners() {
    return {
      bottomLeft: new Hn(this.x, this.y),
      topLeft: new Hn(this.x, this.y + this.w),
      topRight: new Hn(this.x + this.l, this.y + this.w),
      bottomRight: new Hn(this.x + this.l, this.y)
    };
  }
  round() {
    return {
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  getClass() {
    return this.constructor.name;
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: this.l, w: this.w };
    return t && (e = this.getRotatedDimensions()), this.trimmed ? e : {
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2)
    };
  }
  //trim the rectangle
  trimDimensions() {
    var t, e, i, r;
    return this.trimmed ? !1 : (this.trim && Object.values(this.trim).filter((s) => !isNaN(parseFloat(String(s)))).length && (qt(this.l) && (this.l -= ((t = this == null ? void 0 : this.trim) != null && t.x1 ? this.trim.x1 : 0) + ((e = this == null ? void 0 : this.trim) != null && e.x2 ? this.trim.x2 : 0), this.l <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative length")))), qt(this.w) && (this.w -= ((i = this == null ? void 0 : this.trim) != null && i.y1 ? this.trim.y1 : 0) + ((r = this == null ? void 0 : this.trim) != null && r.y2 ? this.trim.y2 : 0), this.w <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative width"))))), this.trimmed = !0, !0);
  }
  /**
   * change the size of the rectangle back to the original size
   */
  removeTrim() {
    var t, e, i, r;
    if (this.trimmed) {
      if (this.l += (typeof ((t = this == null ? void 0 : this.trim) == null ? void 0 : t.x1) == "number" ? this.trim.x1 : 0) + (typeof ((e = this == null ? void 0 : this.trim) == null ? void 0 : e.x2) == "number" ? this.trim.x2 : 0), this.w += (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.y1) == "number" ? this.trim.y1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.y2) == "number" ? this.trim.y2 : 0), this.l <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative length`);
      if (this.w <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative width`);
      this.trimmed = !1;
    }
  }
  getUntrimmedDimensions() {
    var i, r, s, o;
    if (!this.trimmed) return { l: this.l, w: this.w };
    const t = this.getLongSide(), e = this.getShortSide();
    return {
      l: t + (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.x1) == "number" ? this.trim.x1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.x2) == "number" ? this.trim.x2 : 0),
      w: e + (typeof ((s = this == null ? void 0 : this.trim) == null ? void 0 : s.y1) == "number" ? this.trim.y1 : 0) + (typeof ((o = this == null ? void 0 : this.trim) == null ? void 0 : o.y2) == "number" ? this.trim.y2 : 0)
    };
  }
  isIdentical(t, e = !1) {
    if (this.constructor !== t.constructor || this.t !== t.t || this.orientationLock !== t.orientationLock)
      return !1;
    if (Pr(this)) {
      if (t.id === this.id) return !0;
    } else {
      if (t.parentID === this.parentID) return !0;
      if (mr(this) && e && this.parentID !== t.parentID) return !1;
    }
    const { w: i, l: r } = this, { w: s, l: o } = t;
    if (!(i === s && r === o) && !(i === o && r === s))
      return !1;
    const a = this.trim, l = t.trim;
    return !a || !l ? a === l : a.x1 === l.x1 && a.x2 === l.x2 && a.y1 === l.y1 && a.y2 === l.y2;
  }
  /**
   * is this rectangle a square
   */
  isSquare() {
    return this.l === this.w;
  }
  getDistancesToContainerEdges(t) {
    return [
      this.x - t.x,
      t.l - (this.x + this.l),
      t.w - (this.y + this.w),
      this.y - t.y
    ];
  }
  isInsideStock(t) {
    return !(this.x + this.l > t.l || this.y + this.w > t.w || this.x < 0 || this.y < 0);
  }
  /**
  * Creates or retrieves a cached rectangle used for proximity detection.
  * Optimized for frequent calls with the same distance parameter.
  */
  getProximityRectangle(t) {
    if (!t || t < 0) return null;
    const e = this.proximity;
    if ((e == null ? void 0 : e.distance) === t) {
      const r = e.rectangle;
      return this.x === 0 ? (r.x = 0, r.l = this.l + t) : (r.x = this.x - t, r.l = this.l + t * 2), this.y === 0 ? (r.y = 0, r.w = this.w + t) : (r.y = this.y - t, r.w = this.w + t * 2), r;
    }
    const i = new zl({
      id: `${this.id}-proximity`,
      name: "proximity",
      x: this.x === 0 ? 0 : this.x - t,
      y: this.y === 0 ? 0 : this.y - t,
      l: this.x === 0 ? this.l + t : this.l + t * 2,
      w: this.y === 0 ? this.w + t : this.w + t * 2,
      preventAutoRotation: !0
    });
    return this.proximity = { rectangle: i, distance: t }, i;
  }
  isShape() {
    return mr(this);
  }
  isSegment() {
    return Kb(this);
  }
  isStock() {
    return ts(this);
  }
  isGroup() {
    return Pr(this);
  }
  isUserGroup() {
    return xd(this);
  }
}
class wd extends zl {
  constructor(e) {
    super(e);
    tt(this, "type");
    tt(this, "saw");
    tt(this, "algoBenchmark");
    //used by evo
    tt(this, "shapes", []);
    switch (this.shapes = e.shapes, ["sheet", "linear", "roll", null, void 0, ""].includes(e.type) ? this.type = e.type : this.issues.push({ message: `Container type ${e.type ?? "N/A"} is not valid` }), this.type || (this.type = "sheet"), this.setSaw(e), this.cutType) {
      case "beam":
        (!qt(this.t) || this.t <= 0) && this.issues.push(this.createIssue("Stock for beam saws must have a thickness set"));
        break;
    }
  }
  setSaw(e) {
    var i, r, s, o;
    if (qt(e) || (this.saw = new Bs(null)), qt(e == null ? void 0 : e.saw)) {
      if (!((r = e == null ? void 0 : e.saw) != null && r.cutType)) {
        const { cutType: a, cutPreference: l } = nf(e.saw.cutPreference);
        e.saw.cutType = a, e.saw.cutPreference = l;
      }
    } else {
      e.saw = {};
      const { cutType: a, cutPreference: l } = nf(e.cutPreference);
      e.saw.cutType = a, e.saw.cutPreference = l, qt(e == null ? void 0 : e.bladeWidth) && (e.saw.bladeWidth = e.bladeWidth), qt((i = e == null ? void 0 : e.blade) == null ? void 0 : i.width) && (e.saw.bladeWidth = e.blade.width), qt(e == null ? void 0 : e.efficiencyOptions) && (e.saw.efficiencyOptions = e.efficiencyOptions), qt(e == null ? void 0 : e.guillotineOptions) && (e.saw.guillotineOptions = e.guillotineOptions), qt(e == null ? void 0 : e.stackHeight) && (e.saw.stackHeight = e.stackHeight);
    }
    try {
      qt(e == null ? void 0 : e.saw) && (Xb(e.saw) ? this.saw = e.saw : this.saw = new Bs(e.saw, this.type)), (o = (s = this.saw) == null ? void 0 : s.issues) != null && o.length && this.issues.push(...this.saw.issues);
    } catch (a) {
      throw new Error("error creating saw", { cause: a });
    }
  }
  get cutType() {
    var e, i, r, s;
    return qt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.cutType) ? this.saw.cutType : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutType) ?? null;
  }
  get cutPreference() {
    var e, i, r, s;
    return qt((e = this.saw) == null ? void 0 : e.cutPreference) ? this.saw.cutPreference : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutPreference) ?? null;
  }
  get guillotineOptions() {
    var e, i, r, s;
    return qt((e = this.saw) == null ? void 0 : e.guillotineOptions) ? this.saw.guillotineOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.guillotineOptions) ?? null;
  }
  get efficiencyOptions() {
    var e, i, r, s;
    return qt((e = this.saw) == null ? void 0 : e.efficiencyOptions) ? this.saw.efficiencyOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.efficiencyOptions) ?? null;
  }
  get primaryCompression() {
    var e, i;
    if (this.cutType === "efficiency")
      return (i = (e = this.saw) == null ? void 0 : e.efficiencyOptions) != null && i.primaryCompression ? this.efficiencyOptions.primaryCompression : "y";
  }
  getHalfBladeWidth() {
    const e = this.getBladeWidth();
    return e ? e / 2 : 0;
  }
  getBladeWidth() {
    var i, r, s;
    const e = (((i = this == null ? void 0 : this.saw) == null ? void 0 : i.bladeWidth) || ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.bladeWidth)) ?? 0;
    return isNaN(e) ? 0 : e;
  }
  getStock() {
    return ts(this) ? this : this != null && this.stock ? this.stock : null;
  }
}
class Bs {
  constructor(t, e = "sheet") {
    tt(this, "issues");
    tt(this, "bladeWidth");
    tt(this, "cutType");
    tt(this, "cutPreference");
    tt(this, "guillotineOptions");
    tt(this, "efficiencyOptions");
    tt(this, "stackHeight");
    tt(this, "stockType");
    tt(this, "options");
    switch (t = So(t), this.options = yl({}, t == null ? void 0 : t.options, {
      stockSelection: "efficiency",
      stackingMode: "dimensions",
      minSpacing: 0,
      minSpacingDimension: {}
    }), this.stackHeight = (t == null ? void 0 : t.stackHeight) ?? null, this.stockType = (t == null ? void 0 : t.stockType) ?? e, this.issues = [], ["sheet", "linear", "roll"].includes(this.stockType) || this.issues.push({ message: `Saw stock type: ${this.stockType} not valid` }), this.stockType || (this.stockType = "sheet"), this.cutType = t == null ? void 0 : t.cutType, this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "roll":
        ["efficiency", "guillotine", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "linear":
        break;
      default:
        ["none", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
    }
    switch (this.cutPreference = t == null ? void 0 : t.cutPreference, this.cutType) {
      case "guillotine":
        ["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.cutType === "guillotine" && this.cutPreference === "l" && this.stockType === "roll" && this.issues.push({ message: `Cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"} and stock type: ${this.stockType}` }), this.options.minSpacing = 0;
        break;
      case "beam":
        ["l", null, void 0].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.options.minSpacing = 0;
        break;
    }
    switch (qt(t == null ? void 0 : t.bladeWidth) ? typeof t.bladeWidth == "string" ? this.bladeWidth = ne(t.bladeWidth) : this.bladeWidth = t.bladeWidth : this.bladeWidth = 0, (isNaN(this.bladeWidth) || this.bladeWidth < 0) && (this.issues.push({ message: `Blade width: ${this.bladeWidth ?? "N/A"} is not valid` }), this.bladeWidth = 0), this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Invalid cut type: ${this.cutType} for stock type: ${e}, cut preference: ${this.cutPreference}` }), this.cutType === "guillotine" && (["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Invalid cut preference: ${this.cutPreference} for stock type: ${e}, cut type: ${this.cutType}` })), this.cutType === "beam" && [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" }), this.cutType === "beam" && (this.cutPreference = "l"), this.cutType || (this.cutType = "efficiency");
        break;
      case "linear":
        this.cutType = null, this.cutPreference = null;
        break;
    }
    switch (this.cutType) {
      case "efficiency":
        this.efficiencyOptions = yl({}, t == null ? void 0 : t.efficiencyOptions, { primaryCompression: "y" });
        break;
      case "guillotine":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        break;
      case "beam":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null }), this.cutPreference = "l", [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" });
        break;
    }
  }
  clone() {
    const t = structuredClone(this);
    return new Bs(t);
  }
}
class es extends wd {
  constructor(e) {
    e = So(e), e.preventAutoRotation = (e == null ? void 0 : e.type) === "roll", e.autoAdd && !e.q && (e.q = 1);
    super(e);
    tt(this, "_id");
    //used for mongo
    tt(this, "autoAdd");
    tt(this, "allowExactFitShapes");
    tt(this, "analysis");
    tt(this, "tidy");
    tt(this, "used");
    tt(this, "stack");
    tt(this, "winningStrategy");
    //used for reporting
    tt(this, "unusable");
    //used by stock matching
    tt(this, "duplicatePattern");
    tt(this, "score");
    tt(this, "rootSegment");
    delete this.stock, this._id = e == null ? void 0 : e._id, this.autoAdd = qt(e == null ? void 0 : e.autoAdd) ? e.autoAdd : !1, this.allowExactFitShapes = qt(e == null ? void 0 : e.allowExactFitShapes) ? e.allowExactFitShapes : !1, this.analysis = qt(e.analysis) ? e.analysis : null, this.tidy = qt(e == null ? void 0 : e.tidy) ? e.tidy : !1, this.algoBenchmark = null, this.used = qt(e == null ? void 0 : e.used) ? e.used : !1, this.stack = qt(e == null ? void 0 : e.stack) ? e.stack : !1, this.duplicatePattern = (e == null ? void 0 : e.duplicatePattern) ?? null, this.initStock(e);
  }
  initStock(e) {
    switch (this.type) {
      case "linear":
      case "roll":
        this.trim.y1 = 0, this.trim.y2 = 0, this.grain = null;
        break;
    }
    this.validateStock(e), this.issues.length;
  }
  reset() {
    this.used = !1, this.stack = null, this.score = null, this.rootSegment = null, this.tidy = null, this.analysis = null, this.duplicatePattern = null, this.shapes = [];
  }
  validateStock(e) {
    ["grain"].forEach((i) => {
      this.createIssues(ai[i](e[i]));
    }), this.createIssues(ai.trim(this));
  }
  /**
   * compress for saving / transfer
   */
  save() {
    delete this.tidy, delete this.score, delete this.rootSegment, delete this.shapes, delete this.saw, this == null || delete this.algoBenchmark, this.stack = ts(this.stack) ? this.stack.id : this.stack, !this.trim.x1 && !this.trim.x2 && !this.trim.y1 && !this.trim.y2 && (this.trim = null);
  }
  resetStrategies() {
    this.algoBenchmark = null;
  }
  isIdentical(e) {
    let i = !1, r = !1, s = !1, o = !1;
    if (this.material === e.material && (i = !0), this.t === e.t && (r = !0), this.l === e.l && (s = !0), this.w === e.w && (o = !0), i && r && s && o) return !0;
  }
  hasStack() {
    return typeof this.stack == "number";
  }
  isStacked() {
    return ts(this.stack) || typeof this.stack == "string";
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = parseInt(i.pop()), e++), i.push(e.toString());
    const r = i.join("."), s = structuredClone(this);
    return s.id = r, s.used = !1, s.duplicate = !0, s.stack = !1, s.saw = this.saw, new es(s);
  }
}
class $b extends zl {
  constructor(e) {
    super(e);
    tt(this, "addToInventory");
    //for front end selection
    tt(this, "added");
    //for adding to inputStock
    tt(this, "placementOrder");
    tt(this, "flex");
    this.cost = this.getCost(), this.addToInventory = (e == null ? void 0 : e.addToInventory) ?? !0, this.added = !1, this.placementOrder = (e == null ? void 0 : e.placementOrder) ?? null, this.offcut = !0;
  }
  compressForSaving() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) || ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this._trim, delete this.trimmed;
  }
  getCost() {
    var e;
    return (e = this.stock) != null && e.isStock() && this.stock ? parseFloat((this.getArea() / this.stock.getArea() * this.stock.cost).toFixed(2)) : 0;
  }
}
function Ub({
  offcuts: n,
  stockList: t,
  preventAutoRotation: e = !0
}) {
  return !n || !(n != null && n.length) ? [] : n.map((i) => {
    const r = t.find((o) => {
      var a;
      return o.id === (((a = i == null ? void 0 : i.stock) == null ? void 0 : a.id) ?? (i == null ? void 0 : i.stockId));
    });
    return i.stock = r, e && (i.preventAutoRotation = !0), new $b(i);
  });
}
class ns extends zl {
  constructor(e) {
    e = So(e);
    super(e);
    tt(this, "added");
    tt(this, "guillotineData");
    tt(this, "stockLock");
    tt(this, "score");
    tt(this, "bestScore");
    tt(this, "placementOrder");
    //groups
    tt(this, "groupPlacementOrder");
    tt(this, "group");
    tt(this, "groupID");
    tt(this, "inGroup");
    //is the shape currently part of at least one group
    tt(this, "inUserGroup");
    //is the shape currently part of a user group`
    tt(this, "addedAsGroup");
    tt(this, "isFirstShape");
    tt(this, "firstShapeSampleRotations", []);
    //used for setting the rotation of the first shape (guillotine)
    tt(this, "index");
    //used for ptx
    tt(this, "patternMatch");
    //used for stack detection
    tt(this, "stockMatch");
    tt(this, "minSpacing");
    tt(this, "priority");
    tt(this, "weighting", {});
    //objects
    tt(this, "machining");
    tt(this, "_banding", Object.fromEntries(
      Es.map((e) => [e, !1])
    ));
    tt(this, "_finish", Object.fromEntries(
      dr.map((e) => [e, ""])
    ));
    this.initShape(e);
  }
  initShape(e, i = !1) {
    var r;
    if (!i) {
      if (this.validateShape(e), this.issues.length) throw new Error(this.issues.map((s) => s.message).join(`
`));
      e.orientationLock = (r = e == null ? void 0 : e.orientationLock) == null ? void 0 : r.toLowerCase(), (e == null ? void 0 : e.orientationLock) === " " && (e.orientationLock = ""), this.orientationLock = qt(e == null ? void 0 : e.orientationLock) && this.l !== this.w ? e.orientationLock : null, qt(e == null ? void 0 : e.stockLock) ? Array.isArray(e == null ? void 0 : e.stockLock) && (this.stockLock = e.stockLock.map((s) => s.toString())) : this.stockLock = [], this.banding = e == null ? void 0 : e.banding, this.finish = e == null ? void 0 : e.finish, this.machining = qt(e == null ? void 0 : e.machining) ? new f1(e.machining) : null;
    }
    this.added = qt(e == null ? void 0 : e.added) ? e.added : !1, this.initGuillotineData(e), this.inGroup = qt(e == null ? void 0 : e.inGroup) ? e.inGroup : this.inGroup || !1, this.inUserGroup = qt(e == null ? void 0 : e.inUserGroup) ? e.inUserGroup : this.inUserGroup || !1, this.groupID = qt(e == null ? void 0 : e.groupID) ? e.groupID : this.groupID || null, this.addedAsGroup = qt(e == null ? void 0 : e.addedAsGroup) ? e.addedAsGroup : this.addedAsGroup || !1, this.score = qt(e == null ? void 0 : e.score) ? e.score : this.score || null, this.bestScore = qt(e == null ? void 0 : e.bestScore) ? e.bestScore : this.bestScore || {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    }, this.placementOrder = qt(e == null ? void 0 : e.placementOrder) ? e.placementOrder : this.placementOrder || null, this.groupPlacementOrder = qt(e == null ? void 0 : e.groupPlacementOrder) ? e.groupPlacementOrder : this.groupPlacementOrder || null, this.minSpacing = (e == null ? void 0 : e.minSpacing) ?? (this.minSpacing || 0), this.priority = (e == null ? void 0 : e.priority) ?? {};
  }
  initGuillotineData(e) {
    var i, r, s, o, a, l, h, u;
    this.guillotineData = yl({}, e == null ? void 0 : e.guillotineData, {
      firstShape: ((i = this == null ? void 0 : this.guillotineData) == null ? void 0 : i.firstShape) || null,
      myPhase: ((r = this == null ? void 0 : this.guillotineData) == null ? void 0 : r.myPhase) || null,
      myStripParent: ((s = this == null ? void 0 : this.guillotineData) == null ? void 0 : s.myStripParent) || null,
      myStripDirection: ((o = this == null ? void 0 : this.guillotineData) == null ? void 0 : o.myStripDirection) || null,
      stripShapeBatches: {
        subsetUsed: ((l = (a = this == null ? void 0 : this.guillotineData) == null ? void 0 : a.stripShapeBatches) == null ? void 0 : l.subsetUsed) || !1,
        groups: ((u = (h = this == null ? void 0 : this.guillotineData) == null ? void 0 : h.stripShapeBatches) == null ? void 0 : u.groups) || {}
      }
    });
  }
  cloneGuillotineData() {
    var e;
    return (e = this.guillotineData) != null && e.myStripParent && (mr(this.guillotineData.myStripParent) || Pr(this.guillotineData.myStripParent)) && (this.guillotineData.myStripParent = this.guillotineData.myStripParent.compress()), structuredClone(this.guillotineData);
  }
  getCopyNumber() {
    return parseInt(this.id.split(".").pop());
  }
  getMinSpacing(e, i = !1) {
    var o, a;
    if (!e) return 0;
    let r = (this == null ? void 0 : this.minSpacing) || ((a = (o = e.saw) == null ? void 0 : o.options) == null ? void 0 : a.minSpacing) || 0;
    const s = e.getBladeWidth();
    return s > r && (r = s), i && (r -= s), r < 0 && (r = 0), r;
  }
  validateShape(e) {
    ["orientationLock", "banding"].forEach((i) => {
      this.createIssues(ai[i](e[i]));
    }), this.machining && this.machining.validateEverything(this);
  }
  //individual shape weighting
  /* calculateWeighting()
  	{
  		// const aspect = this.w / this.l;
  		if ( aspect > 0.5 )
  		{
  			//cater for small parts
  			const area = s.getArea();
  			const areaPercentage = area / maxArea;
  
  			if ( areaPercentage <= 0.1 )
  			{
  				s.weighting.edge = areaPercentage;
  			}
  		}
  		//the closer to zero, the higher the edge weighting
  		this.weighting.edge = 1 - aspect;
  		this.weighting.edge *= 2;
  	} */
  update(e) {
    e = So(e), this.initShape(e, !0), this.updateRectangle(e);
  }
  //banding
  set banding(e) {
    if (this._banding = Object.fromEntries(
      Es.map((i) => [i, !1])
    ), !!ko(e, !0))
      for (const i of Es)
        this._banding[i] = qt(e == null ? void 0 : e[i]) ? e[i] : !1;
  }
  get banding() {
    return this._banding;
  }
  //get an array of banding in the order L1, L2, W1, W2
  get bandingArray() {
    return Rb(this._banding);
  }
  get finish() {
    return this._finish;
  }
  get FacesArray() {
    return dr.map((e) => {
      var i;
      return (i = this.finish) == null ? void 0 : i[e];
    });
  }
  set finish(e) {
    if (this._finish = Object.fromEntries(
      dr.map((i) => [i, ""])
    ), !!ko(e, !0))
      for (const i of dr)
        this._finish[i] = qt(e == null ? void 0 : e[i]) ? e[i] : "";
  }
  //compress for saving / transfer
  save() {
    var e, i, r;
    delete this.group, (e = this == null ? void 0 : this.guillotineData) == null || delete e.stripShapeBatches, this.stockId = (i = this == null ? void 0 : this.stock) == null ? void 0 : i.id, delete this.stock, delete this.score, delete this.bestScore, Es.every((s) => {
      var o;
      return !((o = this._banding) != null && o[s]);
    }) && (this._banding = null), dr.every((s) => {
      var o;
      return !((o = this._finish) != null && o[s]);
    }) && (this._finish = null), Tb(this), (r = this.guillotineData) == null || delete r.myStripParent, delete this.score, delete this.inGroup, delete this.groupID, delete this.addedAsGroup, delete this.proximity;
  }
  isExactFit(e) {
    return this.orientationLock === "w" && this.w === e.w || this.orientationLock === "l" && this.l === e.l || !this.orientationLock && this.w === e.w && this.l === e.l;
  }
  addToStock(e) {
    this.stock = e, this.stockId = e.id, this.added = !0, this.inGroup = !1, e.used = !0, this.grain = e.grain, e != null && e.grain && this.rot && (this.grain = xo(e.grain)), H0([
      () => Ms(this.isInsideStock(e), `shape ${this.id} is not inside stock`).to.be.true
    ]);
  }
  removeFromStock() {
    this.placementOrder = null, this.stock = null, this.stockId = null, this.added = !1, this.addedAsGroup = !1, this == null || delete this.isFirstShape, Pr(this) && this.shapes.forEach((e) => e.removeFromStock());
  }
  setBestScore(e, i = null) {
    const r = {
      x: e.x,
      y: e.y,
      rot: e.rot,
      total: e.score.total,
      score: e.score,
      group: e.group,
      weighting: null,
      point: i
    };
    this.bestScore = r;
  }
  resetBestScore() {
    const e = {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.bestScore = e, this.resetGuillotineData(!0);
  }
  resetScore() {
    this.score = null, this.resetGuillotineData(!0);
  }
  resetBothScores() {
    this.resetBestScore(), this.resetScore();
  }
  resetPosition() {
    this.x = 0, this.y = 0, this.placementOrder = null, this.resetGuillotineData(!0);
  }
  resetGroupData() {
    this.inGroup = !1, this.group = null, this.groupID = null, this.groupPlacementOrder = null, this.grain = null;
  }
  resetGuillotineData(e = !1) {
    var r, s;
    const i = {
      firstShape: !1,
      myPhase: null,
      myStripDirection: null,
      stripShapeBatches: {
        subsetUsed: !1,
        groups: {}
      }
    };
    e && (i.stripShapeBatches.groups = (s = (r = this.guillotineData) == null ? void 0 : r.stripShapeBatches) == null ? void 0 : s.groups), this.guillotineData = i;
  }
  reset(e = !1, i = !0, r = !1) {
    this.removeFromStock(), this.resetPosition(), this.setRotation(0), this.placementOrder = null, this == null || delete this.isFirstShape, this.patternMatch = !1, e || this.resetBothScores(), r || this.resetGroupData(), this.resetGuillotineData(i);
  }
  round() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y),
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  //get an array of allowed rotations for this container
  getAllowedRotations(e) {
    const i = [];
    for (let r = 0; r <= 1; r++)
      this.canRotate(r, e) && this.willItFit(e, r) && i.push(r);
    return i;
  }
  /**
   * checks if a shape can rotate
   * checks for fit and grain
   * does not change the shape's rotation during the checks
   * @returns false if cannot rotate or can rotate but won't fit
   */
  canRotate(e = null, i = null) {
    if (!qt(e))
      throw new Error("no rotation provided to canRotate");
    if (e === !0 && (e = 1), e === !1 && (e = 0), this.isSquare() && e || i && !this.willItFit(i, e))
      return !1;
    const r = this.getNecessaryOrientation(i);
    return !(r === "l" && e === 1 || r === "w" && e === 0);
  }
  /**
   * can a shape rotate to produce the specified dimensions on a specific side
   * @todo tests
   */
  canRotateToDimension(e, i, r = null) {
    if (!i) throw new Error("requiredSide not supplied to canRotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (r) {
      if (i === "l") {
        if (s === e && this.canRotate(0, r) || o === e && this.canRotate(1, r)) return !0;
      } else if (i === "w" && (o === e && this.canRotate(0, r) || s === e && this.canRotate(1, r)))
        return !0;
    } else if (this.orientationLock) {
      if (this.orientationLock === "l")
        return i === "l" && e === s;
      if (this.orientationLock === "w")
        return i === "l" && e === o;
    }
    return !1;
  }
  canRotateToDimensionRange(e, i, r, s = null) {
    if (!r) throw new Error("requiredSide not supplied to canRotateToDimensionRange");
    if (this.l >= e && this.l <= i || this.w >= e && this.w <= i) {
      if (this.l === this.w) return !0;
      const o = this.getLongSide(), a = this.getShortSide();
      if (s) {
        if (r === "l") {
          if (o >= e && o <= i && this.canRotate(0, s) || a >= e && a <= i && this.canRotate(1, s)) return !0;
        } else if (r === "w" && (a >= e && a <= i && this.canRotate(0, s) || o >= e && o <= i && this.canRotate(1, s)))
          return !0;
      } else if (this.orientationLock) {
        if (this.orientationLock === "l")
          return r === "l" && o >= e && o <= i;
        if (this.orientationLock === "w")
          return r === "l" && a >= e && a <= i;
      }
    }
    return !1;
  }
  rotateToDimension(e, i, r) {
    if (!i) throw new Error("requiredSide not supplied to rotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (i === "l") {
      if (s === e && this.canRotate(0, r)) return this.setRotation(0);
      if (o === e && this.canRotate(1, r)) return this.setRotation(1);
    } else if (i === "w") {
      if (o === e && this.canRotate(0, r)) return this.setRotation(0);
      if (s === e && this.canRotate(1, r)) return this.setRotation(1);
    }
    return !1;
  }
  //get the orientation lock catering for container grain
  convertShapeGrainToOrientationLock(e) {
    if (!e) throw new Error("container not supplied to convertShapeGrainToOrientationLock");
    if (!of(e)) throw new Error("container is not a container");
    if (Pr(this)) return this.orientationLock;
    if (!qt(this.orientationLock)) return null;
    const i = e.getStock();
    return qt(i.grain) ? this.orientationLock === i.grain ? "l" : "w" : this.orientationLock;
  }
  /**
   * get the orientation lock catering for container grain
   */
  getNecessaryOrientation(e) {
    if (!e) return this.orientationLock;
    if (Pr(this)) return this.orientationLock;
    if (!qt(this.orientationLock)) return null;
    if (of(e))
      return this.convertShapeGrainToOrientationLock(e);
    if (Pr(this) || xd(this))
      return qt(this.orientationLock) ? this.orientationLock : null;
  }
  /**
   * get the required grain rotation
   * checks for stock grain and part orientationLock
   * does not check for fit
   */
  getGrainRotation(e) {
    if (Pr(this)) return this.rot;
    if (!qt(this.orientationLock)) return null;
    const i = e.getStock();
    return !this.orientationLock || !qt(i == null ? void 0 : i.grain) ? null : this.isGroup() ? this.orientationLock === "l" ? 0 : 1 : this.orientationLock === (i == null ? void 0 : i.grain) ? 0 : 1;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  rotate(e = null, i = null) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.canRotate(e, i) ? (this.rot === e || this.swapDimensions(), !0) : !1;
  }
  swapDimensions() {
    [this.l, this.w] = [this.w, this.l];
  }
  forceRotate(e) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.rot === e || this.swapDimensions(), !0;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotation(e = null, i = null) {
    return e ? e = 1 : e = 0, i && e && !this.willItFit(i, e) ? !1 : this.rotate(e, i);
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotationToOrientationLock(e) {
    if (!e)
      throw new Error("container not supplied to setRotationToOrientationLock");
    const i = this.getNecessaryOrientation(e);
    if (i === "l") return this.setRotation(0);
    if (i === "w") return this.setRotation(1);
  }
  setRotationToOrientationLockWithoutContainer() {
    if (this.orientationLock === "l") return this.setRotation(0);
    if (this.orientationLock === "w") return this.setRotation(1);
  }
  getBandingLength(e) {
    return !Mb(e) || !this.banding[e] ? 0 : e === "x1" || e === "x2" ? this.getShortSide() : e === "y1" || e === "y2" ? this.getLongSide() : p1(e) ? c1(this, e) : 0;
  }
  getPriority(e) {
    var r;
    if (!e) return 0;
    const i = e.parentID;
    return (r = this.priority) != null && r[i] ? this.priority[i] : 0;
  }
  clearPriority() {
    this.priority = {};
  }
  getPerimeterCutVectors() {
    var r;
    const e = (r = this.stock) != null && r.isStock() ? this.stock.getBladeWidth() / 2 : null;
    return [
      //bottom
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y - e,
        type: "bottom"
      },
      //right
      {
        x1: this.x + this.l + e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "right"
      },
      //top
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y + this.w + e,
        y2: this.y + this.w + e,
        type: "top"
      },
      //left
      {
        x1: this.x - e,
        x2: this.x - e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "left"
      }
    ];
  }
  /* getTrimmedDimensions()
  	{
  		if ( this.trimmed )
  			return {
  				l: this.l,
  				w: this.w
  			};
  
  		return {
  			l: this.l - this.trim.x1 - this.trim.x2,
  			w: this.w - this.trim.y1 - this.trim.y2
  		};
  	} */
  /**
   * create cuts around the perimeter of a shape
   * @param {Stock} stock
   * @returns {Array} cuts
   */
  createPerimeterCuts(e = null) {
    let i = [];
    if (e = e || this.stock, !e) throw new Error("stock is required to create a cut");
    return this.getPerimeterCutVectors().forEach((s) => {
      var o;
      return i.push(new Tc({
        stock: (o = this.stock) != null && o.isStock() ? this.stock : e,
        x1: s.x1,
        x2: s.x2,
        y1: s.y1,
        y2: s.y2,
        type: s.type
      }));
    }), i = i.filter((s) => s.isInsideStock()), i;
  }
  createOffset(e) {
    if (!this.stock) throw new Error("createOffset - stock not defined");
    const i = {
      x: this.x - e,
      y: this.y - e,
      l: this.l + e * 2,
      w: this.w + e * 2
    };
    return i.x < 0 && (i.x = 0, i.l -= e), i.y < 0 && (i.y = 0, i.w -= e), i.x + i.l > this.stock.l && (i.l = this.stock.l - i.x), i.y + i.w > this.stock.w && (i.w = this.stock.w - i.y), i;
  }
  setPositionToBestScore() {
    this.setRotation(this.bestScore.rot), this.x = this.bestScore.x, this.y = this.bestScore.y;
  }
  /**
   * will this shape fit in a container
   */
  willItFit(e, i = null) {
    return g1(e, this, i);
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = i.pop(), e++), i.push(e);
    const r = i.join("."), s = this.stock;
    this.stock = null;
    const o = structuredClone(this);
    return o.stock = s, o.id = r, o.added = !1, o.duplicate = !0, delete o.score, delete o.bestScore, delete o.stock, delete o.placementOrder, delete o.inGroup, delete o.addedAsGroup, delete o.groupID, delete o.isFirstShape, new ns(o);
  }
  //this is a compressed version of the shape to help with memory management
  compress() {
    const e = this.cloneGuillotineData();
    return e.myStripParent = Yb(this.guillotineData.myStripParent) ? this.guillotineData.myStripParent.id : this.guillotineData.myStripParent, {
      id: this.id,
      x: this.added ? this.x : 0,
      y: this.added ? this.y : 0,
      l: this.l,
      w: this.w,
      added: this.added,
      guillotineData: e,
      placementOrder: this.placementOrder,
      bestScore: this.bestScore,
      inGroup: this.inGroup,
      groupID: this.groupID,
      addedAsGroup: this.addedAsGroup,
      groupPlacementOrder: this.groupPlacementOrder,
      minSpacing: this.minSpacing,
      cloneType: "shape",
      priority: Object.assign({}, this.priority)
    };
  }
  isTooCloseToEdges(e) {
    var r, s;
    const i = ((s = (r = e.saw) == null ? void 0 : r.options) == null ? void 0 : s.minSpacing) || this.minSpacing;
    return i ? this.getDistancesToContainerEdges(e).some((o) => o > 0 && o <= i) : !1;
  }
  validateStripShapeBatches() {
    const e = Object.values(this.guillotineData.stripShapeBatches.groups);
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (r.id !== this.id)
        throw new Error(`strip shape group id does not match shape id ${this.id} ${r.id} ${i}`);
      if (![this.l, this.w].includes(r.dimension))
        throw new Error(`strip shape group dimension does not match shape dimensions ${this.id} ${r.id} ${i} ${this.l} ${this.w} ${r.dimension}`);
    }
  }
  getStripShapeBatchData(e) {
    var i;
    return typeof e != "number" || !((i = this == null ? void 0 : this.guillotineData) != null && i.stripShapeBatches) || !this.guillotineData.stripShapeBatches.groups || !(e in this.guillotineData.stripShapeBatches.groups) ? !1 : this.guillotineData.stripShapeBatches.groups[e];
  }
  isInStripShapeBatch(e) {
    return !!this.getStripShapeBatchData(e);
  }
  isStacked() {
    return this.added && this.stock && this.stock.isStacked();
  }
}
class y1 extends wd {
  constructor(e) {
    var t = (...nA) => (super(...nA), tt(this, "firstShape"), tt(this, "cuts"), tt(this, "phase"), tt(this, "merged"), tt(this, "children"), tt(this, "siblings"), //used by vis only
    tt(this, "parent"), tt(this, "segmentType"), tt(this, "completed"), //used by vis only
    tt(this, "rowSegment"), //used by cuts
    tt(this, "placementOrder"), tt(this, "hasBeamTrim"), tt(this, "cutDirection"), this);
    if (e) {
      if (e.preventAutoRotation = !0, t(e), this.validateSegment(e), this.issues.length)
        throw new Error(`Segment validation failed - ${this.issues.join(" ")}`);
      delete this.trim, delete this.trimmed, this.shapes = qt(e == null ? void 0 : e.shapes) ? e.shapes : [], this.firstShape = qt(e == null ? void 0 : e.firstShape) ? e.firstShape : null, this.cuts = [], this.phase = qt(e == null ? void 0 : e.phase) ? e.phase : null, this.merged = qt(e == null ? void 0 : e.merged) ? e.merged : !1, this.parent = qt(e == null ? void 0 : e.parent) ? e.parent : null, this.children = qt(e == null ? void 0 : e.children) ? e.children : [], this.siblings = qt(e == null ? void 0 : e.siblings) ? e.siblings : [], this.offcut = qt(e == null ? void 0 : e.offcut) ? e.offcut : !1, this.segmentType = qt(e == null ? void 0 : e.segmentType) ? e.segmentType : null, this.placementOrder = null, this.cutDirection = qt(e == null ? void 0 : e.cutDirection) ? e.cutDirection : "l", this.hasBeamTrim = qt(e == null ? void 0 : e.hasBeamTrim) ? e.hasBeamTrim : !1;
    }
  }
  validateSegment(e) {
    var i, r;
    (Ue.lessThanOrEqualTo(e.w, 0) || Ue.lessThanOrEqualTo(e.l, 0)) && this.issues.push({ message: `Zero / negative dimension - l: ${e.l}, w: ${e.w}.` }), (Ue.lessThan(e.x, 0) || Ue.lessThan(e.y, 0)) && this.issues.push({ message: `Negative position - x: ${e == null ? void 0 : e.x}, y: ${e == null ? void 0 : e.y}.` }), e != null && e.stock && (Ue.greaterThan(e.x + e.l, e.stock.l) || Ue.greaterThan(e.y + e.w, e.stock.w)) && this.issues.push({ message: `Outside of stock ${e.stock.id} - x: ${e.x}, y: ${e.y}, l: ${e.l}, w: ${e.w}, sl: ${(i = e == null ? void 0 : e.stock) == null ? void 0 : i.l}, sw: ${(r = e == null ? void 0 : e.stock) == null ? void 0 : r.w}.` });
  }
  //compress for saving / transfer
  save() {
    var e;
    this.children = this.children.map((i) => ({
      id: i.id,
      x: i.x,
      y: i.y,
      l: i.l,
      w: i.w,
      offcut: i.offcut
    })), this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this.shapes, delete this.saw, delete this.siblings, delete this.parent, delete this.trim, this.algoBenchmark = null;
  }
  getBladeWidth() {
    return this.stock.getBladeWidth();
  }
  /**
   * create a normalised shape list to allow searching for duplicates
   */
  getNormalisedShapes(e) {
    return e.map((i) => ({
      x: i.x - this.x,
      y: i.y - this.y,
      l: i.l,
      w: i.w
    }));
  }
  reset() {
    this.stock.used = !1, this.children = [], this.siblings = [], this.parent = null, this.cuts = [], this.phase = null;
  }
}
class zs extends ns {
  //used for sorting
  constructor(e) {
    var i, r;
    if (e = So(e), !((i = e == null ? void 0 : e.shapes) != null && i.length))
      throw new Error("attempting to create a group with no shapes");
    e.preventAutoRotation = !0;
    super(e);
    tt(this, "shapes");
    tt(this, "positions");
    tt(this, "direction");
    tt(this, "container");
    tt(this, "outOfBounds");
    tt(this, "collision");
    tt(this, "counter", 0);
    tt(this, "type");
    tt(this, "efficiency");
    this.q = 1, delete this._banding, delete this._finish, delete this._trim, this.shapes = e.shapes, this.positions = (r = e == null ? void 0 : e.positions) != null && r.length ? e.positions : [], this.direction = e.direction, this.container = e.container, this.type = (e == null ? void 0 : e.type) ?? "auto", this.initGroup();
  }
  initGroup() {
    var e;
    (e = this == null ? void 0 : this.shapes) != null && e.length && (this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]));
  }
  setShapePositions() {
    if (!this.container) return;
    this.positions = [], this.type !== "user" && this.sortShapes();
    let e = 0;
    const i = G2(this.direction);
    this.shapes.forEach((o, a) => {
      this.positions.push({
        shape: o.id,
        [i]: e,
        [V2(i)]: 0,
        rot: o.rot.valueOf()
      }), o.inGroup = !0, e += a === this.shapes.length - 1 ? o[this.direction] : o[this.direction] + o.getMinSpacing(this.container);
    }), this[this.direction] = e;
    const r = xo(this.direction), s = this.shapes.reduce((o, a) => a[r] > o ? a[r] : o, 0);
    if (this[r] = s, W0()) {
      const o = this.shapes.slice(0, -1).reduce((h, u) => h + u.getMinSpacing(this.container), 0), l = this.shapes.reduce((h, u) => h + u[this.direction], 0) + o;
      H0([
        () => Ms(Ue.equalTo(l, this[this.direction]), "group dimension is incorrect in direction").to.be.true,
        () => Ms(e, "currentPosition is incorrect in direction").to.equal(this[this.direction]),
        () => Ms(s, "group dimension in other direction is not correct").to.equal(this[r])
      ]);
    }
    if (this.w > this.container.w || this.l > this.container.l)
      throw new Error(`group ${this.id} is bigger than container - group ${this.l}x${this.w}, container ${this.container.l}x${this.container.w}`);
  }
  //update the shape spacing and overall group dimensions to account for min spacing
  updateShapeSpacing(e) {
    this.container = e, this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]);
  }
  //get the area of the shapes (does not include blade width) - overwrites the rectangle method
  getArea() {
    return this.shapes.reduce((e, i) => e + i.getArea(), 0);
  }
  destroy() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !1);
  }
  reset() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !0);
  }
  /**
   * orientate all the shapes correctly to fit in the group
   */
  orientateShapes(e) {
    this.shapes.forEach((i) => {
      const r = this.positions.find((o) => o.shape === i.id);
      if (!r) throw new Error("position not found for shape in group");
      if (!i.rotate(r.rot, e)) throw new Error("orientateShapes - unable to rotate shape in group");
    });
  }
  /**
   * sort the shapes by size
   */
  sortShapes() {
    const e = xo(this.direction);
    this.shapes.sort((i, r) => r[e] === i[e] ? r[this.direction] === i[this.direction] ? i.id.localeCompare(r.id, void 0, { numeric: !0 }) : r[this.direction] - i[this.direction] : r[e] - i[e]);
  }
  /**
   * place the group shapes on the stock
   */
  placeMyShapes(e) {
    if (!e) throw new Error("placeShapes requires stock");
    this.addToStock(e);
    for (let i = 0; i < this.shapes.length; i++) {
      const r = this.shapes[i];
      r.addToStock(e);
      const s = this.positions.find((l) => l.shape === r.id);
      if (!s) throw new Error("position not found for shape in group");
      if (r.x = this.x + s.x, r.y = this.y + s.y, !r.rotate(s.rot, e)) throw new Error("placeMyShapes - unable to rotate shape in group");
      i === 0 && this.x === 0 && this.y === 0 && (r.isFirstShape = !0), r.addedAsGroup = this.id, r.inGroup = !1, r.score = this.score;
      const a = r.guillotineData.stripShapeBatches;
      r.guillotineData = this.cloneGuillotineData(), r.guillotineData.stripShapeBatches = a, r.bestScore = this.bestScore, typeof this.placementOrder == "number" && (r.groupPlacementOrder = i, r.placementOrder = this.placementOrder + i / 1e6);
    }
  }
  //this is for groups which are created once and reused between stock e.g. user groups
  orientateCorrectly(e) {
    this.orientateShapes(e), this.setRotationToOrientationLock(e);
  }
  clone(e = []) {
    const r = `g${parseInt(this.id.split("g")[1]) + 1}`, s = this.shapes, o = this.container, a = this.stock;
    this.shapes = [], this.container = null, this.stock = null;
    const l = structuredClone(this);
    return this.shapes = s, this.container = o, this.stock = a, l.container = this.container, l.shapes = e, l.id = r, new zs(l);
  }
  compress() {
    const e = super.compress.call(this);
    return e.direction = this.direction, e.positions = structuredClone(this.positions), e.shapes = this.shapes.map((i) => i.compress()), e.type = this.type, e.cloneType = "group", e;
  }
}
function Wb(n, t, e, i) {
  return t.filter((r, s) => {
    var o, a;
    return n.stockMatch.material[s] = null, n.stockMatch.thickness[s] = null, n.stockMatch.width[s] = null, n.stockMatch.fit[s] = null, (mr(n) || xd(n)) && (g1(r, n) ? n.stockMatch.fit[s] = !0 : n.stockMatch.fit[s] = !1), e ? !(r != null && r.material) && !(n != null && n.material) || ((o = r == null ? void 0 : r.material) == null ? void 0 : o.toLowerCase()) === ((a = n == null ? void 0 : n.material) == null ? void 0 : a.toLowerCase()) ? n.stockMatch.material[s] = !0 : n.stockMatch.material[s] = !1 : n.stockMatch.material[s] = !0, i ? qt(n.t) && qt(r.t) ? (mr(n) && Ue.equalTo(n.t, r.t) || n.t === r.t) && (n.stockMatch.thickness[s] = !0) : n.stockMatch.thickness[s] = !1 : n.stockMatch.thickness[s] = !0, r.type === "linear" ? mr(n) && (n.canRotate(0, r) && Ue.equalTo(n.w, r.w) || n.canRotate(1, r) && Ue.equalTo(n.l, r.w) ? n.stockMatch.width[s] = !0 : n.stockMatch.width[s] = !1) : n.stockMatch.width[s] = !0, n.stockMatch.fit[s] && n.stockMatch.material[s] && n.stockMatch.thickness[s] && n.stockMatch.width[s];
  });
}
function Hb(n, t, e) {
  const i = hr(n[0]);
  if (i && (t = t.map((u) => {
    const d = new es(u);
    return d.trimDimensions(), d;
  }), n = n.map((u) => {
    const d = new ns(u);
    return d.trimDimensions(), d;
  })), Uu(t[0]) && (t = t.map((u, d) => (u.id = `${d.toString()}.0`, new es(u)))), n.some((u) => qt(u.stockLock) && u.stockLock.length)) return;
  t = t.filter((u) => u.autoAdd === !0 || qt(u.q) && u.q > 0);
  const s = t.some((u) => qt(u.material)), o = t.some((u) => qt(u.t)), a = /* @__PURE__ */ new Set();
  for (const u of n) {
    u.stockMatch = {
      material: [],
      thickness: [],
      width: [],
      fit: []
    };
    const d = Wb(u, t, s, o);
    if (u.stockMatch.fit = !u.stockMatch.fit.every((p) => p === !1), u.stockMatch.material = !u.stockMatch.material.every((p) => p === !1), u.stockMatch.thickness = !u.stockMatch.thickness.every((p) => p === !1), u.stockMatch.width = !u.stockMatch.width.every((p) => p === !1), !i) {
      if (d.length) {
        const p = d.map((f) => f.getParentID());
        u.stockLock = p, p.forEach((f) => a.add(f));
      } else if (u.stockMatch.fit)
        u.stockMatch.material || u.issues.push({ message: `materials must match - could not find any stock with ${u.material ? u.material + " material" : "no material set"}` }), u.stockMatch.thickness || u.issues.push({ message: `thicknesses must match - could not find any stock with ${u.t ? "thickness " + u.t : "no thickness set"}` }), e === "linear" && !u.stockMatch.width && u.issues.push({ message: `widths must match for linear calculations - could not find any stock with ${u.w ? "width " + u.w : "no width set"}` });
      else {
        const p = u.getTrimmedDimensions();
        u.issues.push({ message: `${p.l.toFixed()}x${p.w.toFixed()} will not fit on any stock - check dimensions, min spacing, trim & orientation lock` });
      }
      u.stockMatch = null;
    }
  }
  const l = n.filter((u) => !u.stockLock || !u.stockLock.length).sort(Ju.ID), h = t.filter((u) => !a.has(u.parentID)).sort(Ju.ID);
  return t = t.filter((u) => ts(u)).filter((u) => a.has(u.parentID)), (s || o) && (n = n.filter((u) => {
    var d;
    return (d = u == null ? void 0 : u.stockLock) == null ? void 0 : d.length;
  })), {
    stockList: t,
    unusableStock: h,
    shapeList: n,
    unusableShapes: l
  };
}
function Gb(n) {
  if (!n.length) return "n";
  const t = n.map((e) => e.grain).filter((e) => e);
  return t.length ? t.every((e) => e === "l") ? "l" : t.every((e) => e === "w") ? "w" : t.some((e) => e === "l" || e === "w") ? "y" : "n" : "n";
}
function Vb(n) {
  return n.shapes !== void 0;
}
function Pr(n) {
  return n instanceof zs && n.type !== "user";
}
function xd(n) {
  return n instanceof zs && n.type === "user";
}
function lo(n) {
  return n instanceof Fb;
}
function Uu(n) {
  return n instanceof m1;
}
function hr(n) {
  return n instanceof vd;
}
function ts(n) {
  return n instanceof es;
}
function of(n) {
  return n instanceof wd;
}
function mr(n) {
  return n instanceof ns && !(n instanceof zs);
}
function Yb(n) {
  return n instanceof ns || n instanceof zs;
}
function Kb(n) {
  return n instanceof y1;
}
function Xb(n) {
  return n instanceof Bs;
}
function Jb(n) {
  return !n || typeof n != "string" ? "" : n.toUpperCase();
}
function ac(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n) !== void 0;
}
function pn(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n);
}
function qt(n) {
  return !(n === void 0 || n === null || n === "" || typeof n == "object" && !Object.values(n).length);
}
function ko(n, t = !1) {
  if (!qt(n) || typeof n != "object") return !1;
  const e = Object.values(n);
  return e.length === 0 ? !1 : t ? e.some((i) => qt(i) && i) : e.some((i) => qt(i));
}
function Zb(n) {
  return n != null && n.length ? n.filter((t) => t.used && (t.stack === !1 || typeof t.stack == "number")) : [];
}
function Qb() {
  const n = document.documentElement;
  return "requestFullscreen" in n || "webkitRequestFullscreen" in n || "mozRequestFullScreen" in n || "msRequestFullscreen" in n;
}
function $l(n) {
  return n ? (n = n.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^ a-z0-9._\-|]/gim, ""), n.trim()) : null;
}
function b1(n, t = 100) {
  return n ? (n = n.trim(), n = n.substring(0, t), n) : "";
}
function en(n) {
  "@babel/helpers - typeof";
  return en = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, en(n);
}
var li = Uint8Array, Di = Uint16Array, _d = Int32Array, Mc = new li([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Rc = new li([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), af = new li([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), v1 = function(n, t) {
  for (var e = new Di(31), i = 0; i < 31; ++i)
    e[i] = t += 1 << n[i - 1];
  for (var r = new _d(e[30]), i = 1; i < 30; ++i)
    for (var s = e[i]; s < e[i + 1]; ++s)
      r[s] = s - e[i] << 5 | i;
  return { b: e, r };
}, w1 = v1(Mc, 2), x1 = w1.b, lf = w1.r;
x1[28] = 258, lf[258] = 28;
var _1 = v1(Rc, 0), tv = _1.b, Wp = _1.r, uf = new Di(32768);
for (var hn = 0; hn < 32768; ++hn) {
  var Cs = (hn & 43690) >> 1 | (hn & 21845) << 1;
  Cs = (Cs & 52428) >> 2 | (Cs & 13107) << 2, Cs = (Cs & 61680) >> 4 | (Cs & 3855) << 4, uf[hn] = ((Cs & 65280) >> 8 | (Cs & 255) << 8) >> 1;
}
var Or = function(n, t, e) {
  for (var i = n.length, r = 0, s = new Di(t); r < i; ++r)
    n[r] && ++s[n[r] - 1];
  var o = new Di(t);
  for (r = 1; r < t; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  var a;
  if (e) {
    a = new Di(1 << t);
    var l = 15 - t;
    for (r = 0; r < i; ++r)
      if (n[r])
        for (var h = r << 4 | n[r], u = t - n[r], d = o[n[r] - 1]++ << u, p = d | (1 << u) - 1; d <= p; ++d)
          a[uf[d] >> l] = h;
  } else
    for (a = new Di(i), r = 0; r < i; ++r)
      n[r] && (a[r] = uf[o[n[r] - 1]++] >> 15 - n[r]);
  return a;
}, js = new li(288);
for (var hn = 0; hn < 144; ++hn)
  js[hn] = 8;
for (var hn = 144; hn < 256; ++hn)
  js[hn] = 9;
for (var hn = 256; hn < 280; ++hn)
  js[hn] = 7;
for (var hn = 280; hn < 288; ++hn)
  js[hn] = 8;
var Pl = new li(32);
for (var hn = 0; hn < 32; ++hn)
  Pl[hn] = 5;
var ev = /* @__PURE__ */ Or(js, 9, 0), nv = /* @__PURE__ */ Or(js, 9, 1), iv = /* @__PURE__ */ Or(Pl, 5, 0), rv = /* @__PURE__ */ Or(Pl, 5, 1), _h = function(n) {
  for (var t = n[0], e = 1; e < n.length; ++e)
    n[e] > t && (t = n[e]);
  return t;
}, ar = function(n, t, e) {
  var i = t / 8 | 0;
  return (n[i] | n[i + 1] << 8) >> (t & 7) & e;
}, Sh = function(n, t) {
  var e = t / 8 | 0;
  return (n[e] | n[e + 1] << 8 | n[e + 2] << 16) >> (t & 7);
}, Sd = function(n) {
  return (n + 7) / 8 | 0;
}, S1 = function(n, t, e) {
  return (e == null || e > n.length) && (e = n.length), new li(n.subarray(t, e));
}, sv = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], ur = function(n, t, e) {
  var i = new Error(t || sv[n]);
  if (i.code = n, Error.captureStackTrace && Error.captureStackTrace(i, ur), !e)
    throw i;
  return i;
}, ov = function(n, t, e, i) {
  var r = n.length, s = 0;
  if (!r || t.f && !t.l)
    return e || new li(0);
  var o = !e, a = o || t.i != 2, l = t.i;
  o && (e = new li(r * 3));
  var h = function(Dt) {
    var Jt = e.length;
    if (Dt > Jt) {
      var Qt = new li(Math.max(Jt * 2, Dt));
      Qt.set(e), e = Qt;
    }
  }, u = t.f || 0, d = t.p || 0, p = t.b || 0, f = t.l, m = t.d, b = t.m, x = t.n, y = r * 8;
  do {
    if (!f) {
      u = ar(n, d, 1);
      var v = ar(n, d + 1, 3);
      if (d += 3, v)
        if (v == 1)
          f = nv, m = rv, b = 9, x = 5;
        else if (v == 2) {
          var q = ar(n, d, 31) + 257, T = ar(n, d + 10, 15) + 4, F = q + ar(n, d + 5, 31) + 1;
          d += 14;
          for (var M = new li(F), B = new li(19), P = 0; P < T; ++P)
            B[af[P]] = ar(n, d + P * 3, 7);
          d += T * 3;
          for (var A = _h(B), I = (1 << A) - 1, S = Or(B, A, 1), P = 0; P < F; ) {
            var X = S[ar(n, d, I)];
            d += X & 15;
            var k = X >> 4;
            if (k < 16)
              M[P++] = k;
            else {
              var H = 0, j = 0;
              for (k == 16 ? (j = 3 + ar(n, d, 3), d += 2, H = M[P - 1]) : k == 17 ? (j = 3 + ar(n, d, 7), d += 3) : k == 18 && (j = 11 + ar(n, d, 127), d += 7); j--; )
                M[P++] = H;
            }
          }
          var Q = M.subarray(0, q), G = M.subarray(q);
          b = _h(Q), x = _h(G), f = Or(Q, b, 1), m = Or(G, x, 1);
        } else
          ur(1);
      else {
        var k = Sd(d) + 4, C = n[k - 4] | n[k - 3] << 8, E = k + C;
        if (E > r) {
          l && ur(0);
          break;
        }
        a && h(p + C), e.set(n.subarray(k, E), p), t.b = p += C, t.p = d = E * 8, t.f = u;
        continue;
      }
      if (d > y) {
        l && ur(0);
        break;
      }
    }
    a && h(p + 131072);
    for (var ft = (1 << b) - 1, nt = (1 << x) - 1, N = d; ; N = d) {
      var H = f[Sh(n, d) & ft], z = H >> 4;
      if (d += H & 15, d > y) {
        l && ur(0);
        break;
      }
      if (H || ur(2), z < 256)
        e[p++] = z;
      else if (z == 256) {
        N = d, f = null;
        break;
      } else {
        var V = z - 254;
        if (z > 264) {
          var P = z - 257, Y = Mc[P];
          V = ar(n, d, (1 << Y) - 1) + x1[P], d += Y;
        }
        var ot = m[Sh(n, d) & nt], wt = ot >> 4;
        ot || ur(3), d += ot & 15;
        var G = tv[wt];
        if (wt > 3) {
          var Y = Rc[wt];
          G += Sh(n, d) & (1 << Y) - 1, d += Y;
        }
        if (d > y) {
          l && ur(0);
          break;
        }
        a && h(p + 131072);
        var mt = p + V;
        if (p < G) {
          var xt = s - G, zt = Math.min(G, mt);
          for (xt + p < 0 && ur(3); p < zt; ++p)
            e[p] = i[xt + p];
        }
        for (; p < mt; ++p)
          e[p] = e[p - G];
      }
    }
    t.l = f, t.p = N, t.b = p, t.f = u, f && (u = 1, t.m = b, t.d = m, t.n = x);
  } while (!u);
  return p != e.length && o ? S1(e, 0, p) : e.subarray(0, p);
}, Zr = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8;
}, hl = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8, n[i + 2] |= e >> 16;
}, kh = function(n, t) {
  for (var e = [], i = 0; i < n.length; ++i)
    n[i] && e.push({ s: i, f: n[i] });
  var r = e.length, s = e.slice();
  if (!r)
    return { t: A1, l: 0 };
  if (r == 1) {
    var o = new li(e[0].s + 1);
    return o[e[0].s] = 1, { t: o, l: 1 };
  }
  e.sort(function(E, q) {
    return E.f - q.f;
  }), e.push({ s: -1, f: 25001 });
  var a = e[0], l = e[1], h = 0, u = 1, d = 2;
  for (e[0] = { s: -1, f: a.f + l.f, l: a, r: l }; u != r - 1; )
    a = e[e[h].f < e[d].f ? h++ : d++], l = e[h != u && e[h].f < e[d].f ? h++ : d++], e[u++] = { s: -1, f: a.f + l.f, l: a, r: l };
  for (var p = s[0].s, i = 1; i < r; ++i)
    s[i].s > p && (p = s[i].s);
  var f = new Di(p + 1), m = cf(e[u - 1], f, 0);
  if (m > t) {
    var i = 0, b = 0, x = m - t, y = 1 << x;
    for (s.sort(function(q, T) {
      return f[T.s] - f[q.s] || q.f - T.f;
    }); i < r; ++i) {
      var v = s[i].s;
      if (f[v] > t)
        b += y - (1 << m - f[v]), f[v] = t;
      else
        break;
    }
    for (b >>= x; b > 0; ) {
      var k = s[i].s;
      f[k] < t ? b -= 1 << t - f[k]++ - 1 : ++i;
    }
    for (; i >= 0 && b; --i) {
      var C = s[i].s;
      f[C] == t && (--f[C], ++b);
    }
    m = t;
  }
  return { t: new li(f), l: m };
}, cf = function(n, t, e) {
  return n.s == -1 ? Math.max(cf(n.l, t, e + 1), cf(n.r, t, e + 1)) : t[n.s] = e;
}, Hp = function(n) {
  for (var t = n.length; t && !n[--t]; )
    ;
  for (var e = new Di(++t), i = 0, r = n[0], s = 1, o = function(l) {
    e[i++] = l;
  }, a = 1; a <= t; ++a)
    if (n[a] == r && a != t)
      ++s;
    else {
      if (!r && s > 2) {
        for (; s > 138; s -= 138)
          o(32754);
        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(r), --s; s > 6; s -= 6)
          o(8304);
        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        o(r);
      s = 1, r = n[a];
    }
  return { c: e.subarray(0, i), n: t };
}, fl = function(n, t) {
  for (var e = 0, i = 0; i < t.length; ++i)
    e += n[i] * t[i];
  return e;
}, k1 = function(n, t, e) {
  var i = e.length, r = Sd(t + 2);
  n[r] = i & 255, n[r + 1] = i >> 8, n[r + 2] = n[r] ^ 255, n[r + 3] = n[r + 1] ^ 255;
  for (var s = 0; s < i; ++s)
    n[r + s + 4] = e[s];
  return (r + 4 + i) * 8;
}, Gp = function(n, t, e, i, r, s, o, a, l, h, u) {
  Zr(t, u++, e), ++r[256];
  for (var d = kh(r, 15), p = d.t, f = d.l, m = kh(s, 15), b = m.t, x = m.l, y = Hp(p), v = y.c, k = y.n, C = Hp(b), E = C.c, q = C.n, T = new Di(19), F = 0; F < v.length; ++F)
    ++T[v[F] & 31];
  for (var F = 0; F < E.length; ++F)
    ++T[E[F] & 31];
  for (var M = kh(T, 7), B = M.t, P = M.l, A = 19; A > 4 && !B[af[A - 1]]; --A)
    ;
  var I = h + 5 << 3, S = fl(r, js) + fl(s, Pl) + o, X = fl(r, p) + fl(s, b) + o + 14 + 3 * A + fl(T, B) + 2 * T[16] + 3 * T[17] + 7 * T[18];
  if (l >= 0 && I <= S && I <= X)
    return k1(t, u, n.subarray(l, l + h));
  var H, j, Q, G;
  if (Zr(t, u, 1 + (X < S)), u += 2, X < S) {
    H = Or(p, f, 0), j = p, Q = Or(b, x, 0), G = b;
    var ft = Or(B, P, 0);
    Zr(t, u, k - 257), Zr(t, u + 5, q - 1), Zr(t, u + 10, A - 4), u += 14;
    for (var F = 0; F < A; ++F)
      Zr(t, u + 3 * F, B[af[F]]);
    u += 3 * A;
    for (var nt = [v, E], N = 0; N < 2; ++N)
      for (var z = nt[N], F = 0; F < z.length; ++F) {
        var V = z[F] & 31;
        Zr(t, u, ft[V]), u += B[V], V > 15 && (Zr(t, u, z[F] >> 5 & 127), u += z[F] >> 12);
      }
  } else
    H = ev, j = js, Q = iv, G = Pl;
  for (var F = 0; F < a; ++F) {
    var Y = i[F];
    if (Y > 255) {
      var V = Y >> 18 & 31;
      hl(t, u, H[V + 257]), u += j[V + 257], V > 7 && (Zr(t, u, Y >> 23 & 31), u += Mc[V]);
      var ot = Y & 31;
      hl(t, u, Q[ot]), u += G[ot], ot > 3 && (hl(t, u, Y >> 5 & 8191), u += Rc[ot]);
    } else
      hl(t, u, H[Y]), u += j[Y];
  }
  return hl(t, u, H[256]), u + j[256];
}, av = /* @__PURE__ */ new _d([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), A1 = /* @__PURE__ */ new li(0), lv = function(n, t, e, i, r, s) {
  var o = s.z || n.length, a = new li(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r), l = a.subarray(i, a.length - r), h = s.l, u = (s.r || 0) & 7;
  if (t) {
    u && (l[0] = s.r >> 3);
    for (var d = av[t - 1], p = d >> 13, f = d & 8191, m = (1 << e) - 1, b = s.p || new Di(32768), x = s.h || new Di(m + 1), y = Math.ceil(e / 3), v = 2 * y, k = function(O) {
      return (n[O] ^ n[O + 1] << y ^ n[O + 2] << v) & m;
    }, C = new _d(25e3), E = new Di(288), q = new Di(32), T = 0, F = 0, M = s.i || 0, B = 0, P = s.w || 0, A = 0; M + 2 < o; ++M) {
      var I = k(M), S = M & 32767, X = x[I];
      if (b[S] = X, x[I] = S, P <= M) {
        var H = o - M;
        if ((T > 7e3 || B > 24576) && (H > 423 || !h)) {
          u = Gp(n, l, 0, C, E, q, F, B, A, M - A, u), B = T = F = 0, A = M;
          for (var j = 0; j < 286; ++j)
            E[j] = 0;
          for (var j = 0; j < 30; ++j)
            q[j] = 0;
        }
        var Q = 2, G = 0, ft = f, nt = S - X & 32767;
        if (H > 2 && I == k(M - nt))
          for (var N = Math.min(p, H) - 1, z = Math.min(32767, M), V = Math.min(258, H); nt <= z && --ft && S != X; ) {
            if (n[M + Q] == n[M + Q - nt]) {
              for (var Y = 0; Y < V && n[M + Y] == n[M + Y - nt]; ++Y)
                ;
              if (Y > Q) {
                if (Q = Y, G = nt, Y > N)
                  break;
                for (var ot = Math.min(nt, Y - 2), wt = 0, j = 0; j < ot; ++j) {
                  var mt = M - nt + j & 32767, xt = b[mt], zt = mt - xt & 32767;
                  zt > wt && (wt = zt, X = mt);
                }
              }
            }
            S = X, X = b[S], nt += S - X & 32767;
          }
        if (G) {
          C[B++] = 268435456 | lf[Q] << 18 | Wp[G];
          var Dt = lf[Q] & 31, Jt = Wp[G] & 31;
          F += Mc[Dt] + Rc[Jt], ++E[257 + Dt], ++q[Jt], P = M + Q, ++T;
        } else
          C[B++] = n[M], ++E[n[M]];
      }
    }
    for (M = Math.max(M, P); M < o; ++M)
      C[B++] = n[M], ++E[n[M]];
    u = Gp(n, l, h, C, E, q, F, B, A, M - A, u), h || (s.r = u & 7 | l[u / 8 | 0] << 3, u -= 7, s.h = x, s.p = b, s.i = M, s.w = P);
  } else {
    for (var M = s.w || 0; M < o + h; M += 65535) {
      var Qt = M + 65535;
      Qt >= o && (l[u / 8 | 0] = h, Qt = o), u = k1(l, u + 1, n.subarray(M, Qt));
    }
    s.i = o;
  }
  return S1(a, 0, i + Sd(u) + r);
}, N1 = function() {
  var n = 1, t = 0;
  return {
    p: function(e) {
      for (var i = n, r = t, s = e.length | 0, o = 0; o != s; ) {
        for (var a = Math.min(o + 2655, s); o < a; ++o)
          r += i += e[o];
        i = (i & 65535) + 15 * (i >> 16), r = (r & 65535) + 15 * (r >> 16);
      }
      n = i, t = r;
    },
    d: function() {
      return n %= 65521, t %= 65521, (n & 255) << 24 | (n & 65280) << 8 | (t & 255) << 8 | t >> 8;
    }
  };
}, uv = function(n, t, e, i, r) {
  if (!r && (r = { l: 1 }, t.dictionary)) {
    var s = t.dictionary.subarray(-32768), o = new li(s.length + n.length);
    o.set(s), o.set(n, s.length), n = o, r.w = s.length;
  }
  return lv(n, t.level == null ? 6 : t.level, t.mem == null ? r.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 20 : 12 + t.mem, e, i, r);
}, C1 = function(n, t, e) {
  for (; e; ++t)
    n[t] = e, e >>>= 8;
}, cv = function(n, t) {
  var e = t.level, i = e == 0 ? 0 : e < 6 ? 1 : e == 9 ? 3 : 2;
  if (n[0] = 120, n[1] = i << 6 | (t.dictionary && 32), n[1] |= 31 - (n[0] << 8 | n[1]) % 31, t.dictionary) {
    var r = N1();
    r.p(t.dictionary), C1(n, 2, r.d());
  }
}, hv = function(n, t) {
  return ((n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31) && ur(6, "invalid zlib data"), (n[1] >> 5 & 1) == +!t && ur(6, "invalid zlib data: " + (n[1] & 32 ? "need" : "unexpected") + " dictionary"), (n[1] >> 3 & 4) + 2;
};
function hf(n, t) {
  t || (t = {});
  var e = N1();
  e.p(n);
  var i = uv(n, t, t.dictionary ? 6 : 2, 4);
  return cv(i, t), C1(i, i.length - 4, e.d()), i;
}
function fv(n, t) {
  return ov(n.subarray(hv(n, t), -4), { i: 2 }, t, t);
}
var dv = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), pv = 0;
try {
  dv.decode(A1, { stream: !0 }), pv = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Ce = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Ah() {
  Ce.console && typeof Ce.console.log == "function" && Ce.console.log.apply(Ce.console, arguments);
}
var an = { log: Ah, warn: function(n) {
  Ce.console && (typeof Ce.console.warn == "function" ? Ce.console.warn.apply(Ce.console, arguments) : Ah.call(null, arguments));
}, error: function(n) {
  Ce.console && (typeof Ce.console.error == "function" ? Ce.console.error.apply(Ce.console, arguments) : Ah(n));
} };
function Nh(n, t, e) {
  var i = new XMLHttpRequest();
  i.open("GET", n), i.responseType = "blob", i.onload = function() {
    ro(i.response, t, e);
  }, i.onerror = function() {
    an.error("could not download file");
  }, i.send();
}
function Vp(n) {
  var t = new XMLHttpRequest();
  t.open("HEAD", n, !1);
  try {
    t.send();
  } catch {
  }
  return t.status >= 200 && t.status <= 299;
}
function Nu(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var t = document.createEvent("MouseEvents");
    t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(t);
  }
}
var Sl, ff, ro = Ce.saveAs || ((typeof window > "u" ? "undefined" : en(window)) !== "object" || window !== Ce ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, t, e) {
  var i = Ce.URL || Ce.webkitURL, r = document.createElement("a");
  t = t || n.name || "download", r.download = t, r.rel = "noopener", typeof n == "string" ? (r.href = n, r.origin !== location.origin ? Vp(r.href) ? Nh(n, t, e) : Nu(r, r.target = "_blank") : Nu(r)) : (r.href = i.createObjectURL(n), setTimeout(function() {
    i.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Nu(r);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, t, e) {
  if (t = t || n.name || "download", typeof n == "string") if (Vp(n)) Nh(n, t, e);
  else {
    var i = document.createElement("a");
    i.href = n, i.target = "_blank", setTimeout(function() {
      Nu(i);
    });
  }
  else navigator.msSaveOrOpenBlob(function(r, s) {
    return s === void 0 ? s = { autoBom: !1 } : en(s) !== "object" && (an.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(r.type) ? new Blob(["\uFEFF", r], { type: r.type }) : r;
  }(n, e), t);
} : function(n, t, e, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof n == "string") return Nh(n, t, e);
  var r = n.type === "application/octet-stream", s = /constructor/i.test(Ce.HTMLElement) || Ce.safari, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || r && s) && (typeof FileReader > "u" ? "undefined" : en(FileReader)) === "object") {
    var a = new FileReader();
    a.onloadend = function() {
      var u = a.result;
      u = o ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = u : location = u, i = null;
    }, a.readAsDataURL(n);
  } else {
    var l = Ce.URL || Ce.webkitURL, h = l.createObjectURL(n);
    i ? i.location = h : location.href = h, i = null, setTimeout(function() {
      l.revokeObjectURL(h);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function P1(n) {
  var t;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var e = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(a) {
    return [parseInt(a[1]), parseInt(a[2]), parseInt(a[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(a) {
    return [parseInt(a[1], 16), parseInt(a[2], 16), parseInt(a[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(a) {
    return [parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16), parseInt(a[3] + a[3], 16)];
  } }], i = 0; i < e.length; i++) {
    var r = e[i].re, s = e[i].process, o = r.exec(n);
    o && (t = s(o), this.r = t[0], this.g = t[1], this.b = t[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var a = this.r.toString(16), l = this.g.toString(16), h = this.b.toString(16);
    return a.length == 1 && (a = "0" + a), l.length == 1 && (l = "0" + l), h.length == 1 && (h = "0" + h), "#" + a + l + h;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ch(n, t) {
  var e = n[0], i = n[1], r = n[2], s = n[3];
  e = ni(e, i, r, s, t[0], 7, -680876936), s = ni(s, e, i, r, t[1], 12, -389564586), r = ni(r, s, e, i, t[2], 17, 606105819), i = ni(i, r, s, e, t[3], 22, -1044525330), e = ni(e, i, r, s, t[4], 7, -176418897), s = ni(s, e, i, r, t[5], 12, 1200080426), r = ni(r, s, e, i, t[6], 17, -1473231341), i = ni(i, r, s, e, t[7], 22, -45705983), e = ni(e, i, r, s, t[8], 7, 1770035416), s = ni(s, e, i, r, t[9], 12, -1958414417), r = ni(r, s, e, i, t[10], 17, -42063), i = ni(i, r, s, e, t[11], 22, -1990404162), e = ni(e, i, r, s, t[12], 7, 1804603682), s = ni(s, e, i, r, t[13], 12, -40341101), r = ni(r, s, e, i, t[14], 17, -1502002290), e = ii(e, i = ni(i, r, s, e, t[15], 22, 1236535329), r, s, t[1], 5, -165796510), s = ii(s, e, i, r, t[6], 9, -1069501632), r = ii(r, s, e, i, t[11], 14, 643717713), i = ii(i, r, s, e, t[0], 20, -373897302), e = ii(e, i, r, s, t[5], 5, -701558691), s = ii(s, e, i, r, t[10], 9, 38016083), r = ii(r, s, e, i, t[15], 14, -660478335), i = ii(i, r, s, e, t[4], 20, -405537848), e = ii(e, i, r, s, t[9], 5, 568446438), s = ii(s, e, i, r, t[14], 9, -1019803690), r = ii(r, s, e, i, t[3], 14, -187363961), i = ii(i, r, s, e, t[8], 20, 1163531501), e = ii(e, i, r, s, t[13], 5, -1444681467), s = ii(s, e, i, r, t[2], 9, -51403784), r = ii(r, s, e, i, t[7], 14, 1735328473), e = ri(e, i = ii(i, r, s, e, t[12], 20, -1926607734), r, s, t[5], 4, -378558), s = ri(s, e, i, r, t[8], 11, -2022574463), r = ri(r, s, e, i, t[11], 16, 1839030562), i = ri(i, r, s, e, t[14], 23, -35309556), e = ri(e, i, r, s, t[1], 4, -1530992060), s = ri(s, e, i, r, t[4], 11, 1272893353), r = ri(r, s, e, i, t[7], 16, -155497632), i = ri(i, r, s, e, t[10], 23, -1094730640), e = ri(e, i, r, s, t[13], 4, 681279174), s = ri(s, e, i, r, t[0], 11, -358537222), r = ri(r, s, e, i, t[3], 16, -722521979), i = ri(i, r, s, e, t[6], 23, 76029189), e = ri(e, i, r, s, t[9], 4, -640364487), s = ri(s, e, i, r, t[12], 11, -421815835), r = ri(r, s, e, i, t[15], 16, 530742520), e = si(e, i = ri(i, r, s, e, t[2], 23, -995338651), r, s, t[0], 6, -198630844), s = si(s, e, i, r, t[7], 10, 1126891415), r = si(r, s, e, i, t[14], 15, -1416354905), i = si(i, r, s, e, t[5], 21, -57434055), e = si(e, i, r, s, t[12], 6, 1700485571), s = si(s, e, i, r, t[3], 10, -1894986606), r = si(r, s, e, i, t[10], 15, -1051523), i = si(i, r, s, e, t[1], 21, -2054922799), e = si(e, i, r, s, t[8], 6, 1873313359), s = si(s, e, i, r, t[15], 10, -30611744), r = si(r, s, e, i, t[6], 15, -1560198380), i = si(i, r, s, e, t[13], 21, 1309151649), e = si(e, i, r, s, t[4], 6, -145523070), s = si(s, e, i, r, t[11], 10, -1120210379), r = si(r, s, e, i, t[2], 15, 718787259), i = si(i, r, s, e, t[9], 21, -343485551), n[0] = Os(e, n[0]), n[1] = Os(i, n[1]), n[2] = Os(r, n[2]), n[3] = Os(s, n[3]);
}
function Dc(n, t, e, i, r, s) {
  return t = Os(Os(t, n), Os(i, s)), Os(t << r | t >>> 32 - r, e);
}
function ni(n, t, e, i, r, s, o) {
  return Dc(t & e | ~t & i, n, t, r, s, o);
}
function ii(n, t, e, i, r, s, o) {
  return Dc(t & i | e & ~i, n, t, r, s, o);
}
function ri(n, t, e, i, r, s, o) {
  return Dc(t ^ e ^ i, n, t, r, s, o);
}
function si(n, t, e, i, r, s, o) {
  return Dc(e ^ (t | ~i), n, t, r, s, o);
}
function L1(n) {
  var t, e = n.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (t = 64; t <= n.length; t += 64) Ch(i, gv(n.substring(t - 64, t)));
  n = n.substring(t - 64);
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (t = 0; t < n.length; t++) r[t >> 2] |= n.charCodeAt(t) << (t % 4 << 3);
  if (r[t >> 2] |= 128 << (t % 4 << 3), t > 55) for (Ch(i, r), t = 0; t < 16; t++) r[t] = 0;
  return r[14] = 8 * e, Ch(i, r), i;
}
function gv(n) {
  var t, e = [];
  for (t = 0; t < 64; t += 4) e[t >> 2] = n.charCodeAt(t) + (n.charCodeAt(t + 1) << 8) + (n.charCodeAt(t + 2) << 16) + (n.charCodeAt(t + 3) << 24);
  return e;
}
Sl = Ce.atob.bind(Ce), ff = Ce.btoa.bind(Ce);
var Yp = "0123456789abcdef".split("");
function mv(n) {
  for (var t = "", e = 0; e < 4; e++) t += Yp[n >> 8 * e + 4 & 15] + Yp[n >> 8 * e & 15];
  return t;
}
function yv(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function df(n) {
  return L1(n).map(yv).join("");
}
var bv = function(n) {
  for (var t = 0; t < n.length; t++) n[t] = mv(n[t]);
  return n.join("");
}(L1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Os(n, t) {
  if (bv) {
    var e = (65535 & n) + (65535 & t);
    return (n >> 16) + (t >> 16) + (e >> 16) << 16 | 65535 & e;
  }
  return n + t & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function pf(n, t) {
  var e, i, r, s;
  if (n !== e) {
    for (var o = (r = n, s = 1 + (256 / n.length >> 0), new Array(s + 1).join(r)), a = [], l = 0; l < 256; l++) a[l] = l;
    var h = 0;
    for (l = 0; l < 256; l++) {
      var u = a[l];
      h = (h + u + o.charCodeAt(l)) % 256, a[l] = a[h], a[h] = u;
    }
    e = n, i = a;
  } else a = i;
  var d = t.length, p = 0, f = 0, m = "";
  for (l = 0; l < d; l++) f = (f + (u = a[p = (p + 1) % 256])) % 256, a[p] = a[f], a[f] = u, o = a[(a[p] + a[f]) % 256], m += String.fromCharCode(t.charCodeAt(l) ^ o);
  return m;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Kp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function da(n, t, e, i) {
  this.v = 1, this.r = 2;
  var r = 192;
  n.forEach(function(a) {
    if (Kp.perm !== void 0) throw new Error("Invalid permission: " + a);
    r += Kp[a];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (t + this.padding).substr(0, 32), o = (e + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, o), this.P = -(1 + (255 ^ r)), this.encryptionKey = df(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = pf(this.encryptionKey, this.padding);
}
function pa(n) {
  if (/[^\u0000-\u00ff]/.test(n)) throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var t = "", e = n.length, i = 0; i < e; i++) {
    var r = n.charCodeAt(i);
    r < 33 || r === 35 || r === 37 || r === 40 || r === 41 || r === 47 || r === 60 || r === 62 || r === 91 || r === 93 || r === 123 || r === 125 || r > 126 ? t += "#" + ("0" + r.toString(16)).slice(-2) : t += n[i];
  }
  return t;
}
function Xp(n) {
  if (en(n) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var t = {};
  this.subscribe = function(e, i, r) {
    if (r = r || !1, typeof e != "string" || typeof i != "function" || typeof r != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    t.hasOwnProperty(e) || (t[e] = {});
    var s = Math.random().toString(35);
    return t[e][s] = [i, !!r], s;
  }, this.unsubscribe = function(e) {
    for (var i in t) if (t[i][e]) return delete t[i][e], Object.keys(t[i]).length === 0 && delete t[i], !0;
    return !1;
  }, this.publish = function(e) {
    if (t.hasOwnProperty(e)) {
      var i = Array.prototype.slice.call(arguments, 1), r = [];
      for (var s in t[e]) {
        var o = t[e][s];
        try {
          o[0].apply(n, i);
        } catch (a) {
          Ce.console && an.error("jsPDF PubSub Error", a.message, a);
        }
        o[1] && r.push(s);
      }
      r.length && r.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return t;
  };
}
function Ll(n) {
  if (!(this instanceof Ll)) return new Ll(n);
  var t = "opacity,stroke-opacity".split(",");
  for (var e in n) n.hasOwnProperty(e) && t.indexOf(e) >= 0 && (this[e] = n[e]);
  this.id = "", this.objectNumber = -1;
}
function I1(n, t) {
  this.gState = n, this.matrix = t, this.id = "", this.objectNumber = -1;
}
function Is(n, t, e, i, r) {
  if (!(this instanceof Is)) return new Is(n, t, e, i, r);
  this.type = n === "axial" ? 2 : 3, this.coords = t, this.colors = e, I1.call(this, i, r);
}
function uo(n, t, e, i, r) {
  if (!(this instanceof uo)) return new uo(n, t, e, i, r);
  this.boundingBox = n, this.xStep = t, this.yStep = e, this.stream = "", this.cloneIndex = 0, I1.call(this, i, r);
}
function Se(n) {
  var t, e = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], r = arguments[2], s = arguments[3], o = [], a = 1, l = 16, h = "S", u = null;
  en(n = n || {}) === "object" && (e = n.orientation, i = n.unit || i, r = n.format || r, s = n.compress || n.compressPdf || s, (u = n.encryption || null) !== null && (u.userPassword = u.userPassword || "", u.ownerPassword = u.ownerPassword || "", u.userPermissions = u.userPermissions || []), a = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (t = n.precision), n.floatPrecision !== void 0 && (l = n.floatPrecision), h = n.defaultPathOperation || "S"), o = n.filters || (s === !0 ? ["FlateEncode"] : o), i = i || "mm", e = ("" + (e || "P")).toLowerCase();
  var d = n.putOnlyUsedFonts || !1, p = {}, f = { internal: {}, __private__: {} };
  f.__private__.PubSub = Xp;
  var m = "1.3", b = f.__private__.getPdfVersion = function() {
    return m;
  };
  f.__private__.setPdfVersion = function(w) {
    m = w;
  };
  var x = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  f.__private__.getPageFormats = function() {
    return x;
  };
  var y = f.__private__.getPageFormat = function(w) {
    return x[w];
  };
  r = r || "a4";
  var v = { COMPAT: "compat", ADVANCED: "advanced" }, k = v.COMPAT;
  function C() {
    this.saveGraphicsState(), U(new xe(kt, 0, 0, -kt, 0, ps() * kt).toString() + " cm"), this.setFontSize(this.getFontSize() / kt), h = "n", k = v.ADVANCED;
  }
  function E() {
    this.restoreGraphicsState(), h = "S", k = v.COMPAT;
  }
  var q = f.__private__.combineFontStyleAndFontWeight = function(w, D) {
    if (w == "bold" && D == "normal" || w == "bold" && D == 400 || w == "normal" && D == "italic" || w == "bold" && D == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return D && (w = D == 400 || D === "normal" ? w === "italic" ? "italic" : "normal" : D != 700 && D !== "bold" || w !== "normal" ? (D == 700 ? "bold" : D) + "" + w : "bold"), w;
  };
  f.advancedAPI = function(w) {
    var D = k === v.COMPAT;
    return D && C.call(this), typeof w != "function" || (w(this), D && E.call(this)), this;
  }, f.compatAPI = function(w) {
    var D = k === v.ADVANCED;
    return D && E.call(this), typeof w != "function" || (w(this), D && C.call(this)), this;
  }, f.isAdvancedAPI = function() {
    return k === v.ADVANCED;
  };
  var T, F = function(w) {
    if (k !== v.ADVANCED) throw new Error(w + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, M = f.roundToPrecision = f.__private__.roundToPrecision = function(w, D) {
    var ut = t || D;
    if (isNaN(w) || isNaN(ut)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return w.toFixed(ut).replace(/0+$/, "");
  };
  T = f.hpf = f.__private__.hpf = typeof l == "number" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, l);
  } : l === "smart" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, w > -1 && w < 1 ? 16 : 5);
  } : function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, 16);
  };
  var B = f.f2 = f.__private__.f2 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f2");
    return M(w, 2);
  }, P = f.__private__.f3 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f3");
    return M(w, 3);
  }, A = f.scale = f.__private__.scale = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.scale");
    return k === v.COMPAT ? w * kt : k === v.ADVANCED ? w : void 0;
  }, I = function(w) {
    return k === v.COMPAT ? ps() - w : k === v.ADVANCED ? w : void 0;
  }, S = function(w) {
    return A(I(w));
  };
  f.__private__.setPrecision = f.setPrecision = function(w) {
    typeof parseInt(w, 10) == "number" && (t = parseInt(w, 10));
  };
  var X, H = "00000000000000000000000000000000", j = f.__private__.getFileId = function() {
    return H;
  }, Q = f.__private__.setFileId = function(w) {
    return H = w !== void 0 && /^[a-fA-F0-9]{32}$/.test(w) ? w.toUpperCase() : H.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), u !== null && (Me = new da(u.userPermissions, u.userPassword, u.ownerPassword, H)), H;
  };
  f.setFileId = function(w) {
    return Q(w), this;
  }, f.getFileId = function() {
    return j();
  };
  var G = f.__private__.convertDateToPDFDate = function(w) {
    var D = w.getTimezoneOffset(), ut = D < 0 ? "+" : "-", gt = Math.floor(Math.abs(D / 60)), Pt = Math.abs(D % 60), Bt = [ut, V(gt), "'", V(Pt), "'"].join("");
    return ["D:", w.getFullYear(), V(w.getMonth() + 1), V(w.getDate()), V(w.getHours()), V(w.getMinutes()), V(w.getSeconds()), Bt].join("");
  }, ft = f.__private__.convertPDFDateToDate = function(w) {
    var D = parseInt(w.substr(2, 4), 10), ut = parseInt(w.substr(6, 2), 10) - 1, gt = parseInt(w.substr(8, 2), 10), Pt = parseInt(w.substr(10, 2), 10), Bt = parseInt(w.substr(12, 2), 10), Xt = parseInt(w.substr(14, 2), 10);
    return new Date(D, ut, gt, Pt, Bt, Xt, 0);
  }, nt = f.__private__.setCreationDate = function(w) {
    var D;
    if (w === void 0 && (w = /* @__PURE__ */ new Date()), w instanceof Date) D = G(w);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(w)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      D = w;
    }
    return X = D;
  }, N = f.__private__.getCreationDate = function(w) {
    var D = X;
    return w === "jsDate" && (D = ft(X)), D;
  };
  f.setCreationDate = function(w) {
    return nt(w), this;
  }, f.getCreationDate = function(w) {
    return N(w);
  };
  var z, V = f.__private__.padd2 = function(w) {
    return ("0" + parseInt(w)).slice(-2);
  }, Y = f.__private__.padd2Hex = function(w) {
    return ("00" + (w = w.toString())).substr(w.length);
  }, ot = 0, wt = [], mt = [], xt = 0, zt = [], Dt = [], Jt = !1, Qt = mt, O = function() {
    ot = 0, xt = 0, mt = [], wt = [], zt = [], er = wn(), gi = wn();
  };
  f.__private__.setCustomOutputDestination = function(w) {
    Jt = !0, Qt = w;
  };
  var ct = function(w) {
    Jt || (Qt = w);
  };
  f.__private__.resetCustomOutputDestination = function() {
    Jt = !1, Qt = mt;
  };
  var U = f.__private__.out = function(w) {
    return w = w.toString(), xt += w.length + 1, Qt.push(w), Qt;
  }, et = f.__private__.write = function(w) {
    return U(arguments.length === 1 ? w.toString() : Array.prototype.join.call(arguments, " "));
  }, J = f.__private__.getArrayBuffer = function(w) {
    for (var D = w.length, ut = new ArrayBuffer(D), gt = new Uint8Array(ut); D--; ) gt[D] = w.charCodeAt(D);
    return ut;
  }, rt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  f.__private__.getStandardFonts = function() {
    return rt;
  };
  var vt = n.fontSize || 16;
  f.__private__.setFontSize = f.setFontSize = function(w) {
    return vt = k === v.ADVANCED ? w / kt : w, this;
  };
  var At, ht = f.__private__.getFontSize = f.getFontSize = function() {
    return k === v.COMPAT ? vt : vt * kt;
  }, Ot = n.R2L || !1;
  f.__private__.setR2L = f.setR2L = function(w) {
    return Ot = w, this;
  }, f.__private__.getR2L = f.getR2L = function() {
    return Ot;
  };
  var $t, Ft = f.__private__.setZoomMode = function(w) {
    var D = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(w)) At = w;
    else if (isNaN(w)) {
      if (D.indexOf(w) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + w + '" is not recognized.');
      At = w;
    } else At = parseInt(w, 10);
  };
  f.__private__.getZoomMode = function() {
    return At;
  };
  var Ut, ie = f.__private__.setPageMode = function(w) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(w) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + w + '" is not recognized.');
    $t = w;
  };
  f.__private__.getPageMode = function() {
    return $t;
  };
  var oe = f.__private__.setLayoutMode = function(w) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(w) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + w + '" is not recognized.');
    Ut = w;
  };
  f.__private__.getLayoutMode = function() {
    return Ut;
  }, f.__private__.setDisplayMode = f.setDisplayMode = function(w, D, ut) {
    return Ft(w), oe(D), ie(ut), this;
  };
  var ae = { title: "", subject: "", author: "", keywords: "", creator: "" };
  f.__private__.getDocumentProperty = function(w) {
    if (Object.keys(ae).indexOf(w) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ae[w];
  }, f.__private__.getDocumentProperties = function() {
    return ae;
  }, f.__private__.setDocumentProperties = f.setProperties = f.setDocumentProperties = function(w) {
    for (var D in ae) ae.hasOwnProperty(D) && w[D] && (ae[D] = w[D]);
    return this;
  }, f.__private__.setDocumentProperty = function(w, D) {
    if (Object.keys(ae).indexOf(w) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ae[w] = D;
  };
  var dt, kt, te, Rt, be, Kt = {}, jt = {}, ge = [], we = {}, Rn = {}, Ze = {}, Dn = {}, fn = null, We = 0, ke = [], He = new Xp(f), tr = n.hotfixes || [], En = {}, Bi = {}, mn = [], xe = function w(D, ut, gt, Pt, Bt, Xt) {
    if (!(this instanceof w)) return new w(D, ut, gt, Pt, Bt, Xt);
    isNaN(D) && (D = 1), isNaN(ut) && (ut = 0), isNaN(gt) && (gt = 0), isNaN(Pt) && (Pt = 1), isNaN(Bt) && (Bt = 0), isNaN(Xt) && (Xt = 0), this._matrix = [D, ut, gt, Pt, Bt, Xt];
  };
  Object.defineProperty(xe.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(xe.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(xe.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(xe.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(xe.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(xe.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(xe.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(xe.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(xe.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(xe.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(xe.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(xe.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(xe.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(xe.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(xe.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(xe.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), xe.prototype.join = function(w) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(T).join(w);
  }, xe.prototype.multiply = function(w) {
    var D = w.sx * this.sx + w.shy * this.shx, ut = w.sx * this.shy + w.shy * this.sy, gt = w.shx * this.sx + w.sy * this.shx, Pt = w.shx * this.shy + w.sy * this.sy, Bt = w.tx * this.sx + w.ty * this.shx + this.tx, Xt = w.tx * this.shy + w.ty * this.sy + this.ty;
    return new xe(D, ut, gt, Pt, Bt, Xt);
  }, xe.prototype.decompose = function() {
    var w = this.sx, D = this.shy, ut = this.shx, gt = this.sy, Pt = this.tx, Bt = this.ty, Xt = Math.sqrt(w * w + D * D), ue = (w /= Xt) * ut + (D /= Xt) * gt;
    ut -= w * ue, gt -= D * ue;
    var ye = Math.sqrt(ut * ut + gt * gt);
    return ue /= ye, w * (gt /= ye) < D * (ut /= ye) && (w = -w, D = -D, ue = -ue, Xt = -Xt), { scale: new xe(Xt, 0, 0, ye, 0, 0), translate: new xe(1, 0, 0, 1, Pt, Bt), rotate: new xe(w, D, -D, w, 0, 0), skew: new xe(1, 0, ue, 1, 0, 0) };
  }, xe.prototype.toString = function(w) {
    return this.join(" ");
  }, xe.prototype.inversed = function() {
    var w = this.sx, D = this.shy, ut = this.shx, gt = this.sy, Pt = this.tx, Bt = this.ty, Xt = 1 / (w * gt - D * ut), ue = gt * Xt, ye = -D * Xt, Oe = -ut * Xt, Ie = w * Xt;
    return new xe(ue, ye, Oe, Ie, -ue * Pt - Oe * Bt, -ye * Pt - Ie * Bt);
  }, xe.prototype.applyToPoint = function(w) {
    var D = w.x * this.sx + w.y * this.shx + this.tx, ut = w.x * this.shy + w.y * this.sy + this.ty;
    return new zo(D, ut);
  }, xe.prototype.applyToRectangle = function(w) {
    var D = this.applyToPoint(w), ut = this.applyToPoint(new zo(w.x + w.w, w.y + w.h));
    return new $a(D.x, D.y, ut.x - D.x, ut.y - D.y);
  }, xe.prototype.clone = function() {
    var w = this.sx, D = this.shy, ut = this.shx, gt = this.sy, Pt = this.tx, Bt = this.ty;
    return new xe(w, D, ut, gt, Pt, Bt);
  }, f.Matrix = xe;
  var Ai = f.matrixMult = function(w, D) {
    return D.multiply(w);
  }, ji = new xe(1, 0, 0, 1, 0, 0);
  f.unitMatrix = f.identityMatrix = ji;
  var ti = function(w, D) {
    if (!Rn[w]) {
      var ut = (D instanceof Is ? "Sh" : "P") + (Object.keys(we).length + 1).toString(10);
      D.id = ut, Rn[w] = ut, we[ut] = D, He.publish("addPattern", D);
    }
  };
  f.ShadingPattern = Is, f.TilingPattern = uo, f.addShadingPattern = function(w, D) {
    return F("addShadingPattern()"), ti(w, D), this;
  }, f.beginTilingPattern = function(w) {
    F("beginTilingPattern()"), Kl(w.boundingBox[0], w.boundingBox[1], w.boundingBox[2] - w.boundingBox[0], w.boundingBox[3] - w.boundingBox[1], w.matrix);
  }, f.endTilingPattern = function(w, D) {
    F("endTilingPattern()"), D.stream = Dt[z].join(`
`), ti(w, D), He.publish("endTilingPattern", D), mn.pop().restore();
  };
  var vn = f.__private__.newObject = function() {
    var w = wn();
    return ui(w, !0), w;
  }, wn = f.__private__.newObjectDeferred = function() {
    return ot++, wt[ot] = function() {
      return xt;
    }, ot;
  }, ui = function(w, D) {
    return D = typeof D == "boolean" && D, wt[w] = xt, D && U(w + " 0 obj"), w;
  }, ss = f.__private__.newAdditionalObject = function() {
    var w = { objId: wn(), content: "" };
    return zt.push(w), w;
  }, er = wn(), gi = wn(), Ni = f.__private__.decodeColorString = function(w) {
    var D = w.split(" ");
    if (D.length !== 2 || D[1] !== "g" && D[1] !== "G")
      D.length === 5 && (D[4] === "k" || D[4] === "K") && (D = [(1 - D[0]) * (1 - D[3]), (1 - D[1]) * (1 - D[3]), (1 - D[2]) * (1 - D[3]), "r"]);
    else {
      var ut = parseFloat(D[0]);
      D = [ut, ut, ut, "r"];
    }
    for (var gt = "#", Pt = 0; Pt < 3; Pt++) gt += ("0" + Math.floor(255 * parseFloat(D[Pt])).toString(16)).slice(-2);
    return gt;
  }, Ci = f.__private__.encodeColorString = function(w) {
    var D;
    typeof w == "string" && (w = { ch1: w });
    var ut = w.ch1, gt = w.ch2, Pt = w.ch3, Bt = w.ch4, Xt = w.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ut == "string" && ut.charAt(0) !== "#") {
      var ue = new P1(ut);
      if (ue.ok) ut = ue.toHex();
      else if (!/^\d*\.?\d*$/.test(ut)) throw new Error('Invalid color "' + ut + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof ut == "string" && /^#[0-9A-Fa-f]{3}$/.test(ut) && (ut = "#" + ut[1] + ut[1] + ut[2] + ut[2] + ut[3] + ut[3]), typeof ut == "string" && /^#[0-9A-Fa-f]{6}$/.test(ut)) {
      var ye = parseInt(ut.substr(1), 16);
      ut = ye >> 16 & 255, gt = ye >> 8 & 255, Pt = 255 & ye;
    }
    if (gt === void 0 || Bt === void 0 && ut === gt && gt === Pt) if (typeof ut == "string") D = ut + " " + Xt[0];
    else switch (w.precision) {
      case 2:
        D = B(ut / 255) + " " + Xt[0];
        break;
      case 3:
      default:
        D = P(ut / 255) + " " + Xt[0];
    }
    else if (Bt === void 0 || en(Bt) === "object") {
      if (Bt && !isNaN(Bt.a) && Bt.a === 0) return D = ["1.", "1.", "1.", Xt[1]].join(" ");
      if (typeof ut == "string") D = [ut, gt, Pt, Xt[1]].join(" ");
      else switch (w.precision) {
        case 2:
          D = [B(ut / 255), B(gt / 255), B(Pt / 255), Xt[1]].join(" ");
          break;
        default:
        case 3:
          D = [P(ut / 255), P(gt / 255), P(Pt / 255), Xt[1]].join(" ");
      }
    } else if (typeof ut == "string") D = [ut, gt, Pt, Bt, Xt[2]].join(" ");
    else switch (w.precision) {
      case 2:
        D = [B(ut), B(gt), B(Pt), B(Bt), Xt[2]].join(" ");
        break;
      case 3:
      default:
        D = [P(ut), P(gt), P(Pt), P(Bt), Xt[2]].join(" ");
    }
    return D;
  }, qi = f.__private__.getFilters = function() {
    return o;
  }, Pi = f.__private__.putStream = function(w) {
    var D = (w = w || {}).data || "", ut = w.filters || qi(), gt = w.alreadyAppliedFilters || [], Pt = w.addLength1 || !1, Bt = D.length, Xt = w.objectId, ue = function(ei) {
      return ei;
    };
    if (u !== null && Xt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    u !== null && (ue = Me.encryptor(Xt, 0));
    var ye = {};
    ut === !0 && (ut = ["FlateEncode"]);
    var Oe = w.additionalKeyValues || [], Ie = (ye = Se.API.processDataByFilters !== void 0 ? Se.API.processDataByFilters(D, ut) : { data: D, reverseChain: [] }).reverseChain + (Array.isArray(gt) ? gt.join(" ") : gt.toString());
    if (ye.data.length !== 0 && (Oe.push({ key: "Length", value: ye.data.length }), Pt === !0 && Oe.push({ key: "Length1", value: Bt })), Ie.length != 0) if (Ie.split("/").length - 1 == 1) Oe.push({ key: "Filter", value: Ie });
    else {
      Oe.push({ key: "Filter", value: "[" + Ie + "]" });
      for (var qe = 0; qe < Oe.length; qe += 1) if (Oe[qe].key === "DecodeParms") {
        for (var yn = [], xn = 0; xn < ye.reverseChain.split("/").length - 1; xn += 1) yn.push("null");
        yn.push(Oe[qe].value), Oe[qe].value = "[" + yn.join(" ") + "]";
      }
    }
    U("<<");
    for (var On = 0; On < Oe.length; On++) U("/" + Oe[On].key + " " + Oe[On].value);
    U(">>"), ye.data.length !== 0 && (U("stream"), U(ue(ye.data)), U("endstream"));
  }, zi = f.__private__.putPage = function(w) {
    var D = w.number, ut = w.data, gt = w.objId, Pt = w.contentsObjId;
    ui(gt, !0), U("<</Type /Page"), U("/Parent " + w.rootDictionaryObjId + " 0 R"), U("/Resources " + w.resourceDictionaryObjId + " 0 R"), U("/MediaBox [" + parseFloat(T(w.mediaBox.bottomLeftX)) + " " + parseFloat(T(w.mediaBox.bottomLeftY)) + " " + T(w.mediaBox.topRightX) + " " + T(w.mediaBox.topRightY) + "]"), w.cropBox !== null && U("/CropBox [" + T(w.cropBox.bottomLeftX) + " " + T(w.cropBox.bottomLeftY) + " " + T(w.cropBox.topRightX) + " " + T(w.cropBox.topRightY) + "]"), w.bleedBox !== null && U("/BleedBox [" + T(w.bleedBox.bottomLeftX) + " " + T(w.bleedBox.bottomLeftY) + " " + T(w.bleedBox.topRightX) + " " + T(w.bleedBox.topRightY) + "]"), w.trimBox !== null && U("/TrimBox [" + T(w.trimBox.bottomLeftX) + " " + T(w.trimBox.bottomLeftY) + " " + T(w.trimBox.topRightX) + " " + T(w.trimBox.topRightY) + "]"), w.artBox !== null && U("/ArtBox [" + T(w.artBox.bottomLeftX) + " " + T(w.artBox.bottomLeftY) + " " + T(w.artBox.topRightX) + " " + T(w.artBox.topRightY) + "]"), typeof w.userUnit == "number" && w.userUnit !== 1 && U("/UserUnit " + w.userUnit), He.publish("putPage", { objId: gt, pageContext: ke[D], pageNumber: D, page: ut }), U("/Contents " + Pt + " 0 R"), U(">>"), U("endobj");
    var Bt = ut.join(`
`);
    return k === v.ADVANCED && (Bt += `
Q`), ui(Pt, !0), Pi({ data: Bt, filters: qi(), objectId: Pt }), U("endobj"), gt;
  }, wr = f.__private__.putPages = function() {
    var w, D, ut = [];
    for (w = 1; w <= We; w++) ke[w].objId = wn(), ke[w].contentsObjId = wn();
    for (w = 1; w <= We; w++) ut.push(zi({ number: w, data: Dt[w], objId: ke[w].objId, contentsObjId: ke[w].contentsObjId, mediaBox: ke[w].mediaBox, cropBox: ke[w].cropBox, bleedBox: ke[w].bleedBox, trimBox: ke[w].trimBox, artBox: ke[w].artBox, userUnit: ke[w].userUnit, rootDictionaryObjId: er, resourceDictionaryObjId: gi }));
    ui(er, !0), U("<</Type /Pages");
    var gt = "/Kids [";
    for (D = 0; D < We; D++) gt += ut[D] + " 0 R ";
    U(gt + "]"), U("/Count " + We), U(">>"), U("endobj"), He.publish("postPutPages");
  }, Dr = function(w) {
    He.publish("putFont", { font: w, out: U, newObject: vn, putStream: Pi }), w.isAlreadyPutted !== !0 && (w.objectNumber = vn(), U("<<"), U("/Type /Font"), U("/BaseFont /" + pa(w.postScriptName)), U("/Subtype /Type1"), typeof w.encoding == "string" && U("/Encoding /" + w.encoding), U("/FirstChar 32"), U("/LastChar 255"), U(">>"), U("endobj"));
  }, nr = function() {
    for (var w in Kt) Kt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && Dr(Kt[w]);
  }, Br = function(w) {
    w.objectNumber = vn();
    var D = [];
    D.push({ key: "Type", value: "/XObject" }), D.push({ key: "Subtype", value: "/Form" }), D.push({ key: "BBox", value: "[" + [T(w.x), T(w.y), T(w.x + w.width), T(w.y + w.height)].join(" ") + "]" }), D.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" });
    var ut = w.pages[1].join(`
`);
    Pi({ data: ut, additionalKeyValues: D, objectId: w.objectNumber }), U("endobj");
  }, jr = function() {
    for (var w in En) En.hasOwnProperty(w) && Br(En[w]);
  }, qr = function(w, D) {
    var ut, gt = [], Pt = 1 / (D - 1);
    for (ut = 0; ut < 1; ut += Pt) gt.push(ut);
    if (gt.push(1), w[0].offset != 0) {
      var Bt = { offset: 0, color: w[0].color };
      w.unshift(Bt);
    }
    if (w[w.length - 1].offset != 1) {
      var Xt = { offset: 1, color: w[w.length - 1].color };
      w.push(Xt);
    }
    for (var ue = "", ye = 0, Oe = 0; Oe < gt.length; Oe++) {
      for (ut = gt[Oe]; ut > w[ye + 1].offset; ) ye++;
      var Ie = w[ye].offset, qe = (ut - Ie) / (w[ye + 1].offset - Ie), yn = w[ye].color, xn = w[ye + 1].color;
      ue += Y(Math.round((1 - qe) * yn[0] + qe * xn[0]).toString(16)) + Y(Math.round((1 - qe) * yn[1] + qe * xn[1]).toString(16)) + Y(Math.round((1 - qe) * yn[2] + qe * xn[2]).toString(16));
    }
    return ue.trim();
  }, os = function(w, D) {
    D || (D = 21);
    var ut = vn(), gt = qr(w.colors, D), Pt = [];
    Pt.push({ key: "FunctionType", value: "0" }), Pt.push({ key: "Domain", value: "[0.0 1.0]" }), Pt.push({ key: "Size", value: "[" + D + "]" }), Pt.push({ key: "BitsPerSample", value: "8" }), Pt.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Pt.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Pi({ data: gt, additionalKeyValues: Pt, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: ut }), U("endobj"), w.objectNumber = vn(), U("<< /ShadingType " + w.type), U("/ColorSpace /DeviceRGB");
    var Bt = "/Coords [" + T(parseFloat(w.coords[0])) + " " + T(parseFloat(w.coords[1])) + " ";
    w.type === 2 ? Bt += T(parseFloat(w.coords[2])) + " " + T(parseFloat(w.coords[3])) : Bt += T(parseFloat(w.coords[2])) + " " + T(parseFloat(w.coords[3])) + " " + T(parseFloat(w.coords[4])) + " " + T(parseFloat(w.coords[5])), U(Bt += "]"), w.matrix && U("/Matrix [" + w.matrix.toString() + "]"), U("/Function " + ut + " 0 R"), U("/Extend [true true]"), U(">>"), U("endobj");
  }, Io = function(w, D) {
    var ut = wn(), gt = vn();
    D.push({ resourcesOid: ut, objectOid: gt }), w.objectNumber = gt;
    var Pt = [];
    Pt.push({ key: "Type", value: "/Pattern" }), Pt.push({ key: "PatternType", value: "1" }), Pt.push({ key: "PaintType", value: "1" }), Pt.push({ key: "TilingType", value: "1" }), Pt.push({ key: "BBox", value: "[" + w.boundingBox.map(T).join(" ") + "]" }), Pt.push({ key: "XStep", value: T(w.xStep) }), Pt.push({ key: "YStep", value: T(w.yStep) }), Pt.push({ key: "Resources", value: ut + " 0 R" }), w.matrix && Pt.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" }), Pi({ data: w.stream, additionalKeyValues: Pt, objectId: w.objectNumber }), U("endobj");
  }, as = function(w) {
    var D;
    for (D in we) we.hasOwnProperty(D) && (we[D] instanceof Is ? os(we[D]) : we[D] instanceof uo && Io(we[D], w));
  }, Eo = function(w) {
    for (var D in w.objectNumber = vn(), U("<<"), w) switch (D) {
      case "opacity":
        U("/ca " + B(w[D]));
        break;
      case "stroke-opacity":
        U("/CA " + B(w[D]));
    }
    U(">>"), U("endobj");
  }, ls = function() {
    var w;
    for (w in Ze) Ze.hasOwnProperty(w) && Eo(Ze[w]);
  }, $s = function() {
    for (var w in U("/XObject <<"), En) En.hasOwnProperty(w) && En[w].objectNumber >= 0 && U("/" + w + " " + En[w].objectNumber + " 0 R");
    He.publish("putXobjectDict"), U(">>");
  }, zr = function() {
    Me.oid = vn(), U("<<"), U("/Filter /Standard"), U("/V " + Me.v), U("/R " + Me.r), U("/U <" + Me.toHexString(Me.U) + ">"), U("/O <" + Me.toHexString(Me.O) + ">"), U("/P " + Me.P), U(">>"), U("endobj");
  }, Oo = function() {
    for (var w in U("/Font <<"), Kt) Kt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && U("/" + w + " " + Kt[w].objectNumber + " 0 R");
    U(">>");
  }, Oa = function() {
    if (Object.keys(we).length > 0) {
      for (var w in U("/Shading <<"), we) we.hasOwnProperty(w) && we[w] instanceof Is && we[w].objectNumber >= 0 && U("/" + w + " " + we[w].objectNumber + " 0 R");
      He.publish("putShadingPatternDict"), U(">>");
    }
  }, us = function(w) {
    if (Object.keys(we).length > 0) {
      for (var D in U("/Pattern <<"), we) we.hasOwnProperty(D) && we[D] instanceof f.TilingPattern && we[D].objectNumber >= 0 && we[D].objectNumber < w && U("/" + D + " " + we[D].objectNumber + " 0 R");
      He.publish("putTilingPatternDict"), U(">>");
    }
  }, Ta = function() {
    if (Object.keys(Ze).length > 0) {
      var w;
      for (w in U("/ExtGState <<"), Ze) Ze.hasOwnProperty(w) && Ze[w].objectNumber >= 0 && U("/" + w + " " + Ze[w].objectNumber + " 0 R");
      He.publish("putGStateDict"), U(">>");
    }
  }, dn = function(w) {
    ui(w.resourcesOid, !0), U("<<"), U("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), Oo(), Oa(), us(w.objectOid), Ta(), $s(), U(">>"), U("endobj");
  }, To = function() {
    var w = [];
    nr(), ls(), jr(), as(w), He.publish("putResources"), w.forEach(dn), dn({ resourcesOid: gi, objectOid: Number.MAX_SAFE_INTEGER }), He.publish("postPutResources");
  }, Us = function() {
    He.publish("putAdditionalObjects");
    for (var w = 0; w < zt.length; w++) {
      var D = zt[w];
      ui(D.objId, !0), U(D.content), U("endobj");
    }
    He.publish("postPutAdditionalObjects");
  }, Fo = function(w) {
    jt[w.fontName] = jt[w.fontName] || {}, jt[w.fontName][w.fontStyle] = w.id;
  }, Ws = function(w, D, ut, gt, Pt) {
    var Bt = { id: "F" + (Object.keys(Kt).length + 1).toString(10), postScriptName: w, fontName: D, fontStyle: ut, encoding: gt, isStandardFont: Pt || !1, metadata: {} };
    return He.publish("addFont", { font: Bt, instance: this }), Kt[Bt.id] = Bt, Fo(Bt), Bt.id;
  }, $i = function(w) {
    for (var D = 0, ut = rt.length; D < ut; D++) {
      var gt = Ws.call(this, w[D][0], w[D][1], w[D][2], rt[D][3], !0);
      d === !1 && (p[gt] = !0);
      var Pt = w[D][0].split("-");
      Fo({ id: gt, fontName: Pt[0], fontStyle: Pt[1] || "" });
    }
    He.publish("addFonts", { fonts: Kt, dictionary: jt });
  }, Li = function(w) {
    return w.foo = function() {
      try {
        return w.apply(this, arguments);
      } catch (gt) {
        var D = gt.stack || "";
        ~D.indexOf(" at ") && (D = D.split(" at ")[1]);
        var ut = "Error in function " + D.split(`
`)[0].split("<")[0] + ": " + gt.message;
        if (!Ce.console) throw new Error(ut);
        Ce.console.error(ut, gt), Ce.alert && alert(ut);
      }
    }, w.foo.bar = w, w.foo;
  }, cs = function(w, D) {
    var ut, gt, Pt, Bt, Xt, ue, ye, Oe, Ie;
    if (Pt = (D = D || {}).sourceEncoding || "Unicode", Xt = D.outputEncoding, (D.autoencode || Xt) && Kt[dt].metadata && Kt[dt].metadata[Pt] && Kt[dt].metadata[Pt].encoding && (Bt = Kt[dt].metadata[Pt].encoding, !Xt && Kt[dt].encoding && (Xt = Kt[dt].encoding), !Xt && Bt.codePages && (Xt = Bt.codePages[0]), typeof Xt == "string" && (Xt = Bt[Xt]), Xt)) {
      for (ye = !1, ue = [], ut = 0, gt = w.length; ut < gt; ut++) (Oe = Xt[w.charCodeAt(ut)]) ? ue.push(String.fromCharCode(Oe)) : ue.push(w[ut]), ue[ut].charCodeAt(0) >> 8 && (ye = !0);
      w = ue.join("");
    }
    for (ut = w.length; ye === void 0 && ut !== 0; ) w.charCodeAt(ut - 1) >> 8 && (ye = !0), ut--;
    if (!ye) return w;
    for (ue = D.noBOM ? [] : [254, 255], ut = 0, gt = w.length; ut < gt; ut++) {
      if ((Ie = (Oe = w.charCodeAt(ut)) >> 8) >> 8) throw new Error("Character at position " + ut + " of string '" + w + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      ue.push(Ie), ue.push(Oe - (Ie << 8));
    }
    return String.fromCharCode.apply(void 0, ue);
  }, Vn = f.__private__.pdfEscape = f.pdfEscape = function(w, D) {
    return cs(w, D).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, hs = f.__private__.beginPage = function(w) {
    Dt[++We] = [], ke[We] = { objId: 0, contentsObjId: 0, userUnit: Number(a), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(w[0]), topRightY: Number(w[1]) } }, Ro(We), ct(Dt[z]);
  }, $r = function(w, D) {
    var ut, gt, Pt;
    switch (e = D || e, typeof w == "string" && (ut = y(w.toLowerCase()), Array.isArray(ut) && (gt = ut[0], Pt = ut[1])), Array.isArray(w) && (gt = w[0] * kt, Pt = w[1] * kt), isNaN(gt) && (gt = r[0], Pt = r[1]), (gt > 14400 || Pt > 14400) && (an.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), gt = Math.min(14400, gt), Pt = Math.min(14400, Pt)), r = [gt, Pt], e.substr(0, 1)) {
      case "l":
        Pt > gt && (r = [Pt, gt]);
        break;
      case "p":
        gt > Pt && (r = [Pt, gt]);
    }
    hs(r), Wl(Ba), U(ir), qa !== 0 && U(qa + " J"), za !== 0 && U(za + " j"), He.publish("addPage", { pageNumber: We });
  }, Mo = function(w) {
    w > 0 && w <= We && (Dt.splice(w, 1), ke.splice(w, 1), We--, z > We && (z = We), this.setPage(z));
  }, Ro = function(w) {
    w > 0 && w <= We && (z = w);
  }, Fa = f.__private__.getNumberOfPages = f.getNumberOfPages = function() {
    return Dt.length - 1;
  }, Do = function(w, D, ut) {
    var gt, Pt = void 0;
    return ut = ut || {}, w = w !== void 0 ? w : Kt[dt].fontName, D = D !== void 0 ? D : Kt[dt].fontStyle, gt = w.toLowerCase(), jt[gt] !== void 0 && jt[gt][D] !== void 0 ? Pt = jt[gt][D] : jt[w] !== void 0 && jt[w][D] !== void 0 ? Pt = jt[w][D] : ut.disableWarning === !1 && an.warn("Unable to look up font label for font '" + w + "', '" + D + "'. Refer to getFontList() for available fonts."), Pt || ut.noFallback || (Pt = jt.times[D]) == null && (Pt = jt.times.normal), Pt;
  }, lt = f.__private__.putInfo = function() {
    var w = vn(), D = function(gt) {
      return gt;
    };
    for (var ut in u !== null && (D = Me.encryptor(w, 0)), U("<<"), U("/Producer (" + Vn(D("jsPDF " + Se.version)) + ")"), ae) ae.hasOwnProperty(ut) && ae[ut] && U("/" + ut.substr(0, 1).toUpperCase() + ut.substr(1) + " (" + Vn(D(ae[ut])) + ")");
    U("/CreationDate (" + Vn(D(X)) + ")"), U(">>"), U("endobj");
  }, pt = f.__private__.putCatalog = function(w) {
    var D = (w = w || {}).rootDictionaryObjId || er;
    switch (vn(), U("<<"), U("/Type /Catalog"), U("/Pages " + D + " 0 R"), At || (At = "fullwidth"), At) {
      case "fullwidth":
        U("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        U("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        U("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        U("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var ut = "" + At;
        ut.substr(ut.length - 1) === "%" && (At = parseInt(At) / 100), typeof At == "number" && U("/OpenAction [3 0 R /XYZ null null " + B(At) + "]");
    }
    switch (Ut || (Ut = "continuous"), Ut) {
      case "continuous":
        U("/PageLayout /OneColumn");
        break;
      case "single":
        U("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        U("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        U("/PageLayout /TwoColumnRight");
    }
    $t && U("/PageMode /" + $t), He.publish("putCatalog"), U(">>"), U("endobj");
  }, _t = f.__private__.putTrailer = function() {
    U("trailer"), U("<<"), U("/Size " + (ot + 1)), U("/Root " + ot + " 0 R"), U("/Info " + (ot - 1) + " 0 R"), u !== null && U("/Encrypt " + Me.oid + " 0 R"), U("/ID [ <" + H + "> <" + H + "> ]"), U(">>");
  }, Wt = f.__private__.putHeader = function() {
    U("%PDF-" + m), U("%ºß¬à");
  }, Tt = f.__private__.putXRef = function() {
    var w = "0000000000";
    U("xref"), U("0 " + (ot + 1)), U("0000000000 65535 f ");
    for (var D = 1; D <= ot; D++)
      typeof wt[D] == "function" ? U((w + wt[D]()).slice(-10) + " 00000 n ") : wt[D] !== void 0 ? U((w + wt[D]).slice(-10) + " 00000 n ") : U("0000000000 00000 n ");
  }, fe = f.__private__.buildDocument = function() {
    O(), ct(mt), He.publish("buildDocument"), Wt(), wr(), Us(), To(), u !== null && zr(), lt(), pt();
    var w = xt;
    return Tt(), _t(), U("startxref"), U("" + w), U("%%EOF"), ct(Dt[z]), mt.join(`
`);
  }, le = f.__private__.getBlob = function(w) {
    return new Blob([J(w)], { type: "application/pdf" });
  }, ve = f.output = f.__private__.output = Li(function(w, D) {
    switch (typeof (D = D || {}) == "string" ? D = { filename: D } : D.filename = D.filename || "generated.pdf", w) {
      case void 0:
        return fe();
      case "save":
        f.save(D.filename);
        break;
      case "arraybuffer":
        return J(fe());
      case "blob":
        return le(fe());
      case "bloburi":
      case "bloburl":
        if (Ce.URL !== void 0 && typeof Ce.URL.createObjectURL == "function") return Ce.URL && Ce.URL.createObjectURL(le(fe())) || void 0;
        an.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var ut = "", gt = fe();
        try {
          ut = ff(gt);
        } catch {
          ut = ff(unescape(encodeURIComponent(gt)));
        }
        return "data:application/pdf;filename=" + D.filename + ";base64," + ut;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Ce) === "[object Window]") {
          var Pt = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Bt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          D.pdfObjectUrl && (Pt = D.pdfObjectUrl, Bt = "");
          var Xt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Pt + '"' + Bt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(D) + ");<\/script></body></html>", ue = Ce.open();
          return ue !== null && ue.document.write(Xt), ue;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Ce) === "[object Window]") {
          var ye = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (D.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + D.filename + '" width="500px" height="400px" /></body></html>', Oe = Ce.open();
          if (Oe !== null) {
            Oe.document.write(ye);
            var Ie = this;
            Oe.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Oe.document.title = D.filename, Oe.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Ie.output("bloburl"));
            };
          }
          return Oe;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Ce) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var qe = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", D) + '"></iframe></body></html>', yn = Ce.open();
        if (yn !== null && (yn.document.write(qe), yn.document.title = D.filename), yn || typeof safari > "u") return yn;
        break;
      case "datauri":
      case "dataurl":
        return Ce.document.location.href = this.output("datauristring", D);
      default:
        return null;
    }
  }), Ge = function(w) {
    return Array.isArray(tr) === !0 && tr.indexOf(w) > -1;
  };
  switch (i) {
    case "pt":
      kt = 1;
      break;
    case "mm":
      kt = 72 / 25.4;
      break;
    case "cm":
      kt = 72 / 2.54;
      break;
    case "in":
      kt = 72;
      break;
    case "px":
      kt = Ge("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      kt = 12;
      break;
    case "ex":
      kt = 6;
      break;
    default:
      if (typeof i != "number") throw new Error("Invalid unit: " + i);
      kt = i;
  }
  var Me = null;
  nt(), Q();
  var Le = function(w) {
    return u !== null ? Me.encryptor(w, 0) : function(D) {
      return D;
    };
  }, je = f.__private__.getPageInfo = f.getPageInfo = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: ke[w].objId, pageNumber: w, pageContext: ke[w] };
  }, Zt = f.__private__.getPageInfoByObjId = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var D in ke) if (ke[D].objId === w) break;
    return je(D);
  }, Ii = f.__private__.getCurrentPageInfo = f.getCurrentPageInfo = function() {
    return { objId: ke[z].objId, pageNumber: z, pageContext: ke[z] };
  };
  f.addPage = function() {
    return $r.apply(this, arguments), this;
  }, f.setPage = function() {
    return Ro.apply(this, arguments), ct.call(this, Dt[z]), this;
  }, f.insertPage = function(w) {
    return this.addPage(), this.movePage(z, w), this;
  }, f.movePage = function(w, D) {
    var ut, gt;
    if (w > D) {
      ut = Dt[w], gt = ke[w];
      for (var Pt = w; Pt > D; Pt--) Dt[Pt] = Dt[Pt - 1], ke[Pt] = ke[Pt - 1];
      Dt[D] = ut, ke[D] = gt, this.setPage(D);
    } else if (w < D) {
      ut = Dt[w], gt = ke[w];
      for (var Bt = w; Bt < D; Bt++) Dt[Bt] = Dt[Bt + 1], ke[Bt] = ke[Bt + 1];
      Dt[D] = ut, ke[D] = gt, this.setPage(D);
    }
    return this;
  }, f.deletePage = function() {
    return Mo.apply(this, arguments), this;
  }, f.__private__.text = f.text = function(w, D, ut, gt, Pt) {
    var Bt, Xt, ue, ye, Oe, Ie, qe, yn, xn, On = (gt = gt || {}).scope || this;
    if (typeof w == "number" && typeof D == "number" && (typeof ut == "string" || Array.isArray(ut))) {
      var ei = ut;
      ut = D, D = w, w = ei;
    }
    if (arguments[3] instanceof xe ? (F("The transform parameter of text() with a Matrix value"), xn = Pt) : (ue = arguments[4], ye = arguments[5], en(qe = arguments[3]) === "object" && qe !== null || (typeof ue == "string" && (ye = ue, ue = null), typeof qe == "string" && (ye = qe, qe = null), typeof qe == "number" && (ue = qe, qe = null), gt = { flags: qe, angle: ue, align: ye })), isNaN(D) || isNaN(ut) || w == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (w.length === 0) return On;
    var zn = "", rr = !1, Ei = typeof gt.lineHeightFactor == "number" ? gt.lineHeightFactor : Ys, _r = On.internal.scaleFactor;
    function Xl(ln) {
      return ln = ln.split("	").join(Array(gt.TabLen || 9).join(" ")), Vn(ln, qe);
    }
    function Ga(ln) {
      for (var un, An = ln.concat(), Bn = [], Vr = An.length; Vr--; ) typeof (un = An.shift()) == "string" ? Bn.push(un) : Array.isArray(ln) && (un.length === 1 || un[1] === void 0 && un[2] === void 0) ? Bn.push(un[0]) : Bn.push([un[0], un[1], un[2]]);
      return Bn;
    }
    function Va(ln, un) {
      var An;
      if (typeof ln == "string") An = un(ln)[0];
      else if (Array.isArray(ln)) {
        for (var Bn, Vr, el = ln.concat(), Zo = [], eu = el.length; eu--; ) typeof (Bn = el.shift()) == "string" ? Zo.push(un(Bn)[0]) : Array.isArray(Bn) && typeof Bn[0] == "string" && (Vr = un(Bn[0], Bn[1], Bn[2]), Zo.push([Vr[0], Vr[1], Vr[2]]));
        An = Zo;
      }
      return An;
    }
    var Uo = !1, Ya = !0;
    if (typeof w == "string") Uo = !0;
    else if (Array.isArray(w)) {
      var Ka = w.concat();
      Xt = [];
      for (var Wo, Yn = Ka.length; Yn--; ) (typeof (Wo = Ka.shift()) != "string" || Array.isArray(Wo) && typeof Wo[0] != "string") && (Ya = !1);
      Uo = Ya;
    }
    if (Uo === !1) throw new Error('Type of text must be string or Array. "' + w + '" is not recognized.');
    typeof w == "string" && (w = w.match(/[\r?\n]/) ? w.split(/\r\n|\r|\n/g) : [w]);
    var Ho = vt / On.internal.scaleFactor, Go = Ho * (Ei - 1);
    switch (gt.baseline) {
      case "bottom":
        ut -= Go;
        break;
      case "top":
        ut += Ho - Go;
        break;
      case "hanging":
        ut += Ho - 2 * Go;
        break;
      case "middle":
        ut += Ho / 2 - Go;
    }
    if ((Ie = gt.maxWidth || 0) > 0 && (typeof w == "string" ? w = On.splitTextToSize(w, Ie) : Object.prototype.toString.call(w) === "[object Array]" && (w = w.reduce(function(ln, un) {
      return ln.concat(On.splitTextToSize(un, Ie));
    }, []))), Bt = { text: w, x: D, y: ut, options: gt, mutex: { pdfEscape: Vn, activeFontKey: dt, fonts: Kt, activeFontSize: vt } }, He.publish("preProcessText", Bt), w = Bt.text, ue = (gt = Bt.options).angle, !(xn instanceof xe) && ue && typeof ue == "number") {
      ue *= Math.PI / 180, gt.rotationDirection === 0 && (ue = -ue), k === v.ADVANCED && (ue = -ue);
      var Vo = Math.cos(ue), Xa = Math.sin(ue);
      xn = new xe(Vo, Xa, -Xa, Vo, 0, 0);
    } else ue && ue instanceof xe && (xn = ue);
    k !== v.ADVANCED || xn || (xn = ji), (Oe = gt.charSpace || qo) !== void 0 && (zn += T(A(Oe)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (yn = gt.horizontalScale) !== void 0 && (zn += T(100 * yn) + ` Tz
`), gt.lang;
    var yi = -1, Zc = gt.renderingMode !== void 0 ? gt.renderingMode : gt.stroke, Ja = On.internal.getCurrentPageInfo().pageContext;
    switch (Zc) {
      case 0:
      case !1:
      case "fill":
        yi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        yi = 1;
        break;
      case 2:
      case "fillThenStroke":
        yi = 2;
        break;
      case 3:
      case "invisible":
        yi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        yi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        yi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        yi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        yi = 7;
    }
    var Jl = Ja.usedRenderingMode !== void 0 ? Ja.usedRenderingMode : -1;
    yi !== -1 ? zn += yi + ` Tr
` : Jl !== -1 && (zn += `0 Tr
`), yi !== -1 && (Ja.usedRenderingMode = yi), ye = gt.align || "left";
    var Ui, Yo = vt * Ei, Zl = On.internal.pageSize.getWidth(), Ql = Kt[dt];
    Oe = gt.charSpace || qo, Ie = gt.maxWidth || 0, qe = Object.assign({ autoencode: !0, noBOM: !0 }, gt.flags);
    var gs = [], Js = function(ln) {
      return On.getStringUnitWidth(ln, { font: Ql, charSpace: Oe, fontSize: vt, doKerning: !1 }) * vt / _r;
    };
    if (Object.prototype.toString.call(w) === "[object Array]") {
      var bi;
      Xt = Ga(w), ye !== "left" && (Ui = Xt.map(Js));
      var ci, ms = 0;
      if (ye === "right") {
        D -= Ui[0], w = [], Yn = Xt.length;
        for (var Wr = 0; Wr < Yn; Wr++) Wr === 0 ? (ci = xr(D), bi = Ur(ut)) : (ci = A(ms - Ui[Wr]), bi = -Yo), w.push([Xt[Wr], ci, bi]), ms = Ui[Wr];
      } else if (ye === "center") {
        D -= Ui[0] / 2, w = [], Yn = Xt.length;
        for (var Hr = 0; Hr < Yn; Hr++) Hr === 0 ? (ci = xr(D), bi = Ur(ut)) : (ci = A((ms - Ui[Hr]) / 2), bi = -Yo), w.push([Xt[Hr], ci, bi]), ms = Ui[Hr];
      } else if (ye === "left") {
        w = [], Yn = Xt.length;
        for (var Ko = 0; Ko < Yn; Ko++) w.push(Xt[Ko]);
      } else if (ye === "justify" && Ql.encoding === "Identity-H") {
        w = [], Yn = Xt.length, Ie = Ie !== 0 ? Ie : Zl;
        for (var Gr = 0, kn = 0; kn < Yn; kn++) if (bi = kn === 0 ? Ur(ut) : -Yo, ci = kn === 0 ? xr(D) : Gr, kn < Yn - 1) {
          var Za = A((Ie - Ui[kn]) / (Xt[kn].split(" ").length - 1)), hi = Xt[kn].split(" ");
          w.push([hi[0] + " ", ci, bi]), Gr = 0;
          for (var Wi = 1; Wi < hi.length; Wi++) {
            var Xo = (Js(hi[Wi - 1] + " " + hi[Wi]) - Js(hi[Wi])) * _r + Za;
            Wi == hi.length - 1 ? w.push([hi[Wi], Xo, 0]) : w.push([hi[Wi] + " ", Xo, 0]), Gr -= Xo;
          }
        } else w.push([Xt[kn], ci, bi]);
        w.push(["", Gr, 0]);
      } else {
        if (ye !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (w = [], Yn = Xt.length, Ie = Ie !== 0 ? Ie : Zl, kn = 0; kn < Yn; kn++) bi = kn === 0 ? Ur(ut) : -Yo, ci = kn === 0 ? xr(D) : 0, kn < Yn - 1 ? gs.push(T(A((Ie - Ui[kn]) / (Xt[kn].split(" ").length - 1)))) : gs.push(0), w.push([Xt[kn], ci, bi]);
      }
    }
    var tu = typeof gt.R2L == "boolean" ? gt.R2L : Ot;
    tu === !0 && (w = Va(w, function(ln, un, An) {
      return [ln.split("").reverse().join(""), un, An];
    })), Bt = { text: w, x: D, y: ut, options: gt, mutex: { pdfEscape: Vn, activeFontKey: dt, fonts: Kt, activeFontSize: vt } }, He.publish("postProcessText", Bt), w = Bt.text, rr = Bt.mutex.isHex || !1;
    var Qa = Kt[dt].encoding;
    Qa !== "WinAnsiEncoding" && Qa !== "StandardEncoding" || (w = Va(w, function(ln, un, An) {
      return [Xl(ln), un, An];
    })), Xt = Ga(w), w = [];
    for (var Zs, Qs, ys, to = 0, Jo = 1, eo = Array.isArray(Xt[0]) ? Jo : to, bs = "", tl = function(ln, un, An) {
      var Bn = "";
      return An instanceof xe ? (An = typeof gt.angle == "number" ? Ai(An, new xe(1, 0, 0, 1, ln, un)) : Ai(new xe(1, 0, 0, 1, ln, un), An), k === v.ADVANCED && (An = Ai(new xe(1, 0, 0, -1, 0, 0), An)), Bn = An.join(" ") + ` Tm
`) : Bn = T(ln) + " " + T(un) + ` Td
`, Bn;
    }, Hi = 0; Hi < Xt.length; Hi++) {
      switch (bs = "", eo) {
        case Jo:
          ys = (rr ? "<" : "(") + Xt[Hi][0] + (rr ? ">" : ")"), Zs = parseFloat(Xt[Hi][1]), Qs = parseFloat(Xt[Hi][2]);
          break;
        case to:
          ys = (rr ? "<" : "(") + Xt[Hi] + (rr ? ">" : ")"), Zs = xr(D), Qs = Ur(ut);
      }
      gs !== void 0 && gs[Hi] !== void 0 && (bs = gs[Hi] + ` Tw
`), Hi === 0 ? w.push(bs + tl(Zs, Qs, xn) + ys) : eo === to ? w.push(bs + ys) : eo === Jo && w.push(bs + tl(Zs, Qs, xn) + ys);
    }
    w = eo === to ? w.join(` Tj
T* `) : w.join(` Tj
`), w += ` Tj
`;
    var Gi = `BT
/`;
    return Gi += dt + " " + vt + ` Tf
`, Gi += T(vt * Ei) + ` TL
`, Gi += Ks + `
`, Gi += zn, Gi += w, U(Gi += "ET"), p[dt] = !0, On;
  };
  var Ma = f.__private__.clip = f.clip = function(w) {
    return U(w === "evenodd" ? "W*" : "W"), this;
  };
  f.clipEvenOdd = function() {
    return Ma("evenodd");
  }, f.__private__.discardPath = f.discardPath = function() {
    return U("n"), this;
  };
  var mi = f.__private__.isValidStyle = function(w) {
    var D = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(w) !== -1 && (D = !0), D;
  };
  f.__private__.setDefaultPathOperation = f.setDefaultPathOperation = function(w) {
    return mi(w) && (h = w), this;
  };
  var Hs = f.__private__.getStyle = f.getStyle = function(w) {
    var D = h;
    switch (w) {
      case "D":
      case "S":
        D = "S";
        break;
      case "F":
        D = "f";
        break;
      case "FD":
      case "DF":
        D = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        D = w;
    }
    return D;
  }, Gs = f.close = function() {
    return U("h"), this;
  };
  f.stroke = function() {
    return U("S"), this;
  }, f.fill = function(w) {
    return Bo("f", w), this;
  }, f.fillEvenOdd = function(w) {
    return Bo("f*", w), this;
  }, f.fillStroke = function(w) {
    return Bo("B", w), this;
  }, f.fillStrokeEvenOdd = function(w) {
    return Bo("B*", w), this;
  };
  var Bo = function(w, D) {
    en(D) === "object" ? Hc(D, w) : U(w);
  }, Ra = function(w) {
    w === null || k === v.ADVANCED && w === void 0 || (w = Hs(w), U(w));
  };
  function Wc(w, D, ut, gt, Pt) {
    var Bt = new uo(D || this.boundingBox, ut || this.xStep, gt || this.yStep, this.gState, Pt || this.matrix);
    Bt.stream = this.stream;
    var Xt = w + "$$" + this.cloneIndex++ + "$$";
    return ti(Xt, Bt), Bt;
  }
  var Hc = function(w, D) {
    var ut = Rn[w.key], gt = we[ut];
    if (gt instanceof Is) U("q"), U(Gc(D)), gt.gState && f.setGState(gt.gState), U(w.matrix.toString() + " cm"), U("/" + ut + " sh"), U("Q");
    else if (gt instanceof uo) {
      var Pt = new xe(1, 0, 0, -1, 0, ps());
      w.matrix && (Pt = Pt.multiply(w.matrix || ji), ut = Wc.call(gt, w.key, w.boundingBox, w.xStep, w.yStep, Pt).id), U("q"), U("/Pattern cs"), U("/" + ut + " scn"), gt.gState && f.setGState(gt.gState), U(D), U("Q");
    }
  }, Gc = function(w) {
    switch (w) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Da = f.moveTo = function(w, D) {
    return U(T(A(w)) + " " + T(S(D)) + " m"), this;
  }, Vs = f.lineTo = function(w, D) {
    return U(T(A(w)) + " " + T(S(D)) + " l"), this;
  }, fs = f.curveTo = function(w, D, ut, gt, Pt, Bt) {
    return U([T(A(w)), T(S(D)), T(A(ut)), T(S(gt)), T(A(Pt)), T(S(Bt)), "c"].join(" ")), this;
  };
  f.__private__.line = f.line = function(w, D, ut, gt, Pt) {
    if (isNaN(w) || isNaN(D) || isNaN(ut) || isNaN(gt) || !mi(Pt)) throw new Error("Invalid arguments passed to jsPDF.line");
    return k === v.COMPAT ? this.lines([[ut - w, gt - D]], w, D, [1, 1], Pt || "S") : this.lines([[ut - w, gt - D]], w, D, [1, 1]).stroke();
  }, f.__private__.lines = f.lines = function(w, D, ut, gt, Pt, Bt) {
    var Xt, ue, ye, Oe, Ie, qe, yn, xn, On, ei, zn, rr;
    if (typeof w == "number" && (rr = ut, ut = D, D = w, w = rr), gt = gt || [1, 1], Bt = Bt || !1, isNaN(D) || isNaN(ut) || !Array.isArray(w) || !Array.isArray(gt) || !mi(Pt) || typeof Bt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Da(D, ut), Xt = gt[0], ue = gt[1], Oe = w.length, ei = D, zn = ut, ye = 0; ye < Oe; ye++) (Ie = w[ye]).length === 2 ? (ei = Ie[0] * Xt + ei, zn = Ie[1] * ue + zn, Vs(ei, zn)) : (qe = Ie[0] * Xt + ei, yn = Ie[1] * ue + zn, xn = Ie[2] * Xt + ei, On = Ie[3] * ue + zn, ei = Ie[4] * Xt + ei, zn = Ie[5] * ue + zn, fs(qe, yn, xn, On, ei, zn));
    return Bt && Gs(), Ra(Pt), this;
  }, f.path = function(w) {
    for (var D = 0; D < w.length; D++) {
      var ut = w[D], gt = ut.c;
      switch (ut.op) {
        case "m":
          Da(gt[0], gt[1]);
          break;
        case "l":
          Vs(gt[0], gt[1]);
          break;
        case "c":
          fs.apply(this, gt);
          break;
        case "h":
          Gs();
      }
    }
    return this;
  }, f.__private__.rect = f.rect = function(w, D, ut, gt, Pt) {
    if (isNaN(w) || isNaN(D) || isNaN(ut) || isNaN(gt) || !mi(Pt)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return k === v.COMPAT && (gt = -gt), U([T(A(w)), T(S(D)), T(A(ut)), T(A(gt)), "re"].join(" ")), Ra(Pt), this;
  }, f.__private__.triangle = f.triangle = function(w, D, ut, gt, Pt, Bt, Xt) {
    if (isNaN(w) || isNaN(D) || isNaN(ut) || isNaN(gt) || isNaN(Pt) || isNaN(Bt) || !mi(Xt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[ut - w, gt - D], [Pt - ut, Bt - gt], [w - Pt, D - Bt]], w, D, [1, 1], Xt, !0), this;
  }, f.__private__.roundedRect = f.roundedRect = function(w, D, ut, gt, Pt, Bt, Xt) {
    if (isNaN(w) || isNaN(D) || isNaN(ut) || isNaN(gt) || isNaN(Pt) || isNaN(Bt) || !mi(Xt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var ue = 4 / 3 * (Math.SQRT2 - 1);
    return Pt = Math.min(Pt, 0.5 * ut), Bt = Math.min(Bt, 0.5 * gt), this.lines([[ut - 2 * Pt, 0], [Pt * ue, 0, Pt, Bt - Bt * ue, Pt, Bt], [0, gt - 2 * Bt], [0, Bt * ue, -Pt * ue, Bt, -Pt, Bt], [2 * Pt - ut, 0], [-Pt * ue, 0, -Pt, -Bt * ue, -Pt, -Bt], [0, 2 * Bt - gt], [0, -Bt * ue, Pt * ue, -Bt, Pt, -Bt]], w + Pt, D, [1, 1], Xt, !0), this;
  }, f.__private__.ellipse = f.ellipse = function(w, D, ut, gt, Pt) {
    if (isNaN(w) || isNaN(D) || isNaN(ut) || isNaN(gt) || !mi(Pt)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Bt = 4 / 3 * (Math.SQRT2 - 1) * ut, Xt = 4 / 3 * (Math.SQRT2 - 1) * gt;
    return Da(w + ut, D), fs(w + ut, D - Xt, w + Bt, D - gt, w, D - gt), fs(w - Bt, D - gt, w - ut, D - Xt, w - ut, D), fs(w - ut, D + Xt, w - Bt, D + gt, w, D + gt), fs(w + Bt, D + gt, w + ut, D + Xt, w + ut, D), Ra(Pt), this;
  }, f.__private__.circle = f.circle = function(w, D, ut, gt) {
    if (isNaN(w) || isNaN(D) || isNaN(ut) || !mi(gt)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(w, D, ut, ut, gt);
  }, f.setFont = function(w, D, ut) {
    return ut && (D = q(D, ut)), dt = Do(w, D, { disableWarning: !1 }), this;
  };
  var Vc = f.__private__.getFont = f.getFont = function() {
    return Kt[Do.apply(f, arguments)];
  };
  f.__private__.getFontList = f.getFontList = function() {
    var w, D, ut = {};
    for (w in jt) if (jt.hasOwnProperty(w)) for (D in ut[w] = [], jt[w]) jt[w].hasOwnProperty(D) && ut[w].push(D);
    return ut;
  }, f.addFont = function(w, D, ut, gt, Pt) {
    var Bt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Bt.indexOf(arguments[3]) !== -1 ? Pt = arguments[3] : arguments[3] && Bt.indexOf(arguments[3]) == -1 && (ut = q(ut, gt)), Pt = Pt || "Identity-H", Ws.call(this, w, D, ut, Pt);
  };
  var Ys, Ba = n.lineWidth || 0.200025, jo = f.__private__.getLineWidth = f.getLineWidth = function() {
    return Ba;
  }, Wl = f.__private__.setLineWidth = f.setLineWidth = function(w) {
    return Ba = w, U(T(A(w)) + " w"), this;
  };
  f.__private__.setLineDash = Se.API.setLineDash = Se.API.setLineDashPattern = function(w, D) {
    if (w = w || [], D = D || 0, isNaN(D) || !Array.isArray(w)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return w = w.map(function(ut) {
      return T(A(ut));
    }).join(" "), D = T(A(D)), U("[" + w + "] " + D + " d"), this;
  };
  var Hl = f.__private__.getLineHeight = f.getLineHeight = function() {
    return vt * Ys;
  };
  f.__private__.getLineHeight = f.getLineHeight = function() {
    return vt * Ys;
  };
  var Gl = f.__private__.setLineHeightFactor = f.setLineHeightFactor = function(w) {
    return typeof (w = w || 1.15) == "number" && (Ys = w), this;
  }, Vl = f.__private__.getLineHeightFactor = f.getLineHeightFactor = function() {
    return Ys;
  };
  Gl(n.lineHeight);
  var xr = f.__private__.getHorizontalCoordinate = function(w) {
    return A(w);
  }, Ur = f.__private__.getVerticalCoordinate = function(w) {
    return k === v.ADVANCED ? w : ke[z].mediaBox.topRightY - ke[z].mediaBox.bottomLeftY - A(w);
  }, Yc = f.__private__.getHorizontalCoordinateString = f.getHorizontalCoordinateString = function(w) {
    return T(xr(w));
  }, ds = f.__private__.getVerticalCoordinateString = f.getVerticalCoordinateString = function(w) {
    return T(Ur(w));
  }, ir = n.strokeColor || "0 G";
  f.__private__.getStrokeColor = f.getDrawColor = function() {
    return Ni(ir);
  }, f.__private__.setStrokeColor = f.setDrawColor = function(w, D, ut, gt) {
    return ir = Ci({ ch1: w, ch2: D, ch3: ut, ch4: gt, pdfColorType: "draw", precision: 2 }), U(ir), this;
  };
  var ja = n.fillColor || "0 g";
  f.__private__.getFillColor = f.getFillColor = function() {
    return Ni(ja);
  }, f.__private__.setFillColor = f.setFillColor = function(w, D, ut, gt) {
    return ja = Ci({ ch1: w, ch2: D, ch3: ut, ch4: gt, pdfColorType: "fill", precision: 2 }), U(ja), this;
  };
  var Ks = n.textColor || "0 g", Kc = f.__private__.getTextColor = f.getTextColor = function() {
    return Ni(Ks);
  };
  f.__private__.setTextColor = f.setTextColor = function(w, D, ut, gt) {
    return Ks = Ci({ ch1: w, ch2: D, ch3: ut, ch4: gt, pdfColorType: "text", precision: 3 }), this;
  };
  var qo = n.charSpace, Xc = f.__private__.getCharSpace = f.getCharSpace = function() {
    return parseFloat(qo || 0);
  };
  f.__private__.setCharSpace = f.setCharSpace = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return qo = w, this;
  };
  var qa = 0;
  f.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, f.__private__.setLineCap = f.setLineCap = function(w) {
    var D = f.CapJoinStyles[w];
    if (D === void 0) throw new Error("Line cap style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return qa = D, U(D + " J"), this;
  };
  var za = 0;
  f.__private__.setLineJoin = f.setLineJoin = function(w) {
    var D = f.CapJoinStyles[w];
    if (D === void 0) throw new Error("Line join style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return za = D, U(D + " j"), this;
  }, f.__private__.setLineMiterLimit = f.__private__.setMiterLimit = f.setLineMiterLimit = f.setMiterLimit = function(w) {
    if (w = w || 0, isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return U(T(A(w)) + " M"), this;
  }, f.GState = Ll, f.setGState = function(w) {
    (w = typeof w == "string" ? Ze[Dn[w]] : Yl(null, w)).equals(fn) || (U("/" + w.id + " gs"), fn = w);
  };
  var Yl = function(w, D) {
    if (!w || !Dn[w]) {
      var ut = !1;
      for (var gt in Ze) if (Ze.hasOwnProperty(gt) && Ze[gt].equals(D)) {
        ut = !0;
        break;
      }
      if (ut) D = Ze[gt];
      else {
        var Pt = "GS" + (Object.keys(Ze).length + 1).toString(10);
        Ze[Pt] = D, D.id = Pt;
      }
      return w && (Dn[w] = D.id), He.publish("addGState", D), D;
    }
  };
  f.addGState = function(w, D) {
    return Yl(w, D), this;
  }, f.saveGraphicsState = function() {
    return U("q"), ge.push({ key: dt, size: vt, color: Ks }), this;
  }, f.restoreGraphicsState = function() {
    U("Q");
    var w = ge.pop();
    return dt = w.key, vt = w.size, Ks = w.color, fn = null, this;
  }, f.setCurrentTransformationMatrix = function(w) {
    return U(w.toString() + " cm"), this;
  }, f.comment = function(w) {
    return U("#" + w), this;
  };
  var zo = function(w, D) {
    var ut = w || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return ut;
    }, set: function(Bt) {
      isNaN(Bt) || (ut = parseFloat(Bt));
    } });
    var gt = D || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return gt;
    }, set: function(Bt) {
      isNaN(Bt) || (gt = parseFloat(Bt));
    } });
    var Pt = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Pt;
    }, set: function(Bt) {
      Pt = Bt.toString();
    } }), this;
  }, $a = function(w, D, ut, gt) {
    zo.call(this, w, D), this.type = "rect";
    var Pt = ut || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Pt;
    }, set: function(Xt) {
      isNaN(Xt) || (Pt = parseFloat(Xt));
    } });
    var Bt = gt || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Bt;
    }, set: function(Xt) {
      isNaN(Xt) || (Bt = parseFloat(Xt));
    } }), this;
  }, Ua = function() {
    this.page = We, this.currentPage = z, this.pages = Dt.slice(0), this.pagesContext = ke.slice(0), this.x = te, this.y = Rt, this.matrix = be, this.width = Xs(z), this.height = ps(z), this.outputDestination = Qt, this.id = "", this.objectNumber = -1;
  };
  Ua.prototype.restore = function() {
    We = this.page, z = this.currentPage, ke = this.pagesContext, Dt = this.pages, te = this.x, Rt = this.y, be = this.matrix, Wa(z, this.width), Ha(z, this.height), Qt = this.outputDestination;
  };
  var Kl = function(w, D, ut, gt, Pt) {
    mn.push(new Ua()), We = z = 0, Dt = [], te = w, Rt = D, be = Pt, hs([ut, gt]);
  }, Jc = function(w) {
    if (Bi[w]) mn.pop().restore();
    else {
      var D = new Ua(), ut = "Xo" + (Object.keys(En).length + 1).toString(10);
      D.id = ut, Bi[w] = ut, En[ut] = D, He.publish("addFormObject", D), mn.pop().restore();
    }
  };
  for (var $o in f.beginFormObject = function(w, D, ut, gt, Pt) {
    return Kl(w, D, ut, gt, Pt), this;
  }, f.endFormObject = function(w) {
    return Jc(w), this;
  }, f.doFormObject = function(w, D) {
    var ut = En[Bi[w]];
    return U("q"), U(D.toString() + " cm"), U("/" + ut.id + " Do"), U("Q"), this;
  }, f.getFormObject = function(w) {
    var D = En[Bi[w]];
    return { x: D.x, y: D.y, width: D.width, height: D.height, matrix: D.matrix };
  }, f.save = function(w, D) {
    return w = w || "generated.pdf", (D = D || {}).returnPromise = D.returnPromise || !1, D.returnPromise === !1 ? (ro(le(fe()), w), typeof ro.unload == "function" && Ce.setTimeout && setTimeout(ro.unload, 911), this) : new Promise(function(ut, gt) {
      try {
        var Pt = ro(le(fe()), w);
        typeof ro.unload == "function" && Ce.setTimeout && setTimeout(ro.unload, 911), ut(Pt);
      } catch (Bt) {
        gt(Bt.message);
      }
    });
  }, Se.API) Se.API.hasOwnProperty($o) && ($o === "events" && Se.API.events.length ? function(w, D) {
    var ut, gt, Pt;
    for (Pt = D.length - 1; Pt !== -1; Pt--) ut = D[Pt][0], gt = D[Pt][1], w.subscribe.apply(w, [ut].concat(typeof gt == "function" ? [gt] : gt));
  }(He, Se.API.events) : f[$o] = Se.API[$o]);
  var Xs = f.getPageWidth = function(w) {
    return (ke[w = w || z].mediaBox.topRightX - ke[w].mediaBox.bottomLeftX) / kt;
  }, Wa = f.setPageWidth = function(w, D) {
    ke[w].mediaBox.topRightX = D * kt + ke[w].mediaBox.bottomLeftX;
  }, ps = f.getPageHeight = function(w) {
    return (ke[w = w || z].mediaBox.topRightY - ke[w].mediaBox.bottomLeftY) / kt;
  }, Ha = f.setPageHeight = function(w, D) {
    ke[w].mediaBox.topRightY = D * kt + ke[w].mediaBox.bottomLeftY;
  };
  return f.internal = { pdfEscape: Vn, getStyle: Hs, getFont: Vc, getFontSize: ht, getCharSpace: Xc, getTextColor: Kc, getLineHeight: Hl, getLineHeightFactor: Vl, getLineWidth: jo, write: et, getHorizontalCoordinate: xr, getVerticalCoordinate: Ur, getCoordinateString: Yc, getVerticalCoordinateString: ds, collections: {}, newObject: vn, newAdditionalObject: ss, newObjectDeferred: wn, newObjectDeferredBegin: ui, getFilters: qi, putStream: Pi, events: He, scaleFactor: kt, pageSize: { getWidth: function() {
    return Xs(z);
  }, setWidth: function(w) {
    Wa(z, w);
  }, getHeight: function() {
    return ps(z);
  }, setHeight: function(w) {
    Ha(z, w);
  } }, encryptionOptions: u, encryption: Me, getEncryptor: Le, output: ve, getNumberOfPages: Fa, pages: Dt, out: U, f2: B, f3: P, getPageInfo: je, getPageInfoByObjId: Zt, getCurrentPageInfo: Ii, getPDFVersion: b, Point: zo, Rectangle: $a, Matrix: xe, hasHotfix: Ge }, Object.defineProperty(f.internal.pageSize, "width", { get: function() {
    return Xs(z);
  }, set: function(w) {
    Wa(z, w);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(f.internal.pageSize, "height", { get: function() {
    return ps(z);
  }, set: function(w) {
    Ha(z, w);
  }, enumerable: !0, configurable: !0 }), $i.call(f, rt), dt = "F1", $r(r, e), He.publish("initialized"), f;
}
da.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, da.prototype.toHexString = function(n) {
  return n.split("").map(function(t) {
    return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, da.prototype.hexToBytes = function(n) {
  for (var t = [], e = 0; e < n.length; e += 2) t.push(String.fromCharCode(parseInt(n.substr(e, 2), 16)));
  return t.join("");
}, da.prototype.processOwnerPassword = function(n, t) {
  return pf(df(t).substr(0, 5), n);
}, da.prototype.encryptor = function(n, t) {
  var e = df(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & t, t >> 8 & 255)).substr(0, 10);
  return function(i) {
    return pf(e, i);
  };
}, Ll.prototype.equals = function(n) {
  var t, e = "id,objectNumber,equals";
  if (!n || en(n) !== en(this)) return !1;
  var i = 0;
  for (t in this) if (!(e.indexOf(t) >= 0)) {
    if (this.hasOwnProperty(t) && !n.hasOwnProperty(t) || this[t] !== n[t]) return !1;
    i++;
  }
  for (t in n) n.hasOwnProperty(t) && e.indexOf(t) < 0 && i--;
  return i === 0;
}, Se.API = { events: [] }, Se.version = "2.5.2";
var Sn = Se.API, kd = 1, Po = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, ia = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Ee = function(n) {
  return n.toFixed(2);
}, Ps = function(n) {
  return n.toFixed(5);
};
Sn.__acroform__ = {};
var ki = function(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n;
}, Jp = function(n) {
  return n * kd;
}, Cr = function(n) {
  var t = new O1(), e = de.internal.getHeight(n) || 0, i = de.internal.getWidth(n) || 0;
  return t.BBox = [0, 0, Number(Ee(i)), Number(Ee(e))], t;
}, vv = Sn.__acroform__.setBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << t;
}, wv = Sn.__acroform__.clearBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << t);
}, xv = Sn.__acroform__.getBit = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << t ? 1 : 0;
}, Pn = Sn.__acroform__.getBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return xv(n, t - 1);
}, Ln = Sn.__acroform__.setBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return vv(n, t - 1);
}, In = Sn.__acroform__.clearBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return wv(n, t - 1);
}, _v = Sn.__acroform__.calculateCoordinates = function(n, t) {
  var e = t.internal.getHorizontalCoordinate, i = t.internal.getVerticalCoordinate, r = n[0], s = n[1], o = n[2], a = n[3], l = {};
  return l.lowerLeft_X = e(r) || 0, l.lowerLeft_Y = i(s + a) || 0, l.upperRight_X = e(r + o) || 0, l.upperRight_Y = i(s) || 0, [Number(Ee(l.lowerLeft_X)), Number(Ee(l.lowerLeft_Y)), Number(Ee(l.upperRight_X)), Number(Ee(l.upperRight_Y))];
}, Sv = function(n) {
  if (n.appearanceStreamContent) return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var t = [], e = n._V || n.DV, i = gf(n, e), r = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    t.push("/Tx BMC"), t.push("q"), t.push("BT"), t.push(n.scope.__private__.encodeColorString(n.color)), t.push("/" + r + " " + Ee(i.fontSize) + " Tf"), t.push("1 0 0 1 0 0 Tm"), t.push(i.text), t.push("ET"), t.push("Q"), t.push("EMC");
    var s = Cr(n);
    return s.scope = n.scope, s.stream = t.join(`
`), s;
  }
}, gf = function(n, t) {
  var e = n.fontSize === 0 ? n.maxFontSize : n.fontSize, i = { text: "", fontSize: "" }, r = (t = (t = t.substr(0, 1) == "(" ? t.substr(1) : t).substr(t.length - 1) == ")" ? t.substr(0, t.length - 1) : t).split(" ");
  r = n.multiline ? r.map(function(P) {
    return P.split(`
`);
  }) : r.map(function(P) {
    return [P];
  });
  var s = e, o = de.internal.getHeight(n) || 0;
  o = o < 0 ? -o : o;
  var a = de.internal.getWidth(n) || 0;
  a = a < 0 ? -a : a;
  var l = function(P, A, I) {
    if (P + 1 < r.length) {
      var S = A + " " + r[P + 1][0];
      return Cu(S, n, I).width <= a - 4;
    }
    return !1;
  };
  s++;
  t: for (; s > 0; ) {
    t = "", s--;
    var h, u, d = Cu("3", n, s).height, p = n.multiline ? o - s : (o - d) / 2, f = p += 2, m = 0, b = 0, x = 0;
    if (s <= 0) {
      t = `(...) Tj
`, t += "% Width of Text: " + Cu(t, n, s = 12).width + ", FieldWidth:" + a + `
`;
      break;
    }
    for (var y = "", v = 0, k = 0; k < r.length; k++) if (r.hasOwnProperty(k)) {
      var C = !1;
      if (r[k].length !== 1 && x !== r[k].length - 1) {
        if ((d + 2) * (v + 2) + 2 > o) continue t;
        y += r[k][x], C = !0, b = k, k--;
      } else {
        y = (y += r[k][x] + " ").substr(y.length - 1) == " " ? y.substr(0, y.length - 1) : y;
        var E = parseInt(k), q = l(E, y, s), T = k >= r.length - 1;
        if (q && !T) {
          y += " ", x = 0;
          continue;
        }
        if (q || T) {
          if (T) b = E;
          else if (n.multiline && (d + 2) * (v + 2) + 2 > o) continue t;
        } else {
          if (!n.multiline || (d + 2) * (v + 2) + 2 > o) continue t;
          b = E;
        }
      }
      for (var F = "", M = m; M <= b; M++) {
        var B = r[M];
        if (n.multiline) {
          if (M === b) {
            F += B[x] + " ", x = (x + 1) % B.length;
            continue;
          }
          if (M === m) {
            F += B[B.length - 1] + " ";
            continue;
          }
        }
        F += B[0] + " ";
      }
      switch (F = F.substr(F.length - 1) == " " ? F.substr(0, F.length - 1) : F, u = Cu(F, n, s).width, n.textAlign) {
        case "right":
          h = a - u - 2;
          break;
        case "center":
          h = (a - u) / 2;
          break;
        case "left":
        default:
          h = 2;
      }
      t += Ee(h) + " " + Ee(f) + ` Td
`, t += "(" + Po(F) + `) Tj
`, t += -Ee(h) + ` 0 Td
`, f = -(s + 2), u = 0, m = C ? b : b + 1, v++, y = "";
    }
    break;
  }
  return i.text = t, i.fontSize = s, i;
}, Cu = function(n, t, e) {
  var i = t.scope.internal.getFont(t.fontName, t.fontStyle), r = t.scope.getStringUnitWidth(n, { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e);
  return { height: t.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e) * 1.5, width: r };
}, kv = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Av = function(n, t) {
  var e = { type: "reference", object: n };
  t.internal.getPageInfo(n.page).pageContext.annotations.find(function(i) {
    return i.type === e.type && i.object === e.object;
  }) === void 0 && t.internal.getPageInfo(n.page).pageContext.annotations.push(e);
}, Nv = function(n, t) {
  for (var e in n) if (n.hasOwnProperty(e)) {
    var i = e, r = n[e];
    t.internal.newObjectDeferredBegin(r.objId, !0), en(r) === "object" && typeof r.putStream == "function" && r.putStream(), delete n[i];
  }
}, Cv = function(n, t) {
  if (t.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (br.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(kv)), n.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    kd = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new T1(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(e) {
        e.internal.events.unsubscribe(e.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete e.internal.acroformPlugin.acroFormDictionaryRoot._eventID, e.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(e) {
        e.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = e.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r in i) if (i.hasOwnProperty(r)) {
          var s = i[r];
          s.objId = void 0, s.hasAnnotation && Av(s, e);
        }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(e) {
        if (e.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        e.internal.write("/AcroForm " + e.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(e) {
      (function(i, r) {
        var s = !i;
        for (var o in i || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (i.hasOwnProperty(o)) {
          var a = i[o], l = [], h = a.Rect;
          if (a.Rect && (a.Rect = _v(a.Rect, r)), r.internal.newObjectDeferredBegin(a.objId, !0), a.DA = de.createDefaultAppearanceStream(a), en(a) === "object" && typeof a.getKeyValueListForStream == "function" && (l = a.getKeyValueListForStream()), a.Rect = h, a.hasAppearanceStream && !a.appearanceStreamContent) {
            var u = Sv(a);
            l.push({ key: "AP", value: "<</N " + u + ">>" }), r.internal.acroformPlugin.xForms.push(u);
          }
          if (a.appearanceStreamContent) {
            var d = "";
            for (var p in a.appearanceStreamContent) if (a.appearanceStreamContent.hasOwnProperty(p)) {
              var f = a.appearanceStreamContent[p];
              if (d += "/" + p + " ", d += "<<", Object.keys(f).length >= 1 || Array.isArray(f)) {
                for (var o in f) if (f.hasOwnProperty(o)) {
                  var m = f[o];
                  typeof m == "function" && (m = m.call(r, a)), d += "/" + o + " " + m + " ", r.internal.acroformPlugin.xForms.indexOf(m) >= 0 || r.internal.acroformPlugin.xForms.push(m);
                }
              } else typeof (m = f) == "function" && (m = m.call(r, a)), d += "/" + o + " " + m, r.internal.acroformPlugin.xForms.indexOf(m) >= 0 || r.internal.acroformPlugin.xForms.push(m);
              d += ">>";
            }
            l.push({ key: "AP", value: `<<
` + d + ">>" });
          }
          r.internal.putStream({ additionalKeyValues: l, objectId: a.objId }), r.internal.out("endobj");
        }
        s && Nv(r.internal.acroformPlugin.xForms, r);
      })(e, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, E1 = Sn.__acroform__.arrayToPdfArray = function(n, t, e) {
  var i = function(o) {
    return o;
  };
  if (Array.isArray(n)) {
    for (var r = "[", s = 0; s < n.length; s++) switch (s !== 0 && (r += " "), en(n[s])) {
      case "boolean":
      case "number":
      case "object":
        r += n[s].toString();
        break;
      case "string":
        n[s].substr(0, 1) !== "/" ? (t !== void 0 && e && (i = e.internal.getEncryptor(t)), r += "(" + Po(i(n[s].toString())) + ")") : r += n[s].toString();
    }
    return r += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Ph = function(n, t, e) {
  var i = function(r) {
    return r;
  };
  return t !== void 0 && e && (i = e.internal.getEncryptor(t)), (n = n || "").toString(), n = "(" + Po(i(n)) + ")";
}, Ir = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Ir.prototype.toString = function() {
  return this.objId + " 0 R";
}, Ir.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, Ir.prototype.getKeyValueListForStream = function() {
  var n = [], t = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var e in t) if (Object.getOwnPropertyDescriptor(this, t[e]).configurable === !1) {
    var i = t[e], r = this[i];
    r && (Array.isArray(r) ? n.push({ key: i, value: E1(r, this.objId, this.scope) }) : r instanceof Ir ? (r.scope = this.scope, n.push({ key: i, value: r.objId + " 0 R" })) : typeof r != "function" && n.push({ key: i, value: r }));
  }
  return n;
};
var O1 = function() {
  Ir.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, t = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return t;
  }, set: function(e) {
    t = e;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(e) {
    n = e.trim();
  }, get: function() {
    return n || null;
  } });
};
ki(O1, Ir);
var T1 = function() {
  Ir.call(this);
  var n, t = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return t.length > 0 ? t : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return t;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var e = function(i) {
        return i;
      };
      return this.scope && (e = this.scope.internal.getEncryptor(this.objId)), "(" + Po(e(n)) + ")";
    }
  }, set: function(e) {
    n = e;
  } });
};
ki(T1, Ir);
var br = function n() {
  Ir.call(this);
  var t = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(y) {
    if (isNaN(y)) throw new Error('Invalid value "' + y + '" for attribute F supplied.');
    t = y;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(t, 3);
  }, set: function(y) {
    y ? this.F = Ln(t, 3) : this.F = In(t, 3);
  } });
  var e = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(y) {
    if (isNaN(y)) throw new Error('Invalid value "' + y + '" for attribute Ff supplied.');
    e = y;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0) return i;
  }, set: function(y) {
    i = y !== void 0 ? y : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(y) {
    i[0] = y;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(y) {
    i[1] = y;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(y) {
    i[2] = y;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(y) {
    i[3] = y;
  } });
  var r = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(y) {
    switch (y) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        r = y;
        break;
      default:
        throw new Error('Invalid value "' + y + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof lc) return;
      s = "FieldObject" + n.FieldNum++;
    }
    var y = function(v) {
      return v;
    };
    return this.scope && (y = this.scope.internal.getEncryptor(this.objId)), "(" + Po(y(s)) + ")";
  }, set: function(y) {
    s = y.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(y) {
    s = y;
  } });
  var o = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(y) {
    o = y;
  } });
  var a = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(y) {
    a = y;
  } });
  var l = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(y) {
    l = y;
  } });
  var h = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return h === void 0 ? 50 / kd : h;
  }, set: function(y) {
    h = y;
  } });
  var u = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return u;
  }, set: function(y) {
    u = y;
  } });
  var d = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!d || this instanceof lc || this instanceof Rs)) return Ph(d, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), d = y;
  } });
  var p = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (p) return this instanceof qn ? p : Ph(p, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), p = this instanceof qn ? y : y.substr(0, 1) === "(" ? ia(y.substr(1, y.length - 2)) : ia(y);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof qn ? ia(p.substr(1, p.length - 1)) : p;
  }, set: function(y) {
    y = y.toString(), p = this instanceof qn ? "/" + y : y;
  } });
  var f = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return f;
  }, set: function(y) {
    this.V = y;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return this instanceof qn ? f : Ph(f, this.objId, this.scope);
  }, set: function(y) {
    y = y.toString(), f = this instanceof qn ? y : y.substr(0, 1) === "(" ? ia(y.substr(1, y.length - 2)) : ia(y);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof qn ? ia(f.substr(1, f.length - 1)) : f;
  }, set: function(y) {
    y = y.toString(), f = this instanceof qn ? "/" + y : y;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var m, b = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(y) {
    y = !!y, b = y;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (m) return m;
  }, set: function(y) {
    m = y;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 1);
  }, set: function(y) {
    y ? this.Ff = Ln(this.Ff, 1) : this.Ff = In(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 2);
  }, set: function(y) {
    y ? this.Ff = Ln(this.Ff, 2) : this.Ff = In(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 3);
  }, set: function(y) {
    y ? this.Ff = Ln(this.Ff, 3) : this.Ff = In(this.Ff, 3);
  } });
  var x = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (x !== null) return x;
  }, set: function(y) {
    if ([0, 1, 2].indexOf(y) === -1) throw new Error('Invalid value "' + y + '" for attribute Q supplied.');
    x = y;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var y;
    switch (x) {
      case 0:
      default:
        y = "left";
        break;
      case 1:
        y = "center";
        break;
      case 2:
        y = "right";
    }
    return y;
  }, configurable: !0, enumerable: !0, set: function(y) {
    switch (y) {
      case "right":
      case 2:
        x = 2;
        break;
      case "center":
      case 1:
        x = 1;
        break;
      case "left":
      case 0:
      default:
        x = 0;
    }
  } });
};
ki(br, Ir);
var po = function() {
  br.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } });
  var t = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return E1(t, this.objId, this.scope);
  }, set: function(e) {
    var i, r;
    r = [], typeof (i = e) == "string" && (r = function(s, o, a) {
      a || (a = 1);
      for (var l, h = []; l = o.exec(s); ) h.push(l[a]);
      return h;
    }(i, /\((.*?)\)/g)), t = r;
  } }), this.getOptions = function() {
    return t;
  }, this.setOptions = function(e) {
    t = e, this.sort && t.sort();
  }, this.addOption = function(e) {
    e = (e = e || "").toString(), t.push(e), this.sort && t.sort();
  }, this.removeOption = function(e, i) {
    for (i = i || !1, e = (e = e || "").toString(); t.indexOf(e) !== -1 && (t.splice(t.indexOf(e), 1), i !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 18);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 18) : this.Ff = In(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 19);
  }, set: function(e) {
    this.combo === !0 && (e ? this.Ff = Ln(this.Ff, 19) : this.Ff = In(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 20);
  }, set: function(e) {
    e ? (this.Ff = Ln(this.Ff, 20), t.sort()) : this.Ff = In(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 22);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 22) : this.Ff = In(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 23) : this.Ff = In(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 27);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 27) : this.Ff = In(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
ki(po, br);
var go = function() {
  po.call(this), this.fontName = "helvetica", this.combo = !1;
};
ki(go, po);
var mo = function() {
  go.call(this), this.combo = !0;
};
ki(mo, go);
var kl = function() {
  mo.call(this), this.edit = !0;
};
ki(kl, mo);
var qn = function() {
  br.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 15);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 15) : this.Ff = In(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 16);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 16) : this.Ff = In(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 17);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 17) : this.Ff = In(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Ln(this.Ff, 26) : this.Ff = In(this.Ff, 26);
  } });
  var n, t = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var e = function(s) {
      return s;
    };
    if (this.scope && (e = this.scope.internal.getEncryptor(this.objId)), Object.keys(t).length !== 0) {
      var i, r = [];
      for (i in r.push("<<"), t) r.push("/" + i + " (" + Po(e(t[i])) + ")");
      return r.push(">>"), r.join(`
`);
    }
  }, set: function(e) {
    en(e) === "object" && (t = e);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return t.CA || "";
  }, set: function(e) {
    typeof e == "string" && (t.CA = e);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(e) {
    n = "/" + e;
  } });
};
ki(qn, br);
var Al = function() {
  qn.call(this), this.pushButton = !0;
};
ki(Al, qn);
var yo = function() {
  qn.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t !== void 0 ? t : [];
  } });
};
ki(yo, qn);
var lc = function() {
  var n, t;
  br.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(r) {
    n = r;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return t;
  }, set: function(r) {
    t = r;
  } });
  var e, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var r = function(a) {
      return a;
    };
    this.scope && (r = this.scope.internal.getEncryptor(this.objId));
    var s, o = [];
    for (s in o.push("<<"), i) o.push("/" + s + " (" + Po(r(i[s])) + ")");
    return o.push(">>"), o.join(`
`);
  }, set: function(r) {
    en(r) === "object" && (i = r);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(r) {
    typeof r == "string" && (i.CA = r);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(r) {
    e = r;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(r) {
    e = "/" + r;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = de.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
ki(lc, br), yo.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var t in this.Kids) if (this.Kids.hasOwnProperty(t)) {
    var e = this.Kids[t];
    e.appearanceStreamContent = n.createAppearanceStream(e.optionName), e.caption = n.getCA();
  }
}, yo.prototype.createOption = function(n) {
  var t = new lc();
  return t.Parent = this, t.optionName = n, this.Kids.push(t), Pv.call(this.scope, t), t;
};
var Nl = function() {
  qn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = de.CheckBox.createAppearanceStream();
};
ki(Nl, qn);
var Rs = function() {
  br.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 13);
  }, set: function(t) {
    t ? this.Ff = Ln(this.Ff, 13) : this.Ff = In(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 21);
  }, set: function(t) {
    t ? this.Ff = Ln(this.Ff, 21) : this.Ff = In(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Ln(this.Ff, 23) : this.Ff = In(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 24);
  }, set: function(t) {
    t ? this.Ff = Ln(this.Ff, 24) : this.Ff = In(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 25);
  }, set: function(t) {
    t ? this.Ff = Ln(this.Ff, 25) : this.Ff = In(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Ln(this.Ff, 26) : this.Ff = In(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    Number.isInteger(t) && (n = t);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
ki(Rs, br);
var Cl = function() {
  Rs.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Pn(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = Ln(this.Ff, 14) : this.Ff = In(this.Ff, 14);
  } }), this.password = !0;
};
ki(Cl, Rs);
var de = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: de.CheckBox.YesNormal }, D: { On: de.CheckBox.YesPushDown, Off: de.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), s = gf(n, n.caption);
  return e.push("0.749023 g"), e.push("0 0 " + Ee(de.internal.getWidth(n)) + " " + Ee(de.internal.getHeight(n)) + " re"), e.push("f"), e.push("BMC"), e.push("q"), e.push("0 0 1 rg"), e.push("/" + i + " " + Ee(s.fontSize) + " Tf " + r), e.push("BT"), e.push(s.text), e.push("ET"), e.push("Q"), e.push("EMC"), t.stream = e.join(`
`), t;
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), r = [], s = de.internal.getHeight(n), o = de.internal.getWidth(n), a = gf(n, n.caption);
  return r.push("1 g"), r.push("0 0 " + Ee(o) + " " + Ee(s) + " re"), r.push("f"), r.push("q"), r.push("0 0 1 rg"), r.push("0 0 " + Ee(o - 1) + " " + Ee(s - 1) + " re"), r.push("W"), r.push("n"), r.push("0 g"), r.push("BT"), r.push("/" + e + " " + Ee(a.fontSize) + " Tf " + i), r.push(a.text), r.push("ET"), r.push("Q"), t.stream = r.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Ee(de.internal.getWidth(n)) + " " + Ee(de.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var t = { D: { Off: de.RadioButton.Circle.OffPushDown }, N: {} };
  return t.N[n] = de.RadioButton.Circle.YesNormal, t.D[n] = de.RadioButton.Circle.YesPushDown, t;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = de.internal.getWidth(n) <= de.internal.getHeight(n) ? de.internal.getWidth(n) / 4 : de.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = de.internal.Bezier_C, s = Number((i * r).toFixed(5));
  return e.push("q"), e.push("1 0 0 1 " + Ps(de.internal.getWidth(n) / 2) + " " + Ps(de.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), e.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), e.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), e.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = de.internal.getWidth(n) <= de.internal.getHeight(n) ? de.internal.getWidth(n) / 4 : de.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * de.internal.Bezier_C).toFixed(5)), o = Number((i * de.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Ps(de.internal.getWidth(n) / 2) + " " + Ps(de.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), e.push("0 g"), e.push("q"), e.push("1 0 0 1 " + Ps(de.internal.getWidth(n) / 2) + " " + Ps(de.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), e.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), e.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), e.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = de.internal.getWidth(n) <= de.internal.getHeight(n) ? de.internal.getWidth(n) / 4 : de.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * de.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Ps(de.internal.getWidth(n) / 2) + " " + Ps(de.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
} }, Cross: { createAppearanceStream: function(n) {
  var t = { D: { Off: de.RadioButton.Cross.OffPushDown }, N: {} };
  return t.N[n] = de.RadioButton.Cross.YesNormal, t.D[n] = de.RadioButton.Cross.YesPushDown, t;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = de.internal.calculateCross(n);
  return e.push("q"), e.push("1 1 " + Ee(de.internal.getWidth(n) - 2) + " " + Ee(de.internal.getHeight(n) - 2) + " re"), e.push("W"), e.push("n"), e.push(Ee(i.x1.x) + " " + Ee(i.x1.y) + " m"), e.push(Ee(i.x2.x) + " " + Ee(i.x2.y) + " l"), e.push(Ee(i.x4.x) + " " + Ee(i.x4.y) + " m"), e.push(Ee(i.x3.x) + " " + Ee(i.x3.y) + " l"), e.push("s"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = de.internal.calculateCross(n), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + Ee(de.internal.getWidth(n)) + " " + Ee(de.internal.getHeight(n)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + Ee(de.internal.getWidth(n) - 2) + " " + Ee(de.internal.getHeight(n) - 2) + " re"), i.push("W"), i.push("n"), i.push(Ee(e.x1.x) + " " + Ee(e.x1.y) + " m"), i.push(Ee(e.x2.x) + " " + Ee(e.x2.y) + " l"), i.push(Ee(e.x4.x) + " " + Ee(e.x4.y) + " m"), i.push(Ee(e.x3.x) + " " + Ee(e.x3.y) + " l"), i.push("s"), i.push("Q"), t.stream = i.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Ee(de.internal.getWidth(n)) + " " + Ee(de.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} } }, createDefaultAppearanceStream: function(n) {
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, e = n.scope.__private__.encodeColorString(n.color);
  return "/" + t + " " + n.fontSize + " Tf " + e;
} };
de.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var t = de.internal.getWidth(n), e = de.internal.getHeight(n), i = Math.min(t, e);
  return { x1: { x: (t - i) / 2, y: (e - i) / 2 + i }, x2: { x: (t - i) / 2 + i, y: (e - i) / 2 }, x3: { x: (t - i) / 2, y: (e - i) / 2 }, x4: { x: (t - i) / 2 + i, y: (e - i) / 2 + i } };
} }, de.internal.getWidth = function(n) {
  var t = 0;
  return en(n) === "object" && (t = Jp(n.Rect[2])), t;
}, de.internal.getHeight = function(n) {
  var t = 0;
  return en(n) === "object" && (t = Jp(n.Rect[3])), t;
};
var Pv = Sn.addField = function(n) {
  if (Cv(this, n), !(n instanceof br)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var t;
  return (t = n).scope.internal.acroformPlugin.printedOut && (t.scope.internal.acroformPlugin.printedOut = !1, t.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), t.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Sn.AcroFormChoiceField = po, Sn.AcroFormListBox = go, Sn.AcroFormComboBox = mo, Sn.AcroFormEditBox = kl, Sn.AcroFormButton = qn, Sn.AcroFormPushButton = Al, Sn.AcroFormRadioButton = yo, Sn.AcroFormCheckBox = Nl, Sn.AcroFormTextField = Rs, Sn.AcroFormPasswordField = Cl, Sn.AcroFormAppearance = de, Sn.AcroForm = { ChoiceField: po, ListBox: go, ComboBox: mo, EditBox: kl, Button: qn, PushButton: Al, RadioButton: yo, CheckBox: Nl, TextField: Rs, PasswordField: Cl, Appearance: de }, Se.AcroForm = { ChoiceField: po, ListBox: go, ComboBox: mo, EditBox: kl, Button: qn, PushButton: Al, RadioButton: yo, CheckBox: Nl, TextField: Rs, PasswordField: Cl, Appearance: de };
var Lv = Se.AcroForm;
function F1(n) {
  return n.reduce(function(t, e, i) {
    return t[e] = i, t;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var t = "UNKNOWN", e = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = n.__addimage__.getImageFileTypeByImageData = function(P, A) {
    var I, S, X, H, j, Q = t;
    if ((A = A || t) === "RGBA" || P.data !== void 0 && P.data instanceof Uint8ClampedArray && "height" in P && "width" in P) return "RGBA";
    if (q(P)) for (j in e) for (X = e[j], I = 0; I < X.length; I += 1) {
      for (H = !0, S = 0; S < X[I].length; S += 1) if (X[I][S] !== void 0 && X[I][S] !== P[S]) {
        H = !1;
        break;
      }
      if (H === !0) {
        Q = j;
        break;
      }
    }
    else for (j in e) for (X = e[j], I = 0; I < X.length; I += 1) {
      for (H = !0, S = 0; S < X[I].length; S += 1) if (X[I][S] !== void 0 && X[I][S] !== P.charCodeAt(S)) {
        H = !1;
        break;
      }
      if (H === !0) {
        Q = j;
        break;
      }
    }
    return Q === t && A !== t && (Q = A), Q;
  }, r = function P(A) {
    for (var I = this.internal.write, S = this.internal.putStream, X = (0, this.internal.getFilters)(); X.indexOf("FlateEncode") !== -1; ) X.splice(X.indexOf("FlateEncode"), 1);
    A.objectId = this.internal.newObject();
    var H = [];
    if (H.push({ key: "Type", value: "/XObject" }), H.push({ key: "Subtype", value: "/Image" }), H.push({ key: "Width", value: A.width }), H.push({ key: "Height", value: A.height }), A.colorSpace === x.INDEXED ? H.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (A.palette.length / 3 - 1) + " " + ("sMask" in A && A.sMask !== void 0 ? A.objectId + 2 : A.objectId + 1) + " 0 R]" }) : (H.push({ key: "ColorSpace", value: "/" + A.colorSpace }), A.colorSpace === x.DEVICE_CMYK && H.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), H.push({ key: "BitsPerComponent", value: A.bitsPerComponent }), "decodeParameters" in A && A.decodeParameters !== void 0 && H.push({ key: "DecodeParms", value: "<<" + A.decodeParameters + ">>" }), "transparency" in A && Array.isArray(A.transparency)) {
      for (var j = "", Q = 0, G = A.transparency.length; Q < G; Q++) j += A.transparency[Q] + " " + A.transparency[Q] + " ";
      H.push({ key: "Mask", value: "[" + j + "]" });
    }
    A.sMask !== void 0 && H.push({ key: "SMask", value: A.objectId + 1 + " 0 R" });
    var ft = A.filter !== void 0 ? ["/" + A.filter] : void 0;
    if (S({ data: A.data, additionalKeyValues: H, alreadyAppliedFilters: ft, objectId: A.objectId }), I("endobj"), "sMask" in A && A.sMask !== void 0) {
      var nt = "/Predictor " + A.predictor + " /Colors 1 /BitsPerComponent " + A.bitsPerComponent + " /Columns " + A.width, N = { width: A.width, height: A.height, colorSpace: "DeviceGray", bitsPerComponent: A.bitsPerComponent, decodeParameters: nt, data: A.sMask };
      "filter" in A && (N.filter = A.filter), P.call(this, N);
    }
    if (A.colorSpace === x.INDEXED) {
      var z = this.internal.newObject();
      S({ data: F(new Uint8Array(A.palette)), objectId: z }), I("endobj");
    }
  }, s = function() {
    var P = this.internal.collections.addImage_images;
    for (var A in P) r.call(this, P[A]);
  }, o = function() {
    var P, A = this.internal.collections.addImage_images, I = this.internal.write;
    for (var S in A) I("/I" + (P = A[S]).index, P.objectId, "0", "R");
  }, a = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", o));
  }, l = function() {
    var P = this.internal.collections.addImage_images;
    return a.call(this), P;
  }, h = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, u = function(P) {
    return typeof n["process" + P.toUpperCase()] == "function";
  }, d = function(P) {
    return en(P) === "object" && P.nodeType === 1;
  }, p = function(P, A) {
    if (P.nodeName === "IMG" && P.hasAttribute("src")) {
      var I = "" + P.getAttribute("src");
      if (I.indexOf("data:image/") === 0) return Sl(unescape(I).split("base64,").pop());
      var S = n.loadFile(I, !0);
      if (S !== void 0) return S;
    }
    if (P.nodeName === "CANVAS") {
      if (P.width === 0 || P.height === 0) throw new Error("Given canvas must have data. Canvas width: " + P.width + ", height: " + P.height);
      var X;
      switch (A) {
        case "PNG":
          X = "image/png";
          break;
        case "WEBP":
          X = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          X = "image/jpeg";
      }
      return Sl(P.toDataURL(X, 1).split("base64,").pop());
    }
  }, f = function(P) {
    var A = this.internal.collections.addImage_images;
    if (A) {
      for (var I in A) if (P === A[I].alias) return A[I];
    }
  }, m = function(P, A, I) {
    return P || A || (P = -96, A = -96), P < 0 && (P = -1 * I.width * 72 / P / this.internal.scaleFactor), A < 0 && (A = -1 * I.height * 72 / A / this.internal.scaleFactor), P === 0 && (P = A * I.width / I.height), A === 0 && (A = P * I.height / I.width), [P, A];
  }, b = function(P, A, I, S, X, H) {
    var j = m.call(this, I, S, X), Q = this.internal.getCoordinateString, G = this.internal.getVerticalCoordinateString, ft = l.call(this);
    if (I = j[0], S = j[1], ft[X.index] = X, H) {
      H *= Math.PI / 180;
      var nt = Math.cos(H), N = Math.sin(H), z = function(Y) {
        return Y.toFixed(4);
      }, V = [z(nt), z(N), z(-1 * N), z(nt), 0, 0, "cm"];
    }
    this.internal.write("q"), H ? (this.internal.write([1, "0", "0", 1, Q(P), G(A + S), "cm"].join(" ")), this.internal.write(V.join(" ")), this.internal.write([Q(I), "0", "0", Q(S), "0", "0", "cm"].join(" "))) : this.internal.write([Q(I), "0", "0", Q(S), Q(P), G(A + S), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + X.index + " Do"), this.internal.write("Q");
  }, x = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, v = n.__addimage__.sHashCode = function(P) {
    var A, I, S = 0;
    if (typeof P == "string") for (I = P.length, A = 0; A < I; A++) S = (S << 5) - S + P.charCodeAt(A), S |= 0;
    else if (q(P)) for (I = P.byteLength / 2, A = 0; A < I; A++) S = (S << 5) - S + P[A], S |= 0;
    return S;
  }, k = n.__addimage__.validateStringAsBase64 = function(P) {
    (P = P || "").toString().trim();
    var A = !0;
    return P.length === 0 && (A = !1), P.length % 4 != 0 && (A = !1), /^[A-Za-z0-9+/]+$/.test(P.substr(0, P.length - 2)) === !1 && (A = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(P.substr(-2)) === !1 && (A = !1), A;
  }, C = n.__addimage__.extractImageFromDataUrl = function(P) {
    var A = (P = P || "").split("base64,"), I = null;
    if (A.length === 2) {
      var S = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(A[0]);
      Array.isArray(S) && (I = { mimeType: S[1], charset: S[2], data: A[1] });
    }
    return I;
  }, E = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(P) {
    return E() && P instanceof ArrayBuffer;
  };
  var q = n.__addimage__.isArrayBufferView = function(P) {
    return E() && typeof Uint32Array < "u" && (P instanceof Int8Array || P instanceof Uint8Array || typeof Uint8ClampedArray < "u" && P instanceof Uint8ClampedArray || P instanceof Int16Array || P instanceof Uint16Array || P instanceof Int32Array || P instanceof Uint32Array || P instanceof Float32Array || P instanceof Float64Array);
  }, T = n.__addimage__.binaryStringToUint8Array = function(P) {
    for (var A = P.length, I = new Uint8Array(A), S = 0; S < A; S++) I[S] = P.charCodeAt(S);
    return I;
  }, F = n.__addimage__.arrayBufferToBinaryString = function(P) {
    for (var A = "", I = q(P) ? P : new Uint8Array(P), S = 0; S < I.length; S += 8192) A += String.fromCharCode.apply(null, I.subarray(S, S + 8192));
    return A;
  };
  n.addImage = function() {
    var P, A, I, S, X, H, j, Q, G;
    if (typeof arguments[1] == "number" ? (A = t, I = arguments[1], S = arguments[2], X = arguments[3], H = arguments[4], j = arguments[5], Q = arguments[6], G = arguments[7]) : (A = arguments[1], I = arguments[2], S = arguments[3], X = arguments[4], H = arguments[5], j = arguments[6], Q = arguments[7], G = arguments[8]), en(P = arguments[0]) === "object" && !d(P) && "imageData" in P) {
      var ft = P;
      P = ft.imageData, A = ft.format || A || t, I = ft.x || I || 0, S = ft.y || S || 0, X = ft.w || ft.width || X, H = ft.h || ft.height || H, j = ft.alias || j, Q = ft.compression || Q, G = ft.rotation || ft.angle || G;
    }
    var nt = this.internal.getFilters();
    if (Q === void 0 && nt.indexOf("FlateEncode") !== -1 && (Q = "SLOW"), isNaN(I) || isNaN(S)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    a.call(this);
    var N = M.call(this, P, A, j, Q);
    return b.call(this, I, S, X, H, N, G), this;
  };
  var M = function(P, A, I, S) {
    var X, H, j;
    if (typeof P == "string" && i(P) === t) {
      P = unescape(P);
      var Q = B(P, !1);
      (Q !== "" || (Q = n.loadFile(P, !0)) !== void 0) && (P = Q);
    }
    if (d(P) && (P = p(P, A)), A = i(P, A), !u(A)) throw new Error("addImage does not support files of type '" + A + "', please ensure that a plugin for '" + A + "' support is added.");
    if (((j = I) == null || j.length === 0) && (I = function(G) {
      return typeof G == "string" || q(G) ? v(G) : q(G.data) ? v(G.data) : null;
    }(P)), (X = f.call(this, I)) || (E() && (P instanceof Uint8Array || A === "RGBA" || (H = P, P = T(P))), X = this["process" + A.toUpperCase()](P, h.call(this), I, function(G) {
      return G && typeof G == "string" && (G = G.toUpperCase()), G in n.image_compression ? G : y.NONE;
    }(S), H)), !X) throw new Error("An unknown error occurred whilst processing the image.");
    return X;
  }, B = n.__addimage__.convertBase64ToBinaryString = function(P, A) {
    var I;
    A = typeof A != "boolean" || A;
    var S, X = "";
    if (typeof P == "string") {
      S = (I = C(P)) !== null ? I.data : P;
      try {
        X = Sl(S);
      } catch (H) {
        if (A) throw k(S) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + H.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return X;
  };
  n.getImageProperties = function(P) {
    var A, I, S = "";
    if (d(P) && (P = p(P)), typeof P == "string" && i(P) === t && ((S = B(P, !1)) === "" && (S = n.loadFile(P) || ""), P = S), I = i(P), !u(I)) throw new Error("addImage does not support files of type '" + I + "', please ensure that a plugin for '" + I + "' support is added.");
    if (!E() || P instanceof Uint8Array || (P = T(P)), !(A = this["process" + I.toUpperCase()](P))) throw new Error("An unknown error occurred whilst processing the image");
    return A.fileType = I, A;
  };
})(Se.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    if (e !== void 0 && e != "") return !0;
  };
  Se.API.events.push(["addPage", function(e) {
    this.internal.getPageInfo(e.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(e) {
    for (var i, r, s, o = this.internal.getCoordinateString, a = this.internal.getVerticalCoordinateString, l = this.internal.getPageInfoByObjId(e.objId), h = e.pageContext.annotations, u = !1, d = 0; d < h.length && !u; d++) switch ((i = h[d]).type) {
      case "link":
        (t(i.options.url) || t(i.options.pageNumber)) && (u = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        u = !0;
    }
    if (u != 0) {
      this.internal.write("/Annots [");
      for (var p = 0; p < h.length; p++) {
        i = h[p];
        var f = this.internal.pdfEscape, m = this.internal.getEncryptor(e.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var b = this.internal.newAdditionalObject(), x = this.internal.newAdditionalObject(), y = this.internal.getEncryptor(b.objId), v = i.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y) + "] ") + "/Contents (" + f(y(i.contents)) + ")", s += " /Popup " + x.objId + " 0 R", s += " /P " + l.objId + " 0 R", s += " /T (" + f(y(v)) + ") >>", b.content = s;
            var k = b.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + o(i.bounds.x + 30) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w + 30) + " " + a(i.bounds.y) + "] ") + " /Parent " + k, i.open && (s += " /Open true"), s += " >>", x.content = s, this.internal.write(b.objId, "0 R", x.objId, "0 R");
            break;
          case "freetext":
            r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y + i.bounds.h) + "] ";
            var C = i.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + f(m(i.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + C + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (i.options.name) {
              var E = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = E.page, i.options.top = E.y;
            } else i.options.top || (i.options.top = 0);
            if (r = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", s = "", i.options.url) s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + f(m(i.options.url)) + ") >>";
            else if (i.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + i.options.top + "]";
                  break;
                case "FitV":
                  i.options.left = i.options.left || 0, s += " /FitV " + i.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var q = a(i.options.top);
                  i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), s += " /XYZ " + i.options.left + " " + q + " " + i.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(e) {
    var i = this.internal.getCurrentPageInfo();
    switch (e.type) {
      case "link":
        this.link(e.bounds.x, e.bounds.y, e.bounds.w, e.bounds.h, e);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(e);
    }
  }, n.link = function(e, i, r, s, o) {
    var a = this.internal.getCurrentPageInfo(), l = this.internal.getCoordinateString, h = this.internal.getVerticalCoordinateString;
    a.pageContext.annotations.push({ finalBounds: { x: l(e), y: h(i), w: l(e + r), h: h(i + s) }, options: o, type: "link" });
  }, n.textWithLink = function(e, i, r, s) {
    var o, a, l = this.getTextWidth(e), h = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      a = s.maxWidth;
      var u = this.splitTextToSize(e, a).length;
      o = Math.ceil(h * u);
    } else a = l, o = h;
    return this.text(e, i, r, s), r += 0.2 * h, s.align === "center" && (i -= l / 2), s.align === "right" && (i -= l), this.link(i, r - h, a, o, s), l;
  }, n.getTextWidth = function(e) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(e) * i / this.internal.scaleFactor;
  };
}(Se.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, e = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, r = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var s = n.__arabicParser__.isInArabicSubstitutionA = function(b) {
    return t[b.charCodeAt(0)] !== void 0;
  }, o = n.__arabicParser__.isArabicLetter = function(b) {
    return typeof b == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(b);
  }, a = n.__arabicParser__.isArabicEndLetter = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length <= 2;
  }, l = n.__arabicParser__.isArabicAlfLetter = function(b) {
    return o(b) && r.indexOf(b.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 1;
  };
  var h = n.__arabicParser__.arabicLetterHasFinalForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length >= 3;
  };
  var u = n.__arabicParser__.arabicLetterHasMedialForm = function(b) {
    return o(b) && s(b) && t[b.charCodeAt(0)].length == 4;
  }, d = n.__arabicParser__.resolveLigatures = function(b) {
    var x = 0, y = e, v = "", k = 0;
    for (x = 0; x < b.length; x += 1) y[b.charCodeAt(x)] !== void 0 ? (k++, typeof (y = y[b.charCodeAt(x)]) == "number" && (v += String.fromCharCode(y), y = e, k = 0), x === b.length - 1 && (y = e, v += b.charAt(x - (k - 1)), x -= k - 1, k = 0)) : (y = e, v += b.charAt(x - k), x -= k, k = 0);
    return v;
  };
  n.__arabicParser__.isArabicDiacritic = function(b) {
    return b !== void 0 && i[b.charCodeAt(0)] !== void 0;
  };
  var p = n.__arabicParser__.getCorrectForm = function(b, x, y) {
    return o(b) ? s(b) === !1 ? -1 : !h(b) || !o(x) && !o(y) || !o(y) && a(x) || a(b) && !o(x) || a(b) && l(x) || a(b) && a(x) ? 0 : u(b) && o(x) && !a(x) && o(y) && h(y) ? 3 : a(b) || !o(y) ? 1 : 2 : -1;
  }, f = function(b) {
    var x = 0, y = 0, v = 0, k = "", C = "", E = "", q = (b = b || "").split("\\s+"), T = [];
    for (x = 0; x < q.length; x += 1) {
      for (T.push(""), y = 0; y < q[x].length; y += 1) k = q[x][y], C = q[x][y - 1], E = q[x][y + 1], o(k) ? (v = p(k, C, E), T[x] += v !== -1 ? String.fromCharCode(t[k.charCodeAt(0)][v]) : k) : T[x] += k;
      T[x] = d(T[x]);
    }
    return T.join(" ");
  }, m = n.__arabicParser__.processArabic = n.processArabic = function() {
    var b, x = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, y = [];
    if (Array.isArray(x)) {
      var v = 0;
      for (y = [], v = 0; v < x.length; v += 1) Array.isArray(x[v]) ? y.push([f(x[v][0]), x[v][1], x[v][2]]) : y.push([f(x[v])]);
      b = y;
    } else b = f(x);
    return typeof arguments[0] == "string" ? b : (arguments[0].text = b, arguments[0]);
  };
  n.events.push(["preProcessText", m]);
}(Se.API), Se.API.autoPrint = function(n) {
  var t;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        t = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + t + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    var e = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return e;
    }, set: function(a) {
      e = a;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(a) {
      i = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 150 : a, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(a) {
      r = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 300 : a, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(a) {
      s = a;
    } });
    var o = {};
    Object.defineProperty(this, "style", { get: function() {
      return o;
    }, set: function(a) {
      o = a;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  t.prototype.getContext = function(e, i) {
    var r;
    if ((e = e || "2d") !== "2d") return null;
    for (r in i) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = i[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, t.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new t(), this.canvas.pdf = this;
  }]);
}(Se.API), function(n) {
  var t = { left: 0, top: 0, bottom: 0, right: 0 }, e = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, t), this.internal.__cell__.margins.width = this.getPageWidth(), r.call(this));
  }, r = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var l = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return l;
    }, set: function(b) {
      l = b;
    } });
    var h = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return h;
    }, set: function(b) {
      h = b;
    } });
    var u = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return u;
    }, set: function(b) {
      u = b;
    } });
    var d = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return d;
    }, set: function(b) {
      d = b;
    } });
    var p = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return p;
    }, set: function(b) {
      p = b;
    } });
    var f = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return f;
    }, set: function(b) {
      f = b;
    } });
    var m = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return m;
    }, set: function(b) {
      m = b;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(l) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof l == "function" ? l : void 0, this;
  }, n.getTextDimensions = function(l, h) {
    i.call(this);
    var u = (h = h || {}).fontSize || this.getFontSize(), d = h.font || this.getFont(), p = h.scaleFactor || this.internal.scaleFactor, f = 0, m = 0, b = 0, x = this;
    if (!Array.isArray(l) && typeof l != "string") {
      if (typeof l != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      l = String(l);
    }
    var y = h.maxWidth;
    y > 0 ? typeof l == "string" ? l = this.splitTextToSize(l, y) : Object.prototype.toString.call(l) === "[object Array]" && (l = l.reduce(function(k, C) {
      return k.concat(x.splitTextToSize(C, y));
    }, [])) : l = Array.isArray(l) ? l : [l];
    for (var v = 0; v < l.length; v++) f < (b = this.getStringUnitWidth(l[v], { font: d }) * u) && (f = b);
    return f !== 0 && (m = l.length), { w: f /= p, h: Math.max((m * u * this.getLineHeightFactor() - u * (this.getLineHeightFactor() - 1)) / p, 0) };
  }, n.cellAddPage = function() {
    i.call(this), this.addPage();
    var l = this.internal.__cell__.margins || t;
    return this.internal.__cell__.lastCell = new s(l.left, l.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var o = n.cell = function() {
    var l;
    l = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var h = this.internal.__cell__.lastCell, u = this.internal.__cell__.padding, d = this.internal.__cell__.margins || t, p = this.internal.__cell__.tableHeaderRow, f = this.internal.__cell__.printHeaders;
    return h.lineNumber !== void 0 && (h.lineNumber === l.lineNumber ? (l.x = (h.x || 0) + (h.width || 0), l.y = h.y || 0) : h.y + h.height + l.height + d.bottom > this.getPageHeight() ? (this.cellAddPage(), l.y = d.top, f && p && (this.printHeaderRow(l.lineNumber, !0), l.y += p[0].height)) : l.y = h.y + h.height || l.y), l.text[0] !== void 0 && (this.rect(l.x, l.y, l.width, l.height, e === !0 ? "FD" : void 0), l.align === "right" ? this.text(l.text, l.x + l.width - u, l.y + u, { align: "right", baseline: "top" }) : l.align === "center" ? this.text(l.text, l.x + l.width / 2, l.y + u, { align: "center", baseline: "top", maxWidth: l.width - u - u }) : this.text(l.text, l.x + u, l.y + u, { align: "left", baseline: "top", maxWidth: l.width - u - u })), this.internal.__cell__.lastCell = l, this;
  };
  n.table = function(l, h, u, d, p) {
    if (i.call(this), !u) throw new Error("No data for PDF table.");
    var f, m, b, x, y = [], v = [], k = [], C = {}, E = {}, q = [], T = [], F = (p = p || {}).autoSize || !1, M = p.printHeaders !== !1, B = p.css && p.css["font-size"] !== void 0 ? 16 * p.css["font-size"] : p.fontSize || 12, P = p.margins || Object.assign({ width: this.getPageWidth() }, t), A = typeof p.padding == "number" ? p.padding : 3, I = p.headerBackgroundColor || "#c8c8c8", S = p.headerTextColor || "#000";
    if (r.call(this), this.internal.__cell__.printHeaders = M, this.internal.__cell__.margins = P, this.internal.__cell__.table_font_size = B, this.internal.__cell__.padding = A, this.internal.__cell__.headerBackgroundColor = I, this.internal.__cell__.headerTextColor = S, this.setFontSize(B), d == null) v = y = Object.keys(u[0]), k = y.map(function() {
      return "left";
    });
    else if (Array.isArray(d) && en(d[0]) === "object") for (y = d.map(function(ft) {
      return ft.name;
    }), v = d.map(function(ft) {
      return ft.prompt || ft.name || "";
    }), k = d.map(function(ft) {
      return ft.align || "left";
    }), f = 0; f < d.length; f += 1) E[d[f].name] = d[f].width * (19.049976 / 25.4);
    else Array.isArray(d) && typeof d[0] == "string" && (v = y = d, k = y.map(function() {
      return "left";
    }));
    if (F || Array.isArray(d) && typeof d[0] == "string") for (f = 0; f < y.length; f += 1) {
      for (C[x = y[f]] = u.map(function(ft) {
        return ft[x];
      }), this.setFont(void 0, "bold"), q.push(this.getTextDimensions(v[f], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), m = C[x], this.setFont(void 0, "normal"), b = 0; b < m.length; b += 1) q.push(this.getTextDimensions(m[b], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      E[x] = Math.max.apply(null, q) + A + A, q = [];
    }
    if (M) {
      var X = {};
      for (f = 0; f < y.length; f += 1) X[y[f]] = {}, X[y[f]].text = v[f], X[y[f]].align = k[f];
      var H = a.call(this, X, E);
      T = y.map(function(ft) {
        return new s(l, h, E[ft], H, X[ft].text, void 0, X[ft].align);
      }), this.setTableHeaderRow(T), this.printHeaderRow(1, !1);
    }
    var j = d.reduce(function(ft, nt) {
      return ft[nt.name] = nt.align, ft;
    }, {});
    for (f = 0; f < u.length; f += 1) {
      "rowStart" in p && p.rowStart instanceof Function && p.rowStart({ row: f, data: u[f] }, this);
      var Q = a.call(this, u[f], E);
      for (b = 0; b < y.length; b += 1) {
        var G = u[f][y[b]];
        "cellStart" in p && p.cellStart instanceof Function && p.cellStart({ row: f, col: b, data: G }, this), o.call(this, new s(l, h, E[y[b]], Q, G, f + 2, j[y[b]]));
      }
    }
    return this.internal.__cell__.table_x = l, this.internal.__cell__.table_y = h, this;
  };
  var a = function(l, h) {
    var u = this.internal.__cell__.padding, d = this.internal.__cell__.table_font_size, p = this.internal.scaleFactor;
    return Object.keys(l).map(function(f) {
      var m = l[f];
      return this.splitTextToSize(m.hasOwnProperty("text") ? m.text : m, h[f] - u - u);
    }, this).map(function(f) {
      return this.getLineHeightFactor() * f.length * d / p + u + u;
    }, this).reduce(function(f, m) {
      return Math.max(f, m);
    }, 0);
  };
  n.setTableHeaderRow = function(l) {
    i.call(this), this.internal.__cell__.tableHeaderRow = l;
  }, n.printHeaderRow = function(l, h) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var u;
    if (e = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var d = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(d[0], d[1], d[2], d[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var p = [], f = 0; f < this.internal.__cell__.tableHeaderRow.length; f += 1) {
      u = this.internal.__cell__.tableHeaderRow[f].clone(), h && (u.y = this.internal.__cell__.margins.top || 0, p.push(u)), u.lineNumber = l;
      var m = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), o.call(this, u), this.setTextColor(m);
    }
    p.length > 0 && this.setTableHeaderRow(p), this.setFont(void 0, "normal"), e = !1;
  };
}(Se.API);
var M1 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, R1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], mf = F1(R1), D1 = [100, 200, 300, 400, 500, 600, 700, 800, 900], Iv = F1(D1);
function yf(n) {
  var t = n.family.replace(/"|'/g, "").toLowerCase(), e = function(s) {
    return M1[s = s || "normal"] ? s : "normal";
  }(n.style), i = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), r = function(s) {
    return typeof mf[s = s || "normal"] == "number" ? s : "normal";
  }(n.stretch);
  return { family: t, style: e, weight: i, stretch: r, src: n.src || [], ref: n.ref || { name: t, style: [r, e, i].join(" ") } };
}
function Zp(n, t, e, i) {
  var r;
  for (r = e; r >= 0 && r < t.length; r += i) if (n[t[r]]) return n[t[r]];
  for (r = e; r >= 0 && r < t.length; r -= i) if (n[t[r]]) return n[t[r]];
}
var Ev = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Qp = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function tg(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function Ov(n, t, e) {
  for (var i = (e = e || {}).defaultFontFamily || "times", r = Object.assign({}, Ev, e.genericFontFamilies || {}), s = null, o = null, a = 0; a < t.length; ++a) if (r[(s = yf(t[a])).family] && (s.family = r[s.family]), n.hasOwnProperty(s.family)) {
    o = n[s.family];
    break;
  }
  if (!(o = o || n[i])) throw new Error("Could not find a font-family for the rule '" + tg(s) + "' and default family '" + i + "'.");
  if (o = function(l, h) {
    if (h[l]) return h[l];
    var u = mf[l], d = u <= mf.normal ? -1 : 1, p = Zp(h, R1, u, d);
    if (!p) throw new Error("Could not find a matching font-stretch value for " + l);
    return p;
  }(s.stretch, o), o = function(l, h) {
    if (h[l]) return h[l];
    for (var u = M1[l], d = 0; d < u.length; ++d) if (h[u[d]]) return h[u[d]];
    throw new Error("Could not find a matching font-style for " + l);
  }(s.style, o), !(o = function(l, h) {
    if (h[l]) return h[l];
    if (l === 400 && h[500]) return h[500];
    if (l === 500 && h[400]) return h[400];
    var u = Iv[l], d = Zp(h, D1, u, l < 400 ? -1 : 1);
    if (!d) throw new Error("Could not find a matching font-weight for value " + l);
    return d;
  }(s.weight, o))) throw new Error("Failed to resolve a font for the rule '" + tg(s) + "'.");
  return o;
}
function eg(n) {
  return n.trimLeft();
}
function Tv(n, t) {
  for (var e = 0; e < n.length; ) {
    if (n.charAt(e) === t) return [n.substring(0, e), n.substring(e + 1)];
    e += 1;
  }
  return null;
}
function Fv(n) {
  var t = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return t === null ? null : [t[0], n.substring(t[0].length)];
}
var Pu, ng, ig, Lh = ["times"];
(function(n) {
  var t, e, i, r, s, o, a, l, h, u = function(N) {
    return N = N || {}, this.isStrokeTransparent = N.isStrokeTransparent || !1, this.strokeOpacity = N.strokeOpacity || 1, this.strokeStyle = N.strokeStyle || "#000000", this.fillStyle = N.fillStyle || "#000000", this.isFillTransparent = N.isFillTransparent || !1, this.fillOpacity = N.fillOpacity || 1, this.font = N.font || "10px sans-serif", this.textBaseline = N.textBaseline || "alphabetic", this.textAlign = N.textAlign || "left", this.lineWidth = N.lineWidth || 1, this.lineJoin = N.lineJoin || "miter", this.lineCap = N.lineCap || "butt", this.path = N.path || [], this.transform = N.transform !== void 0 ? N.transform.clone() : new l(), this.globalCompositeOperation = N.globalCompositeOperation || "normal", this.globalAlpha = N.globalAlpha || 1, this.clip_path = N.clip_path || [], this.currentPoint = N.currentPoint || new o(), this.miterLimit = N.miterLimit || 10, this.lastPoint = N.lastPoint || new o(), this.lineDashOffset = N.lineDashOffset || 0, this.lineDash = N.lineDash || [], this.margin = N.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = N.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof N.ignoreClearRect != "boolean" || N.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new d(this), t = this.internal.f2, e = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, r = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, o = this.internal.Point, a = this.internal.Rectangle, l = this.internal.Matrix, h = new u();
  }]);
  var d = function(N) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var z = N;
    Object.defineProperty(this, "pdf", { get: function() {
      return z;
    } });
    var V = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return V;
    }, set: function(ct) {
      V = !!ct;
    } });
    var Y = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Y;
    }, set: function(ct) {
      Y = !!ct;
    } });
    var ot = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ot;
    }, set: function(ct) {
      isNaN(ct) || (ot = ct);
    } });
    var wt = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return wt;
    }, set: function(ct) {
      isNaN(ct) || (wt = ct);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return h.margin;
    }, set: function(ct) {
      var U;
      typeof ct == "number" ? U = [ct, ct, ct, ct] : ((U = new Array(4))[0] = ct[0], U[1] = ct.length >= 2 ? ct[1] : U[0], U[2] = ct.length >= 3 ? ct[2] : U[0], U[3] = ct.length >= 4 ? ct[3] : U[1]), h.margin = U;
    } });
    var mt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return mt;
    }, set: function(ct) {
      mt = ct;
    } });
    var xt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return xt;
    }, set: function(ct) {
      xt = ct;
    } });
    var zt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return zt;
    }, set: function(ct) {
      zt = ct;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return h;
    }, set: function(ct) {
      ct instanceof u && (h = ct);
    } }), Object.defineProperty(this, "path", { get: function() {
      return h.path;
    }, set: function(ct) {
      h.path = ct;
    } });
    var Dt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Dt;
    }, set: function(ct) {
      Dt = ct;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ct) {
      var U;
      U = p(ct), this.ctx.fillStyle = U.style, this.ctx.isFillTransparent = U.a === 0, this.ctx.fillOpacity = U.a, this.pdf.setFillColor(U.r, U.g, U.b, { a: U.a }), this.pdf.setTextColor(U.r, U.g, U.b, { a: U.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ct) {
      var U = p(ct);
      this.ctx.strokeStyle = U.style, this.ctx.isStrokeTransparent = U.a === 0, this.ctx.strokeOpacity = U.a, U.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (U.a, this.pdf.setDrawColor(U.r, U.g, U.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ct) {
      ["butt", "round", "square"].indexOf(ct) !== -1 && (this.ctx.lineCap = ct, this.pdf.setLineCap(ct));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ct) {
      isNaN(ct) || (this.ctx.lineWidth = ct, this.pdf.setLineWidth(ct));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ct) {
      ["bevel", "round", "miter"].indexOf(ct) !== -1 && (this.ctx.lineJoin = ct, this.pdf.setLineJoin(ct));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ct) {
      isNaN(ct) || (this.ctx.miterLimit = ct, this.pdf.setMiterLimit(ct));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ct) {
      this.ctx.textBaseline = ct;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ct) {
      ["right", "end", "center", "left", "start"].indexOf(ct) !== -1 && (this.ctx.textAlign = ct);
    } });
    var Jt = null;
    function Qt(ct, U) {
      if (Jt === null) {
        var et = function(J) {
          var rt = [];
          return Object.keys(J).forEach(function(vt) {
            J[vt].forEach(function(At) {
              var ht = null;
              switch (At) {
                case "bold":
                  ht = { family: vt, weight: "bold" };
                  break;
                case "italic":
                  ht = { family: vt, style: "italic" };
                  break;
                case "bolditalic":
                  ht = { family: vt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  ht = { family: vt };
              }
              ht !== null && (ht.ref = { name: vt, style: At }, rt.push(ht));
            });
          }), rt;
        }(ct.getFontList());
        Jt = function(J) {
          for (var rt = {}, vt = 0; vt < J.length; ++vt) {
            var At = yf(J[vt]), ht = At.family, Ot = At.stretch, $t = At.style, Ft = At.weight;
            rt[ht] = rt[ht] || {}, rt[ht][Ot] = rt[ht][Ot] || {}, rt[ht][Ot][$t] = rt[ht][Ot][$t] || {}, rt[ht][Ot][$t][Ft] = At;
          }
          return rt;
        }(et.concat(U));
      }
      return Jt;
    }
    var O = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return O;
    }, set: function(ct) {
      Jt = null, O = ct;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ct) {
      var U;
      if (this.ctx.font = ct, (U = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ct)) !== null) {
        var et = U[1], J = (U[2], U[3]), rt = U[4], vt = (U[5], U[6]), At = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(rt)[2];
        rt = Math.floor(At === "px" ? parseFloat(rt) * this.pdf.internal.scaleFactor : At === "em" ? parseFloat(rt) * this.pdf.getFontSize() : parseFloat(rt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(rt);
        var ht = function(ae) {
          var dt, kt, te = [], Rt = ae.trim();
          if (Rt === "") return Lh;
          if (Rt in Qp) return [Qp[Rt]];
          for (; Rt !== ""; ) {
            switch (kt = null, dt = (Rt = eg(Rt)).charAt(0)) {
              case '"':
              case "'":
                kt = Tv(Rt.substring(1), dt);
                break;
              default:
                kt = Fv(Rt);
            }
            if (kt === null || (te.push(kt[0]), (Rt = eg(kt[1])) !== "" && Rt.charAt(0) !== ",")) return Lh;
            Rt = Rt.replace(/^,/, "");
          }
          return te;
        }(vt);
        if (this.fontFaces) {
          var Ot = Ov(Qt(this.pdf, this.fontFaces), ht.map(function(ae) {
            return { family: ae, stretch: "normal", weight: J, style: et };
          }));
          this.pdf.setFont(Ot.ref.name, Ot.ref.style);
        } else {
          var $t = "";
          (J === "bold" || parseInt(J, 10) >= 700 || et === "bold") && ($t = "bold"), et === "italic" && ($t += "italic"), $t.length === 0 && ($t = "normal");
          for (var Ft = "", Ut = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, ie = 0; ie < ht.length; ie++) {
            if (this.pdf.internal.getFont(ht[ie], $t, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Ft = ht[ie];
              break;
            }
            if ($t === "bolditalic" && this.pdf.internal.getFont(ht[ie], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Ft = ht[ie], $t = "bold";
            else if (this.pdf.internal.getFont(ht[ie], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Ft = ht[ie], $t = "normal";
              break;
            }
          }
          if (Ft === "") {
            for (var oe = 0; oe < ht.length; oe++) if (Ut[ht[oe]]) {
              Ft = Ut[ht[oe]];
              break;
            }
          }
          Ft = Ft === "" ? "Times" : Ft, this.pdf.setFont(Ft, $t);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ct) {
      this.ctx.globalCompositeOperation = ct;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ct) {
      this.ctx.globalAlpha = ct;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ct) {
      this.ctx.lineDashOffset = ct, nt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ct) {
      this.ctx.lineDash = ct, nt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ct) {
      this.ctx.ignoreClearRect = !!ct;
    } });
  };
  d.prototype.setLineDash = function(N) {
    this.lineDash = N;
  }, d.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, d.prototype.fill = function() {
    C.call(this, "fill", !1);
  }, d.prototype.stroke = function() {
    C.call(this, "stroke", !1);
  }, d.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, d.prototype.moveTo = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var V = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "mt", x: V.x, y: V.y }), this.ctx.lastPoint = new o(N, z);
  }, d.prototype.closePath = function() {
    var N = new o(0, 0), z = 0;
    for (z = this.path.length - 1; z !== -1; z--) if (this.path[z].type === "begin" && en(this.path[z + 1]) === "object" && typeof this.path[z + 1].x == "number") {
      N = new o(this.path[z + 1].x, this.path[z + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new o(N.x, N.y);
  }, d.prototype.lineTo = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var V = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "lt", x: V.x, y: V.y }), this.ctx.lastPoint = new o(V.x, V.y);
  }, d.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), C.call(this, null, !0);
  }, d.prototype.quadraticCurveTo = function(N, z, V, Y) {
    if (isNaN(V) || isNaN(Y) || isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ot = this.ctx.transform.applyToPoint(new o(V, Y)), wt = this.ctx.transform.applyToPoint(new o(N, z));
    this.path.push({ type: "qct", x1: wt.x, y1: wt.y, x: ot.x, y: ot.y }), this.ctx.lastPoint = new o(ot.x, ot.y);
  }, d.prototype.bezierCurveTo = function(N, z, V, Y, ot, wt) {
    if (isNaN(ot) || isNaN(wt) || isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y)) throw an.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var mt = this.ctx.transform.applyToPoint(new o(ot, wt)), xt = this.ctx.transform.applyToPoint(new o(N, z)), zt = this.ctx.transform.applyToPoint(new o(V, Y));
    this.path.push({ type: "bct", x1: xt.x, y1: xt.y, x2: zt.x, y2: zt.y, x: mt.x, y: mt.y }), this.ctx.lastPoint = new o(mt.x, mt.y);
  }, d.prototype.arc = function(N, z, V, Y, ot, wt) {
    if (isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y) || isNaN(ot)) throw an.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (wt = !!wt, !this.ctx.transform.isIdentity) {
      var mt = this.ctx.transform.applyToPoint(new o(N, z));
      N = mt.x, z = mt.y;
      var xt = this.ctx.transform.applyToPoint(new o(0, V)), zt = this.ctx.transform.applyToPoint(new o(0, 0));
      V = Math.sqrt(Math.pow(xt.x - zt.x, 2) + Math.pow(xt.y - zt.y, 2));
    }
    Math.abs(ot - Y) >= 2 * Math.PI && (Y = 0, ot = 2 * Math.PI), this.path.push({ type: "arc", x: N, y: z, radius: V, startAngle: Y, endAngle: ot, counterclockwise: wt });
  }, d.prototype.arcTo = function(N, z, V, Y, ot) {
    throw new Error("arcTo not implemented.");
  }, d.prototype.rect = function(N, z, V, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y)) throw an.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(N, z), this.lineTo(N + V, z), this.lineTo(N + V, z + Y), this.lineTo(N, z + Y), this.lineTo(N, z), this.lineTo(N + V, z), this.lineTo(N, z);
  }, d.prototype.fillRect = function(N, z, V, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y)) throw an.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!f.call(this)) {
      var ot = {};
      this.lineCap !== "butt" && (ot.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ot.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(N, z, V, Y), this.fill(), ot.hasOwnProperty("lineCap") && (this.lineCap = ot.lineCap), ot.hasOwnProperty("lineJoin") && (this.lineJoin = ot.lineJoin);
    }
  }, d.prototype.strokeRect = function(N, z, V, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y)) throw an.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    m.call(this) || (this.beginPath(), this.rect(N, z, V, Y), this.stroke());
  }, d.prototype.clearRect = function(N, z, V, Y) {
    if (isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y)) throw an.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(N, z, V, Y));
  }, d.prototype.save = function(N) {
    N = typeof N != "boolean" || N;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, V = 0; V < this.pdf.internal.getNumberOfPages(); V++) this.pdf.setPage(V + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(z), N) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Y = new u(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Y;
    }
  }, d.prototype.restore = function(N) {
    N = typeof N != "boolean" || N;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, V = 0; V < this.pdf.internal.getNumberOfPages(); V++) this.pdf.setPage(V + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(z), N && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, d.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var p = function(N) {
    var z, V, Y, ot;
    if (N.isCanvasGradient === !0 && (N = N.getColor()), !N) return { r: 0, g: 0, b: 0, a: 0, style: N };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(N)) z = 0, V = 0, Y = 0, ot = 0;
    else {
      var wt = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(N);
      if (wt !== null) z = parseInt(wt[1]), V = parseInt(wt[2]), Y = parseInt(wt[3]), ot = 1;
      else if ((wt = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(N)) !== null) z = parseInt(wt[1]), V = parseInt(wt[2]), Y = parseInt(wt[3]), ot = parseFloat(wt[4]);
      else {
        if (ot = 1, typeof N == "string" && N.charAt(0) !== "#") {
          var mt = new P1(N);
          N = mt.ok ? mt.toHex() : "#000000";
        }
        N.length === 4 ? (z = N.substring(1, 2), z += z, V = N.substring(2, 3), V += V, Y = N.substring(3, 4), Y += Y) : (z = N.substring(1, 3), V = N.substring(3, 5), Y = N.substring(5, 7)), z = parseInt(z, 16), V = parseInt(V, 16), Y = parseInt(Y, 16);
      }
    }
    return { r: z, g: V, b: Y, a: ot, style: N };
  }, f = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, m = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  d.prototype.fillText = function(N, z, V, Y) {
    if (isNaN(z) || isNaN(V) || typeof N != "string") throw an.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Y = isNaN(Y) ? void 0 : Y, !f.call(this)) {
      var ot = Q(this.ctx.transform.rotation), wt = this.ctx.transform.scaleX;
      A.call(this, { text: N, x: z, y: V, scale: wt, angle: ot, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.strokeText = function(N, z, V, Y) {
    if (isNaN(z) || isNaN(V) || typeof N != "string") throw an.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!m.call(this)) {
      Y = isNaN(Y) ? void 0 : Y;
      var ot = Q(this.ctx.transform.rotation), wt = this.ctx.transform.scaleX;
      A.call(this, { text: N, x: z, y: V, scale: wt, renderingMode: "stroke", angle: ot, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.measureText = function(N) {
    if (typeof N != "string") throw an.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var z = this.pdf, V = this.pdf.internal.scaleFactor, Y = z.internal.getFontSize(), ot = z.getStringUnitWidth(N) * Y / z.internal.scaleFactor, wt = function(mt) {
      var xt = (mt = mt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return xt;
      } }), this;
    };
    return new wt({ width: ot *= Math.round(96 * V / 72 * 1e4) / 1e4 });
  }, d.prototype.scale = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var V = new l(N, 0, 0, z, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(V);
  }, d.prototype.rotate = function(N) {
    if (isNaN(N)) throw an.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var z = new l(Math.cos(N), Math.sin(N), -Math.sin(N), Math.cos(N), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(z);
  }, d.prototype.translate = function(N, z) {
    if (isNaN(N) || isNaN(z)) throw an.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var V = new l(1, 0, 0, 1, N, z);
    this.ctx.transform = this.ctx.transform.multiply(V);
  }, d.prototype.transform = function(N, z, V, Y, ot, wt) {
    if (isNaN(N) || isNaN(z) || isNaN(V) || isNaN(Y) || isNaN(ot) || isNaN(wt)) throw an.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var mt = new l(N, z, V, Y, ot, wt);
    this.ctx.transform = this.ctx.transform.multiply(mt);
  }, d.prototype.setTransform = function(N, z, V, Y, ot, wt) {
    N = isNaN(N) ? 1 : N, z = isNaN(z) ? 0 : z, V = isNaN(V) ? 0 : V, Y = isNaN(Y) ? 1 : Y, ot = isNaN(ot) ? 0 : ot, wt = isNaN(wt) ? 0 : wt, this.ctx.transform = new l(N, z, V, Y, ot, wt);
  };
  var b = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  d.prototype.drawImage = function(N, z, V, Y, ot, wt, mt, xt, zt) {
    var Dt = this.pdf.getImageProperties(N), Jt = 1, Qt = 1, O = 1, ct = 1;
    Y !== void 0 && xt !== void 0 && (O = xt / Y, ct = zt / ot, Jt = Dt.width / Y * xt / Y, Qt = Dt.height / ot * zt / ot), wt === void 0 && (wt = z, mt = V, z = 0, V = 0), Y !== void 0 && xt === void 0 && (xt = Y, zt = ot), Y === void 0 && xt === void 0 && (xt = Dt.width, zt = Dt.height);
    for (var U, et = this.ctx.transform.decompose(), J = Q(et.rotate.shx), rt = new l(), vt = (rt = (rt = (rt = rt.multiply(et.translate)).multiply(et.skew)).multiply(et.scale)).applyToRectangle(new a(wt - z * O, mt - V * ct, Y * Jt, ot * Qt)), At = x.call(this, vt), ht = [], Ot = 0; Ot < At.length; Ot += 1) ht.indexOf(At[Ot]) === -1 && ht.push(At[Ot]);
    if (k(ht), this.autoPaging) for (var $t = ht[0], Ft = ht[ht.length - 1], Ut = $t; Ut < Ft + 1; Ut++) {
      this.pdf.setPage(Ut);
      var ie = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], oe = Ut === 1 ? this.posY + this.margin[0] : this.margin[0], ae = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], dt = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], kt = Ut === 1 ? 0 : ae + (Ut - 2) * dt;
      if (this.ctx.clip_path.length !== 0) {
        var te = this.path;
        U = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(U, this.posX + this.margin[3], -kt + oe + this.ctx.prevPageLastElemOffset), E.call(this, "fill", !0), this.path = te;
      }
      var Rt = JSON.parse(JSON.stringify(vt));
      Rt = v([Rt], this.posX + this.margin[3], -kt + oe + this.ctx.prevPageLastElemOffset)[0];
      var be = (Ut > $t || Ut < Ft) && b.call(this);
      be && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ie, dt, null).clip().discardPath()), this.pdf.addImage(N, "JPEG", Rt.x, Rt.y, Rt.w, Rt.h, null, null, J), be && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(N, "JPEG", vt.x, vt.y, vt.w, vt.h, null, null, J);
  };
  var x = function(N, z, V) {
    var Y = [];
    z = z || this.pdf.internal.pageSize.width, V = V || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ot = this.posY + this.ctx.prevPageLastElemOffset;
    switch (N.type) {
      default:
      case "mt":
      case "lt":
        Y.push(Math.floor((N.y + ot) / V) + 1);
        break;
      case "arc":
        Y.push(Math.floor((N.y + ot - N.radius) / V) + 1), Y.push(Math.floor((N.y + ot + N.radius) / V) + 1);
        break;
      case "qct":
        var wt = G(this.ctx.lastPoint.x, this.ctx.lastPoint.y, N.x1, N.y1, N.x, N.y);
        Y.push(Math.floor((wt.y + ot) / V) + 1), Y.push(Math.floor((wt.y + wt.h + ot) / V) + 1);
        break;
      case "bct":
        var mt = ft(this.ctx.lastPoint.x, this.ctx.lastPoint.y, N.x1, N.y1, N.x2, N.y2, N.x, N.y);
        Y.push(Math.floor((mt.y + ot) / V) + 1), Y.push(Math.floor((mt.y + mt.h + ot) / V) + 1);
        break;
      case "rect":
        Y.push(Math.floor((N.y + ot) / V) + 1), Y.push(Math.floor((N.y + N.h + ot) / V) + 1);
    }
    for (var xt = 0; xt < Y.length; xt += 1) for (; this.pdf.internal.getNumberOfPages() < Y[xt]; ) y.call(this);
    return Y;
  }, y = function() {
    var N = this.fillStyle, z = this.strokeStyle, V = this.font, Y = this.lineCap, ot = this.lineWidth, wt = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = N, this.strokeStyle = z, this.font = V, this.lineCap = Y, this.lineWidth = ot, this.lineJoin = wt;
  }, v = function(N, z, V) {
    for (var Y = 0; Y < N.length; Y++) switch (N[Y].type) {
      case "bct":
        N[Y].x2 += z, N[Y].y2 += V;
      case "qct":
        N[Y].x1 += z, N[Y].y1 += V;
      case "mt":
      case "lt":
      case "arc":
      default:
        N[Y].x += z, N[Y].y += V;
    }
    return N;
  }, k = function(N) {
    return N.sort(function(z, V) {
      return z - V;
    });
  }, C = function(N, z) {
    for (var V, Y, ot = this.fillStyle, wt = this.strokeStyle, mt = this.lineCap, xt = this.lineWidth, zt = Math.abs(xt * this.ctx.transform.scaleX), Dt = this.lineJoin, Jt = JSON.parse(JSON.stringify(this.path)), Qt = JSON.parse(JSON.stringify(this.path)), O = [], ct = 0; ct < Qt.length; ct++) if (Qt[ct].x !== void 0) for (var U = x.call(this, Qt[ct]), et = 0; et < U.length; et += 1) O.indexOf(U[et]) === -1 && O.push(U[et]);
    for (var J = 0; J < O.length; J++) for (; this.pdf.internal.getNumberOfPages() < O[J]; ) y.call(this);
    if (k(O), this.autoPaging) for (var rt = O[0], vt = O[O.length - 1], At = rt; At < vt + 1; At++) {
      this.pdf.setPage(At), this.fillStyle = ot, this.strokeStyle = wt, this.lineCap = mt, this.lineWidth = zt, this.lineJoin = Dt;
      var ht = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Ot = At === 1 ? this.posY + this.margin[0] : this.margin[0], $t = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ft = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Ut = At === 1 ? 0 : $t + (At - 2) * Ft;
      if (this.ctx.clip_path.length !== 0) {
        var ie = this.path;
        V = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(V, this.posX + this.margin[3], -Ut + Ot + this.ctx.prevPageLastElemOffset), E.call(this, N, !0), this.path = ie;
      }
      if (Y = JSON.parse(JSON.stringify(Jt)), this.path = v(Y, this.posX + this.margin[3], -Ut + Ot + this.ctx.prevPageLastElemOffset), z === !1 || At === 0) {
        var oe = (At > rt || At < vt) && b.call(this);
        oe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ht, Ft, null).clip().discardPath()), E.call(this, N, z), oe && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = xt;
    }
    else this.lineWidth = zt, E.call(this, N, z), this.lineWidth = xt;
    this.path = Jt;
  }, E = function(N, z) {
    if ((N !== "stroke" || z || !m.call(this)) && (N === "stroke" || z || !f.call(this))) {
      for (var V, Y, ot = [], wt = this.path, mt = 0; mt < wt.length; mt++) {
        var xt = wt[mt];
        switch (xt.type) {
          case "begin":
            ot.push({ begin: !0 });
            break;
          case "close":
            ot.push({ close: !0 });
            break;
          case "mt":
            ot.push({ start: xt, deltas: [], abs: [] });
            break;
          case "lt":
            var zt = ot.length;
            if (wt[mt - 1] && !isNaN(wt[mt - 1].x) && (V = [xt.x - wt[mt - 1].x, xt.y - wt[mt - 1].y], zt > 0)) {
              for (; zt >= 0; zt--) if (ot[zt - 1].close !== !0 && ot[zt - 1].begin !== !0) {
                ot[zt - 1].deltas.push(V), ot[zt - 1].abs.push(xt);
                break;
              }
            }
            break;
          case "bct":
            V = [xt.x1 - wt[mt - 1].x, xt.y1 - wt[mt - 1].y, xt.x2 - wt[mt - 1].x, xt.y2 - wt[mt - 1].y, xt.x - wt[mt - 1].x, xt.y - wt[mt - 1].y], ot[ot.length - 1].deltas.push(V);
            break;
          case "qct":
            var Dt = wt[mt - 1].x + 2 / 3 * (xt.x1 - wt[mt - 1].x), Jt = wt[mt - 1].y + 2 / 3 * (xt.y1 - wt[mt - 1].y), Qt = xt.x + 2 / 3 * (xt.x1 - xt.x), O = xt.y + 2 / 3 * (xt.y1 - xt.y), ct = xt.x, U = xt.y;
            V = [Dt - wt[mt - 1].x, Jt - wt[mt - 1].y, Qt - wt[mt - 1].x, O - wt[mt - 1].y, ct - wt[mt - 1].x, U - wt[mt - 1].y], ot[ot.length - 1].deltas.push(V);
            break;
          case "arc":
            ot.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ot[ot.length - 1].abs) && ot[ot.length - 1].abs.push(xt);
        }
      }
      Y = z ? null : N === "stroke" ? "stroke" : "fill";
      for (var et = !1, J = 0; J < ot.length; J++) if (ot[J].arc) for (var rt = ot[J].abs, vt = 0; vt < rt.length; vt++) {
        var At = rt[vt];
        At.type === "arc" ? F.call(this, At.x, At.y, At.radius, At.startAngle, At.endAngle, At.counterclockwise, void 0, z, !et) : I.call(this, At.x, At.y), et = !0;
      }
      else if (ot[J].close === !0) this.pdf.internal.out("h"), et = !1;
      else if (ot[J].begin !== !0) {
        var ht = ot[J].start.x, Ot = ot[J].start.y;
        S.call(this, ot[J].deltas, ht, Ot), et = !0;
      }
      Y && M.call(this, Y), z && B.call(this);
    }
  }, q = function(N) {
    var z = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, V = z * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return N - V;
      case "top":
        return N + z - V;
      case "hanging":
        return N + z - 2 * V;
      case "middle":
        return N + z / 2 - V;
      case "ideographic":
        return N;
      case "alphabetic":
      default:
        return N;
    }
  }, T = function(N) {
    return N + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  d.prototype.createLinearGradient = function() {
    var N = function() {
    };
    return N.colorStops = [], N.addColorStop = function(z, V) {
      this.colorStops.push([z, V]);
    }, N.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, N.isCanvasGradient = !0, N;
  }, d.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, d.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var F = function(N, z, V, Y, ot, wt, mt, xt, zt) {
    for (var Dt = H.call(this, V, Y, ot, wt), Jt = 0; Jt < Dt.length; Jt++) {
      var Qt = Dt[Jt];
      Jt === 0 && (zt ? P.call(this, Qt.x1 + N, Qt.y1 + z) : I.call(this, Qt.x1 + N, Qt.y1 + z)), X.call(this, N, z, Qt.x2, Qt.y2, Qt.x3, Qt.y3, Qt.x4, Qt.y4);
    }
    xt ? B.call(this) : M.call(this, mt);
  }, M = function(N) {
    switch (N) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, B = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, P = function(N, z) {
    this.pdf.internal.out(e(N) + " " + i(z) + " m");
  }, A = function(N) {
    var z;
    switch (N.align) {
      case "right":
      case "end":
        z = "right";
        break;
      case "center":
        z = "center";
        break;
      case "left":
      case "start":
      default:
        z = "left";
    }
    var V = this.pdf.getTextDimensions(N.text), Y = q.call(this, N.y), ot = T.call(this, Y) - V.h, wt = this.ctx.transform.applyToPoint(new o(N.x, Y)), mt = this.ctx.transform.decompose(), xt = new l();
    xt = (xt = (xt = xt.multiply(mt.translate)).multiply(mt.skew)).multiply(mt.scale);
    for (var zt, Dt, Jt, Qt = this.ctx.transform.applyToRectangle(new a(N.x, Y, V.w, V.h)), O = xt.applyToRectangle(new a(N.x, ot, V.w, V.h)), ct = x.call(this, O), U = [], et = 0; et < ct.length; et += 1) U.indexOf(ct[et]) === -1 && U.push(ct[et]);
    if (k(U), this.autoPaging) for (var J = U[0], rt = U[U.length - 1], vt = J; vt < rt + 1; vt++) {
      this.pdf.setPage(vt);
      var At = vt === 1 ? this.posY + this.margin[0] : this.margin[0], ht = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ot = this.pdf.internal.pageSize.height - this.margin[2], $t = Ot - this.margin[0], Ft = this.pdf.internal.pageSize.width - this.margin[1], Ut = Ft - this.margin[3], ie = vt === 1 ? 0 : ht + (vt - 2) * $t;
      if (this.ctx.clip_path.length !== 0) {
        var oe = this.path;
        zt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(zt, this.posX + this.margin[3], -1 * ie + At), E.call(this, "fill", !0), this.path = oe;
      }
      var ae = v([JSON.parse(JSON.stringify(O))], this.posX + this.margin[3], -ie + At + this.ctx.prevPageLastElemOffset)[0];
      N.scale >= 0.01 && (Dt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Dt * N.scale), Jt = this.lineWidth, this.lineWidth = Jt * N.scale);
      var dt = this.autoPaging !== "text";
      if (dt || ae.y + ae.h <= Ot) {
        if (dt || ae.y >= At && ae.x <= Ft) {
          var kt = dt ? N.text : this.pdf.splitTextToSize(N.text, N.maxWidth || Ft - ae.x)[0], te = v([JSON.parse(JSON.stringify(Qt))], this.posX + this.margin[3], -ie + At + this.ctx.prevPageLastElemOffset)[0], Rt = dt && (vt > J || vt < rt) && b.call(this);
          Rt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ut, $t, null).clip().discardPath()), this.pdf.text(kt, te.x, te.y, { angle: N.angle, align: z, renderingMode: N.renderingMode }), Rt && this.pdf.restoreGraphicsState();
        }
      } else ae.y < Ot && (this.ctx.prevPageLastElemOffset += Ot - ae.y);
      N.scale >= 0.01 && (this.pdf.setFontSize(Dt), this.lineWidth = Jt);
    }
    else N.scale >= 0.01 && (Dt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Dt * N.scale), Jt = this.lineWidth, this.lineWidth = Jt * N.scale), this.pdf.text(N.text, wt.x + this.posX, wt.y + this.posY, { angle: N.angle, align: z, renderingMode: N.renderingMode, maxWidth: N.maxWidth }), N.scale >= 0.01 && (this.pdf.setFontSize(Dt), this.lineWidth = Jt);
  }, I = function(N, z, V, Y) {
    V = V || 0, Y = Y || 0, this.pdf.internal.out(e(N + V) + " " + i(z + Y) + " l");
  }, S = function(N, z, V) {
    return this.pdf.lines(N, z, V, null, null);
  }, X = function(N, z, V, Y, ot, wt, mt, xt) {
    this.pdf.internal.out([t(r(V + N)), t(s(Y + z)), t(r(ot + N)), t(s(wt + z)), t(r(mt + N)), t(s(xt + z)), "c"].join(" "));
  }, H = function(N, z, V, Y) {
    for (var ot = 2 * Math.PI, wt = Math.PI / 2; z > V; ) z -= ot;
    var mt = Math.abs(V - z);
    mt < ot && Y && (mt = ot - mt);
    for (var xt = [], zt = Y ? -1 : 1, Dt = z; mt > 1e-5; ) {
      var Jt = Dt + zt * Math.min(mt, wt);
      xt.push(j.call(this, N, Dt, Jt)), mt -= Math.abs(Jt - Dt), Dt = Jt;
    }
    return xt;
  }, j = function(N, z, V) {
    var Y = (V - z) / 2, ot = N * Math.cos(Y), wt = N * Math.sin(Y), mt = ot, xt = -wt, zt = mt * mt + xt * xt, Dt = zt + mt * ot + xt * wt, Jt = 4 / 3 * (Math.sqrt(2 * zt * Dt) - Dt) / (mt * wt - xt * ot), Qt = mt - Jt * xt, O = xt + Jt * mt, ct = Qt, U = -O, et = Y + z, J = Math.cos(et), rt = Math.sin(et);
    return { x1: N * Math.cos(z), y1: N * Math.sin(z), x2: Qt * J - O * rt, y2: Qt * rt + O * J, x3: ct * J - U * rt, y3: ct * rt + U * J, x4: N * Math.cos(V), y4: N * Math.sin(V) };
  }, Q = function(N) {
    return 180 * N / Math.PI;
  }, G = function(N, z, V, Y, ot, wt) {
    var mt = N + 0.5 * (V - N), xt = z + 0.5 * (Y - z), zt = ot + 0.5 * (V - ot), Dt = wt + 0.5 * (Y - wt), Jt = Math.min(N, ot, mt, zt), Qt = Math.max(N, ot, mt, zt), O = Math.min(z, wt, xt, Dt), ct = Math.max(z, wt, xt, Dt);
    return new a(Jt, O, Qt - Jt, ct - O);
  }, ft = function(N, z, V, Y, ot, wt, mt, xt) {
    var zt, Dt, Jt, Qt, O, ct, U, et, J, rt, vt, At, ht, Ot, $t = V - N, Ft = Y - z, Ut = ot - V, ie = wt - Y, oe = mt - ot, ae = xt - wt;
    for (Dt = 0; Dt < 41; Dt++) J = (U = (Jt = N + (zt = Dt / 40) * $t) + zt * ((O = V + zt * Ut) - Jt)) + zt * (O + zt * (ot + zt * oe - O) - U), rt = (et = (Qt = z + zt * Ft) + zt * ((ct = Y + zt * ie) - Qt)) + zt * (ct + zt * (wt + zt * ae - ct) - et), Dt == 0 ? (vt = J, At = rt, ht = J, Ot = rt) : (vt = Math.min(vt, J), At = Math.min(At, rt), ht = Math.max(ht, J), Ot = Math.max(Ot, rt));
    return new a(Math.round(vt), Math.round(At), Math.round(ht - vt), Math.round(Ot - At));
  }, nt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var N, z, V = (N = this.ctx.lineDash, z = this.ctx.lineDashOffset, JSON.stringify({ lineDash: N, lineDashOffset: z }));
      this.prevLineDash !== V && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = V);
    }
  };
})(Se.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(s) {
    var o, a, l, h, u, d, p, f, m, b;
    for (a = [], l = 0, h = (s += o = "\0\0\0\0".slice(s.length % 4 || 4)).length; h > l; l += 4) (u = (s.charCodeAt(l) << 24) + (s.charCodeAt(l + 1) << 16) + (s.charCodeAt(l + 2) << 8) + s.charCodeAt(l + 3)) !== 0 ? (d = (u = ((u = ((u = ((u = (u - (b = u % 85)) / 85) - (m = u % 85)) / 85) - (f = u % 85)) / 85) - (p = u % 85)) / 85) % 85, a.push(d + 33, p + 33, f + 33, m + 33, b + 33)) : a.push(122);
    return function(x, y) {
      for (var v = y; v > 0; v--) x.pop();
    }(a, o.length), String.fromCharCode.apply(String, a) + "~>";
  }, e = function(s) {
    var o, a, l, h, u, d = String, p = "length", f = 255, m = "charCodeAt", b = "slice", x = "replace";
    for (s[b](-2), s = s[b](0, -2)[x](/\s/g, "")[x]("z", "!!!!!"), l = [], h = 0, u = (s += o = "uuuuu"[b](s[p] % 5 || 5))[p]; u > h; h += 5) a = 52200625 * (s[m](h) - 33) + 614125 * (s[m](h + 1) - 33) + 7225 * (s[m](h + 2) - 33) + 85 * (s[m](h + 3) - 33) + (s[m](h + 4) - 33), l.push(f & a >> 24, f & a >> 16, f & a >> 8, f & a);
    return function(y, v) {
      for (var k = v; k > 0; k--) y.pop();
    }(l, o[p]), d.fromCharCode.apply(d, l);
  }, i = function(s) {
    var o = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), o.test(s) === !1) return "";
    for (var a = "", l = 0; l < s.length; l += 2) a += String.fromCharCode("0x" + (s[l] + s[l + 1]));
    return a;
  }, r = function(s) {
    for (var o = new Uint8Array(s.length), a = s.length; a--; ) o[a] = s.charCodeAt(a);
    return s = (o = hf(o)).reduce(function(l, h) {
      return l + String.fromCharCode(h);
    }, "");
  };
  n.processDataByFilters = function(s, o) {
    var a = 0, l = s || "", h = [];
    for (typeof (o = o || []) == "string" && (o = [o]), a = 0; a < o.length; a += 1) switch (o[a]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        l = e(l), h.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        l = t(l), h.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        l = i(l), h.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        l = l.split("").map(function(u) {
          return ("0" + u.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", h.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        l = r(l), h.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + o[a] + '" is not implemented');
    }
    return { data: l, reverseChain: h.reverse().join(" ") };
  };
}(Se.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.loadFile = function(t, e, i) {
    return function(r, s, o) {
      s = s !== !1, o = typeof o == "function" ? o : function() {
      };
      var a = void 0;
      try {
        a = function(l, h, u) {
          var d = new XMLHttpRequest(), p = 0, f = function(m) {
            var b = m.length, x = [], y = String.fromCharCode;
            for (p = 0; p < b; p += 1) x.push(y(255 & m.charCodeAt(p)));
            return x.join("");
          };
          if (d.open("GET", l, !h), d.overrideMimeType("text/plain; charset=x-user-defined"), h === !1 && (d.onload = function() {
            d.status === 200 ? u(f(this.responseText)) : u(void 0);
          }), d.send(null), h && d.status === 200) return f(d.responseText);
        }(r, s, o);
      } catch {
      }
      return a;
    }(t, e, i);
  }, n.loadImageFile = n.loadFile;
}(Se.API), function(n) {
  function t() {
    return (Ce.html2canvas ? Promise.resolve(Ce.html2canvas) : import("./html2canvas.esm-d2sM-0Wm.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load html2canvas: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  function e() {
    return (Ce.DOMPurify ? Promise.resolve(Ce.DOMPurify) : import("./purify.es-DD-6ZaCo.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load dompurify: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  var i = function(o) {
    var a = en(o);
    return a === "undefined" ? "undefined" : a === "string" || o instanceof String ? "string" : a === "number" || o instanceof Number ? "number" : a === "function" || o instanceof Function ? "function" : o && o.constructor === Array ? "array" : o && o.nodeType === 1 ? "element" : a === "object" ? "object" : "unknown";
  }, r = function(o, a) {
    var l = document.createElement(o);
    for (var h in a.className && (l.className = a.className), a.innerHTML && a.dompurify && (l.innerHTML = a.dompurify.sanitize(a.innerHTML)), a.style) l.style[h] = a.style[h];
    return l;
  }, s = function o(a) {
    var l = Object.assign(o.convert(Promise.resolve()), JSON.parse(JSON.stringify(o.template))), h = o.convert(Promise.resolve(), l);
    return h = (h = h.setProgress(1, o, 1, [o])).set(a);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(o, a) {
    return o.__proto__ = a || s.prototype, o;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(o, a) {
    return this.then(function() {
      switch (a = a || function(l) {
        switch (i(l)) {
          case "string":
            return "string";
          case "element":
            return l.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(o)) {
        case "string":
          return this.then(e).then(function(l) {
            return this.set({ src: r("div", { innerHTML: o, dompurify: l }) });
          });
        case "element":
          return this.set({ src: o });
        case "canvas":
          return this.set({ canvas: o });
        case "img":
          return this.set({ img: o });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(o) {
    switch (o) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var o = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, a = function l(h, u) {
        for (var d = h.nodeType === 3 ? document.createTextNode(h.nodeValue) : h.cloneNode(!1), p = h.firstChild; p; p = p.nextSibling) u !== !0 && p.nodeType === 1 && p.nodeName === "SCRIPT" || d.appendChild(l(p, u));
        return h.nodeType === 1 && (h.nodeName === "CANVAS" ? (d.width = h.width, d.height = h.height, d.getContext("2d").drawImage(h, 0, 0)) : h.nodeName !== "TEXTAREA" && h.nodeName !== "SELECT" || (d.value = h.value), d.addEventListener("load", function() {
          d.scrollTop = h.scrollTop, d.scrollLeft = h.scrollLeft;
        }, !0)), d;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      a.tagName === "BODY" && (o.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = r("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = r("div", { className: "html2pdf__container", style: o }), this.prop.container.appendChild(a), this.prop.container.firstChild.appendChild(r("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = Object.assign({}, this.opt.html2canvas);
      return delete l.onrendered, a(this.prop.container, l);
    }).then(function(a) {
      (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = this.opt.jsPDF, h = this.opt.fontFaces, u = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, d = Object.assign({ async: !0, allowTaint: !0, scale: u, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete d.onrendered, l.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, l.context2d.posX = this.opt.x, l.context2d.posY = this.opt.y, l.context2d.margin = this.opt.margin, l.context2d.fontFaces = h, h) for (var p = 0; p < h.length; ++p) {
        var f = h[p], m = f.src.find(function(b) {
          return b.format === "truetype";
        });
        m && l.addFont(m.url, f.ref.name, f.ref.style);
      }
      return d.windowHeight = d.windowHeight || 0, d.windowHeight = d.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : d.windowHeight, l.context2d.save(!0), a(this.prop.container, d);
    }).then(function(a) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var o = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = o;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(o, a, l) {
    return (l = l || "pdf").toLowerCase() === "img" || l.toLowerCase() === "image" ? this.outputImg(o, a) : this.outputPdf(o, a);
  }, s.prototype.outputPdf = function(o, a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(o, a);
    });
  }, s.prototype.outputImg = function(o) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (o) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + o + '" is not supported.';
      }
    });
  }, s.prototype.save = function(o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(o ? { filename: o } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(o) {
    if (i(o) !== "object") return this;
    var a = Object.keys(o || {}).map(function(l) {
      if (l in s.template.prop) return function() {
        this.prop[l] = o[l];
      };
      switch (l) {
        case "margin":
          return this.setMargin.bind(this, o.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = o.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, o.pageSize);
        default:
          return function() {
            this.opt[l] = o[l];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(a);
    });
  }, s.prototype.get = function(o, a) {
    return this.then(function() {
      var l = o in s.template.prop ? this.prop[o] : this.opt[o];
      return a ? a(l) : l;
    });
  }, s.prototype.setMargin = function(o) {
    return this.then(function() {
      switch (i(o)) {
        case "number":
          o = [o, o, o, o];
        case "array":
          if (o.length === 2 && (o = [o[0], o[1], o[0], o[1]]), o.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = o;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(o) {
    function a(l, h) {
      return Math.floor(l * h / 72 * 96);
    }
    return this.then(function() {
      (o = o || Se.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (o.inner = { width: o.width - this.opt.margin[1] - this.opt.margin[3], height: o.height - this.opt.margin[0] - this.opt.margin[2] }, o.inner.px = { width: a(o.inner.width, o.k), height: a(o.inner.height, o.k) }, o.inner.ratio = o.inner.height / o.inner.width), this.prop.pageSize = o;
    });
  }, s.prototype.setProgress = function(o, a, l, h) {
    return o != null && (this.progress.val = o), a != null && (this.progress.state = a), l != null && (this.progress.n = l), h != null && (this.progress.stack = h), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(o, a, l, h) {
    return this.setProgress(o ? this.progress.val + o : null, a || null, l ? this.progress.n + l : null, h ? this.progress.stack.concat(h) : null);
  }, s.prototype.then = function(o, a) {
    var l = this;
    return this.thenCore(o, a, function(h, u) {
      return l.updateProgress(null, null, 1, [h]), Promise.prototype.then.call(this, function(d) {
        return l.updateProgress(null, h), d;
      }).then(h, u).then(function(d) {
        return l.updateProgress(1), d;
      });
    });
  }, s.prototype.thenCore = function(o, a, l) {
    l = l || Promise.prototype.then, o && (o = o.bind(this)), a && (a = a.bind(this));
    var h = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), u = l.call(h, o, a);
    return s.convert(u, this.__proto__);
  }, s.prototype.thenExternal = function(o, a) {
    return Promise.prototype.then.call(this, o, a);
  }, s.prototype.thenList = function(o) {
    var a = this;
    return o.forEach(function(l) {
      a = a.thenCore(l);
    }), a;
  }, s.prototype.catch = function(o) {
    o && (o = o.bind(this));
    var a = Promise.prototype.catch.call(this, o);
    return s.convert(a, this);
  }, s.prototype.catchExternal = function(o) {
    return Promise.prototype.catch.call(this, o);
  }, s.prototype.error = function(o) {
    return this.then(function() {
      throw new Error(o);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Se.getPageSize = function(o, a, l) {
    if (en(o) === "object") {
      var h = o;
      o = h.orientation, a = h.unit || a, l = h.format || l;
    }
    a = a || "mm", l = l || "a4", o = ("" + (o || "P")).toLowerCase();
    var u, d = ("" + l).toLowerCase(), p = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (a) {
      case "pt":
        u = 1;
        break;
      case "mm":
        u = 72 / 25.4;
        break;
      case "cm":
        u = 72 / 2.54;
        break;
      case "in":
        u = 72;
        break;
      case "px":
        u = 0.75;
        break;
      case "pc":
      case "em":
        u = 12;
        break;
      case "ex":
        u = 6;
        break;
      default:
        throw "Invalid unit: " + a;
    }
    var f, m = 0, b = 0;
    if (p.hasOwnProperty(d)) m = p[d][1] / u, b = p[d][0] / u;
    else try {
      m = l[1], b = l[0];
    } catch {
      throw new Error("Invalid format: " + l);
    }
    if (o === "p" || o === "portrait") o = "p", b > m && (f = b, b = m, m = f);
    else {
      if (o !== "l" && o !== "landscape") throw "Invalid orientation: " + o;
      o = "l", m > b && (f = b, b = m, m = f);
    }
    return { width: b, height: m, unit: a, k: u, orientation: o };
  }, n.html = function(o, a) {
    (a = a || {}).callback = a.callback || function() {
    }, a.html2canvas = a.html2canvas || {}, a.html2canvas.canvas = a.html2canvas.canvas || this.canvas, a.jsPDF = a.jsPDF || this, a.fontFaces = a.fontFaces ? a.fontFaces.map(yf) : null;
    var l = new s(a);
    return a.worker ? l : l.from(o).doCallback();
  };
}(Se.API), Se.API.addJS = function(n) {
  return ig = n, this.internal.events.subscribe("postPutResources", function() {
    Pu = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Pu + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), ng = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + ig + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Pu !== void 0 && ng !== void 0 && this.internal.out("/Names <</JavaScript " + Pu + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t;
  n.events.push(["postPutResources", function() {
    var e = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var r = e.outline.render().split(/\r\n/), s = 0; s < r.length; s++) {
      var o = r[s], a = i.exec(o);
      if (a != null) {
        var l = a[1];
        e.internal.newObjectDeferredBegin(l, !1);
      }
      e.internal.write(o);
    }
    if (this.outline.createNamedDestinations) {
      var h = this.internal.pages.length, u = [];
      for (s = 0; s < h; s++) {
        var d = e.internal.newObject();
        u.push(d);
        var p = e.internal.getPageInfo(s + 1);
        e.internal.write("<< /D[" + p.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f = e.internal.newObject();
      for (e.internal.write("<< /Names [ "), s = 0; s < u.length; s++) e.internal.write("(page_" + (s + 1) + ")" + u[s] + " 0 R");
      e.internal.write(" ] >>", "endobj"), t = e.internal.newObject(), e.internal.write("<< /Dests " + f + " 0 R"), e.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + t + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var e = this;
    e.outline = { createNamedDestinations: !1, root: { children: [] } }, e.outline.add = function(i, r, s) {
      var o = { title: r, options: s, children: [] };
      return i == null && (i = this.root), i.children.push(o), o;
    }, e.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = e, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, e.outline.genIds_r = function(i) {
      i.id = e.internal.newObjectDeferred();
      for (var r = 0; r < i.children.length; r++) this.genIds_r(i.children[r]);
    }, e.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, e.outline.renderItems = function(i) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < i.children.length; s++) {
        var o = i.children[s];
        this.objStart(o), this.line("/Title " + this.makeString(o.title)), this.line("/Parent " + this.makeRef(i)), s > 0 && this.line("/Prev " + this.makeRef(i.children[s - 1])), s < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[s + 1])), o.children.length > 0 && (this.line("/First " + this.makeRef(o.children[0])), this.line("/Last " + this.makeRef(o.children[o.children.length - 1])));
        var a = this.count = this.count_r({ count: 0 }, o);
        if (a > 0 && this.line("/Count " + a), o.options && o.options.pageNumber) {
          var l = e.internal.getPageInfo(o.options.pageNumber);
          this.line("/Dest [" + l.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var h = 0; h < i.children.length; h++) this.renderItems(i.children[h]);
    }, e.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, e.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, e.outline.makeString = function(i) {
      return "(" + e.internal.pdfEscape(i) + ")";
    }, e.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, e.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, e.outline.count_r = function(i, r) {
      for (var s = 0; s < r.children.length; s++) i.count++, this.count_r(i, r.children[s]);
      return i.count;
    };
  }]);
}(Se.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(e, i, r, s, o, a) {
    var l, h = this.decode.DCT_DECODE, u = null;
    if (typeof e == "string" || this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) {
      switch (e = o || e, e = this.__addimage__.isArrayBuffer(e) ? new Uint8Array(e) : e, (l = function(d) {
        for (var p, f = 256 * d.charCodeAt(4) + d.charCodeAt(5), m = d.length, b = { width: 0, height: 0, numcomponents: 1 }, x = 4; x < m; x += 2) {
          if (x += f, t.indexOf(d.charCodeAt(x + 1)) !== -1) {
            p = 256 * d.charCodeAt(x + 5) + d.charCodeAt(x + 6), b = { width: 256 * d.charCodeAt(x + 7) + d.charCodeAt(x + 8), height: p, numcomponents: d.charCodeAt(x + 9) };
            break;
          }
          f = 256 * d.charCodeAt(x + 2) + d.charCodeAt(x + 3);
        }
        return b;
      }(e = this.__addimage__.isArrayBufferView(e) ? this.__addimage__.arrayBufferToBinaryString(e) : e)).numcomponents) {
        case 1:
          a = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          a = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          a = this.color_spaces.DEVICE_RGB;
      }
      u = { data: e, width: l.width, height: l.height, colorSpace: a, bitsPerComponent: 8, filter: h, index: i, alias: r };
    }
    return u;
  };
}(Se.API);
var ra, Lu, rg, sg, og, Mv = function() {
  var n, t, e;
  function i(s) {
    var o, a, l, h, u, d, p, f, m, b, x, y, v, k;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, d = null; ; ) {
      switch (o = this.readUInt32(), m = (function() {
        var C, E;
        for (E = [], C = 0; C < 4; ++C) E.push(String.fromCharCode(this.data[this.pos++]));
        return E;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(o);
          break;
        case "fcTL":
          d && this.animation.frames.push(d), this.pos += 4, d = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, u = this.readUInt16(), h = this.readUInt16() || 100, d.delay = 1e3 * u / h, d.disposeOp = this.data[this.pos++], d.blendOp = this.data[this.pos++], d.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (m === "fdAT" && (this.pos += 4, o -= 4), s = (d != null ? d.data : void 0) || this.imgData, y = 0; 0 <= o ? y < o : y > o; 0 <= o ? ++y : --y) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (l = this.palette.length / 3, this.transparency.indexed = this.read(o), this.transparency.indexed.length > l) throw new Error("More transparent colors than palette size");
              if ((b = l - this.transparency.indexed.length) > 0) for (v = 0; 0 <= b ? v < b : v > b; 0 <= b ? ++v : --v) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(o)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(o);
          }
          break;
        case "tEXt":
          p = (x = this.read(o)).indexOf(0), f = String.fromCharCode.apply(String, x.slice(0, p)), this.text[f] = String.fromCharCode.apply(String, x.slice(p + 1));
          break;
        case "IEND":
          return d && this.animation.frames.push(d), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (k = this.colorType) === 4 || k === 6, a = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += o;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  i.prototype.read = function(s) {
    var o, a;
    for (a = [], o = 0; 0 <= s ? o < s : o > s; 0 <= s ? ++o : --o) a.push(this.data[this.pos++]);
    return a;
  }, i.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.decodePixels = function(s) {
    var o = this.pixelBitlength / 8, a = new Uint8Array(this.width * this.height * o), l = 0, h = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function u(d, p, f, m) {
      var b, x, y, v, k, C, E, q, T, F, M, B, P, A, I, S, X, H, j, Q, G, ft = Math.ceil((h.width - d) / f), nt = Math.ceil((h.height - p) / m), N = h.width == ft && h.height == nt;
      for (A = o * ft, B = N ? a : new Uint8Array(A * nt), C = s.length, P = 0, x = 0; P < nt && l < C; ) {
        switch (s[l++]) {
          case 0:
            for (v = X = 0; X < A; v = X += 1) B[x++] = s[l++];
            break;
          case 1:
            for (v = H = 0; H < A; v = H += 1) b = s[l++], k = v < o ? 0 : B[x - o], B[x++] = (b + k) % 256;
            break;
          case 2:
            for (v = j = 0; j < A; v = j += 1) b = s[l++], y = (v - v % o) / o, I = P && B[(P - 1) * A + y * o + v % o], B[x++] = (I + b) % 256;
            break;
          case 3:
            for (v = Q = 0; Q < A; v = Q += 1) b = s[l++], y = (v - v % o) / o, k = v < o ? 0 : B[x - o], I = P && B[(P - 1) * A + y * o + v % o], B[x++] = (b + Math.floor((k + I) / 2)) % 256;
            break;
          case 4:
            for (v = G = 0; G < A; v = G += 1) b = s[l++], y = (v - v % o) / o, k = v < o ? 0 : B[x - o], P === 0 ? I = S = 0 : (I = B[(P - 1) * A + y * o + v % o], S = y && B[(P - 1) * A + (y - 1) * o + v % o]), E = k + I - S, q = Math.abs(E - k), F = Math.abs(E - I), M = Math.abs(E - S), T = q <= F && q <= M ? k : F <= M ? I : S, B[x++] = (b + T) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[l - 1]);
        }
        if (!N) {
          var z = ((p + P * m) * h.width + d) * o, V = P * A;
          for (v = 0; v < ft; v += 1) {
            for (var Y = 0; Y < o; Y += 1) a[z++] = B[V++];
            z += (f - 1) * o;
          }
        }
        P++;
      }
    }
    return s = fv(s), h.interlaceMethod == 1 ? (u(0, 0, 8, 8), u(4, 0, 8, 8), u(0, 4, 4, 8), u(2, 0, 4, 4), u(0, 2, 2, 4), u(1, 0, 2, 2), u(0, 1, 1, 2)) : u(0, 0, 1, 1), a;
  }, i.prototype.decodePalette = function() {
    var s, o, a, l, h, u, d, p, f;
    for (a = this.palette, u = this.transparency.indexed || [], h = new Uint8Array((u.length || 0) + a.length), l = 0, s = 0, o = d = 0, p = a.length; d < p; o = d += 3) h[l++] = a[o], h[l++] = a[o + 1], h[l++] = a[o + 2], h[l++] = (f = u[s++]) != null ? f : 255;
    return h;
  }, i.prototype.copyToImageData = function(s, o) {
    var a, l, h, u, d, p, f, m, b, x, y;
    if (l = this.colors, b = null, a = this.hasAlphaChannel, this.palette.length && (b = (y = this._decodedPalette) != null ? y : this._decodedPalette = this.decodePalette(), l = 4, a = !0), m = (h = s.data || s).length, d = b || o, u = p = 0, l === 1) for (; u < m; ) f = b ? 4 * o[u / 4] : p, x = d[f++], h[u++] = x, h[u++] = x, h[u++] = x, h[u++] = a ? d[f++] : 255, p = f;
    else for (; u < m; ) f = b ? 4 * o[u / 4] : p, h[u++] = d[f++], h[u++] = d[f++], h[u++] = d[f++], h[u++] = a ? d[f++] : 255, p = f;
  }, i.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var r = function() {
    if (Object.prototype.toString.call(Ce) === "[object Window]") {
      try {
        t = Ce.document.createElement("canvas"), e = t.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return r(), n = function(s) {
    var o;
    if (r() === !0) return e.width = s.width, e.height = s.height, e.clearRect(0, 0, s.width, s.height), e.putImageData(s, 0, 0), (o = new Image()).src = t.toDataURL(), o;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, i.prototype.decodeFrames = function(s) {
    var o, a, l, h, u, d, p, f;
    if (this.animation) {
      for (f = [], a = u = 0, d = (p = this.animation.frames).length; u < d; a = ++u) o = p[a], l = s.createImageData(o.width, o.height), h = this.decodePixels(new Uint8Array(o.data)), this.copyToImageData(l, h), o.imageData = l, f.push(o.image = n(l));
      return f;
    }
  }, i.prototype.renderFrame = function(s, o) {
    var a, l, h;
    return a = (l = this.animation.frames)[o], h = l[o - 1], o === 0 && s.clearRect(0, 0, this.width, this.height), (h != null ? h.disposeOp : void 0) === 1 ? s.clearRect(h.xOffset, h.yOffset, h.width, h.height) : (h != null ? h.disposeOp : void 0) === 2 && s.putImageData(h.imageData, h.xOffset, h.yOffset), a.blendOp === 0 && s.clearRect(a.xOffset, a.yOffset, a.width, a.height), s.drawImage(a.image, a.xOffset, a.yOffset);
  }, i.prototype.animate = function(s) {
    var o, a, l, h, u, d, p = this;
    return a = 0, d = this.animation, h = d.numFrames, l = d.frames, u = d.numPlays, (o = function() {
      var f, m;
      if (f = a++ % h, m = l[f], p.renderFrame(s, f), h > 1 && a / h < u) return p.animation._timeout = setTimeout(o, m.delay);
    })();
  }, i.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, i.prototype.render = function(s) {
    var o, a;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, o = s.getContext("2d"), this.animation ? (this.decodeFrames(o), this.animate(o)) : (a = o.createImageData(this.width, this.height), this.copyToImageData(a, this.decodePixels()), o.putImageData(a, 0, 0));
  }, i;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Rv(n) {
  var t = 0;
  if (n[t++] !== 71 || n[t++] !== 73 || n[t++] !== 70 || n[t++] !== 56 || (n[t++] + 1 & 253) != 56 || n[t++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var e = n[t++] | n[t++] << 8, i = n[t++] | n[t++] << 8, r = n[t++], s = r >> 7, o = 1 << (7 & r) + 1;
  n[t++], n[t++];
  var a = null, l = null;
  s && (a = t, l = o, t += 3 * o);
  var h = !0, u = [], d = 0, p = null, f = 0, m = null;
  for (this.width = e, this.height = i; h && t < n.length; ) switch (n[t++]) {
    case 33:
      switch (n[t++]) {
        case 255:
          if (n[t] !== 11 || n[t + 1] == 78 && n[t + 2] == 69 && n[t + 3] == 84 && n[t + 4] == 83 && n[t + 5] == 67 && n[t + 6] == 65 && n[t + 7] == 80 && n[t + 8] == 69 && n[t + 9] == 50 && n[t + 10] == 46 && n[t + 11] == 48 && n[t + 12] == 3 && n[t + 13] == 1 && n[t + 16] == 0) t += 14, m = n[t++] | n[t++] << 8, t++;
          else for (t += 12; ; ) {
            if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
            if (P === 0) break;
            t += P;
          }
          break;
        case 249:
          if (n[t++] !== 4 || n[t + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var b = n[t++];
          d = n[t++] | n[t++] << 8, p = n[t++], !(1 & b) && (p = null), f = b >> 2 & 7, t++;
          break;
        case 254:
          for (; ; ) {
            if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
            if (P === 0) break;
            t += P;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + n[t - 1].toString(16));
      }
      break;
    case 44:
      var x = n[t++] | n[t++] << 8, y = n[t++] | n[t++] << 8, v = n[t++] | n[t++] << 8, k = n[t++] | n[t++] << 8, C = n[t++], E = C >> 6 & 1, q = 1 << (7 & C) + 1, T = a, F = l, M = !1;
      C >> 7 && (M = !0, T = t, F = q, t += 3 * q);
      var B = t;
      for (t++; ; ) {
        var P;
        if (!((P = n[t++]) >= 0)) throw Error("Invalid block size");
        if (P === 0) break;
        t += P;
      }
      u.push({ x, y, width: v, height: k, has_local_palette: M, palette_offset: T, palette_size: F, data_offset: B, data_length: t - B, transparent_index: p, interlaced: !!E, delay: d, disposal: f });
      break;
    case 59:
      h = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + n[t - 1].toString(16));
  }
  this.numFrames = function() {
    return u.length;
  }, this.loopCount = function() {
    return m;
  }, this.frameInfo = function(A) {
    if (A < 0 || A >= u.length) throw new Error("Frame index out of range.");
    return u[A];
  }, this.decodeAndBlitFrameBGRA = function(A, I) {
    var S = this.frameInfo(A), X = S.width * S.height, H = new Uint8Array(X);
    ag(n, S.data_offset, H, X);
    var j = S.palette_offset, Q = S.transparent_index;
    Q === null && (Q = 256);
    var G = S.width, ft = e - G, nt = G, N = 4 * (S.y * e + S.x), z = 4 * ((S.y + S.height) * e + S.x), V = N, Y = 4 * ft;
    S.interlaced === !0 && (Y += 4 * e * 7);
    for (var ot = 8, wt = 0, mt = H.length; wt < mt; ++wt) {
      var xt = H[wt];
      if (nt === 0 && (nt = G, (V += Y) >= z && (Y = 4 * ft + 4 * e * (ot - 1), V = N + (G + ft) * (ot << 1), ot >>= 1)), xt === Q) V += 4;
      else {
        var zt = n[j + 3 * xt], Dt = n[j + 3 * xt + 1], Jt = n[j + 3 * xt + 2];
        I[V++] = Jt, I[V++] = Dt, I[V++] = zt, I[V++] = 255;
      }
      --nt;
    }
  }, this.decodeAndBlitFrameRGBA = function(A, I) {
    var S = this.frameInfo(A), X = S.width * S.height, H = new Uint8Array(X);
    ag(n, S.data_offset, H, X);
    var j = S.palette_offset, Q = S.transparent_index;
    Q === null && (Q = 256);
    var G = S.width, ft = e - G, nt = G, N = 4 * (S.y * e + S.x), z = 4 * ((S.y + S.height) * e + S.x), V = N, Y = 4 * ft;
    S.interlaced === !0 && (Y += 4 * e * 7);
    for (var ot = 8, wt = 0, mt = H.length; wt < mt; ++wt) {
      var xt = H[wt];
      if (nt === 0 && (nt = G, (V += Y) >= z && (Y = 4 * ft + 4 * e * (ot - 1), V = N + (G + ft) * (ot << 1), ot >>= 1)), xt === Q) V += 4;
      else {
        var zt = n[j + 3 * xt], Dt = n[j + 3 * xt + 1], Jt = n[j + 3 * xt + 2];
        I[V++] = zt, I[V++] = Dt, I[V++] = Jt, I[V++] = 255;
      }
      --nt;
    }
  };
}
function ag(n, t, e, i) {
  for (var r = n[t++], s = 1 << r, o = s + 1, a = o + 1, l = r + 1, h = (1 << l) - 1, u = 0, d = 0, p = 0, f = n[t++], m = new Int32Array(4096), b = null; ; ) {
    for (; u < 16 && f !== 0; ) d |= n[t++] << u, u += 8, f === 1 ? f = n[t++] : --f;
    if (u < l) break;
    var x = d & h;
    if (d >>= l, u -= l, x !== s) {
      if (x === o) break;
      for (var y = x < a ? x : b, v = 0, k = y; k > s; ) k = m[k] >> 8, ++v;
      var C = k;
      if (p + v + (y !== x ? 1 : 0) > i) return void an.log("Warning, gif stream longer than expected.");
      e[p++] = C;
      var E = p += v;
      for (y !== x && (e[p++] = C), k = y; v--; ) k = m[k], e[--E] = 255 & k, k >>= 8;
      b !== null && a < 4096 && (m[a++] = b << 8 | C, a >= h + 1 && l < 12 && (++l, h = h << 1 | 1)), b = x;
    } else a = o + 1, h = (1 << (l = r + 1)) - 1, b = null;
  }
  return p !== i && an.log("Warning, gif stream shorter than expected."), e;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ih(n) {
  var t, e, i, r, s, o = Math.floor, a = new Array(64), l = new Array(64), h = new Array(64), u = new Array(64), d = new Array(65535), p = new Array(65535), f = new Array(64), m = new Array(64), b = [], x = 0, y = 7, v = new Array(64), k = new Array(64), C = new Array(64), E = new Array(256), q = new Array(2048), T = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], F = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], B = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], A = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], S = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], X = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function H(N, z) {
    for (var V = 0, Y = 0, ot = new Array(), wt = 1; wt <= 16; wt++) {
      for (var mt = 1; mt <= N[wt]; mt++) ot[z[Y]] = [], ot[z[Y]][0] = V, ot[z[Y]][1] = wt, Y++, V++;
      V *= 2;
    }
    return ot;
  }
  function j(N) {
    for (var z = N[0], V = N[1] - 1; V >= 0; ) z & 1 << V && (x |= 1 << y), V--, --y < 0 && (x == 255 ? (Q(255), Q(0)) : Q(x), y = 7, x = 0);
  }
  function Q(N) {
    b.push(N);
  }
  function G(N) {
    Q(N >> 8 & 255), Q(255 & N);
  }
  function ft(N, z, V, Y, ot) {
    for (var wt, mt = ot[0], xt = ot[240], zt = function(rt, vt) {
      var At, ht, Ot, $t, Ft, Ut, ie, oe, ae, dt, kt = 0;
      for (ae = 0; ae < 8; ++ae) {
        At = rt[kt], ht = rt[kt + 1], Ot = rt[kt + 2], $t = rt[kt + 3], Ft = rt[kt + 4], Ut = rt[kt + 5], ie = rt[kt + 6];
        var te = At + (oe = rt[kt + 7]), Rt = At - oe, be = ht + ie, Kt = ht - ie, jt = Ot + Ut, ge = Ot - Ut, we = $t + Ft, Rn = $t - Ft, Ze = te + we, Dn = te - we, fn = be + jt, We = be - jt;
        rt[kt] = Ze + fn, rt[kt + 4] = Ze - fn;
        var ke = 0.707106781 * (We + Dn);
        rt[kt + 2] = Dn + ke, rt[kt + 6] = Dn - ke;
        var He = 0.382683433 * ((Ze = Rn + ge) - (We = Kt + Rt)), tr = 0.5411961 * Ze + He, En = 1.306562965 * We + He, Bi = 0.707106781 * (fn = ge + Kt), mn = Rt + Bi, xe = Rt - Bi;
        rt[kt + 5] = xe + tr, rt[kt + 3] = xe - tr, rt[kt + 1] = mn + En, rt[kt + 7] = mn - En, kt += 8;
      }
      for (kt = 0, ae = 0; ae < 8; ++ae) {
        At = rt[kt], ht = rt[kt + 8], Ot = rt[kt + 16], $t = rt[kt + 24], Ft = rt[kt + 32], Ut = rt[kt + 40], ie = rt[kt + 48];
        var Ai = At + (oe = rt[kt + 56]), ji = At - oe, ti = ht + ie, vn = ht - ie, wn = Ot + Ut, ui = Ot - Ut, ss = $t + Ft, er = $t - Ft, gi = Ai + ss, Ni = Ai - ss, Ci = ti + wn, qi = ti - wn;
        rt[kt] = gi + Ci, rt[kt + 32] = gi - Ci;
        var Pi = 0.707106781 * (qi + Ni);
        rt[kt + 16] = Ni + Pi, rt[kt + 48] = Ni - Pi;
        var zi = 0.382683433 * ((gi = er + ui) - (qi = vn + ji)), wr = 0.5411961 * gi + zi, Dr = 1.306562965 * qi + zi, nr = 0.707106781 * (Ci = ui + vn), Br = ji + nr, jr = ji - nr;
        rt[kt + 40] = jr + wr, rt[kt + 24] = jr - wr, rt[kt + 8] = Br + Dr, rt[kt + 56] = Br - Dr, kt++;
      }
      for (ae = 0; ae < 64; ++ae) dt = rt[ae] * vt[ae], f[ae] = dt > 0 ? dt + 0.5 | 0 : dt - 0.5 | 0;
      return f;
    }(N, z), Dt = 0; Dt < 64; ++Dt) m[T[Dt]] = zt[Dt];
    var Jt = m[0] - V;
    V = m[0], Jt == 0 ? j(Y[0]) : (j(Y[p[wt = 32767 + Jt]]), j(d[wt]));
    for (var Qt = 63; Qt > 0 && m[Qt] == 0; ) Qt--;
    if (Qt == 0) return j(mt), V;
    for (var O, ct = 1; ct <= Qt; ) {
      for (var U = ct; m[ct] == 0 && ct <= Qt; ) ++ct;
      var et = ct - U;
      if (et >= 16) {
        O = et >> 4;
        for (var J = 1; J <= O; ++J) j(xt);
        et &= 15;
      }
      wt = 32767 + m[ct], j(ot[(et << 4) + p[wt]]), j(d[wt]), ct++;
    }
    return Qt != 63 && j(mt), V;
  }
  function nt(N) {
    N = Math.min(Math.max(N, 1), 100), s != N && (function(z) {
      for (var V = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Y = 0; Y < 64; Y++) {
        var ot = o((V[Y] * z + 50) / 100);
        ot = Math.min(Math.max(ot, 1), 255), a[T[Y]] = ot;
      }
      for (var wt = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], mt = 0; mt < 64; mt++) {
        var xt = o((wt[mt] * z + 50) / 100);
        xt = Math.min(Math.max(xt, 1), 255), l[T[mt]] = xt;
      }
      for (var zt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Dt = 0, Jt = 0; Jt < 8; Jt++) for (var Qt = 0; Qt < 8; Qt++) h[Dt] = 1 / (a[T[Dt]] * zt[Jt] * zt[Qt] * 8), u[Dt] = 1 / (l[T[Dt]] * zt[Jt] * zt[Qt] * 8), Dt++;
    }(N < 50 ? Math.floor(5e3 / N) : Math.floor(200 - 2 * N)), s = N);
  }
  this.encode = function(N, z) {
    z && nt(z), b = new Array(), x = 0, y = 7, G(65496), G(65504), G(16), Q(74), Q(70), Q(73), Q(70), Q(0), Q(1), Q(1), Q(0), G(1), G(1), Q(0), Q(0), function() {
      G(65499), G(132), Q(0);
      for (var ht = 0; ht < 64; ht++) Q(a[ht]);
      Q(1);
      for (var Ot = 0; Ot < 64; Ot++) Q(l[Ot]);
    }(), function(ht, Ot) {
      G(65472), G(17), Q(8), G(Ot), G(ht), Q(3), Q(1), Q(17), Q(0), Q(2), Q(17), Q(1), Q(3), Q(17), Q(1);
    }(N.width, N.height), function() {
      G(65476), G(418), Q(0);
      for (var ht = 0; ht < 16; ht++) Q(F[ht + 1]);
      for (var Ot = 0; Ot <= 11; Ot++) Q(M[Ot]);
      Q(16);
      for (var $t = 0; $t < 16; $t++) Q(B[$t + 1]);
      for (var Ft = 0; Ft <= 161; Ft++) Q(P[Ft]);
      Q(1);
      for (var Ut = 0; Ut < 16; Ut++) Q(A[Ut + 1]);
      for (var ie = 0; ie <= 11; ie++) Q(I[ie]);
      Q(17);
      for (var oe = 0; oe < 16; oe++) Q(S[oe + 1]);
      for (var ae = 0; ae <= 161; ae++) Q(X[ae]);
    }(), G(65498), G(12), Q(3), Q(1), Q(0), Q(2), Q(17), Q(3), Q(17), Q(0), Q(63), Q(0);
    var V = 0, Y = 0, ot = 0;
    x = 0, y = 7, this.encode.displayName = "_encode_";
    for (var wt, mt, xt, zt, Dt, Jt, Qt, O, ct, U = N.data, et = N.width, J = N.height, rt = 4 * et, vt = 0; vt < J; ) {
      for (wt = 0; wt < rt; ) {
        for (Dt = rt * vt + wt, Qt = -1, O = 0, ct = 0; ct < 64; ct++) Jt = Dt + (O = ct >> 3) * rt + (Qt = 4 * (7 & ct)), vt + O >= J && (Jt -= rt * (vt + 1 + O - J)), wt + Qt >= rt && (Jt -= wt + Qt - rt + 4), mt = U[Jt++], xt = U[Jt++], zt = U[Jt++], v[ct] = (q[mt] + q[xt + 256 >> 0] + q[zt + 512 >> 0] >> 16) - 128, k[ct] = (q[mt + 768 >> 0] + q[xt + 1024 >> 0] + q[zt + 1280 >> 0] >> 16) - 128, C[ct] = (q[mt + 1280 >> 0] + q[xt + 1536 >> 0] + q[zt + 1792 >> 0] >> 16) - 128;
        V = ft(v, h, V, t, i), Y = ft(k, u, Y, e, r), ot = ft(C, u, ot, e, r), wt += 32;
      }
      vt += 8;
    }
    if (y >= 0) {
      var At = [];
      At[1] = y + 1, At[0] = (1 << y + 1) - 1, j(At);
    }
    return G(65497), new Uint8Array(b);
  }, n = n || 50, function() {
    for (var N = String.fromCharCode, z = 0; z < 256; z++) E[z] = N(z);
  }(), t = H(F, M), e = H(A, I), i = H(B, P), r = H(S, X), function() {
    for (var N = 1, z = 2, V = 1; V <= 15; V++) {
      for (var Y = N; Y < z; Y++) p[32767 + Y] = V, d[32767 + Y] = [], d[32767 + Y][1] = V, d[32767 + Y][0] = Y;
      for (var ot = -(z - 1); ot <= -N; ot++) p[32767 + ot] = V, d[32767 + ot] = [], d[32767 + ot][1] = V, d[32767 + ot][0] = z - 1 + ot;
      N <<= 1, z <<= 1;
    }
  }(), function() {
    for (var N = 0; N < 256; N++) q[N] = 19595 * N, q[N + 256 >> 0] = 38470 * N, q[N + 512 >> 0] = 7471 * N + 32768, q[N + 768 >> 0] = -11059 * N, q[N + 1024 >> 0] = -21709 * N, q[N + 1280 >> 0] = 32768 * N + 8421375, q[N + 1536 >> 0] = -27439 * N, q[N + 1792 >> 0] = -5329 * N;
  }(), nt(n);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function lr(n, t) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!t, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function lg(n) {
  function t(F) {
    if (!F) throw Error("assert :P");
  }
  function e(F, M, B) {
    for (var P = 0; 4 > P; P++) if (F[M + P] != B.charCodeAt(P)) return !0;
    return !1;
  }
  function i(F, M, B, P, A) {
    for (var I = 0; I < A; I++) F[M + I] = B[P + I];
  }
  function r(F, M, B, P) {
    for (var A = 0; A < P; A++) F[M + A] = B;
  }
  function s(F) {
    return new Int32Array(F);
  }
  function o(F, M) {
    for (var B = [], P = 0; P < F; P++) B.push(new M());
    return B;
  }
  function a(F, M) {
    var B = [];
    return function P(A, I, S) {
      for (var X = S[I], H = 0; H < X && (A.push(S.length > I + 1 ? [] : new M()), !(S.length < I + 1)); H++) P(A[H], I + 1, S);
    }(B, 0, F), B;
  }
  var l = function() {
    var F = this;
    function M(c, g) {
      for (var _ = 1 << g - 1 >>> 0; c & _; ) _ >>>= 1;
      return _ ? (c & _ - 1) + _ : c;
    }
    function B(c, g, _, L, R) {
      t(!(L % _));
      do
        c[g + (L -= _)] = R;
      while (0 < L);
    }
    function P(c, g, _, L, R) {
      if (t(2328 >= R), 512 >= R) var $ = s(512);
      else if (($ = s(R)) == null) return 0;
      return function(W, K, Z, it, yt, Lt) {
        var It, Ct, Vt = K, Mt = 1 << Z, bt = s(16), St = s(16);
        for (t(yt != 0), t(it != null), t(W != null), t(0 < Z), Ct = 0; Ct < yt; ++Ct) {
          if (15 < it[Ct]) return 0;
          ++bt[it[Ct]];
        }
        if (bt[0] == yt) return 0;
        for (St[1] = 0, It = 1; 15 > It; ++It) {
          if (bt[It] > 1 << It) return 0;
          St[It + 1] = St[It] + bt[It];
        }
        for (Ct = 0; Ct < yt; ++Ct) It = it[Ct], 0 < it[Ct] && (Lt[St[It]++] = Ct);
        if (St[15] == 1) return (it = new A()).g = 0, it.value = Lt[0], B(W, Vt, 1, Mt, it), Mt;
        var Ht, Yt = -1, Gt = Mt - 1, ce = 0, re = 1, _e = 1, se = 1 << Z;
        for (Ct = 0, It = 1, yt = 2; It <= Z; ++It, yt <<= 1) {
          if (re += _e <<= 1, 0 > (_e -= bt[It])) return 0;
          for (; 0 < bt[It]; --bt[It]) (it = new A()).g = It, it.value = Lt[Ct++], B(W, Vt + ce, yt, se, it), ce = M(ce, It);
        }
        for (It = Z + 1, yt = 2; 15 >= It; ++It, yt <<= 1) {
          if (re += _e <<= 1, 0 > (_e -= bt[It])) return 0;
          for (; 0 < bt[It]; --bt[It]) {
            if (it = new A(), (ce & Gt) != Yt) {
              for (Vt += se, Ht = 1 << (Yt = It) - Z; 15 > Yt && !(0 >= (Ht -= bt[Yt])); ) ++Yt, Ht <<= 1;
              Mt += se = 1 << (Ht = Yt - Z), W[K + (Yt = ce & Gt)].g = Ht + Z, W[K + Yt].value = Vt - K - Yt;
            }
            it.g = It - Z, it.value = Lt[Ct++], B(W, Vt + (ce >> Z), yt, se, it), ce = M(ce, It);
          }
        }
        return re != 2 * St[15] - 1 ? 0 : Mt;
      }(c, g, _, L, R, $);
    }
    function A() {
      this.value = this.g = 0;
    }
    function I() {
      this.value = this.g = 0;
    }
    function S() {
      this.G = o(5, A), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o(Yn, I);
    }
    function X(c, g, _, L) {
      t(c != null), t(g != null), t(2147483648 > L), c.Ca = 254, c.I = 0, c.b = -8, c.Ka = 0, c.oa = g, c.pa = _, c.Jd = g, c.Yc = _ + L, c.Zc = 4 <= L ? _ + L - 4 + 1 : _, wt(c);
    }
    function H(c, g) {
      for (var _ = 0; 0 < g--; ) _ |= xt(c, 128) << g;
      return _;
    }
    function j(c, g) {
      var _ = H(c, g);
      return mt(c) ? -_ : _;
    }
    function Q(c, g, _, L) {
      var R, $ = 0;
      for (t(c != null), t(g != null), t(4294967288 > L), c.Sb = L, c.Ra = 0, c.u = 0, c.h = 0, 4 < L && (L = 4), R = 0; R < L; ++R) $ += g[_ + R] << 8 * R;
      c.Ra = $, c.bb = L, c.oa = g, c.pa = _;
    }
    function G(c) {
      for (; 8 <= c.u && c.bb < c.Sb; ) c.Ra >>>= 8, c.Ra += c.oa[c.pa + c.bb] << Vo - 8 >>> 0, ++c.bb, c.u -= 8;
      V(c) && (c.h = 1, c.u = 0);
    }
    function ft(c, g) {
      if (t(0 <= g), !c.h && g <= Go) {
        var _ = z(c) & Ho[g];
        return c.u += g, G(c), _;
      }
      return c.h = 1, c.u = 0;
    }
    function nt() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function z(c) {
      return c.Ra >>> (c.u & Vo - 1) >>> 0;
    }
    function V(c) {
      return t(c.bb <= c.Sb), c.h || c.bb == c.Sb && c.u > Vo;
    }
    function Y(c, g) {
      c.u = g, c.h = V(c);
    }
    function ot(c) {
      c.u >= Xa && (t(c.u >= Xa), G(c));
    }
    function wt(c) {
      t(c != null && c.oa != null), c.pa < c.Zc ? (c.I = (c.oa[c.pa++] | c.I << 8) >>> 0, c.b += 8) : (t(c != null && c.oa != null), c.pa < c.Yc ? (c.b += 8, c.I = c.oa[c.pa++] | c.I << 8) : c.Ka ? c.b = 0 : (c.I <<= 8, c.b += 8, c.Ka = 1));
    }
    function mt(c) {
      return H(c, 1);
    }
    function xt(c, g) {
      var _ = c.Ca;
      0 > c.b && wt(c);
      var L = c.b, R = _ * g >>> 8, $ = (c.I >>> L > R) + 0;
      for ($ ? (_ -= R, c.I -= R + 1 << L >>> 0) : _ = R + 1, L = _, R = 0; 256 <= L; ) R += 8, L >>= 8;
      return L = 7 ^ R + yi[L], c.b -= L, c.Ca = (_ << L) - 1, $;
    }
    function zt(c, g, _) {
      c[g + 0] = _ >> 24 & 255, c[g + 1] = _ >> 16 & 255, c[g + 2] = _ >> 8 & 255, c[g + 3] = _ >> 0 & 255;
    }
    function Dt(c, g) {
      return c[g + 0] << 0 | c[g + 1] << 8;
    }
    function Jt(c, g) {
      return Dt(c, g) | c[g + 2] << 16;
    }
    function Qt(c, g) {
      return Dt(c, g) | Dt(c, g + 2) << 16;
    }
    function O(c, g) {
      var _ = 1 << g;
      return t(c != null), t(0 < g), c.X = s(_), c.X == null ? 0 : (c.Mb = 32 - g, c.Xa = g, 1);
    }
    function ct(c, g) {
      t(c != null), t(g != null), t(c.Xa == g.Xa), i(g.X, 0, c.X, 0, 1 << g.Xa);
    }
    function U() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function et(c, g, _, L) {
      t(_ != null), t(L != null);
      var R = _[0], $ = L[0];
      return R == 0 && (R = (c * $ + g / 2) / g), $ == 0 && ($ = (g * R + c / 2) / c), 0 >= R || 0 >= $ ? 0 : (_[0] = R, L[0] = $, 1);
    }
    function J(c, g) {
      return c + (1 << g) - 1 >>> g;
    }
    function rt(c, g) {
      return ((4278255360 & c) + (4278255360 & g) >>> 0 & 4278255360) + ((16711935 & c) + (16711935 & g) >>> 0 & 16711935) >>> 0;
    }
    function vt(c, g) {
      F[g] = function(_, L, R, $, W, K, Z) {
        var it;
        for (it = 0; it < W; ++it) {
          var yt = F[c](K[Z + it - 1], R, $ + it);
          K[Z + it] = rt(_[L + it], yt);
        }
      };
    }
    function At() {
      this.ud = this.hd = this.jd = 0;
    }
    function ht(c, g) {
      return ((4278124286 & (c ^ g)) >>> 1) + (c & g) >>> 0;
    }
    function Ot(c) {
      return 0 <= c && 256 > c ? c : 0 > c ? 0 : 255 < c ? 255 : void 0;
    }
    function $t(c, g) {
      return Ot(c + (c - g + 0.5 >> 1));
    }
    function Ft(c, g, _) {
      return Math.abs(g - _) - Math.abs(c - _);
    }
    function Ut(c, g, _, L, R, $, W) {
      for (L = $[W - 1], _ = 0; _ < R; ++_) $[W + _] = L = rt(c[g + _], L);
    }
    function ie(c, g, _, L, R) {
      var $;
      for ($ = 0; $ < _; ++$) {
        var W = c[g + $], K = W >> 8 & 255, Z = 16711935 & (Z = (Z = 16711935 & W) + ((K << 16) + K));
        L[R + $] = (4278255360 & W) + Z >>> 0;
      }
    }
    function oe(c, g) {
      g.jd = c >> 0 & 255, g.hd = c >> 8 & 255, g.ud = c >> 16 & 255;
    }
    function ae(c, g, _, L, R, $) {
      var W;
      for (W = 0; W < L; ++W) {
        var K = g[_ + W], Z = K >>> 8, it = K, yt = 255 & (yt = (yt = K >>> 16) + ((c.jd << 24 >> 24) * (Z << 24 >> 24) >>> 5));
        it = 255 & (it = (it = it + ((c.hd << 24 >> 24) * (Z << 24 >> 24) >>> 5)) + ((c.ud << 24 >> 24) * (yt << 24 >> 24) >>> 5)), R[$ + W] = (4278255360 & K) + (yt << 16) + it;
      }
    }
    function dt(c, g, _, L, R) {
      F[g] = function($, W, K, Z, it, yt, Lt, It, Ct) {
        for (Z = Lt; Z < It; ++Z) for (Lt = 0; Lt < Ct; ++Lt) it[yt++] = R(K[L($[W++])]);
      }, F[c] = function($, W, K, Z, it, yt, Lt) {
        var It = 8 >> $.b, Ct = $.Ea, Vt = $.K[0], Mt = $.w;
        if (8 > It) for ($ = (1 << $.b) - 1, Mt = (1 << It) - 1; W < K; ++W) {
          var bt, St = 0;
          for (bt = 0; bt < Ct; ++bt) bt & $ || (St = L(Z[it++])), yt[Lt++] = R(Vt[St & Mt]), St >>= It;
        }
        else F["VP8LMapColor" + _](Z, it, Vt, Mt, yt, Lt, W, K, Ct);
      };
    }
    function kt(c, g, _, L, R) {
      for (_ = g + _; g < _; ) {
        var $ = c[g++];
        L[R++] = $ >> 16 & 255, L[R++] = $ >> 8 & 255, L[R++] = $ >> 0 & 255;
      }
    }
    function te(c, g, _, L, R) {
      for (_ = g + _; g < _; ) {
        var $ = c[g++];
        L[R++] = $ >> 16 & 255, L[R++] = $ >> 8 & 255, L[R++] = $ >> 0 & 255, L[R++] = $ >> 24 & 255;
      }
    }
    function Rt(c, g, _, L, R) {
      for (_ = g + _; g < _; ) {
        var $ = (W = c[g++]) >> 16 & 240 | W >> 12 & 15, W = W >> 0 & 240 | W >> 28 & 15;
        L[R++] = $, L[R++] = W;
      }
    }
    function be(c, g, _, L, R) {
      for (_ = g + _; g < _; ) {
        var $ = (W = c[g++]) >> 16 & 248 | W >> 13 & 7, W = W >> 5 & 224 | W >> 3 & 31;
        L[R++] = $, L[R++] = W;
      }
    }
    function Kt(c, g, _, L, R) {
      for (_ = g + _; g < _; ) {
        var $ = c[g++];
        L[R++] = $ >> 0 & 255, L[R++] = $ >> 8 & 255, L[R++] = $ >> 16 & 255;
      }
    }
    function jt(c, g, _, L, R, $) {
      if ($ == 0) for (_ = g + _; g < _; ) zt(L, (($ = c[g++])[0] >> 24 | $[1] >> 8 & 65280 | $[2] << 8 & 16711680 | $[3] << 24) >>> 0), R += 32;
      else i(L, R, c, g, _);
    }
    function ge(c, g) {
      F[g][0] = F[c + "0"], F[g][1] = F[c + "1"], F[g][2] = F[c + "2"], F[g][3] = F[c + "3"], F[g][4] = F[c + "4"], F[g][5] = F[c + "5"], F[g][6] = F[c + "6"], F[g][7] = F[c + "7"], F[g][8] = F[c + "8"], F[g][9] = F[c + "9"], F[g][10] = F[c + "10"], F[g][11] = F[c + "11"], F[g][12] = F[c + "12"], F[g][13] = F[c + "13"], F[g][14] = F[c + "0"], F[g][15] = F[c + "0"];
    }
    function we(c) {
      return c == eh || c == nh || c == au || c == ih;
    }
    function Rn() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Ze() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Dn() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Rn(), this.f.kb = new Ze(), this.sd = null;
    }
    function fn() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function We() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ke(c) {
      return alert("todo:WebPSamplerProcessPlane"), c.T;
    }
    function He(c, g) {
      var _ = c.T, L = g.ba.f.RGBA, R = L.eb, $ = L.fb + c.ka * L.A, W = Yi[g.ba.S], K = c.y, Z = c.O, it = c.f, yt = c.N, Lt = c.ea, It = c.W, Ct = g.cc, Vt = g.dc, Mt = g.Mc, bt = g.Nc, St = c.ka, Ht = c.ka + c.T, Yt = c.U, Gt = Yt + 1 >> 1;
      for (St == 0 ? W(K, Z, null, null, it, yt, Lt, It, it, yt, Lt, It, R, $, null, null, Yt) : (W(g.ec, g.fc, K, Z, Ct, Vt, Mt, bt, it, yt, Lt, It, R, $ - L.A, R, $, Yt), ++_); St + 2 < Ht; St += 2) Ct = it, Vt = yt, Mt = Lt, bt = It, yt += c.Rc, It += c.Rc, $ += 2 * L.A, W(K, (Z += 2 * c.fa) - c.fa, K, Z, Ct, Vt, Mt, bt, it, yt, Lt, It, R, $ - L.A, R, $, Yt);
      return Z += c.fa, c.j + Ht < c.o ? (i(g.ec, g.fc, K, Z, Yt), i(g.cc, g.dc, it, yt, Gt), i(g.Mc, g.Nc, Lt, It, Gt), _--) : 1 & Ht || W(K, Z, null, null, it, yt, Lt, It, it, yt, Lt, It, R, $ + L.A, null, null, Yt), _;
    }
    function tr(c, g, _) {
      var L = c.F, R = [c.J];
      if (L != null) {
        var $ = c.U, W = g.ba.S, K = W == ou || W == au;
        g = g.ba.f.RGBA;
        var Z = [0], it = c.ka;
        Z[0] = c.T, c.Kb && (it == 0 ? --Z[0] : (--it, R[0] -= c.width), c.j + c.ka + c.T == c.o && (Z[0] = c.o - c.j - it));
        var yt = g.eb;
        it = g.fb + it * g.A, c = un(L, R[0], c.width, $, Z, yt, it + (K ? 0 : 3), g.A), t(_ == Z), c && we(W) && Gi(yt, it, K, $, Z, g.A);
      }
      return 0;
    }
    function En(c) {
      var g = c.ma, _ = g.ba.S, L = 11 > _, R = _ == ru || _ == su || _ == ou || _ == th || _ == 12 || we(_);
      if (g.memory = null, g.Ib = null, g.Jb = null, g.Nd = null, !Ya(g.Oa, c, R ? 11 : 12)) return 0;
      if (R && we(_) && Xt(), c.da) alert("todo:use_scaling");
      else {
        if (L) {
          if (g.Ib = ke, c.Kb) {
            if (_ = c.U + 1 >> 1, g.memory = s(c.U + 2 * _), g.memory == null) return 0;
            g.ec = g.memory, g.fc = 0, g.cc = g.ec, g.dc = g.fc + c.U, g.Mc = g.cc, g.Nc = g.dc + _, g.Ib = He, Xt();
          }
        } else alert("todo:EmitYUV");
        R && (g.Jb = tr, L && Pt());
      }
      if (L && !tp) {
        for (c = 0; 256 > c; ++c) r2[c] = 89858 * (c - 128) + uu >> lu, a2[c] = -22014 * (c - 128) + uu, o2[c] = -45773 * (c - 128), s2[c] = 113618 * (c - 128) + uu >> lu;
        for (c = il; c < oh; ++c) g = 76283 * (c - 16) + uu >> lu, l2[c - il] = Ei(g, 255), u2[c - il] = Ei(g + 8 >> 4, 15);
        tp = 1;
      }
      return 1;
    }
    function Bi(c) {
      var g = c.ma, _ = c.U, L = c.T;
      return t(!(1 & c.ka)), 0 >= _ || 0 >= L ? 0 : (_ = g.Ib(c, g), g.Jb != null && g.Jb(c, g, _), g.Dc += _, 1);
    }
    function mn(c) {
      c.ma.memory = null;
    }
    function xe(c, g, _, L) {
      return ft(c, 8) != 47 ? 0 : (g[0] = ft(c, 14) + 1, _[0] = ft(c, 14) + 1, L[0] = ft(c, 1), ft(c, 3) != 0 ? 0 : !c.h);
    }
    function Ai(c, g) {
      if (4 > c) return c + 1;
      var _ = c - 2 >> 1;
      return (2 + (1 & c) << _) + ft(g, _) + 1;
    }
    function ji(c, g) {
      return 120 < g ? g - 120 : 1 <= (_ = ((_ = Wm[g - 1]) >> 4) * c + (8 - (15 & _))) ? _ : 1;
      var _;
    }
    function ti(c, g, _) {
      var L = z(_), R = c[g += 255 & L].g - 8;
      return 0 < R && (Y(_, _.u + 8), L = z(_), g += c[g].value, g += L & (1 << R) - 1), Y(_, _.u + c[g].g), c[g].value;
    }
    function vn(c, g, _) {
      return _.g += c.g, _.value += c.value << g >>> 0, t(8 >= _.g), c.g;
    }
    function wn(c, g, _) {
      var L = c.xc;
      return t((g = L == 0 ? 0 : c.vc[c.md * (_ >> L) + (g >> L)]) < c.Wb), c.Ya[g];
    }
    function ui(c, g, _, L) {
      var R = c.ab, $ = c.c * g, W = c.C;
      g = W + g;
      var K = _, Z = L;
      for (L = c.Ta, _ = c.Ua; 0 < R--; ) {
        var it = c.gc[R], yt = W, Lt = g, It = K, Ct = Z, Vt = (Z = L, K = _, it.Ea);
        switch (t(yt < Lt), t(Lt <= it.nc), it.hc) {
          case 2:
            Jl(It, Ct, (Lt - yt) * Vt, Z, K);
            break;
          case 0:
            var Mt = yt, bt = Lt, St = Z, Ht = K, Yt = (se = it).Ea;
            Mt == 0 && (Zc(It, Ct, null, null, 1, St, Ht), Ut(It, Ct + 1, 0, 0, Yt - 1, St, Ht + 1), Ct += Yt, Ht += Yt, ++Mt);
            for (var Gt = 1 << se.b, ce = Gt - 1, re = J(Yt, se.b), _e = se.K, se = se.w + (Mt >> se.b) * re; Mt < bt; ) {
              var Ke = _e, Qe = se, ze = 1;
              for (Ja(It, Ct, St, Ht - Yt, 1, St, Ht); ze < Yt; ) {
                var De = (ze & ~ce) + Gt;
                De > Yt && (De = Yt), (0, gs[Ke[Qe++] >> 8 & 15])(It, Ct + +ze, St, Ht + ze - Yt, De - ze, St, Ht + ze), ze = De;
              }
              Ct += Yt, Ht += Yt, ++Mt & ce || (se += re);
            }
            Lt != it.nc && i(Z, K - Vt, Z, K + (Lt - yt - 1) * Vt, Vt);
            break;
          case 1:
            for (Vt = It, bt = Ct, Yt = (It = it.Ea) - (Ht = It & ~(St = (Ct = 1 << it.b) - 1)), Mt = J(It, it.b), Gt = it.K, it = it.w + (yt >> it.b) * Mt; yt < Lt; ) {
              for (ce = Gt, re = it, _e = new At(), se = bt + Ht, Ke = bt + It; bt < se; ) oe(ce[re++], _e), Js(_e, Vt, bt, Ct, Z, K), bt += Ct, K += Ct;
              bt < Ke && (oe(ce[re++], _e), Js(_e, Vt, bt, Yt, Z, K), bt += Yt, K += Yt), ++yt & St || (it += Mt);
            }
            break;
          case 3:
            if (It == Z && Ct == K && 0 < it.b) {
              for (bt = Z, It = Vt = K + (Lt - yt) * Vt - (Ht = (Lt - yt) * J(it.Ea, it.b)), Ct = Z, St = K, Mt = [], Ht = (Yt = Ht) - 1; 0 <= Ht; --Ht) Mt[Ht] = Ct[St + Ht];
              for (Ht = Yt - 1; 0 <= Ht; --Ht) bt[It + Ht] = Mt[Ht];
              Ui(it, yt, Lt, Z, Vt, Z, K);
            } else Ui(it, yt, Lt, It, Ct, Z, K);
        }
        K = L, Z = _;
      }
      Z != _ && i(L, _, K, Z, $);
    }
    function ss(c, g) {
      var _ = c.V, L = c.Ba + c.c * c.C, R = g - c.C;
      if (t(g <= c.l.o), t(16 >= R), 0 < R) {
        var $ = c.l, W = c.Ta, K = c.Ua, Z = $.width;
        if (ui(c, R, _, L), R = K = [K], t((_ = c.C) < (L = g)), t($.v < $.va), L > $.o && (L = $.o), _ < $.j) {
          var it = $.j - _;
          _ = $.j, R[0] += it * Z;
        }
        if (_ >= L ? _ = 0 : (R[0] += 4 * $.v, $.ka = _ - $.j, $.U = $.va - $.v, $.T = L - _, _ = 1), _) {
          if (K = K[0], 11 > (_ = c.ca).S) {
            var yt = _.f.RGBA, Lt = (L = _.S, R = $.U, $ = $.T, it = yt.eb, yt.A), It = $;
            for (yt = yt.fb + c.Ma * yt.A; 0 < It--; ) {
              var Ct = W, Vt = K, Mt = R, bt = it, St = yt;
              switch (L) {
                case iu:
                  bi(Ct, Vt, Mt, bt, St);
                  break;
                case ru:
                  ci(Ct, Vt, Mt, bt, St);
                  break;
                case eh:
                  ci(Ct, Vt, Mt, bt, St), Gi(bt, St, 0, Mt, 1, 0);
                  break;
                case Wd:
                  Hr(Ct, Vt, Mt, bt, St);
                  break;
                case su:
                  jt(Ct, Vt, Mt, bt, St, 1);
                  break;
                case nh:
                  jt(Ct, Vt, Mt, bt, St, 1), Gi(bt, St, 0, Mt, 1, 0);
                  break;
                case ou:
                  jt(Ct, Vt, Mt, bt, St, 0);
                  break;
                case au:
                  jt(Ct, Vt, Mt, bt, St, 0), Gi(bt, St, 1, Mt, 1, 0);
                  break;
                case th:
                  ms(Ct, Vt, Mt, bt, St);
                  break;
                case ih:
                  ms(Ct, Vt, Mt, bt, St), ln(bt, St, Mt, 1, 0);
                  break;
                case Hd:
                  Wr(Ct, Vt, Mt, bt, St);
                  break;
                default:
                  t(0);
              }
              K += Z, yt += Lt;
            }
            c.Ma += $;
          } else alert("todo:EmitRescaledRowsYUVA");
          t(c.Ma <= _.height);
        }
      }
      c.C = g, t(c.C <= c.i);
    }
    function er(c) {
      var g;
      if (0 < c.ua) return 0;
      for (g = 0; g < c.Wb; ++g) {
        var _ = c.Ya[g].G, L = c.Ya[g].H;
        if (0 < _[1][L[1] + 0].g || 0 < _[2][L[2] + 0].g || 0 < _[3][L[3] + 0].g) return 0;
      }
      return 1;
    }
    function gi(c, g, _, L, R, $) {
      if (c.Z != 0) {
        var W = c.qd, K = c.rd;
        for (t(ws[c.Z] != null); g < _; ++g) ws[c.Z](W, K, L, R, L, R, $), W = L, K = R, R += $;
        c.qd = W, c.rd = K;
      }
    }
    function Ni(c, g) {
      var _ = c.l.ma, L = _.Z == 0 || _.Z == 1 ? c.l.j : c.C;
      if (L = c.C < L ? L : c.C, t(g <= c.l.o), g > L) {
        var R = c.l.width, $ = _.ca, W = _.tb + R * L, K = c.V, Z = c.Ba + c.c * L, it = c.gc;
        t(c.ab == 1), t(it[0].hc == 3), Zl(it[0], L, g, K, Z, $, W), gi(_, L, g, $, W, R);
      }
      c.C = c.Ma = g;
    }
    function Ci(c, g, _, L, R, $, W) {
      var K = c.$ / L, Z = c.$ % L, it = c.m, yt = c.s, Lt = _ + c.$, It = Lt;
      R = _ + L * R;
      var Ct = _ + L * $, Vt = 280 + yt.ua, Mt = c.Pb ? K : 16777216, bt = 0 < yt.ua ? yt.Wa : null, St = yt.wc, Ht = Lt < Ct ? wn(yt, Z, K) : null;
      t(c.C < $), t(Ct <= R);
      var Yt = !1;
      t: for (; ; ) {
        for (; Yt || Lt < Ct; ) {
          var Gt = 0;
          if (K >= Mt) {
            var ce = Lt - _;
            t((Mt = c).Pb), Mt.wd = Mt.m, Mt.xd = ce, 0 < Mt.s.ua && ct(Mt.s.Wa, Mt.s.vb), Mt = K + Gm;
          }
          if (Z & St || (Ht = wn(yt, Z, K)), t(Ht != null), Ht.Qb && (g[Lt] = Ht.qb, Yt = !0), !Yt) if (ot(it), Ht.jc) {
            Gt = it, ce = g;
            var re = Lt, _e = Ht.pd[z(Gt) & Yn - 1];
            t(Ht.jc), 256 > _e.g ? (Y(Gt, Gt.u + _e.g), ce[re] = _e.value, Gt = 0) : (Y(Gt, Gt.u + _e.g - 256), t(256 <= _e.value), Gt = _e.value), Gt == 0 && (Yt = !0);
          } else Gt = ti(Ht.G[0], Ht.H[0], it);
          if (it.h) break;
          if (Yt || 256 > Gt) {
            if (!Yt) if (Ht.nd) g[Lt] = (Ht.qb | Gt << 8) >>> 0;
            else {
              if (ot(it), Yt = ti(Ht.G[1], Ht.H[1], it), ot(it), ce = ti(Ht.G[2], Ht.H[2], it), re = ti(Ht.G[3], Ht.H[3], it), it.h) break;
              g[Lt] = (re << 24 | Yt << 16 | Gt << 8 | ce) >>> 0;
            }
            if (Yt = !1, ++Lt, ++Z >= L && (Z = 0, ++K, W != null && K <= $ && !(K % 16) && W(c, K), bt != null)) for (; It < Lt; ) Gt = g[It++], bt.X[(506832829 * Gt & 4294967295) >>> bt.Mb] = Gt;
          } else if (280 > Gt) {
            if (Gt = Ai(Gt - 256, it), ce = ti(Ht.G[4], Ht.H[4], it), ot(it), ce = ji(L, ce = Ai(ce, it)), it.h) break;
            if (Lt - _ < ce || R - Lt < Gt) break t;
            for (re = 0; re < Gt; ++re) g[Lt + re] = g[Lt + re - ce];
            for (Lt += Gt, Z += Gt; Z >= L; ) Z -= L, ++K, W != null && K <= $ && !(K % 16) && W(c, K);
            if (t(Lt <= R), Z & St && (Ht = wn(yt, Z, K)), bt != null) for (; It < Lt; ) Gt = g[It++], bt.X[(506832829 * Gt & 4294967295) >>> bt.Mb] = Gt;
          } else {
            if (!(Gt < Vt)) break t;
            for (Yt = Gt - 280, t(bt != null); It < Lt; ) Gt = g[It++], bt.X[(506832829 * Gt & 4294967295) >>> bt.Mb] = Gt;
            Gt = Lt, t(!(Yt >>> (ce = bt).Xa)), g[Gt] = ce.X[Yt], Yt = !0;
          }
          Yt || t(it.h == V(it));
        }
        if (c.Pb && it.h && Lt < R) t(c.m.h), c.a = 5, c.m = c.wd, c.$ = c.xd, 0 < c.s.ua && ct(c.s.vb, c.s.Wa);
        else {
          if (it.h) break t;
          W != null && W(c, K > $ ? $ : K), c.a = 0, c.$ = Lt - _;
        }
        return 1;
      }
      return c.a = 3, 0;
    }
    function qi(c) {
      t(c != null), c.vc = null, c.yc = null, c.Ya = null;
      var g = c.Wa;
      g != null && (g.X = null), c.vb = null, t(c != null);
    }
    function Pi() {
      var c = new Jc();
      return c == null ? null : (c.a = 0, c.xb = Yd, ge("Predictor", "VP8LPredictors"), ge("Predictor", "VP8LPredictors_C"), ge("PredictorAdd", "VP8LPredictorsAdd"), ge("PredictorAdd", "VP8LPredictorsAdd_C"), Jl = ie, Js = ae, bi = kt, ci = te, ms = Rt, Wr = be, Hr = Kt, F.VP8LMapColor32b = Yo, F.VP8LMapColor8b = Ql, c);
    }
    function zi(c, g, _, L, R) {
      var $ = 1, W = [c], K = [g], Z = L.m, it = L.s, yt = null, Lt = 0;
      t: for (; ; ) {
        if (_) for (; $ && ft(Z, 1); ) {
          var It = W, Ct = K, Vt = L, Mt = 1, bt = Vt.m, St = Vt.gc[Vt.ab], Ht = ft(bt, 2);
          if (Vt.Oc & 1 << Ht) $ = 0;
          else {
            switch (Vt.Oc |= 1 << Ht, St.hc = Ht, St.Ea = It[0], St.nc = Ct[0], St.K = [null], ++Vt.ab, t(4 >= Vt.ab), Ht) {
              case 0:
              case 1:
                St.b = ft(bt, 3) + 2, Mt = zi(J(St.Ea, St.b), J(St.nc, St.b), 0, Vt, St.K), St.K = St.K[0];
                break;
              case 3:
                var Yt, Gt = ft(bt, 8) + 1, ce = 16 < Gt ? 0 : 4 < Gt ? 1 : 2 < Gt ? 2 : 3;
                if (It[0] = J(St.Ea, ce), St.b = ce, Yt = Mt = zi(Gt, 1, 0, Vt, St.K)) {
                  var re, _e = Gt, se = St, Ke = 1 << (8 >> se.b), Qe = s(Ke);
                  if (Qe == null) Yt = 0;
                  else {
                    var ze = se.K[0], De = se.w;
                    for (Qe[0] = se.K[0][0], re = 1; re < 1 * _e; ++re) Qe[re] = rt(ze[De + re], Qe[re - 1]);
                    for (; re < 4 * Ke; ++re) Qe[re] = 0;
                    se.K[0] = null, se.K[0] = Qe, Yt = 1;
                  }
                }
                Mt = Yt;
                break;
              case 2:
                break;
              default:
                t(0);
            }
            $ = Mt;
          }
        }
        if (W = W[0], K = K[0], $ && ft(Z, 1) && !($ = 1 <= (Lt = ft(Z, 4)) && 11 >= Lt)) {
          L.a = 3;
          break t;
        }
        var on;
        if (on = $) e: {
          var nn, Te, Tn, vi = L, Fn = W, wi = K, tn = Lt, Ti = _, Fi = vi.m, $n = vi.s, Kn = [null], fi = 1, Ki = 0, Sr = Hm[tn];
          n: for (; ; ) {
            if (Ti && ft(Fi, 1)) {
              var Un = ft(Fi, 3) + 2, Kr = J(Fn, Un), no = J(wi, Un), Qo = Kr * no;
              if (!zi(Kr, no, 0, vi, Kn)) break n;
              for (Kn = Kn[0], $n.xc = Un, nn = 0; nn < Qo; ++nn) {
                var xs = Kn[nn] >> 8 & 65535;
                Kn[nn] = xs, xs >= fi && (fi = xs + 1);
              }
            }
            if (Fi.h) break n;
            for (Te = 0; 5 > Te; ++Te) {
              var _n = Gd[Te];
              !Te && 0 < tn && (_n += 1 << tn), Ki < _n && (Ki = _n);
            }
            var ah = o(fi * Sr, A), ip = fi, rp = o(ip, S);
            if (rp == null) var hu = null;
            else t(65536 >= ip), hu = rp;
            var rl = s(Ki);
            if (hu == null || rl == null || ah == null) {
              vi.a = 1;
              break n;
            }
            var fu = ah;
            for (nn = Tn = 0; nn < fi; ++nn) {
              var or = hu[nn], ta = or.G, ea = or.H, sp = 0, du = 1, op = 0;
              for (Te = 0; 5 > Te; ++Te) {
                _n = Gd[Te], ta[Te] = fu, ea[Te] = Tn, !Te && 0 < tn && (_n += 1 << tn);
                r: {
                  var pu, lh = _n, gu = vi, sl = rl, f2 = fu, d2 = Tn, uh = 0, _s = gu.m, p2 = ft(_s, 1);
                  if (r(sl, 0, 0, lh), p2) {
                    var g2 = ft(_s, 1) + 1, m2 = ft(_s, 1), ap = ft(_s, m2 == 0 ? 1 : 8);
                    sl[ap] = 1, g2 == 2 && (sl[ap = ft(_s, 8)] = 1);
                    var mu = 1;
                  } else {
                    var lp = s(19), up = ft(_s, 4) + 4;
                    if (19 < up) {
                      gu.a = 3;
                      var yu = 0;
                      break r;
                    }
                    for (pu = 0; pu < up; ++pu) lp[Um[pu]] = ft(_s, 3);
                    var ch = void 0, ol = void 0, cp = gu, y2 = lp, bu = lh, hp = sl, hh = 0, Ss = cp.m, fp = 8, dp = o(128, A);
                    i: for (; P(dp, 0, 7, y2, 19); ) {
                      if (ft(Ss, 1)) {
                        var b2 = 2 + 2 * ft(Ss, 3);
                        if ((ch = 2 + ft(Ss, b2)) > bu) break i;
                      } else ch = bu;
                      for (ol = 0; ol < bu && ch--; ) {
                        ot(Ss);
                        var pp = dp[0 + (127 & z(Ss))];
                        Y(Ss, Ss.u + pp.g);
                        var na = pp.value;
                        if (16 > na) hp[ol++] = na, na != 0 && (fp = na);
                        else {
                          var v2 = na == 16, gp = na - 16, w2 = zm[gp], mp = ft(Ss, qm[gp]) + w2;
                          if (ol + mp > bu) break i;
                          for (var x2 = v2 ? fp : 0; 0 < mp--; ) hp[ol++] = x2;
                        }
                      }
                      hh = 1;
                      break i;
                    }
                    hh || (cp.a = 3), mu = hh;
                  }
                  (mu = mu && !_s.h) && (uh = P(f2, d2, 8, sl, lh)), mu && uh != 0 ? yu = uh : (gu.a = 3, yu = 0);
                }
                if (yu == 0) break n;
                if (du && $m[Te] == 1 && (du = fu[Tn].g == 0), sp += fu[Tn].g, Tn += yu, 3 >= Te) {
                  var al, fh = rl[0];
                  for (al = 1; al < _n; ++al) rl[al] > fh && (fh = rl[al]);
                  op += fh;
                }
              }
              if (or.nd = du, or.Qb = 0, du && (or.qb = (ta[3][ea[3] + 0].value << 24 | ta[1][ea[1] + 0].value << 16 | ta[2][ea[2] + 0].value) >>> 0, sp == 0 && 256 > ta[0][ea[0] + 0].value && (or.Qb = 1, or.qb += ta[0][ea[0] + 0].value << 8)), or.jc = !or.Qb && 6 > op, or.jc) {
                var vu, Xr = or;
                for (vu = 0; vu < Yn; ++vu) {
                  var ks = vu, As = Xr.pd[ks], wu = Xr.G[0][Xr.H[0] + ks];
                  256 <= wu.value ? (As.g = wu.g + 256, As.value = wu.value) : (As.g = 0, As.value = 0, ks >>= vn(wu, 8, As), ks >>= vn(Xr.G[1][Xr.H[1] + ks], 16, As), ks >>= vn(Xr.G[2][Xr.H[2] + ks], 0, As), vn(Xr.G[3][Xr.H[3] + ks], 24, As));
                }
              }
            }
            $n.vc = Kn, $n.Wb = fi, $n.Ya = hu, $n.yc = ah, on = 1;
            break e;
          }
          on = 0;
        }
        if (!($ = on)) {
          L.a = 3;
          break t;
        }
        if (0 < Lt) {
          if (it.ua = 1 << Lt, !O(it.Wa, Lt)) {
            L.a = 1, $ = 0;
            break t;
          }
        } else it.ua = 0;
        var dh = L, yp = W, _2 = K, ph = dh.s, gh = ph.xc;
        if (dh.c = yp, dh.i = _2, ph.md = J(yp, gh), ph.wc = gh == 0 ? -1 : (1 << gh) - 1, _) {
          L.xb = Qm;
          break t;
        }
        if ((yt = s(W * K)) == null) {
          L.a = 1, $ = 0;
          break t;
        }
        $ = ($ = Ci(L, yt, 0, W, K, K, null)) && !Z.h;
        break t;
      }
      return $ ? (R != null ? R[0] = yt : (t(yt == null), t(_)), L.$ = 0, _ || qi(it)) : qi(it), $;
    }
    function wr(c, g) {
      var _ = c.c * c.i, L = _ + g + 16 * g;
      return t(c.c <= g), c.V = s(L), c.V == null ? (c.Ta = null, c.Ua = 0, c.a = 1, 0) : (c.Ta = c.V, c.Ua = c.Ba + _ + g, 1);
    }
    function Dr(c, g) {
      var _ = c.C, L = g - _, R = c.V, $ = c.Ba + c.c * _;
      for (t(g <= c.l.o); 0 < L; ) {
        var W = 16 < L ? 16 : L, K = c.l.ma, Z = c.l.width, it = Z * W, yt = K.ca, Lt = K.tb + Z * _, It = c.Ta, Ct = c.Ua;
        ui(c, W, R, $), An(It, Ct, yt, Lt, it), gi(K, _, _ + W, yt, Lt, Z), L -= W, R += W * c.c, _ += W;
      }
      t(_ == g), c.C = c.Ma = g;
    }
    function nr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Br() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function jr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function qr() {
      this.Yb = function() {
        var c = [];
        return function g(_, L, R) {
          for (var $ = R[L], W = 0; W < $ && (_.push(R.length > L + 1 ? [] : 0), !(R.length < L + 1)); W++) g(_[W], L + 1, R);
        }(c, 0, [3, 11]), c;
      }();
    }
    function os() {
      this.jb = s(3), this.Wc = a([4, 8], qr), this.Xc = a([4, 17], qr);
    }
    function Io() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function as() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Eo() {
      this.Na = this.la = 0;
    }
    function ls() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function $s() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zr() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new as()), this.Y = 0, this.ya = Array(new $s()), this.aa = 0, this.l = new us();
    }
    function Oo() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Oa() {
      this.cb = this.a = 0, this.sc = "", this.m = new nt(), this.Od = new nr(), this.Kc = new Br(), this.ed = new Io(), this.Qa = new jr(), this.Ic = this.$c = this.Aa = 0, this.D = new zr(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o(8, nt), this.ia = 0, this.pb = o(4, ls), this.Pa = new os(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Oo()), this.Hd = 0, this.rb = Array(new Eo()), this.sb = 0, this.wa = Array(new as()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new $s()), this.L = this.aa = 0, this.gd = a([4, 2], as), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function us() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Ta() {
      var c = new Oa();
      return c != null && (c.a = 0, c.sc = "OK", c.cb = 0, c.Xb = 0, nl || (nl = Fo)), c;
    }
    function dn(c, g, _) {
      return c.a == 0 && (c.a = g, c.sc = _, c.cb = 0), 0;
    }
    function To(c, g, _) {
      return 3 <= _ && c[g + 0] == 157 && c[g + 1] == 1 && c[g + 2] == 42;
    }
    function Us(c, g) {
      if (c == null) return 0;
      if (c.a = 0, c.sc = "OK", g == null) return dn(c, 2, "null VP8Io passed to VP8GetHeaders()");
      var _ = g.data, L = g.w, R = g.ha;
      if (4 > R) return dn(c, 7, "Truncated header.");
      var $ = _[L + 0] | _[L + 1] << 8 | _[L + 2] << 16, W = c.Od;
      if (W.Rb = !(1 & $), W.td = $ >> 1 & 7, W.yd = $ >> 4 & 1, W.ub = $ >> 5, 3 < W.td) return dn(c, 3, "Incorrect keyframe parameters.");
      if (!W.yd) return dn(c, 4, "Frame not displayable.");
      L += 3, R -= 3;
      var K = c.Kc;
      if (W.Rb) {
        if (7 > R) return dn(c, 7, "cannot parse picture header");
        if (!To(_, L, R)) return dn(c, 3, "Bad code word");
        K.c = 16383 & (_[L + 4] << 8 | _[L + 3]), K.Td = _[L + 4] >> 6, K.i = 16383 & (_[L + 6] << 8 | _[L + 5]), K.Ud = _[L + 6] >> 6, L += 7, R -= 7, c.za = K.c + 15 >> 4, c.Ub = K.i + 15 >> 4, g.width = K.c, g.height = K.i, g.Da = 0, g.j = 0, g.v = 0, g.va = g.width, g.o = g.height, g.da = 0, g.ib = g.width, g.hb = g.height, g.U = g.width, g.T = g.height, r(($ = c.Pa).jb, 0, 255, $.jb.length), t(($ = c.Qa) != null), $.Cb = 0, $.Bb = 0, $.Fb = 1, r($.Zb, 0, 0, $.Zb.length), r($.Lb, 0, 0, $.Lb);
      }
      if (W.ub > R) return dn(c, 7, "bad partition length");
      X($ = c.m, _, L, W.ub), L += W.ub, R -= W.ub, W.Rb && (K.Ld = mt($), K.Kd = mt($)), K = c.Qa;
      var Z, it = c.Pa;
      if (t($ != null), t(K != null), K.Cb = mt($), K.Cb) {
        if (K.Bb = mt($), mt($)) {
          for (K.Fb = mt($), Z = 0; 4 > Z; ++Z) K.Zb[Z] = mt($) ? j($, 7) : 0;
          for (Z = 0; 4 > Z; ++Z) K.Lb[Z] = mt($) ? j($, 6) : 0;
        }
        if (K.Bb) for (Z = 0; 3 > Z; ++Z) it.jb[Z] = mt($) ? H($, 8) : 255;
      } else K.Bb = 0;
      if ($.Ka) return dn(c, 3, "cannot parse segment header");
      if ((K = c.ed).zd = mt($), K.Tb = H($, 6), K.wb = H($, 3), K.Pc = mt($), K.Pc && mt($)) {
        for (it = 0; 4 > it; ++it) mt($) && (K.vd[it] = j($, 6));
        for (it = 0; 4 > it; ++it) mt($) && (K.od[it] = j($, 6));
      }
      if (c.L = K.Tb == 0 ? 0 : K.zd ? 1 : 2, $.Ka) return dn(c, 3, "cannot parse filter header");
      var yt = R;
      if (R = Z = L, L = Z + yt, K = yt, c.Xb = (1 << H(c.m, 2)) - 1, yt < 3 * (it = c.Xb)) _ = 7;
      else {
        for (Z += 3 * it, K -= 3 * it, yt = 0; yt < it; ++yt) {
          var Lt = _[R + 0] | _[R + 1] << 8 | _[R + 2] << 16;
          Lt > K && (Lt = K), X(c.Jc[+yt], _, Z, Lt), Z += Lt, K -= Lt, R += 3;
        }
        X(c.Jc[+it], _, Z, K), _ = Z < L ? 0 : 5;
      }
      if (_ != 0) return dn(c, _, "cannot parse partitions");
      for (_ = H(Z = c.m, 7), R = mt(Z) ? j(Z, 4) : 0, L = mt(Z) ? j(Z, 4) : 0, K = mt(Z) ? j(Z, 4) : 0, it = mt(Z) ? j(Z, 4) : 0, Z = mt(Z) ? j(Z, 4) : 0, yt = c.Qa, Lt = 0; 4 > Lt; ++Lt) {
        if (yt.Cb) {
          var It = yt.Zb[Lt];
          yt.Fb || (It += _);
        } else {
          if (0 < Lt) {
            c.pb[Lt] = c.pb[0];
            continue;
          }
          It = _;
        }
        var Ct = c.pb[Lt];
        Ct.Sc[0] = rh[Ei(It + R, 127)], Ct.Sc[1] = sh[Ei(It + 0, 127)], Ct.Eb[0] = 2 * rh[Ei(It + L, 127)], Ct.Eb[1] = 101581 * sh[Ei(It + K, 127)] >> 16, 8 > Ct.Eb[1] && (Ct.Eb[1] = 8), Ct.Qc[0] = rh[Ei(It + it, 117)], Ct.Qc[1] = sh[Ei(It + Z, 127)], Ct.lc = It + Z;
      }
      if (!W.Rb) return dn(c, 4, "Not a key frame.");
      for (mt($), W = c.Pa, _ = 0; 4 > _; ++_) {
        for (R = 0; 8 > R; ++R) for (L = 0; 3 > L; ++L) for (K = 0; 11 > K; ++K) it = xt($, Jm[_][R][L][K]) ? H($, 8) : Km[_][R][L][K], W.Wc[_][R].Yb[L][K] = it;
        for (R = 0; 17 > R; ++R) W.Xc[_][R] = W.Wc[_][Zm[R]];
      }
      return c.kc = mt($), c.kc && (c.Bd = H($, 8)), c.cb = 1;
    }
    function Fo(c, g, _, L, R, $, W) {
      var K = g[R].Yb[_];
      for (_ = 0; 16 > R; ++R) {
        if (!xt(c, K[_ + 0])) return R;
        for (; !xt(c, K[_ + 1]); ) if (K = g[++R].Yb[0], _ = 0, R == 16) return 16;
        var Z = g[R + 1].Yb;
        if (xt(c, K[_ + 2])) {
          var it = c, yt = 0;
          if (xt(it, (It = K)[(Lt = _) + 3])) if (xt(it, It[Lt + 6])) {
            for (K = 0, Lt = 2 * (yt = xt(it, It[Lt + 8])) + (It = xt(it, It[Lt + 9 + yt])), yt = 0, It = Vm[Lt]; It[K]; ++K) yt += yt + xt(it, It[K]);
            yt += 3 + (8 << Lt);
          } else xt(it, It[Lt + 7]) ? (yt = 7 + 2 * xt(it, 165), yt += xt(it, 145)) : yt = 5 + xt(it, 159);
          else yt = xt(it, It[Lt + 4]) ? 3 + xt(it, It[Lt + 5]) : 2;
          K = Z[2];
        } else yt = 1, K = Z[1];
        Z = W + Ym[R], 0 > (it = c).b && wt(it);
        var Lt, It = it.b, Ct = (Lt = it.Ca >> 1) - (it.I >> It) >> 31;
        --it.b, it.Ca += Ct, it.Ca |= 1, it.I -= (Lt + 1 & Ct) << It, $[Z] = ((yt ^ Ct) - Ct) * L[(0 < R) + 0];
      }
      return 16;
    }
    function Ws(c) {
      var g = c.rb[c.sb - 1];
      g.la = 0, g.Na = 0, r(c.zc, 0, 0, c.zc.length), c.ja = 0;
    }
    function $i(c, g) {
      if (c == null) return 0;
      if (g == null) return dn(c, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!c.cb && !Us(c, g)) return 0;
      if (t(c.cb), g.ac == null || g.ac(g)) {
        g.ob && (c.L = 0);
        var _ = cu[c.L];
        if (c.L == 2 ? (c.yb = 0, c.zb = 0) : (c.yb = g.v - _ >> 4, c.zb = g.j - _ >> 4, 0 > c.yb && (c.yb = 0), 0 > c.zb && (c.zb = 0)), c.Va = g.o + 15 + _ >> 4, c.Hb = g.va + 15 + _ >> 4, c.Hb > c.za && (c.Hb = c.za), c.Va > c.Ub && (c.Va = c.Ub), 0 < c.L) {
          var L = c.ed;
          for (_ = 0; 4 > _; ++_) {
            var R;
            if (c.Qa.Cb) {
              var $ = c.Qa.Lb[_];
              c.Qa.Fb || ($ += L.Tb);
            } else $ = L.Tb;
            for (R = 0; 1 >= R; ++R) {
              var W = c.gd[_][R], K = $;
              if (L.Pc && (K += L.vd[0], R && (K += L.od[0])), 0 < (K = 0 > K ? 0 : 63 < K ? 63 : K)) {
                var Z = K;
                0 < L.wb && (Z = 4 < L.wb ? Z >> 2 : Z >> 1) > 9 - L.wb && (Z = 9 - L.wb), 1 > Z && (Z = 1), W.dd = Z, W.tc = 2 * K + Z, W.ld = 40 <= K ? 2 : 15 <= K ? 1 : 0;
              } else W.tc = 0;
              W.La = R;
            }
          }
        }
        _ = 0;
      } else dn(c, 6, "Frame setup failed"), _ = c.a;
      if (_ = _ == 0) {
        if (_) {
          c.$c = 0, 0 < c.Aa || (c.Ic = h2);
          t: {
            _ = c.Ic, L = 4 * (Z = c.za);
            var it = 32 * Z, yt = Z + 1, Lt = 0 < c.L ? Z * (0 < c.Aa ? 2 : 1) : 0, It = (c.Aa == 2 ? 2 : 1) * Z;
            if ((W = L + 832 + (R = 3 * (16 * _ + cu[c.L]) / 2 * it) + ($ = c.Fa != null && 0 < c.Fa.length ? c.Kc.c * c.Kc.i : 0)) != W) _ = 0;
            else {
              if (W > c.Vb) {
                if (c.Vb = 0, c.Ec = s(W), c.Fc = 0, c.Ec == null) {
                  _ = dn(c, 1, "no memory during frame initialization.");
                  break t;
                }
                c.Vb = W;
              }
              W = c.Ec, K = c.Fc, c.Ac = W, c.Bc = K, K += L, c.Gd = o(it, Oo), c.Hd = 0, c.rb = o(yt + 1, Eo), c.sb = 1, c.wa = Lt ? o(Lt, as) : null, c.Y = 0, c.D.Nb = 0, c.D.wa = c.wa, c.D.Y = c.Y, 0 < c.Aa && (c.D.Y += Z), t(!0), c.oc = W, c.pc = K, K += 832, c.ya = o(It, $s), c.aa = 0, c.D.ya = c.ya, c.D.aa = c.aa, c.Aa == 2 && (c.D.aa += Z), c.R = 16 * Z, c.B = 8 * Z, Z = (it = cu[c.L]) * c.R, it = it / 2 * c.B, c.sa = W, c.ta = K + Z, c.qa = c.sa, c.ra = c.ta + 16 * _ * c.R + it, c.Ha = c.qa, c.Ia = c.ra + 8 * _ * c.B + it, c.$c = 0, K += R, c.mb = $ ? W : null, c.nb = $ ? K : null, t(K + $ <= c.Fc + c.Vb), Ws(c), r(c.Ac, c.Bc, 0, L), _ = 1;
            }
          }
          if (_) {
            if (g.ka = 0, g.y = c.sa, g.O = c.ta, g.f = c.qa, g.N = c.ra, g.ea = c.Ha, g.Vd = c.Ia, g.fa = c.R, g.Rc = c.B, g.F = null, g.J = 0, !eu) {
              for (_ = -255; 255 >= _; ++_) Bn[255 + _] = 0 > _ ? -_ : _;
              for (_ = -1020; 1020 >= _; ++_) Vr[1020 + _] = -128 > _ ? -128 : 127 < _ ? 127 : _;
              for (_ = -112; 112 >= _; ++_) el[112 + _] = -16 > _ ? -16 : 15 < _ ? 15 : _;
              for (_ = -255; 510 >= _; ++_) Zo[255 + _] = 0 > _ ? 0 : 255 < _ ? 255 : _;
              eu = 1;
            }
            Ko = lt, Gr = Mo, Za = Ro, hi = Fa, Wi = Do, kn = $r, Xo = ja, tu = Ks, Qa = Xc, Zs = qa, Qs = Kc, ys = qo, to = za, Jo = Yl, eo = Vl, bs = xr, tl = Ur, Hi = Yc, sr[0] = mi, sr[1] = _t, sr[2] = Ii, sr[3] = Ma, sr[4] = Hs, sr[5] = Bo, sr[6] = Gs, sr[7] = Ra, sr[8] = Hc, sr[9] = Wc, vs[0] = Ge, vs[1] = Tt, vs[2] = fe, vs[3] = le, vs[4] = Me, vs[5] = Le, vs[6] = je, Yr[0] = fs, Yr[1] = Wt, Yr[2] = Gc, Yr[3] = Da, Yr[4] = Ys, Yr[5] = Vc, Yr[6] = Ba, _ = 1;
          } else _ = 0;
        }
        _ && (_ = function(Ct, Vt) {
          for (Ct.M = 0; Ct.M < Ct.Va; ++Ct.M) {
            var Mt, bt = Ct.Jc[Ct.M & Ct.Xb], St = Ct.m, Ht = Ct;
            for (Mt = 0; Mt < Ht.za; ++Mt) {
              var Yt = St, Gt = Ht, ce = Gt.Ac, re = Gt.Bc + 4 * Mt, _e = Gt.zc, se = Gt.ya[Gt.aa + Mt];
              if (Gt.Qa.Bb ? se.$b = xt(Yt, Gt.Pa.jb[0]) ? 2 + xt(Yt, Gt.Pa.jb[2]) : xt(Yt, Gt.Pa.jb[1]) : se.$b = 0, Gt.kc && (se.Ad = xt(Yt, Gt.Bd)), se.Za = !xt(Yt, 145) + 0, se.Za) {
                var Ke = se.Ob, Qe = 0;
                for (Gt = 0; 4 > Gt; ++Gt) {
                  var ze, De = _e[0 + Gt];
                  for (ze = 0; 4 > ze; ++ze) {
                    De = Xm[ce[re + ze]][De];
                    for (var on = Vd[xt(Yt, De[0])]; 0 < on; ) on = Vd[2 * on + xt(Yt, De[on])];
                    De = -on, ce[re + ze] = De;
                  }
                  i(Ke, Qe, ce, re, 4), Qe += 4, _e[0 + Gt] = De;
                }
              } else De = xt(Yt, 156) ? xt(Yt, 128) ? 1 : 3 : xt(Yt, 163) ? 2 : 0, se.Ob[0] = De, r(ce, re, De, 4), r(_e, 0, De, 4);
              se.Dd = xt(Yt, 142) ? xt(Yt, 114) ? xt(Yt, 183) ? 1 : 3 : 2 : 0;
            }
            if (Ht.m.Ka) return dn(Ct, 7, "Premature end-of-partition0 encountered.");
            for (; Ct.ja < Ct.za; ++Ct.ja) {
              if (Ht = bt, Yt = (St = Ct).rb[St.sb - 1], ce = St.rb[St.sb + St.ja], Mt = St.ya[St.aa + St.ja], re = St.kc ? Mt.Ad : 0) Yt.la = ce.la = 0, Mt.Za || (Yt.Na = ce.Na = 0), Mt.Hc = 0, Mt.Gc = 0, Mt.ia = 0;
              else {
                var nn, Te;
                if (Yt = ce, ce = Ht, re = St.Pa.Xc, _e = St.ya[St.aa + St.ja], se = St.pb[_e.$b], Gt = _e.ad, Ke = 0, Qe = St.rb[St.sb - 1], De = ze = 0, r(Gt, Ke, 0, 384), _e.Za) var Tn = 0, vi = re[3];
                else {
                  on = s(16);
                  var Fn = Yt.Na + Qe.Na;
                  if (Fn = nl(ce, re[1], Fn, se.Eb, 0, on, 0), Yt.Na = Qe.Na = (0 < Fn) + 0, 1 < Fn) Ko(on, 0, Gt, Ke);
                  else {
                    var wi = on[0] + 3 >> 3;
                    for (on = 0; 256 > on; on += 16) Gt[Ke + on] = wi;
                  }
                  Tn = 1, vi = re[0];
                }
                var tn = 15 & Yt.la, Ti = 15 & Qe.la;
                for (on = 0; 4 > on; ++on) {
                  var Fi = 1 & Ti;
                  for (wi = Te = 0; 4 > wi; ++wi) tn = tn >> 1 | (Fi = (Fn = nl(ce, vi, Fn = Fi + (1 & tn), se.Sc, Tn, Gt, Ke)) > Tn) << 7, Te = Te << 2 | (3 < Fn ? 3 : 1 < Fn ? 2 : Gt[Ke + 0] != 0), Ke += 16;
                  tn >>= 4, Ti = Ti >> 1 | Fi << 7, ze = (ze << 8 | Te) >>> 0;
                }
                for (vi = tn, Tn = Ti >> 4, nn = 0; 4 > nn; nn += 2) {
                  for (Te = 0, tn = Yt.la >> 4 + nn, Ti = Qe.la >> 4 + nn, on = 0; 2 > on; ++on) {
                    for (Fi = 1 & Ti, wi = 0; 2 > wi; ++wi) Fn = Fi + (1 & tn), tn = tn >> 1 | (Fi = 0 < (Fn = nl(ce, re[2], Fn, se.Qc, 0, Gt, Ke))) << 3, Te = Te << 2 | (3 < Fn ? 3 : 1 < Fn ? 2 : Gt[Ke + 0] != 0), Ke += 16;
                    tn >>= 2, Ti = Ti >> 1 | Fi << 5;
                  }
                  De |= Te << 4 * nn, vi |= tn << 4 << nn, Tn |= (240 & Ti) << nn;
                }
                Yt.la = vi, Qe.la = Tn, _e.Hc = ze, _e.Gc = De, _e.ia = 43690 & De ? 0 : se.ia, re = !(ze | De);
              }
              if (0 < St.L && (St.wa[St.Y + St.ja] = St.gd[Mt.$b][Mt.Za], St.wa[St.Y + St.ja].La |= !re), Ht.Ka) return dn(Ct, 7, "Premature end-of-file encountered.");
            }
            if (Ws(Ct), St = Vt, Ht = 1, Mt = (bt = Ct).D, Yt = 0 < bt.L && bt.M >= bt.zb && bt.M <= bt.Va, bt.Aa == 0) t: {
              if (Mt.M = bt.M, Mt.uc = Yt, Va(bt, Mt), Ht = 1, Mt = (Te = bt.D).Nb, Yt = (De = cu[bt.L]) * bt.R, ce = De / 2 * bt.B, on = 16 * Mt * bt.R, wi = 8 * Mt * bt.B, re = bt.sa, _e = bt.ta - Yt + on, se = bt.qa, Gt = bt.ra - ce + wi, Ke = bt.Ha, Qe = bt.Ia - ce + wi, Ti = (tn = Te.M) == 0, ze = tn >= bt.Va - 1, bt.Aa == 2 && Va(bt, Te), Te.uc) for (Fi = (Fn = bt).D.M, t(Fn.D.uc), Te = Fn.yb; Te < Fn.Hb; ++Te) {
                Tn = Te, vi = Fi;
                var $n = (Kn = (_n = Fn).D).Nb;
                nn = _n.R;
                var Kn = Kn.wa[Kn.Y + Tn], fi = _n.sa, Ki = _n.ta + 16 * $n * nn + 16 * Tn, Sr = Kn.dd, Un = Kn.tc;
                if (Un != 0) if (t(3 <= Un), _n.L == 1) 0 < Tn && bs(fi, Ki, nn, Un + 4), Kn.La && Hi(fi, Ki, nn, Un), 0 < vi && eo(fi, Ki, nn, Un + 4), Kn.La && tl(fi, Ki, nn, Un);
                else {
                  var Kr = _n.B, no = _n.qa, Qo = _n.ra + 8 * $n * Kr + 8 * Tn, xs = _n.Ha, _n = _n.Ia + 8 * $n * Kr + 8 * Tn;
                  $n = Kn.ld, 0 < Tn && (tu(fi, Ki, nn, Un + 4, Sr, $n), Zs(no, Qo, xs, _n, Kr, Un + 4, Sr, $n)), Kn.La && (ys(fi, Ki, nn, Un, Sr, $n), Jo(no, Qo, xs, _n, Kr, Un, Sr, $n)), 0 < vi && (Xo(fi, Ki, nn, Un + 4, Sr, $n), Qa(no, Qo, xs, _n, Kr, Un + 4, Sr, $n)), Kn.La && (Qs(fi, Ki, nn, Un, Sr, $n), to(no, Qo, xs, _n, Kr, Un, Sr, $n));
                }
              }
              if (bt.ia && alert("todo:DitherRow"), St.put != null) {
                if (Te = 16 * tn, tn = 16 * (tn + 1), Ti ? (St.y = bt.sa, St.O = bt.ta + on, St.f = bt.qa, St.N = bt.ra + wi, St.ea = bt.Ha, St.W = bt.Ia + wi) : (Te -= De, St.y = re, St.O = _e, St.f = se, St.N = Gt, St.ea = Ke, St.W = Qe), ze || (tn -= De), tn > St.o && (tn = St.o), St.F = null, St.J = null, bt.Fa != null && 0 < bt.Fa.length && Te < tn && (St.J = Ha(bt, St, Te, tn - Te), St.F = bt.mb, St.F == null && St.F.length == 0)) {
                  Ht = dn(bt, 3, "Could not decode alpha data.");
                  break t;
                }
                Te < St.j && (De = St.j - Te, Te = St.j, t(!(1 & De)), St.O += bt.R * De, St.N += bt.B * (De >> 1), St.W += bt.B * (De >> 1), St.F != null && (St.J += St.width * De)), Te < tn && (St.O += St.v, St.N += St.v >> 1, St.W += St.v >> 1, St.F != null && (St.J += St.v), St.ka = Te - St.j, St.U = St.va - St.v, St.T = tn - Te, Ht = St.put(St));
              }
              Mt + 1 != bt.Ic || ze || (i(bt.sa, bt.ta - Yt, re, _e + 16 * bt.R, Yt), i(bt.qa, bt.ra - ce, se, Gt + 8 * bt.B, ce), i(bt.Ha, bt.Ia - ce, Ke, Qe + 8 * bt.B, ce));
            }
            if (!Ht) return dn(Ct, 6, "Output aborted.");
          }
          return 1;
        }(c, g)), g.bc != null && g.bc(g), _ &= 1;
      }
      return _ ? (c.cb = 0, _) : 0;
    }
    function Li(c, g, _, L, R) {
      R = c[g + _ + 32 * L] + (R >> 3), c[g + _ + 32 * L] = -256 & R ? 0 > R ? 0 : 255 : R;
    }
    function cs(c, g, _, L, R, $) {
      Li(c, g, 0, _, L + R), Li(c, g, 1, _, L + $), Li(c, g, 2, _, L - $), Li(c, g, 3, _, L - R);
    }
    function Vn(c) {
      return (20091 * c >> 16) + c;
    }
    function hs(c, g, _, L) {
      var R, $ = 0, W = s(16);
      for (R = 0; 4 > R; ++R) {
        var K = c[g + 0] + c[g + 8], Z = c[g + 0] - c[g + 8], it = (35468 * c[g + 4] >> 16) - Vn(c[g + 12]), yt = Vn(c[g + 4]) + (35468 * c[g + 12] >> 16);
        W[$ + 0] = K + yt, W[$ + 1] = Z + it, W[$ + 2] = Z - it, W[$ + 3] = K - yt, $ += 4, g++;
      }
      for (R = $ = 0; 4 > R; ++R) K = (c = W[$ + 0] + 4) + W[$ + 8], Z = c - W[$ + 8], it = (35468 * W[$ + 4] >> 16) - Vn(W[$ + 12]), Li(_, L, 0, 0, K + (yt = Vn(W[$ + 4]) + (35468 * W[$ + 12] >> 16))), Li(_, L, 1, 0, Z + it), Li(_, L, 2, 0, Z - it), Li(_, L, 3, 0, K - yt), $++, L += 32;
    }
    function $r(c, g, _, L) {
      var R = c[g + 0] + 4, $ = 35468 * c[g + 4] >> 16, W = Vn(c[g + 4]), K = 35468 * c[g + 1] >> 16;
      cs(_, L, 0, R + W, c = Vn(c[g + 1]), K), cs(_, L, 1, R + $, c, K), cs(_, L, 2, R - $, c, K), cs(_, L, 3, R - W, c, K);
    }
    function Mo(c, g, _, L, R) {
      hs(c, g, _, L), R && hs(c, g + 16, _, L + 4);
    }
    function Ro(c, g, _, L) {
      Gr(c, g + 0, _, L, 1), Gr(c, g + 32, _, L + 128, 1);
    }
    function Fa(c, g, _, L) {
      var R;
      for (c = c[g + 0] + 4, R = 0; 4 > R; ++R) for (g = 0; 4 > g; ++g) Li(_, L, g, R, c);
    }
    function Do(c, g, _, L) {
      c[g + 0] && hi(c, g + 0, _, L), c[g + 16] && hi(c, g + 16, _, L + 4), c[g + 32] && hi(c, g + 32, _, L + 128), c[g + 48] && hi(c, g + 48, _, L + 128 + 4);
    }
    function lt(c, g, _, L) {
      var R, $ = s(16);
      for (R = 0; 4 > R; ++R) {
        var W = c[g + 0 + R] + c[g + 12 + R], K = c[g + 4 + R] + c[g + 8 + R], Z = c[g + 4 + R] - c[g + 8 + R], it = c[g + 0 + R] - c[g + 12 + R];
        $[0 + R] = W + K, $[8 + R] = W - K, $[4 + R] = it + Z, $[12 + R] = it - Z;
      }
      for (R = 0; 4 > R; ++R) W = (c = $[0 + 4 * R] + 3) + $[3 + 4 * R], K = $[1 + 4 * R] + $[2 + 4 * R], Z = $[1 + 4 * R] - $[2 + 4 * R], it = c - $[3 + 4 * R], _[L + 0] = W + K >> 3, _[L + 16] = it + Z >> 3, _[L + 32] = W - K >> 3, _[L + 48] = it - Z >> 3, L += 64;
    }
    function pt(c, g, _) {
      var L, R = g - 32, $ = Oi, W = 255 - c[R - 1];
      for (L = 0; L < _; ++L) {
        var K, Z = $, it = W + c[g - 1];
        for (K = 0; K < _; ++K) c[g + K] = Z[it + c[R + K]];
        g += 32;
      }
    }
    function _t(c, g) {
      pt(c, g, 4);
    }
    function Wt(c, g) {
      pt(c, g, 8);
    }
    function Tt(c, g) {
      pt(c, g, 16);
    }
    function fe(c, g) {
      var _;
      for (_ = 0; 16 > _; ++_) i(c, g + 32 * _, c, g - 32, 16);
    }
    function le(c, g) {
      var _;
      for (_ = 16; 0 < _; --_) r(c, g, c[g - 1], 16), g += 32;
    }
    function ve(c, g, _) {
      var L;
      for (L = 0; 16 > L; ++L) r(g, _ + 32 * L, c, 16);
    }
    function Ge(c, g) {
      var _, L = 16;
      for (_ = 0; 16 > _; ++_) L += c[g - 1 + 32 * _] + c[g + _ - 32];
      ve(L >> 5, c, g);
    }
    function Me(c, g) {
      var _, L = 8;
      for (_ = 0; 16 > _; ++_) L += c[g - 1 + 32 * _];
      ve(L >> 4, c, g);
    }
    function Le(c, g) {
      var _, L = 8;
      for (_ = 0; 16 > _; ++_) L += c[g + _ - 32];
      ve(L >> 4, c, g);
    }
    function je(c, g) {
      ve(128, c, g);
    }
    function Zt(c, g, _) {
      return c + 2 * g + _ + 2 >> 2;
    }
    function Ii(c, g) {
      var _, L = g - 32;
      for (L = new Uint8Array([Zt(c[L - 1], c[L + 0], c[L + 1]), Zt(c[L + 0], c[L + 1], c[L + 2]), Zt(c[L + 1], c[L + 2], c[L + 3]), Zt(c[L + 2], c[L + 3], c[L + 4])]), _ = 0; 4 > _; ++_) i(c, g + 32 * _, L, 0, L.length);
    }
    function Ma(c, g) {
      var _ = c[g - 1], L = c[g - 1 + 32], R = c[g - 1 + 64], $ = c[g - 1 + 96];
      zt(c, g + 0, 16843009 * Zt(c[g - 1 - 32], _, L)), zt(c, g + 32, 16843009 * Zt(_, L, R)), zt(c, g + 64, 16843009 * Zt(L, R, $)), zt(c, g + 96, 16843009 * Zt(R, $, $));
    }
    function mi(c, g) {
      var _, L = 4;
      for (_ = 0; 4 > _; ++_) L += c[g + _ - 32] + c[g - 1 + 32 * _];
      for (L >>= 3, _ = 0; 4 > _; ++_) r(c, g + 32 * _, L, 4);
    }
    function Hs(c, g) {
      var _ = c[g - 1 + 0], L = c[g - 1 + 32], R = c[g - 1 + 64], $ = c[g - 1 - 32], W = c[g + 0 - 32], K = c[g + 1 - 32], Z = c[g + 2 - 32], it = c[g + 3 - 32];
      c[g + 0 + 96] = Zt(L, R, c[g - 1 + 96]), c[g + 1 + 96] = c[g + 0 + 64] = Zt(_, L, R), c[g + 2 + 96] = c[g + 1 + 64] = c[g + 0 + 32] = Zt($, _, L), c[g + 3 + 96] = c[g + 2 + 64] = c[g + 1 + 32] = c[g + 0 + 0] = Zt(W, $, _), c[g + 3 + 64] = c[g + 2 + 32] = c[g + 1 + 0] = Zt(K, W, $), c[g + 3 + 32] = c[g + 2 + 0] = Zt(Z, K, W), c[g + 3 + 0] = Zt(it, Z, K);
    }
    function Gs(c, g) {
      var _ = c[g + 1 - 32], L = c[g + 2 - 32], R = c[g + 3 - 32], $ = c[g + 4 - 32], W = c[g + 5 - 32], K = c[g + 6 - 32], Z = c[g + 7 - 32];
      c[g + 0 + 0] = Zt(c[g + 0 - 32], _, L), c[g + 1 + 0] = c[g + 0 + 32] = Zt(_, L, R), c[g + 2 + 0] = c[g + 1 + 32] = c[g + 0 + 64] = Zt(L, R, $), c[g + 3 + 0] = c[g + 2 + 32] = c[g + 1 + 64] = c[g + 0 + 96] = Zt(R, $, W), c[g + 3 + 32] = c[g + 2 + 64] = c[g + 1 + 96] = Zt($, W, K), c[g + 3 + 64] = c[g + 2 + 96] = Zt(W, K, Z), c[g + 3 + 96] = Zt(K, Z, Z);
    }
    function Bo(c, g) {
      var _ = c[g - 1 + 0], L = c[g - 1 + 32], R = c[g - 1 + 64], $ = c[g - 1 - 32], W = c[g + 0 - 32], K = c[g + 1 - 32], Z = c[g + 2 - 32], it = c[g + 3 - 32];
      c[g + 0 + 0] = c[g + 1 + 64] = $ + W + 1 >> 1, c[g + 1 + 0] = c[g + 2 + 64] = W + K + 1 >> 1, c[g + 2 + 0] = c[g + 3 + 64] = K + Z + 1 >> 1, c[g + 3 + 0] = Z + it + 1 >> 1, c[g + 0 + 96] = Zt(R, L, _), c[g + 0 + 64] = Zt(L, _, $), c[g + 0 + 32] = c[g + 1 + 96] = Zt(_, $, W), c[g + 1 + 32] = c[g + 2 + 96] = Zt($, W, K), c[g + 2 + 32] = c[g + 3 + 96] = Zt(W, K, Z), c[g + 3 + 32] = Zt(K, Z, it);
    }
    function Ra(c, g) {
      var _ = c[g + 0 - 32], L = c[g + 1 - 32], R = c[g + 2 - 32], $ = c[g + 3 - 32], W = c[g + 4 - 32], K = c[g + 5 - 32], Z = c[g + 6 - 32], it = c[g + 7 - 32];
      c[g + 0 + 0] = _ + L + 1 >> 1, c[g + 1 + 0] = c[g + 0 + 64] = L + R + 1 >> 1, c[g + 2 + 0] = c[g + 1 + 64] = R + $ + 1 >> 1, c[g + 3 + 0] = c[g + 2 + 64] = $ + W + 1 >> 1, c[g + 0 + 32] = Zt(_, L, R), c[g + 1 + 32] = c[g + 0 + 96] = Zt(L, R, $), c[g + 2 + 32] = c[g + 1 + 96] = Zt(R, $, W), c[g + 3 + 32] = c[g + 2 + 96] = Zt($, W, K), c[g + 3 + 64] = Zt(W, K, Z), c[g + 3 + 96] = Zt(K, Z, it);
    }
    function Wc(c, g) {
      var _ = c[g - 1 + 0], L = c[g - 1 + 32], R = c[g - 1 + 64], $ = c[g - 1 + 96];
      c[g + 0 + 0] = _ + L + 1 >> 1, c[g + 2 + 0] = c[g + 0 + 32] = L + R + 1 >> 1, c[g + 2 + 32] = c[g + 0 + 64] = R + $ + 1 >> 1, c[g + 1 + 0] = Zt(_, L, R), c[g + 3 + 0] = c[g + 1 + 32] = Zt(L, R, $), c[g + 3 + 32] = c[g + 1 + 64] = Zt(R, $, $), c[g + 3 + 64] = c[g + 2 + 64] = c[g + 0 + 96] = c[g + 1 + 96] = c[g + 2 + 96] = c[g + 3 + 96] = $;
    }
    function Hc(c, g) {
      var _ = c[g - 1 + 0], L = c[g - 1 + 32], R = c[g - 1 + 64], $ = c[g - 1 + 96], W = c[g - 1 - 32], K = c[g + 0 - 32], Z = c[g + 1 - 32], it = c[g + 2 - 32];
      c[g + 0 + 0] = c[g + 2 + 32] = _ + W + 1 >> 1, c[g + 0 + 32] = c[g + 2 + 64] = L + _ + 1 >> 1, c[g + 0 + 64] = c[g + 2 + 96] = R + L + 1 >> 1, c[g + 0 + 96] = $ + R + 1 >> 1, c[g + 3 + 0] = Zt(K, Z, it), c[g + 2 + 0] = Zt(W, K, Z), c[g + 1 + 0] = c[g + 3 + 32] = Zt(_, W, K), c[g + 1 + 32] = c[g + 3 + 64] = Zt(L, _, W), c[g + 1 + 64] = c[g + 3 + 96] = Zt(R, L, _), c[g + 1 + 96] = Zt($, R, L);
    }
    function Gc(c, g) {
      var _;
      for (_ = 0; 8 > _; ++_) i(c, g + 32 * _, c, g - 32, 8);
    }
    function Da(c, g) {
      var _;
      for (_ = 0; 8 > _; ++_) r(c, g, c[g - 1], 8), g += 32;
    }
    function Vs(c, g, _) {
      var L;
      for (L = 0; 8 > L; ++L) r(g, _ + 32 * L, c, 8);
    }
    function fs(c, g) {
      var _, L = 8;
      for (_ = 0; 8 > _; ++_) L += c[g + _ - 32] + c[g - 1 + 32 * _];
      Vs(L >> 4, c, g);
    }
    function Vc(c, g) {
      var _, L = 4;
      for (_ = 0; 8 > _; ++_) L += c[g + _ - 32];
      Vs(L >> 3, c, g);
    }
    function Ys(c, g) {
      var _, L = 4;
      for (_ = 0; 8 > _; ++_) L += c[g - 1 + 32 * _];
      Vs(L >> 3, c, g);
    }
    function Ba(c, g) {
      Vs(128, c, g);
    }
    function jo(c, g, _) {
      var L = c[g - _], R = c[g + 0], $ = 3 * (R - L) + Qc[1020 + c[g - 2 * _] - c[g + _]], W = nu[112 + ($ + 4 >> 3)];
      c[g - _] = Oi[255 + L + nu[112 + ($ + 3 >> 3)]], c[g + 0] = Oi[255 + R - W];
    }
    function Wl(c, g, _, L) {
      var R = c[g + 0], $ = c[g + _];
      return Vi[255 + c[g - 2 * _] - c[g - _]] > L || Vi[255 + $ - R] > L;
    }
    function Hl(c, g, _, L) {
      return 4 * Vi[255 + c[g - _] - c[g + 0]] + Vi[255 + c[g - 2 * _] - c[g + _]] <= L;
    }
    function Gl(c, g, _, L, R) {
      var $ = c[g - 3 * _], W = c[g - 2 * _], K = c[g - _], Z = c[g + 0], it = c[g + _], yt = c[g + 2 * _], Lt = c[g + 3 * _];
      return 4 * Vi[255 + K - Z] + Vi[255 + W - it] > L ? 0 : Vi[255 + c[g - 4 * _] - $] <= R && Vi[255 + $ - W] <= R && Vi[255 + W - K] <= R && Vi[255 + Lt - yt] <= R && Vi[255 + yt - it] <= R && Vi[255 + it - Z] <= R;
    }
    function Vl(c, g, _, L) {
      var R = 2 * L + 1;
      for (L = 0; 16 > L; ++L) Hl(c, g + L, _, R) && jo(c, g + L, _);
    }
    function xr(c, g, _, L) {
      var R = 2 * L + 1;
      for (L = 0; 16 > L; ++L) Hl(c, g + L * _, 1, R) && jo(c, g + L * _, 1);
    }
    function Ur(c, g, _, L) {
      var R;
      for (R = 3; 0 < R; --R) Vl(c, g += 4 * _, _, L);
    }
    function Yc(c, g, _, L) {
      var R;
      for (R = 3; 0 < R; --R) xr(c, g += 4, _, L);
    }
    function ds(c, g, _, L, R, $, W, K) {
      for ($ = 2 * $ + 1; 0 < R--; ) {
        if (Gl(c, g, _, $, W)) if (Wl(c, g, _, K)) jo(c, g, _);
        else {
          var Z = c, it = g, yt = _, Lt = Z[it - 2 * yt], It = Z[it - yt], Ct = Z[it + 0], Vt = Z[it + yt], Mt = Z[it + 2 * yt], bt = 27 * (Ht = Qc[1020 + 3 * (Ct - It) + Qc[1020 + Lt - Vt]]) + 63 >> 7, St = 18 * Ht + 63 >> 7, Ht = 9 * Ht + 63 >> 7;
          Z[it - 3 * yt] = Oi[255 + Z[it - 3 * yt] + Ht], Z[it - 2 * yt] = Oi[255 + Lt + St], Z[it - yt] = Oi[255 + It + bt], Z[it + 0] = Oi[255 + Ct - bt], Z[it + yt] = Oi[255 + Vt - St], Z[it + 2 * yt] = Oi[255 + Mt - Ht];
        }
        g += L;
      }
    }
    function ir(c, g, _, L, R, $, W, K) {
      for ($ = 2 * $ + 1; 0 < R--; ) {
        if (Gl(c, g, _, $, W)) if (Wl(c, g, _, K)) jo(c, g, _);
        else {
          var Z = c, it = g, yt = _, Lt = Z[it - yt], It = Z[it + 0], Ct = Z[it + yt], Vt = nu[112 + ((Mt = 3 * (It - Lt)) + 4 >> 3)], Mt = nu[112 + (Mt + 3 >> 3)], bt = Vt + 1 >> 1;
          Z[it - 2 * yt] = Oi[255 + Z[it - 2 * yt] + bt], Z[it - yt] = Oi[255 + Lt + Mt], Z[it + 0] = Oi[255 + It - Vt], Z[it + yt] = Oi[255 + Ct - bt];
        }
        g += L;
      }
    }
    function ja(c, g, _, L, R, $) {
      ds(c, g, _, 1, 16, L, R, $);
    }
    function Ks(c, g, _, L, R, $) {
      ds(c, g, 1, _, 16, L, R, $);
    }
    function Kc(c, g, _, L, R, $) {
      var W;
      for (W = 3; 0 < W; --W) ir(c, g += 4 * _, _, 1, 16, L, R, $);
    }
    function qo(c, g, _, L, R, $) {
      var W;
      for (W = 3; 0 < W; --W) ir(c, g += 4, 1, _, 16, L, R, $);
    }
    function Xc(c, g, _, L, R, $, W, K) {
      ds(c, g, R, 1, 8, $, W, K), ds(_, L, R, 1, 8, $, W, K);
    }
    function qa(c, g, _, L, R, $, W, K) {
      ds(c, g, 1, R, 8, $, W, K), ds(_, L, 1, R, 8, $, W, K);
    }
    function za(c, g, _, L, R, $, W, K) {
      ir(c, g + 4 * R, R, 1, 8, $, W, K), ir(_, L + 4 * R, R, 1, 8, $, W, K);
    }
    function Yl(c, g, _, L, R, $, W, K) {
      ir(c, g + 4, 1, R, 8, $, W, K), ir(_, L + 4, 1, R, 8, $, W, K);
    }
    function zo() {
      this.ba = new Dn(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new We(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function $a() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Ua() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Kl() {
      this.ua = 0, this.Wa = new U(), this.vb = new U(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new S(), this.yc = new A();
    }
    function Jc() {
      this.xb = this.a = 0, this.l = new us(), this.ca = new Dn(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N(), this.Pb = 0, this.wd = new N(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Kl(), this.ab = 0, this.gc = o(4, Ua), this.Oc = 0;
    }
    function $o() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new us(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Xs(c, g, _, L, R, $, W) {
      for (c = c == null ? 0 : c[g + 0], g = 0; g < W; ++g) R[$ + g] = c + _[L + g] & 255, c = R[$ + g];
    }
    function Wa(c, g, _, L, R, $, W) {
      var K;
      if (c == null) Xs(null, null, _, L, R, $, W);
      else for (K = 0; K < W; ++K) R[$ + K] = c[g + K] + _[L + K] & 255;
    }
    function ps(c, g, _, L, R, $, W) {
      if (c == null) Xs(null, null, _, L, R, $, W);
      else {
        var K, Z = c[g + 0], it = Z, yt = Z;
        for (K = 0; K < W; ++K) it = yt + (Z = c[g + K]) - it, yt = _[L + K] + (-256 & it ? 0 > it ? 0 : 255 : it) & 255, it = Z, R[$ + K] = yt;
      }
    }
    function Ha(c, g, _, L) {
      var R = g.width, $ = g.o;
      if (t(c != null && g != null), 0 > _ || 0 >= L || _ + L > $) return null;
      if (!c.Cc) {
        if (c.ga == null) {
          var W;
          if (c.ga = new $o(), (W = c.ga == null) || (W = g.width * g.o, t(c.Gb.length == 0), c.Gb = s(W), c.Uc = 0, c.Gb == null ? W = 0 : (c.mb = c.Gb, c.nb = c.Uc, c.rc = null, W = 1), W = !W), !W) {
            W = c.ga;
            var K = c.Fa, Z = c.P, it = c.qc, yt = c.mb, Lt = c.nb, It = Z + 1, Ct = it - 1, Vt = W.l;
            if (t(K != null && yt != null && g != null), ws[0] = null, ws[1] = Xs, ws[2] = Wa, ws[3] = ps, W.ca = yt, W.tb = Lt, W.c = g.width, W.i = g.height, t(0 < W.c && 0 < W.i), 1 >= it) g = 0;
            else if (W.$a = K[Z + 0] >> 0 & 3, W.Z = K[Z + 0] >> 2 & 3, W.Lc = K[Z + 0] >> 4 & 3, Z = K[Z + 0] >> 6 & 3, 0 > W.$a || 1 < W.$a || 4 <= W.Z || 1 < W.Lc || Z) g = 0;
            else if (Vt.put = Bi, Vt.ac = En, Vt.bc = mn, Vt.ma = W, Vt.width = g.width, Vt.height = g.height, Vt.Da = g.Da, Vt.v = g.v, Vt.va = g.va, Vt.j = g.j, Vt.o = g.o, W.$a) t: {
              t(W.$a == 1), g = Pi();
              e: for (; ; ) {
                if (g == null) {
                  g = 0;
                  break t;
                }
                if (t(W != null), W.mc = g, g.c = W.c, g.i = W.i, g.l = W.l, g.l.ma = W, g.l.width = W.c, g.l.height = W.i, g.a = 0, Q(g.m, K, It, Ct), !zi(W.c, W.i, 1, g, null) || (g.ab == 1 && g.gc[0].hc == 3 && er(g.s) ? (W.ic = 1, K = g.c * g.i, g.Ta = null, g.Ua = 0, g.V = s(K), g.Ba = 0, g.V == null ? (g.a = 1, g = 0) : g = 1) : (W.ic = 0, g = wr(g, W.c)), !g)) break e;
                g = 1;
                break t;
              }
              W.mc = null, g = 0;
            }
            else g = Ct >= W.c * W.i;
            W = !g;
          }
          if (W) return null;
          c.ga.Lc != 1 ? c.Ga = 0 : L = $ - _;
        }
        t(c.ga != null), t(_ + L <= $);
        t: {
          if (g = (K = c.ga).c, $ = K.l.o, K.$a == 0) {
            if (It = c.rc, Ct = c.Vc, Vt = c.Fa, Z = c.P + 1 + _ * g, it = c.mb, yt = c.nb + _ * g, t(Z <= c.P + c.qc), K.Z != 0) for (t(ws[K.Z] != null), W = 0; W < L; ++W) ws[K.Z](It, Ct, Vt, Z, it, yt, g), It = it, Ct = yt, yt += g, Z += g;
            else for (W = 0; W < L; ++W) i(it, yt, Vt, Z, g), It = it, Ct = yt, yt += g, Z += g;
            c.rc = It, c.Vc = Ct;
          } else {
            if (t(K.mc != null), g = _ + L, t((W = K.mc) != null), t(g <= W.i), W.C >= g) g = 1;
            else if (K.ic || Pt(), K.ic) {
              K = W.V, It = W.Ba, Ct = W.c;
              var Mt = W.i, bt = (Vt = 1, Z = W.$ / Ct, it = W.$ % Ct, yt = W.m, Lt = W.s, W.$), St = Ct * Mt, Ht = Ct * g, Yt = Lt.wc, Gt = bt < Ht ? wn(Lt, it, Z) : null;
              t(bt <= St), t(g <= Mt), t(er(Lt));
              e: for (; ; ) {
                for (; !yt.h && bt < Ht; ) {
                  if (it & Yt || (Gt = wn(Lt, it, Z)), t(Gt != null), ot(yt), 256 > (Mt = ti(Gt.G[0], Gt.H[0], yt))) K[It + bt] = Mt, ++bt, ++it >= Ct && (it = 0, ++Z <= g && !(Z % 16) && Ni(W, Z));
                  else {
                    if (!(280 > Mt)) {
                      Vt = 0;
                      break e;
                    }
                    Mt = Ai(Mt - 256, yt);
                    var ce, re = ti(Gt.G[4], Gt.H[4], yt);
                    if (ot(yt), !(bt >= (re = ji(Ct, re = Ai(re, yt))) && St - bt >= Mt)) {
                      Vt = 0;
                      break e;
                    }
                    for (ce = 0; ce < Mt; ++ce) K[It + bt + ce] = K[It + bt + ce - re];
                    for (bt += Mt, it += Mt; it >= Ct; ) it -= Ct, ++Z <= g && !(Z % 16) && Ni(W, Z);
                    bt < Ht && it & Yt && (Gt = wn(Lt, it, Z));
                  }
                  t(yt.h == V(yt));
                }
                Ni(W, Z > g ? g : Z);
                break e;
              }
              !Vt || yt.h && bt < St ? (Vt = 0, W.a = yt.h ? 5 : 3) : W.$ = bt, g = Vt;
            } else g = Ci(W, W.V, W.Ba, W.c, W.i, g, Dr);
            if (!g) {
              L = 0;
              break t;
            }
          }
          _ + L >= $ && (c.Cc = 1), L = 1;
        }
        if (!L) return null;
        if (c.Cc && ((L = c.ga) != null && (L.mc = null), c.ga = null, 0 < c.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return c.nb + _ * R;
    }
    function w(c, g, _, L, R, $) {
      for (; 0 < R--; ) {
        var W, K = c, Z = g + (_ ? 1 : 0), it = c, yt = g + (_ ? 0 : 3);
        for (W = 0; W < L; ++W) {
          var Lt = it[yt + 4 * W];
          Lt != 255 && (Lt *= 32897, K[Z + 4 * W + 0] = K[Z + 4 * W + 0] * Lt >> 23, K[Z + 4 * W + 1] = K[Z + 4 * W + 1] * Lt >> 23, K[Z + 4 * W + 2] = K[Z + 4 * W + 2] * Lt >> 23);
        }
        g += $;
      }
    }
    function D(c, g, _, L, R) {
      for (; 0 < L--; ) {
        var $;
        for ($ = 0; $ < _; ++$) {
          var W = c[g + 2 * $ + 0], K = 15 & (it = c[g + 2 * $ + 1]), Z = 4369 * K, it = (240 & it | it >> 4) * Z >> 16;
          c[g + 2 * $ + 0] = (240 & W | W >> 4) * Z >> 16 & 240 | (15 & W | W << 4) * Z >> 16 >> 4 & 15, c[g + 2 * $ + 1] = 240 & it | K;
        }
        g += R;
      }
    }
    function ut(c, g, _, L, R, $, W, K) {
      var Z, it, yt = 255;
      for (it = 0; it < R; ++it) {
        for (Z = 0; Z < L; ++Z) {
          var Lt = c[g + Z];
          $[W + 4 * Z] = Lt, yt &= Lt;
        }
        g += _, W += K;
      }
      return yt != 255;
    }
    function gt(c, g, _, L, R) {
      var $;
      for ($ = 0; $ < R; ++$) _[L + $] = c[g + $] >> 8;
    }
    function Pt() {
      Gi = w, ln = D, un = ut, An = gt;
    }
    function Bt(c, g, _) {
      F[c] = function(L, R, $, W, K, Z, it, yt, Lt, It, Ct, Vt, Mt, bt, St, Ht, Yt) {
        var Gt, ce = Yt - 1 >> 1, re = K[Z + 0] | it[yt + 0] << 16, _e = Lt[It + 0] | Ct[Vt + 0] << 16;
        t(L != null);
        var se = 3 * re + _e + 131074 >> 2;
        for (g(L[R + 0], 255 & se, se >> 16, Mt, bt), $ != null && (se = 3 * _e + re + 131074 >> 2, g($[W + 0], 255 & se, se >> 16, St, Ht)), Gt = 1; Gt <= ce; ++Gt) {
          var Ke = K[Z + Gt] | it[yt + Gt] << 16, Qe = Lt[It + Gt] | Ct[Vt + Gt] << 16, ze = re + Ke + _e + Qe + 524296, De = ze + 2 * (Ke + _e) >> 3;
          se = De + re >> 1, re = (ze = ze + 2 * (re + Qe) >> 3) + Ke >> 1, g(L[R + 2 * Gt - 1], 255 & se, se >> 16, Mt, bt + (2 * Gt - 1) * _), g(L[R + 2 * Gt - 0], 255 & re, re >> 16, Mt, bt + (2 * Gt - 0) * _), $ != null && (se = ze + _e >> 1, re = De + Qe >> 1, g($[W + 2 * Gt - 1], 255 & se, se >> 16, St, Ht + (2 * Gt - 1) * _), g($[W + 2 * Gt + 0], 255 & re, re >> 16, St, Ht + (2 * Gt + 0) * _)), re = Ke, _e = Qe;
        }
        1 & Yt || (se = 3 * re + _e + 131074 >> 2, g(L[R + Yt - 1], 255 & se, se >> 16, Mt, bt + (Yt - 1) * _), $ != null && (se = 3 * _e + re + 131074 >> 2, g($[W + Yt - 1], 255 & se, se >> 16, St, Ht + (Yt - 1) * _)));
      };
    }
    function Xt() {
      Yi[iu] = t2, Yi[ru] = Kd, Yi[Wd] = e2, Yi[su] = Xd, Yi[ou] = Jd, Yi[th] = Zd, Yi[Hd] = n2, Yi[eh] = Kd, Yi[nh] = Xd, Yi[au] = Jd, Yi[ih] = Zd;
    }
    function ue(c) {
      return c & ~i2 ? 0 > c ? 0 : 255 : c >> Qd;
    }
    function ye(c, g) {
      return ue((19077 * c >> 8) + (26149 * g >> 8) - 14234);
    }
    function Oe(c, g, _) {
      return ue((19077 * c >> 8) - (6419 * g >> 8) - (13320 * _ >> 8) + 8708);
    }
    function Ie(c, g) {
      return ue((19077 * c >> 8) + (33050 * g >> 8) - 17685);
    }
    function qe(c, g, _, L, R) {
      L[R + 0] = ye(c, _), L[R + 1] = Oe(c, g, _), L[R + 2] = Ie(c, g);
    }
    function yn(c, g, _, L, R) {
      L[R + 0] = Ie(c, g), L[R + 1] = Oe(c, g, _), L[R + 2] = ye(c, _);
    }
    function xn(c, g, _, L, R) {
      var $ = Oe(c, g, _);
      g = $ << 3 & 224 | Ie(c, g) >> 3, L[R + 0] = 248 & ye(c, _) | $ >> 5, L[R + 1] = g;
    }
    function On(c, g, _, L, R) {
      var $ = 240 & Ie(c, g) | 15;
      L[R + 0] = 240 & ye(c, _) | Oe(c, g, _) >> 4, L[R + 1] = $;
    }
    function ei(c, g, _, L, R) {
      L[R + 0] = 255, qe(c, g, _, L, R + 1);
    }
    function zn(c, g, _, L, R) {
      yn(c, g, _, L, R), L[R + 3] = 255;
    }
    function rr(c, g, _, L, R) {
      qe(c, g, _, L, R), L[R + 3] = 255;
    }
    function Ei(c, g) {
      return 0 > c ? 0 : c > g ? g : c;
    }
    function _r(c, g, _) {
      F[c] = function(L, R, $, W, K, Z, it, yt, Lt) {
        for (var It = yt + (-2 & Lt) * _; yt != It; ) g(L[R + 0], $[W + 0], K[Z + 0], it, yt), g(L[R + 1], $[W + 0], K[Z + 0], it, yt + _), R += 2, ++W, ++Z, yt += 2 * _;
        1 & Lt && g(L[R + 0], $[W + 0], K[Z + 0], it, yt);
      };
    }
    function Xl(c, g, _) {
      return _ == 0 ? c == 0 ? g == 0 ? 6 : 5 : g == 0 ? 4 : 0 : _;
    }
    function Ga(c, g, _, L, R) {
      switch (c >>> 30) {
        case 3:
          Gr(g, _, L, R, 0);
          break;
        case 2:
          kn(g, _, L, R);
          break;
        case 1:
          hi(g, _, L, R);
      }
    }
    function Va(c, g) {
      var _, L, R = g.M, $ = g.Nb, W = c.oc, K = c.pc + 40, Z = c.oc, it = c.pc + 584, yt = c.oc, Lt = c.pc + 600;
      for (_ = 0; 16 > _; ++_) W[K + 32 * _ - 1] = 129;
      for (_ = 0; 8 > _; ++_) Z[it + 32 * _ - 1] = 129, yt[Lt + 32 * _ - 1] = 129;
      for (0 < R ? W[K - 1 - 32] = Z[it - 1 - 32] = yt[Lt - 1 - 32] = 129 : (r(W, K - 32 - 1, 127, 21), r(Z, it - 32 - 1, 127, 9), r(yt, Lt - 32 - 1, 127, 9)), L = 0; L < c.za; ++L) {
        var It = g.ya[g.aa + L];
        if (0 < L) {
          for (_ = -1; 16 > _; ++_) i(W, K + 32 * _ - 4, W, K + 32 * _ + 12, 4);
          for (_ = -1; 8 > _; ++_) i(Z, it + 32 * _ - 4, Z, it + 32 * _ + 4, 4), i(yt, Lt + 32 * _ - 4, yt, Lt + 32 * _ + 4, 4);
        }
        var Ct = c.Gd, Vt = c.Hd + L, Mt = It.ad, bt = It.Hc;
        if (0 < R && (i(W, K - 32, Ct[Vt].y, 0, 16), i(Z, it - 32, Ct[Vt].f, 0, 8), i(yt, Lt - 32, Ct[Vt].ea, 0, 8)), It.Za) {
          var St = W, Ht = K - 32 + 16;
          for (0 < R && (L >= c.za - 1 ? r(St, Ht, Ct[Vt].y[15], 4) : i(St, Ht, Ct[Vt + 1].y, 0, 4)), _ = 0; 4 > _; _++) St[Ht + 128 + _] = St[Ht + 256 + _] = St[Ht + 384 + _] = St[Ht + 0 + _];
          for (_ = 0; 16 > _; ++_, bt <<= 2) St = W, Ht = K + ep[_], sr[It.Ob[_]](St, Ht), Ga(bt, Mt, 16 * +_, St, Ht);
        } else if (St = Xl(L, R, It.Ob[0]), vs[St](W, K), bt != 0) for (_ = 0; 16 > _; ++_, bt <<= 2) Ga(bt, Mt, 16 * +_, W, K + ep[_]);
        for (_ = It.Gc, St = Xl(L, R, It.Dd), Yr[St](Z, it), Yr[St](yt, Lt), bt = Mt, St = Z, Ht = it, 255 & (It = _ >> 0) && (170 & It ? Za(bt, 256, St, Ht) : Wi(bt, 256, St, Ht)), It = yt, bt = Lt, 255 & (_ >>= 8) && (170 & _ ? Za(Mt, 320, It, bt) : Wi(Mt, 320, It, bt)), R < c.Ub - 1 && (i(Ct[Vt].y, 0, W, K + 480, 16), i(Ct[Vt].f, 0, Z, it + 224, 8), i(Ct[Vt].ea, 0, yt, Lt + 224, 8)), _ = 8 * $ * c.B, Ct = c.sa, Vt = c.ta + 16 * L + 16 * $ * c.R, Mt = c.qa, It = c.ra + 8 * L + _, bt = c.Ha, St = c.Ia + 8 * L + _, _ = 0; 16 > _; ++_) i(Ct, Vt + _ * c.R, W, K + 32 * _, 16);
        for (_ = 0; 8 > _; ++_) i(Mt, It + _ * c.B, Z, it + 32 * _, 8), i(bt, St + _ * c.B, yt, Lt + 32 * _, 8);
      }
    }
    function Uo(c, g, _, L, R, $, W, K, Z) {
      var it = [0], yt = [0], Lt = 0, It = Z != null ? Z.kd : 0, Ct = Z ?? new $a();
      if (c == null || 12 > _) return 7;
      Ct.data = c, Ct.w = g, Ct.ha = _, g = [g], _ = [_], Ct.gb = [Ct.gb];
      t: {
        var Vt = g, Mt = _, bt = Ct.gb;
        if (t(c != null), t(Mt != null), t(bt != null), bt[0] = 0, 12 <= Mt[0] && !e(c, Vt[0], "RIFF")) {
          if (e(c, Vt[0] + 8, "WEBP")) {
            bt = 3;
            break t;
          }
          var St = Qt(c, Vt[0] + 4);
          if (12 > St || 4294967286 < St) {
            bt = 3;
            break t;
          }
          if (It && St > Mt[0] - 8) {
            bt = 7;
            break t;
          }
          bt[0] = St, Vt[0] += 12, Mt[0] -= 12;
        }
        bt = 0;
      }
      if (bt != 0) return bt;
      for (St = 0 < Ct.gb[0], _ = _[0]; ; ) {
        t: {
          var Ht = c;
          Mt = g, bt = _;
          var Yt = it, Gt = yt, ce = Vt = [0];
          if ((se = Lt = [Lt])[0] = 0, 8 > bt[0]) bt = 7;
          else {
            if (!e(Ht, Mt[0], "VP8X")) {
              if (Qt(Ht, Mt[0] + 4) != 10) {
                bt = 3;
                break t;
              }
              if (18 > bt[0]) {
                bt = 7;
                break t;
              }
              var re = Qt(Ht, Mt[0] + 8), _e = 1 + Jt(Ht, Mt[0] + 12);
              if (2147483648 <= _e * (Ht = 1 + Jt(Ht, Mt[0] + 15))) {
                bt = 3;
                break t;
              }
              ce != null && (ce[0] = re), Yt != null && (Yt[0] = _e), Gt != null && (Gt[0] = Ht), Mt[0] += 18, bt[0] -= 18, se[0] = 1;
            }
            bt = 0;
          }
        }
        if (Lt = Lt[0], Vt = Vt[0], bt != 0) return bt;
        if (Mt = !!(2 & Vt), !St && Lt) return 3;
        if ($ != null && ($[0] = !!(16 & Vt)), W != null && (W[0] = Mt), K != null && (K[0] = 0), W = it[0], Vt = yt[0], Lt && Mt && Z == null) {
          bt = 0;
          break;
        }
        if (4 > _) {
          bt = 7;
          break;
        }
        if (St && Lt || !St && !Lt && !e(c, g[0], "ALPH")) {
          _ = [_], Ct.na = [Ct.na], Ct.P = [Ct.P], Ct.Sa = [Ct.Sa];
          t: {
            re = c, bt = g, St = _;
            var se = Ct.gb;
            Yt = Ct.na, Gt = Ct.P, ce = Ct.Sa, _e = 22, t(re != null), t(St != null), Ht = bt[0];
            var Ke = St[0];
            for (t(Yt != null), t(ce != null), Yt[0] = null, Gt[0] = null, ce[0] = 0; ; ) {
              if (bt[0] = Ht, St[0] = Ke, 8 > Ke) {
                bt = 7;
                break t;
              }
              var Qe = Qt(re, Ht + 4);
              if (4294967286 < Qe) {
                bt = 3;
                break t;
              }
              var ze = 8 + Qe + 1 & -2;
              if (_e += ze, 0 < se && _e > se) {
                bt = 3;
                break t;
              }
              if (!e(re, Ht, "VP8 ") || !e(re, Ht, "VP8L")) {
                bt = 0;
                break t;
              }
              if (Ke[0] < ze) {
                bt = 7;
                break t;
              }
              e(re, Ht, "ALPH") || (Yt[0] = re, Gt[0] = Ht + 8, ce[0] = Qe), Ht += ze, Ke -= ze;
            }
          }
          if (_ = _[0], Ct.na = Ct.na[0], Ct.P = Ct.P[0], Ct.Sa = Ct.Sa[0], bt != 0) break;
        }
        _ = [_], Ct.Ja = [Ct.Ja], Ct.xa = [Ct.xa];
        t: if (se = c, bt = g, St = _, Yt = Ct.gb[0], Gt = Ct.Ja, ce = Ct.xa, re = bt[0], Ht = !e(se, re, "VP8 "), _e = !e(se, re, "VP8L"), t(se != null), t(St != null), t(Gt != null), t(ce != null), 8 > St[0]) bt = 7;
        else {
          if (Ht || _e) {
            if (se = Qt(se, re + 4), 12 <= Yt && se > Yt - 12) {
              bt = 3;
              break t;
            }
            if (It && se > St[0] - 8) {
              bt = 7;
              break t;
            }
            Gt[0] = se, bt[0] += 8, St[0] -= 8, ce[0] = _e;
          } else ce[0] = 5 <= St[0] && se[re + 0] == 47 && !(se[re + 4] >> 5), Gt[0] = St[0];
          bt = 0;
        }
        if (_ = _[0], Ct.Ja = Ct.Ja[0], Ct.xa = Ct.xa[0], g = g[0], bt != 0) break;
        if (4294967286 < Ct.Ja) return 3;
        if (K == null || Mt || (K[0] = Ct.xa ? 2 : 1), W = [W], Vt = [Vt], Ct.xa) {
          if (5 > _) {
            bt = 7;
            break;
          }
          K = W, It = Vt, Mt = $, c == null || 5 > _ ? c = 0 : 5 <= _ && c[g + 0] == 47 && !(c[g + 4] >> 5) ? (St = [0], se = [0], Yt = [0], Q(Gt = new N(), c, g, _), xe(Gt, St, se, Yt) ? (K != null && (K[0] = St[0]), It != null && (It[0] = se[0]), Mt != null && (Mt[0] = Yt[0]), c = 1) : c = 0) : c = 0;
        } else {
          if (10 > _) {
            bt = 7;
            break;
          }
          K = Vt, c == null || 10 > _ || !To(c, g + 3, _ - 3) ? c = 0 : (It = c[g + 0] | c[g + 1] << 8 | c[g + 2] << 16, Mt = 16383 & (c[g + 7] << 8 | c[g + 6]), c = 16383 & (c[g + 9] << 8 | c[g + 8]), 1 & It || 3 < (It >> 1 & 7) || !(It >> 4 & 1) || It >> 5 >= Ct.Ja || !Mt || !c ? c = 0 : (W && (W[0] = Mt), K && (K[0] = c), c = 1));
        }
        if (!c || (W = W[0], Vt = Vt[0], Lt && (it[0] != W || yt[0] != Vt))) return 3;
        Z != null && (Z[0] = Ct, Z.offset = g - Z.w, t(4294967286 > g - Z.w), t(Z.offset == Z.ha - _));
        break;
      }
      return bt == 0 || bt == 7 && Lt && Z == null ? ($ != null && ($[0] |= Ct.na != null && 0 < Ct.na.length), L != null && (L[0] = W), R != null && (R[0] = Vt), 0) : bt;
    }
    function Ya(c, g, _) {
      var L = g.width, R = g.height, $ = 0, W = 0, K = L, Z = R;
      if (g.Da = c != null && 0 < c.Da, g.Da && (K = c.cd, Z = c.bd, $ = c.v, W = c.j, 11 > _ || ($ &= -2, W &= -2), 0 > $ || 0 > W || 0 >= K || 0 >= Z || $ + K > L || W + Z > R)) return 0;
      if (g.v = $, g.j = W, g.va = $ + K, g.o = W + Z, g.U = K, g.T = Z, g.da = c != null && 0 < c.da, g.da) {
        if (!et(K, Z, _ = [c.ib], $ = [c.hb])) return 0;
        g.ib = _[0], g.hb = $[0];
      }
      return g.ob = c != null && c.ob, g.Kb = c == null || !c.Sd, g.da && (g.ob = g.ib < 3 * L / 4 && g.hb < 3 * R / 4, g.Kb = 0), 1;
    }
    function Ka(c) {
      if (c == null) return 2;
      if (11 > c.S) {
        var g = c.f.RGBA;
        g.fb += (c.height - 1) * g.A, g.A = -g.A;
      } else g = c.f.kb, c = c.height, g.O += (c - 1) * g.fa, g.fa = -g.fa, g.N += (c - 1 >> 1) * g.Ab, g.Ab = -g.Ab, g.W += (c - 1 >> 1) * g.Db, g.Db = -g.Db, g.F != null && (g.J += (c - 1) * g.lb, g.lb = -g.lb);
      return 0;
    }
    function Wo(c, g, _, L) {
      if (L == null || 0 >= c || 0 >= g) return 2;
      if (_ != null) {
        if (_.Da) {
          var R = _.cd, $ = _.bd, W = -2 & _.v, K = -2 & _.j;
          if (0 > W || 0 > K || 0 >= R || 0 >= $ || W + R > c || K + $ > g) return 2;
          c = R, g = $;
        }
        if (_.da) {
          if (!et(c, g, R = [_.ib], $ = [_.hb])) return 2;
          c = R[0], g = $[0];
        }
      }
      L.width = c, L.height = g;
      t: {
        var Z = L.width, it = L.height;
        if (c = L.S, 0 >= Z || 0 >= it || !(c >= iu && 13 > c)) c = 2;
        else {
          if (0 >= L.Rd && L.sd == null) {
            W = $ = R = g = 0;
            var yt = (K = Z * np[c]) * it;
            if (11 > c || ($ = (it + 1) / 2 * (g = (Z + 1) / 2), c == 12 && (W = (R = Z) * it)), (it = s(yt + 2 * $ + W)) == null) {
              c = 1;
              break t;
            }
            L.sd = it, 11 > c ? ((Z = L.f.RGBA).eb = it, Z.fb = 0, Z.A = K, Z.size = yt) : ((Z = L.f.kb).y = it, Z.O = 0, Z.fa = K, Z.Fd = yt, Z.f = it, Z.N = 0 + yt, Z.Ab = g, Z.Cd = $, Z.ea = it, Z.W = 0 + yt + $, Z.Db = g, Z.Ed = $, c == 12 && (Z.F = it, Z.J = 0 + yt + 2 * $), Z.Tc = W, Z.lb = R);
          }
          if (g = 1, R = L.S, $ = L.width, W = L.height, R >= iu && 13 > R) if (11 > R) c = L.f.RGBA, g &= (K = Math.abs(c.A)) * (W - 1) + $ <= c.size, g &= K >= $ * np[R], g &= c.eb != null;
          else {
            c = L.f.kb, K = ($ + 1) / 2, yt = (W + 1) / 2, Z = Math.abs(c.fa), it = Math.abs(c.Ab);
            var Lt = Math.abs(c.Db), It = Math.abs(c.lb), Ct = It * (W - 1) + $;
            g &= Z * (W - 1) + $ <= c.Fd, g &= it * (yt - 1) + K <= c.Cd, g = (g &= Lt * (yt - 1) + K <= c.Ed) & Z >= $ & it >= K & Lt >= K, g &= c.y != null, g &= c.f != null, g &= c.ea != null, R == 12 && (g &= It >= $, g &= Ct <= c.Tc, g &= c.F != null);
          }
          else g = 0;
          c = g ? 0 : 2;
        }
      }
      return c != 0 || _ != null && _.fd && (c = Ka(L)), c;
    }
    var Yn = 64, Ho = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Go = 24, Vo = 32, Xa = 8, yi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    vt("Predictor0", "PredictorAdd0"), F.Predictor0 = function() {
      return 4278190080;
    }, F.Predictor1 = function(c) {
      return c;
    }, F.Predictor2 = function(c, g, _) {
      return g[_ + 0];
    }, F.Predictor3 = function(c, g, _) {
      return g[_ + 1];
    }, F.Predictor4 = function(c, g, _) {
      return g[_ - 1];
    }, F.Predictor5 = function(c, g, _) {
      return ht(ht(c, g[_ + 1]), g[_ + 0]);
    }, F.Predictor6 = function(c, g, _) {
      return ht(c, g[_ - 1]);
    }, F.Predictor7 = function(c, g, _) {
      return ht(c, g[_ + 0]);
    }, F.Predictor8 = function(c, g, _) {
      return ht(g[_ - 1], g[_ + 0]);
    }, F.Predictor9 = function(c, g, _) {
      return ht(g[_ + 0], g[_ + 1]);
    }, F.Predictor10 = function(c, g, _) {
      return ht(ht(c, g[_ - 1]), ht(g[_ + 0], g[_ + 1]));
    }, F.Predictor11 = function(c, g, _) {
      var L = g[_ + 0];
      return 0 >= Ft(L >> 24 & 255, c >> 24 & 255, (g = g[_ - 1]) >> 24 & 255) + Ft(L >> 16 & 255, c >> 16 & 255, g >> 16 & 255) + Ft(L >> 8 & 255, c >> 8 & 255, g >> 8 & 255) + Ft(255 & L, 255 & c, 255 & g) ? L : c;
    }, F.Predictor12 = function(c, g, _) {
      var L = g[_ + 0];
      return (Ot((c >> 24 & 255) + (L >> 24 & 255) - ((g = g[_ - 1]) >> 24 & 255)) << 24 | Ot((c >> 16 & 255) + (L >> 16 & 255) - (g >> 16 & 255)) << 16 | Ot((c >> 8 & 255) + (L >> 8 & 255) - (g >> 8 & 255)) << 8 | Ot((255 & c) + (255 & L) - (255 & g))) >>> 0;
    }, F.Predictor13 = function(c, g, _) {
      var L = g[_ - 1];
      return ($t((c = ht(c, g[_ + 0])) >> 24 & 255, L >> 24 & 255) << 24 | $t(c >> 16 & 255, L >> 16 & 255) << 16 | $t(c >> 8 & 255, L >> 8 & 255) << 8 | $t(c >> 0 & 255, L >> 0 & 255)) >>> 0;
    };
    var Zc = F.PredictorAdd0;
    F.PredictorAdd1 = Ut, vt("Predictor2", "PredictorAdd2"), vt("Predictor3", "PredictorAdd3"), vt("Predictor4", "PredictorAdd4"), vt("Predictor5", "PredictorAdd5"), vt("Predictor6", "PredictorAdd6"), vt("Predictor7", "PredictorAdd7"), vt("Predictor8", "PredictorAdd8"), vt("Predictor9", "PredictorAdd9"), vt("Predictor10", "PredictorAdd10"), vt("Predictor11", "PredictorAdd11"), vt("Predictor12", "PredictorAdd12"), vt("Predictor13", "PredictorAdd13");
    var Ja = F.PredictorAdd2;
    dt("ColorIndexInverseTransform", "MapARGB", "32b", function(c) {
      return c >> 8 & 255;
    }, function(c) {
      return c;
    }), dt("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(c) {
      return c;
    }, function(c) {
      return c >> 8 & 255;
    });
    var Jl, Ui = F.ColorIndexInverseTransform, Yo = F.MapARGB, Zl = F.VP8LColorIndexInverseTransformAlpha, Ql = F.MapAlpha, gs = F.VP8LPredictorsAdd = [];
    gs.length = 16, (F.VP8LPredictors = []).length = 16, (F.VP8LPredictorsAdd_C = []).length = 16, (F.VP8LPredictors_C = []).length = 16;
    var Js, bi, ci, ms, Wr, Hr, Ko, Gr, kn, Za, hi, Wi, Xo, tu, Qa, Zs, Qs, ys, to, Jo, eo, bs, tl, Hi, Gi, ln, un, An, Bn = s(511), Vr = s(2041), el = s(225), Zo = s(767), eu = 0, Qc = Vr, nu = el, Oi = Zo, Vi = Bn, iu = 0, ru = 1, Wd = 2, su = 3, ou = 4, th = 5, Hd = 6, eh = 7, nh = 8, au = 9, ih = 10, qm = [2, 3, 7], zm = [3, 3, 11], Gd = [280, 256, 256, 256, 40], $m = [0, 1, 1, 1, 0], Um = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Wm = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Hm = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Gm = 8, rh = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], sh = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], nl = null, Vm = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Ym = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Vd = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Km = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Xm = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Jm = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Zm = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], vs = [], sr = [], Yr = [], Qm = 1, Yd = 2, ws = [], Yi = [];
    Bt("UpsampleRgbLinePair", qe, 3), Bt("UpsampleBgrLinePair", yn, 3), Bt("UpsampleRgbaLinePair", rr, 4), Bt("UpsampleBgraLinePair", zn, 4), Bt("UpsampleArgbLinePair", ei, 4), Bt("UpsampleRgba4444LinePair", On, 2), Bt("UpsampleRgb565LinePair", xn, 2);
    var t2 = F.UpsampleRgbLinePair, e2 = F.UpsampleBgrLinePair, Kd = F.UpsampleRgbaLinePair, Xd = F.UpsampleBgraLinePair, Jd = F.UpsampleArgbLinePair, Zd = F.UpsampleRgba4444LinePair, n2 = F.UpsampleRgb565LinePair, lu = 16, uu = 1 << lu - 1, il = -227, oh = 482, Qd = 6, i2 = (256 << Qd) - 1, tp = 0, r2 = s(256), s2 = s(256), o2 = s(256), a2 = s(256), l2 = s(oh - il), u2 = s(oh - il);
    _r("YuvToRgbRow", qe, 3), _r("YuvToBgrRow", yn, 3), _r("YuvToRgbaRow", rr, 4), _r("YuvToBgraRow", zn, 4), _r("YuvToArgbRow", ei, 4), _r("YuvToRgba4444Row", On, 2), _r("YuvToRgb565Row", xn, 2);
    var ep = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], cu = [0, 2, 8], c2 = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], h2 = 1;
    this.WebPDecodeRGBA = function(c, g, _, L, R) {
      var $ = ru, W = new zo(), K = new Dn();
      W.ba = K, K.S = $, K.width = [K.width], K.height = [K.height];
      var Z = K.width, it = K.height, yt = new fn();
      if (yt == null || c == null) var Lt = 2;
      else t(yt != null), Lt = Uo(c, g, _, yt.width, yt.height, yt.Pd, yt.Qd, yt.format, null);
      if (Lt != 0 ? Z = 0 : (Z != null && (Z[0] = yt.width[0]), it != null && (it[0] = yt.height[0]), Z = 1), Z) {
        K.width = K.width[0], K.height = K.height[0], L != null && (L[0] = K.width), R != null && (R[0] = K.height);
        t: {
          if (L = new us(), (R = new $a()).data = c, R.w = g, R.ha = _, R.kd = 1, g = [0], t(R != null), ((c = Uo(R.data, R.w, R.ha, null, null, null, g, null, R)) == 0 || c == 7) && g[0] && (c = 4), (g = c) == 0) {
            if (t(W != null), L.data = R.data, L.w = R.w + R.offset, L.ha = R.ha - R.offset, L.put = Bi, L.ac = En, L.bc = mn, L.ma = W, R.xa) {
              if ((c = Pi()) == null) {
                W = 1;
                break t;
              }
              if (function(It, Ct) {
                var Vt = [0], Mt = [0], bt = [0];
                e: for (; ; ) {
                  if (It == null) return 0;
                  if (Ct == null) return It.a = 2, 0;
                  if (It.l = Ct, It.a = 0, Q(It.m, Ct.data, Ct.w, Ct.ha), !xe(It.m, Vt, Mt, bt)) {
                    It.a = 3;
                    break e;
                  }
                  if (It.xb = Yd, Ct.width = Vt[0], Ct.height = Mt[0], !zi(Vt[0], Mt[0], 1, It, null)) break e;
                  return 1;
                }
                return t(It.a != 0), 0;
              }(c, L)) {
                if (L = (g = Wo(L.width, L.height, W.Oa, W.ba)) == 0) {
                  e: {
                    L = c;
                    n: for (; ; ) {
                      if (L == null) {
                        L = 0;
                        break e;
                      }
                      if (t(L.s.yc != null), t(L.s.Ya != null), t(0 < L.s.Wb), t((_ = L.l) != null), t((R = _.ma) != null), L.xb != 0) {
                        if (L.ca = R.ba, L.tb = R.tb, t(L.ca != null), !Ya(R.Oa, _, su)) {
                          L.a = 2;
                          break n;
                        }
                        if (!wr(L, _.width) || _.da) break n;
                        if ((_.da || we(L.ca.S)) && Pt(), 11 > L.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), L.ca.f.kb.F != null && Pt()), L.Pb && 0 < L.s.ua && L.s.vb.X == null && !O(L.s.vb, L.s.Wa.Xa)) {
                          L.a = 1;
                          break n;
                        }
                        L.xb = 0;
                      }
                      if (!Ci(L, L.V, L.Ba, L.c, L.i, _.o, ss)) break n;
                      R.Dc = L.Ma, L = 1;
                      break e;
                    }
                    t(L.a != 0), L = 0;
                  }
                  L = !L;
                }
                L && (g = c.a);
              } else g = c.a;
            } else {
              if ((c = new Ta()) == null) {
                W = 1;
                break t;
              }
              if (c.Fa = R.na, c.P = R.P, c.qc = R.Sa, Us(c, L)) {
                if ((g = Wo(L.width, L.height, W.Oa, W.ba)) == 0) {
                  if (c.Aa = 0, _ = W.Oa, t((R = c) != null), _ != null) {
                    if (0 < (Z = 0 > (Z = _.Md) ? 0 : 100 < Z ? 255 : 255 * Z / 100)) {
                      for (it = yt = 0; 4 > it; ++it) 12 > (Lt = R.pb[it]).lc && (Lt.ia = Z * c2[0 > Lt.lc ? 0 : Lt.lc] >> 3), yt |= Lt.ia;
                      yt && (alert("todo:VP8InitRandom"), R.ia = 1);
                    }
                    R.Ga = _.Id, 100 < R.Ga ? R.Ga = 100 : 0 > R.Ga && (R.Ga = 0);
                  }
                  $i(c, L) || (g = c.a);
                }
              } else g = c.a;
            }
            g == 0 && W.Oa != null && W.Oa.fd && (g = Ka(W.ba));
          }
          W = g;
        }
        $ = W != 0 ? null : 11 > $ ? K.f.RGBA.eb : K.f.kb.y;
      } else $ = null;
      return $;
    };
    var np = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function h(F, M) {
    for (var B = "", P = 0; P < 4; P++) B += String.fromCharCode(F[M++]);
    return B;
  }
  function u(F, M) {
    return (F[M + 0] << 0 | F[M + 1] << 8 | F[M + 2] << 16) >>> 0;
  }
  function d(F, M) {
    return (F[M + 0] << 0 | F[M + 1] << 8 | F[M + 2] << 16 | F[M + 3] << 24) >>> 0;
  }
  new l();
  var p = [0], f = [0], m = [], b = new l(), x = n, y = function(F, M) {
    var B = {}, P = 0, A = !1, I = 0, S = 0;
    if (B.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(z, V, Y, ot) {
      for (var wt = 0; wt < ot; wt++) if (z[V + wt] != Y.charCodeAt(wt)) return !0;
      return !1;
    }(F, M, "RIFF", 4)) {
      var X, H;
      for (d(F, M += 4), M += 8; M < F.length; ) {
        var j = h(F, M), Q = d(F, M += 4);
        M += 4;
        var G = Q + (1 & Q);
        switch (j) {
          case "VP8 ":
          case "VP8L":
            B.frames[P] === void 0 && (B.frames[P] = {}), (N = B.frames[P]).src_off = A ? S : M - 8, N.src_size = I + Q + 8, P++, A && (A = !1, I = 0, S = 0);
            break;
          case "VP8X":
            (N = B.header = {}).feature_flags = F[M];
            var ft = M + 4;
            N.canvas_width = 1 + u(F, ft), ft += 3, N.canvas_height = 1 + u(F, ft), ft += 3;
            break;
          case "ALPH":
            A = !0, I = G + 8, S = M - 8;
            break;
          case "ANIM":
            (N = B.header).bgcolor = d(F, M), ft = M + 4, N.loop_count = (X = F)[(H = ft) + 0] << 0 | X[H + 1] << 8, ft += 2;
            break;
          case "ANMF":
            var nt, N;
            (N = B.frames[P] = {}).offset_x = 2 * u(F, M), M += 3, N.offset_y = 2 * u(F, M), M += 3, N.width = 1 + u(F, M), M += 3, N.height = 1 + u(F, M), M += 3, N.duration = u(F, M), M += 3, nt = F[M++], N.dispose = 1 & nt, N.blend = nt >> 1 & 1;
        }
        j != "ANMF" && (M += G);
      }
      return B;
    }
  }(x, 0);
  y.response = x, y.rgbaoutput = !0, y.dataurl = !1;
  var v = y.header ? y.header : null, k = y.frames ? y.frames : null;
  if (v) {
    v.loop_counter = v.loop_count, p = [v.canvas_height], f = [v.canvas_width];
    for (var C = 0; C < k.length && k[C].blend != 0; C++) ;
  }
  var E = k[0], q = b.WebPDecodeRGBA(x, E.src_off, E.src_size, f, p);
  E.rgba = q, E.imgwidth = f[0], E.imgheight = p[0];
  for (var T = 0; T < f[0] * p[0] * 4; T++) m[T] = q[T];
  return this.width = f, this.height = p, this.data = m, this;
}
(function(n) {
  var t = function() {
    return typeof hf == "function";
  }, e = function(p, f, m, b) {
    var x = 4, y = o;
    switch (b) {
      case n.image_compression.FAST:
        x = 1, y = s;
        break;
      case n.image_compression.MEDIUM:
        x = 6, y = a;
        break;
      case n.image_compression.SLOW:
        x = 9, y = l;
    }
    p = i(p, f, m, y);
    var v = hf(p, { level: x });
    return n.__addimage__.arrayBufferToBinaryString(v);
  }, i = function(p, f, m, b) {
    for (var x, y, v, k = p.length / f, C = new Uint8Array(p.length + k), E = u(), q = 0; q < k; q += 1) {
      if (v = q * f, x = p.subarray(v, v + f), b) C.set(b(x, m, y), v + q);
      else {
        for (var T, F = E.length, M = []; T < F; T += 1) M[T] = E[T](x, m, y);
        var B = d(M.concat());
        C.set(M[B], v + q);
      }
      y = x;
    }
    return C;
  }, r = function(p) {
    var f = Array.apply([], p);
    return f.unshift(0), f;
  }, s = function(p, f) {
    var m, b = [], x = p.length;
    b[0] = 1;
    for (var y = 0; y < x; y += 1) m = p[y - f] || 0, b[y + 1] = p[y] - m + 256 & 255;
    return b;
  }, o = function(p, f, m) {
    var b, x = [], y = p.length;
    x[0] = 2;
    for (var v = 0; v < y; v += 1) b = m && m[v] || 0, x[v + 1] = p[v] - b + 256 & 255;
    return x;
  }, a = function(p, f, m) {
    var b, x, y = [], v = p.length;
    y[0] = 3;
    for (var k = 0; k < v; k += 1) b = p[k - f] || 0, x = m && m[k] || 0, y[k + 1] = p[k] + 256 - (b + x >>> 1) & 255;
    return y;
  }, l = function(p, f, m) {
    var b, x, y, v, k = [], C = p.length;
    k[0] = 4;
    for (var E = 0; E < C; E += 1) b = p[E - f] || 0, x = m && m[E] || 0, y = m && m[E - f] || 0, v = h(b, x, y), k[E + 1] = p[E] - v + 256 & 255;
    return k;
  }, h = function(p, f, m) {
    if (p === f && f === m) return p;
    var b = Math.abs(f - m), x = Math.abs(p - m), y = Math.abs(p + f - m - m);
    return b <= x && b <= y ? p : x <= y ? f : m;
  }, u = function() {
    return [r, s, o, a, l];
  }, d = function(p) {
    var f = p.map(function(m) {
      return m.reduce(function(b, x) {
        return b + Math.abs(x);
      }, 0);
    });
    return f.indexOf(Math.min.apply(null, f));
  };
  n.processPNG = function(p, f, m, b) {
    var x, y, v, k, C, E, q, T, F, M, B, P, A, I, S, X = this.decode.FLATE_DECODE, H = "";
    if (this.__addimage__.isArrayBuffer(p) && (p = new Uint8Array(p)), this.__addimage__.isArrayBufferView(p)) {
      if (p = (v = new Mv(p)).imgData, y = v.bits, x = v.colorSpace, C = v.colors, [4, 6].indexOf(v.colorType) !== -1) {
        if (v.bits === 8) {
          F = (T = v.pixelBitlength == 32 ? new Uint32Array(v.decodePixels().buffer) : v.pixelBitlength == 16 ? new Uint16Array(v.decodePixels().buffer) : new Uint8Array(v.decodePixels().buffer)).length, B = new Uint8Array(F * v.colors), M = new Uint8Array(F);
          var j, Q = v.pixelBitlength - v.bits;
          for (I = 0, S = 0; I < F; I++) {
            for (A = T[I], j = 0; j < Q; ) B[S++] = A >>> j & 255, j += v.bits;
            M[I] = A >>> j & 255;
          }
        }
        if (v.bits === 16) {
          F = (T = new Uint32Array(v.decodePixels().buffer)).length, B = new Uint8Array(F * (32 / v.pixelBitlength) * v.colors), M = new Uint8Array(F * (32 / v.pixelBitlength)), P = v.colors > 1, I = 0, S = 0;
          for (var G = 0; I < F; ) A = T[I++], B[S++] = A >>> 0 & 255, P && (B[S++] = A >>> 16 & 255, A = T[I++], B[S++] = A >>> 0 & 255), M[G++] = A >>> 16 & 255;
          y = 8;
        }
        b !== n.image_compression.NONE && t() ? (p = e(B, v.width * v.colors, v.colors, b), q = e(M, v.width, 1, b)) : (p = B, q = M, X = void 0);
      }
      if (v.colorType === 3 && (x = this.color_spaces.INDEXED, E = v.palette, v.transparency.indexed)) {
        var ft = v.transparency.indexed, nt = 0;
        for (I = 0, F = ft.length; I < F; ++I) nt += ft[I];
        if ((nt /= 255) === F - 1 && ft.indexOf(0) !== -1) k = [ft.indexOf(0)];
        else if (nt !== F) {
          for (T = v.decodePixels(), M = new Uint8Array(T.length), I = 0, F = T.length; I < F; I++) M[I] = ft[T[I]];
          q = e(M, v.width, 1);
        }
      }
      var N = function(z) {
        var V;
        switch (z) {
          case n.image_compression.FAST:
            V = 11;
            break;
          case n.image_compression.MEDIUM:
            V = 13;
            break;
          case n.image_compression.SLOW:
            V = 14;
            break;
          default:
            V = 12;
        }
        return V;
      }(b);
      return X === this.decode.FLATE_DECODE && (H = "/Predictor " + N + " "), H += "/Colors " + C + " /BitsPerComponent " + y + " /Columns " + v.width, (this.__addimage__.isArrayBuffer(p) || this.__addimage__.isArrayBufferView(p)) && (p = this.__addimage__.arrayBufferToBinaryString(p)), (q && this.__addimage__.isArrayBuffer(q) || this.__addimage__.isArrayBufferView(q)) && (q = this.__addimage__.arrayBufferToBinaryString(q)), { alias: m, data: p, index: f, filter: X, decodeParameters: H, transparency: k, palette: E, sMask: q, predictor: N, width: v.width, height: v.height, bitsPerComponent: y, colorSpace: x };
    }
  };
})(Se.API), function(n) {
  n.processGIF89A = function(t, e, i, r) {
    var s = new Rv(t), o = s.width, a = s.height, l = [];
    s.decodeAndBlitFrameRGBA(0, l);
    var h = { data: l, width: o, height: a }, u = new Ih(100).encode(h, 100);
    return n.processJPEG.call(this, u, e, i, r);
  }, n.processGIF87A = n.processGIF89A;
}(Se.API), lr.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var t = 0; t < n; t++) {
      var e = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[t] = { red: r, green: i, blue: e, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, lr.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, t = this.width * this.height * 4;
    this.data = new Uint8Array(t), this[n]();
  } catch (e) {
    an.log("bit decode error:" + e);
  }
}, lr.prototype.bit1 = function() {
  var n, t = Math.ceil(this.width / 8), e = t % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, r = 0; r < t; r++) for (var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 8 * r * 4, a = 0; a < 8 && 8 * r + a < this.width; a++) {
      var l = this.palette[s >> 7 - a & 1];
      this.data[o + 4 * a] = l.blue, this.data[o + 4 * a + 1] = l.green, this.data[o + 4 * a + 2] = l.red, this.data[o + 4 * a + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, lr.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), t = n % 4, e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < n; r++) {
      var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 2 * r * 4, a = s >> 4, l = 15 & s, h = this.palette[a];
      if (this.data[o] = h.blue, this.data[o + 1] = h.green, this.data[o + 2] = h.red, this.data[o + 3] = 255, 2 * r + 1 >= this.width) break;
      h = this.palette[l], this.data[o + 4] = h.blue, this.data[o + 4 + 1] = h.green, this.data[o + 4 + 2] = h.red, this.data[o + 4 + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, lr.prototype.bit8 = function() {
  for (var n = this.width % 4, t = this.height - 1; t >= 0; t--) {
    for (var e = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var r = this.datav.getUint8(this.pos++, !0), s = e * this.width * 4 + 4 * i;
      if (r < this.palette.length) {
        var o = this.palette[r];
        this.data[s] = o.red, this.data[s + 1] = o.green, this.data[s + 2] = o.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, lr.prototype.bit15 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (s & t) / t * 255 | 0, a = (s >> 5 & t) / t * 255 | 0, l = (s >> 10 & t) / t * 255 | 0, h = s >> 15 ? 255 : 0, u = i * this.width * 4 + 4 * r;
      this.data[u] = l, this.data[u + 1] = a, this.data[u + 2] = o, this.data[u + 3] = h;
    }
    this.pos += n;
  }
}, lr.prototype.bit16 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, s = 0; s < this.width; s++) {
      var o = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (o & t) / t * 255 | 0, l = (o >> 5 & e) / e * 255 | 0, h = (o >> 11) / t * 255 | 0, u = r * this.width * 4 + 4 * s;
      this.data[u] = h, this.data[u + 1] = l, this.data[u + 2] = a, this.data[u + 3] = 255;
    }
    this.pos += n;
  }
}, lr.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = t * this.width * 4 + 4 * e;
      this.data[o] = s, this.data[o + 1] = r, this.data[o + 2] = i, this.data[o + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, lr.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--) for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
    var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), a = t * this.width * 4 + 4 * e;
    this.data[a] = s, this.data[a + 1] = r, this.data[a + 2] = i, this.data[a + 3] = o;
  }
}, lr.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processBMP = function(t, e, i, r) {
    var s = new lr(t, !1), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Ih(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(Se.API), lg.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processWEBP = function(t, e, i, r) {
    var s = new lg(t), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Ih(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(Se.API), Se.API.processRGBA = function(n, t, e) {
  for (var i = n.data, r = i.length, s = new Uint8Array(r / 4 * 3), o = new Uint8Array(r / 4), a = 0, l = 0, h = 0; h < r; h += 4) {
    var u = i[h], d = i[h + 1], p = i[h + 2], f = i[h + 3];
    s[a++] = u, s[a++] = d, s[a++] = p, o[l++] = f;
  }
  var m = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o), data: m, index: t, alias: e, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, Se.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, ra = Se.API, Lu = ra.getCharWidthsArray = function(n, t) {
  var e, i, r = (t = t || {}).font || this.internal.getFont(), s = t.fontSize || this.internal.getFontSize(), o = t.charSpace || this.internal.getCharSpace(), a = t.widths ? t.widths : r.metadata.Unicode.widths, l = a.fof ? a.fof : 1, h = t.kerning ? t.kerning : r.metadata.Unicode.kerning, u = h.fof ? h.fof : 1, d = t.doKerning !== !1, p = 0, f = n.length, m = 0, b = a[0] || l, x = [];
  for (e = 0; e < f; e++) i = n.charCodeAt(e), typeof r.metadata.widthOfString == "function" ? x.push((r.metadata.widthOfGlyph(r.metadata.characterToGlyph(i)) + o * (1e3 / s) || 0) / 1e3) : (p = d && en(h[i]) === "object" && !isNaN(parseInt(h[i][m], 10)) ? h[i][m] / u : 0, x.push((a[i] || b) / l + p)), m = i;
  return x;
}, rg = ra.getStringUnitWidth = function(n, t) {
  var e = (t = t || {}).fontSize || this.internal.getFontSize(), i = t.font || this.internal.getFont(), r = t.charSpace || this.internal.getCharSpace();
  return ra.processArabic && (n = ra.processArabic(n)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(n, e, r) / e : Lu.apply(this, arguments).reduce(function(s, o) {
    return s + o;
  }, 0);
}, sg = function(n, t, e, i) {
  for (var r = [], s = 0, o = n.length, a = 0; s !== o && a + t[s] < e; ) a += t[s], s++;
  r.push(n.slice(0, s));
  var l = s;
  for (a = 0; s !== o; ) a + t[s] > i && (r.push(n.slice(l, s)), a = 0, l = s), a += t[s], s++;
  return l !== s && r.push(n.slice(l, s)), r;
}, og = function(n, t, e) {
  e || (e = {});
  var i, r, s, o, a, l, h, u = [], d = [u], p = e.textIndent || 0, f = 0, m = 0, b = n.split(" "), x = Lu.apply(this, [" ", e])[0];
  if (l = e.lineIndent === -1 ? b[0].length + 2 : e.lineIndent || 0) {
    var y = Array(l).join(" "), v = [];
    b.map(function(C) {
      (C = C.split(/\s*\n/)).length > 1 ? v = v.concat(C.map(function(E, q) {
        return (q && E.length ? `
` : "") + E;
      })) : v.push(C[0]);
    }), b = v, l = rg.apply(this, [y, e]);
  }
  for (s = 0, o = b.length; s < o; s++) {
    var k = 0;
    if (i = b[s], l && i[0] == `
` && (i = i.substr(1), k = 1), p + f + (m = (r = Lu.apply(this, [i, e])).reduce(function(C, E) {
      return C + E;
    }, 0)) > t || k) {
      if (m > t) {
        for (a = sg.apply(this, [i, r, t - (p + f), t]), u.push(a.shift()), u = [a.pop()]; a.length; ) d.push([a.shift()]);
        m = r.slice(i.length - (u[0] ? u[0].length : 0)).reduce(function(C, E) {
          return C + E;
        }, 0);
      } else u = [i];
      d.push(u), p = m + l, f = x;
    } else u.push(i), p += f + m, f = x;
  }
  return h = l ? function(C, E) {
    return (E ? y : "") + C.join(" ");
  } : function(C) {
    return C.join(" ");
  }, d.map(h);
}, ra.splitTextToSize = function(n, t, e) {
  var i, r = (e = e || {}).fontSize || this.internal.getFontSize(), s = (function(u) {
    if (u.widths && u.kerning) return { widths: u.widths, kerning: u.kerning };
    var d = this.internal.getFont(u.fontName, u.fontStyle);
    return d.metadata.Unicode ? { widths: d.metadata.Unicode.widths || { 0: 1 }, kerning: d.metadata.Unicode.kerning || {} } : { font: d.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, e);
  i = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var o = 1 * this.internal.scaleFactor * t / r;
  s.textIndent = e.textIndent ? 1 * e.textIndent * this.internal.scaleFactor / r : 0, s.lineIndent = e.lineIndent;
  var a, l, h = [];
  for (a = 0, l = i.length; a < l; a++) h = h.concat(og.apply(this, [i[a], o, s]));
  return h;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var t = "klmnopqrstuvwxyz", e = {}, i = {}, r = 0; r < t.length; r++) e[t[r]] = "0123456789abcdef"[r], i["0123456789abcdef"[r]] = t[r];
  var s = function(d) {
    return "0x" + parseInt(d, 10).toString(16);
  }, o = n.__fontmetrics__.compress = function(d) {
    var p, f, m, b, x = ["{"];
    for (var y in d) {
      if (p = d[y], isNaN(parseInt(y, 10)) ? f = "'" + y + "'" : (y = parseInt(y, 10), f = (f = s(y).slice(2)).slice(0, -1) + i[f.slice(-1)]), typeof p == "number") p < 0 ? (m = s(p).slice(3), b = "-") : (m = s(p).slice(2), b = ""), m = b + m.slice(0, -1) + i[m.slice(-1)];
      else {
        if (en(p) !== "object") throw new Error("Don't know what to do with value type " + en(p) + ".");
        m = o(p);
      }
      x.push(f + m);
    }
    return x.push("}"), x.join("");
  }, a = n.__fontmetrics__.uncompress = function(d) {
    if (typeof d != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var p, f, m, b, x = {}, y = 1, v = x, k = [], C = "", E = "", q = d.length - 1, T = 1; T < q; T += 1) (b = d[T]) == "'" ? p ? (m = p.join(""), p = void 0) : p = [] : p ? p.push(b) : b == "{" ? (k.push([v, m]), v = {}, m = void 0) : b == "}" ? ((f = k.pop())[0][f[1]] = v, m = void 0, v = f[0]) : b == "-" ? y = -1 : m === void 0 ? e.hasOwnProperty(b) ? (C += e[b], m = parseInt(C, 16) * y, y = 1, C = "") : C += b : e.hasOwnProperty(b) ? (E += e[b], v[m] = parseInt(E, 16) * y, y = 1, m = void 0, E = "") : E += b;
    return x;
  }, l = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: a("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h = { Unicode: { Courier: l, "Courier-Bold": l, "Courier-BoldOblique": l, "Courier-Oblique": l, Helvetica: l, "Helvetica-Bold": l, "Helvetica-BoldOblique": l, "Helvetica-Oblique": l, "Times-Roman": l, "Times-Bold": l, "Times-BoldItalic": l, "Times-Italic": l } }, u = { Unicode: { "Courier-Oblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": a("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": a("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: a("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: a("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": a("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": a("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(d) {
    var p = d.font, f = u.Unicode[p.postScriptName];
    f && (p.metadata.Unicode = {}, p.metadata.Unicode.widths = f.widths, p.metadata.Unicode.kerning = f.kerning);
    var m = h.Unicode[p.postScriptName];
    m && (p.metadata.Unicode.encoding = m, p.encoding = m.codePages[0]);
  }]);
}(Se.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    for (var i = e.length, r = new Uint8Array(i), s = 0; s < i; s++) r[s] = e.charCodeAt(s);
    return r;
  };
  n.API.events.push(["addFont", function(e) {
    var i = void 0, r = e.font, s = e.instance;
    if (!r.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      if (typeof (i = s.existsFileInVFS(r.postScriptName) === !1 ? s.loadFile(r.postScriptName) : s.getFileFromVFS(r.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      (function(o, a) {
        a = /^\x00\x01\x00\x00/.test(a) ? t(a) : t(Sl(a)), o.metadata = n.API.TTFFont.open(a), o.metadata.Unicode = o.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, o.metadata.glyIdsUsed = [0];
      })(r, i);
    }
  }]);
}(Se), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  function t() {
    return (Ce.canvg ? Promise.resolve(Ce.canvg) : import("./index.es-C8ySFdfa.js")).catch(function(e) {
      return Promise.reject(new Error("Could not load canvg: " + e));
    }).then(function(e) {
      return e.default ? e.default : e;
    });
  }
  Se.API.addSvgAsImage = function(e, i, r, s, o, a, l, h) {
    if (isNaN(i) || isNaN(r)) throw an.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(o)) throw an.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var u = document.createElement("canvas");
    u.width = s, u.height = o;
    var d = u.getContext("2d");
    d.fillStyle = "#fff", d.fillRect(0, 0, u.width, u.height);
    var p = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, f = this;
    return t().then(function(m) {
      return m.fromString(d, e, p);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(m) {
      return m.render(p);
    }).then(function() {
      f.addImage(u.toDataURL("image/jpeg", 1), i, r, s, o, l, h);
    });
  };
}(), Se.API.putTotalPages = function(n) {
  var t, e = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (t = new RegExp(n, "g"), e = this.internal.getNumberOfPages()) : (t = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), e = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++) for (var r = 0; r < this.internal.pages[i].length; r++) this.internal.pages[i][r] = this.internal.pages[i][r].replace(t, e);
  return this;
}, Se.API.viewerPreferences = function(n, t) {
  var e;
  n = n || {}, t = t || !1;
  var i, r, s, o = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, a = Object.keys(o), l = [], h = 0, u = 0, d = 0;
  function p(m, b) {
    var x, y = !1;
    for (x = 0; x < m.length; x += 1) m[x] === b && (y = !0);
    return y;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(o)), this.internal.viewerpreferences.isSubscribed = !1), e = this.internal.viewerpreferences.configuration, n === "reset" || t === !0) {
    var f = a.length;
    for (d = 0; d < f; d += 1) e[a[d]].value = e[a[d]].defaultValue, e[a[d]].explicitSet = !1;
  }
  if (en(n) === "object") {
    for (r in n) if (s = n[r], p(a, r) && s !== void 0) {
      if (e[r].type === "boolean" && typeof s == "boolean") e[r].value = s;
      else if (e[r].type === "name" && p(e[r].valueSet, s)) e[r].value = s;
      else if (e[r].type === "integer" && Number.isInteger(s)) e[r].value = s;
      else if (e[r].type === "array") {
        for (h = 0; h < s.length; h += 1) if (i = !0, s[h].length === 1 && typeof s[h][0] == "number") l.push(String(s[h] - 1));
        else if (s[h].length > 1) {
          for (u = 0; u < s[h].length; u += 1) typeof s[h][u] != "number" && (i = !1);
          i === !0 && l.push([s[h][0] - 1, s[h][1] - 1].join(" "));
        }
        e[r].value = "[" + l.join(" ") + "]";
      } else e[r].value = e[r].defaultValue;
      e[r].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var m, b = [];
    for (m in e) e[m].explicitSet === !0 && (e[m].type === "name" ? b.push("/" + m + " /" + e[m].value) : b.push("/" + m + " " + e[m].value));
    b.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + b.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = e, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  var t = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', r = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(i)), o = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), a = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), l = unescape(encodeURIComponent("</x:xmpmeta>")), h = s.length + o.length + a.length + r.length + l.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + h + " >>"), this.internal.write("stream"), this.internal.write(r + s + o + a + l), this.internal.write("endstream"), this.internal.write("endobj");
  }, e = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(i, r) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", e), this.internal.events.subscribe("postPutResources", t)), this;
  };
}(Se.API), function(n) {
  var t = n.API, e = t.pdfEscape16 = function(s, o) {
    for (var a, l = o.metadata.Unicode.widths, h = ["", "0", "00", "000", "0000"], u = [""], d = 0, p = s.length; d < p; ++d) {
      if (a = o.metadata.characterToGlyph(s.charCodeAt(d)), o.metadata.glyIdsUsed.push(a), o.metadata.toUnicode[a] = s.charCodeAt(d), l.indexOf(a) == -1 && (l.push(a), l.push([parseInt(o.metadata.widthOfGlyph(a), 10)])), a == "0") return u.join("");
      a = a.toString(16), u.push(h[4 - a.length], a);
    }
    return u.join("");
  }, i = function(s) {
    var o, a, l, h, u, d, p;
    for (u = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, l = [], d = 0, p = (a = Object.keys(s).sort(function(f, m) {
      return f - m;
    })).length; d < p; d++) o = a[d], l.length >= 100 && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar`, l = []), s[o] !== void 0 && s[o] !== null && typeof s[o].toString == "function" && (h = ("0000" + s[o].toString(16)).slice(-4), o = ("0000" + (+o).toString(16)).slice(-4), l.push("<" + o + "><" + h + ">"));
    return l.length && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar
`), u += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "Identity-H") {
        for (var d = a.metadata.Unicode.widths, p = a.metadata.subset.encode(a.metadata.glyIdsUsed, 1), f = "", m = 0; m < p.length; m++) f += String.fromCharCode(p[m]);
        var b = h();
        u({ data: f, addLength1: !0, objectId: b }), l("endobj");
        var x = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: x }), l("endobj");
        var y = h();
        l("<<"), l("/Type /FontDescriptor"), l("/FontName /" + pa(a.fontName)), l("/FontFile2 " + b + " 0 R"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/Flags " + a.metadata.flags), l("/StemV " + a.metadata.stemV), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l(">>"), l("endobj");
        var v = h();
        l("<<"), l("/Type /Font"), l("/BaseFont /" + pa(a.fontName)), l("/FontDescriptor " + y + " 0 R"), l("/W " + n.API.PDFObject.convert(d)), l("/CIDToGIDMap /Identity"), l("/DW 1000"), l("/Subtype /CIDFontType2"), l("/CIDSystemInfo"), l("<<"), l("/Supplement 0"), l("/Registry (Adobe)"), l("/Ordering (" + a.encoding + ")"), l(">>"), l(">>"), l("endobj"), a.objectNumber = h(), l("<<"), l("/Type /Font"), l("/Subtype /Type0"), l("/ToUnicode " + x + " 0 R"), l("/BaseFont /" + pa(a.fontName)), l("/Encoding /" + a.encoding), l("/DescendantFonts [" + v + " 0 R]"), l(">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]), t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "WinAnsiEncoding") {
        for (var d = a.metadata.rawData, p = "", f = 0; f < d.length; f++) p += String.fromCharCode(d[f]);
        var m = h();
        u({ data: p, addLength1: !0, objectId: m }), l("endobj");
        var b = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: b }), l("endobj");
        var x = h();
        l("<<"), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l("/StemV " + a.metadata.stemV), l("/Type /FontDescriptor"), l("/FontFile2 " + m + " 0 R"), l("/Flags 96"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/FontName /" + pa(a.fontName)), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l(">>"), l("endobj"), a.objectNumber = h();
        for (var y = 0; y < a.metadata.hmtx.widths.length; y++) a.metadata.hmtx.widths[y] = parseInt(a.metadata.hmtx.widths[y] * (1e3 / a.metadata.head.unitsPerEm));
        l("<</Subtype/TrueType/Type/Font/ToUnicode " + b + " 0 R/BaseFont/" + pa(a.fontName) + "/FontDescriptor " + x + " 0 R/Encoding/" + a.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(a.metadata.hmtx.widths) + ">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var r = function(s) {
    var o, a = s.text || "", l = s.x, h = s.y, u = s.options || {}, d = s.mutex || {}, p = d.pdfEscape, f = d.activeFontKey, m = d.fonts, b = f, x = "", y = 0, v = "", k = m[b].encoding;
    if (m[b].encoding !== "Identity-H") return { text: a, x: l, y: h, options: u, mutex: d };
    for (v = a, b = f, Array.isArray(a) && (v = a[0]), y = 0; y < v.length; y += 1) m[b].metadata.hasOwnProperty("cmap") && (o = m[b].metadata.cmap.unicode.codeMap[v[y].charCodeAt(0)]), o || v[y].charCodeAt(0) < 256 && m[b].metadata.hasOwnProperty("Unicode") ? x += v[y] : x += "";
    var C = "";
    return parseInt(b.slice(1)) < 14 || k === "WinAnsiEncoding" ? C = p(x, b).split("").map(function(E) {
      return E.charCodeAt(0).toString(16);
    }).join("") : k === "Identity-H" && (C = e(x, m[b])), d.isHex = !0, { text: C, x: l, y: h, options: u, mutex: d };
  };
  t.events.push(["postProcessText", function(s) {
    var o = s.text || "", a = [], l = { text: o, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(o)) {
      var h = 0;
      for (h = 0; h < o.length; h += 1) Array.isArray(o[h]) && o[h].length === 3 ? a.push([r(Object.assign({}, l, { text: o[h][0] })).text, o[h][1], o[h][2]]) : a.push(r(Object.assign({}, l, { text: o[h] })).text);
      s.text = a;
    } else s.text = r(Object.assign({}, l, { text: o })).text;
  }]);
}(Se), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0;
  }, n.addFileToVFS = function(e, i) {
    return t.call(this), this.internal.vFS[e] = i, this;
  }, n.getFileFromVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0 ? this.internal.vFS[e] : null;
  };
}(Se.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(i) {
    var r, s, o, a, l, h, u, d = t, p = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], f = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], m = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, b = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, x = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], y = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), v = !1, k = 0;
    this.__bidiEngine__ = {};
    var C = function(P) {
      var A = P.charCodeAt(), I = A >> 8, S = b[I];
      return S !== void 0 ? d[256 * S + (255 & A)] : I === 252 || I === 253 ? "AL" : y.test(I) ? "L" : I === 8 ? "R" : "N";
    }, E = function(P) {
      for (var A, I = 0; I < P.length; I++) {
        if ((A = C(P.charAt(I))) === "L") return !1;
        if (A === "R") return !0;
      }
      return !1;
    }, q = function(P, A, I, S) {
      var X, H, j, Q, G = A[S];
      switch (G) {
        case "L":
        case "R":
          v = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          v && (G = "AN");
          break;
        case "AL":
          v = !0, G = "R";
          break;
        case "WS":
          G = "N";
          break;
        case "CS":
          S < 1 || S + 1 >= A.length || (X = I[S - 1]) !== "EN" && X !== "AN" || (H = A[S + 1]) !== "EN" && H !== "AN" ? G = "N" : v && (H = "AN"), G = H === X ? H : "N";
          break;
        case "ES":
          G = (X = S > 0 ? I[S - 1] : "B") === "EN" && S + 1 < A.length && A[S + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (S > 0 && I[S - 1] === "EN") {
            G = "EN";
            break;
          }
          if (v) {
            G = "N";
            break;
          }
          for (j = S + 1, Q = A.length; j < Q && A[j] === "ET"; ) j++;
          G = j < Q && A[j] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (o && !a) {
            for (Q = A.length, j = S + 1; j < Q && A[j] === "NSM"; ) j++;
            if (j < Q) {
              var ft = P[S], nt = ft >= 1425 && ft <= 2303 || ft === 64286;
              if (X = A[j], nt && (X === "R" || X === "AL")) {
                G = "R";
                break;
              }
            }
          }
          G = S < 1 || (X = A[S - 1]) === "B" ? "N" : I[S - 1];
          break;
        case "B":
          v = !1, r = !0, G = k;
          break;
        case "S":
          s = !0, G = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          v = !1;
          break;
        case "BN":
          G = "N";
      }
      return G;
    }, T = function(P, A, I) {
      var S = P.split("");
      return I && F(S, I, { hiLevel: k }), S.reverse(), A && A.reverse(), S.join("");
    }, F = function(P, A, I) {
      var S, X, H, j, Q, G = -1, ft = P.length, nt = 0, N = [], z = k ? f : p, V = [];
      for (v = !1, r = !1, s = !1, X = 0; X < ft; X++) V[X] = C(P[X]);
      for (H = 0; H < ft; H++) {
        if (Q = nt, N[H] = q(P, V, N, H), S = 240 & (nt = z[Q][m[N[H]]]), nt &= 15, A[H] = j = z[nt][5], S > 0) if (S === 16) {
          for (X = G; X < H; X++) A[X] = 1;
          G = -1;
        } else G = -1;
        if (z[nt][6]) G === -1 && (G = H);
        else if (G > -1) {
          for (X = G; X < H; X++) A[X] = j;
          G = -1;
        }
        V[H] === "B" && (A[H] = 0), I.hiLevel |= j;
      }
      s && function(Y, ot, wt) {
        for (var mt = 0; mt < wt; mt++) if (Y[mt] === "S") {
          ot[mt] = k;
          for (var xt = mt - 1; xt >= 0 && Y[xt] === "WS"; xt--) ot[xt] = k;
        }
      }(V, A, ft);
    }, M = function(P, A, I, S, X) {
      if (!(X.hiLevel < P)) {
        if (P === 1 && k === 1 && !r) return A.reverse(), void (I && I.reverse());
        for (var H, j, Q, G, ft = A.length, nt = 0; nt < ft; ) {
          if (S[nt] >= P) {
            for (Q = nt + 1; Q < ft && S[Q] >= P; ) Q++;
            for (G = nt, j = Q - 1; G < j; G++, j--) H = A[G], A[G] = A[j], A[j] = H, I && (H = I[G], I[G] = I[j], I[j] = H);
            nt = Q;
          }
          nt++;
        }
      }
    }, B = function(P, A, I) {
      var S = P.split(""), X = { hiLevel: k };
      return I || (I = []), F(S, I, X), function(H, j, Q) {
        if (Q.hiLevel !== 0 && u) for (var G, ft = 0; ft < H.length; ft++) j[ft] === 1 && (G = x.indexOf(H[ft])) >= 0 && (H[ft] = x[G + 1]);
      }(S, I, X), M(2, S, A, I, X), M(1, S, A, I, X), S.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(P, A, I) {
      if (function(X, H) {
        if (H) for (var j = 0; j < X.length; j++) H[j] = j;
        a === void 0 && (a = E(X)), h === void 0 && (h = E(X));
      }(P, A), o || !l || h) if (o && l && a ^ h) k = a ? 1 : 0, P = T(P, A, I);
      else if (!o && l && h) k = a ? 1 : 0, P = B(P, A, I), P = T(P, A);
      else if (!o || a || l || h) {
        if (o && !l && a ^ h) P = T(P, A), a ? (k = 0, P = B(P, A, I)) : (k = 1, P = B(P, A, I), P = T(P, A));
        else if (o && a && !l && h) k = 1, P = B(P, A, I), P = T(P, A);
        else if (!o && !l && a ^ h) {
          var S = u;
          a ? (k = 1, P = B(P, A, I), k = 0, u = !1, P = B(P, A, I), u = S) : (k = 0, P = B(P, A, I), P = T(P, A), k = 1, u = !1, P = B(P, A, I), u = S, P = T(P, A));
        }
      } else k = 0, P = B(P, A, I);
      else k = a ? 1 : 0, P = B(P, A, I);
      return P;
    }, this.__bidiEngine__.setOptions = function(P) {
      P && (o = P.isInputVisual, l = P.isOutputVisual, a = P.isInputRtl, h = P.isOutputRtl, u = P.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var t = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], e = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(i) {
    var r = i.text, s = (i.x, i.y, i.options || {}), o = (i.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, e.setOptions(s), Object.prototype.toString.call(r) === "[object Array]") {
      var a = 0;
      for (o = [], a = 0; a < r.length; a += 1) Object.prototype.toString.call(r[a]) === "[object Array]" ? o.push([e.doBidiReorder(r[a][0]), r[a][1], r[a][2]]) : o.push([e.doBidiReorder(r[a])]);
      i.text = o;
    } else i.text = e.doBidiReorder(r);
    e.setOptions({ isInputVisual: !0 });
  }]);
}(Se), Se.API.TTFFont = function() {
  function n(t) {
    var e;
    if (this.rawData = t, e = this.contents = new qs(t), this.contents.pos = 4, e.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Jv(this), this.registerTTF();
  }
  return n.open = function(t) {
    return new n(t);
  }, n.prototype.parse = function() {
    return this.directory = new Dv(this.contents), this.head = new jv(this), this.name = new Wv(this), this.cmap = new B1(this), this.toUnicode = {}, this.hhea = new qv(this), this.maxp = new Hv(this), this.hmtx = new Gv(this), this.post = new $v(this), this.os2 = new zv(this), this.loca = new Xv(this), this.glyf = new Vv(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var t, e, i, r, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var o, a, l, h;
      for (h = [], o = 0, a = (l = this.bbox).length; o < a; o++) t = l[o], h.push(Math.round(t * this.scaleFactor));
      return h;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (r = this.post.italic_angle), 32768 & (e = r >> 16) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(t) {
    var e;
    return ((e = this.cmap.unicode) != null ? e.codeMap[t] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(t) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * e;
  }, n.prototype.widthOfString = function(t, e, i) {
    var r, s, o, a;
    for (o = 0, s = 0, a = (t = "" + t).length; 0 <= a ? s < a : s > a; s = 0 <= a ? ++s : --s) r = t.charCodeAt(s), o += this.widthOfGlyph(this.characterToGlyph(r)) + i * (1e3 / e) || 0;
    return o * (e / 1e3);
  }, n.prototype.lineHeight = function(t, e) {
    var i;
    return e == null && (e = !1), i = e ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * t;
  }, n;
}();
var vr, qs = function() {
  function n(t) {
    this.data = t ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(t) {
    return this.data[this.pos++] = t;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(t) {
    return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt32 = function() {
    var t;
    return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t;
  }, n.prototype.writeInt32 = function(t) {
    return t < 0 && (t += 4294967296), this.writeUInt32(t);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(t) {
    return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt16 = function() {
    var t;
    return (t = this.readUInt16()) >= 32768 ? t - 65536 : t;
  }, n.prototype.writeInt16 = function(t) {
    return t < 0 && (t += 65536), this.writeUInt16(t);
  }, n.prototype.readString = function(t) {
    var e, i;
    for (i = [], e = 0; 0 <= t ? e < t : e > t; e = 0 <= t ? ++e : --e) i[e] = String.fromCharCode(this.readByte());
    return i.join("");
  }, n.prototype.writeString = function(t) {
    var e, i, r;
    for (r = [], e = 0, i = t.length; 0 <= i ? e < i : e > i; e = 0 <= i ? ++e : --e) r.push(this.writeByte(t.charCodeAt(e)));
    return r;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(t) {
    return this.writeInt16(t);
  }, n.prototype.readLongLong = function() {
    var t, e, i, r, s, o, a, l;
    return t = this.readByte(), e = this.readByte(), i = this.readByte(), r = this.readByte(), s = this.readByte(), o = this.readByte(), a = this.readByte(), l = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ s) + 65536 * (255 ^ o) + 256 * (255 ^ a) + (255 ^ l) + 1) : 72057594037927940 * t + 281474976710656 * e + 1099511627776 * i + 4294967296 * r + 16777216 * s + 65536 * o + 256 * a + l;
  }, n.prototype.writeLongLong = function(t) {
    var e, i;
    return e = Math.floor(t / 4294967296), i = 4294967295 & t, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(t) {
    return this.writeInt32(t);
  }, n.prototype.read = function(t) {
    var e, i;
    for (e = [], i = 0; 0 <= t ? i < t : i > t; i = 0 <= t ? ++i : --i) e.push(this.readByte());
    return e;
  }, n.prototype.write = function(t) {
    var e, i, r, s;
    for (s = [], i = 0, r = t.length; i < r; i++) e = t[i], s.push(this.writeByte(e));
    return s;
  }, n;
}(), Dv = function() {
  var n;
  function t(e) {
    var i, r, s;
    for (this.scalarType = e.readInt(), this.tableCount = e.readShort(), this.searchRange = e.readShort(), this.entrySelector = e.readShort(), this.rangeShift = e.readShort(), this.tables = {}, r = 0, s = this.tableCount; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = { tag: e.readString(4), checksum: e.readInt(), offset: e.readInt(), length: e.readInt() }, this.tables[i.tag] = i;
  }
  return t.prototype.encode = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b;
    for (b in f = Object.keys(e).length, l = Math.log(2), d = 16 * Math.floor(Math.log(f) / l), o = Math.floor(d / l), u = 16 * f - d, (r = new qs()).writeInt(this.scalarType), r.writeShort(f), r.writeShort(d), r.writeShort(o), r.writeShort(u), s = 16 * f, h = r.pos + s, a = null, m = [], e) for (p = e[b], r.writeString(b), r.writeInt(n(p)), r.writeInt(h), r.writeInt(p.length), m = m.concat(p), b === "head" && (a = h), h += p.length; h % 4; ) m.push(0), h++;
    return r.write(m), i = 2981146554 - n(r.data), r.pos = a + 8, r.writeUInt32(i), r.data;
  }, n = function(e) {
    var i, r, s, o;
    for (e = j1.call(e); e.length % 4; ) e.push(0);
    for (s = new qs(e), r = 0, i = 0, o = e.length; i < o; i = i += 4) r += s.readUInt32();
    return 4294967295 & r;
  }, t;
}(), Bv = {}.hasOwnProperty, Rr = function(n, t) {
  for (var e in t) Bv.call(t, e) && (n[e] = t[e]);
  function i() {
    this.constructor = n;
  }
  return i.prototype = t.prototype, n.prototype = new i(), n.__super__ = t.prototype, n;
};
vr = function() {
  function n(t) {
    var e;
    this.file = t, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var jv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "head", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.revision = e.readInt(), this.checkSumAdjustment = e.readInt(), this.magicNumber = e.readInt(), this.flags = e.readShort(), this.unitsPerEm = e.readShort(), this.created = e.readLongLong(), this.modified = e.readLongLong(), this.xMin = e.readShort(), this.yMin = e.readShort(), this.xMax = e.readShort(), this.yMax = e.readShort(), this.macStyle = e.readShort(), this.lowestRecPPEM = e.readShort(), this.fontDirectionHint = e.readShort(), this.indexToLocFormat = e.readShort(), this.glyphDataFormat = e.readShort();
  }, t.prototype.encode = function(e) {
    var i;
    return (i = new qs()).writeInt(this.version), i.writeInt(this.revision), i.writeInt(this.checkSumAdjustment), i.writeInt(this.magicNumber), i.writeShort(this.flags), i.writeShort(this.unitsPerEm), i.writeLongLong(this.created), i.writeLongLong(this.modified), i.writeShort(this.xMin), i.writeShort(this.yMin), i.writeShort(this.xMax), i.writeShort(this.yMax), i.writeShort(this.macStyle), i.writeShort(this.lowestRecPPEM), i.writeShort(this.fontDirectionHint), i.writeShort(e), i.writeShort(this.glyphDataFormat), i.data;
  }, t;
}(), ug = function() {
  function n(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b, x, y, v, k;
    switch (this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = e + t.readInt(), d = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (l = 0; l < 256; ++l) this.codeMap[l] = t.readByte();
        break;
      case 4:
        for (f = t.readUInt16(), p = f / 2, t.pos += 6, s = function() {
          var C, E;
          for (E = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) E.push(t.readUInt16());
          return E;
        }(), t.pos += 2, b = function() {
          var C, E;
          for (E = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) E.push(t.readUInt16());
          return E;
        }(), h = function() {
          var C, E;
          for (E = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) E.push(t.readUInt16());
          return E;
        }(), u = function() {
          var C, E;
          for (E = [], l = C = 0; 0 <= p ? C < p : C > p; l = 0 <= p ? ++C : --C) E.push(t.readUInt16());
          return E;
        }(), r = (this.length - t.pos + this.offset) / 2, a = function() {
          var C, E;
          for (E = [], l = C = 0; 0 <= r ? C < r : C > r; l = 0 <= r ? ++C : --C) E.push(t.readUInt16());
          return E;
        }(), l = y = 0, k = s.length; y < k; l = ++y) for (x = s[l], i = v = m = b[l]; m <= x ? v <= x : v >= x; i = m <= x ? ++v : --v) u[l] === 0 ? o = i + h[l] : (o = a[u[l] / 2 + (i - m) - (p - l)] || 0) !== 0 && (o += h[l]), this.codeMap[i] = 65535 & o;
    }
    t.pos = d;
  }
  return n.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b, x, y, v, k, C, E, q, T, F, M, B, P, A, I, S, X, H, j, Q, G, ft, nt, N, z, V, Y, ot, wt, mt, xt, zt, Dt, Jt;
    switch (S = new qs(), o = Object.keys(t).sort(function(Qt, O) {
      return Qt - O;
    }), e) {
      case "macroman":
        for (b = 0, x = function() {
          var Qt = [];
          for (m = 0; m < 256; ++m) Qt.push(0);
          return Qt;
        }(), v = { 0: 0 }, s = {}, X = 0, G = o.length; X < G; X++) v[xt = t[r = o[X]]] == null && (v[xt] = ++b), s[r] = { old: t[r], new: v[t[r]] }, x[r] = v[t[r]];
        return S.writeUInt16(1), S.writeUInt16(0), S.writeUInt32(12), S.writeUInt16(0), S.writeUInt16(262), S.writeUInt16(0), S.write(x), { charMap: s, subtable: S.data, maxGlyphID: b + 1 };
      case "unicode":
        for (A = [], d = [], k = 0, v = {}, i = {}, y = h = null, H = 0, ft = o.length; H < ft; H++) v[E = t[r = o[H]]] == null && (v[E] = ++k), i[r] = { old: E, new: v[E] }, a = v[E] - r, y != null && a === h || (y && d.push(y), A.push(r), h = a), y = r;
        for (y && d.push(y), d.push(65535), A.push(65535), B = 2 * (M = A.length), F = 2 * Math.pow(Math.log(M) / Math.LN2, 2), p = Math.log(F / 2) / Math.LN2, T = 2 * M - F, l = [], q = [], f = [], m = j = 0, nt = A.length; j < nt; m = ++j) {
          if (P = A[m], u = d[m], P === 65535) {
            l.push(0), q.push(0);
            break;
          }
          if (P - (I = i[P].new) >= 32768) for (l.push(0), q.push(2 * (f.length + M - m)), r = Q = P; P <= u ? Q <= u : Q >= u; r = P <= u ? ++Q : --Q) f.push(i[r].new);
          else l.push(I - P), q.push(0);
        }
        for (S.writeUInt16(3), S.writeUInt16(1), S.writeUInt32(12), S.writeUInt16(4), S.writeUInt16(16 + 8 * M + 2 * f.length), S.writeUInt16(0), S.writeUInt16(B), S.writeUInt16(F), S.writeUInt16(p), S.writeUInt16(T), wt = 0, N = d.length; wt < N; wt++) r = d[wt], S.writeUInt16(r);
        for (S.writeUInt16(0), mt = 0, z = A.length; mt < z; mt++) r = A[mt], S.writeUInt16(r);
        for (zt = 0, V = l.length; zt < V; zt++) a = l[zt], S.writeUInt16(a);
        for (Dt = 0, Y = q.length; Dt < Y; Dt++) C = q[Dt], S.writeUInt16(C);
        for (Jt = 0, ot = f.length; Jt < ot; Jt++) b = f[Jt], S.writeUInt16(b);
        return { charMap: i, subtable: S.data, maxGlyphID: k + 1 };
    }
  }, n;
}(), B1 = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "cmap", t.prototype.parse = function(e) {
    var i, r, s;
    for (e.pos = this.offset, this.version = e.readUInt16(), s = e.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = new ug(e, this.offset), this.tables.push(i), i.isUnicode && this.unicode == null && (this.unicode = i);
    return !0;
  }, t.encode = function(e, i) {
    var r, s;
    return i == null && (i = "macroman"), r = ug.encode(e, i), (s = new qs()).writeUInt16(0), s.writeUInt16(1), r.table = s.data.concat(r.subtable), r;
  }, t;
}(), qv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "hhea", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.ascender = e.readShort(), this.decender = e.readShort(), this.lineGap = e.readShort(), this.advanceWidthMax = e.readShort(), this.minLeftSideBearing = e.readShort(), this.minRightSideBearing = e.readShort(), this.xMaxExtent = e.readShort(), this.caretSlopeRise = e.readShort(), this.caretSlopeRun = e.readShort(), this.caretOffset = e.readShort(), e.pos += 8, this.metricDataFormat = e.readShort(), this.numberOfMetrics = e.readUInt16();
  }, t;
}(), zv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "OS/2", t.prototype.parse = function(e) {
    if (e.pos = this.offset, this.version = e.readUInt16(), this.averageCharWidth = e.readShort(), this.weightClass = e.readUInt16(), this.widthClass = e.readUInt16(), this.type = e.readShort(), this.ySubscriptXSize = e.readShort(), this.ySubscriptYSize = e.readShort(), this.ySubscriptXOffset = e.readShort(), this.ySubscriptYOffset = e.readShort(), this.ySuperscriptXSize = e.readShort(), this.ySuperscriptYSize = e.readShort(), this.ySuperscriptXOffset = e.readShort(), this.ySuperscriptYOffset = e.readShort(), this.yStrikeoutSize = e.readShort(), this.yStrikeoutPosition = e.readShort(), this.familyClass = e.readShort(), this.panose = function() {
      var i, r;
      for (r = [], i = 0; i < 10; ++i) r.push(e.readByte());
      return r;
    }(), this.charRange = function() {
      var i, r;
      for (r = [], i = 0; i < 4; ++i) r.push(e.readInt());
      return r;
    }(), this.vendorID = e.readString(4), this.selection = e.readShort(), this.firstCharIndex = e.readShort(), this.lastCharIndex = e.readShort(), this.version > 0 && (this.ascent = e.readShort(), this.descent = e.readShort(), this.lineGap = e.readShort(), this.winAscent = e.readShort(), this.winDescent = e.readShort(), this.codePageRange = function() {
      var i, r;
      for (r = [], i = 0; i < 2; i = ++i) r.push(e.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = e.readShort(), this.capHeight = e.readShort(), this.defaultChar = e.readShort(), this.breakChar = e.readShort(), this.maxContext = e.readShort();
  }, t;
}(), $v = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "post", t.prototype.parse = function(e) {
    var i, r, s;
    switch (e.pos = this.offset, this.format = e.readInt(), this.italicAngle = e.readInt(), this.underlinePosition = e.readShort(), this.underlineThickness = e.readShort(), this.isFixedPitch = e.readInt(), this.minMemType42 = e.readInt(), this.maxMemType42 = e.readInt(), this.minMemType1 = e.readInt(), this.maxMemType1 = e.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var o;
        for (r = e.readUInt16(), this.glyphNameIndex = [], o = 0; 0 <= r ? o < r : o > r; o = 0 <= r ? ++o : --o) this.glyphNameIndex.push(e.readUInt16());
        for (this.names = [], s = []; e.pos < this.offset + this.length; ) i = e.readByte(), s.push(this.names.push(e.readString(i)));
        return s;
      case 151552:
        return r = e.readUInt16(), this.offsets = e.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var a, l, h;
          for (h = [], o = a = 0, l = this.file.maxp.numGlyphs; 0 <= l ? a < l : a > l; o = 0 <= l ? ++a : --a) h.push(e.readUInt32());
          return h;
        }).call(this);
    }
  }, t;
}(), Uv = function(n, t) {
  this.raw = n, this.length = n.length, this.platformID = t.platformID, this.encodingID = t.encodingID, this.languageID = t.languageID;
}, Wv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "name", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f;
    for (e.pos = this.offset, e.readShort(), i = e.readShort(), l = e.readShort(), r = [], o = 0; 0 <= i ? o < i : o > i; o = 0 <= i ? ++o : --o) r.push({ platformID: e.readShort(), encodingID: e.readShort(), languageID: e.readShort(), nameID: e.readShort(), length: e.readShort(), offset: this.offset + l + e.readShort() });
    for (h = {}, o = d = 0, p = r.length; d < p; o = ++d) s = r[o], e.pos = s.offset, u = e.readString(s.length), a = new Uv(u, s), h[f = s.nameID] == null && (h[f] = []), h[s.nameID].push(a);
    this.strings = h, this.copyright = h[0], this.fontFamily = h[1], this.fontSubfamily = h[2], this.uniqueSubfamily = h[3], this.fontName = h[4], this.version = h[5];
    try {
      this.postscriptName = h[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = h[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = h[7], this.manufacturer = h[8], this.designer = h[9], this.description = h[10], this.vendorUrl = h[11], this.designerUrl = h[12], this.license = h[13], this.licenseUrl = h[14], this.preferredFamily = h[15], this.preferredSubfamily = h[17], this.compatibleFull = h[18], this.sampleText = h[19];
  }, t;
}(), Hv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "maxp", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.numGlyphs = e.readUInt16(), this.maxPoints = e.readUInt16(), this.maxContours = e.readUInt16(), this.maxCompositePoints = e.readUInt16(), this.maxComponentContours = e.readUInt16(), this.maxZones = e.readUInt16(), this.maxTwilightPoints = e.readUInt16(), this.maxStorage = e.readUInt16(), this.maxFunctionDefs = e.readUInt16(), this.maxInstructionDefs = e.readUInt16(), this.maxStackElements = e.readUInt16(), this.maxSizeOfInstructions = e.readUInt16(), this.maxComponentElements = e.readUInt16(), this.maxComponentDepth = e.readUInt16();
  }, t;
}(), Gv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "hmtx", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h;
    for (e.pos = this.offset, this.metrics = [], i = 0, l = this.file.hhea.numberOfMetrics; 0 <= l ? i < l : i > l; i = 0 <= l ? ++i : --i) this.metrics.push({ advance: e.readUInt16(), lsb: e.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var u, d;
      for (d = [], i = u = 0; 0 <= s ? u < s : u > s; i = 0 <= s ? ++u : --u) d.push(e.readInt16());
      return d;
    }(), this.widths = (function() {
      var u, d, p, f;
      for (f = [], u = 0, d = (p = this.metrics).length; u < d; u++) o = p[u], f.push(o.advance);
      return f;
    }).call(this), r = this.widths[this.widths.length - 1], h = [], i = a = 0; 0 <= s ? a < s : a > s; i = 0 <= s ? ++a : --a) h.push(this.widths.push(r));
    return h;
  }, t.prototype.forGlyph = function(e) {
    return e in this.metrics ? this.metrics[e] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[e - this.metrics.length] };
  }, t;
}(), j1 = [].slice, Vv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "glyf", t.prototype.parse = function() {
    return this.cache = {};
  }, t.prototype.glyphFor = function(e) {
    var i, r, s, o, a, l, h, u, d, p;
    return e in this.cache ? this.cache[e] : (o = this.file.loca, i = this.file.contents, r = o.indexOf(e), (s = o.lengthOf(e)) === 0 ? this.cache[e] = null : (i.pos = this.offset + r, a = (l = new qs(i.read(s))).readShort(), u = l.readShort(), p = l.readShort(), h = l.readShort(), d = l.readShort(), this.cache[e] = a === -1 ? new Kv(l, u, p, h, d) : new Yv(l, a, u, p, h, d), this.cache[e]));
  }, t.prototype.encode = function(e, i, r) {
    var s, o, a, l, h;
    for (a = [], o = [], l = 0, h = i.length; l < h; l++) s = e[i[l]], o.push(a.length), s && (a = a.concat(s.encode(r)));
    return o.push(a.length), { table: a, offsets: o };
  }, t;
}(), Yv = function() {
  function n(t, e, i, r, s, o) {
    this.raw = t, this.numberOfContours = e, this.xMin = i, this.yMin = r, this.xMax = s, this.yMax = o, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), Kv = function() {
  function n(t, e, i, r, s) {
    var o, a;
    for (this.raw = t, this.xMin = e, this.yMin = i, this.xMax = r, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], o = this.raw; a = o.readShort(), this.glyphOffsets.push(o.pos), this.glyphIDs.push(o.readUInt16()), 32 & a; ) o.pos += 1 & a ? 4 : 2, 128 & a ? o.pos += 8 : 64 & a ? o.pos += 4 : 8 & a && (o.pos += 2);
  }
  return n.prototype.encode = function() {
    var t, e, i;
    for (e = new qs(j1.call(this.raw.data)), t = 0, i = this.glyphIDs.length; t < i; ++t) e.pos = this.glyphOffsets[t];
    return e.data;
  }, n;
}(), Xv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Rr(t, vr), t.prototype.tag = "loca", t.prototype.parse = function(e) {
    var i, r;
    return e.pos = this.offset, i = this.file.head.indexToLocFormat, this.offsets = i === 0 ? (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 2) o.push(2 * e.readUInt16());
      return o;
    }).call(this) : (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 4) o.push(e.readUInt32());
      return o;
    }).call(this);
  }, t.prototype.indexOf = function(e) {
    return this.offsets[e];
  }, t.prototype.lengthOf = function(e) {
    return this.offsets[e + 1] - this.offsets[e];
  }, t.prototype.encode = function(e, i) {
    for (var r = new Uint32Array(this.offsets.length), s = 0, o = 0, a = 0; a < r.length; ++a) if (r[a] = s, o < i.length && i[o] == a) {
      ++o, r[a] = s;
      var l = this.offsets[a], h = this.offsets[a + 1] - l;
      h > 0 && (s += h);
    }
    for (var u = new Array(4 * r.length), d = 0; d < r.length; ++d) u[4 * d + 3] = 255 & r[d], u[4 * d + 2] = (65280 & r[d]) >> 8, u[4 * d + 1] = (16711680 & r[d]) >> 16, u[4 * d] = (4278190080 & r[d]) >> 24;
    return u;
  }, t;
}(), Jv = function() {
  function n(t) {
    this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var t, e, i, r, s;
    for (e in r = this.font.cmap.tables[0].codeMap, t = {}, s = this.subset) i = s[e], t[e] = r[i];
    return t;
  }, n.prototype.glyphsFor = function(t) {
    var e, i, r, s, o, a, l;
    for (r = {}, o = 0, a = t.length; o < a; o++) r[s = t[o]] = this.font.glyf.glyphFor(s);
    for (s in e = [], r) (i = r[s]) != null && i.compound && e.push.apply(e, i.glyphIDs);
    if (e.length > 0) for (s in l = this.glyphsFor(e)) i = l[s], r[s] = i;
    return r;
  }, n.prototype.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, m, b, x, y;
    for (r in i = B1.encode(this.generateCmap(), "unicode"), o = this.glyphsFor(t), f = { 0: 0 }, y = i.charMap) f[(l = y[r]).old] = l.new;
    for (m in p = i.maxGlyphID, o) m in f || (f[m] = p++);
    return u = function(v) {
      var k, C;
      for (k in C = {}, v) C[v[k]] = k;
      return C;
    }(f), d = Object.keys(u).sort(function(v, k) {
      return v - k;
    }), b = function() {
      var v, k, C;
      for (C = [], v = 0, k = d.length; v < k; v++) a = d[v], C.push(u[a]);
      return C;
    }(), s = this.font.glyf.encode(o, b, f), h = this.font.loca.encode(s.offsets, b), x = { cmap: this.font.cmap.raw(), glyf: s.table, loca: h, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (x["OS/2"] = this.font.os2.raw()), this.font.directory.encode(x);
  }, n;
}();
Se.API.PDFObject = function() {
  var n;
  function t() {
  }
  return n = function(e, i) {
    return (Array(i + 1).join("0") + e).slice(-i);
  }, t.convert = function(e) {
    var i, r, s, o;
    if (Array.isArray(e)) return "[" + function() {
      var a, l, h;
      for (h = [], a = 0, l = e.length; a < l; a++) i = e[a], h.push(t.convert(i));
      return h;
    }().join(" ") + "]";
    if (typeof e == "string") return "/" + e;
    if (e != null && e.isString) return "(" + e + ")";
    if (e instanceof Date) return "(D:" + n(e.getUTCFullYear(), 4) + n(e.getUTCMonth(), 2) + n(e.getUTCDate(), 2) + n(e.getUTCHours(), 2) + n(e.getUTCMinutes(), 2) + n(e.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(e) === "[object Object]") {
      for (r in s = ["<<"], e) o = e[r], s.push("/" + r + " " + t.convert(o));
      return s.push(">>"), s.join(`
`);
    }
    return "" + e;
  }, t;
}();
const Zv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, AcroForm: Lv, AcroFormAppearance: de, AcroFormButton: qn, AcroFormCheckBox: Nl, AcroFormChoiceField: po, AcroFormComboBox: mo, AcroFormEditBox: kl, AcroFormListBox: go, AcroFormPasswordField: Cl, AcroFormPushButton: Al, AcroFormRadioButton: yo, AcroFormTextField: Rs, GState: Ll, ShadingPattern: Is, TilingPattern: uo, default: Se, jsPDF: Se }, Symbol.toStringTag, { value: "Module" }));
var q1 = { exports: {} };
const Qv = /* @__PURE__ */ wy(Zv);
/*!
* 
*               jsPDF AutoTable plugin v3.8.4
*
*               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
*               Licensed under the MIT License.
*               http://opensource.org/licenses/mit-license
*
*/
(function(n, t) {
  (function(i, r) {
    n.exports = r(function() {
      try {
        return Qv;
      } catch {
      }
    }());
  })(typeof globalThis < "u" ? globalThis : typeof ao < "u" ? ao : typeof window < "u" ? window : typeof self < "u" ? self : ao, function(e) {
    return (
      /******/
      function() {
        var i = {
          /***/
          172: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var p = function(f, m) {
                  return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b, x) {
                    b.__proto__ = x;
                  } || function(b, x) {
                    for (var y in x) Object.prototype.hasOwnProperty.call(x, y) && (b[y] = x[y]);
                  }, p(f, m);
                };
                return function(f, m) {
                  if (typeof m != "function" && m !== null)
                    throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
                  p(f, m);
                  function b() {
                    this.constructor = f;
                  }
                  f.prototype = m === null ? Object.create(m) : (b.prototype = m.prototype, new b());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.CellHookData = l.HookData = void 0;
              var u = (
                /** @class */
                /* @__PURE__ */ function() {
                  function p(f, m, b) {
                    this.table = m, this.pageNumber = m.pageNumber, this.pageCount = this.pageNumber, this.settings = m.settings, this.cursor = b, this.doc = f.getDocument();
                  }
                  return p;
                }()
              );
              l.HookData = u;
              var d = (
                /** @class */
                function(p) {
                  h(f, p);
                  function f(m, b, x, y, v, k) {
                    var C = p.call(this, m, b, k) || this;
                    return C.cell = x, C.row = y, C.column = v, C.section = y.section, C;
                  }
                  return f;
                }(u)
              );
              l.CellHookData = d;
            }
          ),
          /***/
          340: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              var u = h(4), d = h(136), p = h(744), f = h(776), m = h(664), b = h(972);
              function x(y) {
                y.API.autoTable = function() {
                  for (var v = [], k = 0; k < arguments.length; k++)
                    v[k] = arguments[k];
                  var C;
                  v.length === 1 ? C = v[0] : (console.error("Use of deprecated autoTable initiation"), C = v[2] || {}, C.columns = v[0], C.body = v[1]);
                  var E = (0, f.parseInput)(this, C), q = (0, b.createTable)(this, E);
                  return (0, m.drawTable)(this, q), this;
                }, y.API.lastAutoTable = !1, y.API.previousAutoTable = !1, y.API.autoTable.previous = !1, y.API.autoTableText = function(v, k, C, E) {
                  (0, d.default)(v, k, C, E, this);
                }, y.API.autoTableSetDefaults = function(v) {
                  return p.DocHandler.setDefaults(v, this), this;
                }, y.autoTableSetDefaults = function(v, k) {
                  p.DocHandler.setDefaults(v, k);
                }, y.API.autoTableHtmlToJson = function(v, k) {
                  var C;
                  if (k === void 0 && (k = !1), typeof window > "u")
                    return console.error("Cannot run autoTableHtmlToJson in non browser environment"), null;
                  var E = new p.DocHandler(this), q = (0, u.parseHtml)(E, v, window, k, !1), T = q.head, F = q.body, M = ((C = T[0]) === null || C === void 0 ? void 0 : C.map(function(B) {
                    return B.content;
                  })) || [];
                  return { columns: M, rows: F, data: F };
                }, y.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var v = this.lastAutoTable;
                  return v && v.finalY ? v.finalY : 0;
                }, y.API.autoTableAddPageContent = function(v) {
                  return console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead."), y.API.autoTable.globalDefaults || (y.API.autoTable.globalDefaults = {}), y.API.autoTable.globalDefaults.addPageContent = v, this;
                }, y.API.autoTableAddPage = function() {
                  return console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()"), this.addPage(), this;
                };
              }
              l.default = x;
            }
          ),
          /***/
          136: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(u, d, p, f, m) {
                f = f || {};
                var b = 1.15, x = m.internal.scaleFactor, y = m.internal.getFontSize() / x, v = m.getLineHeightFactor ? m.getLineHeightFactor() : b, k = y * v, C = /\r\n|\r|\n/g, E = "", q = 1;
                if ((f.valign === "middle" || f.valign === "bottom" || f.halign === "center" || f.halign === "right") && (E = typeof u == "string" ? u.split(C) : u, q = E.length || 1), p += y * (2 - b), f.valign === "middle" ? p -= q / 2 * k : f.valign === "bottom" && (p -= q * k), f.halign === "center" || f.halign === "right") {
                  var T = y;
                  if (f.halign === "center" && (T *= 0.5), E && q >= 1) {
                    for (var F = 0; F < E.length; F++)
                      m.text(E[F], d - m.getStringUnitWidth(E[F]) * T, p), p += k;
                    return m;
                  }
                  d -= m.getStringUnitWidth(u) * T;
                }
                return f.halign === "justify" ? m.text(u, d, p, {
                  maxWidth: f.maxWidth || 100,
                  align: "justify"
                }) : m.text(u, d, p), m;
              }
              l.default = h;
            }
          ),
          /***/
          420: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getPageAvailableWidth = l.parseSpacing = l.getFillStyle = l.addTableBorder = l.getStringWidth = void 0;
              function h(m, b, x) {
                x.applyStyles(b, !0);
                var y = Array.isArray(m) ? m : [m], v = y.map(function(k) {
                  return x.getTextWidth(k);
                }).reduce(function(k, C) {
                  return Math.max(k, C);
                }, 0);
                return v;
              }
              l.getStringWidth = h;
              function u(m, b, x, y) {
                var v = b.settings.tableLineWidth, k = b.settings.tableLineColor;
                m.applyStyles({ lineWidth: v, lineColor: k });
                var C = d(v, !1);
                C && m.rect(x.x, x.y, b.getWidth(m.pageSize().width), y.y - x.y, C);
              }
              l.addTableBorder = u;
              function d(m, b) {
                var x = m > 0, y = b || b === 0;
                return x && y ? "DF" : x ? "S" : y ? "F" : null;
              }
              l.getFillStyle = d;
              function p(m, b) {
                var x, y, v, k;
                if (m = m || b, Array.isArray(m)) {
                  if (m.length >= 4)
                    return {
                      top: m[0],
                      right: m[1],
                      bottom: m[2],
                      left: m[3]
                    };
                  if (m.length === 3)
                    return {
                      top: m[0],
                      right: m[1],
                      bottom: m[2],
                      left: m[1]
                    };
                  if (m.length === 2)
                    return {
                      top: m[0],
                      right: m[1],
                      bottom: m[0],
                      left: m[1]
                    };
                  m.length === 1 ? m = m[0] : m = b;
                }
                return typeof m == "object" ? (typeof m.vertical == "number" && (m.top = m.vertical, m.bottom = m.vertical), typeof m.horizontal == "number" && (m.right = m.horizontal, m.left = m.horizontal), {
                  left: (x = m.left) !== null && x !== void 0 ? x : b,
                  top: (y = m.top) !== null && y !== void 0 ? y : b,
                  right: (v = m.right) !== null && v !== void 0 ? v : b,
                  bottom: (k = m.bottom) !== null && k !== void 0 ? k : b
                }) : (typeof m != "number" && (m = b), { top: m, right: m, bottom: m, left: m });
              }
              l.parseSpacing = p;
              function f(m, b) {
                var x = p(b.settings.margin, 0);
                return m.pageSize().width - (x.left + x.right);
              }
              l.getPageAvailableWidth = f;
            }
          ),
          /***/
          796: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var f = function(m, b) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(x, y) {
                    x.__proto__ = y;
                  } || function(x, y) {
                    for (var v in y) Object.prototype.hasOwnProperty.call(y, v) && (x[v] = y[v]);
                  }, f(m, b);
                };
                return function(m, b) {
                  if (typeof b != "function" && b !== null)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                  f(m, b);
                  function x() {
                    this.constructor = m;
                  }
                  m.prototype = b === null ? Object.create(b) : (x.prototype = b.prototype, new x());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getTheme = l.defaultStyles = l.HtmlRowInput = void 0;
              var u = (
                /** @class */
                function(f) {
                  h(m, f);
                  function m(b) {
                    var x = f.call(this) || this;
                    return x._element = b, x;
                  }
                  return m;
                }(Array)
              );
              l.HtmlRowInput = u;
              function d(f) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: !1,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / f,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              l.defaultStyles = d;
              function p(f) {
                var m = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return m[f];
              }
              l.getTheme = p;
            }
          ),
          /***/
          903: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseCss = void 0;
              var u = h(420);
              function d(x, y, v, k, C) {
                var E = {}, q = 1.3333333333333333, T = f(y, function(G) {
                  return C.getComputedStyle(G).backgroundColor;
                });
                T != null && (E.fillColor = T);
                var F = f(y, function(G) {
                  return C.getComputedStyle(G).color;
                });
                F != null && (E.textColor = F);
                var M = b(k, v);
                M && (E.cellPadding = M);
                var B = "borderTopColor", P = q * v, A = k.borderTopWidth;
                if (k.borderBottomWidth === A && k.borderRightWidth === A && k.borderLeftWidth === A) {
                  var I = (parseFloat(A) || 0) / P;
                  I && (E.lineWidth = I);
                } else
                  E.lineWidth = {
                    top: (parseFloat(k.borderTopWidth) || 0) / P,
                    right: (parseFloat(k.borderRightWidth) || 0) / P,
                    bottom: (parseFloat(k.borderBottomWidth) || 0) / P,
                    left: (parseFloat(k.borderLeftWidth) || 0) / P
                  }, E.lineWidth.top || (E.lineWidth.right ? B = "borderRightColor" : E.lineWidth.bottom ? B = "borderBottomColor" : E.lineWidth.left && (B = "borderLeftColor"));
                var S = f(y, function(G) {
                  return C.getComputedStyle(G)[B];
                });
                S != null && (E.lineColor = S);
                var X = ["left", "right", "center", "justify"];
                X.indexOf(k.textAlign) !== -1 && (E.halign = k.textAlign), X = ["middle", "bottom", "top"], X.indexOf(k.verticalAlign) !== -1 && (E.valign = k.verticalAlign);
                var H = parseInt(k.fontSize || "");
                isNaN(H) || (E.fontSize = H / q);
                var j = p(k);
                j && (E.fontStyle = j);
                var Q = (k.fontFamily || "").toLowerCase();
                return x.indexOf(Q) !== -1 && (E.font = Q), E;
              }
              l.parseCss = d;
              function p(x) {
                var y = "";
                return (x.fontWeight === "bold" || x.fontWeight === "bolder" || parseInt(x.fontWeight) >= 700) && (y = "bold"), (x.fontStyle === "italic" || x.fontStyle === "oblique") && (y += "italic"), y;
              }
              function f(x, y) {
                var v = m(x, y);
                if (!v)
                  return null;
                var k = v.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!k || !Array.isArray(k))
                  return null;
                var C = [
                  parseInt(k[1]),
                  parseInt(k[2]),
                  parseInt(k[3])
                ], E = parseInt(k[4]);
                return E === 0 || isNaN(C[0]) || isNaN(C[1]) || isNaN(C[2]) ? null : C;
              }
              function m(x, y) {
                var v = y(x);
                return v === "rgba(0, 0, 0, 0)" || v === "transparent" || v === "initial" || v === "inherit" ? x.parentElement == null ? null : m(x.parentElement, y) : v;
              }
              function b(x, y) {
                var v = [
                  x.paddingTop,
                  x.paddingRight,
                  x.paddingBottom,
                  x.paddingLeft
                ], k = 96 / (72 / y), C = (parseInt(x.lineHeight) - parseInt(x.fontSize)) / y / 2, E = v.map(function(T) {
                  return parseInt(T || "0") / k;
                }), q = (0, u.parseSpacing)(E, 0);
                return C > q.top && (q.top = C), C > q.bottom && (q.bottom = C), q;
              }
            }
          ),
          /***/
          744: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.DocHandler = void 0;
              var h = {}, u = (
                /** @class */
                function() {
                  function d(p) {
                    this.jsPDFDocument = p, this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: p.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: p.internal.getFontSize(),
                      fontStyle: p.internal.getFont().fontStyle,
                      font: p.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: p.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: p.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  return d.setDefaults = function(p, f) {
                    f === void 0 && (f = null), f ? f.__autoTableDocumentDefaults = p : h = p;
                  }, d.unifyColor = function(p) {
                    return Array.isArray(p) ? p : typeof p == "number" ? [p, p, p] : typeof p == "string" ? [p] : null;
                  }, d.prototype.applyStyles = function(p, f) {
                    var m, b, x;
                    f === void 0 && (f = !1), p.fontStyle && this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(p.fontStyle);
                    var y = this.jsPDFDocument.internal.getFont(), v = y.fontStyle, k = y.fontName;
                    if (p.font && (k = p.font), p.fontStyle) {
                      v = p.fontStyle;
                      var C = this.getFontList()[k];
                      C && C.indexOf(v) === -1 && (this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(C[0]), v = C[0]);
                    }
                    if (this.jsPDFDocument.setFont(k, v), p.fontSize && this.jsPDFDocument.setFontSize(p.fontSize), !f) {
                      var E = d.unifyColor(p.fillColor);
                      E && (m = this.jsPDFDocument).setFillColor.apply(m, E), E = d.unifyColor(p.textColor), E && (b = this.jsPDFDocument).setTextColor.apply(b, E), E = d.unifyColor(p.lineColor), E && (x = this.jsPDFDocument).setDrawColor.apply(x, E), typeof p.lineWidth == "number" && this.jsPDFDocument.setLineWidth(p.lineWidth);
                    }
                  }, d.prototype.splitTextToSize = function(p, f, m) {
                    return this.jsPDFDocument.splitTextToSize(p, f, m);
                  }, d.prototype.rect = function(p, f, m, b, x) {
                    return this.jsPDFDocument.rect(p, f, m, b, x);
                  }, d.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  }, d.prototype.getTextWidth = function(p) {
                    return this.jsPDFDocument.getTextWidth(p);
                  }, d.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  }, d.prototype.setPage = function(p) {
                    this.jsPDFDocument.setPage(p);
                  }, d.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  }, d.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  }, d.prototype.getGlobalOptions = function() {
                    return h || {};
                  }, d.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  }, d.prototype.pageSize = function() {
                    var p = this.jsPDFDocument.internal.pageSize;
                    return p.width == null && (p = {
                      width: p.getWidth(),
                      height: p.getHeight()
                    }), p;
                  }, d.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  }, d.prototype.getLineHeightFactor = function() {
                    var p = this.jsPDFDocument;
                    return p.getLineHeightFactor ? p.getLineHeightFactor() : 1.15;
                  }, d.prototype.getLineHeight = function(p) {
                    return p / this.scaleFactor() * this.getLineHeightFactor();
                  }, d.prototype.pageNumber = function() {
                    var p = this.jsPDFDocument.internal.getCurrentPageInfo();
                    return p ? p.pageNumber : this.jsPDFDocument.internal.getNumberOfPages();
                  }, d;
                }()
              );
              l.DocHandler = u;
            }
          ),
          /***/
          4: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseHtml = void 0;
              var u = h(903), d = h(796);
              function p(b, x, y, v, k) {
                var C, E;
                v === void 0 && (v = !1), k === void 0 && (k = !1);
                var q;
                typeof x == "string" ? q = y.document.querySelector(x) : q = x;
                var T = Object.keys(b.getFontList()), F = b.scaleFactor(), M = [], B = [], P = [];
                if (!q)
                  return console.error("Html table could not be found with input: ", x), { head: M, body: B, foot: P };
                for (var A = 0; A < q.rows.length; A++) {
                  var I = q.rows[A], S = (E = (C = I == null ? void 0 : I.parentElement) === null || C === void 0 ? void 0 : C.tagName) === null || E === void 0 ? void 0 : E.toLowerCase(), X = f(T, F, y, I, v, k);
                  X && (S === "thead" ? M.push(X) : S === "tfoot" ? P.push(X) : B.push(X));
                }
                return { head: M, body: B, foot: P };
              }
              l.parseHtml = p;
              function f(b, x, y, v, k, C) {
                for (var E = new d.HtmlRowInput(v), q = 0; q < v.cells.length; q++) {
                  var T = v.cells[q], F = y.getComputedStyle(T);
                  if (k || F.display !== "none") {
                    var M = void 0;
                    C && (M = (0, u.parseCss)(b, T, x, F, y)), E.push({
                      rowSpan: T.rowSpan,
                      colSpan: T.colSpan,
                      styles: M,
                      _element: T,
                      content: m(T)
                    });
                  }
                }
                var B = y.getComputedStyle(v);
                if (E.length > 0 && (k || B.display !== "none"))
                  return E;
              }
              function m(b) {
                var x = b.cloneNode(!0);
                return x.innerHTML = x.innerHTML.replace(/\n/g, "").replace(/ +/g, " "), x.innerHTML = x.innerHTML.split(/<br.*?>/).map(function(y) {
                  return y.trim();
                }).join(`
`), x.innerText || x.textContent || "";
              }
            }
          ),
          /***/
          776: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseInput = void 0;
              var u = h(4), d = h(356), p = h(420), f = h(744), m = h(792);
              function b(q, T) {
                var F = new f.DocHandler(q), M = F.getDocumentOptions(), B = F.getGlobalOptions();
                (0, m.default)(F, B, M, T);
                var P = (0, d.assign)({}, B, M, T), A;
                typeof window < "u" && (A = window);
                var I = x(B, M, T), S = y(B, M, T), X = v(F, P), H = C(F, P, A);
                return {
                  id: T.tableId,
                  content: H,
                  hooks: S,
                  styles: I,
                  settings: X
                };
              }
              l.parseInput = b;
              function x(q, T, F) {
                for (var M = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                }, B = function(S) {
                  if (S === "columnStyles") {
                    var X = q[S], H = T[S], j = F[S];
                    M.columnStyles = (0, d.assign)({}, X, H, j);
                  } else {
                    var Q = [q, T, F], G = Q.map(function(ft) {
                      return ft[S] || {};
                    });
                    M[S] = (0, d.assign)({}, G[0], G[1], G[2]);
                  }
                }, P = 0, A = Object.keys(M); P < A.length; P++) {
                  var I = A[P];
                  B(I);
                }
                return M;
              }
              function y(q, T, F) {
                for (var M = [q, T, F], B = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                }, P = 0, A = M; P < A.length; P++) {
                  var I = A[P];
                  I.didParseCell && B.didParseCell.push(I.didParseCell), I.willDrawCell && B.willDrawCell.push(I.willDrawCell), I.didDrawCell && B.didDrawCell.push(I.didDrawCell), I.willDrawPage && B.willDrawPage.push(I.willDrawPage), I.didDrawPage && B.didDrawPage.push(I.didDrawPage);
                }
                return B;
              }
              function v(q, T) {
                var F, M, B, P, A, I, S, X, H, j, Q, G, ft = (0, p.parseSpacing)(T.margin, 40 / q.scaleFactor()), nt = (F = k(q, T.startY)) !== null && F !== void 0 ? F : ft.top, N;
                T.showFoot === !0 ? N = "everyPage" : T.showFoot === !1 ? N = "never" : N = (M = T.showFoot) !== null && M !== void 0 ? M : "everyPage";
                var z;
                T.showHead === !0 ? z = "everyPage" : T.showHead === !1 ? z = "never" : z = (B = T.showHead) !== null && B !== void 0 ? B : "everyPage";
                var V = (P = T.useCss) !== null && P !== void 0 ? P : !1, Y = T.theme || (V ? "plain" : "striped"), ot = !!T.horizontalPageBreak, wt = (A = T.horizontalPageBreakRepeat) !== null && A !== void 0 ? A : null;
                return {
                  includeHiddenHtml: (I = T.includeHiddenHtml) !== null && I !== void 0 ? I : !1,
                  useCss: V,
                  theme: Y,
                  startY: nt,
                  margin: ft,
                  pageBreak: (S = T.pageBreak) !== null && S !== void 0 ? S : "auto",
                  rowPageBreak: (X = T.rowPageBreak) !== null && X !== void 0 ? X : "auto",
                  tableWidth: (H = T.tableWidth) !== null && H !== void 0 ? H : "auto",
                  showHead: z,
                  showFoot: N,
                  tableLineWidth: (j = T.tableLineWidth) !== null && j !== void 0 ? j : 0,
                  tableLineColor: (Q = T.tableLineColor) !== null && Q !== void 0 ? Q : 200,
                  horizontalPageBreak: ot,
                  horizontalPageBreakRepeat: wt,
                  horizontalPageBreakBehaviour: (G = T.horizontalPageBreakBehaviour) !== null && G !== void 0 ? G : "afterAllRows"
                };
              }
              function k(q, T) {
                var F = q.getLastAutoTable(), M = q.scaleFactor(), B = q.pageNumber(), P = !1;
                if (F && F.startPageNumber) {
                  var A = F.startPageNumber + F.pageNumber - 1;
                  P = A === B;
                }
                return typeof T == "number" ? T : (T == null || T === !1) && P && (F == null ? void 0 : F.finalY) != null ? F.finalY + 20 / M : null;
              }
              function C(q, T, F) {
                var M = T.head || [], B = T.body || [], P = T.foot || [];
                if (T.html) {
                  var A = T.includeHiddenHtml;
                  if (F) {
                    var I = (0, u.parseHtml)(q, T.html, F, A, T.useCss) || {};
                    M = I.head || M, B = I.body || M, P = I.foot || M;
                  } else
                    console.error("Cannot parse html in non browser environment");
                }
                var S = T.columns || E(M, B, P);
                return {
                  columns: S,
                  head: M,
                  body: B,
                  foot: P
                };
              }
              function E(q, T, F) {
                var M = q[0] || T[0] || F[0] || [], B = [];
                return Object.keys(M).filter(function(P) {
                  return P !== "_element";
                }).forEach(function(P) {
                  var A = 1, I;
                  Array.isArray(M) ? I = M[parseInt(P)] : I = M[P], typeof I == "object" && !Array.isArray(I) && (A = (I == null ? void 0 : I.colSpan) || 1);
                  for (var S = 0; S < A; S++) {
                    var X = void 0;
                    Array.isArray(M) ? X = B.length : X = P + (S > 0 ? "_".concat(S) : "");
                    var H = { dataKey: X };
                    B.push(H);
                  }
                }), B;
              }
            }
          ),
          /***/
          792: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(d, p, f, m) {
                for (var b = function(k) {
                  k && typeof k != "object" && console.error("The options parameter should be of type object, is: " + typeof k), typeof k.extendWidth < "u" && (k.tableWidth = k.extendWidth ? "auto" : "wrap", console.error("Use of deprecated option: extendWidth, use tableWidth instead.")), typeof k.margins < "u" && (typeof k.margin > "u" && (k.margin = k.margins), console.error("Use of deprecated option: margins, use margin instead.")), k.startY && typeof k.startY != "number" && (console.error("Invalid value for startY option", k.startY), delete k.startY), !k.didDrawPage && (k.afterPageContent || k.beforePageContent || k.afterPageAdd) && (console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead"), k.didDrawPage = function(P) {
                    d.applyStyles(d.userStyles), k.beforePageContent && k.beforePageContent(P), d.applyStyles(d.userStyles), k.afterPageContent && k.afterPageContent(P), d.applyStyles(d.userStyles), k.afterPageAdd && P.pageNumber > 1 && P.afterPageAdd(P), d.applyStyles(d.userStyles);
                  }), [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(P) {
                    k[P] && console.error('The "'.concat(P, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                  }), [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(P) {
                    var A = P[0], I = P[1];
                    k[I] && (console.error("Use of deprecated option ".concat(I, ". Use ").concat(A, " instead")), k[A] = k[I]);
                  }), [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(P) {
                    var A = typeof P == "string" ? P : P[0], I = typeof P == "string" ? P : P[1];
                    typeof k[A] < "u" && (typeof k.styles[I] > "u" && (k.styles[I] = k[A]), console.error("Use of deprecated option: " + A + ", use the style " + I + " instead."));
                  });
                  for (var C = 0, E = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; C < E.length; C++) {
                    var q = E[C];
                    u(k[q] || {});
                  }
                  for (var T = k.columnStyles || {}, F = 0, M = Object.keys(T); F < M.length; F++) {
                    var B = M[F];
                    u(T[B] || {});
                  }
                }, x = 0, y = [p, f, m]; x < y.length; x++) {
                  var v = y[x];
                  b(v);
                }
              }
              l.default = h;
              function u(d) {
                d.rowHeight ? (console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight."), d.minCellHeight || (d.minCellHeight = d.rowHeight)) : d.columnWidth && (console.error("Use of deprecated style columnWidth. It is renamed to cellWidth."), d.cellWidth || (d.cellWidth = d.columnWidth));
              }
            }
          ),
          /***/
          260: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.Column = l.Cell = l.Row = l.Table = void 0;
              var u = h(796), d = h(172), p = h(420), f = (
                /** @class */
                function() {
                  function y(v, k) {
                    this.pageNumber = 1, this.pageCount = 1, this.id = v.id, this.settings = v.settings, this.styles = v.styles, this.hooks = v.hooks, this.columns = k.columns, this.head = k.head, this.body = k.body, this.foot = k.foot;
                  }
                  return y.prototype.getHeadHeight = function(v) {
                    return this.head.reduce(function(k, C) {
                      return k + C.getMaxCellHeight(v);
                    }, 0);
                  }, y.prototype.getFootHeight = function(v) {
                    return this.foot.reduce(function(k, C) {
                      return k + C.getMaxCellHeight(v);
                    }, 0);
                  }, y.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  }, y.prototype.callCellHooks = function(v, k, C, E, q, T) {
                    for (var F = 0, M = k; F < M.length; F++) {
                      var B = M[F], P = new d.CellHookData(v, this, C, E, q, T), A = B(P) === !1;
                      if (C.text = Array.isArray(C.text) ? C.text : [C.text], A)
                        return !1;
                    }
                    return !0;
                  }, y.prototype.callEndPageHooks = function(v, k) {
                    v.applyStyles(v.userStyles);
                    for (var C = 0, E = this.hooks.didDrawPage; C < E.length; C++) {
                      var q = E[C];
                      q(new d.HookData(v, this, k));
                    }
                  }, y.prototype.callWillDrawPageHooks = function(v, k) {
                    for (var C = 0, E = this.hooks.willDrawPage; C < E.length; C++) {
                      var q = E[C];
                      q(new d.HookData(v, this, k));
                    }
                  }, y.prototype.getWidth = function(v) {
                    if (typeof this.settings.tableWidth == "number")
                      return this.settings.tableWidth;
                    if (this.settings.tableWidth === "wrap") {
                      var k = this.columns.reduce(function(E, q) {
                        return E + q.wrappedWidth;
                      }, 0);
                      return k;
                    } else {
                      var C = this.settings.margin;
                      return v - C.left - C.right;
                    }
                  }, y;
                }()
              );
              l.Table = f;
              var m = (
                /** @class */
                function() {
                  function y(v, k, C, E, q) {
                    q === void 0 && (q = !1), this.height = 0, this.raw = v, v instanceof u.HtmlRowInput && (this.raw = v._element, this.element = v._element), this.index = k, this.section = C, this.cells = E, this.spansMultiplePages = q;
                  }
                  return y.prototype.getMaxCellHeight = function(v) {
                    var k = this;
                    return v.reduce(function(C, E) {
                      var q;
                      return Math.max(C, ((q = k.cells[E.index]) === null || q === void 0 ? void 0 : q.height) || 0);
                    }, 0);
                  }, y.prototype.hasRowSpan = function(v) {
                    var k = this;
                    return v.filter(function(C) {
                      var E = k.cells[C.index];
                      return E ? E.rowSpan > 1 : !1;
                    }).length > 0;
                  }, y.prototype.canEntireRowFit = function(v, k) {
                    return this.getMaxCellHeight(k) <= v;
                  }, y.prototype.getMinimumRowHeight = function(v, k) {
                    var C = this;
                    return v.reduce(function(E, q) {
                      var T = C.cells[q.index];
                      if (!T)
                        return 0;
                      var F = k.getLineHeight(T.styles.fontSize), M = T.padding("vertical"), B = M + F;
                      return B > E ? B : E;
                    }, 0);
                  }, y;
                }()
              );
              l.Row = m;
              var b = (
                /** @class */
                function() {
                  function y(v, k, C) {
                    var E, q;
                    this.contentHeight = 0, this.contentWidth = 0, this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.height = 0, this.x = 0, this.y = 0, this.styles = k, this.section = C, this.raw = v;
                    var T = v;
                    v != null && typeof v == "object" && !Array.isArray(v) ? (this.rowSpan = v.rowSpan || 1, this.colSpan = v.colSpan || 1, T = (q = (E = v.content) !== null && E !== void 0 ? E : v.title) !== null && q !== void 0 ? q : v, v._element && (this.raw = v._element)) : (this.rowSpan = 1, this.colSpan = 1);
                    var F = T != null ? "" + T : "", M = /\r\n|\r|\n/g;
                    this.text = F.split(M);
                  }
                  return y.prototype.getTextPos = function() {
                    var v;
                    if (this.styles.valign === "top")
                      v = this.y + this.padding("top");
                    else if (this.styles.valign === "bottom")
                      v = this.y + this.height - this.padding("bottom");
                    else {
                      var k = this.height - this.padding("vertical");
                      v = this.y + k / 2 + this.padding("top");
                    }
                    var C;
                    if (this.styles.halign === "right")
                      C = this.x + this.width - this.padding("right");
                    else if (this.styles.halign === "center") {
                      var E = this.width - this.padding("horizontal");
                      C = this.x + E / 2 + this.padding("left");
                    } else
                      C = this.x + this.padding("left");
                    return { x: C, y: v };
                  }, y.prototype.getContentHeight = function(v, k) {
                    k === void 0 && (k = 1.15);
                    var C = Array.isArray(this.text) ? this.text.length : 1, E = this.styles.fontSize / v * k, q = C * E + this.padding("vertical");
                    return Math.max(q, this.styles.minCellHeight);
                  }, y.prototype.padding = function(v) {
                    var k = (0, p.parseSpacing)(this.styles.cellPadding, 0);
                    return v === "vertical" ? k.top + k.bottom : v === "horizontal" ? k.left + k.right : k[v];
                  }, y;
                }()
              );
              l.Cell = b;
              var x = (
                /** @class */
                function() {
                  function y(v, k, C) {
                    this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.dataKey = v, this.raw = k, this.index = C;
                  }
                  return y.prototype.getMaxCustomCellWidth = function(v) {
                    for (var k = 0, C = 0, E = v.allRows(); C < E.length; C++) {
                      var q = E[C], T = q.cells[this.index];
                      T && typeof T.styles.cellWidth == "number" && (k = Math.max(k, T.styles.cellWidth));
                    }
                    return k;
                  }, y;
                }()
              );
              l.Column = x;
            }
          ),
          /***/
          356: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.assign = void 0;
              function h(u, d, p, f, m) {
                if (u == null)
                  throw new TypeError("Cannot convert undefined or null to object");
                for (var b = Object(u), x = 1; x < arguments.length; x++) {
                  var y = arguments[x];
                  if (y != null)
                    for (var v in y)
                      Object.prototype.hasOwnProperty.call(y, v) && (b[v] = y[v]);
                }
                return b;
              }
              l.assign = h;
            }
          ),
          /***/
          972: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.createTable = void 0;
              var u = h(744), d = h(260), p = h(324), f = h(796), m = h(356);
              function b(q, T) {
                var F = new u.DocHandler(q), M = x(T, F.scaleFactor()), B = new d.Table(T, M);
                return (0, p.calculateWidths)(F, B), F.applyStyles(F.userStyles), B;
              }
              l.createTable = b;
              function x(q, T) {
                var F = q.content, M = C(F.columns);
                if (F.head.length === 0) {
                  var B = v(M, "head");
                  B && F.head.push(B);
                }
                if (F.foot.length === 0) {
                  var B = v(M, "foot");
                  B && F.foot.push(B);
                }
                var P = q.settings.theme, A = q.styles;
                return {
                  columns: M,
                  head: y("head", F.head, M, A, P, T),
                  body: y("body", F.body, M, A, P, T),
                  foot: y("foot", F.foot, M, A, P, T)
                };
              }
              function y(q, T, F, M, B, P) {
                var A = {}, I = T.map(function(S, X) {
                  for (var H = 0, j = {}, Q = 0, G = 0, ft = 0, nt = F; ft < nt.length; ft++) {
                    var N = nt[ft];
                    if (A[N.index] == null || A[N.index].left === 0)
                      if (G === 0) {
                        var z = void 0;
                        Array.isArray(S) ? z = S[N.index - Q - H] : z = S[N.dataKey];
                        var V = {};
                        typeof z == "object" && !Array.isArray(z) && (V = (z == null ? void 0 : z.styles) || {});
                        var Y = E(q, N, X, B, M, P, V), ot = new d.Cell(z, Y, q);
                        j[N.dataKey] = ot, j[N.index] = ot, G = ot.colSpan - 1, A[N.index] = {
                          left: ot.rowSpan - 1,
                          times: G
                        };
                      } else
                        G--, Q++;
                    else
                      A[N.index].left--, G = A[N.index].times, H++;
                  }
                  return new d.Row(S, X, q, j);
                });
                return I;
              }
              function v(q, T) {
                var F = {};
                return q.forEach(function(M) {
                  if (M.raw != null) {
                    var B = k(T, M.raw);
                    B != null && (F[M.dataKey] = B);
                  }
                }), Object.keys(F).length > 0 ? F : null;
              }
              function k(q, T) {
                if (q === "head") {
                  if (typeof T == "object")
                    return T.header || T.title || null;
                  if (typeof T == "string" || typeof T == "number")
                    return T;
                } else if (q === "foot" && typeof T == "object")
                  return T.footer;
                return null;
              }
              function C(q) {
                return q.map(function(T, F) {
                  var M, B, P;
                  return typeof T == "object" ? P = (B = (M = T.dataKey) !== null && M !== void 0 ? M : T.key) !== null && B !== void 0 ? B : F : P = F, new d.Column(P, T, F);
                });
              }
              function E(q, T, F, M, B, P, A) {
                var I = (0, f.getTheme)(M), S;
                q === "head" ? S = B.headStyles : q === "body" ? S = B.bodyStyles : q === "foot" && (S = B.footStyles);
                var X = (0, m.assign)({}, I.table, I[q], B.styles, S), H = B.columnStyles[T.dataKey] || B.columnStyles[T.index] || {}, j = q === "body" ? H : {}, Q = q === "body" && F % 2 === 0 ? (0, m.assign)({}, I.alternateRow, B.alternateRowStyles) : {}, G = (0, f.defaultStyles)(P), ft = (0, m.assign)({}, G, X, Q, j);
                return (0, m.assign)(ft, A);
              }
            }
          ),
          /***/
          664: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.addPage = l.drawTable = void 0;
              var u = h(420), d = h(260), p = h(744), f = h(356), m = h(136), b = h(224);
              function x(H, j) {
                var Q = j.settings, G = Q.startY, ft = Q.margin, nt = {
                  x: ft.left,
                  y: G
                }, N = j.getHeadHeight(j.columns) + j.getFootHeight(j.columns), z = G + ft.bottom + N;
                if (Q.pageBreak === "avoid") {
                  var V = j.body, Y = V.reduce(function(mt, xt) {
                    return mt + xt.height;
                  }, 0);
                  z += Y;
                }
                var ot = new p.DocHandler(H);
                (Q.pageBreak === "always" || Q.startY != null && z > ot.pageSize().height) && (X(ot), nt.y = ft.top), j.callWillDrawPageHooks(ot, nt);
                var wt = (0, f.assign)({}, nt);
                j.startPageNumber = ot.pageNumber(), Q.horizontalPageBreak ? y(ot, j, wt, nt) : (ot.applyStyles(ot.userStyles), (Q.showHead === "firstPage" || Q.showHead === "everyPage") && j.head.forEach(function(mt) {
                  return B(ot, j, mt, nt, j.columns);
                }), ot.applyStyles(ot.userStyles), j.body.forEach(function(mt, xt) {
                  var zt = xt === j.body.length - 1;
                  M(ot, j, mt, zt, wt, nt, j.columns);
                }), ot.applyStyles(ot.userStyles), (Q.showFoot === "lastPage" || Q.showFoot === "everyPage") && j.foot.forEach(function(mt) {
                  return B(ot, j, mt, nt, j.columns);
                })), (0, u.addTableBorder)(ot, j, wt, nt), j.callEndPageHooks(ot, nt), j.finalY = nt.y, H.lastAutoTable = j, H.previousAutoTable = j, H.autoTable && (H.autoTable.previous = j), ot.applyStyles(ot.userStyles);
              }
              l.drawTable = x;
              function y(H, j, Q, G) {
                var ft = (0, b.calculateAllColumnsCanFitInPage)(H, j), nt = j.settings;
                if (nt.horizontalPageBreakBehaviour === "afterAllRows")
                  ft.forEach(function(Y, ot) {
                    H.applyStyles(H.userStyles), ot > 0 ? S(H, j, Q, G, Y.columns, !0) : v(H, j, G, Y.columns), k(H, j, Q, G, Y.columns), E(H, j, G, Y.columns);
                  });
                else
                  for (var N = -1, z = ft[0], V = function() {
                    var Y = N;
                    if (z) {
                      H.applyStyles(H.userStyles);
                      var ot = z.columns;
                      N >= 0 ? S(H, j, Q, G, ot, !0) : v(H, j, G, ot), Y = C(H, j, N + 1, G, ot), E(H, j, G, ot);
                    }
                    var wt = Y - N;
                    ft.slice(1).forEach(function(mt) {
                      H.applyStyles(H.userStyles), S(H, j, Q, G, mt.columns, !0), C(H, j, N + 1, G, mt.columns, wt), E(H, j, G, mt.columns);
                    }), N = Y;
                  }; N < j.body.length - 1; )
                    V();
              }
              function v(H, j, Q, G) {
                var ft = j.settings;
                H.applyStyles(H.userStyles), (ft.showHead === "firstPage" || ft.showHead === "everyPage") && j.head.forEach(function(nt) {
                  return B(H, j, nt, Q, G);
                });
              }
              function k(H, j, Q, G, ft) {
                H.applyStyles(H.userStyles), j.body.forEach(function(nt, N) {
                  var z = N === j.body.length - 1;
                  M(H, j, nt, z, Q, G, ft);
                });
              }
              function C(H, j, Q, G, ft, nt) {
                H.applyStyles(H.userStyles), nt = nt ?? j.body.length;
                var N = Math.min(Q + nt, j.body.length), z = -1;
                return j.body.slice(Q, N).forEach(function(V, Y) {
                  var ot = Q + Y === j.body.length - 1, wt = I(H, j, ot, G);
                  V.canEntireRowFit(wt, ft) && (B(H, j, V, G, ft), z = Q + Y);
                }), z;
              }
              function E(H, j, Q, G) {
                var ft = j.settings;
                H.applyStyles(H.userStyles), (ft.showFoot === "lastPage" || ft.showFoot === "everyPage") && j.foot.forEach(function(nt) {
                  return B(H, j, nt, Q, G);
                });
              }
              function q(H, j, Q) {
                var G = Q.getLineHeight(H.styles.fontSize), ft = H.padding("vertical"), nt = Math.floor((j - ft) / G);
                return Math.max(0, nt);
              }
              function T(H, j, Q, G) {
                var ft = {};
                H.spansMultiplePages = !0, H.height = 0;
                for (var nt = 0, N = 0, z = Q.columns; N < z.length; N++) {
                  var V = z[N], Y = H.cells[V.index];
                  if (Y) {
                    Array.isArray(Y.text) || (Y.text = [Y.text]);
                    var ot = new d.Cell(Y.raw, Y.styles, Y.section);
                    ot = (0, f.assign)(ot, Y), ot.text = [];
                    var wt = q(Y, j, G);
                    Y.text.length > wt && (ot.text = Y.text.splice(wt, Y.text.length));
                    var mt = G.scaleFactor(), xt = G.getLineHeightFactor();
                    Y.contentHeight = Y.getContentHeight(mt, xt), Y.contentHeight >= j && (Y.contentHeight = j, ot.styles.minCellHeight -= j), Y.contentHeight > H.height && (H.height = Y.contentHeight), ot.contentHeight = ot.getContentHeight(mt, xt), ot.contentHeight > nt && (nt = ot.contentHeight), ft[V.index] = ot;
                  }
                }
                var zt = new d.Row(H.raw, -1, H.section, ft, !0);
                zt.height = nt;
                for (var Dt = 0, Jt = Q.columns; Dt < Jt.length; Dt++) {
                  var V = Jt[Dt], ot = zt.cells[V.index];
                  ot && (ot.height = zt.height);
                  var Y = H.cells[V.index];
                  Y && (Y.height = H.height);
                }
                return zt;
              }
              function F(H, j, Q, G) {
                var ft = H.pageSize().height, nt = G.settings.margin, N = nt.top + nt.bottom, z = ft - N;
                j.section === "body" && (z -= G.getHeadHeight(G.columns) + G.getFootHeight(G.columns));
                var V = j.getMinimumRowHeight(G.columns, H), Y = V < Q;
                if (V > z)
                  return console.error("Will not be able to print row ".concat(j.index, " correctly since it's minimum height is larger than page height")), !0;
                if (!Y)
                  return !1;
                var ot = j.hasRowSpan(G.columns), wt = j.getMaxCellHeight(G.columns) > z;
                return wt ? (ot && console.error("The content of row ".concat(j.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.")), !0) : !(ot || G.settings.rowPageBreak === "avoid");
              }
              function M(H, j, Q, G, ft, nt, N) {
                var z = I(H, j, G, nt);
                if (Q.canEntireRowFit(z, N))
                  B(H, j, Q, nt, N);
                else if (F(H, Q, z, j)) {
                  var V = T(Q, z, j, H);
                  B(H, j, Q, nt, N), S(H, j, ft, nt, N), M(H, j, V, G, ft, nt, N);
                } else
                  S(H, j, ft, nt, N), M(H, j, Q, G, ft, nt, N);
              }
              function B(H, j, Q, G, ft) {
                G.x = j.settings.margin.left;
                for (var nt = 0, N = ft; nt < N.length; nt++) {
                  var z = N[nt], V = Q.cells[z.index];
                  if (!V) {
                    G.x += z.width;
                    continue;
                  }
                  H.applyStyles(V.styles), V.x = G.x, V.y = G.y;
                  var Y = j.callCellHooks(H, j.hooks.willDrawCell, V, Q, z, G);
                  if (Y === !1) {
                    G.x += z.width;
                    continue;
                  }
                  P(H, V, G);
                  var ot = V.getTextPos();
                  (0, m.default)(V.text, ot.x, ot.y, {
                    halign: V.styles.halign,
                    valign: V.styles.valign,
                    maxWidth: Math.ceil(V.width - V.padding("left") - V.padding("right"))
                  }, H.getDocument()), j.callCellHooks(H, j.hooks.didDrawCell, V, Q, z, G), G.x += z.width;
                }
                G.y += Q.height;
              }
              function P(H, j, Q) {
                var G = j.styles;
                if (H.getDocument().setFillColor(H.getDocument().getFillColor()), typeof G.lineWidth == "number") {
                  var ft = (0, u.getFillStyle)(G.lineWidth, G.fillColor);
                  ft && H.rect(j.x, Q.y, j.width, j.height, ft);
                } else typeof G.lineWidth == "object" && (G.fillColor && H.rect(j.x, Q.y, j.width, j.height, "F"), A(H, j, Q, G.lineWidth));
              }
              function A(H, j, Q, G) {
                var ft, nt, N, z;
                G.top && (ft = Q.x, nt = Q.y, N = Q.x + j.width, z = Q.y, G.right && (N += 0.5 * G.right), G.left && (ft -= 0.5 * G.left), V(G.top, ft, nt, N, z)), G.bottom && (ft = Q.x, nt = Q.y + j.height, N = Q.x + j.width, z = Q.y + j.height, G.right && (N += 0.5 * G.right), G.left && (ft -= 0.5 * G.left), V(G.bottom, ft, nt, N, z)), G.left && (ft = Q.x, nt = Q.y, N = Q.x, z = Q.y + j.height, G.top && (nt -= 0.5 * G.top), G.bottom && (z += 0.5 * G.bottom), V(G.left, ft, nt, N, z)), G.right && (ft = Q.x + j.width, nt = Q.y, N = Q.x + j.width, z = Q.y + j.height, G.top && (nt -= 0.5 * G.top), G.bottom && (z += 0.5 * G.bottom), V(G.right, ft, nt, N, z));
                function V(Y, ot, wt, mt, xt) {
                  H.getDocument().setLineWidth(Y), H.getDocument().line(ot, wt, mt, xt, "S");
                }
              }
              function I(H, j, Q, G) {
                var ft = j.settings.margin.bottom, nt = j.settings.showFoot;
                return (nt === "everyPage" || nt === "lastPage" && Q) && (ft += j.getFootHeight(j.columns)), H.pageSize().height - G.y - ft;
              }
              function S(H, j, Q, G, ft, nt) {
                ft === void 0 && (ft = []), nt === void 0 && (nt = !1), H.applyStyles(H.userStyles), j.settings.showFoot === "everyPage" && !nt && j.foot.forEach(function(z) {
                  return B(H, j, z, G, ft);
                }), j.callEndPageHooks(H, G);
                var N = j.settings.margin;
                (0, u.addTableBorder)(H, j, Q, G), X(H), j.pageNumber++, j.pageCount++, G.x = N.left, G.y = N.top, Q.y = N.top, j.callWillDrawPageHooks(H, G), j.settings.showHead === "everyPage" && (j.head.forEach(function(z) {
                  return B(H, j, z, G, ft);
                }), H.applyStyles(H.userStyles));
              }
              l.addPage = S;
              function X(H) {
                var j = H.pageNumber();
                H.setPage(j + 1);
                var Q = H.pageNumber();
                return Q === j ? (H.addPage(), !0) : !1;
              }
            }
          ),
          /***/
          224: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.calculateAllColumnsCanFitInPage = void 0;
              var u = h(420);
              function d(f, m, b) {
                var x;
                b === void 0 && (b = {});
                var y = (0, u.getPageAvailableWidth)(f, m), v = /* @__PURE__ */ new Map(), k = [], C = [], E = [];
                m.settings.horizontalPageBreakRepeat, Array.isArray(m.settings.horizontalPageBreakRepeat) ? E = m.settings.horizontalPageBreakRepeat : (typeof m.settings.horizontalPageBreakRepeat == "string" || typeof m.settings.horizontalPageBreakRepeat == "number") && (E = [m.settings.horizontalPageBreakRepeat]), E.forEach(function(M) {
                  var B = m.columns.find(function(P) {
                    return P.dataKey === M || P.index === M;
                  });
                  B && !v.has(B.index) && (v.set(B.index, !0), k.push(B.index), C.push(m.columns[B.index]), y -= B.wrappedWidth);
                });
                for (var q = !0, T = (x = b == null ? void 0 : b.start) !== null && x !== void 0 ? x : 0; T < m.columns.length; ) {
                  if (v.has(T)) {
                    T++;
                    continue;
                  }
                  var F = m.columns[T].wrappedWidth;
                  if (q || y >= F)
                    q = !1, k.push(T), C.push(m.columns[T]), y -= F;
                  else
                    break;
                  T++;
                }
                return { colIndexes: k, columns: C, lastIndex: T - 1 };
              }
              function p(f, m) {
                for (var b = [], x = 0; x < m.columns.length; x++) {
                  var y = d(f, m, { start: x });
                  y.columns.length && (b.push(y), x = y.lastIndex);
                }
                return b;
              }
              l.calculateAllColumnsCanFitInPage = p;
            }
          ),
          /***/
          324: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.ellipsize = l.resizeColumns = l.calculateWidths = void 0;
              var u = h(420);
              function d(k, C) {
                p(k, C);
                var E = [], q = 0;
                C.columns.forEach(function(F) {
                  var M = F.getMaxCustomCellWidth(C);
                  M ? F.width = M : (F.width = F.wrappedWidth, E.push(F)), q += F.width;
                });
                var T = C.getWidth(k.pageSize().width) - q;
                T && (T = f(E, T, function(F) {
                  return Math.max(F.minReadableWidth, F.minWidth);
                })), T && (T = f(E, T, function(F) {
                  return F.minWidth;
                })), T = Math.abs(T), !C.settings.horizontalPageBreak && T > 0.1 / k.scaleFactor() && (T = T < 1 ? T : Math.round(T), console.warn("Of the table content, ".concat(T, " units width could not fit page"))), b(C), x(C, k), m(C);
              }
              l.calculateWidths = d;
              function p(k, C) {
                var E = k.scaleFactor(), q = C.settings.horizontalPageBreak, T = (0, u.getPageAvailableWidth)(k, C);
                C.allRows().forEach(function(F) {
                  for (var M = 0, B = C.columns; M < B.length; M++) {
                    var P = B[M], A = F.cells[P.index];
                    if (A) {
                      var I = C.hooks.didParseCell;
                      C.callCellHooks(k, I, A, F, P, null);
                      var S = A.padding("horizontal");
                      A.contentWidth = (0, u.getStringWidth)(A.text, A.styles, k) + S;
                      var X = (0, u.getStringWidth)(A.text.join(" ").split(/[^\S\u00A0]+/), A.styles, k);
                      if (A.minReadableWidth = X + A.padding("horizontal"), typeof A.styles.cellWidth == "number")
                        A.minWidth = A.styles.cellWidth, A.wrappedWidth = A.styles.cellWidth;
                      else if (A.styles.cellWidth === "wrap" || q === !0)
                        A.contentWidth > T ? (A.minWidth = T, A.wrappedWidth = T) : (A.minWidth = A.contentWidth, A.wrappedWidth = A.contentWidth);
                      else {
                        var H = 10 / E;
                        A.minWidth = A.styles.minCellWidth || H, A.wrappedWidth = A.contentWidth, A.minWidth > A.wrappedWidth && (A.wrappedWidth = A.minWidth);
                      }
                    }
                  }
                }), C.allRows().forEach(function(F) {
                  for (var M = 0, B = C.columns; M < B.length; M++) {
                    var P = B[M], A = F.cells[P.index];
                    if (A && A.colSpan === 1)
                      P.wrappedWidth = Math.max(P.wrappedWidth, A.wrappedWidth), P.minWidth = Math.max(P.minWidth, A.minWidth), P.minReadableWidth = Math.max(P.minReadableWidth, A.minReadableWidth);
                    else {
                      var I = C.styles.columnStyles[P.dataKey] || C.styles.columnStyles[P.index] || {}, S = I.cellWidth || I.minCellWidth;
                      S && typeof S == "number" && (P.minWidth = S, P.wrappedWidth = S);
                    }
                    A && (A.colSpan > 1 && !P.minWidth && (P.minWidth = A.minWidth), A.colSpan > 1 && !P.wrappedWidth && (P.wrappedWidth = A.minWidth));
                  }
                });
              }
              function f(k, C, E) {
                for (var q = C, T = k.reduce(function(H, j) {
                  return H + j.wrappedWidth;
                }, 0), F = 0; F < k.length; F++) {
                  var M = k[F], B = M.wrappedWidth / T, P = q * B, A = M.width + P, I = E(M), S = A < I ? I : A;
                  C -= S - M.width, M.width = S;
                }
                if (C = Math.round(C * 1e10) / 1e10, C) {
                  var X = k.filter(function(H) {
                    return C < 0 ? H.width > E(H) : !0;
                  });
                  X.length && (C = f(X, C, E));
                }
                return C;
              }
              l.resizeColumns = f;
              function m(k) {
                for (var C = {}, E = 1, q = k.allRows(), T = 0; T < q.length; T++)
                  for (var F = q[T], M = 0, B = k.columns; M < B.length; M++) {
                    var P = B[M], A = C[P.index];
                    if (E > 1)
                      E--, delete F.cells[P.index];
                    else if (A)
                      A.cell.height += F.height, E = A.cell.colSpan, delete F.cells[P.index], A.left--, A.left <= 1 && delete C[P.index];
                    else {
                      var I = F.cells[P.index];
                      if (!I)
                        continue;
                      if (I.height = F.height, I.rowSpan > 1) {
                        var S = q.length - T, X = I.rowSpan > S ? S : I.rowSpan;
                        C[P.index] = { cell: I, left: X, row: F };
                      }
                    }
                  }
              }
              function b(k) {
                for (var C = k.allRows(), E = 0; E < C.length; E++)
                  for (var q = C[E], T = null, F = 0, M = 0, B = 0; B < k.columns.length; B++) {
                    var P = k.columns[B];
                    if (M -= 1, M > 1 && k.columns[B + 1])
                      F += P.width, delete q.cells[P.index];
                    else if (T) {
                      var A = T;
                      delete q.cells[P.index], T = null, A.width = P.width + F;
                    } else {
                      var A = q.cells[P.index];
                      if (!A)
                        continue;
                      if (M = A.colSpan, F = 0, A.colSpan > 1) {
                        T = A, F += P.width;
                        continue;
                      }
                      A.width = P.width + F;
                    }
                  }
              }
              function x(k, C) {
                for (var E = { count: 0, height: 0 }, q = 0, T = k.allRows(); q < T.length; q++) {
                  for (var F = T[q], M = 0, B = k.columns; M < B.length; M++) {
                    var P = B[M], A = F.cells[P.index];
                    if (A) {
                      C.applyStyles(A.styles, !0);
                      var I = A.width - A.padding("horizontal");
                      if (A.styles.overflow === "linebreak")
                        A.text = C.splitTextToSize(A.text, I + 1 / C.scaleFactor(), { fontSize: A.styles.fontSize });
                      else if (A.styles.overflow === "ellipsize")
                        A.text = y(A.text, I, A.styles, C, "...");
                      else if (A.styles.overflow === "hidden")
                        A.text = y(A.text, I, A.styles, C, "");
                      else if (typeof A.styles.overflow == "function") {
                        var S = A.styles.overflow(A.text, I);
                        typeof S == "string" ? A.text = [S] : A.text = S;
                      }
                      A.contentHeight = A.getContentHeight(C.scaleFactor(), C.getLineHeightFactor());
                      var X = A.contentHeight / A.rowSpan;
                      A.rowSpan > 1 && E.count * E.height < X * A.rowSpan ? E = { height: X, count: A.rowSpan } : E && E.count > 0 && E.height > X && (X = E.height), X > F.height && (F.height = X);
                    }
                  }
                  E.count--;
                }
              }
              function y(k, C, E, q, T) {
                return k.map(function(F) {
                  return v(F, C, E, q, T);
                });
              }
              l.ellipsize = y;
              function v(k, C, E, q, T) {
                var F = 1e4 * q.scaleFactor();
                if (C = Math.ceil(C * F) / F, C >= (0, u.getStringWidth)(k, E, q))
                  return k;
                for (; C < (0, u.getStringWidth)(k + T, E, q) && !(k.length <= 1); )
                  k = k.substring(0, k.length - 1);
                return k.trim() + T;
              }
            }
          ),
          /***/
          964: (
            /***/
            function(a) {
              if (typeof e > "u") {
                var l = new Error("Cannot find module 'undefined'");
                throw l.code = "MODULE_NOT_FOUND", l;
              }
              a.exports = e;
            }
          )
          /******/
        }, r = {};
        function s(a) {
          var l = r[a];
          if (l !== void 0)
            return l.exports;
          var h = r[a] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return i[a].call(h.exports, h, h.exports, s), h.exports;
        }
        var o = {};
        return function() {
          var a = o;
          Object.defineProperty(a, "__esModule", { value: !0 }), a.Cell = a.Column = a.Row = a.Table = a.CellHookData = a.__drawTable = a.__createTable = a.applyPlugin = void 0;
          var l = s(340), h = s(776), u = s(664), d = s(972), p = s(260);
          Object.defineProperty(a, "Table", { enumerable: !0, get: function() {
            return p.Table;
          } });
          var f = s(172);
          Object.defineProperty(a, "CellHookData", { enumerable: !0, get: function() {
            return f.CellHookData;
          } });
          var m = s(260);
          Object.defineProperty(a, "Cell", { enumerable: !0, get: function() {
            return m.Cell;
          } }), Object.defineProperty(a, "Column", { enumerable: !0, get: function() {
            return m.Column;
          } }), Object.defineProperty(a, "Row", { enumerable: !0, get: function() {
            return m.Row;
          } });
          function b(C) {
            (0, l.default)(C);
          }
          a.applyPlugin = b;
          function x(C, E) {
            var q = (0, h.parseInput)(C, E), T = (0, d.createTable)(C, q);
            (0, u.drawTable)(C, T);
          }
          function y(C, E) {
            var q = (0, h.parseInput)(C, E);
            return (0, d.createTable)(C, q);
          }
          a.__createTable = y;
          function v(C, E) {
            (0, u.drawTable)(C, E);
          }
          a.__drawTable = v;
          try {
            var k = s(964);
            k.jsPDF && (k = k.jsPDF), b(k);
          } catch {
          }
          a.default = x;
        }(), o;
      }()
    );
  });
})(q1);
var tw = q1.exports;
const sa = /* @__PURE__ */ Oc(tw), oa = 5, dl = 10, Iu = ",", aa = {
  fillColor: [7, 59, 76],
  fontStyle: "normal"
}, la = {
  fontSize: 9
}, ua = { left: 10 };
let ca = [];
const ew = (n, t, e = (i) => i.toString()) => {
  var u;
  const { t: i } = A2.global, r = new Se({ orientation: "landscape" });
  let s = 10;
  r.setFontSize(20), r.text(i("pdf.orderSummary"), 10, s), s += 15, r.setFontSize(14), r.text("Your parts", 10, s), s += oa, ca = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity"),
    i("name"),
    `Banding (${gr.join(Iu)})`,
    `Finish (${dr.join(Iu)})`
  ];
  const o = n.parts.map((d) => {
    var m;
    const p = gr.map((b) => d.banding[b] || "-").join(Iu), f = dr.map((b) => d.banding[b] || "-").join(Iu);
    return [
      e(d.l),
      e(d.w),
      e(d.t) || "-",
      ((m = d == null ? void 0 : d.material) == null ? void 0 : m.toUpperCase()) || "-",
      e(d.q),
      d.name || "-",
      p,
      f
    ];
  });
  sa(r, {
    startY: s,
    head: [ca],
    body: o,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + dl, r.setFontSize(14), r.text(i("pdf.stockRequirements"), 10, s), s += oa, ca = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity")
    // 'Cost'
  ];
  const a = n.stock.map((d) => {
    var p;
    return [
      e(d.l),
      e(d.w),
      e(d.t) || "-",
      ((p = d == null ? void 0 : d.material) == null ? void 0 : p.toUpperCase()) || "-",
      e(d.q)
      // stock.cost
    ];
  });
  sa(r, {
    startY: s,
    head: [ca],
    body: a,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + dl, r.setFontSize(14), r.text(i("pdf.rollRequirements"), 10, s), s += oa, ca = [
    i("name"),
    i("material"),
    i("length")
  ];
  const l = n.stock.map((d) => {
    var p, f;
    return [
      ((p = d == null ? void 0 : d.name) == null ? void 0 : p.toUpperCase()) || "-",
      ((f = d == null ? void 0 : d.material) == null ? void 0 : f.toUpperCase()) || "-",
      e(d.analysis.rollLength)
    ];
  });
  if (sa(r, {
    startY: s,
    head: [ca],
    body: l,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + dl, t && Object.values(t)) {
    r.setFontSize(14), r.text("Hardware", 10, s), s += oa;
    const d = Object.values(t).map((p) => [
      p.name.toUpperCase(),
      e(p.q)
      // item.totalCost.toFixed( 2 )
    ]);
    sa(r, {
      startY: s,
      head: [[i("pdf.item"), i("quantity")]],
      body: d,
      margin: ua,
      headStyles: aa,
      styles: la
    }), s = r.autoTable.previous.finalY + dl;
  }
  r.setFontSize(14), r.text(i("pdf.totals"), 10, s), s += oa;
  const h = [
    [i("pdf.totalParts"), e(n.metadata.totalPartsProduced)],
    [i("pdf.partArea"), e(n.metadata.totalPartArea)],
    [i("pdf.totalStockRequired"), e(n.metadata.totalUsedStock)],
    [i("pdf.totalBandingLength"), e(n.metadata.totalBandingLength)],
    [i("pdf.totalFinishArea"), e(n.metadata.totalFinishArea)],
    [i("pdf.totalRollLength"), e(n.metadata.totalRollLength)]
  ];
  if (sa(r, {
    startY: s,
    body: h,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + dl, (u = window == null ? void 0 : window.smartcutImages) != null && u.length) {
    r.addPage();
    let d = 10;
    r.setFontSize(14), r.text(i("pdf.images"), 10, d), d += oa;
    const p = window.smartcutImages.flatMap((f, m) => f.metadata.map((b) => [
      m + 1,
      b.newName
    ]));
    sa(r, {
      startY: d,
      body: p,
      head: [[i("pdf.partIndex"), i("pdf.fileName")]],
      margin: ua,
      headStyles: aa,
      styles: la
    });
  }
  return r.output("datauristring");
};
function nw(n) {
  return C2() ? (P2(n), !0) : !1;
}
function Ad(n) {
  return typeof n == "function" ? n() : Pe(n);
}
const iw = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const rw = Object.prototype.toString, sw = (n) => rw.call(n) === "[object Object]", ow = () => {
};
function aw(n, t) {
  function e(...i) {
    return new Promise((r, s) => {
      Promise.resolve(n(() => t.apply(this, i), { fn: t, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return e;
}
const z1 = (n) => n();
function lw(n = z1) {
  const t = Ae(!0);
  function e() {
    t.value = !1;
  }
  function i() {
    t.value = !0;
  }
  const r = (...s) => {
    t.value && n(...s);
  };
  return { isActive: N2(t), pause: e, resume: i, eventFilter: r };
}
function uw(n) {
  return L2();
}
function cw(n, t, e = {}) {
  const {
    eventFilter: i = z1,
    ...r
  } = e;
  return fr(
    n,
    aw(
      i,
      t
    ),
    r
  );
}
function hw(n, t, e = {}) {
  const {
    eventFilter: i,
    ...r
  } = e, { eventFilter: s, pause: o, resume: a, isActive: l } = lw(i);
  return { stop: cw(
    n,
    t,
    {
      ...r,
      eventFilter: s
    }
  ), pause: o, resume: a, isActive: l };
}
function fw(n, t = !0, e) {
  uw() ? No(n, e) : t ? n() : Qr(n);
}
function dw(n) {
  var t;
  const e = Ad(n);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const uc = iw ? window : void 0;
function cg(...n) {
  let t, e, i, r;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([e, i, r] = n, t = uc) : [t, e, i, r] = n, !t)
    return ow;
  Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
  const s = [], o = () => {
    s.forEach((u) => u()), s.length = 0;
  }, a = (u, d, p, f) => (u.addEventListener(d, p, f), () => u.removeEventListener(d, p, f)), l = fr(
    () => [dw(t), Ad(r)],
    ([u, d]) => {
      if (o(), !u)
        return;
      const p = sw(d) ? { ...d } : d;
      s.push(
        ...e.flatMap((f) => i.map((m) => a(u, f, m, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), h = () => {
    l(), o();
  };
  return nw(h), h;
}
const Eu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ou = "__vueuse_ssr_handlers__", pw = /* @__PURE__ */ gw();
function gw() {
  return Ou in Eu || (Eu[Ou] = Eu[Ou] || {}), Eu[Ou];
}
function mw(n, t) {
  return pw[n] || t;
}
function yw(n) {
  return n == null ? "any" : n instanceof Set ? "set" : n instanceof Map ? "map" : n instanceof Date ? "date" : typeof n == "boolean" ? "boolean" : typeof n == "string" ? "string" : typeof n == "object" ? "object" : Number.isNaN(n) ? "any" : "number";
}
const bw = {
  boolean: {
    read: (n) => n === "true",
    write: (n) => String(n)
  },
  object: {
    read: (n) => JSON.parse(n),
    write: (n) => JSON.stringify(n)
  },
  number: {
    read: (n) => Number.parseFloat(n),
    write: (n) => String(n)
  },
  any: {
    read: (n) => n,
    write: (n) => String(n)
  },
  string: {
    read: (n) => n,
    write: (n) => String(n)
  },
  map: {
    read: (n) => new Map(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n.entries()))
  },
  set: {
    read: (n) => new Set(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n))
  },
  date: {
    read: (n) => new Date(n),
    write: (n) => n.toISOString()
  }
}, hg = "vueuse-storage";
function vw(n, t, e, i = {}) {
  var r;
  const {
    flush: s = "pre",
    deep: o = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: h = !1,
    shallow: u,
    window: d = uc,
    eventFilter: p,
    onError: f = (B) => {
      console.error(B);
    },
    initOnMounted: m
  } = i, b = (u ? oo : Ae)(typeof t == "function" ? t() : t);
  if (!e)
    try {
      e = mw("getDefaultStorage", () => {
        var B;
        return (B = uc) == null ? void 0 : B.localStorage;
      })();
    } catch (B) {
      f(B);
    }
  if (!e)
    return b;
  const x = Ad(t), y = yw(x), v = (r = i.serializer) != null ? r : bw[y], { pause: k, resume: C } = hw(
    b,
    () => q(b.value),
    { flush: s, deep: o, eventFilter: p }
  );
  d && a && fw(() => {
    cg(d, "storage", F), cg(d, hg, M), m && F();
  }), m || F();
  function E(B, P) {
    d && d.dispatchEvent(new CustomEvent(hg, {
      detail: {
        key: n,
        oldValue: B,
        newValue: P,
        storageArea: e
      }
    }));
  }
  function q(B) {
    try {
      const P = e.getItem(n);
      if (B == null)
        E(P, null), e.removeItem(n);
      else {
        const A = v.write(B);
        P !== A && (e.setItem(n, A), E(P, A));
      }
    } catch (P) {
      f(P);
    }
  }
  function T(B) {
    const P = B ? B.newValue : e.getItem(n);
    if (P == null)
      return l && x != null && e.setItem(n, v.write(x)), x;
    if (!B && h) {
      const A = v.read(P);
      return typeof h == "function" ? h(A, x) : y === "object" && !Array.isArray(A) ? { ...x, ...A } : A;
    } else return typeof P != "string" ? P : v.read(P);
  }
  function F(B) {
    if (!(B && B.storageArea !== e)) {
      if (B && B.key == null) {
        b.value = x;
        return;
      }
      if (!(B && B.key !== n)) {
        k();
        try {
          (B == null ? void 0 : B.newValue) !== v.write(b.value) && (b.value = T(B));
        } catch (P) {
          f(P);
        } finally {
          B ? Qr(C) : C();
        }
      }
    }
  }
  function M(B) {
    F(B.detail);
  }
  return b;
}
function fg(n, t, e = {}) {
  const { window: i = uc } = e;
  return vw(n, t, i == null ? void 0 : i.localStorage, e);
}
const Jn = [];
for (let n = 0; n < 256; ++n)
  Jn.push((n + 256).toString(16).slice(1));
function ww(n, t = 0) {
  return (Jn[n[t + 0]] + Jn[n[t + 1]] + Jn[n[t + 2]] + Jn[n[t + 3]] + "-" + Jn[n[t + 4]] + Jn[n[t + 5]] + "-" + Jn[n[t + 6]] + Jn[n[t + 7]] + "-" + Jn[n[t + 8]] + Jn[n[t + 9]] + "-" + Jn[n[t + 10]] + Jn[n[t + 11]] + Jn[n[t + 12]] + Jn[n[t + 13]] + Jn[n[t + 14]] + Jn[n[t + 15]]).toLowerCase();
}
let Eh;
const xw = new Uint8Array(16);
function _w() {
  if (!Eh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Eh = crypto.getRandomValues.bind(crypto);
  }
  return Eh(xw);
}
const Sw = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), dg = { randomUUID: Sw };
function kw(n, t, e) {
  if (dg.randomUUID && !t && !n)
    return dg.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || _w)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, ww(i);
}
const Mr = /* @__PURE__ */ Object.create(null);
Mr.open = "0";
Mr.close = "1";
Mr.ping = "2";
Mr.pong = "3";
Mr.message = "4";
Mr.upgrade = "5";
Mr.noop = "6";
const Wu = /* @__PURE__ */ Object.create(null);
Object.keys(Mr).forEach((n) => {
  Wu[Mr[n]] = n;
});
const bf = { type: "error", data: "parser error" }, $1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", U1 = typeof ArrayBuffer == "function", W1 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, Nd = ({ type: n, data: t }, e, i) => $1 && t instanceof Blob ? e ? i(t) : pg(t, i) : U1 && (t instanceof ArrayBuffer || W1(t)) ? e ? i(t) : pg(new Blob([t]), i) : i(Mr[n] + (t || "")), pg = (n, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const i = e.result.split(",")[1];
    t("b" + (i || ""));
  }, e.readAsDataURL(n);
};
function gg(n) {
  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
}
let Oh;
function Aw(n, t) {
  if ($1 && n.data instanceof Blob)
    return n.data.arrayBuffer().then(gg).then(t);
  if (U1 && (n.data instanceof ArrayBuffer || W1(n.data)))
    return t(gg(n.data));
  Nd(n, !1, (e) => {
    Oh || (Oh = new TextEncoder()), t(Oh.encode(e));
  });
}
const mg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bl = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < mg.length; n++)
  bl[mg.charCodeAt(n)] = n;
const Nw = (n) => {
  let t = n.length * 0.75, e = n.length, i, r = 0, s, o, a, l;
  n[n.length - 1] === "=" && (t--, n[n.length - 2] === "=" && t--);
  const h = new ArrayBuffer(t), u = new Uint8Array(h);
  for (i = 0; i < e; i += 4)
    s = bl[n.charCodeAt(i)], o = bl[n.charCodeAt(i + 1)], a = bl[n.charCodeAt(i + 2)], l = bl[n.charCodeAt(i + 3)], u[r++] = s << 2 | o >> 4, u[r++] = (o & 15) << 4 | a >> 2, u[r++] = (a & 3) << 6 | l & 63;
  return h;
}, Cw = typeof ArrayBuffer == "function", Cd = (n, t) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: H1(n, t)
    };
  const e = n.charAt(0);
  return e === "b" ? {
    type: "message",
    data: Pw(n.substring(1), t)
  } : Wu[e] ? n.length > 1 ? {
    type: Wu[e],
    data: n.substring(1)
  } : {
    type: Wu[e]
  } : bf;
}, Pw = (n, t) => {
  if (Cw) {
    const e = Nw(n);
    return H1(e, t);
  } else
    return { base64: !0, data: n };
}, H1 = (n, t) => {
  switch (t) {
    case "blob":
      return n instanceof Blob ? n : new Blob([n]);
    case "arraybuffer":
    default:
      return n instanceof ArrayBuffer ? n : n.buffer;
  }
}, G1 = "", Lw = (n, t) => {
  const e = n.length, i = new Array(e);
  let r = 0;
  n.forEach((s, o) => {
    Nd(s, !1, (a) => {
      i[o] = a, ++r === e && t(i.join(G1));
    });
  });
}, Iw = (n, t) => {
  const e = n.split(G1), i = [];
  for (let r = 0; r < e.length; r++) {
    const s = Cd(e[r], t);
    if (i.push(s), s.type === "error")
      break;
  }
  return i;
};
function Ew() {
  return new TransformStream({
    transform(n, t) {
      Aw(n, (e) => {
        const i = e.length;
        let r;
        if (i < 126)
          r = new Uint8Array(1), new DataView(r.buffer).setUint8(0, i);
        else if (i < 65536) {
          r = new Uint8Array(3);
          const s = new DataView(r.buffer);
          s.setUint8(0, 126), s.setUint16(1, i);
        } else {
          r = new Uint8Array(9);
          const s = new DataView(r.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(i));
        }
        n.data && typeof n.data != "string" && (r[0] |= 128), t.enqueue(r), t.enqueue(e);
      });
    }
  });
}
let Th;
function Tu(n) {
  return n.reduce((t, e) => t + e.length, 0);
}
function Fu(n, t) {
  if (n[0].length === t)
    return n.shift();
  const e = new Uint8Array(t);
  let i = 0;
  for (let r = 0; r < t; r++)
    e[r] = n[0][i++], i === n[0].length && (n.shift(), i = 0);
  return n.length && i < n[0].length && (n[0] = n[0].slice(i)), e;
}
function Ow(n, t) {
  Th || (Th = new TextDecoder());
  const e = [];
  let i = 0, r = -1, s = !1;
  return new TransformStream({
    transform(o, a) {
      for (e.push(o); ; ) {
        if (i === 0) {
          if (Tu(e) < 1)
            break;
          const l = Fu(e, 1);
          s = (l[0] & 128) === 128, r = l[0] & 127, r < 126 ? i = 3 : r === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (Tu(e) < 2)
            break;
          const l = Fu(e, 2);
          r = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (Tu(e) < 8)
            break;
          const l = Fu(e, 8), h = new DataView(l.buffer, l.byteOffset, l.length), u = h.getUint32(0);
          if (u > Math.pow(2, 21) - 1) {
            a.enqueue(bf);
            break;
          }
          r = u * Math.pow(2, 32) + h.getUint32(4), i = 3;
        } else {
          if (Tu(e) < r)
            break;
          const l = Fu(e, r);
          a.enqueue(Cd(s ? l : Th.decode(l), t)), i = 0;
        }
        if (r === 0 || r > n) {
          a.enqueue(bf);
          break;
        }
      }
    }
  });
}
const V1 = 4;
function Mn(n) {
  if (n) return Tw(n);
}
function Tw(n) {
  for (var t in Mn.prototype)
    n[t] = Mn.prototype[t];
  return n;
}
Mn.prototype.on = Mn.prototype.addEventListener = function(n, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(t), this;
};
Mn.prototype.once = function(n, t) {
  function e() {
    this.off(n, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(n, e), this;
};
Mn.prototype.off = Mn.prototype.removeListener = Mn.prototype.removeAllListeners = Mn.prototype.removeEventListener = function(n, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + n];
  if (!e) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var i, r = 0; r < e.length; r++)
    if (i = e[r], i === t || i.fn === t) {
      e.splice(r, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + n], this;
};
Mn.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + n], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (e) {
    e = e.slice(0);
    for (var i = 0, r = e.length; i < r; ++i)
      e[i].apply(this, t);
  }
  return this;
};
Mn.prototype.emitReserved = Mn.prototype.emit;
Mn.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Mn.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const Bc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0), Ji = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), Fw = "arraybuffer";
function Y1(n, ...t) {
  return t.reduce((e, i) => (n.hasOwnProperty(i) && (e[i] = n[i]), e), {});
}
const Mw = Ji.setTimeout, Rw = Ji.clearTimeout;
function jc(n, t) {
  t.useNativeTimers ? (n.setTimeoutFn = Mw.bind(Ji), n.clearTimeoutFn = Rw.bind(Ji)) : (n.setTimeoutFn = Ji.setTimeout.bind(Ji), n.clearTimeoutFn = Ji.clearTimeout.bind(Ji));
}
const Dw = 1.33;
function Bw(n) {
  return typeof n == "string" ? jw(n) : Math.ceil((n.byteLength || n.size) * Dw);
}
function jw(n) {
  let t = 0, e = 0;
  for (let i = 0, r = n.length; i < r; i++)
    t = n.charCodeAt(i), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (i++, e += 4);
  return e;
}
function K1() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function qw(n) {
  let t = "";
  for (let e in n)
    n.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(n[e]));
  return t;
}
function zw(n) {
  let t = {}, e = n.split("&");
  for (let i = 0, r = e.length; i < r; i++) {
    let s = e[i].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
class $w extends Error {
  constructor(t, e, i) {
    super(t), this.description = e, this.context = i, this.type = "TransportError";
  }
}
class Pd extends Mn {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, jc(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, i) {
    return super.emitReserved("error", new $w(t, e, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = Cd(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, e = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(e);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const e = qw(t);
    return e.length ? "?" + e : "";
  }
}
class Uw extends Pd {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || e();
      })), this.writable || (i++, this.once("drain", function() {
        --i || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    Iw(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, Lw(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", e = this.query || {};
    return this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = K1()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.createUri(t, e);
  }
}
let X1 = !1;
try {
  X1 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Ww = X1;
function Hw() {
}
class Gw extends Uw {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const e = location.protocol === "https:";
      let i = location.port;
      i || (i = e ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", e), i.on("error", (r, s) => {
      this.onError("xhr post error", r, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, i) => {
      this.onError("xhr poll error", e, i);
    }), this.pollXhr = t;
  }
}
class Tr extends Mn {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e, i) {
    super(), this.createRequest = t, jc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = e, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const e = Y1(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(e);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let r in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(r) && i.setRequestHeader(r, this._opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var r;
        i.readyState === 3 && ((r = this._opts.cookieJar) === null || r === void 0 || r.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this._onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Tr.requestsCount++, Tr.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = Hw, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Tr.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Tr.requestsCount = 0;
Tr.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", yg);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in Ji ? "pagehide" : "unload";
    addEventListener(n, yg, !1);
  }
}
function yg() {
  for (let n in Tr.requests)
    Tr.requests.hasOwnProperty(n) && Tr.requests[n].abort();
}
const Vw = function() {
  const n = J1({
    xdomain: !1
  });
  return n && n.responseType !== null;
}();
class Yw extends Gw {
  constructor(t) {
    super(t);
    const e = t && t.forceBase64;
    this.supportsBinary = Vw && !e;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new Tr(J1, this.uri(), t);
  }
}
function J1(n) {
  const t = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || Ww))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new Ji[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Z1 = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Kw extends Pd {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), e = this.opts.protocols, i = Z1 ? {} : Y1(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, e, i);
    } catch (r) {
      return this.emitReserved("error", r);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      Nd(i, this.supportsBinary, (s) => {
        try {
          this.doWrite(i, s);
        } catch {
        }
        r && Bc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", e = this.query || {};
    return this.opts.timestampRequests && (e[this.opts.timestampParam] = K1()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e);
  }
}
const Fh = Ji.WebSocket || Ji.MozWebSocket;
class Xw extends Kw {
  createSocket(t, e, i) {
    return Z1 ? new Fh(t, e, i) : e ? new Fh(t, e) : new Fh(t);
  }
  doWrite(t, e) {
    this.ws.send(e);
  }
}
class Jw extends Pd {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const e = Ow(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(e).getReader(), r = Ew();
        r.readable.pipeTo(t.writable), this._writer = r.writable.getWriter();
        const s = () => {
          i.read().then(({ done: a, value: l }) => {
            a || (this.onPacket(l), s());
          }).catch((a) => {
          });
        };
        s();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      this._writer.write(i).then(() => {
        r && Bc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const Zw = {
  websocket: Xw,
  webtransport: Jw,
  polling: Yw
}, Qw = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, t3 = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function vf(n) {
  if (n.length > 8e3)
    throw "URI too long";
  const t = n, e = n.indexOf("["), i = n.indexOf("]");
  e != -1 && i != -1 && (n = n.substring(0, e) + n.substring(e, i).replace(/:/g, ";") + n.substring(i, n.length));
  let r = Qw.exec(n || ""), s = {}, o = 14;
  for (; o--; )
    s[t3[o]] = r[o] || "";
  return e != -1 && i != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = e3(s, s.path), s.queryKey = n3(s, s.query), s;
}
function e3(n, t) {
  const e = /\/{2,9}/g, i = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function n3(n, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, r, s) {
    r && (e[r] = s);
  }), e;
}
const wf = typeof addEventListener == "function" && typeof removeEventListener == "function", Hu = [];
wf && addEventListener("offline", () => {
  Hu.forEach((n) => n());
}, !1);
class Ds extends Mn {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e) {
    if (super(), this.binaryType = Fw, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (e = t, t = null), t) {
      const i = vf(t);
      e.hostname = i.host, e.secure = i.protocol === "https" || i.protocol === "wss", e.port = i.port, i.query && (e.query = i.query);
    } else e.host && (e.hostname = vf(e.host).host);
    jc(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, e.transports.forEach((i) => {
      const r = i.prototype.name;
      this.transports.push(r), this._transportsByName[r] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = zw(this.opts.query)), wf && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, Hu.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = V1, e.transport = t, this.id && (e.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && Ds.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const e = this.createTransport(t);
    e.open(), this.setTransport(e);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (e) => this._onClose("transport close", e));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", Ds.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this._onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const r = this.writeBuffer[i].data;
      if (r && (e += Bw(r)), i > 0 && e > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, Bc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, e, i, r) {
    if (typeof e == "function" && (r = e, e = void 0), typeof i == "function" && (r = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: i
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), r && this.once("flush", r), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, i = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (Ds.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), wf && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = Hu.indexOf(this._offlineEventListener);
        i !== -1 && Hu.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
Ds.protocol = V1;
class i3 extends Ds {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let e = this.createTransport(t), i = !1;
    Ds.priorWebsocketSuccess = !1;
    const r = () => {
      i || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (d) => {
        if (!i)
          if (d.type === "pong" && d.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Ds.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (u(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const p = new Error("probe error");
            p.transport = e.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function s() {
      i || (i = !0, u(), e.close(), e = null);
    }
    const o = (d) => {
      const p = new Error("probe error: " + d);
      p.transport = e.name, s(), this.emitReserved("upgradeError", p);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function h(d) {
      e && d.name !== e.name && s();
    }
    const u = () => {
      e.removeListener("open", r), e.removeListener("error", o), e.removeListener("close", a), this.off("close", l), this.off("upgrading", h);
    };
    e.once("open", r), e.once("error", o), e.once("close", a), this.once("close", l), this.once("upgrading", h), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      i || e.open();
    }, 200) : e.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const e = [];
    for (let i = 0; i < t.length; i++)
      ~this.transports.indexOf(t[i]) && e.push(t[i]);
    return e;
  }
}
let r3 = class extends i3 {
  constructor(t, e = {}) {
    const i = typeof t == "object" ? t : e;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((r) => Zw[r]).filter((r) => !!r)), super(t, i);
  }
};
function s3(n, t = "", e) {
  let i = n;
  e = e || typeof location < "u" && location, n == null && (n = e.protocol + "//" + e.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = e.protocol + n : n = e.host + n), /^(https?|wss?):\/\//.test(n) || (typeof e < "u" ? n = e.protocol + "//" + n : n = "https://" + n), i = vf(n)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + s + ":" + i.port + t, i.href = i.protocol + "://" + s + (e && e.port === i.port ? "" : ":" + i.port), i;
}
const o3 = typeof ArrayBuffer == "function", a3 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Q1 = Object.prototype.toString, l3 = typeof Blob == "function" || typeof Blob < "u" && Q1.call(Blob) === "[object BlobConstructor]", u3 = typeof File == "function" || typeof File < "u" && Q1.call(File) === "[object FileConstructor]";
function Ld(n) {
  return o3 && (n instanceof ArrayBuffer || a3(n)) || l3 && n instanceof Blob || u3 && n instanceof File;
}
function Gu(n, t) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let e = 0, i = n.length; e < i; e++)
      if (Gu(n[e]))
        return !0;
    return !1;
  }
  if (Ld(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return Gu(n.toJSON(), !0);
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e) && Gu(n[e]))
      return !0;
  return !1;
}
function c3(n) {
  const t = [], e = n.data, i = n;
  return i.data = xf(e, t), i.attachments = t.length, { packet: i, buffers: t };
}
function xf(n, t) {
  if (!n)
    return n;
  if (Ld(n)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(n), e;
  } else if (Array.isArray(n)) {
    const e = new Array(n.length);
    for (let i = 0; i < n.length; i++)
      e[i] = xf(n[i], t);
    return e;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const e = {};
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = xf(n[i], t));
    return e;
  }
  return n;
}
function h3(n, t) {
  return n.data = _f(n.data, t), delete n.attachments, n;
}
function _f(n, t) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < t.length)
      return t[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let e = 0; e < n.length; e++)
      n[e] = _f(n[e], t);
  else if (typeof n == "object")
    for (const e in n)
      Object.prototype.hasOwnProperty.call(n, e) && (n[e] = _f(n[e], t));
  return n;
}
const f3 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], d3 = 5;
var Be;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(Be || (Be = {}));
class p3 {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === Be.EVENT || t.type === Be.ACK) && Gu(t) ? this.encodeAsBinary({
      type: t.type === Be.EVENT ? Be.BINARY_EVENT : Be.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === Be.BINARY_EVENT || t.type === Be.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = c3(t), i = this.encodeAsString(e.packet), r = e.buffers;
    return r.unshift(i), r;
  }
}
function bg(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
class Id extends Mn {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const i = e.type === Be.BINARY_EVENT;
      i || e.type === Be.BINARY_ACK ? (e.type = i ? Be.EVENT : Be.ACK, this.reconstructor = new g3(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (Ld(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (Be[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === Be.BINARY_EVENT || i.type === Be.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const o = t.substring(s, e);
      if (o != Number(o) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(o);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      i.nsp = t.substring(s, e);
    } else
      i.nsp = "/";
    const r = t.charAt(e + 1);
    if (r !== "" && Number(r) == r) {
      const s = e + 1;
      for (; ++e; ) {
        const o = t.charAt(e);
        if (o == null || Number(o) != o) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      i.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (Id.isPayloadValid(i.type, s))
        i.data = s;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case Be.CONNECT:
        return bg(e);
      case Be.DISCONNECT:
        return e === void 0;
      case Be.CONNECT_ERROR:
        return typeof e == "string" || bg(e);
      case Be.EVENT:
      case Be.BINARY_EVENT:
        return Array.isArray(e) && (typeof e[0] == "number" || typeof e[0] == "string" && f3.indexOf(e[0]) === -1);
      case Be.ACK:
      case Be.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class g3 {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = h3(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const m3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Decoder: Id, Encoder: p3, get PacketType() {
  return Be;
}, protocol: d3 }, Symbol.toStringTag, { value: "Module" }));
function cr(n, t, e) {
  return n.on(t, e), function() {
    n.off(t, e);
  };
}
const y3 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class tm extends Mn {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      cr(t, "open", this.onopen.bind(this)),
      cr(t, "packet", this.onpacket.bind(this)),
      cr(t, "error", this.onerror.bind(this)),
      cr(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    var i, r, s;
    if (y3.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const o = {
      type: Be.EVENT,
      data: e
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const u = this.ids++, d = e.pop();
      this._registerAckCallback(u, d), o.id = u;
    }
    const a = (r = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || r === void 0 ? void 0 : r.writable, l = this.connected && !(!((s = this.io.engine) === null || s === void 0) && s._hasPingExpired());
    return this.flags.volatile && !a || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var i;
    const r = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (r === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      e.call(this, new Error("operation has timed out"));
    }, r), o = (...a) => {
      this.io.clearTimeoutFn(s), e.apply(this, a);
    };
    o.withError = !0, this.acks[t] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    return new Promise((i, r) => {
      const s = (o, a) => o ? r(o) : i(a);
      s.withError = !0, e.push(s), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((r, ...s) => i !== this._queue[0] ? void 0 : (r !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(r)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: Be.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((i) => String(i.id) === t)) {
        const i = this.acks[t];
        delete this.acks[t], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case Be.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case Be.EVENT:
        case Be.BINARY_EVENT:
          this.onevent(t);
          break;
        case Be.ACK:
        case Be.BINARY_ACK:
          this.onack(t);
          break;
        case Be.DISCONNECT:
          this.ondisconnect();
          break;
        case Be.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const i of e)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let i = !1;
    return function(...r) {
      i || (i = !0, e.packet({
        type: Be.ACK,
        id: t,
        data: r
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (delete this.acks[t.id], e.withError && t.data.unshift(null), e.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: Be.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const i of e)
        i.apply(this, t.data);
    }
  }
}
function La(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
La.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * n);
    n = Math.floor(t * 10) & 1 ? n + e : n - e;
  }
  return Math.min(n, this.max) | 0;
};
La.prototype.reset = function() {
  this.attempts = 0;
};
La.prototype.setMin = function(n) {
  this.ms = n;
};
La.prototype.setMax = function(n) {
  this.max = n;
};
La.prototype.setJitter = function(n) {
  this.jitter = n;
};
class Sf extends Mn {
  constructor(t, e) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, jc(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((i = e.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new La({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const r = e.parser || m3;
    this.encoder = new r.Encoder(), this.decoder = new r.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new r3(this.uri, this.opts);
    const e = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const r = cr(e, "open", function() {
      i.onopen(), t && t();
    }), s = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), t ? t(a) : this.maybeReconnectOnOpen();
    }, o = cr(e, "error", s);
    if (this._timeout !== !1) {
      const a = this._timeout, l = this.setTimeoutFn(() => {
        r(), s(new Error("timeout")), e.close();
      }, a);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(r), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      cr(t, "ping", this.onping.bind(this)),
      cr(t, "data", this.ondata.bind(this)),
      cr(t, "error", this.onerror.bind(this)),
      cr(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      cr(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    Bc(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new tm(this, t, e), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const i of e)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let i = 0; i < e.length; i++)
      this.engine.write(e[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, e) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((r) => {
          r ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", r)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const pl = {};
function Vu(n, t) {
  typeof n == "object" && (t = n, n = void 0), t = t || {};
  const e = s3(n, t.path || "/socket.io"), i = e.source, r = e.id, s = e.path, o = pl[r] && s in pl[r].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
  let l;
  return a ? l = new Sf(i, t) : (pl[r] || (pl[r] = new Sf(i, t)), l = pl[r]), e.query && !t.query && (t.query = e.queryKey), l.socket(e.path, t);
}
Object.assign(Vu, {
  Manager: Sf,
  Socket: tm,
  io: Vu,
  connect: Vu
});
var b3 = typeof global == "object" && global && global.Object === Object && global, v3 = typeof self == "object" && self && self.Object === Object && self, Ed = b3 || v3 || Function("return this")(), ka = Ed.Symbol, em = Object.prototype, w3 = em.hasOwnProperty, x3 = em.toString, gl = ka ? ka.toStringTag : void 0;
function _3(n) {
  var t = w3.call(n, gl), e = n[gl];
  try {
    n[gl] = void 0;
    var i = !0;
  } catch {
  }
  var r = x3.call(n);
  return i && (t ? n[gl] = e : delete n[gl]), r;
}
var S3 = Object.prototype, k3 = S3.toString;
function A3(n) {
  return k3.call(n);
}
var N3 = "[object Null]", C3 = "[object Undefined]", vg = ka ? ka.toStringTag : void 0;
function nm(n) {
  return n == null ? n === void 0 ? C3 : N3 : vg && vg in Object(n) ? _3(n) : A3(n);
}
function P3(n) {
  return n != null && typeof n == "object";
}
var L3 = "[object Symbol]";
function Od(n) {
  return typeof n == "symbol" || P3(n) && nm(n) == L3;
}
function I3(n, t) {
  for (var e = -1, i = n == null ? 0 : n.length, r = Array(i); ++e < i; )
    r[e] = t(n[e], e, n);
  return r;
}
var Td = Array.isArray, E3 = 1 / 0, wg = ka ? ka.prototype : void 0, xg = wg ? wg.toString : void 0;
function im(n) {
  if (typeof n == "string")
    return n;
  if (Td(n))
    return I3(n, im) + "";
  if (Od(n))
    return xg ? xg.call(n) : "";
  var t = n + "";
  return t == "0" && 1 / n == -E3 ? "-0" : t;
}
function cc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
var O3 = "[object AsyncFunction]", T3 = "[object Function]", F3 = "[object GeneratorFunction]", M3 = "[object Proxy]";
function R3(n) {
  if (!cc(n))
    return !1;
  var t = nm(n);
  return t == T3 || t == F3 || t == O3 || t == M3;
}
var Mh = Ed["__core-js_shared__"], _g = function() {
  var n = /[^.]+$/.exec(Mh && Mh.keys && Mh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function D3(n) {
  return !!_g && _g in n;
}
var B3 = Function.prototype, j3 = B3.toString;
function q3(n) {
  if (n != null) {
    try {
      return j3.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var z3 = /[\\^$.*+?()[\]{}|]/g, $3 = /^\[object .+?Constructor\]$/, U3 = Function.prototype, W3 = Object.prototype, H3 = U3.toString, G3 = W3.hasOwnProperty, V3 = RegExp(
  "^" + H3.call(G3).replace(z3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Y3(n) {
  if (!cc(n) || D3(n))
    return !1;
  var t = R3(n) ? V3 : $3;
  return t.test(q3(n));
}
function K3(n, t) {
  return n == null ? void 0 : n[t];
}
function Fd(n, t) {
  var e = K3(n, t);
  return Y3(e) ? e : void 0;
}
var Sg = function() {
  try {
    var n = Fd(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), X3 = 9007199254740991, J3 = /^(?:0|[1-9]\d*)$/;
function Z3(n, t) {
  var e = typeof n;
  return t = t ?? X3, !!t && (e == "number" || e != "symbol" && J3.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function Q3(n, t, e) {
  t == "__proto__" && Sg ? Sg(n, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : n[t] = e;
}
function rm(n, t) {
  return n === t || n !== n && t !== t;
}
var tx = Object.prototype, ex = tx.hasOwnProperty;
function nx(n, t, e) {
  var i = n[t];
  (!(ex.call(n, t) && rm(i, e)) || e === void 0 && !(t in n)) && Q3(n, t, e);
}
var ix = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rx = /^\w*$/;
function sx(n, t) {
  if (Td(n))
    return !1;
  var e = typeof n;
  return e == "number" || e == "symbol" || e == "boolean" || n == null || Od(n) ? !0 : rx.test(n) || !ix.test(n) || t != null && n in Object(t);
}
var Il = Fd(Object, "create");
function ox() {
  this.__data__ = Il ? Il(null) : {}, this.size = 0;
}
function ax(n) {
  var t = this.has(n) && delete this.__data__[n];
  return this.size -= t ? 1 : 0, t;
}
var lx = "__lodash_hash_undefined__", ux = Object.prototype, cx = ux.hasOwnProperty;
function hx(n) {
  var t = this.__data__;
  if (Il) {
    var e = t[n];
    return e === lx ? void 0 : e;
  }
  return cx.call(t, n) ? t[n] : void 0;
}
var fx = Object.prototype, dx = fx.hasOwnProperty;
function px(n) {
  var t = this.__data__;
  return Il ? t[n] !== void 0 : dx.call(t, n);
}
var gx = "__lodash_hash_undefined__";
function mx(n, t) {
  var e = this.__data__;
  return this.size += this.has(n) ? 0 : 1, e[n] = Il && t === void 0 ? gx : t, this;
}
function Ao(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Ao.prototype.clear = ox;
Ao.prototype.delete = ax;
Ao.prototype.get = hx;
Ao.prototype.has = px;
Ao.prototype.set = mx;
function yx() {
  this.__data__ = [], this.size = 0;
}
function qc(n, t) {
  for (var e = n.length; e--; )
    if (rm(n[e][0], t))
      return e;
  return -1;
}
var bx = Array.prototype, vx = bx.splice;
function wx(n) {
  var t = this.__data__, e = qc(t, n);
  if (e < 0)
    return !1;
  var i = t.length - 1;
  return e == i ? t.pop() : vx.call(t, e, 1), --this.size, !0;
}
function xx(n) {
  var t = this.__data__, e = qc(t, n);
  return e < 0 ? void 0 : t[e][1];
}
function _x(n) {
  return qc(this.__data__, n) > -1;
}
function Sx(n, t) {
  var e = this.__data__, i = qc(e, n);
  return i < 0 ? (++this.size, e.push([n, t])) : e[i][1] = t, this;
}
function Ia(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Ia.prototype.clear = yx;
Ia.prototype.delete = wx;
Ia.prototype.get = xx;
Ia.prototype.has = _x;
Ia.prototype.set = Sx;
var kx = Fd(Ed, "Map");
function Ax() {
  this.size = 0, this.__data__ = {
    hash: new Ao(),
    map: new (kx || Ia)(),
    string: new Ao()
  };
}
function Nx(n) {
  var t = typeof n;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? n !== "__proto__" : n === null;
}
function zc(n, t) {
  var e = n.__data__;
  return Nx(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function Cx(n) {
  var t = zc(this, n).delete(n);
  return this.size -= t ? 1 : 0, t;
}
function Px(n) {
  return zc(this, n).get(n);
}
function Lx(n) {
  return zc(this, n).has(n);
}
function Ix(n, t) {
  var e = zc(this, n), i = e.size;
  return e.set(n, t), this.size += e.size == i ? 0 : 1, this;
}
function Lo(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Lo.prototype.clear = Ax;
Lo.prototype.delete = Cx;
Lo.prototype.get = Px;
Lo.prototype.has = Lx;
Lo.prototype.set = Ix;
var Ex = "Expected a function";
function Md(n, t) {
  if (typeof n != "function" || t != null && typeof t != "function")
    throw new TypeError(Ex);
  var e = function() {
    var i = arguments, r = t ? t.apply(this, i) : i[0], s = e.cache;
    if (s.has(r))
      return s.get(r);
    var o = n.apply(this, i);
    return e.cache = s.set(r, o) || s, o;
  };
  return e.cache = new (Md.Cache || Lo)(), e;
}
Md.Cache = Lo;
var Ox = 500;
function Tx(n) {
  var t = Md(n, function(i) {
    return e.size === Ox && e.clear(), i;
  }), e = t.cache;
  return t;
}
var Fx = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Mx = /\\(\\)?/g, Rx = Tx(function(n) {
  var t = [];
  return n.charCodeAt(0) === 46 && t.push(""), n.replace(Fx, function(e, i, r, s) {
    t.push(r ? s.replace(Mx, "$1") : i || e);
  }), t;
});
function Dx(n) {
  return n == null ? "" : im(n);
}
function sm(n, t) {
  return Td(n) ? n : sx(n, t) ? [n] : Rx(Dx(n));
}
var Bx = 1 / 0;
function om(n) {
  if (typeof n == "string" || Od(n))
    return n;
  var t = n + "";
  return t == "0" && 1 / n == -Bx ? "-0" : t;
}
function jx(n, t) {
  t = sm(t, n);
  for (var e = 0, i = t.length; n != null && e < i; )
    n = n[om(t[e++])];
  return e && e == i ? n : void 0;
}
function bo(n, t, e) {
  var i = n == null ? void 0 : jx(n, t);
  return i === void 0 ? e : i;
}
function qx(n, t, e, i) {
  if (!cc(n))
    return n;
  t = sm(t, n);
  for (var r = -1, s = t.length, o = s - 1, a = n; a != null && ++r < s; ) {
    var l = om(t[r]), h = e;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return n;
    if (r != o) {
      var u = a[l];
      h = void 0, h === void 0 && (h = cc(u) ? u : Z3(t[r + 1]) ? [] : {});
    }
    nx(a, l, h), a = a[l];
  }
  return n;
}
function kg(n, t, e) {
  return n == null ? n : qx(n, t, e);
}
var kf = "http://www.w3.org/1999/xhtml";
const Ag = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: kf,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function am(n) {
  var t = n += "", e = t.indexOf(":");
  return e >= 0 && (t = n.slice(0, e)) !== "xmlns" && (n = n.slice(e + 1)), Ag.hasOwnProperty(t) ? { space: Ag[t], local: n } : n;
}
function zx(n) {
  return function() {
    var t = this.ownerDocument, e = this.namespaceURI;
    return e === kf && t.documentElement.namespaceURI === kf ? t.createElement(n) : t.createElementNS(e, n);
  };
}
function $x(n) {
  return function() {
    return this.ownerDocument.createElementNS(n.space, n.local);
  };
}
function lm(n) {
  var t = am(n);
  return (t.local ? $x : zx)(t);
}
function Ux() {
}
function um(n) {
  return n == null ? Ux : function() {
    return this.querySelector(n);
  };
}
function Wx(n) {
  typeof n != "function" && (n = um(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = new Array(o), l, h, u = 0; u < o; ++u)
      (l = s[u]) && (h = n.call(l, l.__data__, u, s)) && ("__data__" in l && (h.__data__ = l.__data__), a[u] = h);
  return new Si(i, this._parents);
}
function cm(n) {
  return n == null ? [] : Array.isArray(n) ? n : Array.from(n);
}
function Hx() {
  return [];
}
function Gx(n) {
  return n == null ? Hx : function() {
    return this.querySelectorAll(n);
  };
}
function Vx(n) {
  return function() {
    return cm(n.apply(this, arguments));
  };
}
function Yx(n) {
  typeof n == "function" ? n = Vx(n) : n = Gx(n);
  for (var t = this._groups, e = t.length, i = [], r = [], s = 0; s < e; ++s)
    for (var o = t[s], a = o.length, l, h = 0; h < a; ++h)
      (l = o[h]) && (i.push(n.call(l, l.__data__, h, o)), r.push(l));
  return new Si(i, r);
}
function Kx(n) {
  return function() {
    return this.matches(n);
  };
}
function hm(n) {
  return function(t) {
    return t.matches(n);
  };
}
var Xx = Array.prototype.find;
function Jx(n) {
  return function() {
    return Xx.call(this.children, n);
  };
}
function Zx() {
  return this.firstElementChild;
}
function Qx(n) {
  return this.select(n == null ? Zx : Jx(typeof n == "function" ? n : hm(n)));
}
var t4 = Array.prototype.filter;
function e4() {
  return Array.from(this.children);
}
function n4(n) {
  return function() {
    return t4.call(this.children, n);
  };
}
function i4(n) {
  return this.selectAll(n == null ? e4 : n4(typeof n == "function" ? n : hm(n)));
}
function r4(n) {
  typeof n != "function" && (n = Kx(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = [], l, h = 0; h < o; ++h)
      (l = s[h]) && n.call(l, l.__data__, h, s) && a.push(l);
  return new Si(i, this._parents);
}
function fm(n) {
  return new Array(n.length);
}
function s4() {
  return new Si(this._enter || this._groups.map(fm), this._parents);
}
function hc(n, t) {
  this.ownerDocument = n.ownerDocument, this.namespaceURI = n.namespaceURI, this._next = null, this._parent = n, this.__data__ = t;
}
hc.prototype = {
  constructor: hc,
  appendChild: function(n) {
    return this._parent.insertBefore(n, this._next);
  },
  insertBefore: function(n, t) {
    return this._parent.insertBefore(n, t);
  },
  querySelector: function(n) {
    return this._parent.querySelector(n);
  },
  querySelectorAll: function(n) {
    return this._parent.querySelectorAll(n);
  }
};
function o4(n) {
  return function() {
    return n;
  };
}
function a4(n, t, e, i, r, s) {
  for (var o = 0, a, l = t.length, h = s.length; o < h; ++o)
    (a = t[o]) ? (a.__data__ = s[o], i[o] = a) : e[o] = new hc(n, s[o]);
  for (; o < l; ++o)
    (a = t[o]) && (r[o] = a);
}
function l4(n, t, e, i, r, s, o) {
  var a, l, h = /* @__PURE__ */ new Map(), u = t.length, d = s.length, p = new Array(u), f;
  for (a = 0; a < u; ++a)
    (l = t[a]) && (p[a] = f = o.call(l, l.__data__, a, t) + "", h.has(f) ? r[a] = l : h.set(f, l));
  for (a = 0; a < d; ++a)
    f = o.call(n, s[a], a, s) + "", (l = h.get(f)) ? (i[a] = l, l.__data__ = s[a], h.delete(f)) : e[a] = new hc(n, s[a]);
  for (a = 0; a < u; ++a)
    (l = t[a]) && h.get(p[a]) === l && (r[a] = l);
}
function u4(n) {
  return n.__data__;
}
function c4(n, t) {
  if (!arguments.length) return Array.from(this, u4);
  var e = t ? l4 : a4, i = this._parents, r = this._groups;
  typeof n != "function" && (n = o4(n));
  for (var s = r.length, o = new Array(s), a = new Array(s), l = new Array(s), h = 0; h < s; ++h) {
    var u = i[h], d = r[h], p = d.length, f = h4(n.call(u, u && u.__data__, h, i)), m = f.length, b = a[h] = new Array(m), x = o[h] = new Array(m), y = l[h] = new Array(p);
    e(u, d, b, x, y, f, t);
    for (var v = 0, k = 0, C, E; v < m; ++v)
      if (C = b[v]) {
        for (v >= k && (k = v + 1); !(E = x[k]) && ++k < m; ) ;
        C._next = E || null;
      }
  }
  return o = new Si(o, i), o._enter = a, o._exit = l, o;
}
function h4(n) {
  return typeof n == "object" && "length" in n ? n : Array.from(n);
}
function f4() {
  return new Si(this._exit || this._groups.map(fm), this._parents);
}
function d4(n, t, e) {
  var i = this.enter(), r = this, s = this.exit();
  return typeof n == "function" ? (i = n(i), i && (i = i.selection())) : i = i.append(n + ""), t != null && (r = t(r), r && (r = r.selection())), e == null ? s.remove() : e(s), i && r ? i.merge(r).order() : r;
}
function p4(n) {
  for (var t = n.selection ? n.selection() : n, e = this._groups, i = t._groups, r = e.length, s = i.length, o = Math.min(r, s), a = new Array(r), l = 0; l < o; ++l)
    for (var h = e[l], u = i[l], d = h.length, p = a[l] = new Array(d), f, m = 0; m < d; ++m)
      (f = h[m] || u[m]) && (p[m] = f);
  for (; l < r; ++l)
    a[l] = e[l];
  return new Si(a, this._parents);
}
function g4() {
  for (var n = this._groups, t = -1, e = n.length; ++t < e; )
    for (var i = n[t], r = i.length - 1, s = i[r], o; --r >= 0; )
      (o = i[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function m4(n) {
  n || (n = y4);
  function t(d, p) {
    return d && p ? n(d.__data__, p.__data__) : !d - !p;
  }
  for (var e = this._groups, i = e.length, r = new Array(i), s = 0; s < i; ++s) {
    for (var o = e[s], a = o.length, l = r[s] = new Array(a), h, u = 0; u < a; ++u)
      (h = o[u]) && (l[u] = h);
    l.sort(t);
  }
  return new Si(r, this._parents).order();
}
function y4(n, t) {
  return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function b4() {
  var n = arguments[0];
  return arguments[0] = this, n.apply(null, arguments), this;
}
function v4() {
  return Array.from(this);
}
function w4() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length; r < s; ++r) {
      var o = i[r];
      if (o) return o;
    }
  return null;
}
function x4() {
  let n = 0;
  for (const t of this) ++n;
  return n;
}
function _4() {
  return !this.node();
}
function S4(n) {
  for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
    for (var r = t[e], s = 0, o = r.length, a; s < o; ++s)
      (a = r[s]) && n.call(a, a.__data__, s, r);
  return this;
}
function k4(n) {
  return function() {
    this.removeAttribute(n);
  };
}
function A4(n) {
  return function() {
    this.removeAttributeNS(n.space, n.local);
  };
}
function N4(n, t) {
  return function() {
    this.setAttribute(n, t);
  };
}
function C4(n, t) {
  return function() {
    this.setAttributeNS(n.space, n.local, t);
  };
}
function P4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttribute(n) : this.setAttribute(n, e);
  };
}
function L4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e);
  };
}
function I4(n, t) {
  var e = am(n);
  if (arguments.length < 2) {
    var i = this.node();
    return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e);
  }
  return this.each((t == null ? e.local ? A4 : k4 : typeof t == "function" ? e.local ? L4 : P4 : e.local ? C4 : N4)(e, t));
}
function dm(n) {
  return n.ownerDocument && n.ownerDocument.defaultView || n.document && n || n.defaultView;
}
function E4(n) {
  return function() {
    this.style.removeProperty(n);
  };
}
function O4(n, t, e) {
  return function() {
    this.style.setProperty(n, t, e);
  };
}
function T4(n, t, e) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.style.removeProperty(n) : this.style.setProperty(n, i, e);
  };
}
function F4(n, t, e) {
  return arguments.length > 1 ? this.each((t == null ? E4 : typeof t == "function" ? T4 : O4)(n, t, e ?? "")) : M4(this.node(), n);
}
function M4(n, t) {
  return n.style.getPropertyValue(t) || dm(n).getComputedStyle(n, null).getPropertyValue(t);
}
function R4(n) {
  return function() {
    delete this[n];
  };
}
function D4(n, t) {
  return function() {
    this[n] = t;
  };
}
function B4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? delete this[n] : this[n] = e;
  };
}
function j4(n, t) {
  return arguments.length > 1 ? this.each((t == null ? R4 : typeof t == "function" ? B4 : D4)(n, t)) : this.node()[n];
}
function pm(n) {
  return n.trim().split(/^|\s+/);
}
function Rd(n) {
  return n.classList || new gm(n);
}
function gm(n) {
  this._node = n, this._names = pm(n.getAttribute("class") || "");
}
gm.prototype = {
  add: function(n) {
    var t = this._names.indexOf(n);
    t < 0 && (this._names.push(n), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(n) {
    var t = this._names.indexOf(n);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(n) {
    return this._names.indexOf(n) >= 0;
  }
};
function mm(n, t) {
  for (var e = Rd(n), i = -1, r = t.length; ++i < r; ) e.add(t[i]);
}
function ym(n, t) {
  for (var e = Rd(n), i = -1, r = t.length; ++i < r; ) e.remove(t[i]);
}
function q4(n) {
  return function() {
    mm(this, n);
  };
}
function z4(n) {
  return function() {
    ym(this, n);
  };
}
function $4(n, t) {
  return function() {
    (t.apply(this, arguments) ? mm : ym)(this, n);
  };
}
function U4(n, t) {
  var e = pm(n + "");
  if (arguments.length < 2) {
    for (var i = Rd(this.node()), r = -1, s = e.length; ++r < s; ) if (!i.contains(e[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? $4 : t ? q4 : z4)(e, t));
}
function W4() {
  this.textContent = "";
}
function H4(n) {
  return function() {
    this.textContent = n;
  };
}
function G4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function V4(n) {
  return arguments.length ? this.each(n == null ? W4 : (typeof n == "function" ? G4 : H4)(n)) : this.node().textContent;
}
function Y4() {
  this.innerHTML = "";
}
function K4(n) {
  return function() {
    this.innerHTML = n;
  };
}
function X4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function J4(n) {
  return arguments.length ? this.each(n == null ? Y4 : (typeof n == "function" ? X4 : K4)(n)) : this.node().innerHTML;
}
function Z4() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Q4() {
  return this.each(Z4);
}
function t_() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function e_() {
  return this.each(t_);
}
function n_(n) {
  var t = typeof n == "function" ? n : lm(n);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function i_() {
  return null;
}
function r_(n, t) {
  var e = typeof n == "function" ? n : lm(n), i = t == null ? i_ : typeof t == "function" ? t : um(t);
  return this.select(function() {
    return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null);
  });
}
function s_() {
  var n = this.parentNode;
  n && n.removeChild(this);
}
function o_() {
  return this.each(s_);
}
function a_() {
  var n = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function l_() {
  var n = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function u_(n) {
  return this.select(n ? l_ : a_);
}
function c_(n) {
  return arguments.length ? this.property("__data__", n) : this.node().__data__;
}
function h_(n) {
  return function(t) {
    n.call(this, t, this.__data__);
  };
}
function f_(n) {
  return n.trim().split(/^|\s+/).map(function(t) {
    var e = "", i = t.indexOf(".");
    return i >= 0 && (e = t.slice(i + 1), t = t.slice(0, i)), { type: t, name: e };
  });
}
function d_(n) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var e = 0, i = -1, r = t.length, s; e < r; ++e)
        s = t[e], (!n.type || s.type === n.type) && s.name === n.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++i] = s;
      ++i ? t.length = i : delete this.__on;
    }
  };
}
function p_(n, t, e) {
  return function() {
    var i = this.__on, r, s = h_(t);
    if (i) {
      for (var o = 0, a = i.length; o < a; ++o)
        if ((r = i[o]).type === n.type && r.name === n.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = e), r.value = t;
          return;
        }
    }
    this.addEventListener(n.type, s, e), r = { type: n.type, name: n.name, value: t, listener: s, options: e }, i ? i.push(r) : this.__on = [r];
  };
}
function g_(n, t, e) {
  var i = f_(n + ""), r, s = i.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, h = a.length, u; l < h; ++l)
        for (r = 0, u = a[l]; r < s; ++r)
          if ((o = i[r]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (a = t ? p_ : d_, r = 0; r < s; ++r) this.each(a(i[r], t, e));
  return this;
}
function bm(n, t, e) {
  var i = dm(n), r = i.CustomEvent;
  typeof r == "function" ? r = new r(t, e) : (r = i.document.createEvent("Event"), e ? (r.initEvent(t, e.bubbles, e.cancelable), r.detail = e.detail) : r.initEvent(t, !1, !1)), n.dispatchEvent(r);
}
function m_(n, t) {
  return function() {
    return bm(this, n, t);
  };
}
function y_(n, t) {
  return function() {
    return bm(this, n, t.apply(this, arguments));
  };
}
function b_(n, t) {
  return this.each((typeof t == "function" ? y_ : m_)(n, t));
}
function* v_() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length, o; r < s; ++r)
      (o = i[r]) && (yield o);
}
var vm = [null];
function Si(n, t) {
  this._groups = n, this._parents = t;
}
function w_() {
  return this;
}
Si.prototype = {
  constructor: Si,
  select: Wx,
  selectAll: Yx,
  selectChild: Qx,
  selectChildren: i4,
  filter: r4,
  data: c4,
  enter: s4,
  exit: f4,
  join: d4,
  merge: p4,
  selection: w_,
  order: g4,
  sort: m4,
  call: b4,
  nodes: v4,
  node: w4,
  size: x4,
  empty: _4,
  each: S4,
  attr: I4,
  style: F4,
  property: j4,
  classed: U4,
  text: V4,
  html: J4,
  raise: Q4,
  lower: e_,
  append: n_,
  insert: r_,
  remove: o_,
  clone: u_,
  datum: c_,
  on: g_,
  dispatch: b_,
  [Symbol.iterator]: v_
};
function x_(n) {
  return typeof n == "string" ? new Si([[document.querySelector(n)]], [document.documentElement]) : new Si([[n]], vm);
}
function __(n) {
  return typeof n == "string" ? new Si([document.querySelectorAll(n)], [document.documentElement]) : new Si([cm(n)], vm);
}
function Yu(n, t) {
  return n == null || t == null ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function S_(n, t) {
  return n == null || t == null ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
}
function wm(n) {
  let t, e, i;
  n.length !== 2 ? (t = Yu, e = (a, l) => Yu(n(a), l), i = (a, l) => n(a) - l) : (t = n === Yu || n === S_ ? n : k_, e = n, i = n);
  function r(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) < 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function s(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) <= 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function o(a, l, h = 0, u = a.length) {
    const d = r(a, l, h, u - 1);
    return d > h && i(a[d - 1], l) > -i(a[d], l) ? d - 1 : d;
  }
  return { left: r, center: o, right: s };
}
function k_() {
  return 0;
}
function A_(n) {
  return n === null ? NaN : +n;
}
const N_ = wm(Yu), C_ = N_.right;
wm(A_).center;
const P_ = Math.sqrt(50), L_ = Math.sqrt(10), I_ = Math.sqrt(2);
function fc(n, t, e) {
  const i = (t - n) / Math.max(0, e), r = Math.floor(Math.log10(i)), s = i / Math.pow(10, r), o = s >= P_ ? 10 : s >= L_ ? 5 : s >= I_ ? 2 : 1;
  let a, l, h;
  return r < 0 ? (h = Math.pow(10, -r) / o, a = Math.round(n * h), l = Math.round(t * h), a / h < n && ++a, l / h > t && --l, h = -h) : (h = Math.pow(10, r) * o, a = Math.round(n / h), l = Math.round(t / h), a * h < n && ++a, l * h > t && --l), l < a && 0.5 <= e && e < 2 ? fc(n, t, e * 2) : [a, l, h];
}
function E_(n, t, e) {
  if (t = +t, n = +n, e = +e, !(e > 0)) return [];
  if (n === t) return [n];
  const i = t < n, [r, s, o] = i ? fc(t, n, e) : fc(n, t, e);
  if (!(s >= r)) return [];
  const a = s - r + 1, l = new Array(a);
  if (i)
    if (o < 0) for (let h = 0; h < a; ++h) l[h] = (s - h) / -o;
    else for (let h = 0; h < a; ++h) l[h] = (s - h) * o;
  else if (o < 0) for (let h = 0; h < a; ++h) l[h] = (r + h) / -o;
  else for (let h = 0; h < a; ++h) l[h] = (r + h) * o;
  return l;
}
function Af(n, t, e) {
  return t = +t, n = +n, e = +e, fc(n, t, e)[2];
}
function O_(n, t, e) {
  t = +t, n = +n, e = +e;
  const i = t < n, r = i ? Af(t, n, e) : Af(n, t, e);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function T_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(n);
      break;
    default:
      this.range(t).domain(n);
      break;
  }
  return this;
}
function F_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof n == "function" ? this.interpolator(n) : this.range(n);
      break;
    }
    default: {
      this.domain(n), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
function Dd(n, t, e) {
  n.prototype = t.prototype = e, e.constructor = n;
}
function xm(n, t) {
  var e = Object.create(n.prototype);
  for (var i in t) e[i] = t[i];
  return e;
}
function Ul() {
}
var El = 0.7, dc = 1 / El, wa = "\\s*([+-]?\\d+)\\s*", Ol = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Fr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", M_ = /^#([0-9a-f]{3,8})$/, R_ = new RegExp(`^rgb\\(${wa},${wa},${wa}\\)$`), D_ = new RegExp(`^rgb\\(${Fr},${Fr},${Fr}\\)$`), B_ = new RegExp(`^rgba\\(${wa},${wa},${wa},${Ol}\\)$`), j_ = new RegExp(`^rgba\\(${Fr},${Fr},${Fr},${Ol}\\)$`), q_ = new RegExp(`^hsl\\(${Ol},${Fr},${Fr}\\)$`), z_ = new RegExp(`^hsla\\(${Ol},${Fr},${Fr},${Ol}\\)$`), Ng = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Dd(Ul, Aa, {
  copy(n) {
    return Object.assign(new this.constructor(), this, n);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Cg,
  // Deprecated! Use color.formatHex.
  formatHex: Cg,
  formatHex8: $_,
  formatHsl: U_,
  formatRgb: Pg,
  toString: Pg
});
function Cg() {
  return this.rgb().formatHex();
}
function $_() {
  return this.rgb().formatHex8();
}
function U_() {
  return _m(this).formatHsl();
}
function Pg() {
  return this.rgb().formatRgb();
}
function Aa(n) {
  var t, e;
  return n = (n + "").trim().toLowerCase(), (t = M_.exec(n)) ? (e = t[1].length, t = parseInt(t[1], 16), e === 6 ? Lg(t) : e === 3 ? new _i(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : e === 8 ? Mu(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : e === 4 ? Mu(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = R_.exec(n)) ? new _i(t[1], t[2], t[3], 1) : (t = D_.exec(n)) ? new _i(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = B_.exec(n)) ? Mu(t[1], t[2], t[3], t[4]) : (t = j_.exec(n)) ? Mu(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = q_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, 1) : (t = z_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, t[4]) : Ng.hasOwnProperty(n) ? Lg(Ng[n]) : n === "transparent" ? new _i(NaN, NaN, NaN, 0) : null;
}
function Lg(n) {
  return new _i(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function Mu(n, t, e, i) {
  return i <= 0 && (n = t = e = NaN), new _i(n, t, e, i);
}
function W_(n) {
  return n instanceof Ul || (n = Aa(n)), n ? (n = n.rgb(), new _i(n.r, n.g, n.b, n.opacity)) : new _i();
}
function Nn(n, t, e, i) {
  return arguments.length === 1 ? W_(n) : new _i(n, t, e, i ?? 1);
}
function _i(n, t, e, i) {
  this.r = +n, this.g = +t, this.b = +e, this.opacity = +i;
}
Dd(_i, Nn, xm(Ul, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new _i(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? El : Math.pow(El, n), new _i(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new _i(vo(this.r), vo(this.g), vo(this.b), pc(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ig,
  // Deprecated! Use color.formatHex.
  formatHex: Ig,
  formatHex8: H_,
  formatRgb: Eg,
  toString: Eg
}));
function Ig() {
  return `#${co(this.r)}${co(this.g)}${co(this.b)}`;
}
function H_() {
  return `#${co(this.r)}${co(this.g)}${co(this.b)}${co((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Eg() {
  const n = pc(this.opacity);
  return `${n === 1 ? "rgb(" : "rgba("}${vo(this.r)}, ${vo(this.g)}, ${vo(this.b)}${n === 1 ? ")" : `, ${n})`}`;
}
function pc(n) {
  return isNaN(n) ? 1 : Math.max(0, Math.min(1, n));
}
function vo(n) {
  return Math.max(0, Math.min(255, Math.round(n) || 0));
}
function co(n) {
  return n = vo(n), (n < 16 ? "0" : "") + n.toString(16);
}
function Og(n, t, e, i) {
  return i <= 0 ? n = t = e = NaN : e <= 0 || e >= 1 ? n = t = NaN : t <= 0 && (n = NaN), new pr(n, t, e, i);
}
function _m(n) {
  if (n instanceof pr) return new pr(n.h, n.s, n.l, n.opacity);
  if (n instanceof Ul || (n = Aa(n)), !n) return new pr();
  if (n instanceof pr) return n;
  n = n.rgb();
  var t = n.r / 255, e = n.g / 255, i = n.b / 255, r = Math.min(t, e, i), s = Math.max(t, e, i), o = NaN, a = s - r, l = (s + r) / 2;
  return a ? (t === s ? o = (e - i) / a + (e < i) * 6 : e === s ? o = (i - t) / a + 2 : o = (t - e) / a + 4, a /= l < 0.5 ? s + r : 2 - s - r, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new pr(o, a, l, n.opacity);
}
function G_(n, t, e, i) {
  return arguments.length === 1 ? _m(n) : new pr(n, t, e, i ?? 1);
}
function pr(n, t, e, i) {
  this.h = +n, this.s = +t, this.l = +e, this.opacity = +i;
}
Dd(pr, G_, xm(Ul, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new pr(this.h, this.s, this.l * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? El : Math.pow(El, n), new pr(this.h, this.s, this.l * n, this.opacity);
  },
  rgb() {
    var n = this.h % 360 + (this.h < 0) * 360, t = isNaN(n) || isNaN(this.s) ? 0 : this.s, e = this.l, i = e + (e < 0.5 ? e : 1 - e) * t, r = 2 * e - i;
    return new _i(
      Rh(n >= 240 ? n - 240 : n + 120, r, i),
      Rh(n, r, i),
      Rh(n < 120 ? n + 240 : n - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new pr(Tg(this.h), Ru(this.s), Ru(this.l), pc(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const n = pc(this.opacity);
    return `${n === 1 ? "hsl(" : "hsla("}${Tg(this.h)}, ${Ru(this.s) * 100}%, ${Ru(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`;
  }
}));
function Tg(n) {
  return n = (n || 0) % 360, n < 0 ? n + 360 : n;
}
function Ru(n) {
  return Math.max(0, Math.min(1, n || 0));
}
function Rh(n, t, e) {
  return (n < 60 ? t + (e - t) * n / 60 : n < 180 ? e : n < 240 ? t + (e - t) * (240 - n) / 60 : t) * 255;
}
const Bd = (n) => () => n;
function V_(n, t) {
  return function(e) {
    return n + e * t;
  };
}
function Y_(n, t, e) {
  return n = Math.pow(n, e), t = Math.pow(t, e) - n, e = 1 / e, function(i) {
    return Math.pow(n + i * t, e);
  };
}
function K_(n) {
  return (n = +n) == 1 ? Sm : function(t, e) {
    return e - t ? Y_(t, e, n) : Bd(isNaN(t) ? e : t);
  };
}
function Sm(n, t) {
  var e = t - n;
  return e ? V_(n, e) : Bd(isNaN(n) ? t : n);
}
const Fg = function n(t) {
  var e = K_(t);
  function i(r, s) {
    var o = e((r = Nn(r)).r, (s = Nn(s)).r), a = e(r.g, s.g), l = e(r.b, s.b), h = Sm(r.opacity, s.opacity);
    return function(u) {
      return r.r = o(u), r.g = a(u), r.b = l(u), r.opacity = h(u), r + "";
    };
  }
  return i.gamma = n, i;
}(1);
function X_(n, t) {
  t || (t = []);
  var e = n ? Math.min(t.length, n.length) : 0, i = t.slice(), r;
  return function(s) {
    for (r = 0; r < e; ++r) i[r] = n[r] * (1 - s) + t[r] * s;
    return i;
  };
}
function J_(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function Z_(n, t) {
  var e = t ? t.length : 0, i = n ? Math.min(e, n.length) : 0, r = new Array(i), s = new Array(e), o;
  for (o = 0; o < i; ++o) r[o] = $c(n[o], t[o]);
  for (; o < e; ++o) s[o] = t[o];
  return function(a) {
    for (o = 0; o < i; ++o) s[o] = r[o](a);
    return s;
  };
}
function Q_(n, t) {
  var e = /* @__PURE__ */ new Date();
  return n = +n, t = +t, function(i) {
    return e.setTime(n * (1 - i) + t * i), e;
  };
}
function gc(n, t) {
  return n = +n, t = +t, function(e) {
    return n * (1 - e) + t * e;
  };
}
function tS(n, t) {
  var e = {}, i = {}, r;
  (n === null || typeof n != "object") && (n = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in n ? e[r] = $c(n[r], t[r]) : i[r] = t[r];
  return function(s) {
    for (r in e) i[r] = e[r](s);
    return i;
  };
}
var Nf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Dh = new RegExp(Nf.source, "g");
function eS(n) {
  return function() {
    return n;
  };
}
function nS(n) {
  return function(t) {
    return n(t) + "";
  };
}
function iS(n, t) {
  var e = Nf.lastIndex = Dh.lastIndex = 0, i, r, s, o = -1, a = [], l = [];
  for (n = n + "", t = t + ""; (i = Nf.exec(n)) && (r = Dh.exec(t)); )
    (s = r.index) > e && (s = t.slice(e, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, l.push({ i: o, x: gc(i, r) })), e = Dh.lastIndex;
  return e < t.length && (s = t.slice(e), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? nS(l[0].x) : eS(t) : (t = l.length, function(h) {
    for (var u = 0, d; u < t; ++u) a[(d = l[u]).i] = d.x(h);
    return a.join("");
  });
}
function $c(n, t) {
  var e = typeof t, i;
  return t == null || e === "boolean" ? Bd(t) : (e === "number" ? gc : e === "string" ? (i = Aa(t)) ? (t = i, Fg) : iS : t instanceof Aa ? Fg : t instanceof Date ? Q_ : J_(t) ? X_ : Array.isArray(t) ? Z_ : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? tS : gc)(n, t);
}
function km(n, t) {
  return n = +n, t = +t, function(e) {
    return Math.round(n * (1 - e) + t * e);
  };
}
function rS(n) {
  return function() {
    return n;
  };
}
function sS(n) {
  return +n;
}
var Mg = [0, 1];
function Ts(n) {
  return n;
}
function Cf(n, t) {
  return (t -= n = +n) ? function(e) {
    return (e - n) / t;
  } : rS(isNaN(t) ? NaN : 0.5);
}
function oS(n, t) {
  var e;
  return n > t && (e = n, n = t, t = e), function(i) {
    return Math.max(n, Math.min(t, i));
  };
}
function aS(n, t, e) {
  var i = n[0], r = n[1], s = t[0], o = t[1];
  return r < i ? (i = Cf(r, i), s = e(o, s)) : (i = Cf(i, r), s = e(s, o)), function(a) {
    return s(i(a));
  };
}
function lS(n, t, e) {
  var i = Math.min(n.length, t.length) - 1, r = new Array(i), s = new Array(i), o = -1;
  for (n[i] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o < i; )
    r[o] = Cf(n[o], n[o + 1]), s[o] = e(t[o], t[o + 1]);
  return function(a) {
    var l = C_(n, a, 1, i) - 1;
    return s[l](r[l](a));
  };
}
function uS(n, t) {
  return t.domain(n.domain()).range(n.range()).interpolate(n.interpolate()).clamp(n.clamp()).unknown(n.unknown());
}
function cS() {
  var n = Mg, t = Mg, e = $c, i, r, s, o = Ts, a, l, h;
  function u() {
    var p = Math.min(n.length, t.length);
    return o !== Ts && (o = oS(n[0], n[p - 1])), a = p > 2 ? lS : aS, l = h = null, d;
  }
  function d(p) {
    return p == null || isNaN(p = +p) ? s : (l || (l = a(n.map(i), t, e)))(i(o(p)));
  }
  return d.invert = function(p) {
    return o(r((h || (h = a(t, n.map(i), gc)))(p)));
  }, d.domain = function(p) {
    return arguments.length ? (n = Array.from(p, sS), u()) : n.slice();
  }, d.range = function(p) {
    return arguments.length ? (t = Array.from(p), u()) : t.slice();
  }, d.rangeRound = function(p) {
    return t = Array.from(p), e = km, u();
  }, d.clamp = function(p) {
    return arguments.length ? (o = p ? !0 : Ts, u()) : o !== Ts;
  }, d.interpolate = function(p) {
    return arguments.length ? (e = p, u()) : e;
  }, d.unknown = function(p) {
    return arguments.length ? (s = p, d) : s;
  }, function(p, f) {
    return i = p, r = f, u();
  };
}
function hS() {
  return cS()(Ts, Ts);
}
function fS(n) {
  return Math.abs(n = Math.round(n)) >= 1e21 ? n.toLocaleString("en").replace(/,/g, "") : n.toString(10);
}
function mc(n, t) {
  if ((e = (n = t ? n.toExponential(t - 1) : n.toExponential()).indexOf("e")) < 0) return null;
  var e, i = n.slice(0, e);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +n.slice(e + 1)
  ];
}
function Na(n) {
  return n = mc(Math.abs(n)), n ? n[1] : NaN;
}
function dS(n, t) {
  return function(e, i) {
    for (var r = e.length, s = [], o = 0, a = n[0], l = 0; r > 0 && a > 0 && (l + a + 1 > i && (a = Math.max(1, i - l)), s.push(e.substring(r -= a, r + a)), !((l += a + 1) > i)); )
      a = n[o = (o + 1) % n.length];
    return s.reverse().join(t);
  };
}
function pS(n) {
  return function(t) {
    return t.replace(/[0-9]/g, function(e) {
      return n[+e];
    });
  };
}
var gS = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function yc(n) {
  if (!(t = gS.exec(n))) throw new Error("invalid format: " + n);
  var t;
  return new jd({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
yc.prototype = jd.prototype;
function jd(n) {
  this.fill = n.fill === void 0 ? " " : n.fill + "", this.align = n.align === void 0 ? ">" : n.align + "", this.sign = n.sign === void 0 ? "-" : n.sign + "", this.symbol = n.symbol === void 0 ? "" : n.symbol + "", this.zero = !!n.zero, this.width = n.width === void 0 ? void 0 : +n.width, this.comma = !!n.comma, this.precision = n.precision === void 0 ? void 0 : +n.precision, this.trim = !!n.trim, this.type = n.type === void 0 ? "" : n.type + "";
}
jd.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function mS(n) {
  t: for (var t = n.length, e = 1, i = -1, r; e < t; ++e)
    switch (n[e]) {
      case ".":
        i = r = e;
        break;
      case "0":
        i === 0 && (i = e), r = e;
        break;
      default:
        if (!+n[e]) break t;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? n.slice(0, i) + n.slice(r + 1) : n;
}
var Am;
function yS(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1], s = r - (Am = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = i.length;
  return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + mc(n, Math.max(0, t + s - 1))[0];
}
function Rg(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const Dg = {
  "%": (n, t) => (n * 100).toFixed(t),
  b: (n) => Math.round(n).toString(2),
  c: (n) => n + "",
  d: fS,
  e: (n, t) => n.toExponential(t),
  f: (n, t) => n.toFixed(t),
  g: (n, t) => n.toPrecision(t),
  o: (n) => Math.round(n).toString(8),
  p: (n, t) => Rg(n * 100, t),
  r: Rg,
  s: yS,
  X: (n) => Math.round(n).toString(16).toUpperCase(),
  x: (n) => Math.round(n).toString(16)
};
function Bg(n) {
  return n;
}
var jg = Array.prototype.map, qg = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function bS(n) {
  var t = n.grouping === void 0 || n.thousands === void 0 ? Bg : dS(jg.call(n.grouping, Number), n.thousands + ""), e = n.currency === void 0 ? "" : n.currency[0] + "", i = n.currency === void 0 ? "" : n.currency[1] + "", r = n.decimal === void 0 ? "." : n.decimal + "", s = n.numerals === void 0 ? Bg : pS(jg.call(n.numerals, String)), o = n.percent === void 0 ? "%" : n.percent + "", a = n.minus === void 0 ? "−" : n.minus + "", l = n.nan === void 0 ? "NaN" : n.nan + "";
  function h(d) {
    d = yc(d);
    var p = d.fill, f = d.align, m = d.sign, b = d.symbol, x = d.zero, y = d.width, v = d.comma, k = d.precision, C = d.trim, E = d.type;
    E === "n" ? (v = !0, E = "g") : Dg[E] || (k === void 0 && (k = 12), C = !0, E = "g"), (x || p === "0" && f === "=") && (x = !0, p = "0", f = "=");
    var q = b === "$" ? e : b === "#" && /[boxX]/.test(E) ? "0" + E.toLowerCase() : "", T = b === "$" ? i : /[%p]/.test(E) ? o : "", F = Dg[E], M = /[defgprs%]/.test(E);
    k = k === void 0 ? 6 : /[gprs]/.test(E) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function B(P) {
      var A = q, I = T, S, X, H;
      if (E === "c")
        I = F(P) + I, P = "";
      else {
        P = +P;
        var j = P < 0 || 1 / P < 0;
        if (P = isNaN(P) ? l : F(Math.abs(P), k), C && (P = mS(P)), j && +P == 0 && m !== "+" && (j = !1), A = (j ? m === "(" ? m : a : m === "-" || m === "(" ? "" : m) + A, I = (E === "s" ? qg[8 + Am / 3] : "") + I + (j && m === "(" ? ")" : ""), M) {
          for (S = -1, X = P.length; ++S < X; )
            if (H = P.charCodeAt(S), 48 > H || H > 57) {
              I = (H === 46 ? r + P.slice(S + 1) : P.slice(S)) + I, P = P.slice(0, S);
              break;
            }
        }
      }
      v && !x && (P = t(P, 1 / 0));
      var Q = A.length + P.length + I.length, G = Q < y ? new Array(y - Q + 1).join(p) : "";
      switch (v && x && (P = t(G + P, G.length ? y - I.length : 1 / 0), G = ""), f) {
        case "<":
          P = A + P + I + G;
          break;
        case "=":
          P = A + G + P + I;
          break;
        case "^":
          P = G.slice(0, Q = G.length >> 1) + A + P + I + G.slice(Q);
          break;
        default:
          P = G + A + P + I;
          break;
      }
      return s(P);
    }
    return B.toString = function() {
      return d + "";
    }, B;
  }
  function u(d, p) {
    var f = h((d = yc(d), d.type = "f", d)), m = Math.max(-8, Math.min(8, Math.floor(Na(p) / 3))) * 3, b = Math.pow(10, -m), x = qg[8 + m / 3];
    return function(y) {
      return f(b * y) + x;
    };
  }
  return {
    format: h,
    formatPrefix: u
  };
}
var Du, qd, Nm;
vS({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function vS(n) {
  return Du = bS(n), qd = Du.format, Nm = Du.formatPrefix, Du;
}
function Cm(n) {
  return Math.max(0, -Na(Math.abs(n)));
}
function wS(n, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Na(t) / 3))) * 3 - Na(Math.abs(n)));
}
function xS(n, t) {
  return n = Math.abs(n), t = Math.abs(t) - n, Math.max(0, Na(t) - Na(n)) + 1;
}
function _S(n, t, e, i) {
  var r = O_(n, t, e), s;
  switch (i = yc(i ?? ",f"), i.type) {
    case "s": {
      var o = Math.max(Math.abs(n), Math.abs(t));
      return i.precision == null && !isNaN(s = wS(r, o)) && (i.precision = s), Nm(i, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(s = xS(r, Math.max(Math.abs(n), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(s = Cm(r)) && (i.precision = s - (i.type === "%") * 2);
      break;
    }
  }
  return qd(i);
}
function Pm(n) {
  var t = n.domain;
  return n.ticks = function(e) {
    var i = t();
    return E_(i[0], i[i.length - 1], e ?? 10);
  }, n.tickFormat = function(e, i) {
    var r = t();
    return _S(r[0], r[r.length - 1], e ?? 10, i);
  }, n.nice = function(e) {
    e == null && (e = 10);
    var i = t(), r = 0, s = i.length - 1, o = i[r], a = i[s], l, h, u = 10;
    for (a < o && (h = o, o = a, a = h, h = r, r = s, s = h); u-- > 0; ) {
      if (h = Af(o, a, e), h === l)
        return i[r] = o, i[s] = a, t(i);
      if (h > 0)
        o = Math.floor(o / h) * h, a = Math.ceil(a / h) * h;
      else if (h < 0)
        o = Math.ceil(o * h) / h, a = Math.floor(a * h) / h;
      else
        break;
      l = h;
    }
    return n;
  }, n;
}
function Lm() {
  var n = hS();
  return n.copy = function() {
    return uS(n, Lm());
  }, T_.apply(n, arguments), Pm(n);
}
function SS() {
  var n = 0, t = 1, e, i, r, s, o = Ts, a = !1, l;
  function h(d) {
    return d == null || isNaN(d = +d) ? l : o(r === 0 ? 0.5 : (d = (s(d) - e) * r, a ? Math.max(0, Math.min(1, d)) : d));
  }
  h.domain = function(d) {
    return arguments.length ? ([n, t] = d, e = s(n = +n), i = s(t = +t), r = e === i ? 0 : 1 / (i - e), h) : [n, t];
  }, h.clamp = function(d) {
    return arguments.length ? (a = !!d, h) : a;
  }, h.interpolator = function(d) {
    return arguments.length ? (o = d, h) : o;
  };
  function u(d) {
    return function(p) {
      var f, m;
      return arguments.length ? ([f, m] = p, o = d(f, m), h) : [o(0), o(1)];
    };
  }
  return h.range = u($c), h.rangeRound = u(km), h.unknown = function(d) {
    return arguments.length ? (l = d, h) : l;
  }, function(d) {
    return s = d, e = d(n), i = d(t), r = e === i ? 0 : 1 / (i - e), h;
  };
}
function kS(n, t) {
  return t.domain(n.domain()).interpolator(n.interpolator()).clamp(n.clamp()).unknown(n.unknown());
}
function Im() {
  var n = Pm(SS()(Ts));
  return n.copy = function() {
    return kS(n, Im());
  }, F_.apply(n, arguments);
}
function AS(n) {
  return n;
}
var Ku = 1, Xu = 2, Pf = 3, vl = 4, zg = 1e-6;
function NS(n) {
  return "translate(" + n + ",0)";
}
function CS(n) {
  return "translate(0," + n + ")";
}
function PS(n) {
  return (t) => +n(t);
}
function LS(n, t) {
  return t = Math.max(0, n.bandwidth() - t * 2) / 2, n.round() && (t = Math.round(t)), (e) => +n(e) + t;
}
function IS() {
  return !this.__axis;
}
function Uc(n, t) {
  var e = [], i = null, r = null, s = 6, o = 6, a = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, h = n === Ku || n === vl ? -1 : 1, u = n === vl || n === Xu ? "x" : "y", d = n === Ku || n === Pf ? NS : CS;
  function p(f) {
    var m = i ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), b = r ?? (t.tickFormat ? t.tickFormat.apply(t, e) : AS), x = Math.max(s, 0) + a, y = t.range(), v = +y[0] + l, k = +y[y.length - 1] + l, C = (t.bandwidth ? LS : PS)(t.copy(), l), E = f.selection ? f.selection() : f, q = E.selectAll(".domain").data([null]), T = E.selectAll(".tick").data(m, t).order(), F = T.exit(), M = T.enter().append("g").attr("class", "tick"), B = T.select("line"), P = T.select("text");
    q = q.merge(q.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), T = T.merge(M), B = B.merge(M.append("line").attr("stroke", "currentColor").attr(u + "2", h * s)), P = P.merge(M.append("text").attr("fill", "currentColor").attr(u, h * x).attr("dy", n === Ku ? "0em" : n === Pf ? "0.71em" : "0.32em")), f !== E && (q = q.transition(f), T = T.transition(f), B = B.transition(f), P = P.transition(f), F = F.transition(f).attr("opacity", zg).attr("transform", function(A) {
      return isFinite(A = C(A)) ? d(A + l) : this.getAttribute("transform");
    }), M.attr("opacity", zg).attr("transform", function(A) {
      var I = this.parentNode.__axis;
      return d((I && isFinite(I = I(A)) ? I : C(A)) + l);
    })), F.remove(), q.attr("d", n === vl || n === Xu ? o ? "M" + h * o + "," + v + "H" + l + "V" + k + "H" + h * o : "M" + l + "," + v + "V" + k : o ? "M" + v + "," + h * o + "V" + l + "H" + k + "V" + h * o : "M" + v + "," + l + "H" + k), T.attr("opacity", 1).attr("transform", function(A) {
      return d(C(A) + l);
    }), B.attr(u + "2", h * s), P.attr(u, h * x).text(b), E.filter(IS).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", n === Xu ? "start" : n === vl ? "end" : "middle"), E.each(function() {
      this.__axis = C;
    });
  }
  return p.scale = function(f) {
    return arguments.length ? (t = f, p) : t;
  }, p.ticks = function() {
    return e = Array.from(arguments), p;
  }, p.tickArguments = function(f) {
    return arguments.length ? (e = f == null ? [] : Array.from(f), p) : e.slice();
  }, p.tickValues = function(f) {
    return arguments.length ? (i = f == null ? null : Array.from(f), p) : i && i.slice();
  }, p.tickFormat = function(f) {
    return arguments.length ? (r = f, p) : r;
  }, p.tickSize = function(f) {
    return arguments.length ? (s = o = +f, p) : s;
  }, p.tickSizeInner = function(f) {
    return arguments.length ? (s = +f, p) : s;
  }, p.tickSizeOuter = function(f) {
    return arguments.length ? (o = +f, p) : o;
  }, p.tickPadding = function(f) {
    return arguments.length ? (a = +f, p) : a;
  }, p.offset = function(f) {
    return arguments.length ? (l = +f, p) : l;
  }, p;
}
function ES(n) {
  return Uc(Ku, n);
}
function OS(n) {
  return Uc(Xu, n);
}
function TS(n) {
  return Uc(Pf, n);
}
function FS(n) {
  return Uc(vl, n);
}
const Lf = Math.PI, If = 2 * Lf, so = 1e-6, MS = If - so;
function Em(n) {
  this._ += n[0];
  for (let t = 1, e = n.length; t < e; ++t)
    this._ += arguments[t] + n[t];
}
function RS(n) {
  let t = Math.floor(n);
  if (!(t >= 0)) throw new Error(`invalid digits: ${n}`);
  if (t > 15) return Em;
  const e = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, s = i.length; r < s; ++r)
      this._ += Math.round(arguments[r] * e) / e + i[r];
  };
}
class zd {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Em : RS(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, i, r) {
    this._append`Q${+t},${+e},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, e, i, r, s, o) {
    this._append`C${+t},${+e},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, e, i, r, s) {
    if (t = +t, e = +e, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = i - t, h = r - e, u = o - t, d = a - e, p = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (p > so) if (!(Math.abs(d * l - h * u) > so) || !s)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let f = i - o, m = r - a, b = l * l + h * h, x = f * f + m * m, y = Math.sqrt(b), v = Math.sqrt(p), k = s * Math.tan((Lf - Math.acos((b + p - x) / (2 * y * v))) / 2), C = k / v, E = k / y;
      Math.abs(C - 1) > so && this._append`L${t + C * u},${e + C * d}`, this._append`A${s},${s},0,0,${+(d * f > u * m)},${this._x1 = t + E * l},${this._y1 = e + E * h}`;
    }
  }
  arc(t, e, i, r, s, o) {
    if (t = +t, e = +e, i = +i, o = !!o, i < 0) throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(r), l = i * Math.sin(r), h = t + a, u = e + l, d = 1 ^ o, p = o ? r - s : s - r;
    this._x1 === null ? this._append`M${h},${u}` : (Math.abs(this._x1 - h) > so || Math.abs(this._y1 - u) > so) && this._append`L${h},${u}`, i && (p < 0 && (p = p % If + If), p > MS ? this._append`A${i},${i},0,1,${d},${t - a},${e - l}A${i},${i},0,1,${d},${this._x1 = h},${this._y1 = u}` : p > so && this._append`A${i},${i},0,${+(p >= Lf)},${d},${this._x1 = t + i * Math.cos(s)},${this._y1 = e + i * Math.sin(s)}`);
  }
  rect(t, e, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
}
function Om() {
  return new zd();
}
Om.prototype = zd.prototype;
function Xi(n) {
  return function() {
    return n;
  };
}
const $g = Math.abs, oi = Math.atan2, io = Math.cos, DS = Math.max, Bh = Math.min, kr = Math.sin, Er = Math.sqrt, xi = 1e-12, Ca = Math.PI, bc = Ca / 2, Tm = 2 * Ca;
function BS(n) {
  return n > 1 ? 0 : n < -1 ? Ca : Math.acos(n);
}
function Ug(n) {
  return n >= 1 ? bc : n <= -1 ? -bc : Math.asin(n);
}
function Fm(n) {
  let t = 3;
  return n.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const i = Math.floor(e);
      if (!(i >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = i;
    }
    return n;
  }, () => new zd(t);
}
function jS(n) {
  return n.innerRadius;
}
function qS(n) {
  return n.outerRadius;
}
function zS(n) {
  return n.startAngle;
}
function $S(n) {
  return n.endAngle;
}
function US(n) {
  return n && n.padAngle;
}
function WS(n, t, e, i, r, s, o, a) {
  var l = e - n, h = i - t, u = o - r, d = a - s, p = d * l - u * h;
  if (!(p * p < xi))
    return p = (u * (t - s) - d * (n - r)) / p, [n + p * l, t + p * h];
}
function Bu(n, t, e, i, r, s, o) {
  var a = n - e, l = t - i, h = (o ? s : -s) / Er(a * a + l * l), u = h * l, d = -h * a, p = n + u, f = t + d, m = e + u, b = i + d, x = (p + m) / 2, y = (f + b) / 2, v = m - p, k = b - f, C = v * v + k * k, E = r - s, q = p * b - m * f, T = (k < 0 ? -1 : 1) * Er(DS(0, E * E * C - q * q)), F = (q * k - v * T) / C, M = (-q * v - k * T) / C, B = (q * k + v * T) / C, P = (-q * v + k * T) / C, A = F - x, I = M - y, S = B - x, X = P - y;
  return A * A + I * I > S * S + X * X && (F = B, M = P), {
    cx: F,
    cy: M,
    x01: -u,
    y01: -d,
    x11: F * (r / E - 1),
    y11: M * (r / E - 1)
  };
}
function HS() {
  var n = jS, t = qS, e = Xi(0), i = null, r = zS, s = $S, o = US, a = null, l = Fm(h);
  function h() {
    var u, d, p = +n.apply(this, arguments), f = +t.apply(this, arguments), m = r.apply(this, arguments) - bc, b = s.apply(this, arguments) - bc, x = $g(b - m), y = b > m;
    if (a || (a = u = l()), f < p && (d = f, f = p, p = d), !(f > xi)) a.moveTo(0, 0);
    else if (x > Tm - xi)
      a.moveTo(f * io(m), f * kr(m)), a.arc(0, 0, f, m, b, !y), p > xi && (a.moveTo(p * io(b), p * kr(b)), a.arc(0, 0, p, b, m, y));
    else {
      var v = m, k = b, C = m, E = b, q = x, T = x, F = o.apply(this, arguments) / 2, M = F > xi && (i ? +i.apply(this, arguments) : Er(p * p + f * f)), B = Bh($g(f - p) / 2, +e.apply(this, arguments)), P = B, A = B, I, S;
      if (M > xi) {
        var X = Ug(M / p * kr(F)), H = Ug(M / f * kr(F));
        (q -= X * 2) > xi ? (X *= y ? 1 : -1, C += X, E -= X) : (q = 0, C = E = (m + b) / 2), (T -= H * 2) > xi ? (H *= y ? 1 : -1, v += H, k -= H) : (T = 0, v = k = (m + b) / 2);
      }
      var j = f * io(v), Q = f * kr(v), G = p * io(E), ft = p * kr(E);
      if (B > xi) {
        var nt = f * io(k), N = f * kr(k), z = p * io(C), V = p * kr(C), Y;
        if (x < Ca)
          if (Y = WS(j, Q, z, V, nt, N, G, ft)) {
            var ot = j - Y[0], wt = Q - Y[1], mt = nt - Y[0], xt = N - Y[1], zt = 1 / kr(BS((ot * mt + wt * xt) / (Er(ot * ot + wt * wt) * Er(mt * mt + xt * xt))) / 2), Dt = Er(Y[0] * Y[0] + Y[1] * Y[1]);
            P = Bh(B, (p - Dt) / (zt - 1)), A = Bh(B, (f - Dt) / (zt + 1));
          } else
            P = A = 0;
      }
      T > xi ? A > xi ? (I = Bu(z, V, j, Q, f, A, y), S = Bu(nt, N, G, ft, f, A, y), a.moveTo(I.cx + I.x01, I.cy + I.y01), A < B ? a.arc(I.cx, I.cy, A, oi(I.y01, I.x01), oi(S.y01, S.x01), !y) : (a.arc(I.cx, I.cy, A, oi(I.y01, I.x01), oi(I.y11, I.x11), !y), a.arc(0, 0, f, oi(I.cy + I.y11, I.cx + I.x11), oi(S.cy + S.y11, S.cx + S.x11), !y), a.arc(S.cx, S.cy, A, oi(S.y11, S.x11), oi(S.y01, S.x01), !y))) : (a.moveTo(j, Q), a.arc(0, 0, f, v, k, !y)) : a.moveTo(j, Q), !(p > xi) || !(q > xi) ? a.lineTo(G, ft) : P > xi ? (I = Bu(G, ft, nt, N, p, -P, y), S = Bu(j, Q, z, V, p, -P, y), a.lineTo(I.cx + I.x01, I.cy + I.y01), P < B ? a.arc(I.cx, I.cy, P, oi(I.y01, I.x01), oi(S.y01, S.x01), !y) : (a.arc(I.cx, I.cy, P, oi(I.y01, I.x01), oi(I.y11, I.x11), !y), a.arc(0, 0, p, oi(I.cy + I.y11, I.cx + I.x11), oi(S.cy + S.y11, S.cx + S.x11), y), a.arc(S.cx, S.cy, P, oi(S.y11, S.x11), oi(S.y01, S.x01), !y))) : a.arc(0, 0, p, E, C, y);
    }
    if (a.closePath(), u) return a = null, u + "" || null;
  }
  return h.centroid = function() {
    var u = (+n.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Ca / 2;
    return [io(d) * u, kr(d) * u];
  }, h.innerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Xi(+u), h) : n;
  }, h.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Xi(+u), h) : t;
  }, h.cornerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Xi(+u), h) : e;
  }, h.padRadius = function(u) {
    return arguments.length ? (i = u == null ? null : typeof u == "function" ? u : Xi(+u), h) : i;
  }, h.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Xi(+u), h) : r;
  }, h.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : Xi(+u), h) : s;
  }, h.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Xi(+u), h) : o;
  }, h.context = function(u) {
    return arguments.length ? (a = u ?? null, h) : a;
  }, h;
}
const GS = {
  draw(n, t) {
    const e = Er(t / Ca);
    n.moveTo(e, 0), n.arc(0, 0, e, 0, Tm);
  }
}, VS = {
  draw(n, t) {
    const e = Er(t), i = -e / 2;
    n.rect(i, i, e, e);
  }
}, jh = Er(3), YS = {
  draw(n, t) {
    const e = -Er(t / (jh * 3));
    n.moveTo(0, e * 2), n.lineTo(-jh * e, -e), n.lineTo(jh * e, -e), n.closePath();
  }
};
function KS(n, t) {
  let e = null, i = Fm(r);
  n = typeof n == "function" ? n : Xi(n || GS), t = typeof t == "function" ? t : Xi(t === void 0 ? 64 : +t);
  function r() {
    let s;
    if (e || (e = s = i()), n.apply(this, arguments).draw(e, +t.apply(this, arguments)), s) return e = null, s + "" || null;
  }
  return r.type = function(s) {
    return arguments.length ? (n = typeof s == "function" ? s : Xi(s), r) : n;
  }, r.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Xi(+s), r) : t;
  }, r.context = function(s) {
    return arguments.length ? (e = s ?? null, r) : e;
  }, r;
}
const Re = {
  precisionFixed: Cm,
  format: qd,
  select: x_,
  selectAll: __,
  scaleLinear: Lm,
  scaleSequential: Im,
  axisTop: ES,
  axisBottom: TS,
  axisRight: OS,
  axisLeft: FS,
  symbol: KS,
  path: Om,
  arc: HS,
  symbolTriangle: YS,
  symbolSquare: VS
};
function ha(n) {
  return typeof n == "string" && n.length === 6 && !isNaN(+("0x" + n.replace("#", "")));
}
class XS {
  constructor({
    elementID: t,
    env: e = "production",
    main: i = !0,
    units: r = "decimal",
    decimalPlaces: s = 2,
    fractionRoundTo: o = 0,
    saw: a = null,
    app: l = !1,
    embed: h = !1,
    height: u = 0,
    width: d = 0,
    flipY: p = !1,
    flipX: f = !1,
    colors: m = {
      partA: "#1d9bc4",
      partB: "#127da1",
      partHover: "#29c778",
      partSelected: "#1bc319",
      stock: "#ffd166",
      text: "#ffffff"
    },
    options: b = {
      disableClick: !1,
      enableStretch: !0
    },
    vueComponent: x
  }) {
    tt(this, "env");
    tt(this, "main");
    //is this the main vis or not
    tt(this, "units", "decimal");
    tt(this, "decimalPlaces");
    tt(this, "fractionRoundTo");
    tt(this, "formatNumber", (t) => ne(
      t,
      this.units,
      this.decimalPlaces ?? 2,
      !1,
      this.fractionRoundTo ?? 0
    ).toString());
    tt(this, "saw");
    tt(this, "stockType");
    tt(this, "numUniqueShapes");
    tt(this, "app");
    tt(this, "embed");
    tt(this, "height");
    tt(this, "width");
    tt(this, "device");
    tt(this, "vueComponent");
    tt(this, "elWidth");
    tt(this, "elHeight");
    tt(this, "w");
    tt(this, "h");
    tt(this, "padding");
    tt(this, "mobileBreakpoint");
    //scales
    tt(this, "xScale", Re.scaleLinear());
    tt(this, "yScale", Re.scaleLinear());
    tt(this, "yPositionScale", Re.scaleLinear());
    tt(this, "xPositionScale", Re.scaleLinear());
    tt(this, "yAxisScale", Re.scaleLinear());
    tt(this, "measurementScale", Re.scaleLinear());
    tt(this, "xAxis");
    tt(this, "yAxis");
    tt(this, "stretched");
    tt(this, "shapeXAxis");
    tt(this, "shapeYAxis");
    tt(this, "cutMeasurementXAxes");
    tt(this, "cutMeasurementYAxes");
    tt(this, "axisSpacing");
    tt(this, "flipY");
    tt(this, "flipX");
    tt(this, "colors");
    tt(this, "options");
    tt(this, "moveMode");
    tt(this, "moveRotation");
    tt(this, "moving");
    tt(this, "shape");
    tt(this, "shapeColorScale");
    tt(this, "scoreColorScale");
    tt(this, "hasTouch");
    tt(this, "highlightguillotine");
    tt(this, "debug", "");
    //groups | guillotine | positions
    tt(this, "elementID");
    //the id of the element to draw the vis in
    tt(this, "el");
    tt(this, "htmlEl");
    tt(this, "svgCanvas");
    tt(this, "axisGroup");
    tt(this, "stockGroup");
    tt(this, "stockWrappers");
    tt(this, "stock");
    tt(this, "shapeGroup");
    tt(this, "shapeWrappers");
    tt(this, "shapes");
    tt(this, "shapeIDText");
    tt(this, "shapeNameText");
    tt(this, "shapeLengthText");
    tt(this, "shapeWidthText");
    tt(this, "groupGroup");
    tt(this, "groups");
    tt(this, "bandingGroup");
    tt(this, "bandingWrappers");
    tt(this, "banding");
    tt(this, "segmentGroup");
    tt(this, "segments");
    tt(this, "segment");
    tt(this, "positionGroup");
    tt(this, "position");
    tt(this, "dotGroup");
    tt(this, "placementPositionGroup");
    tt(this, "dot");
    tt(this, "cutGroup");
    tt(this, "cuts");
    tt(this, "cut");
    if (!t) throw new Error("elementID is required");
    if (this.el = Re.select(t), this.el === null) return;
    const y = this.el.node();
    if (y !== null) {
      this.htmlEl = y, this.vueComponent = x, this.env = Ve.call(this.vueComponent, ["env"]) === "development" ? "development" : "production", this.debug = this.env === "development" ? "groups" : "", this.app = l || !1, this.embed = h || !1, this.height = u, this.width = d, this.device = l ? "app" : "desktop", this.stretched = !1, this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.w = 0, this.h = 0, this.padding = 0, this.mobileBreakpoint = 450, this.main = i, this.saw = a, this.cutMeasurementXAxes = [], this.cutMeasurementYAxes = [], this.axisSpacing = 16, this.flipY = p, this.flipX = f, m = {
        ...m
      };
      for (const [v, k] of Object.entries(m))
        k && (m[v] = k.replace("#", ""));
      this.colors = {
        partA: ha(m == null ? void 0 : m.partA) ? Nn("#" + m.partA) : Nn("#1d9bc4"),
        partB: ha(m == null ? void 0 : m.partB) ? Nn("#" + m.partB) : Nn("#127da1"),
        partHover: ha(m == null ? void 0 : m.partHover) ? Nn("#" + m.partHover) : Nn("#29c778"),
        partSelected: ha(m == null ? void 0 : m.partSelected) ? Nn("#" + m.partSelected) : Nn("#1bc319"),
        stock: ha(m == null ? void 0 : m.stock) ? Nn("#" + m.stock) : Nn("#ffd166"),
        text: ha(m == null ? void 0 : m.text) ? Nn("#" + m.text) : Nn("#ffffff")
      }, this.shapeColorScale = Re.scaleSequential([
        this.colors.partA,
        this.colors.partB
      ]), this.env = e, this.moveMode = !1, this.moving = !1, this.moveRotation = !1, this.units = r, this.decimalPlaces = s, this.fractionRoundTo = o, this.hasTouch = !1, this.options = b, this.init();
    }
  }
  /**
      * sets up the various wrappers - only needs to be called once
      * the z index is set by the order drawn
      */
  init() {
    if (!this.el) return !1;
    if ((this.decimalPlaces === null || this.decimalPlaces === void 0 || isNaN(this.decimalPlaces)) && (this.decimalPlaces = 2), (this.fractionRoundTo === null || this.fractionRoundTo === void 0 || isNaN(this.fractionRoundTo)) && (this.fractionRoundTo = 0), !this.svgCanvas) {
      if (this.htmlEl.querySelector("svg") === null) {
        const e = this.el.append("svg").attr("class", "vis");
        if (e === null) return;
        e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").attr("id", "stripes").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(90)").attr("id", "grain-l").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("id", "grain-w").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), this.svgCanvas = e;
      }
      this.axisGroup = this.svgCanvas.append("g").attr("class", "axis-group"), this.stockGroup = this.svgCanvas.append("g").attr("class", "stock-group"), this.shapeGroup = this.svgCanvas.append("g").attr("class", "shapes"), this.bandingGroup = this.svgCanvas.append("g").attr("class", "banding-group"), this.segmentGroup = this.svgCanvas.append("g").attr("class", "segments").attr("display", "none"), this.groupGroup = this.svgCanvas.append("g").attr("class", "groups").attr("display", "none"), this.positionGroup = this.svgCanvas.append("g").attr("class", "positions"), this.dotGroup = this.svgCanvas.append("g").attr("class", "dots"), this.env === "development" && (this.placementPositionGroup = this.svgCanvas.append("g").attr("class", "placements")), this.cutGroup = this.svgCanvas.append("g").attr("class", "cuts");
    }
    this.elWidth > 0 && this.updateSize(!0), this.hasTouch = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
  updateUnits(t, e, i) {
    t && (this.units = t), e && (this.decimalPlaces = e), i && (this.fractionRoundTo = i), this.refreshShapes(), this.refreshStock();
  }
  trimNameToFit(t, e) {
    function i(r, s, o) {
      const a = o[s], l = Re.select(a);
      l.text(r.name);
      let h = l.text();
      const u = l.node();
      if (!u) return;
      let d = u.getComputedTextLength();
      const p = this.getWidthAttribute(r) - 20;
      for (; d > p && h.length > 0; )
        h = h.slice(0, -1), l.text(h.length ? h + "..." : ""), d = l.node().getComputedTextLength();
    }
    t.each(i.bind(e));
  }
  getShapeColor(t) {
    var e;
    if (this.env === "development")
      switch (this.debug) {
        case "guillotine":
          if (t.guillotineData.firstShape)
            return Nn(252, 3, 182);
          if (t.addedAsGroup)
            return Nn(43, 156, 16);
          if (typeof t.guillotineData.myPhase == "number") {
            const i = [0, 115, 255], r = [176, 255, 231];
            return `rgb(${i.map((o, a) => Math.round(o + t.guillotineData.myPhase / 5 * (r[a] - o))).join(",")})`;
          }
          break;
        case "groups":
          if (t.addedAsGroup !== !1)
            return Nn(43, 156, 16);
          break;
        case "priorityShapes":
          if (t != null && t.priority && ((e = t.priority) != null && e[t.stock.parentID]))
            return Nn(139, 171, 46);
          break;
        case "score":
          return this.scoreColorScale(t.bestScore.total);
      }
    return this.shapeColorScale(t.parentID - 1);
  }
  setDevice() {
    if (!(!this.htmlEl || this.htmlEl.style.display === "none") && this.htmlEl.offsetWidth) {
      if (this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.elWidth === 0) return !1;
      this.main ? this.elWidth <= this.mobileBreakpoint || this.app ? (this.device = "mobile", this.padding = 0) : (this.device = "desktop", this.padding = 50) : this.padding = 0, this.w = this.elWidth;
    }
  }
  //find the largest dimensions of all the stock (not just the active one)
  findLargestStockDimensions() {
    const t = Ve.call(this.vueComponent, ["stockList"]).filter((r) => r.used);
    if (!(t != null && t.length)) return [null, null];
    const e = t.reduce((r, s) => r.l > s.l ? r : s), i = t.reduce((r, s) => r.w > s.w ? r : s);
    return [e, i];
  }
  debounce(t, e, i = !1) {
    let r;
    return (...s) => new Promise((o) => {
      const a = () => {
        r = null, i || o(t.apply(this, s));
      };
      clearTimeout(r), i && !r && o(t.apply(this, s)), r = setTimeout(a, e);
    });
  }
  updateSize(t = !1) {
    return this.debounce(this._updateSize.bind(this), 10, t)();
  }
  requiresStretch(t, e = null) {
    return t ? (e === null && (e = t.w / t.l), e < 0.15) : !1;
  }
  setAspectRatio(t) {
    if (t) {
      this.w = this.elWidth;
      const e = t.w / t.l;
      this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.requiresStretch(t, e) && this.options.enableStretch ? (this.h = this.htmlEl.clientWidth * 0.15 + this.padding * 2, this.stretched = !0) : (this.h = this.xScale(t.getShortSide()) + this.padding, this.stretched = !1), this.yScale.domain([0, t.w]).range([this.padding, this.h - this.padding]), this.yAxisScale.domain(this.flipY ? [0, t.w] : [t.w, 0]).range([this.padding, this.h - this.padding]), this.yPositionScale.domain([0, t.w]).range(this.flipY ? [this.padding, this.h - this.padding] : [this.h - this.padding, this.padding]), e > 2 && (this.w = this.htmlEl.clientWidth / e + this.padding * 2, this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.h = this.xScale(t.getShortSide()) + this.padding), this.xPositionScale.domain([0, t.l]).range(this.flipX ? [this.w - this.padding, this.padding] : [this.padding, this.w - this.padding]), this.measurementScale.domain([0, t.l]).range([0, this.w - this.padding * 2]), this.w > 0 && this.h > 0 && (e > 2 ? this.el.style("width", this.w + "px") : this.el.style("width", ""), this.el.style("height", this.h + "px"));
    }
  }
  _updateSize() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    this.vueComponent && "suppressResizeObserver" in this.vueComponent && (this.vueComponent.suppressResizeObserver = !0);
    const t = Ve.call(this.vueComponent, ["stockList"]), e = Ve.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length) || !(e != null && e.length)) return !1;
    this.setDevice(), this.refreshStock(), this.refreshShapes(), this.env === "development" && this.refreshPlacementPositions();
  }
  refreshCuts() {
    const t = Ve.call(this.vueComponent, ["activeCuts"]);
    this.resetSegments(), this.initCuts(t);
  }
  refreshStock() {
    const t = Ve.call(this.vueComponent, ["stockList"]);
    if (!(t != null && t.length)) return !1;
    const e = Ve.call(this.vueComponent, ["activeStock"]);
    this.initStock(e), this.refreshCuts();
    const i = Ve.call(this.vueComponent, ["activeSegments"]);
    this.initSegments(i), this.resetPositions(), typeof this.vueComponent.toggleSegments == "function" && this.vueComponent.toggleSegments(!1);
  }
  refreshShapes() {
    const t = Ve.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length)) return !1;
    this.resetPositions();
    const e = Ve.call(this.vueComponent, ["activeShapes"]);
    this.initShapes(e, t);
  }
  refreshPlacementPositions() {
    const t = Ve.call(this.vueComponent, ["placementPositions"]);
    if (!(t != null && t.length)) return !1;
    this.resetPlacementPositions();
    const e = t.filter((i) => i.stockID === Ve.call(this.vueComponent, ["activeStock"]).id);
    this.initPlacementPositions(e);
  }
  recreateUerGroups(t) {
    t.filter((r) => r.inUserGroup);
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r].addedAsGroup, a = t.filter((l) => l.addedAsGroup === o);
      e.push(a), r += a.length;
    }
    const i = [];
    e.forEach((r) => {
      const s = Math.min(...r.map((u) => u.x)), o = Math.min(...r.map((u) => u.y)), a = Math.max(...r.map((u) => u.x + u.l)) - s, l = Math.max(...r.map((u) => u.y + u.w)) - o, h = {
        x: s,
        y: o,
        l: a,
        w: l,
        shapes: r
      };
      i.push(h);
    }), this.initGroups(i);
  }
  //init or update the stock
  initStock(t) {
    if (this.resetStock(), this.setAspectRatio(t), !t || !(t != null && t.w) || !(t != null && t.l) || !this.elWidth)
      return !1;
    this.stockType = t.type;
    let e;
    if (typeof t == "object" && (e = [t]), this.device === "desktop" && this.main) {
      this.xAxis = this.axisGroup.append("g").attr("transform", `translate(0, ${this.padding})`).attr("class", "axis stock x").call(Re.axisTop(this.xScale).ticks(5).tickSize(5)).selectAll("text").attr("dy", -5);
      const i = this.requiresStretch(t);
      (!i || i && this.stretched) && (this.yAxis = this.axisGroup.append("g").attr(
        "transform",
        `translate(${this.w - this.padding}, 0)`
      ).attr("class", "axis stock y").call(Re.axisRight(this.yAxisScale).ticks(5).tickSize(5)).selectAll("text").attr("dx", 5));
    }
    this.stockGroup.data(e).attr(
      "transform",
      () => `translate(${this.padding},${this.padding})`
    ), this.stockGroup.append("rect").attr("class", "background stock").style("fill", this.colors.stock).attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr("x", (i) => {
      i.x = 0;
      const r = i.x;
      i.x = 0;
      const s = this.getRectangleCoordinate(i, "x") - this.padding;
      return i.x = r, s;
    }).attr("y", (i) => {
      i.y = 0;
      const r = i.y;
      i.y = 0;
      const s = this.getRectangleCoordinate(i, "y") - this.padding;
      return i.y = r, s;
    }), this.stock = this.stockGroup.append("rect").attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr(
      "x",
      (i) => this.getRectangleCoordinate(i, "x") - this.padding
    ).attr(
      "y",
      (i) => this.getRectangleCoordinate(i, "y") - this.padding
    ).attr("class", "stock-pattern").style("fill", (i) => i != null && i.grain ? `url(#grain-${i.grain.toLowerCase()})` : "url(#stripes)");
  }
  getWidthAttribute(t) {
    return this.xScale(t.l) - this.padding;
  }
  getHeightAttribute(t) {
    return this.yScale(t.w) - this.padding;
  }
  //init or update the shapes
  initShapes(t, e) {
    var i, r, s;
    if (this.resetShapes(), !(!t || !t.length || !this.elWidth)) {
      if (this.numUniqueShapes = e.filter((o) => !o.duplicate).length, this.shapeColorScale.domain([0, this.numUniqueShapes]), (i = this == null ? void 0 : this.vueComponent) != null && i.gs) {
        Xe.call(this.vueComponent, ["shapeColors"], {});
        for (let o = t.length; o--; ) {
          const a = t[o];
          a.parentID && Ve.call(this.vueComponent, ["shapeColors", a.parentID]) || a.parentID && Xe.call(this.vueComponent, ["shapeColors", a.parentID], Aa(this.shapeColorScale(parseInt(a.parentID) - 1)).formatHex());
        }
      }
      if (this.env === "development") {
        let o = 1 / 0, a = -1 / 0;
        for (const u of t) {
          const d = (r = u == null ? void 0 : u.bestScore) == null ? void 0 : r.total;
          if (d !== 0 && d !== null && d !== void 0) {
            o = d, a = d;
            break;
          }
        }
        const l = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p === 0 || p === null || p === void 0 ? u : p < u ? p : u;
        }, o), h = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p == null ? u : p > u ? p : u;
        }, a);
        this.scoreColorScale = Re.scaleSequential([Nn(251, 224, 255), Nn(122, 0, 138)]).domain([l, h]);
      }
      if (!t || !t.length || (this.shapeWrappers = this.shapeGroup.selectAll("g").data(t).join("g").attr("class", "shape-group"), !this.shapeWrappers.size())) return !1;
      if (this.shapes = this.shapeWrappers.append("rect").attr("class", "shape").attr("fill", (o) => this.getShapeColor(o)).attr("stroke-width", () => this.env === "development" ? 3 : 0).attr("width", (o) => this.getWidthAttribute(o)).attr("height", (o) => this.getHeightAttribute(o)), this.main) {
        const o = [];
        t.forEach((a) => {
          if (a != null && a._banding)
            for (const [l, h] of Object.entries(a._banding)) {
              if (!h || ["a", "b", "c", "d"].includes(l)) continue;
              let u = l;
              if (a.rot)
                switch (l) {
                  case "x1":
                    u = "y1";
                    break;
                  case "x2":
                    u = "y2";
                    break;
                  case "y1":
                    u = "x2";
                    break;
                  case "y2":
                    u = "x1";
                    break;
                }
              switch (u) {
                case "x1":
                  o.push({
                    x1: a.x,
                    x2: a.x,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x1"
                  });
                  break;
                case "x2":
                  o.push({
                    x1: a.x + a.l,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x2"
                  });
                  break;
                case "y1":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y,
                    type: "y1"
                  });
                  break;
                case "y2":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y + a.w,
                    y2: a.y + a.w,
                    type: "y2"
                  });
                  break;
              }
            }
        }), this.bandingWrappers = this.bandingGroup.selectAll("g").data(o).join("line").attr("class", "banding").attr(
          "x1",
          (a) => this.xPositionScale(a.x1) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "x2",
          (a) => this.xPositionScale(a.x2) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "y1",
          (a) => this.yPositionScale(a.y1) + this.getBandingAdjustment(a.type, "y")
        ).attr(
          "y2",
          (a) => this.yPositionScale(a.y2) + this.getBandingAdjustment(a.type, "y")
        ).attr("stroke-width", 2).attr("stroke", "white"), this.shapeIDText = this.shapeWrappers.append("text").attr("class", "shape-text id").text((a) => {
          var l, h;
          if (this.env === "development")
            switch (this.debug) {
              case "guillotine": {
                const u = a.guillotineData.myStripDirection, d = a.addedAsGroup;
                let p = "";
                return u === "l" ? p = `→ ${a.parentID}` : u === "w" && (p = `↑ ${a.parentID}`), (h = a == null ? void 0 : a.priotity) != null && h[(l = a == null ? void 0 : a.stock) == null ? void 0 : l.parentID] && (p += "P"), d && (p += "G"), p.length ? p : this.shapeNameText;
              }
              case "groups":
                {
                  const u = a.addedAsGroup;
                  if (u) return u.split(".")[0].toUpperCase();
                }
                break;
              case "positions":
                return a.id;
            }
          return a.parentID ? a.parentID : a.getParentID();
        }).classed("hidden", (a, l, h) => {
          const u = h[l].getBBox();
          return u.width >= this.measurementScale(a.l) || u.height >= this.yScale(a.w) - this.padding;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeNameText = this.shapeWrappers.append("text").attr("class", "shape-text name").text((a) => !(a != null && a.name) || typeof (a == null ? void 0 : a.name) != "string" ? null : a.name.toUpperCase().trim()).call(this.trimNameToFit, this).classed("hidden", (a, l, h) => h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 40).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeLengthText = this.shapeWrappers.append("text").attr("class", "shape-text length").text((a) => this.debug === "guillotine" ? "" : ne(
          a.l,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          var d;
          return this.app ? this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50 : ((d = a == null ? void 0 : a.stock) == null ? void 0 : d.type) === "linear" ? !1 : h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 30;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeWidthText = this.shapeWrappers.append("text").attr("class", "shape-text width").text((a) => this.debug === "guillotine" ? "" : ne(
          a.w,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          if (this.app)
            return this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50;
          const u = h[l].getBBox();
          return this.measurementScale(a.l) < 30 || u.height >= this.measurementScale(a.w);
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      }
      (this.main || this.app) && !((s = this == null ? void 0 : this.options) != null && s.disableClick) && (this.shapes.on("mousedown", (o, a) => {
        var l, h, u, d, p;
        if (this.moving) return !1;
        if (this.env === "development") {
          if (console.clear(), a) {
            let f = ["id", "placementOrder", "priority", "addedAsGroup"];
            this.debug === "guillotine" ? f = [
              "id",
              "placementOrder",
              "priority",
              "guillotineData.myPhase",
              "guillotineData.myStripDirection",
              "guillotineData.myStripParent",
              "guillotineData.firstShape",
              "addedAsGroup"
            ] : this.debug === "groups" && (f = [
              "id",
              "addedAsGroup"
            ]), console.table(f.reduce((m, b) => {
              const x = Wg(a, b);
              return m[b] = Array.isArray(x) ? x.join(", ") : x, m;
            }, {}));
          }
          if (this.debug === "guillotine") {
            this.shapeWrappers.selectAll(".highlight-a").classed("highlight-a", !1), this.shapeWrappers.selectAll(".highlight-b").classed("highlight-b", !1), this.shapeWrappers.selectAll(".highlight-c").classed("highlight-c", !1);
            const f = (l = a.guillotineData) == null ? void 0 : l.myStripParent, m = (u = (h = t.find((b) => b.id === f)) == null ? void 0 : h.guillotineData) == null ? void 0 : u.myStripParent;
            f && this.shapeWrappers.filter((y) => y.id === f || y.addedAsGroup === f).select("rect").classed("highlight-a", !0), m && this.shapeWrappers.filter((y) => y.id === m || y.addedAsGroup === f).select("rect").classed("highlight-b", !0);
          }
        }
        if (this.app || this.embed) {
          const f = {
            name: a.name,
            id: a.id,
            x: a.x,
            y: a.y,
            l: a.l,
            w: a.w,
            banding: a != null && a.banding && typeof a.banding == "object" ? a.banding : null,
            rot: a.rot,
            stock: (d = a == null ? void 0 : a.stock) == null ? void 0 : d.id,
            color: (p = this.getShapeColor(a)) == null ? void 0 : p.toString(),
            notes: a == null ? void 0 : a.notes
          }, m = new CustomEvent("partClick", {
            detail: f
          });
          if (this.env === "development" && console.log(f), this.htmlEl.dispatchEvent(m), this.app) return !1;
        }
        if (this.device === "desktop" && (this.resetCutMeasurementAxes(), this.addShapeAxes(a)), this.moveMode) {
          const f = xa.call(this.vueComponent, "partsBin");
          f && f.addToPartBin(a);
        } else
          this.findShape(a.id);
      }), !this.app && !this.hasTouch && this.shapes.on(
        "mouseover",
        (o) => {
          this != null && this.moveMode && this.moving || (Re.select(o.target).classed("hover", !0), Re.select(o.target).classed("selected") || Re.select(o.target).style(
            "fill",
            this.colors.partHover.toString()
          ));
        },
        {
          passive: !0
        }
      ).on(
        "mouseout",
        (o, a) => {
          var l;
          Re.select(o.target).classed("hover", !1), Re.select(o.target).classed("selected") || Re.select(o.target).style(
            "fill",
            (l = this.getShapeColor(a)) == null ? void 0 : l.toString()
          );
        },
        {
          passive: !0
        }
      )), this.setShapePosition();
    }
  }
  findShapeElement(t) {
    const e = this.shapeWrappers.filter((i) => i.id === t);
    return e.empty() ? null : e.node();
  }
  findShape(t) {
    const e = this.findShapeElement(t), i = Ve.call(this.vueComponent, ["shapeList"]).find((r) => r.id === t);
    e && this.selectShape(e, i);
  }
  selectShape(t, e) {
    Xe.call(this.vueComponent, ["examineShape"], e), this.shapes.classed("selected", !1), this.shapes.style("fill", (r) => this.getShapeColor(r));
    const i = Re.select(t).select("rect");
    i && (i.classed("selected", !0), i.style("fill", this.colors.partSelected.toString()));
  }
  /**
      * update SHAPE visibility - used for replay
      * @param {Number} number
      */
  updateShapeVisibility(t) {
    var e;
    (e = this == null ? void 0 : this.shapeWrappers) == null || e.style("visibility", (i) => (i == null ? void 0 : i.placementOrder) >= t ? "hidden" : "visible");
  }
  isCutComplete(t, e, i) {
    return t.guillotineData.parentSegmentID === e && i && t.guillotineData.segmentCutOrder < i;
  }
  isCutInsideSegment(t, e) {
    var i;
    return ((i = t.guillotineData) == null ? void 0 : i.parentSegmentID) !== null && !(t != null && t.isTrim) ? t.guillotineData.parentSegmentID === e : !1;
  }
  //update CUT visibility
  updateCutVisibility(t, e = null, i = "") {
    var h, u, d, p, f, m, b, x, y;
    if (e === null || t == null || this != null && this.cuts.empty()) return;
    this.resetShapeAxes(), this.resetCutMeasurementAxes(), Re.select(this.cuts.nodes()[e].parentNode).raise();
    const r = (h = t.guillotineData) == null ? void 0 : h.parentSegmentID, s = this.getHalfBladeWidth(t.stock), o = t.dimension === "l" ? "y" : "x", a = (u = t == null ? void 0 : t.stock) == null ? void 0 : u.trim, l = i === "ptx" ? "ptxOrder" : "order";
    if ((((d = t == null ? void 0 : t.stock) == null ? void 0 : d.cutType) === "guillotine" || ((p = t == null ? void 0 : t.stock) == null ? void 0 : p.cutType) === "beam") && r !== null && typeof r < "u") {
      if (this.cuts.style("visibility", (v) => typeof t.guillotineData[l] == "number" && v.guillotineData[l] <= t.guillotineData[l] || !i && v.guillotineData.parentSegmentID === r ? "visible" : "hidden"), this.cuts.classed("highlight", (v) => t.stock.cutType === "guillotine" && v.isTrim ? v.type === t.type : v.guillotineData[l] === t.guillotineData[l]), this.cuts.classed("ptx-dummy", (v) => v.guillotineData.ptxDummyCut), !i) {
        const v = (f = t == null ? void 0 : t.guillotineData) == null ? void 0 : f.segmentCutOrder;
        if (v == null)
          return;
        this.cuts.classed("completed", (T) => this.isCutComplete(T, r, v)), this.cuts.classed("inside-segment", (T) => this.isCutInsideSegment(T, r));
        let k, C;
        const E = this.getCutSegments(t);
        if (E === !1) return;
        const q = (b = E == null ? void 0 : E.siblings) == null ? void 0 : b[(m = E.main) != null && m.hasBeamTrim ? v - 1 : v];
        q && ((t == null ? void 0 : t.dimension) === "l" ? k = [
          [
            q.y,
            q.y + q.w
          ],
          [
            t.y1 + s,
            (E == null ? void 0 : E.main.y) + (E == null ? void 0 : E.main.w)
          ]
        ] : (t == null ? void 0 : t.dimension) === "w" && (k = [
          [
            q.x,
            q.x + q.l
          ],
          [
            t.x1 + s,
            (E == null ? void 0 : E.main.x) + (E == null ? void 0 : E.main.l)
          ]
        ]), (t == null ? void 0 : t.dimension) === "l" ? C = [(x = t == null ? void 0 : t.distances) == null ? void 0 : x.bottom, t == null ? void 0 : t.distances.top] : (t == null ? void 0 : t.dimension) === "w" && (C = [t == null ? void 0 : t.distances.left, (y = t == null ? void 0 : t.distances) == null ? void 0 : y.right]), this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(k, C, o));
      }
    } else {
      this.cuts.style("visibility", (k, C) => C <= e ? "visible" : "hidden");
      let v;
      if ((t == null ? void 0 : t.dimension) === "l" ? v = [
        [0 + (a.y1 ?? 0), t.y1 - s],
        [
          t.y1 + s,
          t.stock.w - (a != null && a.y2 ? a.y2 : 0)
        ]
      ] : (t == null ? void 0 : t.dimension) === "w" && (v = [
        [0 + (a.x1 ?? 0), t.x1 - s],
        [
          t.x1 + s,
          t.stock.l - (a != null && a.x2 ? a.x2 : 0)
        ]
      ]), v != null && v.length) {
        const k = [
          v[0][1] - v[0][0],
          v[1][1] - v[1][0]
        ];
        this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(v, k, o);
      }
      this.cuts.classed(
        "highlight",
        (k, C) => C === e
      );
    }
    this.cuts.attr("stroke-width", (v, k) => {
      var q;
      let C = Math.ceil(this.measurementScale(this.getBladeWidth(v.stock)));
      const E = (q = t == null ? void 0 : t.guillotineData) == null ? void 0 : q.segmentCutOrder;
      return (this.isCutComplete(v, r, E) || this.isCutInsideSegment(v, r)) && (C += 1), k === e && Math.ceil(this.measurementScale(this.getBladeWidth(v.stock))) < 5 && (C = 5), C;
    });
  }
  //highlight a specific cut (by order or index), segments and related measurements
  showCut(t, e = null, i = "") {
    var h;
    if (e === null) return !1;
    if (this.updateCutVisibility(t, e, i), i === "ptx") {
      this.resetSegments();
      return;
    }
    const r = this.getCutSegments(t);
    if (r === !1) return;
    const { main: s, siblings: o } = r;
    if (!((h = t == null ? void 0 : t.guillotineData) != null && h.parentSegmentID))
      return this.initSegments([s]);
    const a = o == null ? void 0 : o.length;
    let l = [];
    if (a) {
      for (let d = a; d--; )
        o[d] && (o[d].completed = !1);
      if (t.guillotineData.segmentCutOrder === void 0 || t.guillotineData.segmentCutOrder === null)
        return;
      const u = t.guillotineData.segmentCutOrder;
      for (let d = 0; d < a; d++)
        d < u && (o[d].completed = !0);
      l.push(...o), l = l.filter((d) => d);
    }
    l.length && (this.resetSegments(), this.initSegments(l));
  }
  /**
      * toggle the visibility of the shapes
      * @param {Boolean} show
      */
  toggleShapes(t = !1) {
    t ? (this.shapeGroup.attr("display", "block"), this.bandingGroup.attr("display", "block")) : (this.shapeGroup.attr("display", "none"), this.bandingGroup.attr("display", "none"));
  }
  /**
      * add measurements to an axis
      * @param {Array} measurements array of arrays
      * @param {Array} values array of values
      * @param {String} axis x | y
      */
  addCutMeasurementAxes(t, e, i) {
    !i || !(t != null && t.length) || t.forEach((r, s) => {
      const o = r[0], a = r[1];
      if (i === "x") {
        const l = Re.scaleLinear().domain([o, a]).range([
          this.xPositionScale(o),
          this.xPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(0, ${this.h - this.padding + this.axisSpacing})`
        ).attr("class", "axis measurement x").call(Re.axisBottom(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ), this.cutMeasurementXAxes.push(u);
      } else {
        const l = Re.scaleLinear().domain([o, a]).range([
          this.yPositionScale(o),
          this.yPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(${this.padding - this.axisSpacing}, 0)`
        ).attr("class", "axis measurement y").call(Re.axisLeft(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ).attr(
          "dx",
          (d, p, f) => f[p].getBBox().width / 4
        ).attr(
          "transform",
          (d, p, f) => "rotate(90) translate(" + f[p].getBBox().width / 4 + ")"
        ), this.cutMeasurementYAxes.push(u);
      }
    });
  }
  /**
      * add the shape axes
      * @param {Shape} shape
      */
  addShapeAxes(t) {
    var l;
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
    const e = t.x, i = t.x + t.l, r = Re.scaleLinear().domain([e, i]).range([this.xPositionScale(e), this.xPositionScale(i)]), s = t.y, o = t.y + t.w, a = Re.scaleLinear().domain([s, o]).range([this.yPositionScale(s), this.yPositionScale(o)]);
    this.shapeXAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(0, ${this.h - this.padding + this.axisSpacing})`
    ).attr("class", "axis shape x").call(Re.axisBottom(r).tickValues(r.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeXAxis.selectAll("text").attr("dx", (h, u, d) => {
      const p = d[u];
      if (p === null) return;
      const f = p.getBBox();
      return u === 0 ? -f.width / 2 : f.width / 2;
    }), ((l = t == null ? void 0 : t.stock) == null ? void 0 : l.type) !== "linear" && (this.shapeYAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(${this.padding - this.axisSpacing}, 0)`
    ).attr("class", "axis shape y").call(Re.axisLeft(a).tickValues(a.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeYAxis.selectAll("text").attr("x", 0).attr("y", 0).attr(
      "dy",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.height) + 2;
      }
    ).attr(
      "dx",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2;
      }
    ).attr("transform", (h, u, d) => {
      var p, f, m, b, x, y, v, k;
      return this.flipY ? u === 0 ? "rotate(90) translate(-" + ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2 + ")" : "rotate(90) translate(" + ((b = (m = d[u]) == null ? void 0 : m.getBBox()) == null ? void 0 : b.width) / 2 + ")" : u === 0 ? "rotate(90) translate(" + ((y = (x = d[u]) == null ? void 0 : x.getBBox()) == null ? void 0 : y.width) / 2 + ")" : "rotate(90) translate(-" + ((k = (v = d[u]) == null ? void 0 : v.getBBox()) == null ? void 0 : k.width) / 2 + ")";
    }));
  }
  getBandingAdjustment(t, e) {
    switch (t) {
      case "y1":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? 1 : -1;
        break;
      case "y2":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? -1 : 1;
        break;
      case "x1":
        if (e === "x") return this.flipX ? -1 : 1;
        if (e === "y") return 0;
        break;
      case "x2":
        if (e === "x") return this.flipX ? 1 : -1;
        if (e === "y") return 0;
        break;
    }
    return 0;
  }
  getRectangleCoordinate(t, e, i, r) {
    let s;
    if (e === "x") {
      let o;
      switch (i) {
        case "center":
          o = this.xPositionScale(t.x + t.l / 2), r && (o += r);
          break;
        case "right":
          o = this.xPositionScale(t.x + t.l), r && (o -= r);
          break;
        case "left":
        default:
          o = this.xPositionScale(this.flipX ? t.x - t.l : t.x), r && (o -= r);
      }
      s = o;
    } else if (e === "y") {
      let o;
      switch (i) {
        case "center":
          o = this.yPositionScale(t.y + t.w / 2), r && (o += r);
          break;
        case "bottom":
          o = this.yPositionScale(this.flipY ? t.y + t.w : t.y), r && (o += r);
          break;
        case "top":
        default:
          o = this.yPositionScale(this.flipY ? t.y : t.y + t.w), r && (o -= r);
      }
      s = o;
    }
    return s;
  }
  getRotatedSide(t) {
    switch (t) {
      case "x1":
      case "l1":
        return "w1";
      case "x2":
      case "l2":
        return "w2";
      case "y1":
      case "w1":
        return "l2";
      case "y2":
      case "w2":
        return "l1";
    }
  }
  /**
      * update the position of the shapes and the content within
      */
  setShapePosition() {
    if (!this.shapes) return !1;
    this.shapes.attr("x", (t) => this.getRectangleCoordinate(t, "x")).attr("y", (t) => this.getRectangleCoordinate(t, "y")).attr("width", (t) => this.getWidthAttribute(t)).attr("height", (t) => this.getHeightAttribute(t)), this.main && (this.shapeIDText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t) => this.getRectangleCoordinate(t, "y", "center")).attr("dy", 1), this.shapeNameText && this.shapeNameText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "bottom",
      -(i[e].getBBox().height / 2 + 1)
    )), this.shapeLengthText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "top",
      -(i[e].getBBox().height / 2 + 2)
    )), this.shapeWidthText.attr(
      "transform",
      (t, e, i) => `translate(${this.getRectangleCoordinate(
        t,
        "x",
        "left",
        -(i[e].getBBox().height / 2 + 2)
      )},${this.getRectangleCoordinate(t, "y", "center")}) ${this.device === "mobile" ? "rotate(90)" : "rotate(-90)"}`
    ));
  }
  //init or update the cuts
  initCuts(t) {
    if (this.resetCuts(), !t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.cuts = this.cutGroup.selectAll("line").data(t).join("line").attr("class", "cut").attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    }).attr("x1", (e) => this.xPositionScale(e.getVisCoords("x1"))).attr("x2", (e) => this.xPositionScale(e.getVisCoords("x2"))).attr("y1", (e) => this.yPositionScale(e.getVisCoords("y1"))).attr("y2", (e) => this.yPositionScale(e.getVisCoords("y2"))).classed("trim", (e) => e.isTrim);
  }
  //init or update the segments
  initSegments(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetSegments(), this.segments = this.segmentGroup.selectAll("rect").data(t).join("rect").attr("class", "segment").style("opacity", (e) => {
      if ((e == null ? void 0 : e.offcut) === !0) return 0.5;
    }).classed("offcut", (e) => e.offcut).classed("merged", (e) => e.merged).classed("near", (e) => e.shapePosition === "near").classed("far", (e) => e.shapePosition === "far").classed("completed", (e) => e.completed).attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.segmentGroup.selectAll("text").data(t).join("text").attr("class", "segment-text").attr("x", (e) => this.getRectangleCoordinate(e, "x", "center")).attr("y", (e) => this.getRectangleCoordinate(e, "y", "center")).attr("text-anchor", "middle").text((e) => {
      if (this.env !== "development" || e.offcut) return null;
      if (e.cutDirection === "l")
        return this.env === "development" ? `→ ${e.id}` : "→";
      if (e.cutDirection === "w")
        return this.env === "development" ? `↑ ${e.id}` : "↑";
    }).attr("dominant-baseline", "middle"), !this.app && this.env === "development" && this.segments.on("mousedown", function(e, i) {
      const r = structuredClone(i);
      console.log([
        "id",
        "x",
        "y",
        "l",
        "w",
        "cutDirection",
        "cutPreference"
      ].reduce((o, a) => (o[a] = Wg(r, a), o), {}));
    });
  }
  initGroups(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetGroups(), this.groups = this.groupGroup.selectAll("rect").data(t).join("rect").attr("class", "group").attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.groupGroup.attr("display", "block");
  }
  //get relevant segments for a specific cut
  getCutSegments(t) {
    var o, a, l, h;
    const e = (o = t == null ? void 0 : t.guillotineData) == null ? void 0 : o.parentSegmentID, i = ((l = (a = this.vueComponent) == null ? void 0 : a.gs) == null ? void 0 : l.activeSegments) ?? ((h = this.vueComponent) == null ? void 0 : h.activeSegments);
    if (!i.length) return !1;
    let r;
    if (e ? r = i.find((u) => u.id === e) : r = i.find((u) => u.segmentType === "root"), r === void 0) return !1;
    const s = r == null ? void 0 : r.children;
    if (s != null && s.length) {
      const u = s.map((p) => {
        const f = i.find((m) => m.x === p.x && m.y === p.y && m.l === p.l && m.w === p.w);
        return f !== void 0 ? f : null;
      }).filter((p) => p !== null);
      return {
        main: r,
        siblings: u
      };
    }
    return !1;
  }
  /**
      * toggle the visibility of the segments
      * @param {Boolean} show
      */
  toggleSegments(t = !0) {
    t ? this.segmentGroup.attr("display", "block") : this.segmentGroup.attr("display", "none");
  }
  /**
      * show a list of possible movement positions
      */
  initPositions(t, e) {
    if (!e || !t || !this.main) return !1;
    let i;
    if (e.trimDimensions(), !t.willItFit(e, t.rot)) return !1;
    e.removeTrim();
    const r = Ve.call(this.vueComponent, ["shapeList"]).filter((l) => {
      var h;
      return l.added && ((h = l == null ? void 0 : l.stock) == null ? void 0 : h.id) === e.id;
    }), s = Dy(
      null,
      r,
      e
    );
    let o;
    if (e.cutType === "efficiency") {
      if (this.env === "development") {
        const l = Y0(r, e);
        this.positionGroup.selectAll("line").remove();
        const h = l.flatMap((u) => Object.values(u.rays));
        this.positionGroup.selectAll("line").data(h).enter().append("line").attr("x1", (u) => this.xPositionScale(u.x1)).attr("x2", (u) => this.xPositionScale(u.x2)).attr("y1", (u) => this.yPositionScale(u.y1)).attr("y2", (u) => this.yPositionScale(u.y2)).attr("stroke", "rgba(245, 66, 227, 0.5)").attr("stroke-width", 2).on("mousedown", (u, d) => console.log(d));
      }
      o = By(
        e,
        r
      );
    }
    const a = new Co();
    for (const l of s.toArray()) {
      const h = K0(t, l, e);
      h && a.addPoints(h.toArray());
    }
    if (o) {
      const l = o.toArray();
      for (const h of l) {
        const u = My(t, h, e);
        u && a.addPoints(u.toArray());
      }
    }
    e.cutType === "efficiency" ? ([
      new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Hn(
        e.l - t.l - (e.trim.x2 ?? 0),
        0 + (e.trim.y1 ?? 0)
      ),
      new Hn(
        0 + (e.trim.x1 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      ),
      new Hn(
        e.l - t.l - (e.trim.x2 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      )
    ].forEach((l) => a.addPoint(l)), i = a.toArray()) : (a.addPoint(new Hn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0))), i = a.toArray());
    for (let l = i.length; l--; ) {
      const h = i[l];
      t.x = h.x, t.y = h.y;
      for (const u of r)
        if (this.collision(t, u, e)) {
          i.splice(l, 1);
          break;
        }
    }
    return this.positionGroup.selectAll("rect").data(i).join("rect").attr("data-id", (l, h) => h).attr("class", "shape ghost").attr("x", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("y", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y"))).attr("width", this.getWidthAttribute(t)).attr("height", this.getHeightAttribute(t)).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = xa.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), this.hasTouch || this.positionGroup.selectAll("rect").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), Re.select(this).classed("hover", !0), Re.select(this).raise();
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), Re.select(this).classed("hover", !1);
      },
      {
        passive: !0
      }
    ), this.dotGroup.selectAll("circle").data(i).join("circle").attr("data-id", (l, h) => h).attr("class", "dot").classed("raycast", (l) => this.env !== "development" ? !1 : l.raycast).attr("cx", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("cy", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y", "bottom"))).attr("r", 8).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = xa.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), t.x = 0, t.y = 0, this.hasTouch || this.dotGroup.selectAll("circle").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), Re.select(this).classed("hover", !0);
        const h = Re.select(this).attr("data-id"), u = Re.select(`.ghost[data-id="${h}"]`);
        u.raise(), u.classed("highlight", !0);
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), Re.select(this).classed("hover", !1);
        const h = Re.select(this).attr("data-id");
        Re.select(`.ghost[data-id="${h}"]`).classed(
          "highlight",
          !1
        );
      },
      {
        passive: !0
      }
    ), !!(i != null && i.length);
  }
  /**
      * show a list of placement positions
      */
  initPlacementPositions(t) {
    if (!(this.env !== "development" || this.debug !== "positions")) {
      if (!(t != null && t.length)) return !1;
      this.placementPositionGroup.selectAll("circle").data(t).join("circle").attr("data-id", (e, i) => i).attr("class", "dot").attr("cx", (e) => this.xPositionScale(e.x)).attr("cy", (e) => this.yPositionScale(e.y)).attr("r", 3).on("mousedown", (e) => {
        e.stopPropagation();
      });
    }
  }
  /**
      * toggle the visibility of the cuts
      * @param {Boolean} show
      */
  toggleCuts(t = !0) {
    t ? this.cutGroup.attr("display", "block") : this.cutGroup.attr("display", "none");
  }
  clearSelection() {
    var t;
    this != null && this.shapes && (this.shapes.classed("selected", !1), this.shapes.classed("hover", !1), this.shapes.style("fill", (e) => this.getShapeColor(e))), this != null && this.cuts && (this.cuts.classed("selected", !1), this.cuts.classed("highlight", !1), this.cuts.classed("inside-segment", !1), this.cuts.style("visibility", "visible"), this.cuts.attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    })), (t = this == null ? void 0 : this.shapes) != null && t.length && this.shapes.classed("selected", !1);
  }
  /**
      * add padding
      * this.padding will be 0 when necessary
      * @param {number} value
      */
  addPadding(t) {
    return t + this.padding;
  }
  /**
      * @param {Container} container
      * @returns {number} blade width
      */
  getBladeWidth(t = null) {
    var e, i;
    return qt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.bladeWidth) ? (i = this.saw) == null ? void 0 : i.bladeWidth : qt(t) && t !== null ? t.getBladeWidth() : 0;
  }
  getHalfBladeWidth(t = null) {
    const e = this.getBladeWidth(t);
    return e !== void 0 && e > 0 ? e / 2 : 0;
  }
  resetShapes() {
    this.shapeGroup && this.shapeGroup.selectAll("*").remove(), this.bandingGroup && this.bandingGroup.selectAll("*").remove(), this.resetShapeAxes();
  }
  resetShapeAxes() {
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
  }
  resetStock() {
    this.stockGroup && this.stockGroup.selectAll("*").remove(), this.axisGroup && this.axisGroup.selectAll("*").remove(), this.resetStockAxes();
  }
  resetStockAxes() {
    this.xAxis && this.xAxis.remove(), this.yAxis && this.yAxis.remove();
  }
  resetCuts() {
    this.cutGroup && this.cutGroup.selectAll("*").remove(), this.resetCutMeasurementAxes();
  }
  resetSegments() {
    this.segmentGroup && this.segmentGroup.selectAll("*").remove();
  }
  resetGroups() {
    this.groupGroup && this.groupGroup.selectAll("*").remove();
  }
  resetCutMeasurementAxes() {
    var t, e;
    (t = this.cutMeasurementXAxes) != null && t.length && (this.cutMeasurementXAxes.forEach((i) => i.remove()), this.cutMeasurementXAxes.length = 0), (e = this.cutMeasurementYAxes) != null && e.length && (this.cutMeasurementYAxes.forEach((i) => i.remove()), this.cutMeasurementYAxes.length = 0);
  }
  resetPositions() {
    this.positionGroup && this.positionGroup.selectAll("*").remove(), this.dotGroup && this.dotGroup.selectAll("*").remove();
  }
  resetPlacementPositions() {
    this.placementPositionGroup && this.dotGroup.selectAll("*").remove();
  }
  reset() {
    this.resetPositions(), this.resetPlacementPositions(), this.resetShapes(), this.resetStock(), this.resetCuts(), this.resetSegments();
  }
  /**
      * detect collision - required for move mode
      * @param {object} thisShape
      * @param {object} testShape
      * @param {object} container
      * @returns {boolean} true if collision
      */
  collision(t, e, i) {
    if (t.id === e.id)
      throw new Error("collision comparing to self");
    return (
      // 1 left
      t.x < e.x + e.l + this.getBladeWidth(i) && // 2 right
      t.x + t.l + this.getBladeWidth(i) > e.x && // 3 bottom
      t.y < e.y + e.w + this.getBladeWidth(i) && // 4 top
      t.y + t.w + this.getBladeWidth(i) > e.y
    );
  }
}
function Wg(n, t) {
  return t.split(".").reduce((e, i) => e[i], n);
}
function JS(n = "issues", t, e, i = null) {
  var s;
  if (!t || !((s = t == null ? void 0 : t[n]) != null && s.length)) return !1;
  if (t[n].map((o) => o.field).flat().includes(e))
    return i ? t[n].map((a) => a.subField).flat().includes(i) : !0;
}
function ZS(n) {
  if (!ga(n)) return !1;
  const t = Object.getOwnPropertyDescriptor(n, "value");
  return (t == null ? void 0 : t.configurable) === !1;
}
function Xe(n, t) {
  var l;
  if (!(n != null && n[0]) || !this) return !1;
  const e = (h) => ga(h) ? ZS(h) ? "shallowRef" : "ref" : bp(h) ? "reactive" : !I2(h) && typeof h == "object" ? "raw" : "ref";
  let i, r, s;
  if ("gs" in this && typeof ((l = this.gs) == null ? void 0 : l[n[0]]) < "u")
    i = this.gs, r = bo(this.gs, n), s = n[n.length - 1];
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    i = this, r = bo(this, n), s = n[n.length - 1];
  else
    return !1;
  if (ga(r))
    return r.value = t, !0;
  const o = e(r || t);
  let a = t;
  switch (o) {
    case "shallowRef":
      a = oo(t);
      break;
    case "raw":
      typeof t == "object" && t !== null && t.constructor !== Object && t.constructor !== Array ? a = ma(t) : Array.isArray(t) ? a = ma(t.map((h) => typeof h == "object" && h !== null && h.constructor !== Object ? h : JSON.parse(JSON.stringify(h)))) : a = typeof t == "object" ? ma(JSON.parse(JSON.stringify(t))) : ma(t);
      break;
    case "ref":
      ga(t) ? a = t : a = Ae(t);
      break;
    case "reactive":
      a = bp(t) ? t : Ar(t);
      break;
  }
  if (n.length > 1) {
    const h = n.slice(0, -1), u = bo(i, h);
    if (ga(u))
      return kg(u.value, s, a), !0;
  }
  return kg(i, n, a), !0;
}
function Ve(n) {
  var e;
  if (!(n != null && n[0]) || !this) return null;
  let t;
  if ("gs" in this && typeof ((e = this == null ? void 0 : this.gs) == null ? void 0 : e[n[0]]) < "u")
    t = bo(this.gs, n);
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    t = bo(this, n);
  else
    return console.warn("getData path not found", n), null;
  return ga(t) || t && typeof t == "object" && "value" in t ? t.value : t;
}
function Zk(n) {
  var t;
  if (!(n != null && n[0])) return null;
  if ("optionsStore" in this && typeof ((t = this == null ? void 0 : this.optionsStore) == null ? void 0 : t[n[0]]) < "u")
    return bo(this.optionsStore, n);
  if (typeof (this == null ? void 0 : this[n[0]]) < "u") return bo(this, n);
}
function vc(n) {
  n.queue = 0, n.stockCount = 0, n.shapeCount = 0, n.resultCount = 0, n.complete = !1;
}
function QS(n, t) {
  return n != null && n.length ? n.find((e) => e.id === t) : null;
}
function t6(n, t, e = "") {
  if (!(n != null && n.length) || !t) return [];
  const i = n.filter((r) => {
    var s, o, a;
    if (e) {
      if (e === "ptx") return (((a = r == null ? void 0 : r.stock) == null ? void 0 : a.id) ?? (r == null ? void 0 : r.stockId)) === t.id;
    } else return (((s = r == null ? void 0 : r.stock) == null ? void 0 : s.id) ?? (r == null ? void 0 : r.stockId)) === t.id && !((o = r == null ? void 0 : r.guillotineData) != null && o.ptxDummyCut);
  });
  return i.sort((r, s) => {
    var o, a;
    return ((o = r == null ? void 0 : r.guillotineData) == null ? void 0 : o.order) - ((a = s == null ? void 0 : s.guillotineData) == null ? void 0 : a.order);
  }), i;
}
function e6(n) {
  return n != null && n.length ? n.filter((t) => t.used === !0) : [];
}
function n6(n = !1) {
  let t = Ve.call(this, ["inputStock"]);
  if (!(t != null && t.length)) return [{ message: "No stock input" }];
  const e = Ve.call(this, ["stockList"]);
  e && (e.length = 0);
  const i = [];
  n && (t = [t[0]]);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    !(s != null && s.q) && !s.autoAdd && !n || i.push(...this.createStock(s, r));
  }
  return i;
}
function i6() {
  const n = Ve.call(this, ["vis"]);
  if (!n) return;
  const t = Ve.call(this, ["shapeList"]);
  if (!(t != null && t.length)) return !1;
  n.resetPositions(), n.resetShapes();
  const e = Ve.call(this, ["activeShapes"]);
  n.initShapes(e, t);
  const i = xa.call(this, "PartsBin");
  i && i.clear(!1);
}
function r6() {
  const n = Ve.call(this, ["vis"]);
  if (!n) return;
  const t = Ve.call(this, ["stockList"]);
  if (!(t != null && t.length)) return !1;
  const e = Ve.call(this, ["activeStock"]);
  n.initStock(e);
  const i = Ve.call(this, ["activeCuts"]);
  n.initCuts(i);
  const r = Ve.call(this, ["activeSegments"]);
  n.initSegments(r), n.resetPositions(), typeof this.toggleSegments == "function" && this.toggleSegments(!1), this != null && this.cutMode && (this == null || this.showCut(0));
}
function s6() {
  var t;
  const n = ((t = this == null ? void 0 : this.gs) == null ? void 0 : t.vis) ?? (this == null ? void 0 : this.vis);
  n && (n.clearSelection(), n.resetShapeAxes(), n.resetCutMeasurementAxes(), n.resetPositions());
}
function o6(n) {
  Ve.call(this, ["examineShape"]) && (this.examineShape = null), Xe.call(this, ["activeStockId"], n);
}
function Hg() {
  return this != null && this.$parent ? this.$parent : null;
}
function xa(n, t = 0) {
  var r;
  let e = this;
  for (let s = 0; s < t; s++) {
    if (!Hg.call(e))
      return null;
    e = Hg.call(e);
  }
  const i = (r = e == null ? void 0 : e.$refs) == null ? void 0 : r[n];
  return i || null;
}
function a6(n = void 0) {
  return this.socket = Vu(n, {
    withCredentials: !0,
    //this is required to send passport user data
    autoConnect: !1
  }), this.socket.on("connect", () => {
    Xe.call(this, ["connected"], !0);
  }), this.socket.on("maintenance", () => {
    Xe.call(this, ["maintenanceMode"], !0), this.socket.disconnect(), this.env === "development" && console.log("SmartCut - maintenance mode flag received from server");
  }), this.socket.on("connect_error", (t) => {
    Xe.call(this, ["connected"], !1), console.warn(`SmartCut - socket connect_error: ${t.message}`), typeof alert < "u" && alert("We are having trouble connecting to the server. Please try again later."), this.socket.close();
  }), this.socket.on("message", (t) => console.log(t)), this.socket.on("user", (t) => {
    Xe.call(this, ["user"], t);
  }), this.socket.on("queued", () => {
    Xe.call(this, ["progress", "queue"], 1);
  }), this.socket.on("jobInProgess", (t) => (alert(`You already have a job in progress, please wait for it to finish

Job ID: ${t}`), !1)), this.socket.on("jobStart", () => Xe.call(this, ["progress", "queue"], 2)), this.socket.on("progress", (t) => {
    const e = t.data;
    if (typeof e.shapeCount < "u" && Xe.call(this, ["progress", "shapeCount"], e.shapeCount), typeof e.stockCount < "u" && Xe.call(this, ["progress", "stockCount"], e.stockCount), !e.stockCount && !e.shapeCount) {
      const i = Ve.call(this, ["progress", "resultCount"]);
      Xe.call(this, ["progress", "resultCount"], i + 1);
    }
  }), this.socket.on("upgrade", () => {
    "showUpgradeModal" in this && typeof this.showUpgradeModal == "function" && this.showUpgradeModal(), Xe.call(this, ["thinking"], !1);
  }), this.socket.on("error", (t) => {
    var i;
    Xe.call(this, ["thinking"], !1);
    const e = Ve.call(this, ["reset"]);
    typeof e == "function" && e(), console.error("SmartCut error:", t), (i = window == null ? void 0 : window.top) == null || i.postMessage(
      {
        type: "scError",
        message: t
      },
      "*"
    ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage(t), typeof this.showModalMessage == "function" && this.showModalMessage({
      heading: "Issue",
      main: t ? `<p>${t}</p>` : "<p>We are having trouble connecting to the server.</p><p>Please try again later and let us know.</p>"
    });
  }), this.socket.on("result", (t) => {
    var l, h, u, d, p, f, m, b, x, y;
    this.socket.disconnect();
    const e = t.result;
    if (Xe.call(this, ["metadata"], e.metadata ?? {}), Xe.call(this, ["unusableShapes"], e.unusableShapes ?? []), Xe.call(this, ["unavailableStock"], e.unavailableStock ?? []), !((l = e.shapeList) != null && l.length) || !((h = e.stockList) != null && h.length)) {
      const v = Ve.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let k = "<p>We did not manage to fit any parts.</p>";
        (u = e == null ? void 0 : e.unusableShapes) != null && u.length ? (k = "<p>No parts were usable.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "Parts unusable",
          main: k,
          buttonText: "Show me",
          buttonCallback: (C) => {
            C.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (k += "<p>Please double check your list.</p>", this.$nextTick(() => {
          this.showModalMessage({
            heading: "Parts unusable",
            main: k
          });
        }));
      }
      return (d = window == null ? void 0 : window.top) == null || d.postMessage(
        {
          type: "scError",
          message: "No parts were added - please double check your list."
        },
        "*"
      ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage("No parts were added - please double check your list."), Xe.call(this, ["thinking"], !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0), !1;
    }
    e.shapeList.find((v) => !v.added) && typeof this.showModalMessage == "function" && this.$nextTick(() => {
      this.showModalMessage({
        heading: "Parts not used",
        main: "<p>We did not use all your parts.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>",
        buttonText: "Show me",
        buttonCallback: (v) => {
          v.showInputPanel(
            "parts",
            "inputs-unusable-parts"
          );
        }
      });
    }), Xe.call(this, ["progress", "complete"], !0), Xe.call(this, ["jobId"], t == null ? void 0 : t.jobId), typeof this.toggleWidget == "function" && (this.toggleWidget("updateStock", !1), this.toggleWidget("options", !1), this.toggleWidget("offcuts", !1), this.toggleWidget("results", !1), this.toggleWidget("cutlist", !1), this.toggleWidget("export", !1), this.toggleWidget("labels", !1));
    let i;
    e != null && e.saw && (i = new Bs(
      e == null ? void 0 : e.saw,
      ((p = e == null ? void 0 : e.saw) == null ? void 0 : p.stockType) ?? ((m = (f = e.stockList) == null ? void 0 : f[0]) == null ? void 0 : m.type)
    ), Xe.call(this, ["saw"], i));
    const r = Bb({
      saw: i,
      stockList: e.stockList,
      removeScores: !0,
      preventAutoRotation: !0
    });
    Xe.call(this, ["stockList"], r);
    const s = Ve.call(this, ["usedStock"]);
    s.length && Xe.call(this, ["activeStockId"], s[0].id), Xe.call(
      this,
      ["shapeList"],
      jb({
        shapeList: e.shapeList,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.cutList && Xe.call(
      this,
      ["cutList"],
      qb({
        cutList: e.cutList,
        stockList: r
      })
    ), e != null && e.segmentList && Xe.call(
      this,
      ["segmentList"],
      zb({
        segmentList: e.segmentList,
        stockList: r
      })
    ), e != null && e.offcuts && Xe.call(
      this,
      ["offcuts"],
      Ub({
        offcuts: e.offcuts,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.metadata && Xe.call(this, ["metadata"], e.metadata), (b = e == null ? void 0 : e.evolutionVisData) != null && b.length ? Xe.call(this, ["evolutionVisData"], e.evolutionVisData) : typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "evolution", !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "workbench", !0), Xe.call(this, ["thinking"], !1);
    const o = xa.call(this, "inputs");
    if (o && (o != null && o.success) && (o.success = !1), Ve.call(this, ["addedShapes"]).length === 0) {
      const v = Ve.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let k = "<p>We could not fit any parts.</p>";
        (x = e == null ? void 0 : e.unusableShapes) != null && x.length ? (k += "<p>Some parts were not usable - click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "No layouts",
          main: k,
          buttonText: "More info",
          buttonCallback: (C) => {
            C.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (k += "<p>Please double check your list.</p>", this.showModalMessage({
          heading: "No layouts",
          main: k
        }));
      }
      (y = window == null ? void 0 : window.top) == null || y.postMessage(
        {
          type: "scError",
          message: "No parts were added."
        },
        "*"
      ), console.warn("No parts were added."), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0);
    }
  }), this.socket;
}
function l6(n) {
  return !n || !ko(n, !0) ? "" : Object.values(n).filter((t) => t).join("|");
}
function $d(n, t, e = "Options") {
  if (!e && `${t}` in n && typeof n[t] == "object") return !0;
  const i = `${t}${e}`;
  return !!(e && i in n && typeof n[i] == "object");
}
function Ud(n) {
  return `${n}Options`;
}
function u6(n, t, e) {
  const i = Ud(t);
  for (const r in n[i]) {
    const s = Object.keys(n[i][r]);
    for (const o of s)
      e.includes(o) || o in n[i][r] && delete n[i][r][o];
    for (const o of e)
      (r === "all" || !(o in n[i][r])) && (n[i][r][o] = "");
  }
}
function c6(n, t, e = !0) {
  if (!$d(n, t, "Options")) return;
  const i = n[t], r = Object.keys(i);
  for (const s of r)
    Mm(n, t, s, e);
  e && Rm(n, t, "all");
}
function Mm(n, t, e, i = !0) {
  i && Rm(n, t, e), e !== "all" && $d(n, t) && (n[t][e] = !1);
}
function Rm(n, t, e) {
  if (!$d(n, t, "Options")) return;
  const r = n[`${t}Options`][e];
  if (typeof r != "object" || r === null) return;
  Object.keys(r).forEach((o) => r[o] = "");
}
function Dm(n, t, e, i, r, s) {
  var u;
  const o = t + "Options";
  if (!((u = n == null ? void 0 : n[o]) != null && u[e]) || !(i in n[o][e])) return;
  Tl(n, t, e, !1), n[o][e][i] = r;
  const a = n[o][e], l = Object.values(a || {}).filter((d) => d);
  if (!Array.isArray(l)) return;
  const h = wc(n, t, e, s);
  Tl(n, t, e, !!Zn(h));
}
function h6(n, t, e, i, r = [], s) {
  const o = t + "Options";
  if (!n[o] || typeof n[o] != "object") return;
  const a = Object.keys(n[o]);
  if (!a.length) return;
  const l = wc(n, t, "all", s), h = n[o][e], u = Object.values(h || {}).filter((d) => d);
  for (const d of a)
    d !== "all" && (r.includes(d) || (Dm(n, t, d, e, i, s), Array.isArray(u) || Tl(n, t, d, !1), Tl(n, t, d, !!Zn(l))));
}
function Tl(n, t, e, i) {
  var o;
  if (e === "all") return;
  const r = Ud(t), s = l6((o = n == null ? void 0 : n[r]) == null ? void 0 : o[e]);
  i ? n[t][e] = s || !0 : n[t][e] = !1;
}
function wc(n, t, e, i) {
  var l;
  const r = t + "Options";
  if (!((l = n == null ? void 0 : n[r]) != null && l[e])) return !1;
  const s = n[r][e], o = Object.values(s || {}).filter((h) => h);
  if (!Array.isArray(o) || !i || typeof i != "function")
    return !1;
  const a = i(t, o);
  return t === "banding" && p1(e) && Zn(a) ? Ob(n, e, a) / 1e3 : a;
}
function Qk(n) {
  n != null && n.type && delete n.type, f6.call(this, n);
}
function f6(n) {
  if (!(n != null && n.banding) || typeof n.banding != "object") return;
  const t = Object.keys(n.banding);
  if (!t.length) return;
  const e = ["labels", "pricing"];
  if (!t.every((i) => e.includes(i)))
    console.warn("SmartCut - legacy banding data provided - please update to use { labels: string[], pricing: Record<string, number> }");
  else return;
  n.banding = {
    labels: Object.keys(n.banding),
    pricing: n.bandingPricing
  };
}
function d6(n) {
  if (n != null && n.enable) return;
  n.enable = {};
  const t = {
    showDiagram: { new: "diagram", map: "equal" },
    enableFocus: { new: "focus", map: "equal" },
    enableMachining: { new: "machining", map: "equal" },
    enableCSVImport: { new: "csvImport", map: "equal" },
    showProgressNumber: { new: "progressNumber", map: "equal" },
    disableBanding: { new: "banding", map: "reverse" },
    disableFinish: { new: "finish", map: "reverse" },
    disableOrientation: { new: "orientation", map: "reverse" },
    disableClick: { new: "click", map: "reverse" },
    disablePartName: { new: "partName", map: "reverse" }
  };
  for (const e of Object.keys(t))
    e in n && (n.enable[t[e].new] = t[e].map === "reverse" ? !n[e] : n[e], delete n[e]);
  console.log(n);
}
function Ef(n = 0, t, e = null, i = null, r = null) {
  if (!hr(e) && !lo || i === "stock") return !1;
  let s, o;
  if (hr(e) ? s = e.orientationLock : lo(e) ? s = e.direction : i === "shape" && (s = r), n === 0 || lo(e))
    switch (t) {
      case "n":
        o = s === "w" || r === "w";
        break;
      case "l":
      case "y":
        o = s === "w" || r === "w";
        break;
      case "w":
        o = s === "l" || r === "l";
        break;
      default:
        o = r === "w";
    }
  else if (n === 1)
    o = e.w > e.l;
  else if (n === 2)
    switch (t) {
      case "n":
        o = e.w > e.l;
        break;
      case "y":
      case "l":
        o = e.w > e.l;
        break;
      case "w":
        o = e.l >= e.w;
        break;
      default:
        o = !1;
    }
  return o;
}
function Gg(n, t, e = null, i = null, r = null) {
  if (!hr(e) || i === "shape") return !1;
  let s;
  return n === 0 || n === 1 ? Ef(n, t, e, i, r) ? "cc" : !1 : n === 2 ? t === "w" ? e.l < e.w ? "c" : "cc" : !1 : s;
}
function p6(n) {
  n.banding && (n.banding = xc(n.banding, "cc")), n.trim && (n.trim = xc(n.trim, "cc"));
}
function g6(n, t = 0) {
  return t && (t === 1 || t === 2) && (n.preventAutoRotation = !0, t === 2 && n.l < n.w && p6(n)), n;
}
function xc(n, t = "cc", e = {
  x1: "y1",
  x2: "y2",
  y1: "x1",
  y2: "x2"
}, i = {
  a: "d",
  b: "a",
  c: "b",
  d: "c"
}) {
  const r = {
    x1: null,
    x2: null,
    y1: null,
    y2: null
  };
  if (t === "c") {
    for (const [s, o] of Object.entries(e))
      r[o] = n[s];
    for (const [s, o] of Object.entries(i))
      o in n && (r[o] = n[s]);
  } else if (t === "cc") {
    for (const [s, o] of Object.entries(e))
      r[s] = n[o];
    for (const [s, o] of Object.entries(i))
      o in n && (r[s] = n[o]);
  }
  return console.log(r), r;
}
const m6 = {
  name: "StockNavigation",
  props: {
    stockList: {
      type: Array,
      default: () => []
    },
    primaryColor: {
      type: String,
      default: ""
    },
    secondaryColor: {
      type: String,
      default: ""
    },
    activeStockId: {
      type: String,
      default: null
    }
  },
  emits: ["show-stock"],
  methods: {
    showStock(n) {
      this.$emit("show-stock", n);
    }
  }
}, Ea = (n, t) => {
  const e = n.__vccOpts || n;
  for (const [i, r] of t)
    e[i] = r;
  return e;
}, y6 = { id: "mini-stock-nav" }, b6 = ["onMousedown"], v6 = { class: "id" };
function w6(n, t, e, i, r, s) {
  return ee(), he("div", y6, [
    (ee(!0), he(Qn, null, Lr(e.stockList, (o, a) => (ee(), he("button", {
      key: a,
      class: di(["nav-button", { selected: o.id === e.activeStockId }]),
      type: "button",
      style: jn({
        backgroundColor: o.id === e.activeStockId ? "#" + e.secondaryColor : "#" + e.primaryColor
      }),
      onMousedown: (l) => s.showStock(o.id)
    }, [
      me("div", v6, gn(a + 1), 1),
      Xg(me("div", { class: "stack legibility" }, gn(o.stack), 513), [
        [Jg, typeof o.stack == "number" && o.stack > 1]
      ])
    ], 46, b6))), 128))
  ]);
}
const x6 = /* @__PURE__ */ Ea(m6, [["render", w6]]), _6 = {
  name: "Spinner",
  props: {
    size: {
      type: Number,
      default: 100
    },
    showNumber: {
      type: Boolean,
      default: !0
    },
    number: {
      type: Number,
      default: 0
    },
    complete: {
      type: Boolean,
      default: !1
    }
  }
}, S6 = { id: "spinner" }, k6 = ["width", "height"], A6 = {
  key: 2,
  id: "spinner-number",
  class: "stock-number"
};
function N6(n, t, e, i, r, s) {
  return ee(), he("div", S6, [
    e.complete ? Ne("", !0) : (ee(), he("svg", {
      key: 0,
      class: "loading",
      style: jn({ width: e.size + "px", height: e.size + "px" }),
      width: e.size,
      height: e.size,
      viewBox: "0 0 300 300"
    }, t[0] || (t[0] = [
      E2('<rect class="square s1" x="0" y="0"></rect><rect class="square s2" x="100" y="0"></rect><rect class="square s3" x="200" y="0"></rect><rect class="square s4" x="0" y="100"></rect><rect class="square s5" x="200" y="100"></rect><rect class="square s6" x="0" y="200"></rect><rect class="square s7" x="100" y="200"></rect>', 7)
    ]), 12, k6)),
    e.complete ? (ee(), he("svg", {
      key: 1,
      class: "complete",
      style: jn({ width: e.size + "px", height: e.size + "px" }),
      viewBox: "0 0 448 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, t[1] || (t[1] = [
      me("path", { d: "m203.3 331.3c-6.2 6.3-16.4 6.3-22.6 0l-64-64c-6.3-6.2-6.3-16.4 0-22.6 6.2-6.3 16.4-6.3 22.6 0l52.7 52.7 116.7-116.7c6.2-6.3 16.4-6.3 22.6 0 6.3 6.2 6.3 16.4 0 22.6zm-203.3-235.3c0-35.35 28.65-64 64-64h320c35.3 0 64 28.65 64 64v320c0 35.3-28.7 64-64 64h-320c-35.35 0-64-28.7-64-64zm32 0v320c0 17.7 14.33 32 32 32h320c17.7 0 32-14.3 32-32v-320c0-17.67-14.3-32-32-32h-320c-17.67 0-32 14.33-32 32z" }, null, -1)
    ]), 4)) : Ne("", !0),
    e.showNumber ? (ee(), he("div", A6, gn(e.number), 1)) : Ne("", !0)
  ]);
}
const Vg = /* @__PURE__ */ Ea(_6, [["render", N6]]);
function C6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "decimal" : "text" : n === "float" ? "decimal" : n === "integer" ? "numeric" : "text";
}
function P6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "number" : "text" : n === "checkbox" ? "checkbox" : n === "float" || n === "integer" ? "number" : "text";
}
function L6(n, t = null, e = "decimal") {
  switch (n) {
    case "float":
    case "integer":
    case "string":
      return n;
    case "unitDependent":
      return e === "decimal" ? "float" : "string";
    case "checkbox":
      return t || "boolean";
    case "select":
      return t || "string";
    default:
      return "string";
  }
}
function I6(n) {
  return !!n;
}
function E6(n, t) {
  return t ? t.split(".").reduce((i, r) => i && i[r] !== "undefined" ? i[r] : void 0, n) : null;
}
function O6(n, t, e, i = !0) {
  const r = t.split(".");
  let s = n;
  for (let o = 0; o < r.length - 1; o++)
    s[r[o]] || (s[r[o]] = {}), s = s[r[o]];
  (i || !qt(s[r[r.length - 1]])) && (s[r[r.length - 1]] = e);
}
function T6(n, t, e, i, r = !0) {
  var o;
  if (!n || !e || !i || !((o = n == null ? void 0 : n[t]) != null && o[e])) return;
  const s = n[t][e].find((a) => a.id === i);
  if (s)
    return r ? s.enabled = !0 : s.enabled = !1, !0;
}
function F6(n, t, e) {
  var i;
  return (i = n == null ? void 0 : n[t]) != null && i[e] ? n[t][e].filter((r) => r.enabled === !0).map((r) => r.id) : [];
}
function M6(n, t, e, i, r = []) {
  const s = F6(n, e, i);
  if (!s.length) return [];
  const o = t.filter((l) => s.includes(l.id) || l.custom === !0), a = o.filter((l) => (l == null ? void 0 : l.fieldMap) && !l.fieldMap.startsWith("customData."));
  if (s.length !== a.length) {
    const l = new Set(a.map((u) => u.id)), h = o.map((u) => u.id).filter((u) => !l.has(u)).map((u) => `'${u}'`);
    console.warn(`Inputs - these fields do not have a field definition - ${h.join()}`);
  }
  return r.length && o.sort((l, h) => {
    const u = r.indexOf(l.id), d = r.indexOf(h.id);
    return u === -1 ? 1 : d === -1 ? -1 : u - d;
  }), o;
}
const R6 = ["id"], D6 = {
  key: 0,
  class: "delete",
  viewBox: "0 0 512 512",
  xmlns: "http://www.w3.org/2000/svg"
}, B6 = /* @__PURE__ */ is({
  __name: "OrientationButton",
  props: {
    id: { default: "" },
    orientationModel: { default: 0 },
    rectangleType: { default: null },
    rectangle: { default: () => null },
    shapeOrientation: { default: "" },
    stockGrain: { default: "n" },
    buttonBackground: { default: "#848484" },
    iconColor: { default: "#FFFFFF" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["updateOrientation"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = Ae(0), s = rn(() => {
      if (!e.rectangle) return ["l", "w"];
      if (lo(e.rectangle)) return ["l", "w"];
      let y = ["", "l", "w"];
      return e.rectangle.multiEdit && (y = [" ", "", "l", "w"]), o.value && (y = y.filter((v) => v !== "w")), y;
    }), o = rn(() => {
      var y, v, k, C;
      return hr(e.rectangle) || Uu(e.rectangle) ? e.rectangle.isSquare() : e.rectangleType && ((y = e.rectangle) != null && y.l) && ((v = e.rectangle) != null && v.w) ? ((k = e.rectangle) == null ? void 0 : k.l) === ((C = e.rectangle) == null ? void 0 : C.w) : !1;
    }), a = () => {
      if (!hr(e.rectangle)) return "";
      let y = "";
      switch (e.orientationModel) {
        case 0:
          y = f.value;
          break;
        case 1:
          e.stockGrain === "y" || e.stockGrain === "n" ? y = e.rectangle.l >= e.rectangle.w ? "l" : "w" : e.rectangle.l >= e.rectangle.w ? y = e.stockGrain : y = y = e.stockGrain === "l" ? "w" : "l";
          break;
        case 2:
          y = e.rectangle.l >= e.rectangle.w ? "l" : "w";
          break;
      }
      return y;
    }, l = (y) => s.value.findIndex((k) => k === y), h = () => {
      if (e.disabled || s.value.length <= 1) return;
      let y = null;
      if ([1, 2].includes(e.orientationModel))
        if (f.value === "") {
          const v = a();
          y = s.value.findIndex((k) => k === v);
        } else
          y = s.value.findIndex((v) => v === "");
      else e.orientationModel === 0 && (y = l(f.value) + 1, y > s.value.length - 1 && (y = 0));
      r.value = y;
    }, u = (y) => {
      (y.key === "Enter" || y.key === " ") && h();
    }, d = (y) => {
      i("updateOrientation", y);
    }, p = () => {
      const y = f.value;
      switch (e.orientationModel) {
        case 0:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        case 1:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        case 2:
          return y ? e.stockGrain === "n" ? y || e.shapeOrientation || "default" : e.stockGrain === "w" ? y === "w" ? "w" : "l" : y === "l" ? "l" : "w" : "default";
        default:
          return "default";
      }
    }, f = rn(() => {
      let y = "";
      return lo(e.rectangle) ? y = e.rectangle.direction : hr(e.rectangle) ? y = e.rectangle.orientationLock : Uu(e.rectangle) && (y = e.rectangle.grain), y;
    }), m = rn(() => lo(e.rectangle) || !e.rectangle ? {
      l: null,
      w: null
    } : {
      l: e.rectangle.l,
      w: e.rectangle.w
    }), b = rn(() => Ef(
      e.orientationModel,
      e.stockGrain,
      e.rectangle,
      e.rectangleType,
      e.shapeOrientation
    )), x = rn(() => {
      var C;
      if (!e.rectangle)
        return e.shapeOrientation ? "noGrain" : "freeRotation";
      if (Uu(e.rectangle) || e.rectangleType === "stock")
        return {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom"
        }[e.rectangle.grain] || "noGrain";
      const y = {
        n: { " ": "delete", l: "leftRight", w: "leftRight", default: "freeRotation" },
        y: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        l: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        w: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        default: { " ": "delete", l: "leftRight", w: "topBottom", default: "freeRotation" }
      }, v = e.stockGrain || "default";
      let k = "default";
      return hr(e.rectangle) || e.rectangleType === "shape" ? k = p() : lo(e.rectangle) && (k = e.rectangle.direction || "default"), ((C = y[v]) == null ? void 0 : C[k]) || y[v].default;
    });
    return fr(r, (y) => {
      d(s.value[y]);
    }, { immediate: !1 }), fr(m, () => {
      if (!e.rectangle || e.orientationModel === 0 || !hr(e.rectangle)) return;
      const y = a();
      f.value && f.value !== y && d(y);
    }, { immediate: !1 }), No(() => {
      document.addEventListener("keydown", u), hr(e.rectangle) ? r.value = l(a()) : r.value = l(f.value);
    }), Of(() => {
      document.removeEventListener("keydown", u);
    }), (y, v) => (ee(), he("div", {
      id: y.id,
      class: di(["orientation-button", { rot: b.value, square: o.value, disabled: y.disabled, [x.value]: !0 }]),
      tabindex: "0",
      "aria-label": "Part orientation",
      style: jn({
        backgroundColor: y.buttonBackground
      }),
      onClick: h
    }, [
      x.value === "delete" ? (ee(), he("svg", D6, v[0] || (v[0] = [
        me("path", { d: "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z" }, null, -1)
      ]))) : Ne("", !0),
      x.value === "freeRotation" ? (ee(), he("svg", {
        key: 1,
        class: "arrow",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 67 63",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[1] || (v[1] = [
        me("g", null, [
          me("path", { d: "m9.296 31.378c0-3.305.67-6.455 1.88-9.322 3.642-8.621 12.179-14.678 22.12-14.678 10.63 0 19.656 6.927 22.806 16.509" }),
          me("path", { d: "m57.296 31.378c0 13.246-10.754 24-24 24-10.631 0-19.656-6.926-22.806-16.508" }),
          me("path", { d: "m61.183 5.408-4.622 17.851-18.347-1.838" }),
          me("path", { d: "m5.408 57.349 4.622-17.851 18.348 1.838" })
        ], -1)
      ]), 4)) : Ne("", !0),
      x.value === "leftRight" ? (ee(), he("svg", {
        key: 2,
        class: "arrow",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 72 39",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[2] || (v[2] = [
        me("g", null, [
          me("path", { d: "m5.408 19.408h61.095" }),
          me("g", null, [
            me("path", { d: "m52.695 5.408 13.808 14-13.808 14" }),
            me("path", { d: "m17.408 33.408-12-14 12-14" })
          ])
        ], -1)
      ]), 4)) : Ne("", !0),
      x.value === "topBottom" ? (ee(), he("svg", {
        key: 3,
        class: "arrow",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 39 72",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[3] || (v[3] = [
        me("g", null, [
          me("path", { d: "m19.408 66.503v-61.095" }),
          me("g", null, [
            me("path", { d: "m5.408 19.216 14-13.808 14 13.808" }),
            me("path", { d: "m33.408 54.503-14 12-14-12" })
          ])
        ], -1)
      ]), 4)) : Ne("", !0),
      x.value === "grainLeftRight" ? (ee(), he("svg", {
        key: 4,
        class: "grain",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 106 64",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[4] || (v[4] = [
        me("g", null, [
          me("path", { d: "m3 3h99.887" }),
          me("path", { d: "m3.113 32h99.887" }),
          me("path", { d: "m3.113 61h99.887" })
        ], -1)
      ]), 4)) : Ne("", !0),
      x.value === "grainTopBottom" ? (ee(), he("svg", {
        key: 5,
        class: "grain",
        style: jn({
          stroke: y.iconColor ? y.iconColor : "#ffffff"
        }),
        viewBox: "0 0 64 106",
        xmlns: "http://www.w3.org/2000/svg"
      }, v[5] || (v[5] = [
        me("g", null, [
          me("path", { d: "m61 3v99.887" }),
          me("path", { d: "m32 3.113v99.887" }),
          me("path", { d: "m3 3.113v99.887" })
        ], -1)
      ]), 4)) : Ne("", !0)
    ], 14, R6));
  }
}), j6 = ["id"], q6 = /* @__PURE__ */ is({
  __name: "BandingButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    orientationModel: { default: 0 },
    stockGrain: { default: "n" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = Ae({
      x1: !1,
      x2: !1,
      y1: !1,
      y2: !1
    });
    fr(() => e.inputShape.orientationLock, () => {
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 }), fr([
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.banding;
      },
      () => e.orientationModel,
      () => e.stockGrain,
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.orientationLock;
      }
    ], () => {
      var u;
      if (!((u = e.inputShape) != null && u.banding)) return;
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 });
    const s = rn(() => r.value), o = (l) => {
      (l.key === "Enter" || l.key === " ") && a();
    }, a = () => {
      e.disabled || i("clicked");
    };
    return No(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.addEventListener("keydown", o);
    }), Of(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.removeEventListener("keydown", o);
    }), (l, h) => (ee(), he("div", {
      id: l.id,
      class: di(["banding-button", { open: l.open, disabled: l.disabled }]),
      tabindex: "0",
      onClick: a
    }, [
      me("div", {
        class: di(["outer", {
          x1: s.value.x1,
          x2: s.value.x2,
          y1: s.value.y1,
          y2: s.value.y2
        }])
      }, h[0] || (h[0] = [
        me("div", { class: "inner" }, null, -1)
      ]), 2)
    ], 10, j6));
  }
}), z6 = ["unitDependent", "string", "integer", "float", "checkbox", "select"], $6 = {
  name: "CustomInput",
  props: {
    type: {
      type: String,
      default: "string",
      validator(n) {
        return z6.includes(n);
      }
    },
    value: {
      type: [String, Boolean, Number],
      default: null
    },
    //element id
    id: {
      type: String,
      default: ""
    },
    focus: {
      type: Boolean,
      default: !1
    },
    enableLabel: {
      type: Boolean,
      default: !0
    },
    labelPosition: {
      type: String,
      default: "first",
      validator(n) {
        return ["first", "last"].includes(n);
      }
    },
    //used for select / checkbox
    output: {
      type: String,
      default: "string",
      validator(n) {
        return ["string", "integer", "float", "boolean"].includes(n);
      }
    },
    options: {
      type: Array,
      default: () => []
    },
    selectFirstOptionDisabled: {
      type: Boolean,
      default: !0
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: !0
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: !1
    },
    default: {
      type: [String, Number, Boolean],
      default: ""
    },
    units: {
      type: String,
      default: "decimal",
      validator(n) {
        return ["decimal", "fraction"].includes(n);
      }
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    custom: {
      type: Boolean,
      default: !1
    },
    multiEdit: {
      type: Boolean,
      default: !1
    },
    allowBlank: {
      type: Boolean,
      default: !1
    },
    text: {
      type: Object,
      default: () => ({
        select: "Select",
        delete: "Delete"
      })
    },
    issue: {
      type: Boolean,
      default: !1
    },
    warning: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update", "default"],
  computed: {
    thisId() {
      return this.custom ? "custom-" + this.id : this.id;
    },
    inputType() {
      return P6(this.type, this.units);
    },
    inputMode() {
      return C6(this.type, this.units);
    },
    outputType() {
      return L6(this.type, this.output, this.units);
    }
  },
  watch: {
    options: {
      handler() {
        this.value && (this.options.find((n) => n.value == this.value) || this.updateValue(""));
      },
      deep: !1,
      immediate: !1
    }
    /* value: {
    	handler( value )
    	{
    		console.log( 'value changed', value )
    	},
    	deep: false,
    	immediate: true
    } */
  },
  created() {
    this.setDefault();
  },
  mounted() {
    const n = xa.call(this, "input");
    n && this.focus && this.$nextTick(() => n.focus());
  },
  methods: {
    getType() {
      return this.type === "unitDependent" ? this.units === "fraction" ? "string" : "float" : this.type;
    },
    handleInput(n) {
      let t = n.target.value;
      switch ((t === "" || t === null) && this.allowBlank && this.updateValue(null), this.getType()) {
        case "integer":
          t = t.replace(/[^0-9-]/g, ""), t = parseInt(t);
          break;
        case "float":
          t = t.replace(/[^0-9.-]/g, ""), t = parseFloat(t);
          break;
      }
      if ((this.getType() === "integer" || this.getType() === "float") && isNaN(t))
        return this.updateValue(null);
      typeof this.min == "number" && t < this.min && (t = this.min), typeof this.max == "number" && t > this.max && (t = this.max), this.updateValue(t);
    },
    updateValue(n, t = "update") {
      if (n === null) return this.$emit(t, n);
      if (this.type === "unitDependent" || this.output === "unitDependent") {
        if (this.units === "fraction")
          return n = n.replace(/[^0-9/ ]+/g, "").replace(/\s{2,}/g, " ").trim(), this.$emit(t, n);
        if (this.units === "decimal")
          return this.$emit(t, parseFloat(n));
      }
      switch (this.outputType) {
        case "string":
          return this.$emit(t, n);
        case "integer":
          return this.$emit(t, parseInt(n));
        case "float":
          return this.$emit(t, parseFloat(n));
        case "boolean":
          return this.$emit(t, I6(n));
        default:
          return this.$emit(t, n);
      }
    },
    setDefault() {
      !qt(this.value) && qt(this.default) && this.updateValue(this.default);
    }
  }
}, U6 = ["for"], W6 = ["id", "inputmode", "type", "value", "placeholder", "disabled", "readonly", "min", "max", "aria-label"], H6 = ["id", "disabled", "checked", "aria-label"], G6 = ["id", "value", "disabled", "aria-label"], V6 = ["disabled", "selected"], Y6 = {
  key: 0,
  value: " "
}, K6 = ["hidden", "value"], X6 = ["for"];
function J6(n, t, e, i, r, s) {
  var o, a, l, h;
  return ee(), he(Qn, null, [
    e.label && e.enableLabel && e.labelPosition === "first" ? (ee(), he("label", {
      key: 0,
      for: s.thisId
    }, gn(e.label), 9, U6)) : Ne("", !0),
    e.type === "string" || e.type === "integer" || e.type === "float" || e.type === "unitDependent" ? (ee(), he("input", {
      key: 1,
      id: s.thisId,
      ref: "input",
      inputmode: s.inputMode,
      type: s.inputType,
      value: e.value,
      placeholder: e.placeholder,
      disabled: e.disabled,
      readonly: e.readonly,
      class: di({ issue: e.issue, warning: e.warning }),
      min: e.min,
      max: e.max,
      "aria-label": e.label,
      onChange: t[0] || (t[0] = (...u) => s.handleInput && s.handleInput(...u))
    }, null, 42, W6)) : Ne("", !0),
    e.type === "checkbox" ? (ee(), he("input", {
      key: 2,
      id: s.thisId,
      ref: "input",
      type: "checkbox",
      disabled: e.readonly || e.disabled,
      checked: e.value === e.trueValue,
      "aria-label": e.label,
      class: di({ issue: e.issue, warning: e.warning }),
      onChange: t[1] || (t[1] = (u) => s.updateValue(u.target.checked ? e.trueValue : e.falseValue))
    }, null, 42, H6)) : Ne("", !0),
    e.type === "select" ? (ee(), he("select", {
      key: 3,
      id: s.thisId,
      ref: "input",
      value: e.value,
      disabled: e.readonly || e.disabled,
      "aria-label": e.label,
      class: di({ issue: e.issue, warning: e.warning }),
      onChange: t[2] || (t[2] = (u) => s.updateValue(u.target.value))
    }, [
      me("option", {
        value: "",
        disabled: e.selectFirstOptionDisabled,
        selected: !e.value
      }, gn(((a = (o = e.text) == null ? void 0 : o.select) == null ? void 0 : a.toUpperCase()) ?? "SELECT"), 9, V6),
      e.multiEdit ? (ee(), he("option", Y6, gn(((h = (l = e.text) == null ? void 0 : l.delete) == null ? void 0 : h.toUpperCase()) ?? "DELETE"), 1)) : Ne("", !0),
      (ee(!0), he(Qn, null, Lr(e.options, (u) => {
        var d, p, f;
        return ee(), he("option", {
          key: u.value,
          hidden: u.hidden,
          value: u.value
        }, gn(((d = u == null ? void 0 : u.label) == null ? void 0 : d.toUpperCase()) ?? ((f = (p = u == null ? void 0 : u.value) == null ? void 0 : p.toString()) == null ? void 0 : f.toUpperCase())), 9, K6);
      }), 128))
    ], 42, G6)) : Ne("", !0),
    e.label && e.enableLabel && e.labelPosition === "last" ? (ee(), he("label", {
      key: 4,
      for: e.id
    }, gn(e.label), 9, X6)) : Ne("", !0)
  ], 64);
}
const wl = /* @__PURE__ */ Ea($6, [["render", J6]]), Z6 = {
  key: 0,
  class: "inputs"
}, Q6 = { class: "label" }, tk = { class: "label" }, ek = { class: "label" }, nk = ["onClick"], ik = { class: "price" }, rk = ["aria-label"], Yg = /* @__PURE__ */ is({
  __name: "ExtrasInputs",
  props: {
    translate: { type: Boolean, default: !0 },
    shape: {},
    shapeIndex: { default: 0 },
    extraType: {},
    extraLabel: {},
    extraKeys: {},
    allOptions: {},
    pricing: { default: () => ({}) },
    labels: {},
    userFriendlyFieldMap: {},
    partColumns: {},
    orientationModel: { default: 0 },
    getPrice: {},
    formatPrice: {},
    getAvailablePricingOptions: {}
  },
  emits: ["update-all", "set"],
  setup(n, { emit: t }) {
    const e = n, i = t, { t: r } = Zg({
      inheritLocale: !0,
      useScope: "global"
    }), s = Ae(!1), o = rn(() => e.extraType + "Options"), a = rn(() => {
      var x;
      if (!((x = e.allOptions) != null && x.length)) return "auto";
      const m = e.allOptions.length;
      return m ? `repeat(${m + 3 - 1}, minmax(20px, max-content)) 1fr` : "auto";
    }), l = (m, b) => {
      i("update-all", e.shape, e.extraType, m, b);
    }, h = (m, b, x) => {
      i("set", e.shape, e.extraType, m, b, x);
    }, u = (m, b, x, y, v) => {
      var q;
      if (!m) return [];
      const k = (q = b == null ? void 0 : b[x]) == null ? void 0 : q[y];
      if (!k)
        return console.error(`ExtrasInputs: cannot find pricing options for ${x} > ${y}`), [];
      const C = Object.values(k);
      if (!C.length)
        return console.error(`ExtrasInputs: cannot find pricing options for ${x} > ${y}`), [];
      const E = C.filter((T) => typeof T == "string");
      return e.getAvailablePricingOptions ? e.getAvailablePricingOptions(m, E, v) : (console.error("ExtrasInputs: cannot find pricing function in parent"), []);
    }, d = (m) => {
      if (!e.pricing || !Object.values(e.pricing).length) return "";
      if (!e.getPrice)
        return console.error("ExtrasInputs: cannot find getExtrasPrice or formatPrice in parent"), "";
      const b = e.getPrice(e.shape, e.extraType, m);
      return b ? e.formatPrice(b) : "";
    }, p = () => {
      const m = [];
      e.extraType in e.shape || m.push({ message: `The extra type '${e.extraType}' does not exist in the shape.` }), o.value in e.shape || m.push({ message: `The options key '${o.value}' does not exist in the shape.` }), m.length && (s.value = !0, console.error("pre-flight issues found in ExtrasInputs: " + m.map((b) => b.message).join(" ")));
    }, f = (m) => Jb(m);
    return No(() => p()), (m, b) => {
      var y, v, k, C, E, q, T, F;
      const x = Fl("font-awesome-icon");
      return s.value ? Ne("", !0) : (ee(), he("div", {
        key: 0,
        class: di(["extras group", [m.extraType]]),
        style: jn({ "grid-column-end": "span " + (m.partColumns + 1) })
      }, [
        m.allOptions.length === 1 && m.allOptions[0].length === 1 ? (ee(), he("div", Z6, [
          me("div", Q6, gn(f((v = (y = m.allOptions) == null ? void 0 : y[0]) == null ? void 0 : v[0])), 1),
          (k = m.shape) != null && k[o.value] && "all" in m.shape[o.value] ? (ee(), Wn(wl, {
            key: 0,
            id: `${m.extraType}-all-${m.shapeIndex}`,
            type: "checkbox",
            label: f(Pe(r)("all")),
            "true-value": (E = (C = m.allOptions) == null ? void 0 : C[0]) == null ? void 0 : E[0],
            "false-value": "",
            value: (T = m.shape[o.value].all) == null ? void 0 : T[(q = m.labels) == null ? void 0 : q[0]],
            onUpdate: b[0] || (b[0] = (M) => {
              var B, P;
              h("all", (B = m.labels) == null ? void 0 : B[0], M), l((P = m.labels) == null ? void 0 : P[0], M);
            })
          }, null, 8, ["id", "label", "true-value", "value"])) : Ne("", !0),
          (ee(!0), he(Qn, null, Lr(m.extraKeys, (M) => {
            var B, P, A, I, S, X;
            return ee(), he(Qn, { key: M }, [
              (B = m.labels) != null && B[0] && ((A = (P = m.shape) == null ? void 0 : P[o.value]) != null && A[M]) && m.labels[0] in m.shape[o.value][M] ? (ee(), Wn(wl, {
                key: 0,
                id: `${m.extraType}-${M}-${m.shapeIndex}`,
                type: "checkbox",
                label: f(Pe(r)((I = m.userFriendlyFieldMap) == null ? void 0 : I[M])),
                "true-value": (X = (S = m.allOptions) == null ? void 0 : S[0]) == null ? void 0 : X[0],
                "false-value": "",
                value: m.shape[o.value][M][m.labels[0]],
                onUpdate: (H) => h(M, m.labels[0], H)
              }, null, 8, ["id", "label", "true-value", "value", "onUpdate"])) : Ne("", !0)
            ], 64);
          }), 128))
        ])) : (ee(), he("div", {
          key: 1,
          class: "grid inputs",
          style: jn({
            "grid-template-columns": a.value
          })
        }, [
          (F = m.shape) != null && F[o.value] && "all" in m.shape[o.value] ? (ee(), he(Qn, { key: 0 }, [
            me("div", tk, gn(f(Pe(r)("all"))), 1),
            (ee(!0), he(Qn, null, Lr(m.allOptions, (M, B) => {
              var P, A;
              return ee(), Wn(wl, {
                id: `${m.extraType}-all-${m.labels[B]}-${B}-${m.shapeIndex}`,
                key: `${m.extraType}-all-${m.labels[B]}-${B}-${m.shapeIndex}`,
                type: "select",
                disabled: u(m.pricing, m.shape, o.value, "all", B).length === 0,
                options: u(m.pricing, m.shape, o.value, "all", B).map((I) => ({ value: I, label: I })),
                text: { select: "✘" },
                "select-first-option-disabled": !1,
                value: (A = m.shape[o.value].all) == null ? void 0 : A[(P = m.labels) == null ? void 0 : P[B]],
                onUpdate: (I) => {
                  var S, X;
                  h("all", (S = m.labels) == null ? void 0 : S[B], I), l((X = m.labels) == null ? void 0 : X[B], I);
                }
              }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
            }), 128)),
            b[2] || (b[2] = me("div", null, null, -1)),
            b[3] || (b[3] = me("div", null, null, -1))
          ], 64)) : Ne("", !0),
          (ee(!0), he(Qn, null, Lr(m.extraKeys, (M) => {
            var B, P;
            return ee(), he(Qn, { key: M }, [
              (B = m.shape) != null && B[o.value] && M in m.shape[o.value] ? (ee(), he(Qn, { key: 0 }, [
                me("div", ek, gn(f(Pe(r)((P = m.userFriendlyFieldMap) == null ? void 0 : P[M]))), 1),
                (ee(!0), he(Qn, null, Lr(m.allOptions, (A, I) => {
                  var S;
                  return ee(), Wn(wl, {
                    id: `${m.extraType}-${M}-${m.labels[I]}-${I}-${m.shapeIndex}`,
                    key: `${m.extraType}-${M}-${m.labels[I]}-${I}-${m.shapeIndex}`,
                    type: "select",
                    disabled: u(m.pricing, m.shape, o.value, M, I).length === 0,
                    options: u(m.pricing, m.shape, o.value, M, I).map((X) => ({
                      value: X,
                      label: X
                    })),
                    text: { select: "✘" },
                    "select-first-option-disabled": !1,
                    value: m.shape[o.value][M][(S = m.labels) == null ? void 0 : S[I]],
                    onUpdate: (X) => {
                      var H;
                      return h(M, (H = m.labels) == null ? void 0 : H[I], X);
                    }
                  }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
                }), 128))
              ], 64)) : Ne("", !0),
              me("div", {
                class: "delete",
                onClick: () => Pe(Mm)(m.shape, m.extraType, M)
              }, [
                Cn(x, { icon: ["fass", "trash"] })
              ], 8, nk),
              me("div", ik, gn(d(M) || Pe(r)("N/A")), 1)
            ], 64);
          }), 128))
        ], 4)),
        me("button", {
          type: "button",
          class: "delete icon-left",
          "aria-label": Pe(r)(`delete ${m.extraLabel}`),
          onClick: b[1] || (b[1] = () => Pe(c6)(m.shape, m.extraType, !0))
        }, [
          Cn(x, { icon: ["fass", "trash"] }),
          qu(" " + gn(Pe(r)(`delete ${m.extraLabel}`)), 1)
        ], 8, rk)
      ], 6));
    };
  }
}), sk = ["id", "disabled"], ok = { class: "icon" }, ak = /* @__PURE__ */ is({
  __name: "FinishButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = () => {
      e.disabled || i("clicked");
    };
    return (s, o) => {
      var l, h, u, d;
      const a = Fl("font-awesome-icon");
      return ee(), he("button", {
        id: s.id,
        class: di(["finish-button", {
          "face-a": (h = (l = s.inputShape) == null ? void 0 : l.finish) == null ? void 0 : h.a,
          "face-b": (d = (u = s.inputShape) == null ? void 0 : u.finish) == null ? void 0 : d.b,
          selected: s.open
        }]),
        type: "button",
        tabindex: "0",
        disabled: s.disabled,
        onClick: r
      }, [
        me("div", ok, [
          Cn(a, { icon: ["fass", "spray-can"] })
        ]),
        o[0] || (o[0] = me("div", { class: "indicator" }, null, -1))
      ], 10, sk);
    };
  }
}), lk = is({
  name: "MachiningButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    },
    id: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["open"],
  computed: {
    hasMachining() {
      return d1(this.inputShape);
    },
    disabledOrReadonly() {
      var n;
      return this.disabled || !!((n = this.inputShape) != null && n.readonly);
    }
  },
  methods: {
    openMachining() {
      this.disabled || this.$emit("open");
    }
  }
}), uk = ["id", "disabled"];
function ck(n, t, e, i, r, s) {
  const o = Fl("font-awesome-icon");
  return ee(), he("button", {
    id: n.id,
    class: di(["machining-button", { "has-machining": n.hasMachining }]),
    type: "button",
    disabled: n.disabled,
    onClick: t[0] || (t[0] = (...a) => n.openMachining && n.openMachining(...a))
  }, [
    Cn(o, { icon: ["fass", "hammer"] })
  ], 10, uk);
}
const hk = /* @__PURE__ */ Ea(lk, [["render", ck]]), fk = { id: "uploader" }, dk = {
  key: 0,
  class: "debug"
}, pk = {
  key: 1,
  class: "selected-files"
}, gk = ["src"], mk = ["onClick"], yk = /* @__PURE__ */ is({
  __name: "ImageUpload",
  props: {
    shapeId: {
      type: String,
      required: !0
    },
    prefix: {
      type: String,
      required: !0
    },
    uniqueId: {
      type: String,
      required: !0
    },
    env: {
      type: String,
      required: !1,
      default: "production"
    },
    maxImages: {
      type: Number,
      required: !1,
      default: 5
    },
    images: {
      type: Array,
      required: !0
    }
  },
  emits: ["update", "remove"],
  setup(n, { emit: t }) {
    const e = ho(() => import("./ObjectViewer-CdAg69n5.js")), i = Ae(null), r = Ae(!0), s = Ae({
      shapeId: "",
      files: [],
      previewUrls: [],
      metadata: []
    }), o = n, a = t, l = (m) => ["image/jpeg", "image/jpg", "image/png"].includes(m.type), h = () => {
      var m;
      (m = i.value) == null || m.click();
    }, u = (m) => {
      const b = m.target, x = b.files;
      if (!x) return;
      const y = Array.from(x), v = y.filter((M) => !l(M));
      if (v.length > 0) {
        const M = v.map((B) => B.name).join(", ");
        alert(`Invalid file type(s): ${M}
Only JPG and PNG files are allowed.`), b.value = "";
        return;
      }
      const k = s.value.files || [];
      if (k.length + y.length > o.maxImages) {
        alert(`Maximum ${o.maxImages} images allowed per shape.`), b.value = "";
        return;
      }
      const E = [...k, ...y], q = d(E), T = E.map((M, B) => ({
        originalName: M.name,
        newName: `${o.prefix}-${B + 1}-${o.uniqueId}${p(M.name)}`
      })), F = {
        shapeId: o.shapeId,
        files: E,
        previewUrls: q,
        metadata: T
      };
      s.value = F, a("update", F), b.value = "";
    }, d = (m) => m.map((b) => URL.createObjectURL(b)), p = (m) => m.substring(m.lastIndexOf(".")), f = (m) => {
      URL.revokeObjectURL(s.value.previewUrls[m]);
      const b = [...s.value.files], x = [...s.value.previewUrls], y = [...s.value.metadata];
      if (b.splice(m, 1), x.splice(m, 1), y.splice(m, 1), b.length === 0)
        s.value = {
          shapeId: o.shapeId,
          files: [],
          previewUrls: [],
          metadata: []
        }, a("remove", o.shapeId);
      else {
        const v = {
          shapeId: o.shapeId,
          files: b,
          previewUrls: x,
          metadata: y
        };
        s.value = v, a("update", v);
      }
    };
    return O2(() => {
      var m;
      (m = s.value) != null && m.previewUrls && s.value.previewUrls.forEach((b) => URL.revokeObjectURL(b));
    }), No(() => {
      s.value.shapeId = o.shapeId;
      const m = o.images.find((b) => b.shapeId === o.shapeId);
      if (m) {
        const b = d(m.files);
        s.value = {
          ...m,
          previewUrls: b
        };
      }
    }), (m, b) => {
      var y;
      const x = Fl("font-awesome-icon");
      return ee(), he("div", fk, [
        n.env === "development" && r.value ? (ee(), he("div", dk, [
          Cn(Pe(e), {
            data: [s.value],
            paths: ["imageData"]
          }, null, 8, ["data"])
        ])) : Ne("", !0),
        me("input", {
          ref_key: "fileInput",
          ref: i,
          type: "file",
          accept: ".jpg,.jpeg,.png",
          class: "hidden",
          multiple: "",
          onChange: u
        }, null, 544),
        me("button", {
          type: "button",
          class: "upload-button",
          onClick: h
        }, [
          Cn(x, { icon: ["fass", "files"] })
        ]),
        (y = s.value.files) != null && y.length ? (ee(), he("div", pk, [
          (ee(!0), he(Qn, null, Lr(s.value.files, (v, k) => (ee(), he("div", {
            key: k,
            class: "selected-file"
          }, [
            me("img", {
              src: s.value.previewUrls[k],
              alt: "Preview"
            }, null, 8, gk),
            me("button", {
              class: "remove-file",
              type: "button",
              onClick: (C) => f(k)
            }, [
              Cn(x, { icon: ["fass", "trash"] })
            ], 8, mk)
          ]))), 128))
        ])) : Ne("", !0)
      ]);
    };
  }
}), bk = /* @__PURE__ */ Ea(yk, [["__scopeId", "data-v-b59be53a"]]), vk = {
  key: 0,
  class: "debug"
}, wk = { key: 2 }, xk = {
  key: 0,
  class: "row table-heading"
}, _k = {
  key: 0,
  class: "cell center"
}, Sk = {
  key: 1,
  class: "cell delete"
}, kk = { class: "cell" }, Ak = ["id", "disabled", "onClick"], Nk = {
  key: 0,
  class: "cell center"
}, Ck = ["onClick"], Pk = {
  key: 1,
  class: "cell"
}, Lk = ["disabled", "aria-label", "onClick"], Ik = { class: "button-wrapper main" }, Ek = ["aria-label"], Ok = ["aria-label", "disabled"], Tk = ["aria-label"], Fk = { id: "part-count" }, Mk = {
  key: 3,
  id: "messages"
}, Rk = {
  key: 0,
  class: "heading"
}, Dk = { class: "content" }, Bk = {
  key: 4,
  id: "progress"
}, jk = {
  id: "diagram",
  class: "diagram production"
}, qk = {
  key: 0,
  id: "stack"
}, zk = !0, Bm = /* @__PURE__ */ is({
  __name: "CheckoutCalculator",
  props: {
    debug: {
      type: Boolean,
      default: !1
    },
    units: {
      type: String,
      default: "decimal"
    },
    stock: {
      type: Array,
      default: () => []
    },
    findExtrasPrice: {
      type: Function,
      required: !0
    },
    formatPrice: {
      type: Function,
      required: !0
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["inputs-changed", "calculating", "result", "log", "error"],
  setup(n, { expose: t, emit: e }) {
    const i = ho(() => import("./Machining-Dux3wQBA.js")), r = ho(() => import("./ImportCSV-C4BlyzAh.js")), s = ho(() => import("./ObjectViewer-CdAg69n5.js")), o = n, a = e, { t: l, locale: h } = Zg({
      locale: "en_US",
      useScope: "global"
    }), u = "production", d = window.location.hostname;
    let p = null, f = null;
    const m = Ae(!1), b = Ae(!1), x = Ae(!0), y = fg("Checkout/currentURL", window.location.href), v = Ae(window.innerWidth), k = kw(), C = Ae([]), E = Ae(!1), q = Ae(!1), T = Ae(!1), F = Ae(!1), M = Ae(0), B = Ae(!1), P = Ae(!1), A = Ae(Qb()), I = Ar({
      enable: {
        banding: !1,
        finish: !1,
        orientation: !0,
        diagram: !0,
        focus: !0,
        machining: !0,
        csvImport: !1,
        click: !0,
        partName: !0,
        progressNumber: !0,
        imageUpload: !1
      },
      decimalPlaces: 2,
      stackHeight: 100,
      maxParts: null,
      locale: "en_US",
      orientationModel: 0,
      customFields: [],
      fieldOrder: [],
      units: "decimal",
      minDimension: 0,
      stockSelection: null,
      cutPreference: null,
      bladeWidth: null,
      stockType: null,
      minSpacing: 0,
      stockGrain: null
    }), S = Ae(null), X = Ar({
      bladeWidth: 1,
      cutPreference: "l",
      cutType: "guillotine",
      stockType: "sheet",
      stackHeight: 0,
      options: {
        stockSelection: "efficiency",
        minSpacing: 0
      }
    }), H = fg(
      "Checkout/inputShapes",
      [],
      {
        serializer: {
          read: (lt) => {
            if (!lt) return [];
            const pt = lt ? JSON.parse(lt) : [];
            return Db(pt, o.units);
          },
          write: (lt) => JSON.stringify(lt)
        },
        listenToStorageChanges: !1
      }
    ), j = Ae([]), Q = oo([]), G = oo([]), ft = oo([]), nt = oo([]), N = Ae({
      parts: [],
      stock: []
    }), z = Ae(null), V = Ae(null), Y = Ae(null), ot = rn(() => G.value.filter((lt) => lt.added)), wt = rn(() => G.value.filter((lt) => lt.added && !lt.duplicate)), mt = rn(() => wt.value.filter((lt) => lt.added)), xt = rn(() => Q.value.filter((lt) => lt.used && !lt.duplicate)), zt = rn(() => xt.value.filter((lt) => lt.used).map((lt) => (lt.q = xt.value.filter((pt) => pt.parentID === lt.parentID).reduce(
      (pt, _t) => pt + (typeof (_t == null ? void 0 : _t.stack) == "number" && _t.stack > 0 ? _t.stack : 1),
      0
    ), lt))), Dt = rn(() => e6(Q.value)), Jt = rn(() => Y.value ? QS(Q.value, Y.value) : null), Qt = rn(() => Zb(Q.value)), O = rn(() => G.value.filter((lt) => {
      var pt, _t;
      return lt.added && ((pt = lt == null ? void 0 : lt.stock) == null ? void 0 : pt.id) === ((_t = Jt.value) == null ? void 0 : _t.id);
    })), ct = rn(() => t6(ft.value, Jt.value)), U = rn(() => H.value.reduce((lt, pt) => lt + pt.q, 0)), et = Ae(!1), J = Ae(""), rt = Ae(""), vt = Ar({
      banding: null,
      finish: null,
      info: null,
      imageUpload: null
    }), At = Ae([]), ht = Ae([]), Ot = Ae([]), $t = Ae(!1), Ft = Ar({
      units: "decimal",
      faces: { enabled: !0 },
      holes: { enabled: !1 },
      corners: {
        enabled: !1,
        types: []
      },
      banding: { enabled: !1 },
      hingeHoles: { enabled: !1 },
      shelfHoles: { enabled: !1 }
    }), Ut = Ar({
      labels: [],
      pricing: {},
      options: {},
      keys: gr
    }), ie = Ar({
      labels: [],
      pricing: {},
      options: {},
      keys: ["a", "b"]
    }), oe = Ae({
      queue: 0,
      stockCount: 0,
      shapeCount: 0,
      complete: !1
    }), ae = Ar({
      partA: "#118ab2",
      partB: null,
      partHover: null,
      partSelected: null,
      stock: "#ffd166",
      button: "#118ab2",
      buttonText: "#ffffff",
      text: "#ffffff"
    });
    let dt = null;
    const kt = Ae(!1), te = Ae(!1), Rt = Ar({
      disableClick: !1,
      enableStretch: !0
    }), be = oo(null), Kt = Ar({
      parts: {
        sheet: [
          { id: "material", enabled: !1 },
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "t", enabled: !1 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "banding", enabled: !1 },
          { id: "finish", enabled: !1 },
          { id: "machining", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        linear: [
          { id: "l", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "finish", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        roll: [
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "imageUpload", enabled: !1 }
        ]
      }
    }), jt = Ae([]), ge = rn(() => {
      var pt;
      return [...[
        {
          id: "material",
          fieldMap: "material",
          label: l("material"),
          w: "minmax(20px, max-content)",
          type: "select",
          output: "string",
          default: (pt = At.value[0]) == null ? void 0 : pt.name,
          options: At.value.map((_t) => ({
            value: _t.name,
            label: _t.name
          }))
        },
        {
          id: "t",
          fieldMap: "t",
          w: "minmax(20px, max-content)",
          type: "select",
          output: o.units === "decimal" ? "float" : "string",
          label: l("thickness")
        },
        {
          id: "l",
          fieldMap: "l",
          type: "unitDependent",
          label: l("length"),
          min: 0
        },
        {
          id: "w",
          fieldMap: "w",
          type: "unitDependent",
          label: l("width"),
          min: 0
        },
        {
          id: "q",
          fieldMap: "q",
          type: "integer",
          default: 1,
          label: l("quantity"),
          min: 0
        },
        {
          id: "name",
          fieldMap: "name",
          type: "string",
          label: l("name")
        },
        {
          id: "orientationLock",
          w: "32px",
          label: l("orientation"),
          fieldMap: "orientationLock"
        },
        {
          id: "banding",
          w: "32px",
          label: l("banding"),
          fieldMap: "bandingOptions"
        },
        {
          id: "finish",
          type: "checkbox",
          w: "32px",
          label: l("finish"),
          fieldMap: "finish"
        },
        {
          id: "machining",
          w: "32px",
          label: l("machining"),
          fieldMap: "machining"
        },
        {
          id: "imageUpload",
          w: "32px",
          label: l("image upload"),
          fieldMap: "imageUpload"
        }
      ], ...jt.value];
    }), we = rn(() => M6(
      Kt,
      ge.value,
      "parts",
      X.stockType,
      I.fieldOrder
    )), Rn = rn(() => {
      let lt = we.value.length;
      return H.value.length > 1 && lt++, lt;
    }), Ze = rn(() => {
      const lt = {
        id: "34px",
        del: "30px",
        info: "30px"
      }, pt = [];
      for (const _t of we.value)
        _t.id !== "trim" && pt.push(_t.w ?? "minmax(20px, 1fr)");
      return pt.unshift(lt.id), H.value.length > 1 && pt.push(lt.del), pt.join(" ");
    }), Dn = rn(() => ({
      fontSize: "11px",
      textAlign: "right",
      width: "100%",
      height: "auto",
      position: "relative",
      display: "flex",
      visibility: "visible",
      opacity: "1",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingRight: "10px",
      marginTop: "10px",
      marginBottom: "2px",
      userSelect: "none",
      alignItems: "center"
    })), fn = rn(() => ({
      width: "auto",
      height: "auto",
      display: "inline-block",
      position: "relative",
      visibility: "visible",
      opacity: "1",
      color: "#4e4e4e"
    })), We = (lt, pt) => {
      let _t;
      return function(...Tt) {
        const fe = () => {
          clearTimeout(_t), lt(...Tt);
        };
        clearTimeout(_t), _t = setTimeout(fe, pt);
      };
    }, ke = (lt, pt) => E6(lt, pt), He = (lt, pt, _t, Wt = !0) => {
      O6(lt, pt, _t, Wt);
    }, tr = (lt) => {
      if (o.debug && a("log", ["checkout init...", lt]), lt != null && lt.options) {
        const pt = lt.options;
        d6(pt), [
          "stockType",
          "cutPreference",
          "bladeWidth"
        ].forEach((Tt) => {
          Tt in pt || a("error", `${Tt} is a required option`);
        });
        const Wt = {
          stockType: () => {
            const Tt = ["sheet", "linear", "roll"];
            Tt.includes(pt.stockType) || console.warn(`${pt.stockType} is not a valid stockType, expected ${Tt.join("|")}`), X.stockType = pt.stockType;
          },
          stockSelection: () => {
            const Tt = ["efficiency", "smallest"];
            pt != null && pt.stockSelection && !Tt.includes(pt.stockSelection) ? console.warn(`${pt.stockSelection} is not a valid stockSelection, expected ${Tt.join("|")}`) : X.options.stockSelection = pt.stockSelection;
          },
          minSpacing: () => {
            X.options.minSpacing = pt.minSpacing;
          },
          cutPreference: () => {
            const Tt = ["efficiency", "length", "width", "beam"];
            if (Tt.includes(pt.cutPreference)) {
              const { cutType: fe, cutPreference: le } = nf(pt.cutPreference);
              X.cutType = fe, X.cutPreference = le, X.stackHeight = pt.stackHeight, pt.stockType === "linear" && (X.cutType = null, X.cutPreference = null), pt.cutPreference === "beam" && (X.stackHeight = pt.stackHeight);
            } else
              console.warn(`SmartCut - ${pt.cutPreference} is not one of ${Tt.join("|")}`);
          },
          bladeWidth: () => {
            pt.bladeWidth >= 0 ? X.bladeWidth = pt.bladeWidth : console.warn(`SmartCut - you provided an incorrect blade width of: ${pt.bladeWidth}`);
          },
          colors: () => {
            for (const [Tt, fe] of Object.entries(pt == null ? void 0 : pt.colors))
              fe && (ae[Tt] = fe);
          },
          maxParts: () => {
            I.maxParts = pt.maxParts;
          },
          enable: () => {
            mn("banding", pn(pt, ["enable", "banding"])), mn("finish", pn(pt, ["enable", "finish"])), mn("imageUpload", pn(pt, ["enable", "imageUpload"])), mn("orientationLock", pn(pt, ["enable", "orientation"])), mn("machining", pn(pt, ["enable", "machining"])), P.value = pn(pt, ["enable", "csvImport"]), Rt.disableClick = pn(pt, ["enable", "click"]) === !1, mn("name", pn(pt, ["enable", "partName"]));
          },
          locale: () => {
            h.value = pt.locale;
          },
          customFields: () => {
            var fe;
            if (!Array.isArray(pt.customFields) || !((fe = pt.customFields) != null && fe.length)) return;
            const Tt = [];
            pt.customFields.forEach((le, ve) => {
              Tt.push(le), Tt[ve].custom = !0;
              const Ge = xe(le.id);
              Tt[ve].id = Ge, Tt[ve].fieldMap = "customData." + Ge, le.type === "checkbox" && (Tt[ve].w = "32px"), le.type === "select" && (Tt[ve].output = le.output ?? "string", Tt[ve].options = le.options);
            }), jt.value = Tt, H.value.forEach((le) => {
              le.customData = pt.customFields.reduce((ve, Ge) => {
                const Me = xe(Ge.id);
                return ve[Me] = le.customData[Me] || Ge.default || "", ve;
              }, {});
            });
          }
        };
        for (const Tt in pt) {
          if (Tt === "enable")
            for (const fe in I.enable)
              fe in pt.enable && (I.enable[fe] = pt.enable[fe]);
          I[Tt] = pt[Tt], Tt in Wt && Wt[Tt]();
        }
      }
      hs("banding", lt), hs("finish", lt), Ai(lt), ss(lt), q.value = !0, Qr(() => {
        kt.value || cs(), zi() || alert("The SmartCut credit seems to have been tampered with - this is against our terms of service. Please contact support.");
      }), window.smartcutCheckout = { init: tr };
    }, En = (lt) => {
      if (!j.value.length) return "n";
      const pt = lt.material, _t = lt.t, Wt = j.value.filter((Tt) => Tt.material === pt && Tt.t === _t);
      return Wt.length ? Gb(Wt) : "n";
    }, Bi = (lt, pt) => {
      lt.orientationLock = pt;
    }, mn = (lt, pt = !0) => {
      T6(Kt, "parts", X.stockType, lt, pt);
    }, xe = (lt) => lt ? $l(lt).toLowerCase() : null, Ai = (lt) => {
      var pt, _t, Wt, Tt, fe;
      if (pn(I, ["enable", "machining"]) && lt != null && lt.machining) {
        for (const le in Ft)
          lt.machining[le] && (Ft[le] = lt.machining[le]);
        if (["holes", "hingeHoles"].forEach((le) => {
          var ve, Ge;
          (ve = lt == null ? void 0 : lt.machining) != null && ve[le] && (Ft[le].enabled = (Ge = lt == null ? void 0 : lt.machining) == null ? void 0 : Ge[le].enabled);
        }), (Wt = (_t = (pt = lt == null ? void 0 : lt.machining) == null ? void 0 : pt.corners) == null ? void 0 : _t.types) != null && Wt.length && (Ft.corners.enabled = !0, Ft.corners.types = lt.machining.corners.types), lt.banding && ((fe = (Tt = lt == null ? void 0 : lt.options) == null ? void 0 : Tt.enable) != null && fe.banding)) {
          if (!Ut) return;
          Ft.banding = {
            enabled: !0
          }, Ut.options.length && (Ft.banding.options = Ut.options), Ut.labels.length && (Ft.banding.labels = Ut.labels), ko(Ut.pricing) && (Ft.banding.pricing = Ut.pricing);
        }
      }
    }, ji = (lt = null) => {
      V.value = lt, lt && lt.l && lt.w ? $t.value = !0 : alert("Please enter dimensions first");
    }, ti = () => {
      $t.value = !1, document.exitFullscreen && document.exitFullscreen();
    }, vn = (lt = []) => {
      if (ht.value = [], Ot.value = [], mn("t", !1), !!lt.length) {
        for (const pt of lt)
          if (pt != null && pt.t)
            if (typeof pt.t == "string" && pt.t.includes(",")) {
              const _t = gi(pt.t, !0);
              _t.length === 2 ? (er(_t), mn("t", !0), pt.t = ht.value[0]) : a("error", "bonded thickness found which does not have 2 options");
            } else ht.value.includes(pt.t) || ht.value.push(pt.t);
        ht.value.length > 1 && mn("t", !0);
      }
    }, wn = (lt) => ui(lt).thicknesses.map((_t) => ({
      label: _t == null ? void 0 : _t.toString(),
      value: _t
    })), ui = (lt) => {
      var Tt;
      if (!lt) return { thicknesses: [], bondedThicknesses: [] };
      if (!((Tt = At.value) != null && Tt.length))
        return {
          thicknesses: ht.value,
          bondedThicknesses: []
        };
      if (!lt.material) return { thicknesses: [], bondedThicknesses: [] };
      const pt = At.value.find((fe) => fe.name === lt.material);
      if (!pt) return { thicknesses: [], bondedThicknesses: [] };
      const _t = [...pt.thicknesses], Wt = [];
      for (let fe = 0; fe < _t.length; fe++) {
        const le = _t[fe], ve = gi(le), Ge = [];
        if (ve.length) {
          for (const Me of ve)
            _t[fe] = ne(Me), Ge.push(fe);
          fe++;
        }
        Ge.length && Wt.push(Ge);
      }
      return {
        thicknesses: _t,
        bondedThicknesses: Wt
      };
    }, ss = (lt) => {
      var pt;
      if ((pt = lt == null ? void 0 : lt.stock) != null && pt.some((_t) => _t == null ? void 0 : _t.material)) {
        At.value = [], ht.value = [], Ot.value = [];
        const _t = /* @__PURE__ */ new Map();
        lt.stock.forEach((Wt) => {
          var fe;
          if (!Wt.material) return;
          const Tt = Wt.material.toUpperCase();
          if (_t.has(Tt) || _t.set(Tt, /* @__PURE__ */ new Set()), Wt.t != null) {
            const le = Number(Wt.t);
            isNaN(le) || (fe = _t.get(Tt)) == null || fe.add(le);
          }
        }), At.value = Array.from(_t.entries()).map(([Wt, Tt]) => ({
          name: Wt,
          thicknesses: Array.from(Tt).sort((le, ve) => le - ve)
        })), At.value.length > 1 && mn("material", !0);
      } else
        vn(lt.stock);
    }, er = (lt, pt = null) => {
      if (!Array.isArray(lt)) {
        a("error", "addBondedThicknesses expects an array");
        return;
      }
      const _t = [];
      for (let Wt = 0; Wt < lt.length; Wt++) {
        let Tt = lt[Wt];
        o.units === "decimal" && (Tt = parseFloat(Tt)), ht.value.push(Tt), pt && pt.thicknesses.push(Tt), _t.push(ht.value.length - 1);
      }
      Ot.value.push(_t);
    }, gi = (lt, pt = !1) => {
      if (typeof lt == "string" && lt.includes(",")) {
        const _t = lt.split(",");
        return pt ? _t.map((Wt) => ne(Wt)) : _t;
      }
      return [];
    }, Ni = () => {
      te.value ? qi() : Ci();
    }, Ci = () => {
      document.getElementById("smartcut-checkout").requestFullscreen(), te.value = !0;
    }, qi = () => {
      document.exitFullscreen && document.exitFullscreen(), te.value = !1;
    };
    p = We(() => {
      v.value = window.innerWidth;
    }, 30);
    const zi = () => {
      var Wt, Tt;
      if ((Tt = (Wt = be.value) == null ? void 0 : Wt.api) != null && Tt.whiteLabel) return !0;
      let lt = !0;
      const pt = document.querySelector("#smartcut-app #credit"), _t = document.querySelector("#smartcut-app #credit a");
      return [pt, _t].forEach((fe, le) => {
        if (!fe) return lt = !1;
        const ve = window.getComputedStyle(fe);
        if (ve.display === "none" || ve.display === "hidden" || ve.opacity === "0" || ve.color === "transparent" || ve.position !== "relative" || le === 1 && ve.color !== "#4e4e4e" && ve.color !== "rgb(78, 78, 78)")
          return lt = !1;
      }), x.value = lt, lt;
    }, wr = (lt, pt, _t, Wt, Tt) => {
      Dm(
        lt,
        pt,
        _t,
        Wt,
        Tt,
        o.findExtrasPrice
      );
    }, Dr = (lt, pt, _t, Wt) => {
      h6(
        lt,
        pt,
        _t,
        Wt,
        pt === "banding" ? ql : [],
        o.findExtrasPrice
      );
    }, nr = (lt, pt) => {
      const _t = pt === "banding" ? Ut == null ? void 0 : Ut.labels : ie == null ? void 0 : ie.labels;
      u6(lt, pt, _t);
      const Wt = Ud(pt);
      if (lt != null && lt[Wt])
        for (const Tt in lt[Wt]) {
          const fe = wc(lt, pt, Tt, o.findExtrasPrice);
          Tl(lt, pt, Tt, !!fe);
        }
    }, Br = (lt) => {
      const pt = Object.keys(lt);
      return Math.max(...pt.map((Wt) => Wt.split("|").length));
    }, jr = (lt) => {
      const pt = [], _t = Object.keys(lt), Wt = Br(lt);
      for (let Tt = Wt; Tt--; ) pt.push(/* @__PURE__ */ new Set());
      for (const Tt of _t)
        Tt.split("|").forEach((le, ve) => pt[ve].add(le));
      for (let Tt = 0; Tt < Wt; Tt++)
        pt[Tt] = Array.from(pt[Tt]);
      return pt;
    }, qr = (lt, pt = [], _t) => {
      if (!lt) return [];
      if (_t > 0 && !pt[_t - 1]) return [];
      const Wt = /* @__PURE__ */ new Set();
      for (const Tt of Object.keys(lt)) {
        const fe = Tt.split("|");
        if (fe.length > _t) {
          let le = !0;
          for (let ve = 0; ve < _t; ve++)
            if (pt[ve] && fe[ve] !== pt[ve]) {
              le = !1;
              break;
            }
          le && Wt.add(fe[_t]);
        }
      }
      return Array.from(Wt);
    }, os = (lt, pt, _t) => wc(
      lt,
      pt,
      _t,
      o.findExtrasPrice
    ), Io = (lt = "issues", pt, _t) => JS(lt, pt, _t), as = (lt) => {
      const pt = C.value.findIndex((_t) => _t.shapeId === lt.shapeId);
      pt !== -1 ? C.value[pt] = lt : C.value.push(lt), window.smartcutImages = C.value, console.log("Updated images:", C.value);
    }, Eo = (lt) => {
      C.value = C.value.filter((pt) => pt.shapeId !== lt), window.smartcutImages = C.value, console.log("updated images", C.value);
    }, ls = (lt = 1) => {
      for (let pt = lt; pt--; ) {
        let _t;
        if (H.value.length > 0) {
          const Wt = H.value[H.value.length - 1];
          _t = zr({
            material: Wt.material,
            t: Wt.t
          });
        } else
          _t = zr();
        H.value.push(_t);
      }
    }, $s = (lt) => {
      var _t;
      if (o.readonly || H.value.length === 1) return;
      const pt = H.value[lt].listId;
      H.value.splice(lt, 1), ((_t = V.value) == null ? void 0 : _t.listId) === pt && (V.value = null), vc(oe);
    }, zr = ({
      l: lt = null,
      w: pt = X.stockType === "linear" ? ((Ii) => (Ii = j.value[0]) == null ? void 0 : Ii.w)() : null,
      t: _t = ht.value.length ? ht.value[0] : null,
      q: Wt = 1,
      material: Tt = ((Ma) => (Ma = At.value) == null ? void 0 : Ma.length)() === 1 ? At.value[0].name : "",
      name: fe = null,
      orientationLock: le = I.orientationModel === 2 ? "l" : null,
      bandingOptions: ve = null,
      finishOptions: Ge = null,
      banding: Me = null,
      finish: Le = null,
      customData: je = null,
      readonly: Zt = !1
    } = {}) => {
      var Hs, Gs;
      const mi = new vd({
        id: (H.value.length + 1).toString(),
        units: o.units,
        l: lt,
        w: pt,
        t: _t,
        q: Wt,
        material: Tt,
        name: fe,
        orientationLock: le,
        banding: Me,
        bandingOptions: ve,
        finish: Le,
        finishOptions: Ge,
        customData: je,
        readonly: Zt
      });
      return (Hs = Ut == null ? void 0 : Ut.labels) != null && Hs.length && nr(mi, "banding"), (Gs = ie == null ? void 0 : ie.labels) != null && Gs.length && nr(mi, "finish"), mi;
    }, Oo = ({
      name: lt = "",
      l: pt = null,
      w: _t = null,
      t: Wt = null,
      material: Tt = "",
      q: fe = 1,
      trim: le = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      grain: ve = "",
      cost: Ge = 0,
      allowExactFitShapes: Me = !1,
      notes: Le = ""
    }) => new m1({
      id: (j.value.length + 1).toString(),
      name: lt,
      units: o.units,
      l: pt,
      w: _t,
      t: Wt,
      material: Tt,
      q: fe,
      autoAdd: !0,
      trim: le,
      grain: ve,
      cost: Ge,
      allowExactFitShapes: Me,
      notes: Le
    }), Oa = (lt, pt) => {
      const _t = ne(lt.l), Wt = ne(lt.w), Tt = lt.t ? ne(lt.t) : null, fe = new Bs(X), le = new es({
        id: (pt + 1).toString() + ".0",
        name: lt != null && lt.name ? lt.name : `${_t}x${Wt}`,
        l: _t,
        w: Wt,
        t: Tt,
        saw: fe,
        material: lt.material,
        grain: lt.grain,
        autoAdd: !0,
        cost: lt == null ? void 0 : lt.cost,
        trim: lt.trim,
        allowExactFitShapes: lt.allowExactFitShapes,
        type: X.stockType,
        notes: lt == null ? void 0 : lt.notes
      });
      return Q.value.push(le), le.issues;
    }, us = () => {
      var pt, _t;
      const lt = [];
      for (let Wt = 0; Wt < H.value.length; Wt++) {
        const Tt = H.value[Wt];
        if (ne(Tt.l) < ne(I.minDimension) && Tt.issues.push({
          message: l("Part") + ` ${Wt + 1}: ` + l("Minimum dimension is") + ` ${I.minDimension}`,
          field: ["l"],
          index: Wt
        }), ne(Tt.w) < ne(I.minDimension) && Tt.issues.push({
          message: l("Part") + ` ${Wt + 1}: ` + l("Minimum dimension is") + ` ${I.minDimension}`,
          field: ["w"],
          index: Wt
        }), (pt = Tt == null ? void 0 : Tt.issues) != null && pt.length && lt.push(...Tt.issues.map((ve) => (ve.message = l("Part") + ` ${Wt + 1}: ${ve.message}`, ve))), !Tt.l || !Tt.w || !Tt.q) continue;
        const fe = {
          id: (Wt + 1).toString() + ".0",
          l: ne(Tt == null ? void 0 : Tt.l),
          w: ne(Tt == null ? void 0 : Tt.w),
          t: Tt != null && Tt.t ? ne(Tt.t) : null,
          material: Tt != null && Tt.material ? Tt.material : null,
          q: typeof Tt.q != "number" ? parseInt(Tt.q) : Tt.q,
          name: Tt.name,
          orientationLock: Tt.orientationLock,
          banding: Tt.banding,
          finish: Tt.finish,
          machining: Tt.machining,
          customData: Tt.customData
        }, le = new ns(g6(fe, I.orientationModel));
        G.value.push(le), (_t = le == null ? void 0 : le.issues) != null && _t.length && lt.push(...le.issues);
      }
      return dn(), lt;
    }, Ta = (lt) => {
      o6.call({ activeStockId: Y }, lt);
    }, dn = () => {
      ht.value.length && G.value.forEach((lt) => {
        if (!lt.t) return;
        const pt = ht.value.findIndex(
          (Tt) => ne(Tt) === lt.t
        ), _t = Ot.value.find((Tt) => Tt.includes(pt));
        if (!_t) return;
        const Wt = Math.min(
          ..._t.map((Tt) => ht.value[Tt])
        );
        lt.t > Wt && (lt.q = lt.q * (lt.t / Wt), lt.t = Wt);
      });
    }, To = () => {
      r6.call({
        vis: dt,
        stockList: Q,
        activeStock: Jt,
        activeCuts: ct
      }), i6.call({
        vis: dt,
        shapeList: G,
        activeShapes: O
      }, wt.value.length);
    }, Us = () => {
      vc(oe), Q.value = [], G.value = [], ft.value = [], M.value = 0;
    }, Fo = () => {
      H.value.length = 0, ls(1);
    }, Ws = () => {
      var Wt, Tt, fe;
      if (Li(), I.maxParts && U.value > I.maxParts) {
        $i(l("The maximum number of parts is") + " " + I.maxParts);
        return;
      }
      if (a("calculating"), T.value) return !1;
      T.value = !0, F.value = !1;
      const lt = [];
      let pt = 0;
      for (const le of H.value)
        lt.push(...le.validate(
          j.value,
          pt,
          X.stockType,
          null,
          !1
        )), pt++;
      if (lt.length) {
        console.warn(lt), $i({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.map( i => i.message ).slice( 0, 5 )
        }), T.value = !1;
        return;
      }
      if (Us(), lt.push(...n6.call({
        inputStock: j,
        stockList: Q,
        createStock: Oa
      }, !1)), lt.length) {
        $i({
          heading: `Stock issue${lt.length > 1 ? "s" : ""}`,
          main: `${lt.length} issue${lt.length > 1 ? "s" : ""} found with stock inputs`,
          list: lt.map((le) => le.message)
        }), T.value = !1;
        return;
      }
      if (lt.push(...us()), lt.length) {
        $i({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.slice( 0, 5 )
        }), T.value = !1;
        return;
      }
      if (S.value = new Bs(
        X,
        (X == null ? void 0 : X.stockType) ?? ((Wt = Q.value) == null ? void 0 : Wt[0].type)
      ), S.value.issues.length) {
        $i({
          heading: `Saw issue${S.value.issues.length > 1 ? "s" : ""}`,
          main: `${S.value.issues.length} issue${S.value.issues.length > 1 ? "s" : ""} found with saw inputs`
          // list: saw.value.issues.slice( 0, 5 )
        }), T.value = !1;
        return;
      }
      if (!((Tt = Q.value) != null && Tt.length)) {
        $i({
          heading: "No stock",
          main: "No stock items were found",
          list: []
        }), T.value = !1;
        return;
      }
      if (!((fe = G.value) != null && fe.length)) {
        $i({
          heading: "No parts",
          main: "No parts in list",
          list: []
        }), T.value = !1;
        return;
      }
      o.debug && console.log(
        "SmartCut - calculating",
        "stock",
        Q.value.map((le) => le.dimensions()),
        "parts",
        G.value.map((le) => le.dimensions())
      ), f.connect();
      const _t = {
        inputs: {
          parts: H.value,
          stock: j.value,
          saw: S.value
        },
        saw: S.value,
        shapeList: G.value,
        stockList: Q.value,
        enableEvo: B.value,
        domain: d
      };
      f.compress(!0).emit("calculate", _t);
    }, $i = (lt = {
      main: null,
      heading: null,
      list: []
    }) => {
      var pt;
      typeof lt == "object" ? (rt.value = l(lt == null ? void 0 : lt.main), J.value = l(lt.heading), lt != null && lt.list && Array.isArray(lt.list) && ((pt = lt.list) != null && pt.length) && lt.list.forEach((_t) => {
        _t && (rt.value += `

${l(_t)}`);
      })) : rt.value = l(lt), et.value = !0;
    }, Li = () => {
      et.value = !1, rt.value = "", J.value = "";
    }, cs = () => {
      const lt = {
        elementID: "#diagram",
        env: u,
        main: !0,
        units: o.units,
        decimalPlaces: I.decimalPlaces,
        saw: X,
        app: !1,
        embed: !0,
        colors: ae,
        options: Rt,
        vueComponent: {
          env: u,
          stockList: Q,
          shapeList: G,
          activeStock: Jt,
          activeShapes: O,
          activeCuts: ct
        }
      };
      dt = new XS(lt), dt.initStock(Jt.value), dt.initShapes(O.value, G.value), dt.initCuts(ct.value), kt.value = !0;
    }, Vn = async (lt = !1) => {
      if (!dt) return !1;
      await dt.updateSize(lt), s6.call({ vis: dt });
    }, hs = (lt, pt) => {
      var Le;
      if (mn(lt, !1), !lt || !pt || !(pt != null && pt[lt]) || !pn(I, ["enable", lt])) return;
      const _t = [lt, "pricing"];
      if (!ac(pt, _t)) {
        a("error", `${_t.join(".")} not found in sent data`);
        return;
      }
      const Wt = pn(pt, _t);
      if (typeof Wt != "object") {
        a("error", `${_t.join(".")} data must be an object`);
        return;
      }
      if (!ko(Wt)) {
        a("error", `if provided, ${_t.join(".")} data must contain some values`);
        return;
      }
      const Tt = Object.keys(Wt), fe = Object.values(Wt);
      if (!Tt.length) {
        a("error", `no ${_t.join(".")} pricing found`);
        return;
      }
      const le = /,/;
      for (const je of Tt)
        if (le.test(je)) {
          a("error", `${_t} keys must not contain commas and should only be separated by a pipe (|)`);
          return;
        }
      if (fe.some((je) => isNaN(je))) {
        a("error", `${_t} values must be a number`);
        return;
      }
      const ve = Br(Wt), Ge = [lt, "labels"];
      let Me = [];
      if (ac(pt, Ge))
        Me = pn(pt, Ge);
      else {
        a("error", `${Ge.join(".")} not found`);
        return;
      }
      if (!Me) {
        a("error", `${Ge.join(".")} data not provided`);
        return;
      }
      if (!Array.isArray(Me)) {
        a("error", `${Ge.join(".")} data must be an array`);
        return;
      }
      if (!(Me != null && Me.length)) {
        a("error", `if provided, ${Ge.join(".")} data must contain values`);
        return;
      }
      if (Me.length !== ve) {
        a("error", `${Ge.join(".")} length (${Me.length}) must match the number of levels in ${_t.join(".")} (${ve})`);
        return;
      }
      switch (lt) {
        case "banding":
          Ut.labels = Me, Ut.pricing = Wt, Ut.options = jr(Wt);
          break;
        case "finish":
          ie.labels = Me, ie.pricing = Wt, ie.options = jr(Wt);
          break;
      }
      if (mn(lt, !0), !!((Le = H.value) != null && Le.length))
        for (const je of H.value)
          nr(je, lt);
    }, $r = (lt, pt) => {
      if (!pt) return;
      lt !== "info" && Object.keys(vt).forEach((Wt) => {
        Wt !== lt && Wt !== "info" && (vt[Wt] = null);
      });
      const _t = H.value.indexOf(pt);
      vt[lt] === _t ? (V.value = null, vt[lt] = null) : (V.value = pt, vt[lt] = _t);
    }, Mo = (lt) => {
      a("log", ["SmartCut - load event received"]), Ro(lt.detail);
    }, Ro = (lt) => {
      a("log", ["SmartCut - loading parts..."]), Qr(() => {
        var _t, Wt, Tt;
        if (!lt || !((Wt = (_t = lt == null ? void 0 : lt.inputs) == null ? void 0 : _t.parts) != null && Wt.length)) return;
        H.value = [];
        let pt = 0;
        for (const fe of lt.inputs.parts) {
          const le = zr(fe);
          le ? (H.value.push(le), (Tt = le.issues) != null && Tt.length && a("log", [`SmartCut - issues found while importing part at index ${pt}`, le.issues])) : a("log", [`SmartCut - error loading part at index ${pt}`, fe]), pt++;
        }
        a("log", [`SmartCut - loaded ${H.value.length} parts`]);
      });
    }, Fa = (lt) => {
      H.value.length = 0, Qr(() => {
        var pt, _t;
        for (const Wt of lt)
          Wt.t = ((_t = (pt = j.value) == null ? void 0 : pt[0]) == null ? void 0 : _t.t) ?? null, H.value.push(zr(Wt));
      });
    };
    fr(() => o.stock, (lt) => {
      if (Us(), Array.isArray(lt) || console.warn("SmartCut - stock must be passed as an array"), !!(lt != null && lt.length)) {
        j.value = [], At.value.length || vn(lt);
        for (const pt of lt) {
          pt.type = X.stockType;
          const _t = Oo(pt);
          j.value.push(_t);
        }
        j.value.length && (H.value.length ? Qr(() => {
          H.value.forEach((pt) => {
            if (pt.material) {
              const _t = At.value.find((Wt) => Wt.name === pt.material);
              _t && (_t.thicknesses.includes(ne(pt.t)) || (pt.t = _t.thicknesses[0]), pt.t == null && (pt.t = _t.thicknesses[0]));
            } else
              pt.t = j.value[0].t;
          });
        }) : Qr(() => ls(1)));
      }
    }, { immediate: !0 }), fr(H, (lt) => {
      a("inputs-changed"), lt.forEach((pt) => {
        var Wt;
        X.stockType === "linear" && (pt.w = (Wt = j.value[0]) == null ? void 0 : Wt.w);
        const _t = At.value.find((Tt) => Tt.name === pt.material);
        _t && (_t.thicknesses.includes(ne(pt.t)) || (pt.t = _t.thicknesses[0]));
      });
    }, { deep: !0 }), fr(M, (lt) => {
      if (!lt) return;
      kt.value && Vn(), z.value || a("error", "SmartCut - no metadata received from server"), dn();
      const pt = {
        jobId: M.value,
        metadata: z.value,
        parts: mt.value.map((_t) => {
          var Wt, Tt;
          return {
            l: _t.l,
            w: _t.w,
            t: _t == null ? void 0 : _t.t,
            material: _t.material,
            orientationLock: _t.orientationLock,
            q: (Tt = (Wt = z.value) == null ? void 0 : Wt.addedPartTally) == null ? void 0 : Tt[_t.parentID],
            name: _t.name,
            banding: _t.banding,
            finish: _t.finish,
            customData: _t.customData
          };
        }),
        stock: zt.value.map((_t) => {
          var Wt, Tt;
          return {
            name: _t == null ? void 0 : _t.name,
            l: _t.l,
            w: _t.w,
            t: _t == null ? void 0 : _t.t,
            material: _t.material,
            q: (Tt = (Wt = z.value) == null ? void 0 : Wt.usedStockTally) == null ? void 0 : Tt[_t.parentID],
            trim: _t == null ? void 0 : _t.trim,
            cost: _t == null ? void 0 : _t.cost,
            analysis: _t == null ? void 0 : _t.analysis,
            type: _t == null ? void 0 : _t.type
          };
        }),
        offcuts: nt.value.map((_t) => ({
          l: _t.l,
          w: _t.w,
          t: (_t == null ? void 0 : _t.t) ?? null,
          q: _t.q
        })),
        inputs: {
          parts: N.value.parts.map((_t) => {
            const Wt = { ..._t };
            return delete Wt.listId, Wt;
          })
        }
      };
      if (z.value.unplacedParts.length) {
        const _t = z.value.unplacedParts.map((Wt) => Wt.id).join();
        $i(l("The following parts did not fit") + ": " + _t);
      }
      a("result", pt);
    }), fr(v, () => {
      kt.value && Vn();
    }), fr(Y, () => {
      kt.value && Qr(() => To());
    });
    const Do = () => {
      f && (f.disconnect(), f = null);
    };
    return No(() => {
      if (E.value) return;
      const lt = new URL(window.location.href), pt = lt.searchParams.toString(), _t = lt.origin + lt.pathname + (pt ? `?${pt}` : "");
      y.value !== _t && (H.value.length = 0, ls(1)), y.value = _t, h.value = I.locale;
      const Wt = {
        socket: null,
        connected: m,
        maintenanceMode: b,
        jobId: M,
        progress: oe,
        thinking: T,
        user: be,
        saw: S,
        stockList: Q,
        shapeList: G,
        cutList: ft,
        offcuts: nt,
        metadata: z,
        usedStock: Dt,
        addedShapes: ot,
        activeStockId: Y
      };
      f = a6.call(Wt, "https://api.cutlistevo.com/"), f.connect(), f.emit("getUserFromDomain"), window.addEventListener("resize", p, { passive: !0 }), window.addEventListener("smartcut/load", Mo), E.value = !0, o.debug && a("log", [
        "SmartCut - ready...",
        "fields:",
        we.value.map((Tt) => Tt.id)
      ]), typeof window < "u" && (window.smartcutCheckout = { init: tr });
    }), Of(() => {
      window.removeEventListener("resize", p), window.removeEventListener("smartcut/load", Mo), Do(), delete window.smartcutCheckout;
    }), t({
      init: tr,
      getAvailablePricingOptions: qr,
      getExtrasPrice: os,
      formatPrice: o.formatPrice,
      findExtrasPrice: o.findExtrasPrice,
      inputShapes: H,
      initExtrasOptions: nr,
      createShapeInput: zr
    }), (lt, pt) => {
      var Wt, Tt, fe, le, ve, Ge, Me;
      const _t = Fl("font-awesome-icon");
      return ee(), he(Qn, null, [
        Pe(u) === "development" && zk ? (ee(), he("div", vk, [
          pt[5] || (pt[5] = me("div", null, "Developer information", -1)),
          Cn(Pe(s), {
            data: [Kt],
            paths: ["allFields"]
          }, null, 8, ["data"]),
          Cn(Pe(s), {
            data: [ge.value],
            paths: ["fieldDefinitions"]
          }, null, 8, ["data"])
        ])) : Ne("", !0),
        $t.value && ((Wt = V.value) != null && Wt.machining) ? (ee(), Wn(Pe(i), {
          key: 1,
          shape: V.value,
          "onUpdate:shape": pt[0] || (pt[0] = (Le) => V.value = Le),
          translate: !0,
          options: Ft,
          env: Pe(u),
          "find-extras-price": n.findExtrasPrice,
          "get-extras-price": os,
          "get-available-pricing-options": qr,
          "format-price": n.formatPrice,
          onClose: ti
        }, null, 8, ["shape", "options", "env", "find-extras-price", "format-price"])) : Ne("", !0),
        q.value ? Ne("", !0) : (ee(), he("div", wk, [
          Cn(Vg, {
            size: 50,
            "show-number": !1
          })
        ])),
        q.value ? (ee(), he("div", {
          key: 3,
          id: "smartcut-checkout",
          class: di({ fullscreen: te.value })
        }, [
          A.value && !n.readonly ? (ee(), he("div", {
            key: 0,
            id: "smartcut-full-screen",
            class: "icon-left",
            onClick: pt[1] || (pt[1] = (Le) => Ni())
          }, [
            Cn(_t, { icon: ["fasr", "expand"] }),
            qu(" " + gn(Pe(l)("full screen")), 1)
          ])) : Ne("", !0),
          (fe = (Tt = be.value) == null ? void 0 : Tt.api) != null && fe.whiteLabel ? Ne("", !0) : (ee(), he("div", {
            key: 1,
            id: "credit",
            style: jn(Dn.value)
          }, [
            me("a", {
              title: "SmartCut | Cut list optimization software",
              style: jn(fn.value),
              target: "_blank",
              href: "https://smartcut.dev/"
            }, gn(Pe(l)("Powered by SmartCut")), 5)
          ], 4)),
          me("div", {
            id: "part-input",
            class: "inputs no-margin-top grid-table",
            style: jn({ "grid-template-columns": Ze.value })
          }, [
            Pe(H).length ? (ee(), he("div", xk, [
              pt[6] || (pt[6] = me("div", { class: "cell id" }, null, -1)),
              (ee(!0), he(Qn, null, Lr(we.value, (Le) => (ee(), he("div", {
                key: Le.id,
                class: di(["cell", { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Le.id) || Le.type === "checkbox" }])
              }, gn(Le.label), 3))), 128)),
              Pe(u) === "development" ? (ee(), he("div", _k, " Info ")) : Ne("", !0),
              Pe(H).length > 1 ? (ee(), he("div", Sk)) : Ne("", !0)
            ])) : Ne("", !0),
            (ee(!0), he(Qn, null, Lr(Pe(H), (Le, je) => (ee(), he("div", {
              key: je,
              class: "row inputs"
            }, [
              me("div", kk, [
                me("div", {
                  class: "id",
                  style: jn({
                    background: ae.partA,
                    color: ae.text
                  })
                }, gn(je + 1), 5)
              ]),
              (ee(!0), he(Qn, null, Lr(we.value, (Zt) => (ee(), he("div", {
                key: Zt.fieldMap,
                class: di(["cell", [`${Zt.id}`, { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Zt.id) || Zt.type === "checkbox" }]])
              }, [
                ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Zt.id) ? Zt.id === "orientationLock" ? (ee(), Wn(B6, {
                  key: 1,
                  id: "orientation-" + je,
                  rectangle: Le,
                  disabled: n.readonly,
                  "stock-grain": En(Le),
                  "button-background": ae.button,
                  "icon-color": ae.buttonText,
                  "orientation-model": I.orientationModel,
                  onUpdateOrientation: (Ii) => Bi(Le, Ii)
                }, null, 8, ["id", "rectangle", "disabled", "stock-grain", "button-background", "icon-color", "orientation-model", "onUpdateOrientation"])) : Zt.id === "banding" ? (ee(), Wn(q6, {
                  key: 2,
                  id: "banding-" + je,
                  "input-shape": Le,
                  disabled: n.readonly,
                  "stock-grain": En(Le),
                  open: vt.banding === je,
                  "orientation-model": I.orientationModel,
                  onClicked: (Ii) => $r("banding", Le)
                }, null, 8, ["id", "input-shape", "disabled", "stock-grain", "open", "orientation-model", "onClicked"])) : Zt.id === "finish" ? (ee(), Wn(ak, {
                  key: 3,
                  id: "finish-" + je,
                  "input-shape": Le,
                  disabled: n.readonly,
                  open: vt.finish === je,
                  onClicked: (Ii) => $r("finish", Le)
                }, null, 8, ["id", "input-shape", "disabled", "open", "onClicked"])) : Zt.fieldMap === "machining" && A.value ? (ee(), Wn(hk, {
                  key: 4,
                  id: "machining-" + je,
                  disabled: n.readonly,
                  "input-shape": Le,
                  onOpen: (Ii) => ji(Le)
                }, null, 8, ["id", "disabled", "input-shape", "onOpen"])) : Zt.fieldMap === "imageUpload" ? (ee(), he("button", {
                  key: 5,
                  id: "image-upload-" + je,
                  type: "button",
                  disabled: n.readonly,
                  class: di({ selected: vt.info === je }),
                  onClick: (Ii) => $r("imageUpload", Le)
                }, [
                  Cn(_t, { icon: ["fass", "image"] })
                ], 10, Ak)) : Ne("", !0) : (ee(), Wn(wl, {
                  key: 0,
                  id: Zt.id + "-" + je,
                  focus: !n.readonly && I.enable.focus && je === Pe(H).length - 1 && Zt.id === "l",
                  warning: Io("warnings", Le, Zt.fieldMap),
                  issue: Io("issues", Le, Zt.fieldMap),
                  type: Zt.type,
                  output: Zt.output,
                  label: Zt.label,
                  units: n.units,
                  readonly: n.readonly,
                  placeholder: Zt == null ? void 0 : Zt.placeholder,
                  options: Zt.id === "t" ? wn(Le) : Zt == null ? void 0 : Zt.options,
                  "true-value": Zt == null ? void 0 : Zt.trueValue,
                  "false-value": Zt == null ? void 0 : Zt.falseValue,
                  default: Zt == null ? void 0 : Zt.default,
                  min: typeof (Zt == null ? void 0 : Zt.min) == "number" ? Zt.min : null,
                  max: typeof (Zt == null ? void 0 : Zt.max) == "number" ? Zt.max : null,
                  custom: Zt == null ? void 0 : Zt.custom,
                  value: ke(Le, Zt == null ? void 0 : Zt.fieldMap),
                  text: {
                    delete: Pe(l)("delete"),
                    select: Pe(l)("select")
                  },
                  onUpdate: (Ii) => {
                    Zt.fieldMap && He(Le, Zt.fieldMap, Ii);
                  }
                }, null, 8, ["id", "focus", "warning", "issue", "type", "output", "label", "units", "readonly", "placeholder", "options", "true-value", "false-value", "default", "min", "max", "custom", "value", "text", "onUpdate"]))
              ], 2))), 128)),
              Pe(u) === "development" ? (ee(), he("div", Nk, [
                me("button", {
                  type: "button",
                  class: di({ selected: vt.info === je }),
                  onClick: (Zt) => $r("info", Le)
                }, " i ", 10, Ck)
              ])) : Ne("", !0),
              Pe(H).length > 1 ? (ee(), he("div", Pk, [
                me("button", {
                  type: "button",
                  disabled: n.readonly,
                  class: "delete",
                  "aria-label": Pe(l)("remove part"),
                  onClick: (Zt) => $s(je)
                }, [
                  Cn(_t, { icon: ["fass", "trash"] })
                ], 8, Lk)
              ])) : Ne("", !0),
              vt.banding === je && Ut.options.length > 0 ? (ee(), Wn(Yg, {
                key: 2,
                env: Pe(u),
                shape: Le,
                "shape-index": je,
                "extra-type": "banding",
                "extra-label": "banding",
                "extra-keys": Ut.keys,
                "all-options": Ut.options,
                pricing: Ut.pricing,
                labels: Ut.labels,
                "user-friendly-field-map": Pe(sf),
                "part-columns": Rn.value,
                "get-price": os,
                "format-price": n.formatPrice,
                "orientation-model": I.orientationModel,
                "get-available-pricing-options": qr,
                onUpdateAll: Dr,
                onSet: wr
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : Ne("", !0),
              vt.finish === je && ie.options.length > 0 ? (ee(), Wn(Yg, {
                key: 3,
                env: Pe(u),
                shape: Le,
                "shape-index": je,
                "extra-type": "finish",
                "extra-label": "finish",
                "extra-keys": ie.keys,
                "all-options": ie.options,
                pricing: ie.pricing,
                labels: ie.labels,
                "user-friendly-field-map": Pe(sf),
                "part-columns": Rn.value,
                "get-price": os,
                "format-price": n.formatPrice,
                "orientation-model": I.orientationModel,
                "get-available-pricing-options": qr,
                onUpdateAll: Dr,
                onSet: wr
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : Ne("", !0),
              vt.info === je ? (ee(), he("div", {
                key: 4,
                id: "shape-info",
                style: jn({ "grid-column-end": "span " + (Rn.value + 1) })
              }, [
                Cn(Pe(s), {
                  data: [Le == null ? void 0 : Le.machining],
                  paths: ["machining"]
                }, null, 8, ["data"])
              ], 4)) : Ne("", !0),
              vt.imageUpload === je ? (ee(), Wn(bk, {
                key: 5,
                prefix: (je + 1).toString(),
                "unique-id": Pe(k),
                "shape-id": Le.listId,
                env: Pe(u),
                style: jn({ "grid-column-end": "span " + (Rn.value + 1) }),
                images: C.value,
                onUpdate: as,
                onRemove: Eo
              }, null, 8, ["prefix", "unique-id", "shape-id", "env", "style", "images"])) : Ne("", !0)
            ]))), 128))
          ], 4),
          me("div", Ik, [
            n.readonly ? Ne("", !0) : (ee(), he("button", {
              key: 0,
              type: "button",
              "aria-label": Pe(l)("add part"),
              style: jn({ background: ae.button, color: ae.buttonText }),
              class: "add c-btn icon-left",
              onClick: pt[2] || (pt[2] = (Le) => ls(1))
            }, [
              Cn(_t, { icon: ["fasr", "plus-large"] }),
              qu(" " + gn(Pe(l)("add part")), 1)
            ], 12, Ek)),
            me("button", {
              id: "calculate-button",
              type: "button",
              class: "c-btn calculate icon-left",
              "aria-label": Pe(l)("calculate"),
              style: jn({
                background: ae.button,
                color: ae.buttonText
              }),
              disabled: !((le = j.value) != null && le.length) || T.value,
              onClick: pt[3] || (pt[3] = (Le) => Ws())
            }, [
              Cn(_t, { icon: ["fass", "calculator"] }),
              qu(gn(Pe(l)("calculate")), 1)
            ], 12, Ok),
            n.readonly ? Ne("", !0) : (ee(), he("button", {
              key: 1,
              type: "button",
              class: "c-btn clear",
              "aria-label": Pe(l)("clear"),
              onClick: pt[4] || (pt[4] = (Le) => Fo())
            }, [
              Cn(_t, { icon: ["fass", "trash"] })
            ], 8, Tk)),
            me("div", Fk, gn(U.value) + gn(I != null && I.maxParts ? "/" + I.maxParts : ""), 1)
          ]),
          P.value && !n.readonly ? (ee(), Wn(Pe(r), {
            key: 2,
            ref: "import",
            units: n.units,
            "custom-fields": jt.value,
            "banding-options": Ut.options,
            "banding-labels": Ut.labels,
            "finish-options": ie.options,
            "finish-labels": ie.labels,
            options: {
              locale: I.locale
            },
            onImport: Fa
          }, null, 8, ["units", "custom-fields", "banding-options", "banding-labels", "finish-options", "finish-labels", "options"])) : Ne("", !0),
          et.value ? (ee(), he("div", Mk, [
            J.value ? (ee(), he("div", Rk, gn(J.value), 1)) : Ne("", !0),
            me("pre", Dk, gn(rt.value), 1)
          ])) : Ne("", !0),
          (I.enable.diagram ? T.value && !oe.value.complete : T.value || oe.value.complete) ? (ee(), he("div", Bk, [
            Cn(Vg, {
              size: 50,
              number: oe.value.shapeCount,
              complete: oe.value.complete,
              "show-number": I.enable.progressNumber
            }, null, 8, ["number", "complete", "show-number"])
          ])) : Ne("", !0),
          Xg(me("div", jk, [
            ((ve = Jt.value) == null ? void 0 : ve.type) !== "roll" ? (ee(), he("div", qk, gn((Ge = Jt.value) != null && Ge.stack ? (Me = Jt.value) == null ? void 0 : Me.stack : 1), 1)) : Ne("", !0)
          ], 512), [
            [Jg, I.enable.diagram && M.value > 0]
          ]),
          I.enable.diagram && kt.value && Dt.value.length > 1 && M.value > 0 && oe.value.complete ? (ee(), Wn(x6, {
            key: 5,
            ref: "stockNavigation",
            "active-stock-id": Y.value,
            "stock-list": Qt.value,
            "stock-count": Q.value.length,
            "viewport-width": v.value,
            onShowStock: Ta
          }, null, 8, ["active-stock-id", "stock-list", "stock-count", "viewport-width"])) : Ne("", !0)
        ], 2)) : Ne("", !0)
      ], 64);
    };
  }
});
function Kg(n) {
  const t = n;
  t.__i18n = t.__i18n || [], t.__i18n.push({
    locale: "",
    resource: {
      en_US: {
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Length" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Width" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Thickness" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "T" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Name" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantity" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Material" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machining" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grain" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add part" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Remove part" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calculate" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Full screen" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Banding" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete banding" } },
        finish: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Finish" } },
        "image upload": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image upload" } },
        "delete finish": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete finish" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Select" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "All" } },
        a: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        b: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "B" } },
        c: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        d: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "D" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Drop CSV file here" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Powered by SmartCut" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part issue" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue with part inputs" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts in list" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No quantity of parts found" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts were added - please double check your list." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The following parts did not fit" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The maximum number of parts is" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No valid parts found" } },
        Hardware: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware" } },
        "Hardware total": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware total" } },
        Panels: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Panels" } },
        pdf: {
          orderSummary: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Order summary" } },
          stockRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Stock requirements" } },
          rollRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Roll requirements" } },
          totals: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Totals" } },
          item: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Item" } },
          totalParts: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total parts" } },
          partArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part area" } },
          images: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Images" } },
          totalStockRequired: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total stock required" } },
          totalBandingLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total banding length" } },
          totalFinishArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total finish area" } },
          totalRollLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total roll length" } },
          partIndex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part index" } },
          fileName: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "File name" } },
          link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Link" } }
        }
      },
      ca: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Llarg" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ample" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gruix" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantitat" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanitzat" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gir" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Afegeix" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantell" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina cantell" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Neteja" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Peça" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les peces següents no encaixaven" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número màxim de peces és" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desenvolupat per SmartCut" } }
      },
      es_ES: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largo" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ancho" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grueso" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nombre" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantidad" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanizado" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Giro" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Añade" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Canto" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina canto" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Borra" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pieza" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Las siguientes piezas no encajaban" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número máximo de piezas es" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No se encontraron piezas válidas" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Carga el archivo CSV aquí" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desarrollado por SmartCut" } }
      },
      fr_FR: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Longueur" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largeur" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Epaisseur" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "ep" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantité" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Qt" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Matèriel" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machinage" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sens de fil" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ajouter pièce" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer pièce" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Optimiser" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Plein écran" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Chants" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer chants" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sélectionner" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Effacer" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tous" } },
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        "Powered by SmartCut": { t: 0, b: { static: "", t: 2, i: [] } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Télécharger CSV" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce erreur" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur avec l'importation de pièces" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce dans la liste" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune quantité trouvé pour certaines pièces" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce n'a été ajoutée - veuillez vérifier votre liste." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les pièces suivantes ne s'adaptent pas" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Le nombre maximum de pièces est" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce valide trouvée" } }
      }
    }
  });
}
typeof Kg == "function" && Kg(Bm);
const $k = /* @__PURE__ */ Ea(Bm, [["__scopeId", "data-v-beff1c31"]]);
function ju(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, r, s) {
      function o(h, u) {
        if (!r[h]) {
          if (!i[h]) {
            var d = typeof ju == "function" && ju;
            if (!u && d) return d(h, !0);
            if (a) return a(h, !0);
            var p = new Error("Cannot find module '" + h + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var f = r[h] = { exports: {} };
          i[h][0].call(f.exports, function(m) {
            var b = i[h][1][m];
            return o(b || m);
          }, f, f.exports, e, i, r, s);
        }
        return r[h].exports;
      }
      for (var a = typeof ju == "function" && ju, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ 1: [function(e, i, r) {
      var s = e("./utils"), o = e("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(l) {
        for (var h, u, d, p, f, m, b, x = [], y = 0, v = l.length, k = v, C = s.getTypeOf(l) !== "string"; y < l.length; ) k = v - y, d = C ? (h = l[y++], u = y < v ? l[y++] : 0, y < v ? l[y++] : 0) : (h = l.charCodeAt(y++), u = y < v ? l.charCodeAt(y++) : 0, y < v ? l.charCodeAt(y++) : 0), p = h >> 2, f = (3 & h) << 4 | u >> 4, m = 1 < k ? (15 & u) << 2 | d >> 6 : 64, b = 2 < k ? 63 & d : 64, x.push(a.charAt(p) + a.charAt(f) + a.charAt(m) + a.charAt(b));
        return x.join("");
      }, r.decode = function(l) {
        var h, u, d, p, f, m, b = 0, x = 0, y = "data:";
        if (l.substr(0, y.length) === y) throw new Error("Invalid base64 input, it looks like a data url.");
        var v, k = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && k--, l.charAt(l.length - 2) === a.charAt(64) && k--, k % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (v = o.uint8array ? new Uint8Array(0 | k) : new Array(0 | k); b < l.length; ) h = a.indexOf(l.charAt(b++)) << 2 | (p = a.indexOf(l.charAt(b++))) >> 4, u = (15 & p) << 4 | (f = a.indexOf(l.charAt(b++))) >> 2, d = (3 & f) << 6 | (m = a.indexOf(l.charAt(b++))), v[x++] = h, f !== 64 && (v[x++] = u), m !== 64 && (v[x++] = d);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, r) {
      var s = e("./external"), o = e("./stream/DataWorker"), a = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function h(u, d, p, f, m) {
        this.compressedSize = u, this.uncompressedSize = d, this.crc32 = p, this.compression = f, this.compressedContent = m;
      }
      h.prototype = { getContentWorker: function() {
        var u = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, h.createWorkerFrom = function(u, d, p) {
        return u.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, i.exports = h;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, r) {
      var s = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, r) {
      var s = e("./utils"), o = function() {
        for (var a, l = [], h = 0; h < 256; h++) {
          a = h;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[h] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? function(h, u, d, p) {
          var f = o, m = p + d;
          h ^= -1;
          for (var b = p; b < m; b++) h = h >>> 8 ^ f[255 & (h ^ u[b])];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : function(h, u, d, p) {
          var f = o, m = p + d;
          h ^= -1;
          for (var b = p; b < m; b++) h = h >>> 8 ^ f[255 & (h ^ u.charCodeAt(b))];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, r) {
      r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, i, r) {
      var s = null;
      s = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), a = e("./utils"), l = e("./stream/GenericWorker"), h = s ? "uint8array" : "array";
      function u(d, p) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = p, this.meta = {};
      }
      r.magic = "\b\0", a.inherits(u, l), u.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(h, d.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(p) {
          d.push({ data: p, meta: d.meta });
        };
      }, r.compressWorker = function(d) {
        return new u("Deflate", d);
      }, r.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, r) {
      function s(f, m) {
        var b, x = "";
        for (b = 0; b < m; b++) x += String.fromCharCode(255 & f), f >>>= 8;
        return x;
      }
      function o(f, m, b, x, y, v) {
        var k, C, E = f.file, q = f.compression, T = v !== h.utf8encode, F = a.transformTo("string", v(E.name)), M = a.transformTo("string", h.utf8encode(E.name)), B = E.comment, P = a.transformTo("string", v(B)), A = a.transformTo("string", h.utf8encode(B)), I = M.length !== E.name.length, S = A.length !== B.length, X = "", H = "", j = "", Q = E.dir, G = E.date, ft = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        m && !b || (ft.crc32 = f.crc32, ft.compressedSize = f.compressedSize, ft.uncompressedSize = f.uncompressedSize);
        var nt = 0;
        m && (nt |= 8), T || !I && !S || (nt |= 2048);
        var N = 0, z = 0;
        Q && (N |= 16), y === "UNIX" ? (z = 798, N |= function(Y, ot) {
          var wt = Y;
          return Y || (wt = ot ? 16893 : 33204), (65535 & wt) << 16;
        }(E.unixPermissions, Q)) : (z = 20, N |= function(Y) {
          return 63 & (Y || 0);
        }(E.dosPermissions)), k = G.getUTCHours(), k <<= 6, k |= G.getUTCMinutes(), k <<= 5, k |= G.getUTCSeconds() / 2, C = G.getUTCFullYear() - 1980, C <<= 4, C |= G.getUTCMonth() + 1, C <<= 5, C |= G.getUTCDate(), I && (H = s(1, 1) + s(u(F), 4) + M, X += "up" + s(H.length, 2) + H), S && (j = s(1, 1) + s(u(P), 4) + A, X += "uc" + s(j.length, 2) + j);
        var V = "";
        return V += `
\0`, V += s(nt, 2), V += q.magic, V += s(k, 2), V += s(C, 2), V += s(ft.crc32, 4), V += s(ft.compressedSize, 4), V += s(ft.uncompressedSize, 4), V += s(F.length, 2), V += s(X.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + V + F + X, dirRecord: d.CENTRAL_FILE_HEADER + s(z, 2) + V + s(P.length, 2) + "\0\0\0\0" + s(N, 4) + s(x, 4) + F + X + P };
      }
      var a = e("../utils"), l = e("../stream/GenericWorker"), h = e("../utf8"), u = e("../crc32"), d = e("../signature");
      function p(f, m, b, x) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = m, this.zipPlatform = b, this.encodeFileName = x, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(p, l), p.prototype.push = function(f) {
        var m = f.meta.percent || 0, b = this.entriesCount, x = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, l.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: b ? (m + 100 * (b - x - 1)) / b : 100 } }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var m = this.streamFiles && !f.file.dir;
        if (m) {
          var b = o(f, m, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: b.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var m = this.streamFiles && !f.file.dir, b = o(f, m, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(b.dirRecord), m) this.push({ data: function(x) {
          return d.DATA_DESCRIPTOR + s(x.crc32, 4) + s(x.compressedSize, 4) + s(x.uncompressedSize, 4);
        }(f), meta: { percent: 100 } });
        else for (this.push({ data: b.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, m = 0; m < this.dirRecords.length; m++) this.push({ data: this.dirRecords[m], meta: { percent: 100 } });
        var b = this.bytesWritten - f, x = function(y, v, k, C, E) {
          var q = a.transformTo("string", E(C));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(y, 2) + s(y, 2) + s(v, 4) + s(k, 4) + s(q.length, 2) + q;
        }(this.dirRecords.length, b, f, this.zipComment, this.encodeFileName);
        this.push({ data: x, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var m = this;
        return f.on("data", function(b) {
          m.processChunk(b);
        }), f.on("end", function() {
          m.closedSource(m.previous.streamInfo), m._sources.length ? m.prepareNextSource() : m.end();
        }), f.on("error", function(b) {
          m.error(b);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(f) {
        var m = this._sources;
        if (!l.prototype.error.call(this, f)) return !1;
        for (var b = 0; b < m.length; b++) try {
          m[b].error(f);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var f = this._sources, m = 0; m < f.length; m++) f[m].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, r) {
      var s = e("../compressions"), o = e("./ZipFileWorker");
      r.generateWorker = function(a, l, h) {
        var u = new o(l.streamFiles, h, l.platform, l.encodeFileName), d = 0;
        try {
          a.forEach(function(p, f) {
            d++;
            var m = function(v, k) {
              var C = v || k, E = s[C];
              if (!E) throw new Error(C + " is not a valid compression method !");
              return E;
            }(f.options.compression, l.compression), b = f.options.compressionOptions || l.compressionOptions || {}, x = f.dir, y = f.date;
            f._compressWorker(m, b).withStreamInfo("file", { name: p, dir: x, date: y, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(u);
          }), u.entriesCount = d;
        } catch (p) {
          u.error(p);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, r) {
      function s() {
        if (!(this instanceof s)) return new s();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this) typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (s.prototype = e("./object")).loadAsync = e("./load"), s.support = e("./support"), s.defaults = e("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = e("./external"), i.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, r) {
      var s = e("./utils"), o = e("./external"), a = e("./utf8"), l = e("./zipEntries"), h = e("./stream/Crc32Probe"), u = e("./nodejsUtils");
      function d(p) {
        return new o.Promise(function(f, m) {
          var b = p.decompressed.getContentWorker().pipe(new h());
          b.on("error", function(x) {
            m(x);
          }).on("end", function() {
            b.streamInfo.crc32 !== p.decompressed.crc32 ? m(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      i.exports = function(p, f) {
        var m = this;
        return f = s.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), u.isNode && u.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", p, !0, f.optimizedBinaryString, f.base64).then(function(b) {
          var x = new l(f);
          return x.load(b), x;
        }).then(function(b) {
          var x = [o.Promise.resolve(b)], y = b.files;
          if (f.checkCRC32) for (var v = 0; v < y.length; v++) x.push(d(y[v]));
          return o.Promise.all(x);
        }).then(function(b) {
          for (var x = b.shift(), y = x.files, v = 0; v < y.length; v++) {
            var k = y[v], C = k.fileNameStr, E = s.resolve(k.fileNameStr);
            m.file(E, k.decompressed, { binary: !0, optimizedBinaryString: !0, date: k.date, dir: k.dir, comment: k.fileCommentStr.length ? k.fileCommentStr : null, unixPermissions: k.unixPermissions, dosPermissions: k.dosPermissions, createFolders: f.createFolders }), k.dir || (m.file(E).unsafeOriginalName = C);
          }
          return x.zipComment.length && (m.comment = x.zipComment), m;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, r) {
      var s = e("../utils"), o = e("../stream/GenericWorker");
      function a(l, h) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(h);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var h = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          h.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          h.isPaused ? this.generatedError = u : h.error(u);
        }).on("end", function() {
          h.isPaused ? h._upstreamEnded = !0 : h.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, r) {
      var s = e("readable-stream").Readable;
      function o(a, l, h) {
        s.call(this, l), this._helper = a;
        var u = this;
        a.on("data", function(d, p) {
          u.push(d) || u._helper.pause(), h && h(p);
        }).on("error", function(d) {
          u.emit("error", d);
        }).on("end", function() {
          u.push(null);
        });
      }
      e("../utils").inherits(o, s), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, r) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, o);
        if (typeof s == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(s, o);
      }, allocBuffer: function(s) {
        if (Buffer.alloc) return Buffer.alloc(s);
        var o = new Buffer(s);
        return o.fill(0), o;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(e, i, r) {
      function s(E, q, T) {
        var F, M = a.getTypeOf(q), B = a.extend(T || {}, u);
        B.date = B.date || /* @__PURE__ */ new Date(), B.compression !== null && (B.compression = B.compression.toUpperCase()), typeof B.unixPermissions == "string" && (B.unixPermissions = parseInt(B.unixPermissions, 8)), B.unixPermissions && 16384 & B.unixPermissions && (B.dir = !0), B.dosPermissions && 16 & B.dosPermissions && (B.dir = !0), B.dir && (E = y(E)), B.createFolders && (F = x(E)) && v.call(this, F, !0);
        var P = M === "string" && B.binary === !1 && B.base64 === !1;
        T && T.binary !== void 0 || (B.binary = !P), (q instanceof d && q.uncompressedSize === 0 || B.dir || !q || q.length === 0) && (B.base64 = !1, B.binary = !0, q = "", B.compression = "STORE", M = "string");
        var A = null;
        A = q instanceof d || q instanceof l ? q : m.isNode && m.isStream(q) ? new b(E, q) : a.prepareContent(E, q, B.binary, B.optimizedBinaryString, B.base64);
        var I = new p(E, A, B);
        this.files[E] = I;
      }
      var o = e("./utf8"), a = e("./utils"), l = e("./stream/GenericWorker"), h = e("./stream/StreamHelper"), u = e("./defaults"), d = e("./compressedObject"), p = e("./zipObject"), f = e("./generate"), m = e("./nodejsUtils"), b = e("./nodejs/NodejsStreamInputAdapter"), x = function(E) {
        E.slice(-1) === "/" && (E = E.substring(0, E.length - 1));
        var q = E.lastIndexOf("/");
        return 0 < q ? E.substring(0, q) : "";
      }, y = function(E) {
        return E.slice(-1) !== "/" && (E += "/"), E;
      }, v = function(E, q) {
        return q = q !== void 0 ? q : u.createFolders, E = y(E), this.files[E] || s.call(this, E, null, { dir: !0, createFolders: q }), this.files[E];
      };
      function k(E) {
        return Object.prototype.toString.call(E) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(E) {
        var q, T, F;
        for (q in this.files) F = this.files[q], (T = q.slice(this.root.length, q.length)) && q.slice(0, this.root.length) === this.root && E(T, F);
      }, filter: function(E) {
        var q = [];
        return this.forEach(function(T, F) {
          E(T, F) && q.push(F);
        }), q;
      }, file: function(E, q, T) {
        if (arguments.length !== 1) return E = this.root + E, s.call(this, E, q, T), this;
        if (k(E)) {
          var F = E;
          return this.filter(function(B, P) {
            return !P.dir && F.test(B);
          });
        }
        var M = this.files[this.root + E];
        return M && !M.dir ? M : null;
      }, folder: function(E) {
        if (!E) return this;
        if (k(E)) return this.filter(function(M, B) {
          return B.dir && E.test(M);
        });
        var q = this.root + E, T = v.call(this, q), F = this.clone();
        return F.root = T.name, F;
      }, remove: function(E) {
        E = this.root + E;
        var q = this.files[E];
        if (q || (E.slice(-1) !== "/" && (E += "/"), q = this.files[E]), q && !q.dir) delete this.files[E];
        else for (var T = this.filter(function(M, B) {
          return B.name.slice(0, E.length) === E;
        }), F = 0; F < T.length; F++) delete this.files[T[F].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(E) {
        var q, T = {};
        try {
          if ((T = a.extend(E || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = T.type.toLowerCase(), T.compression = T.compression.toUpperCase(), T.type === "binarystring" && (T.type = "string"), !T.type) throw new Error("No output type specified.");
          a.checkSupport(T.type), T.platform !== "darwin" && T.platform !== "freebsd" && T.platform !== "linux" && T.platform !== "sunos" || (T.platform = "UNIX"), T.platform === "win32" && (T.platform = "DOS");
          var F = T.comment || this.comment || "";
          q = f.generateWorker(this, T, F);
        } catch (M) {
          (q = new l("error")).error(M);
        }
        return new h(q, T.type || "string", T.mimeType);
      }, generateAsync: function(E, q) {
        return this.generateInternalStream(E).accumulate(q);
      }, generateNodeStream: function(E, q) {
        return (E = E || {}).type || (E.type = "nodebuffer"), this.generateInternalStream(E).toNodejsStream(q);
      } };
      i.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, r) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
        for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l];
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === l && this.data[p + 1] === h && this.data[p + 2] === u && this.data[p + 3] === d) return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.readData(4);
        return l === p[0] && h === p[1] && u === p[2] && d === p[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, r) {
      var s = e("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, h = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--) h = (h << 8) + this.byteAt(l);
        return this.index += a, h;
      }, readString: function(a) {
        return s.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, r) {
      var s = e("./Uint8ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, r) {
      var s = e("./ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, r) {
      var s = e("../utils"), o = e("../support"), a = e("./ArrayReader"), l = e("./StringReader"), h = e("./NodeBufferReader"), u = e("./Uint8ArrayReader");
      i.exports = function(d) {
        var p = s.getTypeOf(d);
        return s.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new h(d) : o.uint8array ? new u(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../crc32");
      function a() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(a, s), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var h = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = h + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var h = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          h.dataIsReady = !0, h.data = u, h.max = u && u.length || 0, h.type = s.getTypeOf(u), h.isPaused || h._tickAndRepeat();
        }, function(u) {
          h.error(u);
        });
      }
      s.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, h = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, h);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, h);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, h);
        }
        return this.index = h, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, r) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o]) for (var l = 0; l < this._listeners[o].length; l++) this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = s;
    }, {}], 29: [function(e, i, r) {
      var s = e("../utils"), o = e("./ConvertWorker"), a = e("./GenericWorker"), l = e("../base64"), h = e("../support"), u = e("../external"), d = null;
      if (h.nodestream) try {
        d = e("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(m, b) {
        return new u.Promise(function(x, y) {
          var v = [], k = m._internalType, C = m._outputType, E = m._mimeType;
          m.on("data", function(q, T) {
            v.push(q), b && b(T);
          }).on("error", function(q) {
            v = [], y(q);
          }).on("end", function() {
            try {
              var q = function(T, F, M) {
                switch (T) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", F), M);
                  case "base64":
                    return l.encode(F);
                  default:
                    return s.transformTo(T, F);
                }
              }(C, function(T, F) {
                var M, B = 0, P = null, A = 0;
                for (M = 0; M < F.length; M++) A += F[M].length;
                switch (T) {
                  case "string":
                    return F.join("");
                  case "array":
                    return Array.prototype.concat.apply([], F);
                  case "uint8array":
                    for (P = new Uint8Array(A), M = 0; M < F.length; M++) P.set(F[M], B), B += F[M].length;
                    return P;
                  case "nodebuffer":
                    return Buffer.concat(F);
                  default:
                    throw new Error("concat : unsupported type '" + T + "'");
                }
              }(k, v), E);
              x(q);
            } catch (T) {
              y(T);
            }
            v = [];
          }).resume();
        });
      }
      function f(m, b, x) {
        var y = b;
        switch (b) {
          case "blob":
          case "arraybuffer":
            y = "uint8array";
            break;
          case "base64":
            y = "string";
        }
        try {
          this._internalType = y, this._outputType = b, this._mimeType = x, s.checkSupport(y), this._worker = m.pipe(new o(y)), m.lock();
        } catch (v) {
          this._worker = new a("error"), this._worker.error(v);
        }
      }
      f.prototype = { accumulate: function(m) {
        return p(this, m);
      }, on: function(m, b) {
        var x = this;
        return m === "data" ? this._worker.on(m, function(y) {
          b.call(x, y.data, y.meta);
        }) : this._worker.on(m, function() {
          s.delay(b, arguments, x);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(m) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, m);
      } }, i.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, r) {
      if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") r.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          r.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(s), r.blob = o.getBlob("application/zip").size === 0;
          } catch {
            r.blob = !1;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch {
        r.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, r) {
      for (var s = e("./utils"), o = e("./support"), a = e("./nodejsUtils"), l = e("./stream/GenericWorker"), h = new Array(256), u = 0; u < 256; u++) h[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      h[254] = h[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      r.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : function(m) {
          var b, x, y, v, k, C = m.length, E = 0;
          for (v = 0; v < C; v++) (64512 & (x = m.charCodeAt(v))) == 55296 && v + 1 < C && (64512 & (y = m.charCodeAt(v + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (y - 56320), v++), E += x < 128 ? 1 : x < 2048 ? 2 : x < 65536 ? 3 : 4;
          for (b = o.uint8array ? new Uint8Array(E) : new Array(E), v = k = 0; k < E; v++) (64512 & (x = m.charCodeAt(v))) == 55296 && v + 1 < C && (64512 & (y = m.charCodeAt(v + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (y - 56320), v++), x < 128 ? b[k++] = x : (x < 2048 ? b[k++] = 192 | x >>> 6 : (x < 65536 ? b[k++] = 224 | x >>> 12 : (b[k++] = 240 | x >>> 18, b[k++] = 128 | x >>> 12 & 63), b[k++] = 128 | x >>> 6 & 63), b[k++] = 128 | 63 & x);
          return b;
        }(f);
      }, r.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : function(m) {
          var b, x, y, v, k = m.length, C = new Array(2 * k);
          for (b = x = 0; b < k; ) if ((y = m[b++]) < 128) C[x++] = y;
          else if (4 < (v = h[y])) C[x++] = 65533, b += v - 1;
          else {
            for (y &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && b < k; ) y = y << 6 | 63 & m[b++], v--;
            1 < v ? C[x++] = 65533 : y < 65536 ? C[x++] = y : (y -= 65536, C[x++] = 55296 | y >> 10 & 1023, C[x++] = 56320 | 1023 & y);
          }
          return C.length !== x && (C.subarray ? C = C.subarray(0, x) : C.length = x), s.applyFromCharCode(C);
        }(f = s.transformTo(o.uint8array ? "uint8array" : "array", f));
      }, s.inherits(d, l), d.prototype.processChunk = function(f) {
        var m = s.transformTo(o.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var b = m;
            (m = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), m.set(b, this.leftOver.length);
          } else m = this.leftOver.concat(m);
          this.leftOver = null;
        }
        var x = function(v, k) {
          var C;
          for ((k = k || v.length) > v.length && (k = v.length), C = k - 1; 0 <= C && (192 & v[C]) == 128; ) C--;
          return C < 0 || C === 0 ? k : C + h[v[C]] > k ? C : k;
        }(m), y = m;
        x !== m.length && (o.uint8array ? (y = m.subarray(0, x), this.leftOver = m.subarray(x, m.length)) : (y = m.slice(0, x), this.leftOver = m.slice(x, m.length))), this.push({ data: r.utf8decode(y), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, r.Utf8DecodeWorker = d, s.inherits(p, l), p.prototype.processChunk = function(f) {
        this.push({ data: r.utf8encode(f.data), meta: f.meta });
      }, r.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, r) {
      var s = e("./support"), o = e("./base64"), a = e("./nodejsUtils"), l = e("./external");
      function h(b) {
        return b;
      }
      function u(b, x) {
        for (var y = 0; y < b.length; ++y) x[y] = 255 & b.charCodeAt(y);
        return x;
      }
      e("setimmediate"), r.newBlob = function(b, x) {
        r.checkSupport("blob");
        try {
          return new Blob([b], { type: x });
        } catch {
          try {
            var y = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return y.append(b), y.getBlob(x);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(b, x, y) {
        var v = [], k = 0, C = b.length;
        if (C <= y) return String.fromCharCode.apply(null, b);
        for (; k < C; ) x === "array" || x === "nodebuffer" ? v.push(String.fromCharCode.apply(null, b.slice(k, Math.min(k + y, C)))) : v.push(String.fromCharCode.apply(null, b.subarray(k, Math.min(k + y, C)))), k += y;
        return v.join("");
      }, stringifyByChar: function(b) {
        for (var x = "", y = 0; y < b.length; y++) x += String.fromCharCode(b[y]);
        return x;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(b) {
        var x = 65536, y = r.getTypeOf(b), v = !0;
        if (y === "uint8array" ? v = d.applyCanBeUsed.uint8array : y === "nodebuffer" && (v = d.applyCanBeUsed.nodebuffer), v) for (; 1 < x; ) try {
          return d.stringifyByChunk(b, y, x);
        } catch {
          x = Math.floor(x / 2);
        }
        return d.stringifyByChar(b);
      }
      function f(b, x) {
        for (var y = 0; y < b.length; y++) x[y] = b[y];
        return x;
      }
      r.applyFromCharCode = p;
      var m = {};
      m.string = { string: h, array: function(b) {
        return u(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return m.string.uint8array(b).buffer;
      }, uint8array: function(b) {
        return u(b, new Uint8Array(b.length));
      }, nodebuffer: function(b) {
        return u(b, a.allocBuffer(b.length));
      } }, m.array = { string: p, array: h, arraybuffer: function(b) {
        return new Uint8Array(b).buffer;
      }, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return a.newBufferFrom(b);
      } }, m.arraybuffer = { string: function(b) {
        return p(new Uint8Array(b));
      }, array: function(b) {
        return f(new Uint8Array(b), new Array(b.byteLength));
      }, arraybuffer: h, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return a.newBufferFrom(new Uint8Array(b));
      } }, m.uint8array = { string: p, array: function(b) {
        return f(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return b.buffer;
      }, uint8array: h, nodebuffer: function(b) {
        return a.newBufferFrom(b);
      } }, m.nodebuffer = { string: p, array: function(b) {
        return f(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return m.nodebuffer.uint8array(b).buffer;
      }, uint8array: function(b) {
        return f(b, new Uint8Array(b.length));
      }, nodebuffer: h }, r.transformTo = function(b, x) {
        if (x = x || "", !b) return x;
        r.checkSupport(b);
        var y = r.getTypeOf(x);
        return m[y][b](x);
      }, r.resolve = function(b) {
        for (var x = b.split("/"), y = [], v = 0; v < x.length; v++) {
          var k = x[v];
          k === "." || k === "" && v !== 0 && v !== x.length - 1 || (k === ".." ? y.pop() : y.push(k));
        }
        return y.join("/");
      }, r.getTypeOf = function(b) {
        return typeof b == "string" ? "string" : Object.prototype.toString.call(b) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(b) ? "nodebuffer" : s.uint8array && b instanceof Uint8Array ? "uint8array" : s.arraybuffer && b instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, r.checkSupport = function(b) {
        if (!s[b.toLowerCase()]) throw new Error(b + " is not supported by this platform");
      }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(b) {
        var x, y, v = "";
        for (y = 0; y < (b || "").length; y++) v += "\\x" + ((x = b.charCodeAt(y)) < 16 ? "0" : "") + x.toString(16).toUpperCase();
        return v;
      }, r.delay = function(b, x, y) {
        setImmediate(function() {
          b.apply(y || null, x || []);
        });
      }, r.inherits = function(b, x) {
        function y() {
        }
        y.prototype = x.prototype, b.prototype = new y();
      }, r.extend = function() {
        var b, x, y = {};
        for (b = 0; b < arguments.length; b++) for (x in arguments[b]) Object.prototype.hasOwnProperty.call(arguments[b], x) && y[x] === void 0 && (y[x] = arguments[b][x]);
        return y;
      }, r.prepareContent = function(b, x, y, v, k) {
        return l.Promise.resolve(x).then(function(C) {
          return s.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(E, q) {
            var T = new FileReader();
            T.onload = function(F) {
              E(F.target.result);
            }, T.onerror = function(F) {
              q(F.target.error);
            }, T.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var E = r.getTypeOf(C);
          return E ? (E === "arraybuffer" ? C = r.transformTo("uint8array", C) : E === "string" && (k ? C = o.decode(C) : y && v !== !0 && (C = function(q) {
            return u(q, s.uint8array ? new Uint8Array(q.length) : new Array(q.length));
          }(C))), C) : l.Promise.reject(new Error("Can't read the data of '" + b + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./signature"), l = e("./zipEntry"), h = e("./support");
      function u(d) {
        this.files = [], this.loadOptions = d;
      }
      u.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(d) + ")");
        }
      }, isSignature: function(d, p) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var m = this.reader.readString(4) === p;
        return this.reader.setIndex(f), m;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), p = h.uint8array ? "uint8array" : "array", f = o.transformTo(p, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, p, f, m = this.zip64EndOfCentralSize - 44; 0 < m; ) d = this.reader.readInt(2), p = this.reader.readInt(4), f = this.reader.readData(p), this.zip64ExtensibleData[d] = { id: d, length: p, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, p;
        for (d = 0; d < this.files.length; d++) p = this.files[d], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (d < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var p = d;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var m = p - f;
        if (0 < m) this.isSignature(p, a.CENTRAL_FILE_HEADER) || (this.reader.zero = m);
        else if (m < 0) throw new Error("Corrupted zip: missing " + Math.abs(m) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = s(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./compressedObject"), l = e("./crc32"), h = e("./utf8"), u = e("./compressions"), d = e("./support");
      function p(f, m) {
        this.options = f, this.loadOptions = m;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var m, b;
        if (f.skip(22), this.fileNameLength = f.readInt(2), b = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((m = function(x) {
          for (var y in u) if (Object.prototype.hasOwnProperty.call(u, y) && u[y].magic === x) return u[y];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, m, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var m = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        f.skip(m), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = s(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var m, b, x, y = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < y; ) m = f.readInt(2), b = f.readInt(2), x = f.readData(b), this.extraFields[m] = { id: m, length: b, value: x };
        f.setIndex(y);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = h.utf8decode(this.fileName), this.fileCommentStr = h.utf8decode(this.fileComment);
        else {
          var m = this.findExtraFieldUnicodePath();
          if (m !== null) this.fileNameStr = m;
          else {
            var b = o.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(b);
          }
          var x = this.findExtraFieldUnicodeComment();
          if (x !== null) this.fileCommentStr = x;
          else {
            var y = o.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(y);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var m = s(f.value);
          return m.readInt(1) !== 1 || l(this.fileName) !== m.readInt(4) ? null : h.utf8decode(m.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var m = s(f.value);
          return m.readInt(1) !== 1 || l(this.fileComment) !== m.readInt(4) ? null : h.utf8decode(m.readData(f.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, r) {
      function s(m, b, x) {
        this.name = m, this.dir = x.dir, this.date = x.date, this.comment = x.comment, this.unixPermissions = x.unixPermissions, this.dosPermissions = x.dosPermissions, this._data = b, this._dataBinary = x.binary, this.options = { compression: x.compression, compressionOptions: x.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), a = e("./stream/DataWorker"), l = e("./utf8"), h = e("./compressedObject"), u = e("./stream/GenericWorker");
      s.prototype = { internalStream: function(m) {
        var b = null, x = "string";
        try {
          if (!m) throw new Error("No output type specified.");
          var y = (x = m.toLowerCase()) === "string" || x === "text";
          x !== "binarystring" && x !== "text" || (x = "string"), b = this._decompressWorker();
          var v = !this._dataBinary;
          v && !y && (b = b.pipe(new l.Utf8EncodeWorker())), !v && y && (b = b.pipe(new l.Utf8DecodeWorker()));
        } catch (k) {
          (b = new u("error")).error(k);
        }
        return new o(b, x, "");
      }, async: function(m, b) {
        return this.internalStream(m).accumulate(b);
      }, nodeStream: function(m, b) {
        return this.internalStream(m || "nodebuffer").toNodejsStream(b);
      }, _compressWorker: function(m, b) {
        if (this._data instanceof h && this._data.compression.magic === m.magic) return this._data.getCompressedWorker();
        var x = this._decompressWorker();
        return this._dataBinary || (x = x.pipe(new l.Utf8EncodeWorker())), h.createWorkerFrom(x, m, b);
      }, _decompressWorker: function() {
        return this._data instanceof h ? this._data.getContentWorker() : this._data instanceof u ? this._data : new a(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++) s.prototype[d[f]] = p;
      i.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, r) {
      (function(s) {
        var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
        if (l) {
          var h = 0, u = new l(m), d = s.document.createTextNode("");
          u.observe(d, { characterData: !0 }), o = function() {
            d.data = h = ++h % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0) o = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
          var b = s.document.createElement("script");
          b.onreadystatechange = function() {
            m(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
          }, s.document.documentElement.appendChild(b);
        } : function() {
          setTimeout(m, 0);
        };
        else {
          var p = new s.MessageChannel();
          p.port1.onmessage = m, o = function() {
            p.port2.postMessage(0);
          };
        }
        var f = [];
        function m() {
          var b, x;
          a = !0;
          for (var y = f.length; y; ) {
            for (x = f, f = [], b = -1; ++b < y; ) x[b]();
            y = f.length;
          }
          a = !1;
        }
        i.exports = function(b) {
          f.push(b) !== 1 || a || o();
        };
      }).call(this, typeof ao < "u" ? ao : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, r) {
      var s = e("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], h = ["FULFILLED"], u = ["PENDING"];
      function d(y) {
        if (typeof y != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, y !== o && b(this, y);
      }
      function p(y, v, k) {
        this.promise = y, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof k == "function" && (this.onRejected = k, this.callRejected = this.otherCallRejected);
      }
      function f(y, v, k) {
        s(function() {
          var C;
          try {
            C = v(k);
          } catch (E) {
            return a.reject(y, E);
          }
          C === y ? a.reject(y, new TypeError("Cannot resolve promise with itself")) : a.resolve(y, C);
        });
      }
      function m(y) {
        var v = y && y.then;
        if (y && (typeof y == "object" || typeof y == "function") && typeof v == "function") return function() {
          v.apply(y, arguments);
        };
      }
      function b(y, v) {
        var k = !1;
        function C(T) {
          k || (k = !0, a.reject(y, T));
        }
        function E(T) {
          k || (k = !0, a.resolve(y, T));
        }
        var q = x(function() {
          v(E, C);
        });
        q.status === "error" && C(q.value);
      }
      function x(y, v) {
        var k = {};
        try {
          k.value = y(v), k.status = "success";
        } catch (C) {
          k.status = "error", k.value = C;
        }
        return k;
      }
      (i.exports = d).prototype.finally = function(y) {
        if (typeof y != "function") return this;
        var v = this.constructor;
        return this.then(function(k) {
          return v.resolve(y()).then(function() {
            return k;
          });
        }, function(k) {
          return v.resolve(y()).then(function() {
            throw k;
          });
        });
      }, d.prototype.catch = function(y) {
        return this.then(null, y);
      }, d.prototype.then = function(y, v) {
        if (typeof y != "function" && this.state === h || typeof v != "function" && this.state === l) return this;
        var k = new this.constructor(o);
        return this.state !== u ? f(k, this.state === h ? y : v, this.outcome) : this.queue.push(new p(k, y, v)), k;
      }, p.prototype.callFulfilled = function(y) {
        a.resolve(this.promise, y);
      }, p.prototype.otherCallFulfilled = function(y) {
        f(this.promise, this.onFulfilled, y);
      }, p.prototype.callRejected = function(y) {
        a.reject(this.promise, y);
      }, p.prototype.otherCallRejected = function(y) {
        f(this.promise, this.onRejected, y);
      }, a.resolve = function(y, v) {
        var k = x(m, v);
        if (k.status === "error") return a.reject(y, k.value);
        var C = k.value;
        if (C) b(y, C);
        else {
          y.state = h, y.outcome = v;
          for (var E = -1, q = y.queue.length; ++E < q; ) y.queue[E].callFulfilled(v);
        }
        return y;
      }, a.reject = function(y, v) {
        y.state = l, y.outcome = v;
        for (var k = -1, C = y.queue.length; ++k < C; ) y.queue[k].callRejected(v);
        return y;
      }, d.resolve = function(y) {
        return y instanceof this ? y : a.resolve(new this(o), y);
      }, d.reject = function(y) {
        var v = new this(o);
        return a.reject(v, y);
      }, d.all = function(y) {
        var v = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var k = y.length, C = !1;
        if (!k) return this.resolve([]);
        for (var E = new Array(k), q = 0, T = -1, F = new this(o); ++T < k; ) M(y[T], T);
        return F;
        function M(B, P) {
          v.resolve(B).then(function(A) {
            E[P] = A, ++q !== k || C || (C = !0, a.resolve(F, E));
          }, function(A) {
            C || (C = !0, a.reject(F, A));
          });
        }
      }, d.race = function(y) {
        var v = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var k = y.length, C = !1;
        if (!k) return this.resolve([]);
        for (var E = -1, q = new this(o); ++E < k; ) T = y[E], v.resolve(T).then(function(F) {
          C || (C = !0, a.resolve(q, F));
        }, function(F) {
          C || (C = !0, a.reject(q, F));
        });
        var T;
        return q;
      };
    }, { immediate: 36 }], 38: [function(e, i, r) {
      var s = {};
      (0, e("./lib/utils/common").assign)(s, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, r) {
      var s = e("./zlib/deflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/messages"), h = e("./zlib/zstream"), u = Object.prototype.toString, d = 0, p = -1, f = 0, m = 8;
      function b(y) {
        if (!(this instanceof b)) return new b(y);
        this.options = o.assign({ level: p, method: m, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, y || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var k = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (k !== d) throw new Error(l[k]);
        if (v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var C;
          if (C = typeof v.dictionary == "string" ? a.string2buf(v.dictionary) : u.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (k = s.deflateSetDictionary(this.strm, C)) !== d) throw new Error(l[k]);
          this._dict_set = !0;
        }
      }
      function x(y, v) {
        var k = new b(v);
        if (k.push(y, !0), k.err) throw k.msg || l[k.err];
        return k.result;
      }
      b.prototype.push = function(y, v) {
        var k, C, E = this.strm, q = this.options.chunkSize;
        if (this.ended) return !1;
        C = v === ~~v ? v : v === !0 ? 4 : 0, typeof y == "string" ? E.input = a.string2buf(y) : u.call(y) === "[object ArrayBuffer]" ? E.input = new Uint8Array(y) : E.input = y, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new o.Buf8(q), E.next_out = 0, E.avail_out = q), (k = s.deflate(E, C)) !== 1 && k !== d) return this.onEnd(k), !(this.ended = !0);
          E.avail_out !== 0 && (E.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(E.output, E.next_out))) : this.onData(o.shrinkBuf(E.output, E.next_out)));
        } while ((0 < E.avail_in || E.avail_out === 0) && k !== 1);
        return C === 4 ? (k = s.deflateEnd(this.strm), this.onEnd(k), this.ended = !0, k === d) : C !== 2 || (this.onEnd(d), !(E.avail_out = 0));
      }, b.prototype.onData = function(y) {
        this.chunks.push(y);
      }, b.prototype.onEnd = function(y) {
        y === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, r.Deflate = b, r.deflate = x, r.deflateRaw = function(y, v) {
        return (v = v || {}).raw = !0, x(y, v);
      }, r.gzip = function(y, v) {
        return (v = v || {}).gzip = !0, x(y, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, r) {
      var s = e("./zlib/inflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/constants"), h = e("./zlib/messages"), u = e("./zlib/zstream"), d = e("./zlib/gzheader"), p = Object.prototype.toString;
      function f(b) {
        if (!(this instanceof f)) return new f(b);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
        var x = this.options;
        x.raw && 0 <= x.windowBits && x.windowBits < 16 && (x.windowBits = -x.windowBits, x.windowBits === 0 && (x.windowBits = -15)), !(0 <= x.windowBits && x.windowBits < 16) || b && b.windowBits || (x.windowBits += 32), 15 < x.windowBits && x.windowBits < 48 && !(15 & x.windowBits) && (x.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var y = s.inflateInit2(this.strm, x.windowBits);
        if (y !== l.Z_OK) throw new Error(h[y]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      function m(b, x) {
        var y = new f(x);
        if (y.push(b, !0), y.err) throw y.msg || h[y.err];
        return y.result;
      }
      f.prototype.push = function(b, x) {
        var y, v, k, C, E, q, T = this.strm, F = this.options.chunkSize, M = this.options.dictionary, B = !1;
        if (this.ended) return !1;
        v = x === ~~x ? x : x === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof b == "string" ? T.input = a.binstring2buf(b) : p.call(b) === "[object ArrayBuffer]" ? T.input = new Uint8Array(b) : T.input = b, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new o.Buf8(F), T.next_out = 0, T.avail_out = F), (y = s.inflate(T, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && M && (q = typeof M == "string" ? a.string2buf(M) : p.call(M) === "[object ArrayBuffer]" ? new Uint8Array(M) : M, y = s.inflateSetDictionary(this.strm, q)), y === l.Z_BUF_ERROR && B === !0 && (y = l.Z_OK, B = !1), y !== l.Z_STREAM_END && y !== l.Z_OK) return this.onEnd(y), !(this.ended = !0);
          T.next_out && (T.avail_out !== 0 && y !== l.Z_STREAM_END && (T.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (k = a.utf8border(T.output, T.next_out), C = T.next_out - k, E = a.buf2string(T.output, k), T.next_out = C, T.avail_out = F - C, C && o.arraySet(T.output, T.output, k, C, 0), this.onData(E)) : this.onData(o.shrinkBuf(T.output, T.next_out)))), T.avail_in === 0 && T.avail_out === 0 && (B = !0);
        } while ((0 < T.avail_in || T.avail_out === 0) && y !== l.Z_STREAM_END);
        return y === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (y = s.inflateEnd(this.strm), this.onEnd(y), this.ended = !0, y === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(T.avail_out = 0));
      }, f.prototype.onData = function(b) {
        this.chunks.push(b);
      }, f.prototype.onEnd = function(b) {
        b === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, r.Inflate = f, r.inflate = m, r.inflateRaw = function(b, x) {
        return (x = x || {}).raw = !0, m(b, x);
      }, r.ungzip = m;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      r.assign = function(l) {
        for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
          var u = h.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var d in u) u.hasOwnProperty(d) && (l[d] = u[d]);
          }
        }
        return l;
      }, r.shrinkBuf = function(l, h) {
        return l.length === h ? l : l.subarray ? l.subarray(0, h) : (l.length = h, l);
      };
      var o = { arraySet: function(l, h, u, d, p) {
        if (h.subarray && l.subarray) l.set(h.subarray(u, u + d), p);
        else for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        var h, u, d, p, f, m;
        for (h = d = 0, u = l.length; h < u; h++) d += l[h].length;
        for (m = new Uint8Array(d), h = p = 0, u = l.length; h < u; h++) f = l[h], m.set(f, p), p += f.length;
        return m;
      } }, a = { arraySet: function(l, h, u, d, p) {
        for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      r.setTyped = function(l) {
        l ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, a));
      }, r.setTyped(s);
    }, {}], 42: [function(e, i, r) {
      var s = e("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), h = 0; h < 256; h++) l[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      function u(d, p) {
        if (p < 65537 && (d.subarray && a || !d.subarray && o)) return String.fromCharCode.apply(null, s.shrinkBuf(d, p));
        for (var f = "", m = 0; m < p; m++) f += String.fromCharCode(d[m]);
        return f;
      }
      l[254] = l[254] = 1, r.string2buf = function(d) {
        var p, f, m, b, x, y = d.length, v = 0;
        for (b = 0; b < y; b++) (64512 & (f = d.charCodeAt(b))) == 55296 && b + 1 < y && (64512 & (m = d.charCodeAt(b + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (m - 56320), b++), v += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (p = new s.Buf8(v), b = x = 0; x < v; b++) (64512 & (f = d.charCodeAt(b))) == 55296 && b + 1 < y && (64512 & (m = d.charCodeAt(b + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (m - 56320), b++), f < 128 ? p[x++] = f : (f < 2048 ? p[x++] = 192 | f >>> 6 : (f < 65536 ? p[x++] = 224 | f >>> 12 : (p[x++] = 240 | f >>> 18, p[x++] = 128 | f >>> 12 & 63), p[x++] = 128 | f >>> 6 & 63), p[x++] = 128 | 63 & f);
        return p;
      }, r.buf2binstring = function(d) {
        return u(d, d.length);
      }, r.binstring2buf = function(d) {
        for (var p = new s.Buf8(d.length), f = 0, m = p.length; f < m; f++) p[f] = d.charCodeAt(f);
        return p;
      }, r.buf2string = function(d, p) {
        var f, m, b, x, y = p || d.length, v = new Array(2 * y);
        for (f = m = 0; f < y; ) if ((b = d[f++]) < 128) v[m++] = b;
        else if (4 < (x = l[b])) v[m++] = 65533, f += x - 1;
        else {
          for (b &= x === 2 ? 31 : x === 3 ? 15 : 7; 1 < x && f < y; ) b = b << 6 | 63 & d[f++], x--;
          1 < x ? v[m++] = 65533 : b < 65536 ? v[m++] = b : (b -= 65536, v[m++] = 55296 | b >> 10 & 1023, v[m++] = 56320 | 1023 & b);
        }
        return u(v, m);
      }, r.utf8border = function(d, p) {
        var f;
        for ((p = p || d.length) > d.length && (p = d.length), f = p - 1; 0 <= f && (192 & d[f]) == 128; ) f--;
        return f < 0 || f === 0 ? p : f + l[d[f]] > p ? f : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, r) {
      i.exports = function(s, o, a, l) {
        for (var h = 65535 & s | 0, u = s >>> 16 & 65535 | 0, d = 0; a !== 0; ) {
          for (a -= d = 2e3 < a ? 2e3 : a; u = u + (h = h + o[l++] | 0) | 0, --d; ) ;
          h %= 65521, u %= 65521;
        }
        return h | u << 16 | 0;
      };
    }, {}], 44: [function(e, i, r) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, r) {
      var s = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var h = 0; h < 8; h++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, h) {
        var u = s, d = h + l;
        o ^= -1;
        for (var p = h; p < d; p++) o = o >>> 8 ^ u[255 & (o ^ a[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, r) {
      var s, o = e("../utils/common"), a = e("./trees"), l = e("./adler32"), h = e("./crc32"), u = e("./messages"), d = 0, p = 4, f = 0, m = -2, b = -1, x = 4, y = 2, v = 8, k = 9, C = 286, E = 30, q = 19, T = 2 * C + 1, F = 15, M = 3, B = 258, P = B + M + 1, A = 42, I = 113, S = 1, X = 2, H = 3, j = 4;
      function Q(O, ct) {
        return O.msg = u[ct], ct;
      }
      function G(O) {
        return (O << 1) - (4 < O ? 9 : 0);
      }
      function ft(O) {
        for (var ct = O.length; 0 <= --ct; ) O[ct] = 0;
      }
      function nt(O) {
        var ct = O.state, U = ct.pending;
        U > O.avail_out && (U = O.avail_out), U !== 0 && (o.arraySet(O.output, ct.pending_buf, ct.pending_out, U, O.next_out), O.next_out += U, ct.pending_out += U, O.total_out += U, O.avail_out -= U, ct.pending -= U, ct.pending === 0 && (ct.pending_out = 0));
      }
      function N(O, ct) {
        a._tr_flush_block(O, 0 <= O.block_start ? O.block_start : -1, O.strstart - O.block_start, ct), O.block_start = O.strstart, nt(O.strm);
      }
      function z(O, ct) {
        O.pending_buf[O.pending++] = ct;
      }
      function V(O, ct) {
        O.pending_buf[O.pending++] = ct >>> 8 & 255, O.pending_buf[O.pending++] = 255 & ct;
      }
      function Y(O, ct) {
        var U, et, J = O.max_chain_length, rt = O.strstart, vt = O.prev_length, At = O.nice_match, ht = O.strstart > O.w_size - P ? O.strstart - (O.w_size - P) : 0, Ot = O.window, $t = O.w_mask, Ft = O.prev, Ut = O.strstart + B, ie = Ot[rt + vt - 1], oe = Ot[rt + vt];
        O.prev_length >= O.good_match && (J >>= 2), At > O.lookahead && (At = O.lookahead);
        do
          if (Ot[(U = ct) + vt] === oe && Ot[U + vt - 1] === ie && Ot[U] === Ot[rt] && Ot[++U] === Ot[rt + 1]) {
            rt += 2, U++;
            do
              ;
            while (Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && Ot[++rt] === Ot[++U] && rt < Ut);
            if (et = B - (Ut - rt), rt = Ut - B, vt < et) {
              if (O.match_start = ct, At <= (vt = et)) break;
              ie = Ot[rt + vt - 1], oe = Ot[rt + vt];
            }
          }
        while ((ct = Ft[ct & $t]) > ht && --J != 0);
        return vt <= O.lookahead ? vt : O.lookahead;
      }
      function ot(O) {
        var ct, U, et, J, rt, vt, At, ht, Ot, $t, Ft = O.w_size;
        do {
          if (J = O.window_size - O.lookahead - O.strstart, O.strstart >= Ft + (Ft - P)) {
            for (o.arraySet(O.window, O.window, Ft, Ft, 0), O.match_start -= Ft, O.strstart -= Ft, O.block_start -= Ft, ct = U = O.hash_size; et = O.head[--ct], O.head[ct] = Ft <= et ? et - Ft : 0, --U; ) ;
            for (ct = U = Ft; et = O.prev[--ct], O.prev[ct] = Ft <= et ? et - Ft : 0, --U; ) ;
            J += Ft;
          }
          if (O.strm.avail_in === 0) break;
          if (vt = O.strm, At = O.window, ht = O.strstart + O.lookahead, Ot = J, $t = void 0, $t = vt.avail_in, Ot < $t && ($t = Ot), U = $t === 0 ? 0 : (vt.avail_in -= $t, o.arraySet(At, vt.input, vt.next_in, $t, ht), vt.state.wrap === 1 ? vt.adler = l(vt.adler, At, $t, ht) : vt.state.wrap === 2 && (vt.adler = h(vt.adler, At, $t, ht)), vt.next_in += $t, vt.total_in += $t, $t), O.lookahead += U, O.lookahead + O.insert >= M) for (rt = O.strstart - O.insert, O.ins_h = O.window[rt], O.ins_h = (O.ins_h << O.hash_shift ^ O.window[rt + 1]) & O.hash_mask; O.insert && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[rt + M - 1]) & O.hash_mask, O.prev[rt & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = rt, rt++, O.insert--, !(O.lookahead + O.insert < M)); ) ;
        } while (O.lookahead < P && O.strm.avail_in !== 0);
      }
      function wt(O, ct) {
        for (var U, et; ; ) {
          if (O.lookahead < P) {
            if (ot(O), O.lookahead < P && ct === d) return S;
            if (O.lookahead === 0) break;
          }
          if (U = 0, O.lookahead >= M && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + M - 1]) & O.hash_mask, U = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart), U !== 0 && O.strstart - U <= O.w_size - P && (O.match_length = Y(O, U)), O.match_length >= M) if (et = a._tr_tally(O, O.strstart - O.match_start, O.match_length - M), O.lookahead -= O.match_length, O.match_length <= O.max_lazy_match && O.lookahead >= M) {
            for (O.match_length--; O.strstart++, O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + M - 1]) & O.hash_mask, U = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart, --O.match_length != 0; ) ;
            O.strstart++;
          } else O.strstart += O.match_length, O.match_length = 0, O.ins_h = O.window[O.strstart], O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + 1]) & O.hash_mask;
          else et = a._tr_tally(O, 0, O.window[O.strstart]), O.lookahead--, O.strstart++;
          if (et && (N(O, !1), O.strm.avail_out === 0)) return S;
        }
        return O.insert = O.strstart < M - 1 ? O.strstart : M - 1, ct === p ? (N(O, !0), O.strm.avail_out === 0 ? H : j) : O.last_lit && (N(O, !1), O.strm.avail_out === 0) ? S : X;
      }
      function mt(O, ct) {
        for (var U, et, J; ; ) {
          if (O.lookahead < P) {
            if (ot(O), O.lookahead < P && ct === d) return S;
            if (O.lookahead === 0) break;
          }
          if (U = 0, O.lookahead >= M && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + M - 1]) & O.hash_mask, U = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart), O.prev_length = O.match_length, O.prev_match = O.match_start, O.match_length = M - 1, U !== 0 && O.prev_length < O.max_lazy_match && O.strstart - U <= O.w_size - P && (O.match_length = Y(O, U), O.match_length <= 5 && (O.strategy === 1 || O.match_length === M && 4096 < O.strstart - O.match_start) && (O.match_length = M - 1)), O.prev_length >= M && O.match_length <= O.prev_length) {
            for (J = O.strstart + O.lookahead - M, et = a._tr_tally(O, O.strstart - 1 - O.prev_match, O.prev_length - M), O.lookahead -= O.prev_length - 1, O.prev_length -= 2; ++O.strstart <= J && (O.ins_h = (O.ins_h << O.hash_shift ^ O.window[O.strstart + M - 1]) & O.hash_mask, U = O.prev[O.strstart & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = O.strstart), --O.prev_length != 0; ) ;
            if (O.match_available = 0, O.match_length = M - 1, O.strstart++, et && (N(O, !1), O.strm.avail_out === 0)) return S;
          } else if (O.match_available) {
            if ((et = a._tr_tally(O, 0, O.window[O.strstart - 1])) && N(O, !1), O.strstart++, O.lookahead--, O.strm.avail_out === 0) return S;
          } else O.match_available = 1, O.strstart++, O.lookahead--;
        }
        return O.match_available && (et = a._tr_tally(O, 0, O.window[O.strstart - 1]), O.match_available = 0), O.insert = O.strstart < M - 1 ? O.strstart : M - 1, ct === p ? (N(O, !0), O.strm.avail_out === 0 ? H : j) : O.last_lit && (N(O, !1), O.strm.avail_out === 0) ? S : X;
      }
      function xt(O, ct, U, et, J) {
        this.good_length = O, this.max_lazy = ct, this.nice_length = U, this.max_chain = et, this.func = J;
      }
      function zt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * T), this.dyn_dtree = new o.Buf16(2 * (2 * E + 1)), this.bl_tree = new o.Buf16(2 * (2 * q + 1)), ft(this.dyn_ltree), ft(this.dyn_dtree), ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(F + 1), this.heap = new o.Buf16(2 * C + 1), ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * C + 1), ft(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Dt(O) {
        var ct;
        return O && O.state ? (O.total_in = O.total_out = 0, O.data_type = y, (ct = O.state).pending = 0, ct.pending_out = 0, ct.wrap < 0 && (ct.wrap = -ct.wrap), ct.status = ct.wrap ? A : I, O.adler = ct.wrap === 2 ? 0 : 1, ct.last_flush = d, a._tr_init(ct), f) : Q(O, m);
      }
      function Jt(O) {
        var ct = Dt(O);
        return ct === f && function(U) {
          U.window_size = 2 * U.w_size, ft(U.head), U.max_lazy_match = s[U.level].max_lazy, U.good_match = s[U.level].good_length, U.nice_match = s[U.level].nice_length, U.max_chain_length = s[U.level].max_chain, U.strstart = 0, U.block_start = 0, U.lookahead = 0, U.insert = 0, U.match_length = U.prev_length = M - 1, U.match_available = 0, U.ins_h = 0;
        }(O.state), ct;
      }
      function Qt(O, ct, U, et, J, rt) {
        if (!O) return m;
        var vt = 1;
        if (ct === b && (ct = 6), et < 0 ? (vt = 0, et = -et) : 15 < et && (vt = 2, et -= 16), J < 1 || k < J || U !== v || et < 8 || 15 < et || ct < 0 || 9 < ct || rt < 0 || x < rt) return Q(O, m);
        et === 8 && (et = 9);
        var At = new zt();
        return (O.state = At).strm = O, At.wrap = vt, At.gzhead = null, At.w_bits = et, At.w_size = 1 << At.w_bits, At.w_mask = At.w_size - 1, At.hash_bits = J + 7, At.hash_size = 1 << At.hash_bits, At.hash_mask = At.hash_size - 1, At.hash_shift = ~~((At.hash_bits + M - 1) / M), At.window = new o.Buf8(2 * At.w_size), At.head = new o.Buf16(At.hash_size), At.prev = new o.Buf16(At.w_size), At.lit_bufsize = 1 << J + 6, At.pending_buf_size = 4 * At.lit_bufsize, At.pending_buf = new o.Buf8(At.pending_buf_size), At.d_buf = 1 * At.lit_bufsize, At.l_buf = 3 * At.lit_bufsize, At.level = ct, At.strategy = rt, At.method = U, Jt(O);
      }
      s = [new xt(0, 0, 0, 0, function(O, ct) {
        var U = 65535;
        for (U > O.pending_buf_size - 5 && (U = O.pending_buf_size - 5); ; ) {
          if (O.lookahead <= 1) {
            if (ot(O), O.lookahead === 0 && ct === d) return S;
            if (O.lookahead === 0) break;
          }
          O.strstart += O.lookahead, O.lookahead = 0;
          var et = O.block_start + U;
          if ((O.strstart === 0 || O.strstart >= et) && (O.lookahead = O.strstart - et, O.strstart = et, N(O, !1), O.strm.avail_out === 0) || O.strstart - O.block_start >= O.w_size - P && (N(O, !1), O.strm.avail_out === 0)) return S;
        }
        return O.insert = 0, ct === p ? (N(O, !0), O.strm.avail_out === 0 ? H : j) : (O.strstart > O.block_start && (N(O, !1), O.strm.avail_out), S);
      }), new xt(4, 4, 8, 4, wt), new xt(4, 5, 16, 8, wt), new xt(4, 6, 32, 32, wt), new xt(4, 4, 16, 16, mt), new xt(8, 16, 32, 32, mt), new xt(8, 16, 128, 128, mt), new xt(8, 32, 128, 256, mt), new xt(32, 128, 258, 1024, mt), new xt(32, 258, 258, 4096, mt)], r.deflateInit = function(O, ct) {
        return Qt(O, ct, v, 15, 8, 0);
      }, r.deflateInit2 = Qt, r.deflateReset = Jt, r.deflateResetKeep = Dt, r.deflateSetHeader = function(O, ct) {
        return O && O.state ? O.state.wrap !== 2 ? m : (O.state.gzhead = ct, f) : m;
      }, r.deflate = function(O, ct) {
        var U, et, J, rt;
        if (!O || !O.state || 5 < ct || ct < 0) return O ? Q(O, m) : m;
        if (et = O.state, !O.output || !O.input && O.avail_in !== 0 || et.status === 666 && ct !== p) return Q(O, O.avail_out === 0 ? -5 : m);
        if (et.strm = O, U = et.last_flush, et.last_flush = ct, et.status === A) if (et.wrap === 2) O.adler = 0, z(et, 31), z(et, 139), z(et, 8), et.gzhead ? (z(et, (et.gzhead.text ? 1 : 0) + (et.gzhead.hcrc ? 2 : 0) + (et.gzhead.extra ? 4 : 0) + (et.gzhead.name ? 8 : 0) + (et.gzhead.comment ? 16 : 0)), z(et, 255 & et.gzhead.time), z(et, et.gzhead.time >> 8 & 255), z(et, et.gzhead.time >> 16 & 255), z(et, et.gzhead.time >> 24 & 255), z(et, et.level === 9 ? 2 : 2 <= et.strategy || et.level < 2 ? 4 : 0), z(et, 255 & et.gzhead.os), et.gzhead.extra && et.gzhead.extra.length && (z(et, 255 & et.gzhead.extra.length), z(et, et.gzhead.extra.length >> 8 & 255)), et.gzhead.hcrc && (O.adler = h(O.adler, et.pending_buf, et.pending, 0)), et.gzindex = 0, et.status = 69) : (z(et, 0), z(et, 0), z(et, 0), z(et, 0), z(et, 0), z(et, et.level === 9 ? 2 : 2 <= et.strategy || et.level < 2 ? 4 : 0), z(et, 3), et.status = I);
        else {
          var vt = v + (et.w_bits - 8 << 4) << 8;
          vt |= (2 <= et.strategy || et.level < 2 ? 0 : et.level < 6 ? 1 : et.level === 6 ? 2 : 3) << 6, et.strstart !== 0 && (vt |= 32), vt += 31 - vt % 31, et.status = I, V(et, vt), et.strstart !== 0 && (V(et, O.adler >>> 16), V(et, 65535 & O.adler)), O.adler = 1;
        }
        if (et.status === 69) if (et.gzhead.extra) {
          for (J = et.pending; et.gzindex < (65535 & et.gzhead.extra.length) && (et.pending !== et.pending_buf_size || (et.gzhead.hcrc && et.pending > J && (O.adler = h(O.adler, et.pending_buf, et.pending - J, J)), nt(O), J = et.pending, et.pending !== et.pending_buf_size)); ) z(et, 255 & et.gzhead.extra[et.gzindex]), et.gzindex++;
          et.gzhead.hcrc && et.pending > J && (O.adler = h(O.adler, et.pending_buf, et.pending - J, J)), et.gzindex === et.gzhead.extra.length && (et.gzindex = 0, et.status = 73);
        } else et.status = 73;
        if (et.status === 73) if (et.gzhead.name) {
          J = et.pending;
          do {
            if (et.pending === et.pending_buf_size && (et.gzhead.hcrc && et.pending > J && (O.adler = h(O.adler, et.pending_buf, et.pending - J, J)), nt(O), J = et.pending, et.pending === et.pending_buf_size)) {
              rt = 1;
              break;
            }
            rt = et.gzindex < et.gzhead.name.length ? 255 & et.gzhead.name.charCodeAt(et.gzindex++) : 0, z(et, rt);
          } while (rt !== 0);
          et.gzhead.hcrc && et.pending > J && (O.adler = h(O.adler, et.pending_buf, et.pending - J, J)), rt === 0 && (et.gzindex = 0, et.status = 91);
        } else et.status = 91;
        if (et.status === 91) if (et.gzhead.comment) {
          J = et.pending;
          do {
            if (et.pending === et.pending_buf_size && (et.gzhead.hcrc && et.pending > J && (O.adler = h(O.adler, et.pending_buf, et.pending - J, J)), nt(O), J = et.pending, et.pending === et.pending_buf_size)) {
              rt = 1;
              break;
            }
            rt = et.gzindex < et.gzhead.comment.length ? 255 & et.gzhead.comment.charCodeAt(et.gzindex++) : 0, z(et, rt);
          } while (rt !== 0);
          et.gzhead.hcrc && et.pending > J && (O.adler = h(O.adler, et.pending_buf, et.pending - J, J)), rt === 0 && (et.status = 103);
        } else et.status = 103;
        if (et.status === 103 && (et.gzhead.hcrc ? (et.pending + 2 > et.pending_buf_size && nt(O), et.pending + 2 <= et.pending_buf_size && (z(et, 255 & O.adler), z(et, O.adler >> 8 & 255), O.adler = 0, et.status = I)) : et.status = I), et.pending !== 0) {
          if (nt(O), O.avail_out === 0) return et.last_flush = -1, f;
        } else if (O.avail_in === 0 && G(ct) <= G(U) && ct !== p) return Q(O, -5);
        if (et.status === 666 && O.avail_in !== 0) return Q(O, -5);
        if (O.avail_in !== 0 || et.lookahead !== 0 || ct !== d && et.status !== 666) {
          var At = et.strategy === 2 ? function(ht, Ot) {
            for (var $t; ; ) {
              if (ht.lookahead === 0 && (ot(ht), ht.lookahead === 0)) {
                if (Ot === d) return S;
                break;
              }
              if (ht.match_length = 0, $t = a._tr_tally(ht, 0, ht.window[ht.strstart]), ht.lookahead--, ht.strstart++, $t && (N(ht, !1), ht.strm.avail_out === 0)) return S;
            }
            return ht.insert = 0, Ot === p ? (N(ht, !0), ht.strm.avail_out === 0 ? H : j) : ht.last_lit && (N(ht, !1), ht.strm.avail_out === 0) ? S : X;
          }(et, ct) : et.strategy === 3 ? function(ht, Ot) {
            for (var $t, Ft, Ut, ie, oe = ht.window; ; ) {
              if (ht.lookahead <= B) {
                if (ot(ht), ht.lookahead <= B && Ot === d) return S;
                if (ht.lookahead === 0) break;
              }
              if (ht.match_length = 0, ht.lookahead >= M && 0 < ht.strstart && (Ft = oe[Ut = ht.strstart - 1]) === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut]) {
                ie = ht.strstart + B;
                do
                  ;
                while (Ft === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut] && Ft === oe[++Ut] && Ut < ie);
                ht.match_length = B - (ie - Ut), ht.match_length > ht.lookahead && (ht.match_length = ht.lookahead);
              }
              if (ht.match_length >= M ? ($t = a._tr_tally(ht, 1, ht.match_length - M), ht.lookahead -= ht.match_length, ht.strstart += ht.match_length, ht.match_length = 0) : ($t = a._tr_tally(ht, 0, ht.window[ht.strstart]), ht.lookahead--, ht.strstart++), $t && (N(ht, !1), ht.strm.avail_out === 0)) return S;
            }
            return ht.insert = 0, Ot === p ? (N(ht, !0), ht.strm.avail_out === 0 ? H : j) : ht.last_lit && (N(ht, !1), ht.strm.avail_out === 0) ? S : X;
          }(et, ct) : s[et.level].func(et, ct);
          if (At !== H && At !== j || (et.status = 666), At === S || At === H) return O.avail_out === 0 && (et.last_flush = -1), f;
          if (At === X && (ct === 1 ? a._tr_align(et) : ct !== 5 && (a._tr_stored_block(et, 0, 0, !1), ct === 3 && (ft(et.head), et.lookahead === 0 && (et.strstart = 0, et.block_start = 0, et.insert = 0))), nt(O), O.avail_out === 0)) return et.last_flush = -1, f;
        }
        return ct !== p ? f : et.wrap <= 0 ? 1 : (et.wrap === 2 ? (z(et, 255 & O.adler), z(et, O.adler >> 8 & 255), z(et, O.adler >> 16 & 255), z(et, O.adler >> 24 & 255), z(et, 255 & O.total_in), z(et, O.total_in >> 8 & 255), z(et, O.total_in >> 16 & 255), z(et, O.total_in >> 24 & 255)) : (V(et, O.adler >>> 16), V(et, 65535 & O.adler)), nt(O), 0 < et.wrap && (et.wrap = -et.wrap), et.pending !== 0 ? f : 1);
      }, r.deflateEnd = function(O) {
        var ct;
        return O && O.state ? (ct = O.state.status) !== A && ct !== 69 && ct !== 73 && ct !== 91 && ct !== 103 && ct !== I && ct !== 666 ? Q(O, m) : (O.state = null, ct === I ? Q(O, -3) : f) : m;
      }, r.deflateSetDictionary = function(O, ct) {
        var U, et, J, rt, vt, At, ht, Ot, $t = ct.length;
        if (!O || !O.state || (rt = (U = O.state).wrap) === 2 || rt === 1 && U.status !== A || U.lookahead) return m;
        for (rt === 1 && (O.adler = l(O.adler, ct, $t, 0)), U.wrap = 0, $t >= U.w_size && (rt === 0 && (ft(U.head), U.strstart = 0, U.block_start = 0, U.insert = 0), Ot = new o.Buf8(U.w_size), o.arraySet(Ot, ct, $t - U.w_size, U.w_size, 0), ct = Ot, $t = U.w_size), vt = O.avail_in, At = O.next_in, ht = O.input, O.avail_in = $t, O.next_in = 0, O.input = ct, ot(U); U.lookahead >= M; ) {
          for (et = U.strstart, J = U.lookahead - (M - 1); U.ins_h = (U.ins_h << U.hash_shift ^ U.window[et + M - 1]) & U.hash_mask, U.prev[et & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = et, et++, --J; ) ;
          U.strstart = et, U.lookahead = M - 1, ot(U);
        }
        return U.strstart += U.lookahead, U.block_start = U.strstart, U.insert = U.lookahead, U.lookahead = 0, U.match_length = U.prev_length = M - 1, U.match_available = 0, O.next_in = At, O.input = ht, O.avail_in = vt, U.wrap = rt, f;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, r) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, r) {
      i.exports = function(s, o) {
        var a, l, h, u, d, p, f, m, b, x, y, v, k, C, E, q, T, F, M, B, P, A, I, S, X;
        a = s.state, l = s.next_in, S = s.input, h = l + (s.avail_in - 5), u = s.next_out, X = s.output, d = u - (o - s.avail_out), p = u + (s.avail_out - 257), f = a.dmax, m = a.wsize, b = a.whave, x = a.wnext, y = a.window, v = a.hold, k = a.bits, C = a.lencode, E = a.distcode, q = (1 << a.lenbits) - 1, T = (1 << a.distbits) - 1;
        t: do {
          k < 15 && (v += S[l++] << k, k += 8, v += S[l++] << k, k += 8), F = C[v & q];
          e: for (; ; ) {
            if (v >>>= M = F >>> 24, k -= M, (M = F >>> 16 & 255) === 0) X[u++] = 65535 & F;
            else {
              if (!(16 & M)) {
                if (!(64 & M)) {
                  F = C[(65535 & F) + (v & (1 << M) - 1)];
                  continue e;
                }
                if (32 & M) {
                  a.mode = 12;
                  break t;
                }
                s.msg = "invalid literal/length code", a.mode = 30;
                break t;
              }
              B = 65535 & F, (M &= 15) && (k < M && (v += S[l++] << k, k += 8), B += v & (1 << M) - 1, v >>>= M, k -= M), k < 15 && (v += S[l++] << k, k += 8, v += S[l++] << k, k += 8), F = E[v & T];
              n: for (; ; ) {
                if (v >>>= M = F >>> 24, k -= M, !(16 & (M = F >>> 16 & 255))) {
                  if (!(64 & M)) {
                    F = E[(65535 & F) + (v & (1 << M) - 1)];
                    continue n;
                  }
                  s.msg = "invalid distance code", a.mode = 30;
                  break t;
                }
                if (P = 65535 & F, k < (M &= 15) && (v += S[l++] << k, (k += 8) < M && (v += S[l++] << k, k += 8)), f < (P += v & (1 << M) - 1)) {
                  s.msg = "invalid distance too far back", a.mode = 30;
                  break t;
                }
                if (v >>>= M, k -= M, (M = u - d) < P) {
                  if (b < (M = P - M) && a.sane) {
                    s.msg = "invalid distance too far back", a.mode = 30;
                    break t;
                  }
                  if (I = y, (A = 0) === x) {
                    if (A += m - M, M < B) {
                      for (B -= M; X[u++] = y[A++], --M; ) ;
                      A = u - P, I = X;
                    }
                  } else if (x < M) {
                    if (A += m + x - M, (M -= x) < B) {
                      for (B -= M; X[u++] = y[A++], --M; ) ;
                      if (A = 0, x < B) {
                        for (B -= M = x; X[u++] = y[A++], --M; ) ;
                        A = u - P, I = X;
                      }
                    }
                  } else if (A += x - M, M < B) {
                    for (B -= M; X[u++] = y[A++], --M; ) ;
                    A = u - P, I = X;
                  }
                  for (; 2 < B; ) X[u++] = I[A++], X[u++] = I[A++], X[u++] = I[A++], B -= 3;
                  B && (X[u++] = I[A++], 1 < B && (X[u++] = I[A++]));
                } else {
                  for (A = u - P; X[u++] = X[A++], X[u++] = X[A++], X[u++] = X[A++], 2 < (B -= 3); ) ;
                  B && (X[u++] = X[A++], 1 < B && (X[u++] = X[A++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < h && u < p);
        l -= B = k >> 3, v &= (1 << (k -= B << 3)) - 1, s.next_in = l, s.next_out = u, s.avail_in = l < h ? h - l + 5 : 5 - (l - h), s.avail_out = u < p ? p - u + 257 : 257 - (u - p), a.hold = v, a.bits = k;
      };
    }, {}], 49: [function(e, i, r) {
      var s = e("../utils/common"), o = e("./adler32"), a = e("./crc32"), l = e("./inffast"), h = e("./inftrees"), u = 1, d = 2, p = 0, f = -2, m = 1, b = 852, x = 592;
      function y(A) {
        return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((65280 & A) << 8) + ((255 & A) << 24);
      }
      function v() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function k(A) {
        var I;
        return A && A.state ? (I = A.state, A.total_in = A.total_out = I.total = 0, A.msg = "", I.wrap && (A.adler = 1 & I.wrap), I.mode = m, I.last = 0, I.havedict = 0, I.dmax = 32768, I.head = null, I.hold = 0, I.bits = 0, I.lencode = I.lendyn = new s.Buf32(b), I.distcode = I.distdyn = new s.Buf32(x), I.sane = 1, I.back = -1, p) : f;
      }
      function C(A) {
        var I;
        return A && A.state ? ((I = A.state).wsize = 0, I.whave = 0, I.wnext = 0, k(A)) : f;
      }
      function E(A, I) {
        var S, X;
        return A && A.state ? (X = A.state, I < 0 ? (S = 0, I = -I) : (S = 1 + (I >> 4), I < 48 && (I &= 15)), I && (I < 8 || 15 < I) ? f : (X.window !== null && X.wbits !== I && (X.window = null), X.wrap = S, X.wbits = I, C(A))) : f;
      }
      function q(A, I) {
        var S, X;
        return A ? (X = new v(), (A.state = X).window = null, (S = E(A, I)) !== p && (A.state = null), S) : f;
      }
      var T, F, M = !0;
      function B(A) {
        if (M) {
          var I;
          for (T = new s.Buf32(512), F = new s.Buf32(32), I = 0; I < 144; ) A.lens[I++] = 8;
          for (; I < 256; ) A.lens[I++] = 9;
          for (; I < 280; ) A.lens[I++] = 7;
          for (; I < 288; ) A.lens[I++] = 8;
          for (h(u, A.lens, 0, 288, T, 0, A.work, { bits: 9 }), I = 0; I < 32; ) A.lens[I++] = 5;
          h(d, A.lens, 0, 32, F, 0, A.work, { bits: 5 }), M = !1;
        }
        A.lencode = T, A.lenbits = 9, A.distcode = F, A.distbits = 5;
      }
      function P(A, I, S, X) {
        var H, j = A.state;
        return j.window === null && (j.wsize = 1 << j.wbits, j.wnext = 0, j.whave = 0, j.window = new s.Buf8(j.wsize)), X >= j.wsize ? (s.arraySet(j.window, I, S - j.wsize, j.wsize, 0), j.wnext = 0, j.whave = j.wsize) : (X < (H = j.wsize - j.wnext) && (H = X), s.arraySet(j.window, I, S - X, H, j.wnext), (X -= H) ? (s.arraySet(j.window, I, S - X, X, 0), j.wnext = X, j.whave = j.wsize) : (j.wnext += H, j.wnext === j.wsize && (j.wnext = 0), j.whave < j.wsize && (j.whave += H))), 0;
      }
      r.inflateReset = C, r.inflateReset2 = E, r.inflateResetKeep = k, r.inflateInit = function(A) {
        return q(A, 15);
      }, r.inflateInit2 = q, r.inflate = function(A, I) {
        var S, X, H, j, Q, G, ft, nt, N, z, V, Y, ot, wt, mt, xt, zt, Dt, Jt, Qt, O, ct, U, et, J = 0, rt = new s.Buf8(4), vt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0) return f;
        (S = A.state).mode === 12 && (S.mode = 13), Q = A.next_out, H = A.output, ft = A.avail_out, j = A.next_in, X = A.input, G = A.avail_in, nt = S.hold, N = S.bits, z = G, V = ft, ct = p;
        t: for (; ; ) switch (S.mode) {
          case m:
            if (S.wrap === 0) {
              S.mode = 13;
              break;
            }
            for (; N < 16; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            if (2 & S.wrap && nt === 35615) {
              rt[S.check = 0] = 255 & nt, rt[1] = nt >>> 8 & 255, S.check = a(S.check, rt, 2, 0), N = nt = 0, S.mode = 2;
              break;
            }
            if (S.flags = 0, S.head && (S.head.done = !1), !(1 & S.wrap) || (((255 & nt) << 8) + (nt >> 8)) % 31) {
              A.msg = "incorrect header check", S.mode = 30;
              break;
            }
            if ((15 & nt) != 8) {
              A.msg = "unknown compression method", S.mode = 30;
              break;
            }
            if (N -= 4, O = 8 + (15 & (nt >>>= 4)), S.wbits === 0) S.wbits = O;
            else if (O > S.wbits) {
              A.msg = "invalid window size", S.mode = 30;
              break;
            }
            S.dmax = 1 << O, A.adler = S.check = 1, S.mode = 512 & nt ? 10 : 12, N = nt = 0;
            break;
          case 2:
            for (; N < 16; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            if (S.flags = nt, (255 & S.flags) != 8) {
              A.msg = "unknown compression method", S.mode = 30;
              break;
            }
            if (57344 & S.flags) {
              A.msg = "unknown header flags set", S.mode = 30;
              break;
            }
            S.head && (S.head.text = nt >> 8 & 1), 512 & S.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, S.check = a(S.check, rt, 2, 0)), N = nt = 0, S.mode = 3;
          case 3:
            for (; N < 32; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            S.head && (S.head.time = nt), 512 & S.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, rt[2] = nt >>> 16 & 255, rt[3] = nt >>> 24 & 255, S.check = a(S.check, rt, 4, 0)), N = nt = 0, S.mode = 4;
          case 4:
            for (; N < 16; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            S.head && (S.head.xflags = 255 & nt, S.head.os = nt >> 8), 512 & S.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, S.check = a(S.check, rt, 2, 0)), N = nt = 0, S.mode = 5;
          case 5:
            if (1024 & S.flags) {
              for (; N < 16; ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              S.length = nt, S.head && (S.head.extra_len = nt), 512 & S.flags && (rt[0] = 255 & nt, rt[1] = nt >>> 8 & 255, S.check = a(S.check, rt, 2, 0)), N = nt = 0;
            } else S.head && (S.head.extra = null);
            S.mode = 6;
          case 6:
            if (1024 & S.flags && (G < (Y = S.length) && (Y = G), Y && (S.head && (O = S.head.extra_len - S.length, S.head.extra || (S.head.extra = new Array(S.head.extra_len)), s.arraySet(S.head.extra, X, j, Y, O)), 512 & S.flags && (S.check = a(S.check, X, Y, j)), G -= Y, j += Y, S.length -= Y), S.length)) break t;
            S.length = 0, S.mode = 7;
          case 7:
            if (2048 & S.flags) {
              if (G === 0) break t;
              for (Y = 0; O = X[j + Y++], S.head && O && S.length < 65536 && (S.head.name += String.fromCharCode(O)), O && Y < G; ) ;
              if (512 & S.flags && (S.check = a(S.check, X, Y, j)), G -= Y, j += Y, O) break t;
            } else S.head && (S.head.name = null);
            S.length = 0, S.mode = 8;
          case 8:
            if (4096 & S.flags) {
              if (G === 0) break t;
              for (Y = 0; O = X[j + Y++], S.head && O && S.length < 65536 && (S.head.comment += String.fromCharCode(O)), O && Y < G; ) ;
              if (512 & S.flags && (S.check = a(S.check, X, Y, j)), G -= Y, j += Y, O) break t;
            } else S.head && (S.head.comment = null);
            S.mode = 9;
          case 9:
            if (512 & S.flags) {
              for (; N < 16; ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              if (nt !== (65535 & S.check)) {
                A.msg = "header crc mismatch", S.mode = 30;
                break;
              }
              N = nt = 0;
            }
            S.head && (S.head.hcrc = S.flags >> 9 & 1, S.head.done = !0), A.adler = S.check = 0, S.mode = 12;
            break;
          case 10:
            for (; N < 32; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            A.adler = S.check = y(nt), N = nt = 0, S.mode = 11;
          case 11:
            if (S.havedict === 0) return A.next_out = Q, A.avail_out = ft, A.next_in = j, A.avail_in = G, S.hold = nt, S.bits = N, 2;
            A.adler = S.check = 1, S.mode = 12;
          case 12:
            if (I === 5 || I === 6) break t;
          case 13:
            if (S.last) {
              nt >>>= 7 & N, N -= 7 & N, S.mode = 27;
              break;
            }
            for (; N < 3; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            switch (S.last = 1 & nt, N -= 1, 3 & (nt >>>= 1)) {
              case 0:
                S.mode = 14;
                break;
              case 1:
                if (B(S), S.mode = 20, I !== 6) break;
                nt >>>= 2, N -= 2;
                break t;
              case 2:
                S.mode = 17;
                break;
              case 3:
                A.msg = "invalid block type", S.mode = 30;
            }
            nt >>>= 2, N -= 2;
            break;
          case 14:
            for (nt >>>= 7 & N, N -= 7 & N; N < 32; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            if ((65535 & nt) != (nt >>> 16 ^ 65535)) {
              A.msg = "invalid stored block lengths", S.mode = 30;
              break;
            }
            if (S.length = 65535 & nt, N = nt = 0, S.mode = 15, I === 6) break t;
          case 15:
            S.mode = 16;
          case 16:
            if (Y = S.length) {
              if (G < Y && (Y = G), ft < Y && (Y = ft), Y === 0) break t;
              s.arraySet(H, X, j, Y, Q), G -= Y, j += Y, ft -= Y, Q += Y, S.length -= Y;
              break;
            }
            S.mode = 12;
            break;
          case 17:
            for (; N < 14; ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            if (S.nlen = 257 + (31 & nt), nt >>>= 5, N -= 5, S.ndist = 1 + (31 & nt), nt >>>= 5, N -= 5, S.ncode = 4 + (15 & nt), nt >>>= 4, N -= 4, 286 < S.nlen || 30 < S.ndist) {
              A.msg = "too many length or distance symbols", S.mode = 30;
              break;
            }
            S.have = 0, S.mode = 18;
          case 18:
            for (; S.have < S.ncode; ) {
              for (; N < 3; ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              S.lens[vt[S.have++]] = 7 & nt, nt >>>= 3, N -= 3;
            }
            for (; S.have < 19; ) S.lens[vt[S.have++]] = 0;
            if (S.lencode = S.lendyn, S.lenbits = 7, U = { bits: S.lenbits }, ct = h(0, S.lens, 0, 19, S.lencode, 0, S.work, U), S.lenbits = U.bits, ct) {
              A.msg = "invalid code lengths set", S.mode = 30;
              break;
            }
            S.have = 0, S.mode = 19;
          case 19:
            for (; S.have < S.nlen + S.ndist; ) {
              for (; xt = (J = S.lencode[nt & (1 << S.lenbits) - 1]) >>> 16 & 255, zt = 65535 & J, !((mt = J >>> 24) <= N); ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              if (zt < 16) nt >>>= mt, N -= mt, S.lens[S.have++] = zt;
              else {
                if (zt === 16) {
                  for (et = mt + 2; N < et; ) {
                    if (G === 0) break t;
                    G--, nt += X[j++] << N, N += 8;
                  }
                  if (nt >>>= mt, N -= mt, S.have === 0) {
                    A.msg = "invalid bit length repeat", S.mode = 30;
                    break;
                  }
                  O = S.lens[S.have - 1], Y = 3 + (3 & nt), nt >>>= 2, N -= 2;
                } else if (zt === 17) {
                  for (et = mt + 3; N < et; ) {
                    if (G === 0) break t;
                    G--, nt += X[j++] << N, N += 8;
                  }
                  N -= mt, O = 0, Y = 3 + (7 & (nt >>>= mt)), nt >>>= 3, N -= 3;
                } else {
                  for (et = mt + 7; N < et; ) {
                    if (G === 0) break t;
                    G--, nt += X[j++] << N, N += 8;
                  }
                  N -= mt, O = 0, Y = 11 + (127 & (nt >>>= mt)), nt >>>= 7, N -= 7;
                }
                if (S.have + Y > S.nlen + S.ndist) {
                  A.msg = "invalid bit length repeat", S.mode = 30;
                  break;
                }
                for (; Y--; ) S.lens[S.have++] = O;
              }
            }
            if (S.mode === 30) break;
            if (S.lens[256] === 0) {
              A.msg = "invalid code -- missing end-of-block", S.mode = 30;
              break;
            }
            if (S.lenbits = 9, U = { bits: S.lenbits }, ct = h(u, S.lens, 0, S.nlen, S.lencode, 0, S.work, U), S.lenbits = U.bits, ct) {
              A.msg = "invalid literal/lengths set", S.mode = 30;
              break;
            }
            if (S.distbits = 6, S.distcode = S.distdyn, U = { bits: S.distbits }, ct = h(d, S.lens, S.nlen, S.ndist, S.distcode, 0, S.work, U), S.distbits = U.bits, ct) {
              A.msg = "invalid distances set", S.mode = 30;
              break;
            }
            if (S.mode = 20, I === 6) break t;
          case 20:
            S.mode = 21;
          case 21:
            if (6 <= G && 258 <= ft) {
              A.next_out = Q, A.avail_out = ft, A.next_in = j, A.avail_in = G, S.hold = nt, S.bits = N, l(A, V), Q = A.next_out, H = A.output, ft = A.avail_out, j = A.next_in, X = A.input, G = A.avail_in, nt = S.hold, N = S.bits, S.mode === 12 && (S.back = -1);
              break;
            }
            for (S.back = 0; xt = (J = S.lencode[nt & (1 << S.lenbits) - 1]) >>> 16 & 255, zt = 65535 & J, !((mt = J >>> 24) <= N); ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            if (xt && !(240 & xt)) {
              for (Dt = mt, Jt = xt, Qt = zt; xt = (J = S.lencode[Qt + ((nt & (1 << Dt + Jt) - 1) >> Dt)]) >>> 16 & 255, zt = 65535 & J, !(Dt + (mt = J >>> 24) <= N); ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              nt >>>= Dt, N -= Dt, S.back += Dt;
            }
            if (nt >>>= mt, N -= mt, S.back += mt, S.length = zt, xt === 0) {
              S.mode = 26;
              break;
            }
            if (32 & xt) {
              S.back = -1, S.mode = 12;
              break;
            }
            if (64 & xt) {
              A.msg = "invalid literal/length code", S.mode = 30;
              break;
            }
            S.extra = 15 & xt, S.mode = 22;
          case 22:
            if (S.extra) {
              for (et = S.extra; N < et; ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              S.length += nt & (1 << S.extra) - 1, nt >>>= S.extra, N -= S.extra, S.back += S.extra;
            }
            S.was = S.length, S.mode = 23;
          case 23:
            for (; xt = (J = S.distcode[nt & (1 << S.distbits) - 1]) >>> 16 & 255, zt = 65535 & J, !((mt = J >>> 24) <= N); ) {
              if (G === 0) break t;
              G--, nt += X[j++] << N, N += 8;
            }
            if (!(240 & xt)) {
              for (Dt = mt, Jt = xt, Qt = zt; xt = (J = S.distcode[Qt + ((nt & (1 << Dt + Jt) - 1) >> Dt)]) >>> 16 & 255, zt = 65535 & J, !(Dt + (mt = J >>> 24) <= N); ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              nt >>>= Dt, N -= Dt, S.back += Dt;
            }
            if (nt >>>= mt, N -= mt, S.back += mt, 64 & xt) {
              A.msg = "invalid distance code", S.mode = 30;
              break;
            }
            S.offset = zt, S.extra = 15 & xt, S.mode = 24;
          case 24:
            if (S.extra) {
              for (et = S.extra; N < et; ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              S.offset += nt & (1 << S.extra) - 1, nt >>>= S.extra, N -= S.extra, S.back += S.extra;
            }
            if (S.offset > S.dmax) {
              A.msg = "invalid distance too far back", S.mode = 30;
              break;
            }
            S.mode = 25;
          case 25:
            if (ft === 0) break t;
            if (Y = V - ft, S.offset > Y) {
              if ((Y = S.offset - Y) > S.whave && S.sane) {
                A.msg = "invalid distance too far back", S.mode = 30;
                break;
              }
              ot = Y > S.wnext ? (Y -= S.wnext, S.wsize - Y) : S.wnext - Y, Y > S.length && (Y = S.length), wt = S.window;
            } else wt = H, ot = Q - S.offset, Y = S.length;
            for (ft < Y && (Y = ft), ft -= Y, S.length -= Y; H[Q++] = wt[ot++], --Y; ) ;
            S.length === 0 && (S.mode = 21);
            break;
          case 26:
            if (ft === 0) break t;
            H[Q++] = S.length, ft--, S.mode = 21;
            break;
          case 27:
            if (S.wrap) {
              for (; N < 32; ) {
                if (G === 0) break t;
                G--, nt |= X[j++] << N, N += 8;
              }
              if (V -= ft, A.total_out += V, S.total += V, V && (A.adler = S.check = S.flags ? a(S.check, H, V, Q - V) : o(S.check, H, V, Q - V)), V = ft, (S.flags ? nt : y(nt)) !== S.check) {
                A.msg = "incorrect data check", S.mode = 30;
                break;
              }
              N = nt = 0;
            }
            S.mode = 28;
          case 28:
            if (S.wrap && S.flags) {
              for (; N < 32; ) {
                if (G === 0) break t;
                G--, nt += X[j++] << N, N += 8;
              }
              if (nt !== (4294967295 & S.total)) {
                A.msg = "incorrect length check", S.mode = 30;
                break;
              }
              N = nt = 0;
            }
            S.mode = 29;
          case 29:
            ct = 1;
            break t;
          case 30:
            ct = -3;
            break t;
          case 31:
            return -4;
          case 32:
          default:
            return f;
        }
        return A.next_out = Q, A.avail_out = ft, A.next_in = j, A.avail_in = G, S.hold = nt, S.bits = N, (S.wsize || V !== A.avail_out && S.mode < 30 && (S.mode < 27 || I !== 4)) && P(A, A.output, A.next_out, V - A.avail_out) ? (S.mode = 31, -4) : (z -= A.avail_in, V -= A.avail_out, A.total_in += z, A.total_out += V, S.total += V, S.wrap && V && (A.adler = S.check = S.flags ? a(S.check, H, V, A.next_out - V) : o(S.check, H, V, A.next_out - V)), A.data_type = S.bits + (S.last ? 64 : 0) + (S.mode === 12 ? 128 : 0) + (S.mode === 20 || S.mode === 15 ? 256 : 0), (z == 0 && V === 0 || I === 4) && ct === p && (ct = -5), ct);
      }, r.inflateEnd = function(A) {
        if (!A || !A.state) return f;
        var I = A.state;
        return I.window && (I.window = null), A.state = null, p;
      }, r.inflateGetHeader = function(A, I) {
        var S;
        return A && A.state && 2 & (S = A.state).wrap ? ((S.head = I).done = !1, p) : f;
      }, r.inflateSetDictionary = function(A, I) {
        var S, X = I.length;
        return A && A.state ? (S = A.state).wrap !== 0 && S.mode !== 11 ? f : S.mode === 11 && o(1, I, X, 0) !== S.check ? -3 : P(A, I, X, X) ? (S.mode = 31, -4) : (S.havedict = 1, p) : f;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, r) {
      var s = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(u, d, p, f, m, b, x, y) {
        var v, k, C, E, q, T, F, M, B, P = y.bits, A = 0, I = 0, S = 0, X = 0, H = 0, j = 0, Q = 0, G = 0, ft = 0, nt = 0, N = null, z = 0, V = new s.Buf16(16), Y = new s.Buf16(16), ot = null, wt = 0;
        for (A = 0; A <= 15; A++) V[A] = 0;
        for (I = 0; I < f; I++) V[d[p + I]]++;
        for (H = P, X = 15; 1 <= X && V[X] === 0; X--) ;
        if (X < H && (H = X), X === 0) return m[b++] = 20971520, m[b++] = 20971520, y.bits = 1, 0;
        for (S = 1; S < X && V[S] === 0; S++) ;
        for (H < S && (H = S), A = G = 1; A <= 15; A++) if (G <<= 1, (G -= V[A]) < 0) return -1;
        if (0 < G && (u === 0 || X !== 1)) return -1;
        for (Y[1] = 0, A = 1; A < 15; A++) Y[A + 1] = Y[A] + V[A];
        for (I = 0; I < f; I++) d[p + I] !== 0 && (x[Y[d[p + I]]++] = I);
        if (T = u === 0 ? (N = ot = x, 19) : u === 1 ? (N = o, z -= 257, ot = a, wt -= 257, 256) : (N = l, ot = h, -1), A = S, q = b, Q = I = nt = 0, C = -1, E = (ft = 1 << (j = H)) - 1, u === 1 && 852 < ft || u === 2 && 592 < ft) return 1;
        for (; ; ) {
          for (F = A - Q, B = x[I] < T ? (M = 0, x[I]) : x[I] > T ? (M = ot[wt + x[I]], N[z + x[I]]) : (M = 96, 0), v = 1 << A - Q, S = k = 1 << j; m[q + (nt >> Q) + (k -= v)] = F << 24 | M << 16 | B | 0, k !== 0; ) ;
          for (v = 1 << A - 1; nt & v; ) v >>= 1;
          if (v !== 0 ? (nt &= v - 1, nt += v) : nt = 0, I++, --V[A] == 0) {
            if (A === X) break;
            A = d[p + x[I]];
          }
          if (H < A && (nt & E) !== C) {
            for (Q === 0 && (Q = H), q += S, G = 1 << (j = A - Q); j + Q < X && !((G -= V[j + Q]) <= 0); ) j++, G <<= 1;
            if (ft += 1 << j, u === 1 && 852 < ft || u === 2 && 592 < ft) return 1;
            m[C = nt & E] = H << 24 | j << 16 | q - b | 0;
          }
        }
        return nt !== 0 && (m[q + nt] = A - Q << 24 | 64 << 16 | 0), y.bits = H, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, r) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, r) {
      var s = e("../utils/common"), o = 0, a = 1;
      function l(J) {
        for (var rt = J.length; 0 <= --rt; ) J[rt] = 0;
      }
      var h = 0, u = 29, d = 256, p = d + 1 + u, f = 30, m = 19, b = 2 * p + 1, x = 15, y = 16, v = 7, k = 256, C = 16, E = 17, q = 18, T = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], F = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], M = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], P = new Array(2 * (p + 2));
      l(P);
      var A = new Array(2 * f);
      l(A);
      var I = new Array(512);
      l(I);
      var S = new Array(256);
      l(S);
      var X = new Array(u);
      l(X);
      var H, j, Q, G = new Array(f);
      function ft(J, rt, vt, At, ht) {
        this.static_tree = J, this.extra_bits = rt, this.extra_base = vt, this.elems = At, this.max_length = ht, this.has_stree = J && J.length;
      }
      function nt(J, rt) {
        this.dyn_tree = J, this.max_code = 0, this.stat_desc = rt;
      }
      function N(J) {
        return J < 256 ? I[J] : I[256 + (J >>> 7)];
      }
      function z(J, rt) {
        J.pending_buf[J.pending++] = 255 & rt, J.pending_buf[J.pending++] = rt >>> 8 & 255;
      }
      function V(J, rt, vt) {
        J.bi_valid > y - vt ? (J.bi_buf |= rt << J.bi_valid & 65535, z(J, J.bi_buf), J.bi_buf = rt >> y - J.bi_valid, J.bi_valid += vt - y) : (J.bi_buf |= rt << J.bi_valid & 65535, J.bi_valid += vt);
      }
      function Y(J, rt, vt) {
        V(J, vt[2 * rt], vt[2 * rt + 1]);
      }
      function ot(J, rt) {
        for (var vt = 0; vt |= 1 & J, J >>>= 1, vt <<= 1, 0 < --rt; ) ;
        return vt >>> 1;
      }
      function wt(J, rt, vt) {
        var At, ht, Ot = new Array(x + 1), $t = 0;
        for (At = 1; At <= x; At++) Ot[At] = $t = $t + vt[At - 1] << 1;
        for (ht = 0; ht <= rt; ht++) {
          var Ft = J[2 * ht + 1];
          Ft !== 0 && (J[2 * ht] = ot(Ot[Ft]++, Ft));
        }
      }
      function mt(J) {
        var rt;
        for (rt = 0; rt < p; rt++) J.dyn_ltree[2 * rt] = 0;
        for (rt = 0; rt < f; rt++) J.dyn_dtree[2 * rt] = 0;
        for (rt = 0; rt < m; rt++) J.bl_tree[2 * rt] = 0;
        J.dyn_ltree[2 * k] = 1, J.opt_len = J.static_len = 0, J.last_lit = J.matches = 0;
      }
      function xt(J) {
        8 < J.bi_valid ? z(J, J.bi_buf) : 0 < J.bi_valid && (J.pending_buf[J.pending++] = J.bi_buf), J.bi_buf = 0, J.bi_valid = 0;
      }
      function zt(J, rt, vt, At) {
        var ht = 2 * rt, Ot = 2 * vt;
        return J[ht] < J[Ot] || J[ht] === J[Ot] && At[rt] <= At[vt];
      }
      function Dt(J, rt, vt) {
        for (var At = J.heap[vt], ht = vt << 1; ht <= J.heap_len && (ht < J.heap_len && zt(rt, J.heap[ht + 1], J.heap[ht], J.depth) && ht++, !zt(rt, At, J.heap[ht], J.depth)); ) J.heap[vt] = J.heap[ht], vt = ht, ht <<= 1;
        J.heap[vt] = At;
      }
      function Jt(J, rt, vt) {
        var At, ht, Ot, $t, Ft = 0;
        if (J.last_lit !== 0) for (; At = J.pending_buf[J.d_buf + 2 * Ft] << 8 | J.pending_buf[J.d_buf + 2 * Ft + 1], ht = J.pending_buf[J.l_buf + Ft], Ft++, At === 0 ? Y(J, ht, rt) : (Y(J, (Ot = S[ht]) + d + 1, rt), ($t = T[Ot]) !== 0 && V(J, ht -= X[Ot], $t), Y(J, Ot = N(--At), vt), ($t = F[Ot]) !== 0 && V(J, At -= G[Ot], $t)), Ft < J.last_lit; ) ;
        Y(J, k, rt);
      }
      function Qt(J, rt) {
        var vt, At, ht, Ot = rt.dyn_tree, $t = rt.stat_desc.static_tree, Ft = rt.stat_desc.has_stree, Ut = rt.stat_desc.elems, ie = -1;
        for (J.heap_len = 0, J.heap_max = b, vt = 0; vt < Ut; vt++) Ot[2 * vt] !== 0 ? (J.heap[++J.heap_len] = ie = vt, J.depth[vt] = 0) : Ot[2 * vt + 1] = 0;
        for (; J.heap_len < 2; ) Ot[2 * (ht = J.heap[++J.heap_len] = ie < 2 ? ++ie : 0)] = 1, J.depth[ht] = 0, J.opt_len--, Ft && (J.static_len -= $t[2 * ht + 1]);
        for (rt.max_code = ie, vt = J.heap_len >> 1; 1 <= vt; vt--) Dt(J, Ot, vt);
        for (ht = Ut; vt = J.heap[1], J.heap[1] = J.heap[J.heap_len--], Dt(J, Ot, 1), At = J.heap[1], J.heap[--J.heap_max] = vt, J.heap[--J.heap_max] = At, Ot[2 * ht] = Ot[2 * vt] + Ot[2 * At], J.depth[ht] = (J.depth[vt] >= J.depth[At] ? J.depth[vt] : J.depth[At]) + 1, Ot[2 * vt + 1] = Ot[2 * At + 1] = ht, J.heap[1] = ht++, Dt(J, Ot, 1), 2 <= J.heap_len; ) ;
        J.heap[--J.heap_max] = J.heap[1], function(oe, ae) {
          var dt, kt, te, Rt, be, Kt, jt = ae.dyn_tree, ge = ae.max_code, we = ae.stat_desc.static_tree, Rn = ae.stat_desc.has_stree, Ze = ae.stat_desc.extra_bits, Dn = ae.stat_desc.extra_base, fn = ae.stat_desc.max_length, We = 0;
          for (Rt = 0; Rt <= x; Rt++) oe.bl_count[Rt] = 0;
          for (jt[2 * oe.heap[oe.heap_max] + 1] = 0, dt = oe.heap_max + 1; dt < b; dt++) fn < (Rt = jt[2 * jt[2 * (kt = oe.heap[dt]) + 1] + 1] + 1) && (Rt = fn, We++), jt[2 * kt + 1] = Rt, ge < kt || (oe.bl_count[Rt]++, be = 0, Dn <= kt && (be = Ze[kt - Dn]), Kt = jt[2 * kt], oe.opt_len += Kt * (Rt + be), Rn && (oe.static_len += Kt * (we[2 * kt + 1] + be)));
          if (We !== 0) {
            do {
              for (Rt = fn - 1; oe.bl_count[Rt] === 0; ) Rt--;
              oe.bl_count[Rt]--, oe.bl_count[Rt + 1] += 2, oe.bl_count[fn]--, We -= 2;
            } while (0 < We);
            for (Rt = fn; Rt !== 0; Rt--) for (kt = oe.bl_count[Rt]; kt !== 0; ) ge < (te = oe.heap[--dt]) || (jt[2 * te + 1] !== Rt && (oe.opt_len += (Rt - jt[2 * te + 1]) * jt[2 * te], jt[2 * te + 1] = Rt), kt--);
          }
        }(J, rt), wt(Ot, ie, J.bl_count);
      }
      function O(J, rt, vt) {
        var At, ht, Ot = -1, $t = rt[1], Ft = 0, Ut = 7, ie = 4;
        for ($t === 0 && (Ut = 138, ie = 3), rt[2 * (vt + 1) + 1] = 65535, At = 0; At <= vt; At++) ht = $t, $t = rt[2 * (At + 1) + 1], ++Ft < Ut && ht === $t || (Ft < ie ? J.bl_tree[2 * ht] += Ft : ht !== 0 ? (ht !== Ot && J.bl_tree[2 * ht]++, J.bl_tree[2 * C]++) : Ft <= 10 ? J.bl_tree[2 * E]++ : J.bl_tree[2 * q]++, Ot = ht, ie = (Ft = 0) === $t ? (Ut = 138, 3) : ht === $t ? (Ut = 6, 3) : (Ut = 7, 4));
      }
      function ct(J, rt, vt) {
        var At, ht, Ot = -1, $t = rt[1], Ft = 0, Ut = 7, ie = 4;
        for ($t === 0 && (Ut = 138, ie = 3), At = 0; At <= vt; At++) if (ht = $t, $t = rt[2 * (At + 1) + 1], !(++Ft < Ut && ht === $t)) {
          if (Ft < ie) for (; Y(J, ht, J.bl_tree), --Ft != 0; ) ;
          else ht !== 0 ? (ht !== Ot && (Y(J, ht, J.bl_tree), Ft--), Y(J, C, J.bl_tree), V(J, Ft - 3, 2)) : Ft <= 10 ? (Y(J, E, J.bl_tree), V(J, Ft - 3, 3)) : (Y(J, q, J.bl_tree), V(J, Ft - 11, 7));
          Ot = ht, ie = (Ft = 0) === $t ? (Ut = 138, 3) : ht === $t ? (Ut = 6, 3) : (Ut = 7, 4);
        }
      }
      l(G);
      var U = !1;
      function et(J, rt, vt, At) {
        V(J, (h << 1) + (At ? 1 : 0), 3), function(ht, Ot, $t, Ft) {
          xt(ht), z(ht, $t), z(ht, ~$t), s.arraySet(ht.pending_buf, ht.window, Ot, $t, ht.pending), ht.pending += $t;
        }(J, rt, vt);
      }
      r._tr_init = function(J) {
        U || (function() {
          var rt, vt, At, ht, Ot, $t = new Array(x + 1);
          for (ht = At = 0; ht < u - 1; ht++) for (X[ht] = At, rt = 0; rt < 1 << T[ht]; rt++) S[At++] = ht;
          for (S[At - 1] = ht, ht = Ot = 0; ht < 16; ht++) for (G[ht] = Ot, rt = 0; rt < 1 << F[ht]; rt++) I[Ot++] = ht;
          for (Ot >>= 7; ht < f; ht++) for (G[ht] = Ot << 7, rt = 0; rt < 1 << F[ht] - 7; rt++) I[256 + Ot++] = ht;
          for (vt = 0; vt <= x; vt++) $t[vt] = 0;
          for (rt = 0; rt <= 143; ) P[2 * rt + 1] = 8, rt++, $t[8]++;
          for (; rt <= 255; ) P[2 * rt + 1] = 9, rt++, $t[9]++;
          for (; rt <= 279; ) P[2 * rt + 1] = 7, rt++, $t[7]++;
          for (; rt <= 287; ) P[2 * rt + 1] = 8, rt++, $t[8]++;
          for (wt(P, p + 1, $t), rt = 0; rt < f; rt++) A[2 * rt + 1] = 5, A[2 * rt] = ot(rt, 5);
          H = new ft(P, T, d + 1, p, x), j = new ft(A, F, 0, f, x), Q = new ft(new Array(0), M, 0, m, v);
        }(), U = !0), J.l_desc = new nt(J.dyn_ltree, H), J.d_desc = new nt(J.dyn_dtree, j), J.bl_desc = new nt(J.bl_tree, Q), J.bi_buf = 0, J.bi_valid = 0, mt(J);
      }, r._tr_stored_block = et, r._tr_flush_block = function(J, rt, vt, At) {
        var ht, Ot, $t = 0;
        0 < J.level ? (J.strm.data_type === 2 && (J.strm.data_type = function(Ft) {
          var Ut, ie = 4093624447;
          for (Ut = 0; Ut <= 31; Ut++, ie >>>= 1) if (1 & ie && Ft.dyn_ltree[2 * Ut] !== 0) return o;
          if (Ft.dyn_ltree[18] !== 0 || Ft.dyn_ltree[20] !== 0 || Ft.dyn_ltree[26] !== 0) return a;
          for (Ut = 32; Ut < d; Ut++) if (Ft.dyn_ltree[2 * Ut] !== 0) return a;
          return o;
        }(J)), Qt(J, J.l_desc), Qt(J, J.d_desc), $t = function(Ft) {
          var Ut;
          for (O(Ft, Ft.dyn_ltree, Ft.l_desc.max_code), O(Ft, Ft.dyn_dtree, Ft.d_desc.max_code), Qt(Ft, Ft.bl_desc), Ut = m - 1; 3 <= Ut && Ft.bl_tree[2 * B[Ut] + 1] === 0; Ut--) ;
          return Ft.opt_len += 3 * (Ut + 1) + 5 + 5 + 4, Ut;
        }(J), ht = J.opt_len + 3 + 7 >>> 3, (Ot = J.static_len + 3 + 7 >>> 3) <= ht && (ht = Ot)) : ht = Ot = vt + 5, vt + 4 <= ht && rt !== -1 ? et(J, rt, vt, At) : J.strategy === 4 || Ot === ht ? (V(J, 2 + (At ? 1 : 0), 3), Jt(J, P, A)) : (V(J, 4 + (At ? 1 : 0), 3), function(Ft, Ut, ie, oe) {
          var ae;
          for (V(Ft, Ut - 257, 5), V(Ft, ie - 1, 5), V(Ft, oe - 4, 4), ae = 0; ae < oe; ae++) V(Ft, Ft.bl_tree[2 * B[ae] + 1], 3);
          ct(Ft, Ft.dyn_ltree, Ut - 1), ct(Ft, Ft.dyn_dtree, ie - 1);
        }(J, J.l_desc.max_code + 1, J.d_desc.max_code + 1, $t + 1), Jt(J, J.dyn_ltree, J.dyn_dtree)), mt(J), At && xt(J);
      }, r._tr_tally = function(J, rt, vt) {
        return J.pending_buf[J.d_buf + 2 * J.last_lit] = rt >>> 8 & 255, J.pending_buf[J.d_buf + 2 * J.last_lit + 1] = 255 & rt, J.pending_buf[J.l_buf + J.last_lit] = 255 & vt, J.last_lit++, rt === 0 ? J.dyn_ltree[2 * vt]++ : (J.matches++, rt--, J.dyn_ltree[2 * (S[vt] + d + 1)]++, J.dyn_dtree[2 * N(rt)]++), J.last_lit === J.lit_bufsize - 1;
      }, r._tr_align = function(J) {
        V(J, 2, 3), Y(J, k, P), function(rt) {
          rt.bi_valid === 16 ? (z(rt, rt.bi_buf), rt.bi_buf = 0, rt.bi_valid = 0) : 8 <= rt.bi_valid && (rt.pending_buf[rt.pending++] = 255 & rt.bi_buf, rt.bi_buf >>= 8, rt.bi_valid -= 8);
        }(J);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, r) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, r) {
      (function(s) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, h, u, d, p = 1, f = {}, m = !1, b = o.document, x = Object.getPrototypeOf && Object.getPrototypeOf(o);
            x = x && x.setTimeout ? x : o, l = {}.toString.call(o.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                v(C);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var C = !0, E = o.onmessage;
                return o.onmessage = function() {
                  C = !1;
                }, o.postMessage("", "*"), o.onmessage = E, C;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), function(C) {
              o.postMessage(d + C, "*");
            }) : o.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(C) {
              v(C.data);
            }, function(C) {
              u.port2.postMessage(C);
            }) : b && "onreadystatechange" in b.createElement("script") ? (h = b.documentElement, function(C) {
              var E = b.createElement("script");
              E.onreadystatechange = function() {
                v(C), E.onreadystatechange = null, h.removeChild(E), E = null;
              }, h.appendChild(E);
            }) : function(C) {
              setTimeout(v, 0, C);
            }, x.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var E = new Array(arguments.length - 1), q = 0; q < E.length; q++) E[q] = arguments[q + 1];
              var T = { callback: C, args: E };
              return f[p] = T, l(p), p++;
            }, x.clearImmediate = y;
          }
          function y(C) {
            delete f[C];
          }
          function v(C) {
            if (m) setTimeout(v, 0, C);
            else {
              var E = f[C];
              if (E) {
                m = !0;
                try {
                  (function(q) {
                    var T = q.callback, F = q.args;
                    switch (F.length) {
                      case 0:
                        T();
                        break;
                      case 1:
                        T(F[0]);
                        break;
                      case 2:
                        T(F[0], F[1]);
                        break;
                      case 3:
                        T(F[0], F[1], F[2]);
                        break;
                      default:
                        T.apply(a, F);
                    }
                  })(E);
                } finally {
                  y(C), m = !1;
                }
              }
            }
          }
          function k(C) {
            C.source === o && typeof C.data == "string" && C.data.indexOf(d) === 0 && v(+C.data.slice(d.length));
          }
        })(typeof self > "u" ? s === void 0 ? this : s : self);
      }).call(this, typeof ao < "u" ? ao : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jm);
var Uk = jm.exports;
const Wk = /* @__PURE__ */ Oc(Uk), Hk = {
  key: 0,
  class: "debug"
}, Gk = !1, Vk = /* @__PURE__ */ is({
  __name: "WordPress",
  setup(n) {
    const t = ["banding", "finish", "cutLength", "perPart", "rollLength", "surcharge", "machining", "stock", "custom"], e = (dt) => t.includes(dt), i = ho(() => import("./FormulaPricing-Uaqf0WV4.js")), r = ho(() => import("./ObjectViewer-CdAg69n5.js")), s = "production", o = {}, a = {};
    let l;
    const h = {
      banding: null,
      finish: null
    };
    let u = null, d = [], p = null, f = {};
    const m = Ae(!1), b = Ae("manual"), x = Ae(""), y = Ae([]), v = Ae(null), k = Ae(!0), C = Ae(null), E = Ae(null), q = Ae(!1), T = Ae(null), F = rn(() => window.smartcutConfig.settings.units ?? "decimal");
    T2("calculator", () => T.value);
    const M = (dt) => {
      m.value && console.log("SmartCut -", ...dt);
    }, B = (dt) => {
      console.error(`SmartCut - ${dt}`);
    }, P = (dt = !1) => {
      q.value = !0, ["checkout", "intro_text", "offcuts", "banding_key"].forEach((te) => {
        const Rt = o[te];
        Rt && (Rt.style.display = "block");
      }), ht() && (o.pricing_table.style.display = "table"), dt ? I(!0) : S(), j();
    }, A = (dt = !0, kt = !0) => {
      q.value = !1, ["checkout", "intro_text", "offcuts", "banding_key", "pricing_table"].forEach((Rt) => {
        const be = o[Rt];
        be && (be.style.display = "none");
      }), kt === !0 ? H() : kt === !1 && j(), dt ? I() : dt === !1 && S();
    }, I = (dt = !1) => {
      o.quantity.style.display = "inline-block", o.quantity.readOnly = dt;
    }, S = () => {
      q.value !== !1 && (o.quantity.value = "1", o.quantity.style.display = "none", o.quantity.readOnly = !0);
    }, X = (dt, kt) => {
      if (isNaN(kt)) throw new Error("Price must be a number");
      if (!e(dt)) return;
      const Rt = {
        custom: {
          visible: null,
          hidden: "smartcut-custom-price"
        },
        perPart: {
          hidden: "smartcut-per-part-price",
          visible: "per_part_price"
        },
        rollLength: {
          hidden: null,
          visible: "roll_length_price"
        },
        banding: {
          hidden: "smartcut-banding-price",
          visible: "banding_total_price"
        },
        finish: {
          hidden: "smartcut-finish-price",
          visible: "finish_total_price"
        },
        machining: {
          hidden: "smartcut-machining-price",
          visible: "machining_total_price"
        },
        surcharge: {
          hidden: "smartcut-cut-to-size-surcharge",
          visible: "surcharge_price"
        },
        cutLength: {
          hidden: "smartcut-cut-length-price",
          visible: "cut_length_price"
        },
        stock: {
          hidden: null,
          visible: "stock_total_price"
        }
      }[dt];
      Rt != null && Rt.hidden && a[Rt.hidden] && (a[Rt.hidden].value = kt), Rt != null && Rt.visible && o[Rt.visible] && (o[Rt.visible].innerText = mt(kt));
    }, H = () => {
      if (!o.cart_button) {
        B("Cart button not found");
        return;
      }
      o.cart_button.disabled = !1;
    }, j = () => {
      if (q.value !== !1) {
        if (!o.cart_button) {
          B("Cart button not found");
          return;
        }
        o.cart_button.disabled = !0;
      }
    }, Q = (dt, kt = 0) => {
      if (!o.quantity) {
        B("Quantity field not found when trying to set");
        return;
      }
      o.quantity.value = dt.toFixed(kt);
    }, G = (dt) => {
      M(["setting variation price", dt]);
      const kt = document.querySelector(".woocommerce-variation-price .smartcut-price-selector");
      kt && (kt.innerText = mt(dt)), v.value.display_price = dt;
    }, ft = () => {
      if (!(window != null && window.smartcutConfig)) {
        B("SmartCut config not found");
        return;
      }
      const dt = window.smartcutConfig;
      l = dt.settings;
      const kt = Jt(pn(window, ["smartcutConfig", "banding_data"])), te = Jt(pn(window, ["smartcutConfig", "finish_data"])), Rt = {
        debug: l.debug,
        units: l.units,
        locale: dt.locale,
        decimalPlaces: 2,
        //saw
        stockType: l.stock_type,
        bladeWidth: l.blade_width,
        cutPreference: l.cut_preference,
        stackHeight: l.stack_height,
        stockSelection: l.stock_selection,
        stockGrain: l.stock_grain,
        minSpacing: l.min_spacing,
        maxParts: l.max_parts ?? null,
        orientationModel: l.orientation_model,
        minDimension: l.min_dimension,
        enable: {
          banding: !l.disable_banding,
          finish: !l.disable_finish,
          orientation: !l.disable_orientation,
          diagram: !l.hide_diagram,
          focus: !0,
          machining: l.enable_machining,
          csvImport: l.enable_import,
          click: !0,
          partName: !l.disable_part_name,
          progressNumber: l.pricing_strategy !== "part_area",
          imageUpload: l.enable_image_upload
        },
        colors: {
          partA: (l == null ? void 0 : l.part_a_color) ?? "#1d9bc4",
          partB: (l == null ? void 0 : l.part_b_color) ?? "#065d7a",
          partHover: (l == null ? void 0 : l.part_hover_color) ?? "#f8b029",
          partSelected: (l == null ? void 0 : l.part_selected_color) ?? "#5bc85b",
          stock: (l == null ? void 0 : l.stock_color) ?? "#ffd166",
          button: (l == null ? void 0 : l.button_color) ?? "#118ab2",
          buttonText: (l == null ? void 0 : l.button_text_color) ?? "#ffffff",
          text: (l == null ? void 0 : l.text_color) ?? "#ffffff"
        }
      };
      m.value = Rt.debug;
      const be = {
        units: "decimal",
        faces: {
          enabled: l.machining_sides
        },
        holes: {
          enabled: l.machining_holes,
          defaultDiameter: l.machining_holes_default_diameter,
          diameters: l.machining_holes_diameters.split(",").map((jt) => jt.trim()).filter(Boolean),
          minDiameter: l.machining_holes_min_diameter,
          maxDiameter: l.machining_holes_max_diameter,
          enableDepth: l.machining_holes_depth,
          depths: l.machining_holes_depths.split(",").map((jt) => jt.trim()).filter(Boolean),
          defaultDepth: l.machining_holes_default_depth,
          minDepth: l.machining_holes_min_depth,
          maxDepth: l.machining_holes_max_depth
        },
        hingeHoles: {
          enabled: l.machining_hinge_holes,
          minimumHoleDistance: l.machining_hinge_holes_minimum_hole_distance,
          defaultDistanceFromEdge: l.machining_hinge_holes_default_distance_from_edge,
          defaultOuterSpacing: l.machining_hinge_holes_default_outer_spacing,
          defaultHingeLength: l.machining_hinge_holes_default_hinge_length
        },
        corners: {
          enabled: l.machining_radius_corners || l.machining_bevel_corners,
          types: [
            l.machining_radius_corners ? "radius" : null,
            l.machining_bevel_corners ? "bevel" : null
          ].filter(Boolean),
          minValue: l.machining_corners_min_value,
          maxValue: l.machining_corners_max_value,
          enableBanding: l.machining_corners_enable_banding
        }
      };
      k.value = J(), k.value ? I(!0) : S(), u.type === "variable" ? A(!1, !1) : P(k.value);
      const Kt = {
        type: u.type,
        stock: y.value,
        variations: d ?? null,
        options: Rt,
        banding: kt,
        finish: te,
        machining: be
      };
      Qr(() => {
        T.value && T.value.init(Kt);
      }), Kt.type === "variable" && (M(["setting variable product form listeners"]), jQuery(function(jt) {
        jt(".variations_form").on("reset_data", () => A(!1, !1)).on("found_variation", (ge, we) => Ut(ge, we));
      }));
    }, nt = (dt) => {
      const kt = (dt == null ? void 0 : dt.multiple_sizes) === !0;
      u = {
        type: dt == null ? void 0 : dt.product_type,
        multiple_sizes: kt,
        size: dt != null && dt.size ? dt.size.split(" | ") : [],
        l: !kt && (dt != null && dt.l) ? parseFloat(dt.l) : null,
        w: !kt && (dt != null && dt.w) ? parseFloat(dt.w) : null,
        t: (dt == null ? void 0 : dt.t) ?? null,
        price: parseFloat(dt == null ? void 0 : dt.price) ?? null,
        stock_name: dt.stock_name
      }, u.multiple_sizes || (u.l || B("product 'length' attribute not available"), u.w || B("product 'width' attribute not available"));
    }, N = (dt) => {
      b.value = pn(window, ["smartcutConfig", "settings", "enable_formula"]) === !0 ? "formula" : "manual", x.value = pn(window, ["smartcutConfig", "settings", "formula_url"]), M([`Input type: ${b.value}`]), M([`Input type: ${b.value}`]), f = {
        thousands_separator: dt == null ? void 0 : dt.thousands_separator,
        decimal_separator: dt == null ? void 0 : dt.decimal_separator,
        number_of_decimals: dt == null ? void 0 : dt.number_of_decimals,
        currency_symbol: dt == null ? void 0 : dt.currency_symbol,
        currency_position: dt == null ? void 0 : dt.currency_position
      };
    }, z = () => {
      const dt = {
        checkout: "#smartcut-app",
        intro_text: "#smartcut-intro-text",
        pricing_table: "#smartcut-pricing-table",
        offcuts: "#include_offcuts_field",
        banding_key: "#smartcut-banding-key",
        finish_key: "#smartcut-finish-key",
        banding_total_price: "#smartcut-banding-total bdi .smartcut-price-selector",
        finish_total_price: "#smartcut-finish-total bdi .smartcut-price-selector",
        cut_length_price: "#smartcut-cut-length-total bdi .smartcut-price-selector",
        per_part_price: "#smartcut-per-part-total bdi .smartcut-price-selector",
        roll_length_price: "#smartcut-roll-length-total bdi .smartcut-price-selector",
        surcharge_price: "#smartcut-surcharge-total bdi .smartcut-price-selector",
        machining_total_price: "#smartcut-machining-total bdi .smartcut-price-selector",
        stock_total_price: "#smartcut-stock-total bdi .smartcut-price-selector",
        quantity: ".smartcut-stock-quantity",
        //this is the add to cart quantity element(s)
        cart_button: ".single_add_to_cart_button"
      };
      for (const [kt, te] of Object.entries(dt))
        o[kt] = document.querySelector(te);
      if (!o.checkout)
        return B("checkout iframe not found");
      if (!o.quantity)
        return B("quantity field not found");
      if (!o.cart_button)
        return B("cart button not found");
      o.quantity.readOnly = !0, j();
    }, V = () => ({
      x1: l.stock_trim_x1 ?? 0,
      x2: l.stock_trim_x2 ?? 0,
      y1: l.stock_type === "linear" ? 0 : l.stock_trim_y1 ?? 0,
      y2: l.stock_type === "linear" ? 0 : l.stock_trim_y2 ?? 0
    }), Y = (dt = null, kt = null, te = null, Rt = null, be = null) => {
      let Kt;
      if (be && typeof be == "object") {
        Kt = [];
        for (const [ge, we] of Object.entries(be))
          ge !== "attribute_size" && ge !== "attribute_thickness" && Kt.push(`${ge.replace("attribute_", "")}: ${we}`);
        Kt = Kt.join(" - ");
      }
      return {
        name: u.stock_name,
        type: l.stock_type,
        l: dt,
        w: kt,
        t: te,
        grain: l.stock_grain,
        cost: parseFloat((Rt == null ? void 0 : Rt.toString()) || "0"),
        trim: V(),
        allowExactFitShapes: !0,
        notes: Kt
      };
    }, ot = () => {
      u != null && u.stock_name || B("product name not specified"), y.value = [], u.multiple_sizes ? u.size.forEach((dt) => {
        const [kt, te] = dt.split("x"), Rt = Y(
          parseFloat(kt),
          parseFloat(te),
          u == null ? void 0 : u.t,
          dt.price
        );
        y.value.push(Rt);
      }) : y.value.push(Y(
        u.l,
        u.w,
        u == null ? void 0 : u.t,
        u == null ? void 0 : u.price
      ));
    }, wt = (dt, kt) => {
      const te = dt.split(".");
      return te[0] = te[0].replace(/\B(?=(\d{3})+(?!\d))/g, kt), te.join(".");
    }, mt = (dt = 0, kt = "") => {
      if (!dt)
        return kt ? zt("0.00") : "0.00";
      typeof dt == "string" && (dt = parseFloat(dt));
      const te = dt.toFixed(f.number_of_decimals).replace(".", f.decimal_separator), Rt = wt(te, f.thousands_separator);
      return kt ? zt(Rt) : Rt;
    }, xt = (dt) => {
      if (dt == null) return "";
      typeof dt == "string" && (dt = parseFloat(dt));
      const te = dt % 1 !== 0 ? f.number_of_decimals : 0, Rt = dt.toFixed(te).replace(".", f.decimal_separator);
      return wt(Rt, f.thousands_separator);
    }, zt = (dt) => {
      switch (f.currency_position) {
        case "left":
          return `${f.currency_symbol}${dt}`;
        case "right":
          return `${dt}${f.currency_symbol}`;
        default:
          return `${f.currency_symbol}${dt}`;
      }
    }, Dt = (dt) => {
      const kt = (te) => b1($l(te), 100).replace("|", "_");
      return Array.isArray(dt) ? dt.map(kt).join(",") : kt(dt);
    }, Jt = (dt) => {
      if (!dt) return null;
      const kt = {
        labels: [],
        pricing: {}
      }, te = Object.values(dt);
      for (const Rt of te)
        Rt != null && Rt.variations ? (kt.labels.push(...Object.keys(Rt.options)), Object.values(Rt.variations).forEach((be) => {
          const { options: Kt } = be, jt = Object.values(Kt).map((ge) => Dt(ge)).join("|");
          kt.pricing[jt] = parseInt(be.price);
        })) : Rt != null && Rt.options && Object.keys(Rt.options).forEach((be) => {
          kt.pricing[Dt(be)] = parseInt(Rt.price);
        });
      return kt.labels.length || kt.labels.push("type"), kt;
    }, Qt = (dt, kt) => {
      if (!kt.length || !ac(h, [dt])) return null;
      const te = pn(h, [dt]);
      if (!ko(te)) return null;
      const be = Object.values(te).map((Kt) => Kt != null && Kt.variations ? Object.values(Kt.variations).map((jt) => (jt.type = "variable", jt)) : (Kt.type = "simple", Kt)).flat().find((Kt) => {
        let jt;
        return Kt.type === "simple" ? jt = Object.keys(Kt.options) : jt = Object.values(Kt.options), jt ? jt.every((ge, we) => Dt(ge) === Dt(kt[we])) : !1;
      });
      return be != null && be.price ? parseFloat(be.price) : null;
    }, O = (dt) => {
      let kt = 0;
      if (typeof dt == "object") {
        for (let [te, Rt] of Object.entries(dt)) {
          typeof Rt == "string" && (Rt = parseFloat(Rt));
          const be = te.split("|"), Kt = Qt("finish", be);
          if (Kt === null) continue;
          const ge = Number(Rt) / 1e6 * parseFloat(Kt.toString());
          kt += ge;
        }
        if ("min_finish_charge" in l) {
          const te = parseFloat(l == null ? void 0 : l.min_finish_charge);
          if (te > 0 && kt > 0 && kt < te)
            return te;
        }
      }
      return kt;
    }, ct = (dt) => {
      let kt = 0;
      if (typeof dt == "object") {
        for (let [te, Rt] of Object.entries(dt)) {
          typeof Rt == "string" && (Rt = parseFloat(Rt));
          const be = te.split("|"), Kt = Qt("banding", be);
          if (Kt === null) continue;
          const jt = Rt / (l.units === "fraction" ? 12 : 1e3) * parseFloat(Kt.toString());
          kt += jt;
        }
        if ("min_banding_charge" in l) {
          const te = parseFloat(l == null ? void 0 : l.min_banding_charge);
          if (te > 0 && kt > 0 && kt < te)
            return te;
        }
      }
      return kt;
    }, U = (dt) => (p.holes ?? 0) * (dt.metadata.numHoles ?? 0) + (p.corners ?? 0) * (dt.metadata.numCorners ?? 0), et = () => {
      o.quantity.value = "1", j(), a["smartcut-cut-to-size-surcharge"].value = 0;
      for (const dt of t) X(dt, 0);
      for (const dt in a)
        dt !== "smartcut-hardware-price" && (a[dt].value = null);
    }, J = () => {
      var dt;
      if (((dt = window.smartcutConfig) == null ? void 0 : dt.product_type) === "variable")
        return !1;
      switch (l.pricing_strategy) {
        case "full_stock":
        case "part_area":
        case "full_stock_plus_cut_length":
        case "full_stock_plus_num_parts":
          return !0;
        case "roll_length":
        case "cut_length":
          return !1;
        default:
          return !1;
      }
    }, rt = (dt) => {
      if (ac(l, ["enable", dt]) && pn(l, ["enable", dt]) === !1)
        return !1;
      const kt = pn(h, [dt]);
      return !!(kt && Object.values(kt).length);
    }, vt = () => l.enable_machining === !0, At = () => !((l == null ? void 0 : l.surcharge_type) === "none" || !(l != null && l.surcharge) || l.surcharge === "0.00"), ht = () => !!(l.pricing_strategy === "full_stock_plus_cut_length" || l.pricing_strategy === "full_stock_plus_num_parts" || l.pricing_strategy === "roll_length" || At() || rt("banding") || rt("finish") || vt()), Ot = (dt) => {
      var te;
      let kt = (te = dt == null ? void 0 : dt.attributes) == null ? void 0 : te.attribute_size;
      return kt || (kt = u == null ? void 0 : u.size), kt;
    }, $t = (dt) => /\d+x\d+/.test(dt), Ft = () => {
      window.smartcutConfig.input_fields.forEach((dt) => {
        const kt = dt.replaceAll("_", "-");
        a[kt] = document.getElementById(kt);
      });
    }, Ut = (dt, kt) => {
      et(), v.value = kt, M(["variation selected", kt.attributes]), y.value = [];
      const te = pn(kt, ["attributes", "attribute_thickness"]);
      if (u.selected_thickness = te, u.multiple_sizes) {
        const Rt = Ot(kt);
        if (M([`variation found with size: ${Rt} & thickness: ${te}`]), !Rt)
          return A(!1), B("The size of this multiple size product could not be found");
        if (Array.isArray(Rt) ? P(!1) : $t(Rt) ? A(!0, !0) : P(!1), d != null && d.length && te) {
          let be;
          if (Array.isArray(Rt)) {
            const Kt = d.find((jt) => jt.attributes.thickness === te);
            if (!Kt)
              return B(`variation not found for thickness ${te}`);
            be = Rt.map((jt) => ({
              size: jt,
              l: jt.split("x")[0],
              w: jt.split("x")[1],
              t: te,
              price: Kt == null ? void 0 : Kt.price
            }));
          } else
            be = d.filter((Kt) => {
              var jt, ge;
              return /\d+x\d+/.test((jt = Kt == null ? void 0 : Kt.attributes) == null ? void 0 : jt.size) ? te === ((ge = Kt == null ? void 0 : Kt.attributes) == null ? void 0 : ge.thickness) : !1;
            }).map((Kt) => {
              var we, Rn, Ze, Dn;
              const jt = d.find((fn) => {
                var We, ke;
                return te === ((We = fn == null ? void 0 : fn.attributes) == null ? void 0 : We.thickness) && Rt === ((ke = fn == null ? void 0 : fn.attributes) == null ? void 0 : ke.size);
              });
              jt || B(`exactMatchVariation not found for thickness ${te}, size: ${Rt} in variations`);
              let ge = !(jt != null && jt.price) || parseFloat(jt.price) === 0 ? (Kt == null ? void 0 : Kt.price) ?? "0" : jt == null ? void 0 : jt.price;
              return M([
                `size attribute: '${(we = Kt == null ? void 0 : Kt.attributes) == null ? void 0 : we.size}'`,
                `price for 'thickness ${te}, size: ${Rt}' detected as ${ge}`
              ]), {
                size: (Rn = Kt == null ? void 0 : Kt.attributes) == null ? void 0 : Rn.size,
                l: (Ze = Kt == null ? void 0 : Kt.attributes) == null ? void 0 : Ze.size.split("x")[0],
                w: (Dn = Kt == null ? void 0 : Kt.attributes) == null ? void 0 : Dn.size.split("x")[1],
                t: u.selected_thickness,
                price: ge
              };
            });
          q.value === !0 && be.forEach((Kt) => {
            const jt = Y(
              Kt.l,
              Kt.w,
              Kt.t,
              Kt.price,
              kt == null ? void 0 : kt.attributes
            );
            y.value.push(jt);
          });
        }
      } else {
        const Rt = d.find((be) => be.attributes.thickness === te);
        if (!Rt) return B(`variation not found for thickness ${te}`);
        y.value.push(Y(
          u.l,
          u.w,
          te,
          Rt.price,
          kt == null ? void 0 : kt.attributes
        )), P(!1);
      }
    }, ie = async (dt) => {
      var be, Kt;
      et();
      let kt = 0;
      const te = J();
      if (te || Q(1), M(["result event received", dt]), !(dt != null && dt.jobId)) return;
      switch (E.value = ma(dt.metadata), l.pricing_strategy) {
        case "full_stock": {
          M(["calculating cost by full sheet"]), te ? Q(dt.metadata.totalUsedStock) : kt = parseFloat(dt.metadata.totalStockCost), H();
          break;
        }
        case "part_area": {
          M(["calculating cost by part area in meters / sq feet"]);
          const jt = l.units === "fraction" ? dt.metadata.totalPartArea / 144 : dt.metadata.totalPartArea / 1e6;
          M([`part area in square ${l.units === "fraction" ? "feet" : "meters"}`, jt]), te ? Q(jt, 2) : (M([`totalPrice is area: ${jt} * price: ${v.value.display_price}`]), kt = jt * parseFloat(v.value.display_price)), H();
          break;
        }
        case "cut_length": {
          M(["calculating cost by cut length in feet / meters"]);
          const jt = dt.metadata.totalCutLength / (l.units === "fraction" ? 12 : 1e3);
          Q(jt, 2), H();
          break;
        }
        case "full_stock_plus_cut_length": {
          M(["calculating cost by full sheet plus cut length"]), te ? o.quantity.value = dt.metadata.totalUsedStock : kt = parseFloat(dt.metadata.totalStockCost);
          const ge = dt.metadata.totalCutLength / (l.units === "fraction" ? 12 : 1e3) * l.cut_length_price;
          X("cutLength", ge), kt += ge, H();
          break;
        }
        case "full_stock_plus_num_parts": {
          if (M(["calculating cost by full sheet plus number of parts"]), te)
            o.quantity.value = dt.metadata.totalUsedStock;
          else {
            const ge = parseFloat(dt.metadata.totalStockCost);
            X("stock", ge), kt = ge;
          }
          const jt = dt.metadata.totalPartsProduced * l.per_part_price;
          X("perPart", jt), kt += jt, H();
          break;
        }
        case "roll_length": {
          M(["calculating cost by roll length"]);
          const jt = dt.stock.reduce((ge, we) => {
            const Rn = we.analysis.rollLength / (l.units === "fraction" ? 12 : 1e3) * we.cost;
            return ge + Rn;
          }, 0);
          X("rollLength", jt), kt += jt, H();
          break;
        }
      }
      if (!te) {
        if (!dt.metadata.totalStockCost)
          return B("Total stock cost not returned for a multiple size product");
        M([`total cost is ${kt}`]), X("custom", kt);
      }
      if (rt("banding") && ((be = dt == null ? void 0 : dt.metadata) != null && be.bandingLengthByType)) {
        const jt = ct(dt.metadata.bandingLengthByType);
        X("banding", jt), kt += jt;
      }
      if (rt("finish") && ((Kt = dt == null ? void 0 : dt.metadata) != null && Kt.bandingLengthByType)) {
        const jt = O(dt.metadata.finishAreaByType);
        X("finish", jt), kt += jt;
      }
      if (b.value === "formula") {
        const jt = parseFloat(a["smartcut-hardware-price"].value);
        isNaN(jt) || (kt += jt);
      }
      if (vt()) {
        const jt = U(dt);
        X("machining", jt), kt += jt;
      }
      if (At() && (l != null && l.surcharge)) {
        let jt = 0;
        (l == null ? void 0 : l.surcharge_type) === "per_sheet" ? jt = parseFloat(l == null ? void 0 : l.surcharge) * parseFloat(dt.metadata.totalUsedStock) : jt = parseFloat(l == null ? void 0 : l.surcharge), X("surcharge", jt), M(["added surcharge", jt]), kt += jt;
      }
      v.value && G(kt);
      const Rt = {
        "smartcut-job-id": dt == null ? void 0 : dt.jobId,
        "smartcut-dimensions": dt == null ? void 0 : dt.parts.map((jt) => `${jt == null ? void 0 : jt.l}x${jt == null ? void 0 : jt.w} [${jt == null ? void 0 : jt.q}]`).join(", "),
        "smartcut-total-cut-length": dt.metadata.totalCutLength,
        "smartcut-part-area": dt.metadata.totalPartArea,
        "smartcut-total-cuts": dt.metadata.totalCuts,
        "smartcut-total-parts": dt.metadata.totalPartsProduced,
        "smartcut-machining": dt.metadata.hasMachining
      };
      if (Object.entries(Rt).forEach(([jt, ge]) => {
        a != null && a[jt] && (a[jt].value = ge);
      }), a != null && a["smartcut-stock-summary"]) {
        const jt = dt.stock.map((ge) => `${ge == null ? void 0 : ge.l}x${ge == null ? void 0 : ge.w}${ge != null && ge.t ? "x" + ge.t : ""} [${ge == null ? void 0 : ge.q}]`).join(", ");
        a["smartcut-stock-summary"].value = jt;
      }
      await oe(dt);
    }, oe = async (dt) => {
      const te = ew(dt, C.value, xt).split(",")[1], Rt = new Wk();
      Rt.file("order-summary.pdf", te);
      const be = await Rt.generateAsync({ type: "blob" }), Kt = new File([be], "order-summary.zip", { type: "application/zip" }), jt = a["smartcut-order-summary"].closest("form");
      if (!jt) return;
      const ge = new DataTransfer();
      ge.items.add(Kt);
      const we = jt.querySelector('[name="smartcut_order_summary"]');
      we instanceof HTMLInputElement && (we.files = ge.files);
    }, ae = (dt, kt) => {
      j(), C.value = ma(dt), a["smartcut-hardware-price"].value = kt;
    };
    return No(() => {
      console.log("💥 Powered by https://smartcut.dev", window.smartcutConfig.version), M(["Launching WordPress checkout..."]), h.banding = pn(window, ["smartcutConfig", "banding_data"]), h.finish = pn(window, ["smartcutConfig", "finish_data"]), p = pn(window, ["smartcutConfig", "machining_pricing"]), d = pn(window, ["smartcutConfig", "variations"]), z(), Ft(), nt(window.smartcutConfig), N(window.smartcutConfig), ft(), ot(), [
        "div.quantity > input.plus",
        "div.quantity > input.minus",
        "div.quantity .qty-plus",
        "div.quantity .qty-minus"
      ].forEach((te) => {
        const Rt = document.querySelector(te);
        Rt && (Rt.style.display = "none");
      });
      const kt = new CustomEvent("smartcut/ready");
      window.dispatchEvent(kt), M(["Wordpress checkout ready"]);
    }), (dt, kt) => (ee(), he(Qn, null, [
      Pe(s) === "development" && Gk ? (ee(), he("div", Hk, [
        kt[0] || (kt[0] = me("div", null, "WP - developer information", -1)),
        Cn(Pe(r), {
          data: [Pe(u)],
          paths: ["product"]
        }, null, 8, ["data"]),
        Cn(Pe(r), {
          data: [y.value],
          paths: ["stock"]
        }, null, 8, ["data"]),
        Cn(Pe(r), {
          data: [h],
          paths: ["extrasData"]
        }, null, 8, ["data"])
      ])) : Ne("", !0),
      b.value === "formula" && x.value ? (ee(), Wn(Pe(i), {
        key: 1,
        ref: "formulapricing",
        units: F.value,
        "format-price": mt,
        url: x.value,
        debug: m.value,
        onHardwareResult: ae,
        onPanelResult: j
      }, null, 8, ["units", "url", "debug"])) : Ne("", !0),
      b.value === "manual" || b.value === "formula" && x.value ? (ee(), Wn($k, {
        key: 2,
        ref_key: "calculator",
        ref: T,
        readonly: b.value === "formula",
        debug: m.value,
        stock: y.value,
        "find-extras-price": Qt,
        "format-price": mt,
        units: F.value,
        onLog: M,
        onError: B,
        onResult: ie,
        onInputsChanged: j
      }, null, 8, ["readonly", "debug", "stock", "units"])) : Ne("", !0)
    ], 64));
  }
}), Yk = /* @__PURE__ */ is({
  __name: "Launch",
  props: {
    type: { default: "" }
  },
  setup(n) {
    const t = ho(() => import("./Vanilla-r_cpjfCQ.js")), e = {
      wordpress: Vk,
      vanilla: t
    }, i = n, r = rn(() => {
      const s = i.type.toLowerCase();
      return e[s] || null;
    });
    return (s, o) => (ee(), Wn(F2(r.value), { ref: "checkout" }, null, 512));
  }
}), tA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: Yk }, Symbol.toStringTag, { value: "Module" }));
export {
  $k as C,
  wl as I,
  tA as L,
  Ea as _,
  ao as a,
  en as b,
  ac as c,
  Oc as d,
  Re as e,
  ne as f,
  pn as g,
  gr as h,
  d1 as i,
  Zk as j,
  h1 as k,
  Yg as l,
  Qk as m,
  h6 as n,
  Yy as o,
  Mm as r,
  Dm as s,
  sf as u,
  qt as v
};
