var k2 = Object.defineProperty;
var A2 = (n, t, e) => t in n ? k2(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var et = (n, t, e) => A2(n, typeof t != "symbol" ? t + "" : t, e);
import { i as N2, u as Oe, o as Us, n as dr, r as _e, a as C2, w as Qi, g as P2, b as L2, c as I2, s as lo, d as ga, e as bp, f as es, m as gl, h as E2, j as Qt, k as le, F as Qn, l as Lr, p as di, q as Dn, t as ye, v as hn, x as Xg, y as Jg, z as O2, A as ke, B as Rr, C as Re, D as _c, E as va, G as Zg, H as Ml, I as Un, J as Zn, K as T2, L as po, M as F2, N as M2 } from "./main-8aQ3tJEo.js";
let _u;
const R2 = new Uint8Array(16);
function D2() {
  if (!_u && (_u = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !_u))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return _u(R2);
}
const Kn = [];
for (let n = 0; n < 256; ++n)
  Kn.push((n + 256).toString(16).slice(1));
function B2(n, t = 0) {
  return Kn[n[t + 0]] + Kn[n[t + 1]] + Kn[n[t + 2]] + Kn[n[t + 3]] + "-" + Kn[n[t + 4]] + Kn[n[t + 5]] + "-" + Kn[n[t + 6]] + Kn[n[t + 7]] + "-" + Kn[n[t + 8]] + Kn[n[t + 9]] + "-" + Kn[n[t + 10]] + Kn[n[t + 11]] + Kn[n[t + 12]] + Kn[n[t + 13]] + Kn[n[t + 14]] + Kn[n[t + 15]];
}
const j2 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vp = {
  randomUUID: j2
};
function Qg(n, t, e) {
  if (vp.randomUUID && !t && !n)
    return vp.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || D2)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, B2(i);
}
const fa = 1e-10, q2 = 10, z2 = Number.MAX_SAFE_INTEGER, $2 = 4294967295, Jn = (n) => typeof n == "number" && Number.isFinite(n), zu = (n) => Array.isArray(n) && n.length > 0;
function al(n, t, e = fa) {
  if (n === t) return 0;
  if (Number.isInteger(n) && Number.isInteger(t))
    return n > t ? 1 : -1;
  const i = n - t;
  return Math.abs(i) < e ? 0 : i;
}
const U2 = {
  greaterThan: (n, t, e = fa) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) > 0,
  greaterThanOrEqualTo: (n, t, e = fa) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) >= 0,
  lessThan: (n, t, e = fa) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) < 0,
  lessThanOrEqualTo: (n, t, e = fa) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) <= 0,
  equalTo: (n, t, e = fa) => !Jn(n) || !Jn(t) ? !1 : al(n, t, e) === 0
};
function W2(n) {
  return Jn(n) ? Number.isInteger(n) ? n : Number(n.toFixed(q2)) : !1;
}
function H2(n) {
  if (!Jn(n) || n < 0 || n > z2)
    throw new Error("Invalid length parameter");
  return Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / ($2 + 1) * n);
}
function G2(n, t) {
  if (!zu(n))
    throw new Error("Invalid array parameter");
  if (!Jn(t) || t < 0 || t > n.length)
    throw new Error("Invalid size parameter");
  const e = n.slice(), i = n.length - t;
  for (let r = n.length - 1; r >= i; r--) {
    const s = Math.floor(Math.random() * (r + 1));
    [e[r], e[s]] = [e[s], e[r]];
  }
  return e.slice(i);
}
class Su {
  static calculateMean(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    return t.reduce((e, i) => e + i, 0) / t.length;
  }
  static calculateStandardDeviation(t, e = null) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const i = e ?? this.calculateMean(t), r = t.reduce((s, o) => {
      const a = o - i;
      return s + a * a;
    }, 0) / t.length;
    return Math.sqrt(r);
  }
  static calculateCoefficientOfVariation(t) {
    if (!zu(t))
      throw new Error("Invalid input array");
    const e = this.calculateMean(t);
    if (e === 0)
      throw new Error("Mean is zero, coefficient of variation undefined");
    return this.calculateStandardDeviation(t, e) / e;
  }
}
const Ve = {
  ...U2,
  isNumber: Jn,
  round: W2,
  getRandom: H2,
  getRandomSample: G2,
  calculateStandardDeviation: Su.calculateStandardDeviation.bind(Su),
  calculateCoefficientOfVariation: Su.calculateCoefficientOfVariation.bind(Su)
}, Ju = {
  //sort by width then length - use .sort(sortHeightDescWidthDesc)
  WDLD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
  },
  WALA(n, t) {
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
    if (n.l === t.l) return 0;
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
  },
  //sort by length d then width d
  LDWD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
  },
  LAWA(n, t) {
    if (n.l > t.l) return 1;
    if (n.l < t.l) return -1;
    if (n.w === t.w) return 0;
    if (n.w > t.w) return 1;
    if (n.w < t.w) return -1;
  },
  //sort by width d
  WD(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    if (n.w === t.w) return 0;
  },
  LD(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    if (n.l === t.l) return 0;
  },
  LDIDA(n, t) {
    if (n.l < t.l) return 1;
    if (n.l > t.l) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  WDIDA(n, t) {
    if (n.w < t.w) return 1;
    if (n.w > t.w) return -1;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  //sort by proportion
  /* sortProportion: function(a, b) {
  
  		if (a.proportion < b.proportion) return 1;
  		if (a.proportion > b.proportion) return -1;
  
  		if (a.proportion === b.proportion) return a.index - b.index;
  
  	} */
  //area descending
  AD(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
  },
  AA(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) return 0;
  },
  AAID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return -1;
    if (e > i) return 1;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  ADID(n, t) {
    const e = n.getArea(), i = t.getArea();
    if (e < i) return 1;
    if (e > i) return -1;
    if (e === i) return 0;
    if (e === i) {
      const r = n.id.toString().split("."), s = t.id.toString().split(".");
      return r[0] !== s[0] ? parseInt(r[0]) - parseInt(s[0]) : parseInt(r[1]) - parseInt(s[1]);
    }
    return 0;
  },
  //by id ascending
  ID(n, t) {
    if (!n.id || !t.id) return 0;
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  IDDesc(n, t) {
    const e = n.id.toString().split("."), i = t.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(i[0]) - parseInt(e[0]) : parseInt(i[1]) - parseInt(e[1]);
  },
  StockID(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : parseInt(e[1]) - parseInt(i[1]);
  },
  StockIDAD(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    const r = n.getArea(), s = t.getArea();
    if (r < s) return 1;
    if (r > s) return -1;
  },
  parentID(n, t) {
    return n.parentID - t.parentID;
  },
  YX(n, t) {
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
    if (n.y === t.y) return 0;
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
  },
  XY(n, t) {
    if (n.x < t.x) return -1;
    if (n.x > t.x) return 1;
    if (n.x === t.x) return 0;
    if (n.y < t.y) return -1;
    if (n.y > t.y) return 1;
  },
  subset(n, t) {
    if (n.totalLength < t.totalLength) return 1;
    if (n.totalLength > t.totalLength) return -1;
    if (n.area === t.area) return 0;
    if (n.area < t.area) return 1;
    if (n.area > t.area) return -1;
  },
  placementOrder(n, t) {
    return (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  typePlacementOrder(n, t) {
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  stockIDTypePlacementOrder(n, t) {
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    if (e[0] !== i[0])
      return parseInt(e[0]) - parseInt(i[0]);
    if (e[1] !== i[1])
      return parseInt(e[1]) - parseInt(i[1]);
    if (n.offcut && !t.offcut) return 1;
    if (!n.offcut && t.offcut) return 0;
    if (n.offcut === t.offcut) return n.placementOrder - t.placementOrder;
  },
  offcutPlacementOrder(n, t) {
    var r, s;
    if (!((r = n == null ? void 0 : n.stock) != null && r.id) || !((s = t == null ? void 0 : t.stock) != null && s.id)) return 0;
    const e = n.stock.id.toString().split("."), i = t.stock.id.toString().split(".");
    return e[0] !== i[0] ? parseInt(e[0]) - parseInt(i[0]) : e[1] !== i[1] ? parseInt(e[1]) - parseInt(i[1]) : (n == null ? void 0 : n.placementOrder) - (t == null ? void 0 : t.placementOrder);
  },
  groupPlacementOrder(n, t) {
    if (n.placementOrder > t.placementOrder) return 1;
    if (n.placementOrder < t.placementOrder) return -1;
    if (n.groupPlacementOrder === t.groupPlacementOrder) return 0;
    if (n.groupPlacementOrder > t.groupPlacementOrder) return 1;
    if (n.groupPlacementOrder < t.groupPlacementOrder) return -1;
  },
  swapFirstTwo(n) {
    const t = n[1];
    n[1] = n[0], n[0] = t;
  },
  //Fisher-Yates shuffle
  shuffle(n) {
    for (let t = n.length - 1; t > 0; t--) {
      const e = Math.floor(Math.random() * (t + 1));
      [n[t], n[e]] = [n[e], n[t]];
    }
  },
  /**
      * generator function which accepts a dimension to cater for shape rotation lock
      */
  fillThenArea(n) {
    return function(t, e) {
      return t.getLongSide(n) > e.getLongSide(n) ? -1 : t.getLongSide(n) < e.getLongSide(n) ? 1 : t.getArea() > e.getArea() ? -1 : t.getArea() < e.getArea() ? 1 : 0;
    };
  },
  aspect(n, t) {
    const e = n.getAspect(), i = t.getAspect();
    return e > i ? -1 : e < i ? 1 : 0;
  }
};
function V2(n) {
  if (n === "l") return "x";
  if (n === "w") return "y";
}
function So(n) {
  return n ? n === "l" ? "w" : "l" : null;
}
function Y2(n) {
  return n ? n === "x" ? "y" : "x" : null;
}
class ma {
  constructor(t) {
    et(this, "x1");
    et(this, "x2");
    et(this, "y1");
    et(this, "y2");
    et(this, "dimension");
    et(this, "direction");
    et(this, "shapeCollisions");
    et(this, "origin");
    et(this, "type");
    this.x1 = t.x1, this.x2 = t.x2, this.y1 = t.y1, this.y2 = t.y2, this.dimension = K2(this), this.direction = X2(this), this.type = t != null && t.type ? t.type : null, this.origin = t != null && t.origin ? t.origin : null;
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
}
function Ps(n, t, e, i, r = null, s = null) {
  return new ma({ x1: n, y1: t, x2: e, y2: i, origin: r, type: s });
}
function K2(n) {
  return typeof n > "u" || !Ve.isNumber(n.x1) || !Ve.isNumber(n.x2) || !Ve.isNumber(n.y1) || !Ve.isNumber(n.y2) ? null : n.x1 === n.x2 && n.y1 !== n.y2 ? "w" : n.y1 === n.y2 && n.x1 !== n.x2 ? "l" : null;
}
function X2(n) {
  return typeof n > "u" || !Ve.isNumber(n.x1) || !Ve.isNumber(n.x2) || !Ve.isNumber(n.y1) || !Ve.isNumber(n.y2) ? null : n.x1 < n.x2 ? "lr" : n.x1 > n.x2 ? "rl" : n.y1 < n.y2 ? "bt" : n.y1 > n.y2 ? "tb" : null;
}
function J2(n, t) {
  const e = n.getCorners(), i = {};
  return e.bottomLeft.x > 0 && e.bottomLeft.y > 0 && (i.bottomLeftDown = Ps(
    e.bottomLeft.x,
    e.bottomLeft.y,
    e.bottomLeft.x,
    0,
    "bottomLeft",
    "bottomLeftDown"
  ), i.bottomLeftLeft = Ps(
    e.bottomLeft.x,
    e.bottomLeft.y,
    0,
    e.bottomLeft.y,
    "bottomLeft",
    "bottomLeftLeft"
  )), e.topLeft.x > 0 && e.topLeft.y < t.w && (i.topLeftLeft = Ps(
    e.topLeft.x,
    e.topLeft.y,
    0,
    e.topLeft.y,
    "topLeft",
    "topLeftLeft"
  ), i.topLeftTop = Ps(
    e.topLeft.x,
    e.topLeft.y,
    e.topLeft.x,
    t.w,
    "topLeft",
    "topLeftTop"
  )), e.topRight.y < t.w && e.topRight.x < t.l && (i.topRightTop = Ps(
    e.topRight.x,
    e.topRight.y,
    e.topRight.x,
    t.w,
    "topRight",
    "topRightTop"
  ), i.topRightRight = Ps(
    e.topRight.x,
    e.topRight.y,
    t.l,
    e.topRight.y,
    "topRight",
    "topRightRight"
  )), e.bottomRight.x < t.l && e.bottomRight.y > 0 && (i.bottomRightRight = Ps(
    e.bottomRight.x,
    e.bottomRight.y,
    t.l,
    e.bottomRight.y,
    "bottomRight",
    "bottomRightRight"
  ), i.bottomRightDown = Ps(
    e.bottomRight.x,
    e.bottomRight.y,
    e.bottomRight.x,
    0,
    "bottomRight",
    "bottomRightDown"
  )), i;
}
var t0 = Object.defineProperty, Z2 = Object.getOwnPropertyNames, It = (n, t) => t0(n, "name", { value: t, configurable: !0 }), Q2 = (n, t) => function() {
  return t || (0, n[Z2(n)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Tf = (n, t) => {
  for (var e in t)
    t0(n, e, { get: t[e], enumerable: !0 });
}, ty = Q2({
  "(disabled):util"() {
  }
}), Zu = {};
Tf(Zu, {
  addChainableMethod: () => Hf,
  addLengthGuard: () => Bl,
  addMethod: () => $f,
  addProperty: () => zf,
  checkError: () => Mi,
  compareByInspect: () => nc,
  eql: () => C0,
  expectTypes: () => a0,
  flag: () => Me,
  getActual: () => kc,
  getMessage: () => Rf,
  getName: () => Nc,
  getOperator: () => Kf,
  getOwnEnumerableProperties: () => Yf,
  getOwnEnumerablePropertySymbols: () => Vf,
  getPathInfo: () => qf,
  hasProperty: () => Ac,
  inspect: () => Ge,
  isNaN: () => ic,
  isNumeric: () => Hn,
  isProxyEnabled: () => Dl,
  isRegExp: () => rc,
  objDisplay: () => go,
  overwriteChainableMethod: () => Gf,
  overwriteMethod: () => Wf,
  overwriteProperty: () => Uf,
  proxify: () => Ca,
  test: () => Ff,
  transferFlags: () => br,
  type: () => sn
});
var Mi = {};
Tf(Mi, {
  compatibleConstructor: () => i0,
  compatibleInstance: () => n0,
  compatibleMessage: () => r0,
  getConstructorName: () => s0,
  getMessage: () => o0
});
function Sc(n) {
  return n instanceof Error || Object.prototype.toString.call(n) === "[object Error]";
}
It(Sc, "isErrorInstance");
function e0(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
It(e0, "isRegExp");
function n0(n, t) {
  return Sc(t) && n === t;
}
It(n0, "compatibleInstance");
function i0(n, t) {
  return Sc(t) ? n.constructor === t.constructor || n instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? n.constructor === t || n instanceof t : !1;
}
It(i0, "compatibleConstructor");
function r0(n, t) {
  const e = typeof n == "string" ? n : n.message;
  return e0(t) ? t.test(e) : typeof t == "string" ? e.indexOf(t) !== -1 : !1;
}
It(r0, "compatibleMessage");
function s0(n) {
  let t = n;
  return Sc(n) ? t = n.constructor.name : typeof n == "function" && (t = n.name, t === "" && (t = new n().name || t)), t;
}
It(s0, "getConstructorName");
function o0(n) {
  let t = "";
  return n && n.message ? t = n.message : typeof n == "string" && (t = n), t;
}
It(o0, "getMessage");
function Me(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    i[t] = e;
  else
    return i[t];
}
It(Me, "flag");
function Ff(n, t) {
  var e = Me(n, "negate"), i = t[0];
  return e ? !i : i;
}
It(Ff, "test");
function sn(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
It(sn, "type");
var ey = "captureStackTrace" in Error, _o, Ke = (_o = class extends Error {
  constructor(e = "Unspecified AssertionError", i, r) {
    super(e);
    et(this, "message");
    this.message = e, ey && Error.captureStackTrace(this, r || _o);
    for (const s in i)
      s in this || (this[s] = i[s]);
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  toJSON(e) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: e !== !1 ? this.stack : void 0
    };
  }
}, It(_o, "AssertionError"), _o);
function a0(n, t) {
  var e = Me(n, "message"), i = Me(n, "ssfi");
  e = e ? e + ": " : "", n = Me(n, "object"), t = t.map(function(o) {
    return o.toLowerCase();
  }), t.sort();
  var r = t.map(function(o, a) {
    var l = ~["a", "e", "i", "o", "u"].indexOf(o.charAt(0)) ? "an" : "a", h = t.length > 1 && a === t.length - 1 ? "or " : "";
    return h + l + " " + o;
  }).join(", "), s = sn(n).toLowerCase();
  if (!t.some(function(o) {
    return s === o;
  }))
    throw new Ke(
      e + "object tested must be " + r + ", but " + s + " given",
      void 0,
      i
    );
}
It(a0, "expectTypes");
function kc(n, t) {
  return t.length > 4 ? t[4] : n._obj;
}
It(kc, "getActual");
var wp = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, ny = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, xa = "…";
function l0(n, t) {
  const e = wp[ny[t]] || wp[t] || "";
  return e ? `\x1B[${e[0]}m${String(n)}\x1B[${e[1]}m` : String(n);
}
It(l0, "colorise");
function u0({
  showHidden: n = !1,
  depth: t = 2,
  colors: e = !1,
  customInspect: i = !0,
  showProxy: r = !1,
  maxArrayLength: s = 1 / 0,
  breakLength: o = 1 / 0,
  seen: a = [],
  // eslint-disable-next-line no-shadow
  truncate: l = 1 / 0,
  stylize: h = String
} = {}, u) {
  const d = {
    showHidden: !!n,
    depth: Number(t),
    colors: !!e,
    customInspect: !!i,
    showProxy: !!r,
    maxArrayLength: Number(s),
    breakLength: Number(o),
    truncate: Number(l),
    seen: a,
    inspect: u,
    stylize: h
  };
  return d.colors && (d.stylize = l0), d;
}
It(u0, "normaliseOptions");
function c0(n) {
  return n >= "\uD800" && n <= "\uDBFF";
}
It(c0, "isHighSurrogate");
function ss(n, t, e = xa) {
  n = String(n);
  const i = e.length, r = n.length;
  if (i > t && r > i)
    return e;
  if (r > t && r > i) {
    let s = t - i;
    return s > 0 && c0(n[s - 1]) && (s = s - 1), `${n.slice(0, s)}${e}`;
  }
  return n;
}
It(ss, "truncate");
function tr(n, t, e, i = ", ") {
  e = e || t.inspect;
  const r = n.length;
  if (r === 0)
    return "";
  const s = t.truncate;
  let o = "", a = "", l = "";
  for (let h = 0; h < r; h += 1) {
    const u = h + 1 === n.length, d = h + 2 === n.length;
    l = `${xa}(${n.length - h})`;
    const p = n[h];
    t.truncate = s - o.length - (u ? 0 : i.length);
    const f = a || e(p, t) + (u ? "" : i), g = o.length + f.length, y = g + l.length;
    if (u && g > s && o.length + l.length <= s || !u && !d && y > s || (a = u ? "" : e(n[h + 1], t) + (d ? "" : i), !u && d && y > s && g + a.length > s))
      break;
    if (o += f, !u && !d && g + a.length >= s) {
      l = `${xa}(${n.length - h - 1})`;
      break;
    }
    l = "";
  }
  return `${o}${l}`;
}
It(tr, "inspectList");
function h0(n) {
  return n.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? n : JSON.stringify(n).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
It(h0, "quoteComplexKey");
function _a([n, t], e) {
  return e.truncate -= 2, typeof n == "string" ? n = h0(n) : typeof n != "number" && (n = `[${e.inspect(n, e)}]`), e.truncate -= n.length, t = e.inspect(t, e), `${n}: ${t}`;
}
It(_a, "inspectProperty");
function f0(n, t) {
  const e = Object.keys(n).slice(n.length);
  if (!n.length && !e.length)
    return "[]";
  t.truncate -= 4;
  const i = tr(n, t);
  t.truncate -= i.length;
  let r = "";
  return e.length && (r = tr(e.map((s) => [s, n[s]]), t, _a)), `[ ${i}${r ? `, ${r}` : ""} ]`;
}
It(f0, "inspectArray");
var iy = /* @__PURE__ */ It((n) => typeof Buffer == "function" && n instanceof Buffer ? "Buffer" : n[Symbol.toStringTag] ? n[Symbol.toStringTag] : n.constructor.name, "getArrayName");
function Nr(n, t) {
  const e = iy(n);
  t.truncate -= e.length + 4;
  const i = Object.keys(n).slice(n.length);
  if (!n.length && !i.length)
    return `${e}[]`;
  let r = "";
  for (let o = 0; o < n.length; o++) {
    const a = `${t.stylize(ss(n[o], t.truncate), "number")}${o === n.length - 1 ? "" : ", "}`;
    if (t.truncate -= a.length, n[o] !== n.length && t.truncate <= 3) {
      r += `${xa}(${n.length - n[o] + 1})`;
      break;
    }
    r += a;
  }
  let s = "";
  return i.length && (s = tr(i.map((o) => [o, n[o]]), t, _a)), `${e}[ ${r}${s ? `, ${s}` : ""} ]`;
}
It(Nr, "inspectTypedArray");
function d0(n, t) {
  const e = n.toJSON();
  if (e === null)
    return "Invalid Date";
  const i = e.split("T"), r = i[0];
  return t.stylize(`${r}T${ss(i[1], t.truncate - r.length - 1)}`, "date");
}
It(d0, "inspectDate");
function zh(n, t) {
  const e = n[Symbol.toStringTag] || "Function", i = n.name;
  return i ? t.stylize(`[${e} ${ss(i, t.truncate - 11)}]`, "special") : t.stylize(`[${e}]`, "special");
}
It(zh, "inspectFunction");
function p0([n, t], e) {
  return e.truncate -= 4, n = e.inspect(n, e), e.truncate -= n.length, t = e.inspect(t, e), `${n} => ${t}`;
}
It(p0, "inspectMapEntry");
function g0(n) {
  const t = [];
  return n.forEach((e, i) => {
    t.push([i, e]);
  }), t;
}
It(g0, "mapToEntries");
function m0(n, t) {
  return n.size - 1 <= 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${tr(g0(n), t, p0)} }`);
}
It(m0, "inspectMap");
var ry = Number.isNaN || ((n) => n !== n);
function $h(n, t) {
  return ry(n) ? t.stylize("NaN", "number") : n === 1 / 0 ? t.stylize("Infinity", "number") : n === -1 / 0 ? t.stylize("-Infinity", "number") : n === 0 ? t.stylize(1 / n === 1 / 0 ? "+0" : "-0", "number") : t.stylize(ss(String(n), t.truncate), "number");
}
It($h, "inspectNumber");
function Uh(n, t) {
  let e = ss(n.toString(), t.truncate - 1);
  return e !== xa && (e += "n"), t.stylize(e, "bigint");
}
It(Uh, "inspectBigInt");
function y0(n, t) {
  const e = n.toString().split("/")[2], i = t.truncate - (2 + e.length), r = n.source;
  return t.stylize(`/${ss(r, i)}/${e}`, "regexp");
}
It(y0, "inspectRegExp");
function b0(n) {
  const t = [];
  return n.forEach((e) => {
    t.push(e);
  }), t;
}
It(b0, "arrayFromSet");
function v0(n, t) {
  return n.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${tr(b0(n), t)} }`);
}
It(v0, "inspectSet");
var xp = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), sy = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, oy = 16, ay = 4;
function w0(n) {
  return sy[n] || `\\u${`0000${n.charCodeAt(0).toString(oy)}`.slice(-ay)}`;
}
It(w0, "escape");
function Wh(n, t) {
  return xp.test(n) && (n = n.replace(xp, w0)), t.stylize(`'${ss(n, t.truncate - 2)}'`, "string");
}
It(Wh, "inspectString");
function Hh(n) {
  return "description" in Symbol.prototype ? n.description ? `Symbol(${n.description})` : "Symbol()" : n.toString();
}
It(Hh, "inspectSymbol");
var x0 = /* @__PURE__ */ It(() => "Promise{…}", "getPromiseValue");
try {
  const { getPromiseDetails: n, kPending: t, kRejected: e } = process.binding("util");
  Array.isArray(n(Promise.resolve())) && (x0 = /* @__PURE__ */ It((i, r) => {
    const [s, o] = n(i);
    return s === t ? "Promise{<pending>}" : `Promise${s === e ? "!" : ""}{${r.inspect(o, r)}}`;
  }, "getPromiseValue"));
} catch {
}
var ly = x0;
function xl(n, t) {
  const e = Object.getOwnPropertyNames(n), i = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n) : [];
  if (e.length === 0 && i.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const r = tr(e.map((a) => [a, n[a]]), t, _a), s = tr(i.map((a) => [a, n[a]]), t, _a);
  t.seen.pop();
  let o = "";
  return r && s && (o = ", "), `{ ${r}${o}${s} }`;
}
It(xl, "inspectObject");
var yh = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function _0(n, t) {
  let e = "";
  return yh && yh in n && (e = n[yh]), e = e || n.constructor.name, (!e || e === "_class") && (e = "<Anonymous Class>"), t.truncate -= e.length, `${e}${xl(n, t)}`;
}
It(_0, "inspectClass");
function S0(n, t) {
  return n.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${tr(n, t)} ]`);
}
It(S0, "inspectArguments");
var uy = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function k0(n, t) {
  const e = Object.getOwnPropertyNames(n).filter((o) => uy.indexOf(o) === -1), i = n.name;
  t.truncate -= i.length;
  let r = "";
  if (typeof n.message == "string" ? r = ss(n.message, t.truncate) : e.unshift("message"), r = r ? `: ${r}` : "", t.truncate -= r.length + 5, t.seen = t.seen || [], t.seen.includes(n))
    return "[Circular]";
  t.seen.push(n);
  const s = tr(e.map((o) => [o, n[o]]), t, _a);
  return `${i}${r}${s ? ` { ${s} }` : ""}`;
}
It(k0, "inspectObject");
function A0([n, t], e) {
  return e.truncate -= 3, t ? `${e.stylize(String(n), "yellow")}=${e.stylize(`"${t}"`, "string")}` : `${e.stylize(String(n), "yellow")}`;
}
It(A0, "inspectAttribute");
function Qu(n, t) {
  return tr(n, t, Mf, `
`);
}
It(Qu, "inspectHTMLCollection");
function Mf(n, t) {
  const e = n.getAttributeNames(), i = n.tagName.toLowerCase(), r = t.stylize(`<${i}`, "special"), s = t.stylize(">", "special"), o = t.stylize(`</${i}>`, "special");
  t.truncate -= i.length * 2 + 5;
  let a = "";
  e.length > 0 && (a += " ", a += tr(e.map((u) => [u, n.getAttribute(u)]), t, A0, " ")), t.truncate -= a.length;
  const l = t.truncate;
  let h = Qu(n.children, t);
  return h && h.length > l && (h = `${xa}(${n.children.length})`), `${r}${a}${s}${h}${o}`;
}
It(Mf, "inspectHTML");
var cy = typeof Symbol == "function" && typeof Symbol.for == "function", bh = cy ? Symbol.for("chai/inspect") : "@@chai/inspect", ya = !1;
try {
  const n = ty();
  ya = n.inspect ? n.inspect.custom : !1;
} catch {
  ya = !1;
}
var _p = /* @__PURE__ */ new WeakMap(), Sp = {}, kp = {
  undefined: (n, t) => t.stylize("undefined", "undefined"),
  null: (n, t) => t.stylize("null", "null"),
  boolean: (n, t) => t.stylize(String(n), "boolean"),
  Boolean: (n, t) => t.stylize(String(n), "boolean"),
  number: $h,
  Number: $h,
  bigint: Uh,
  BigInt: Uh,
  string: Wh,
  String: Wh,
  function: zh,
  Function: zh,
  symbol: Hh,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: Hh,
  Array: f0,
  Date: d0,
  Map: m0,
  Set: v0,
  RegExp: y0,
  Promise: ly,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (n, t) => t.stylize("WeakSet{…}", "special"),
  WeakMap: (n, t) => t.stylize("WeakMap{…}", "special"),
  Arguments: S0,
  Int8Array: Nr,
  Uint8Array: Nr,
  Uint8ClampedArray: Nr,
  Int16Array: Nr,
  Uint16Array: Nr,
  Int32Array: Nr,
  Uint32Array: Nr,
  Float32Array: Nr,
  Float64Array: Nr,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: k0,
  HTMLCollection: Qu,
  NodeList: Qu
}, hy = /* @__PURE__ */ It((n, t, e) => bh in n && typeof n[bh] == "function" ? n[bh](t) : ya && ya in n && typeof n[ya] == "function" ? n[ya](t.depth, t) : "inspect" in n && typeof n.inspect == "function" ? n.inspect(t.depth, t) : "constructor" in n && _p.has(n.constructor) ? _p.get(n.constructor)(n, t) : Sp[e] ? Sp[e](n, t) : "", "inspectCustom"), fy = Object.prototype.toString;
function tc(n, t = {}) {
  const e = u0(t, tc), { customInspect: i } = e;
  let r = n === null ? "null" : typeof n;
  if (r === "object" && (r = fy.call(n).slice(8, -1)), r in kp)
    return kp[r](n, e);
  if (i && n) {
    const o = hy(n, e, r);
    if (o)
      return typeof o == "string" ? o : tc(o, e);
  }
  const s = n ? Object.getPrototypeOf(n) : !1;
  return s === Object.prototype || s === null ? xl(n, e) : n && typeof HTMLElement == "function" && n instanceof HTMLElement ? Mf(n, e) : "constructor" in n ? n.constructor !== Object ? _0(n, e) : xl(n, e) : n === Object(n) ? xl(n, e) : e.stylize(String(n), r);
}
It(tc, "inspect");
var pi = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function Ge(n, t, e, i) {
  var r = {
    colors: i,
    depth: typeof e > "u" ? 2 : e,
    showHidden: t,
    truncate: pi.truncateThreshold ? pi.truncateThreshold : 1 / 0
  };
  return tc(n, r);
}
It(Ge, "inspect");
function go(n) {
  var t = Ge(n), e = Object.prototype.toString.call(n);
  if (pi.truncateThreshold && t.length >= pi.truncateThreshold) {
    if (e === "[object Function]")
      return !n.name || n.name === "" ? "[Function]" : "[Function: " + n.name + "]";
    if (e === "[object Array]")
      return "[ Array(" + n.length + ") ]";
    if (e === "[object Object]") {
      var i = Object.keys(n), r = i.length > 2 ? i.splice(0, 2).join(", ") + ", ..." : i.join(", ");
      return "{ Object (" + r + ") }";
    } else
      return t;
  } else
    return t;
}
It(go, "objDisplay");
function Rf(n, t) {
  var e = Me(n, "negate"), i = Me(n, "object"), r = t[3], s = kc(n, t), o = e ? t[2] : t[1], a = Me(n, "message");
  return typeof o == "function" && (o = o()), o = o || "", o = o.replace(/#\{this\}/g, function() {
    return go(i);
  }).replace(/#\{act\}/g, function() {
    return go(s);
  }).replace(/#\{exp\}/g, function() {
    return go(r);
  }), a ? a + ": " + o : o;
}
It(Rf, "getMessage");
function br(n, t, e) {
  var i = n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), e = arguments.length === 3 ? e : !0;
  for (var r in i)
    (e || r !== "object" && r !== "ssfi" && r !== "lockSsfi" && r != "message") && (t.__flags[r] = i[r]);
}
It(br, "transferFlags");
function Gh(n) {
  if (typeof n > "u")
    return "undefined";
  if (n === null)
    return "null";
  const t = n[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(n).slice(8, -1);
}
It(Gh, "type");
function Df() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
It(Df, "FakeMap");
Df.prototype = {
  get: /* @__PURE__ */ It(function(t) {
    return t[this._key];
  }, "get"),
  set: /* @__PURE__ */ It(function(t, e) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: e,
      configurable: !0
    });
  }, "set")
};
var N0 = typeof WeakMap == "function" ? WeakMap : Df;
function Vh(n, t, e) {
  if (!e || ko(n) || ko(t))
    return null;
  var i = e.get(n);
  if (i) {
    var r = i.get(t);
    if (typeof r == "boolean")
      return r;
  }
  return null;
}
It(Vh, "memoizeCompare");
function ml(n, t, e, i) {
  if (!(!e || ko(n) || ko(t))) {
    var r = e.get(n);
    r ? r.set(t, i) : (r = new N0(), r.set(t, i), e.set(n, r));
  }
}
It(ml, "memoizeSet");
var C0 = Rl;
function Rl(n, t, e) {
  if (e && e.comparator)
    return Yh(n, t, e);
  var i = Bf(n, t);
  return i !== null ? i : Yh(n, t, e);
}
It(Rl, "deepEqual");
function Bf(n, t) {
  return n === t ? n !== 0 || 1 / n === 1 / t : n !== n && // eslint-disable-line no-self-compare
  t !== t ? !0 : ko(n) || ko(t) ? !1 : null;
}
It(Bf, "simpleEqual");
function Yh(n, t, e) {
  e = e || {}, e.memoize = e.memoize === !1 ? !1 : e.memoize || new N0();
  var i = e && e.comparator, r = Vh(n, t, e.memoize);
  if (r !== null)
    return r;
  var s = Vh(t, n, e.memoize);
  if (s !== null)
    return s;
  if (i) {
    var o = i(n, t);
    if (o === !1 || o === !0)
      return ml(n, t, e.memoize, o), o;
    var a = Bf(n, t);
    if (a !== null)
      return a;
  }
  var l = Gh(n);
  if (l !== Gh(t))
    return ml(n, t, e.memoize, !1), !1;
  ml(n, t, e.memoize, !0);
  var h = P0(n, t, l, e);
  return ml(n, t, e.memoize, h), h;
}
It(Yh, "extensiveDeepEqual");
function P0(n, t, e, i) {
  switch (e) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return Rl(n.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return n === t;
    case "Error":
      return jf(n, t, ["name", "message", "code"], i);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Rs(n, t, i);
    case "RegExp":
      return L0(n, t);
    case "Generator":
      return I0(n, t, i);
    case "DataView":
      return Rs(new Uint8Array(n.buffer), new Uint8Array(t.buffer), i);
    case "ArrayBuffer":
      return Rs(new Uint8Array(n), new Uint8Array(t), i);
    case "Set":
      return Kh(n, t, i);
    case "Map":
      return Kh(n, t, i);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return n.equals(t);
    case "Temporal.Duration":
      return n.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return n.toString() === t.toString();
    default:
      return O0(n, t, i);
  }
}
It(P0, "extensiveDeepEqualByType");
function L0(n, t) {
  return n.toString() === t.toString();
}
It(L0, "regexpEqual");
function Kh(n, t, e) {
  try {
    if (n.size !== t.size)
      return !1;
    if (n.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var i = [], r = [];
  return n.forEach(/* @__PURE__ */ It(function(o, a) {
    i.push([o, a]);
  }, "gatherEntries")), t.forEach(/* @__PURE__ */ It(function(o, a) {
    r.push([o, a]);
  }, "gatherEntries")), Rs(i.sort(), r.sort(), e);
}
It(Kh, "entriesEqual");
function Rs(n, t, e) {
  var i = n.length;
  if (i !== t.length)
    return !1;
  if (i === 0)
    return !0;
  for (var r = -1; ++r < i; )
    if (Rl(n[r], t[r], e) === !1)
      return !1;
  return !0;
}
It(Rs, "iterableEqual");
function I0(n, t, e) {
  return Rs(ec(n), ec(t), e);
}
It(I0, "generatorEqual");
function E0(n) {
  return typeof Symbol < "u" && typeof n == "object" && typeof Symbol.iterator < "u" && typeof n[Symbol.iterator] == "function";
}
It(E0, "hasIteratorFunction");
function Xh(n) {
  if (E0(n))
    try {
      return ec(n[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
It(Xh, "getIteratorEntries");
function ec(n) {
  for (var t = n.next(), e = [t.value]; t.done === !1; )
    t = n.next(), e.push(t.value);
  return e;
}
It(ec, "getGeneratorEntries");
function Jh(n) {
  var t = [];
  for (var e in n)
    t.push(e);
  return t;
}
It(Jh, "getEnumerableKeys");
function Zh(n) {
  for (var t = [], e = Object.getOwnPropertySymbols(n), i = 0; i < e.length; i += 1) {
    var r = e[i];
    Object.getOwnPropertyDescriptor(n, r).enumerable && t.push(r);
  }
  return t;
}
It(Zh, "getEnumerableSymbols");
function jf(n, t, e, i) {
  var r = e.length;
  if (r === 0)
    return !0;
  for (var s = 0; s < r; s += 1)
    if (Rl(n[e[s]], t[e[s]], i) === !1)
      return !1;
  return !0;
}
It(jf, "keysEqual");
function O0(n, t, e) {
  var i = Jh(n), r = Jh(t), s = Zh(n), o = Zh(t);
  if (i = i.concat(s), r = r.concat(o), i.length && i.length === r.length)
    return Rs(Qh(i).sort(), Qh(r).sort()) === !1 ? !1 : jf(n, t, i, e);
  var a = Xh(n), l = Xh(t);
  return a.length && a.length === l.length ? (a.sort(), l.sort(), Rs(a, l, e)) : i.length === 0 && a.length === 0 && r.length === 0 && l.length === 0;
}
It(O0, "objectEqual");
function ko(n) {
  return n === null || typeof n != "object";
}
It(ko, "isPrimitive");
function Qh(n) {
  return n.map(/* @__PURE__ */ It(function(e) {
    return typeof e == "symbol" ? e.toString() : e;
  }, "mapSymbol"));
}
It(Qh, "mapSymbols");
function Ac(n, t) {
  return typeof n > "u" || n === null ? !1 : t in Object(n);
}
It(Ac, "hasProperty");
function T0(n) {
  return n.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((i) => {
    if (i === "constructor" || i === "__proto__" || i === "prototype")
      return {};
    const s = /^\[(\d+)\]$/.exec(i);
    let o = null;
    return s ? o = { i: parseFloat(s[1]) } : o = { p: i.replace(/\\([.[\]])/g, "$1") }, o;
  });
}
It(T0, "parsePath");
function tf(n, t, e) {
  let i = n, r = null;
  e = typeof e > "u" ? t.length : e;
  for (let s = 0; s < e; s++) {
    const o = t[s];
    i && (typeof o.p > "u" ? i = i[o.i] : i = i[o.p], s === e - 1 && (r = i));
  }
  return r;
}
It(tf, "internalGetPathValue");
function qf(n, t) {
  const e = T0(t), i = e[e.length - 1], r = {
    parent: e.length > 1 ? tf(n, e, e.length - 1) : n,
    name: i.p || i.i,
    value: tf(n, e)
  };
  return r.exists = Ac(r.parent, r.name), r;
}
It(qf, "getPathInfo");
function lt(n, t, e, i) {
  return Me(this, "ssfi", e || lt), Me(this, "lockSsfi", i), Me(this, "object", n), Me(this, "message", t), Me(this, "eql", pi.deepEqual || C0), Ca(this);
}
It(lt, "Assertion");
Object.defineProperty(lt, "includeStack", {
  get: function() {
    return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), pi.includeStack;
  },
  set: function(n) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), pi.includeStack = n;
  }
});
Object.defineProperty(lt, "showDiff", {
  get: function() {
    return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), pi.showDiff;
  },
  set: function(n) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), pi.showDiff = n;
  }
});
lt.addProperty = function(n, t) {
  zf(this.prototype, n, t);
};
lt.addMethod = function(n, t) {
  $f(this.prototype, n, t);
};
lt.addChainableMethod = function(n, t, e) {
  Hf(this.prototype, n, t, e);
};
lt.overwriteProperty = function(n, t) {
  Uf(this.prototype, n, t);
};
lt.overwriteMethod = function(n, t) {
  Wf(this.prototype, n, t);
};
lt.overwriteChainableMethod = function(n, t, e) {
  Gf(this.prototype, n, t, e);
};
lt.prototype.assert = function(n, t, e, i, r, s) {
  var o = Ff(this, arguments);
  if (s !== !1 && (s = !0), i === void 0 && r === void 0 && (s = !1), pi.showDiff !== !0 && (s = !1), !o) {
    t = Rf(this, arguments);
    var a = kc(this, arguments), l = {
      actual: a,
      expected: i,
      showDiff: s
    }, h = Kf(this, arguments);
    throw h && (l.operator = h), new Ke(
      t,
      l,
      pi.includeStack ? this.assert : Me(this, "ssfi")
    );
  }
};
Object.defineProperty(
  lt.prototype,
  "_obj",
  {
    get: function() {
      return Me(this, "object");
    },
    set: function(n) {
      Me(this, "object", n);
    }
  }
);
function Dl() {
  return pi.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
It(Dl, "isProxyEnabled");
function zf(n, t, e) {
  e = e === void 0 ? function() {
  } : e, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ It(function i() {
        !Dl() && !Me(this, "lockSsfi") && Me(this, "ssfi", i);
        var r = e.call(this);
        if (r !== void 0)
          return r;
        var s = new lt();
        return br(this, s), s;
      }, "propertyGetter"),
      configurable: !0
    }
  );
}
It(zf, "addProperty");
var dy = Object.getOwnPropertyDescriptor(function() {
}, "length");
function Bl(n, t, e) {
  return dy.configurable && Object.defineProperty(n, "length", {
    get: function() {
      throw Error(e ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".');
    }
  }), n;
}
It(Bl, "addLengthGuard");
function F0(n) {
  var t = Object.getOwnPropertyNames(n);
  function e(r) {
    t.indexOf(r) === -1 && t.push(r);
  }
  It(e, "addProperty");
  for (var i = Object.getPrototypeOf(n); i !== null; )
    Object.getOwnPropertyNames(i).forEach(e), i = Object.getPrototypeOf(i);
  return t;
}
It(F0, "getProperties");
var Ap = ["__flags", "__methods", "_obj", "assert"];
function Ca(n, t) {
  return Dl() ? new Proxy(n, {
    get: /* @__PURE__ */ It(function e(i, r) {
      if (typeof r == "string" && pi.proxyExcludedKeys.indexOf(r) === -1 && !Reflect.has(i, r)) {
        if (t)
          throw Error("Invalid Chai property: " + t + "." + r + '. See docs for proper usage of "' + t + '".');
        var s = null, o = 4;
        throw F0(i).forEach(function(a) {
          if (!Object.prototype.hasOwnProperty(a) && Ap.indexOf(a) === -1) {
            var l = M0(
              r,
              a,
              o
            );
            l < o && (s = a, o = l);
          }
        }), Error(s !== null ? "Invalid Chai property: " + r + '. Did you mean "' + s + '"?' : "Invalid Chai property: " + r);
      }
      return Ap.indexOf(r) === -1 && !Me(i, "lockSsfi") && Me(i, "ssfi", e), Reflect.get(i, r);
    }, "proxyGetter")
  }) : n;
}
It(Ca, "proxify");
function M0(n, t, e) {
  if (Math.abs(n.length - t.length) >= e)
    return e;
  for (var i = [], r = 0; r <= n.length; r++)
    i[r] = Array(t.length + 1).fill(0), i[r][0] = r;
  for (var s = 0; s < t.length; s++)
    i[0][s] = s;
  for (var r = 1; r <= n.length; r++)
    for (var o = n.charCodeAt(r - 1), s = 1; s <= t.length; s++) {
      if (Math.abs(r - s) >= e) {
        i[r][s] = e;
        continue;
      }
      i[r][s] = Math.min(
        i[r - 1][s] + 1,
        i[r][s - 1] + 1,
        i[r - 1][s - 1] + (o === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  return i[n.length][t.length];
}
It(M0, "stringDistanceCapped");
function $f(n, t, e) {
  var i = /* @__PURE__ */ It(function() {
    Me(this, "lockSsfi") || Me(this, "ssfi", i);
    var r = e.apply(this, arguments);
    if (r !== void 0)
      return r;
    var s = new lt();
    return br(this, s), s;
  }, "methodWrapper");
  Bl(i, t, !1), n[t] = Ca(i, t);
}
It($f, "addMethod");
function Uf(n, t, e) {
  var i = Object.getOwnPropertyDescriptor(n, t), r = /* @__PURE__ */ It(function() {
  }, "_super");
  i && typeof i.get == "function" && (r = i.get), Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ It(function s() {
        !Dl() && !Me(this, "lockSsfi") && Me(this, "ssfi", s);
        var o = Me(this, "lockSsfi");
        Me(this, "lockSsfi", !0);
        var a = e(r).call(this);
        if (Me(this, "lockSsfi", o), a !== void 0)
          return a;
        var l = new lt();
        return br(this, l), l;
      }, "overwritingPropertyGetter"),
      configurable: !0
    }
  );
}
It(Uf, "overwriteProperty");
function Wf(n, t, e) {
  var i = n[t], r = /* @__PURE__ */ It(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  i && typeof i == "function" && (r = i);
  var s = /* @__PURE__ */ It(function() {
    Me(this, "lockSsfi") || Me(this, "ssfi", s);
    var o = Me(this, "lockSsfi");
    Me(this, "lockSsfi", !0);
    var a = e(r).apply(this, arguments);
    if (Me(this, "lockSsfi", o), a !== void 0)
      return a;
    var l = new lt();
    return br(this, l), l;
  }, "overwritingMethodWrapper");
  Bl(s, t, !1), n[t] = Ca(s, t);
}
It(Wf, "overwriteMethod");
var py = typeof Object.setPrototypeOf == "function", Np = /* @__PURE__ */ It(function() {
}, "testFn"), gy = Object.getOwnPropertyNames(Np).filter(function(n) {
  var t = Object.getOwnPropertyDescriptor(Np, n);
  return typeof t != "object" ? !0 : !t.configurable;
}), my = Function.prototype.call, yy = Function.prototype.apply;
function Hf(n, t, e, i) {
  typeof i != "function" && (i = /* @__PURE__ */ It(function() {
  }, "chainingBehavior"));
  var r = {
    method: e,
    chainingBehavior: i
  };
  n.__methods || (n.__methods = {}), n.__methods[t] = r, Object.defineProperty(
    n,
    t,
    {
      get: /* @__PURE__ */ It(function() {
        r.chainingBehavior.call(this);
        var o = /* @__PURE__ */ It(function() {
          Me(this, "lockSsfi") || Me(this, "ssfi", o);
          var h = r.method.apply(this, arguments);
          if (h !== void 0)
            return h;
          var u = new lt();
          return br(this, u), u;
        }, "chainableMethodWrapper");
        if (Bl(o, t, !0), py) {
          var a = Object.create(this);
          a.call = my, a.apply = yy, Object.setPrototypeOf(o, a);
        } else {
          var l = Object.getOwnPropertyNames(n);
          l.forEach(function(h) {
            if (gy.indexOf(h) === -1) {
              var u = Object.getOwnPropertyDescriptor(n, h);
              Object.defineProperty(o, h, u);
            }
          });
        }
        return br(this, o), Ca(o);
      }, "chainableMethodGetter"),
      configurable: !0
    }
  );
}
It(Hf, "addChainableMethod");
function Gf(n, t, e, i) {
  var r = n.__methods[t], s = r.chainingBehavior;
  r.chainingBehavior = /* @__PURE__ */ It(function() {
    var l = i(s).call(this);
    if (l !== void 0)
      return l;
    var h = new lt();
    return br(this, h), h;
  }, "overwritingChainableMethodGetter");
  var o = r.method;
  r.method = /* @__PURE__ */ It(function() {
    var l = e(o).apply(this, arguments);
    if (l !== void 0)
      return l;
    var h = new lt();
    return br(this, h), h;
  }, "overwritingChainableMethodWrapper");
}
It(Gf, "overwriteChainableMethod");
function nc(n, t) {
  return Ge(n) < Ge(t) ? -1 : 1;
}
It(nc, "compareByInspect");
function Vf(n) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(n).filter(function(t) {
    return Object.getOwnPropertyDescriptor(n, t).enumerable;
  });
}
It(Vf, "getOwnEnumerablePropertySymbols");
function Yf(n) {
  return Object.keys(n).concat(Vf(n));
}
It(Yf, "getOwnEnumerableProperties");
function R0(n) {
  return n !== n;
}
It(R0, "_isNaN");
var ic = Number.isNaN || R0;
function D0(n) {
  var t = sn(n), e = ["Array", "Object", "Function"];
  return e.indexOf(t) !== -1;
}
It(D0, "isObjectType");
function Kf(n, t) {
  var e = Me(n, "operator"), i = Me(n, "negate"), r = t[3], s = i ? t[2] : t[1];
  if (e)
    return e;
  if (typeof s == "function" && (s = s()), s = s || "", !!s && !/\shave\s/.test(s)) {
    var o = D0(r);
    return /\snot\s/.test(s) ? o ? "notDeepStrictEqual" : "notStrictEqual" : o ? "deepStrictEqual" : "strictEqual";
  }
}
It(Kf, "getOperator");
function Nc(n) {
  return n.name;
}
It(Nc, "getName");
function rc(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
It(rc, "isRegExp");
function Hn(n) {
  return ["Number", "BigInt"].includes(sn(n));
}
It(Hn, "isNumeric");
var { flag: kt } = Zu;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(n) {
  lt.addProperty(n);
});
lt.addProperty("not", function() {
  kt(this, "negate", !0);
});
lt.addProperty("deep", function() {
  kt(this, "deep", !0);
});
lt.addProperty("nested", function() {
  kt(this, "nested", !0);
});
lt.addProperty("own", function() {
  kt(this, "own", !0);
});
lt.addProperty("ordered", function() {
  kt(this, "ordered", !0);
});
lt.addProperty("any", function() {
  kt(this, "any", !0), kt(this, "all", !1);
});
lt.addProperty("all", function() {
  kt(this, "all", !0), kt(this, "any", !1);
});
var Cp = {
  function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function Xf(n, t) {
  t && kt(this, "message", t), n = n.toLowerCase();
  var e = kt(this, "object"), i = ~["a", "e", "i", "o", "u"].indexOf(n.charAt(0)) ? "an " : "a ";
  const r = sn(e).toLowerCase();
  Cp.function.includes(n) ? this.assert(
    Cp[n].includes(r),
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  ) : this.assert(
    n === r,
    "expected #{this} to be " + i + n,
    "expected #{this} not to be " + i + n
  );
}
It(Xf, "an");
lt.addChainableMethod("an", Xf);
lt.addChainableMethod("a", Xf);
function B0(n, t) {
  return ic(n) && ic(t) || n === t;
}
It(B0, "SameValueZero");
function jl() {
  kt(this, "contains", !0);
}
It(jl, "includeChainingBehavior");
function ql(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = sn(e).toLowerCase(), r = kt(this, "message"), s = kt(this, "negate"), o = kt(this, "ssfi"), a = kt(this, "deep"), l = a ? "deep " : "", h = a ? kt(this, "eql") : B0;
  r = r ? r + ": " : "";
  var u = !1;
  switch (i) {
    case "string":
      u = e.indexOf(n) !== -1;
      break;
    case "weakset":
      if (a)
        throw new Ke(
          r + "unable to use .deep.include with WeakSet",
          void 0,
          o
        );
      u = e.has(n);
      break;
    case "map":
      e.forEach(function(g) {
        u = u || h(g, n);
      });
      break;
    case "set":
      a ? e.forEach(function(g) {
        u = u || h(g, n);
      }) : u = e.has(n);
      break;
    case "array":
      a ? u = e.some(function(g) {
        return h(g, n);
      }) : u = e.indexOf(n) !== -1;
      break;
    default:
      if (n !== Object(n))
        throw new Ke(
          r + "the given combination of arguments (" + i + " and " + sn(n).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + sn(n).toLowerCase(),
          void 0,
          o
        );
      var d = Object.keys(n), p = null, f = 0;
      if (d.forEach(function(g) {
        var y = new lt(e);
        if (br(this, y, !0), kt(y, "lockSsfi", !0), !s || d.length === 1) {
          y.property(g, n[g]);
          return;
        }
        try {
          y.property(g, n[g]);
        } catch (_) {
          if (!Mi.compatibleConstructor(_, Ke))
            throw _;
          p === null && (p = _), f++;
        }
      }, this), s && d.length > 1 && f === d.length)
        throw p;
      return;
  }
  this.assert(
    u,
    "expected #{this} to " + l + "include " + Ge(n),
    "expected #{this} to not " + l + "include " + Ge(n)
  );
}
It(ql, "include");
lt.addChainableMethod("include", ql, jl);
lt.addChainableMethod("contain", ql, jl);
lt.addChainableMethod("contains", ql, jl);
lt.addChainableMethod("includes", ql, jl);
lt.addProperty("ok", function() {
  this.assert(
    kt(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
lt.addProperty("true", function() {
  this.assert(
    kt(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !kt(this, "negate")
  );
});
lt.addProperty("numeric", function() {
  const n = kt(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(sn(n)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !kt(this, "negate")
  );
});
lt.addProperty("callable", function() {
  const n = kt(this, "object"), t = kt(this, "ssfi"), e = kt(this, "message"), i = e ? `${e}: ` : "", r = kt(this, "negate"), s = r ? `${i}expected ${Ge(n)} not to be a callable function` : `${i}expected ${Ge(n)} to be a callable function`, o = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(sn(n));
  if (o && r || !o && !r)
    throw new Ke(
      s,
      void 0,
      t
    );
});
lt.addProperty("false", function() {
  this.assert(
    kt(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!kt(this, "negate")
  );
});
lt.addProperty("null", function() {
  this.assert(
    kt(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
lt.addProperty("undefined", function() {
  this.assert(
    kt(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
lt.addProperty("NaN", function() {
  this.assert(
    ic(kt(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function Jf() {
  var n = kt(this, "object");
  this.assert(
    n != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
It(Jf, "assertExist");
lt.addProperty("exist", Jf);
lt.addProperty("exists", Jf);
lt.addProperty("empty", function() {
  var n = kt(this, "object"), t = kt(this, "ssfi"), e = kt(this, "message"), i;
  switch (e = e ? e + ": " : "", sn(n).toLowerCase()) {
    case "array":
    case "string":
      i = n.length;
      break;
    case "map":
    case "set":
      i = n.size;
      break;
    case "weakmap":
    case "weakset":
      throw new Ke(
        e + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function":
      var r = e + ".empty was passed a function " + Nc(n);
      throw new Ke(r.trim(), void 0, t);
    default:
      if (n !== Object(n))
        throw new Ke(
          e + ".empty was passed non-string primitive " + Ge(n),
          void 0,
          t
        );
      i = Object.keys(n).length;
  }
  this.assert(
    i === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function Zf() {
  var n = kt(this, "object"), t = sn(n);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
It(Zf, "checkArguments");
lt.addProperty("arguments", Zf);
lt.addProperty("Arguments", Zf);
function Cc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object");
  if (kt(this, "deep")) {
    var i = kt(this, "lockSsfi");
    kt(this, "lockSsfi", !0), this.eql(n), kt(this, "lockSsfi", i);
  } else
    this.assert(
      n === e,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      n,
      this._obj,
      !0
    );
}
It(Cc, "assertEqual");
lt.addMethod("equal", Cc);
lt.addMethod("equals", Cc);
lt.addMethod("eq", Cc);
function Qf(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "eql");
  this.assert(
    e(n, kt(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    n,
    this._obj,
    !0
  );
}
It(Qf, "assertEql");
lt.addMethod("eql", Qf);
lt.addMethod("eqls", Qf);
function Pc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase();
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    throw new Ke(s + "the argument to above must be a date", void 0, o);
  if (!Hn(n) && (i || Hn(e)))
    throw new Ke(s + "the argument to above must be a number", void 0, o);
  if (!i && a !== "date" && !Hn(e)) {
    var h = a === "string" ? "'" + e + "'" : e;
    throw new Ke(s + "expected " + h + " to be a number or a date", void 0, o);
  }
  if (i) {
    var u = "length", d;
    a === "map" || a === "set" ? (u = "size", d = e.size) : d = e.length, this.assert(
      d > n,
      "expected #{this} to have a " + u + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + u + " above #{exp}",
      n,
      d
    );
  } else
    this.assert(
      e > n,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n
    );
}
It(Pc, "assertAbove");
lt.addMethod("above", Pc);
lt.addMethod("gt", Pc);
lt.addMethod("greaterThan", Pc);
function Lc(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to least must be a date";
  else if (!Hn(n) && (i || Hn(e)))
    h = s + "the argument to least must be a number";
  else if (!i && a !== "date" && !Hn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ke(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f >= n,
      "expected #{this} to have a " + p + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e >= n,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n
    );
}
It(Lc, "assertLeast");
lt.addMethod("least", Lc);
lt.addMethod("gte", Lc);
lt.addMethod("greaterThanOrEqual", Lc);
function Ic(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to below must be a date";
  else if (!Hn(n) && (i || Hn(e)))
    h = s + "the argument to below must be a number";
  else if (!i && a !== "date" && !Hn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ke(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f < n,
      "expected #{this} to have a " + p + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + p + " below #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e < n,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n
    );
}
It(Ic, "assertBelow");
lt.addMethod("below", Ic);
lt.addMethod("lt", Ic);
lt.addMethod("lessThan", Ic);
function Ec(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "doLength"), r = kt(this, "message"), s = r ? r + ": " : "", o = kt(this, "ssfi"), a = sn(e).toLowerCase(), l = sn(n).toLowerCase(), h, u = !0;
  if (i && a !== "map" && a !== "set" && new lt(e, r, o, !0).to.have.property("length"), !i && a === "date" && l !== "date")
    h = s + "the argument to most must be a date";
  else if (!Hn(n) && (i || Hn(e)))
    h = s + "the argument to most must be a number";
  else if (!i && a !== "date" && !Hn(e)) {
    var d = a === "string" ? "'" + e + "'" : e;
    h = s + "expected " + d + " to be a number or a date";
  } else
    u = !1;
  if (u)
    throw new Ke(h, void 0, o);
  if (i) {
    var p = "length", f;
    a === "map" || a === "set" ? (p = "size", f = e.size) : f = e.length, this.assert(
      f <= n,
      "expected #{this} to have a " + p + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + p + " above #{exp}",
      n,
      f
    );
  } else
    this.assert(
      e <= n,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n
    );
}
It(Ec, "assertMost");
lt.addMethod("most", Ec);
lt.addMethod("lte", Ec);
lt.addMethod("lessThanOrEqual", Ec);
lt.addMethod("within", function(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "doLength"), s = kt(this, "message"), o = s ? s + ": " : "", a = kt(this, "ssfi"), l = sn(i).toLowerCase(), h = sn(n).toLowerCase(), u = sn(t).toLowerCase(), d, p = !0, f = h === "date" && u === "date" ? n.toISOString() + ".." + t.toISOString() : n + ".." + t;
  if (r && l !== "map" && l !== "set" && new lt(i, s, a, !0).to.have.property("length"), !r && l === "date" && (h !== "date" || u !== "date"))
    d = o + "the arguments to within must be dates";
  else if ((!Hn(n) || !Hn(t)) && (r || Hn(i)))
    d = o + "the arguments to within must be numbers";
  else if (!r && l !== "date" && !Hn(i)) {
    var g = l === "string" ? "'" + i + "'" : i;
    d = o + "expected " + g + " to be a number or a date";
  } else
    p = !1;
  if (p)
    throw new Ke(d, void 0, a);
  if (r) {
    var y = "length", _;
    l === "map" || l === "set" ? (y = "size", _ = i.size) : _ = i.length, this.assert(
      _ >= n && _ <= t,
      "expected #{this} to have a " + y + " within " + f,
      "expected #{this} to not have a " + y + " within " + f
    );
  } else
    this.assert(
      i >= n && i <= t,
      "expected #{this} to be within " + f,
      "expected #{this} to not be within " + f
    );
});
function td(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "ssfi"), r = kt(this, "message");
  try {
    var s = e instanceof n;
  } catch (a) {
    throw a instanceof TypeError ? (r = r ? r + ": " : "", new Ke(
      r + "The instanceof assertion needs a constructor but " + sn(n) + " was given.",
      void 0,
      i
    )) : a;
  }
  var o = Nc(n);
  o == null && (o = "an unnamed constructor"), this.assert(
    s,
    "expected #{this} to be an instance of " + o,
    "expected #{this} to not be an instance of " + o
  );
}
It(td, "assertInstanceOf");
lt.addMethod("instanceof", td);
lt.addMethod("instanceOf", td);
function ed(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "nested"), r = kt(this, "own"), s = kt(this, "message"), o = kt(this, "object"), a = kt(this, "ssfi"), l = typeof n;
  if (s = s ? s + ": " : "", i) {
    if (l !== "string")
      throw new Ke(
        s + "the argument to property must be a string when using nested syntax",
        void 0,
        a
      );
  } else if (l !== "string" && l !== "number" && l !== "symbol")
    throw new Ke(
      s + "the argument to property must be a string, number, or symbol",
      void 0,
      a
    );
  if (i && r)
    throw new Ke(
      s + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      a
    );
  if (o == null)
    throw new Ke(
      s + "Target cannot be null or undefined.",
      void 0,
      a
    );
  var h = kt(this, "deep"), u = kt(this, "negate"), d = i ? qf(o, n) : null, p = i ? d.value : o[n], f = h ? kt(this, "eql") : (_, b) => _ === b, g = "";
  h && (g += "deep "), r && (g += "own "), i && (g += "nested "), g += "property ";
  var y;
  r ? y = Object.prototype.hasOwnProperty.call(o, n) : i ? y = d.exists : y = Ac(o, n), (!u || arguments.length === 1) && this.assert(
    y,
    "expected #{this} to have " + g + Ge(n),
    "expected #{this} to not have " + g + Ge(n)
  ), arguments.length > 1 && this.assert(
    y && f(t, p),
    "expected #{this} to have " + g + Ge(n) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + g + Ge(n) + " of #{act}",
    t,
    p
  ), kt(this, "object", p);
}
It(ed, "assertProperty");
lt.addMethod("property", ed);
function nd(n, t, e) {
  kt(this, "own", !0), ed.apply(this, arguments);
}
It(nd, "assertOwnProperty");
lt.addMethod("ownProperty", nd);
lt.addMethod("haveOwnProperty", nd);
function id(n, t, e) {
  typeof t == "string" && (e = t, t = null), e && kt(this, "message", e);
  var i = kt(this, "object"), r = Object.getOwnPropertyDescriptor(Object(i), n), s = kt(this, "eql");
  r && t ? this.assert(
    s(t, r),
    "expected the own property descriptor for " + Ge(n) + " on #{this} to match " + Ge(t) + ", got " + Ge(r),
    "expected the own property descriptor for " + Ge(n) + " on #{this} to not match " + Ge(t),
    t,
    r,
    !0
  ) : this.assert(
    r,
    "expected #{this} to have an own property descriptor for " + Ge(n),
    "expected #{this} to not have an own property descriptor for " + Ge(n)
  ), kt(this, "object", r);
}
It(id, "assertOwnPropertyDescriptor");
lt.addMethod("ownPropertyDescriptor", id);
lt.addMethod("haveOwnPropertyDescriptor", id);
function rd() {
  kt(this, "doLength", !0);
}
It(rd, "assertLengthChain");
function sd(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = sn(e).toLowerCase(), r = kt(this, "message"), s = kt(this, "ssfi"), o = "length", a;
  switch (i) {
    case "map":
    case "set":
      o = "size", a = e.size;
      break;
    default:
      new lt(e, r, s, !0).to.have.property("length"), a = e.length;
  }
  this.assert(
    a == n,
    "expected #{this} to have a " + o + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + o + " of #{act}",
    n,
    a
  );
}
It(sd, "assertLength");
lt.addChainableMethod("length", sd, rd);
lt.addChainableMethod("lengthOf", sd, rd);
function od(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object");
  this.assert(
    n.exec(e),
    "expected #{this} to match " + n,
    "expected #{this} not to match " + n
  );
}
It(od, "assertMatch");
lt.addMethod("match", od);
lt.addMethod("matches", od);
lt.addMethod("string", function(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "message"), r = kt(this, "ssfi");
  new lt(e, i, r, !0).is.a("string"), this.assert(
    ~e.indexOf(n),
    "expected #{this} to contain " + Ge(n),
    "expected #{this} to not contain " + Ge(n)
  );
});
function ad(n) {
  var t = kt(this, "object"), e = sn(t), i = sn(n), r = kt(this, "ssfi"), s = kt(this, "deep"), o, a = "", l, h = !0, u = kt(this, "message");
  u = u ? u + ": " : "";
  var d = u + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (e === "Map" || e === "Set")
    a = s ? "deeply " : "", l = [], t.forEach(function(v, A) {
      l.push(A);
    }), i !== "Array" && (n = Array.prototype.slice.call(arguments));
  else {
    switch (l = Yf(t), i) {
      case "Array":
        if (arguments.length > 1)
          throw new Ke(d, void 0, r);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new Ke(d, void 0, r);
        n = Object.keys(n);
        break;
      default:
        n = Array.prototype.slice.call(arguments);
    }
    n = n.map(function(v) {
      return typeof v == "symbol" ? v : String(v);
    });
  }
  if (!n.length)
    throw new Ke(u + "keys required", void 0, r);
  var p = n.length, f = kt(this, "any"), g = kt(this, "all"), y = n, _ = s ? kt(this, "eql") : (v, A) => v === A;
  if (!f && !g && (g = !0), f && (h = y.some(function(v) {
    return l.some(function(A) {
      return _(v, A);
    });
  })), g && (h = y.every(function(v) {
    return l.some(function(A) {
      return _(v, A);
    });
  }), kt(this, "contains") || (h = h && n.length == l.length)), p > 1) {
    n = n.map(function(v) {
      return Ge(v);
    });
    var b = n.pop();
    g && (o = n.join(", ") + ", and " + b), f && (o = n.join(", ") + ", or " + b);
  } else
    o = Ge(n[0]);
  o = (p > 1 ? "keys " : "key ") + o, o = (kt(this, "contains") ? "contain " : "have ") + o, this.assert(
    h,
    "expected #{this} to " + a + o,
    "expected #{this} to not " + a + o,
    y.slice(0).sort(nc),
    l.sort(nc),
    !0
  );
}
It(ad, "assertKeys");
lt.addMethod("keys", ad);
lt.addMethod("key", ad);
function Oc(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "ssfi"), s = kt(this, "message"), o = kt(this, "negate") || !1;
  new lt(i, s, r, !0).is.a("function"), (rc(n) || typeof n == "string") && (t = n, n = null);
  let a, l = !1;
  try {
    i();
  } catch (v) {
    l = !0, a = v;
  }
  var h = n === void 0 && t === void 0, u = !!(n && t), d = !1, p = !1;
  if (h || !h && !o) {
    var f = "an error";
    n instanceof Error ? f = "#{exp}" : n && (f = Mi.getConstructorName(n));
    let v = a;
    if (a instanceof Error)
      v = a.toString();
    else if (typeof a == "string")
      v = a;
    else if (a && (typeof a == "object" || typeof a == "function"))
      try {
        v = Mi.getConstructorName(a);
      } catch {
      }
    this.assert(
      l,
      "expected #{this} to throw " + f,
      "expected #{this} to not throw an error but #{act} was thrown",
      n && n.toString(),
      v
    );
  }
  if (n && a) {
    if (n instanceof Error) {
      var g = Mi.compatibleInstance(a, n);
      g === o && (u && o ? d = !0 : this.assert(
        o,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (a && !o ? " but #{act} was thrown" : ""),
        n.toString(),
        a.toString()
      ));
    }
    var y = Mi.compatibleConstructor(a, n);
    y === o && (u && o ? d = !0 : this.assert(
      o,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
      n instanceof Error ? n.toString() : n && Mi.getConstructorName(n),
      a instanceof Error ? a.toString() : a && Mi.getConstructorName(a)
    ));
  }
  if (a && t !== void 0 && t !== null) {
    var _ = "including";
    rc(t) && (_ = "matching");
    var b = Mi.compatibleMessage(a, t);
    b === o && (u && o ? p = !0 : this.assert(
      o,
      "expected #{this} to throw error " + _ + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + _ + " #{exp}",
      t,
      Mi.getMessage(a)
    ));
  }
  d && p && this.assert(
    o,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (a ? " but #{act} was thrown" : ""),
    n instanceof Error ? n.toString() : n && Mi.getConstructorName(n),
    a instanceof Error ? a.toString() : a && Mi.getConstructorName(a)
  ), kt(this, "object", a);
}
It(Oc, "assertThrows");
lt.addMethod("throw", Oc);
lt.addMethod("throws", Oc);
lt.addMethod("Throw", Oc);
function ld(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "itself"), r = typeof e == "function" && !i ? e.prototype[n] : e[n];
  this.assert(
    typeof r == "function",
    "expected #{this} to respond to " + Ge(n),
    "expected #{this} to not respond to " + Ge(n)
  );
}
It(ld, "respondTo");
lt.addMethod("respondTo", ld);
lt.addMethod("respondsTo", ld);
lt.addProperty("itself", function() {
  kt(this, "itself", !0);
});
function ud(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = n(e);
  this.assert(
    i,
    "expected #{this} to satisfy " + go(n),
    "expected #{this} to not satisfy" + go(n),
    !kt(this, "negate"),
    i
  );
}
It(ud, "satisfy");
lt.addMethod("satisfy", ud);
lt.addMethod("satisfies", ud);
function cd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.numeric;
  let o = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new Ke(r ? `${r}: ${o}` : o, void 0, s);
  if (new lt(t, r, s, !0).is.numeric, o = "A `expected` value is required for `closeTo`", n == null)
    throw new Ke(r ? `${r}: ${o}` : o, void 0, s);
  new lt(n, r, s, !0).is.numeric;
  const a = /* @__PURE__ */ It((l) => l < 0n ? -l : l, "abs");
  this.assert(
    a(i - n) <= t,
    "expected #{this} to be close to " + n + " +/- " + t,
    "expected #{this} not to be close to " + n + " +/- " + t
  );
}
It(cd, "closeTo");
lt.addMethod("closeTo", cd);
lt.addMethod("approximately", cd);
function j0(n, t, e, i, r) {
  let s = Array.from(t), o = Array.from(n);
  if (!i) {
    if (o.length !== s.length)
      return !1;
    s = s.slice();
  }
  return o.every(function(a, l) {
    if (r)
      return e ? e(a, s[l]) : a === s[l];
    if (!e) {
      var h = s.indexOf(a);
      return h === -1 ? !1 : (i || s.splice(h, 1), !0);
    }
    return s.some(function(u, d) {
      return e(a, u) ? (i || s.splice(d, 1), !0) : !1;
    });
  });
}
It(j0, "isSubsetOf");
lt.addMethod("members", function(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "message"), r = kt(this, "ssfi");
  new lt(e, i, r, !0).to.be.iterable, new lt(n, i, r, !0).to.be.iterable;
  var s = kt(this, "contains"), o = kt(this, "ordered"), a, l, h;
  s ? (a = o ? "an ordered superset" : "a superset", l = "expected #{this} to be " + a + " of #{exp}", h = "expected #{this} to not be " + a + " of #{exp}") : (a = o ? "ordered members" : "members", l = "expected #{this} to have the same " + a + " as #{exp}", h = "expected #{this} to not have the same " + a + " as #{exp}");
  var u = kt(this, "deep") ? kt(this, "eql") : void 0;
  this.assert(
    j0(n, e, u, s, o),
    l,
    h,
    n,
    e,
    !0
  );
});
lt.addProperty("iterable", function(n) {
  n && kt(this, "message", n);
  var t = kt(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function q0(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "object"), i = kt(this, "message"), r = kt(this, "ssfi"), s = kt(this, "contains"), o = kt(this, "deep"), a = kt(this, "eql");
  new lt(n, i, r, !0).to.be.an("array"), s ? this.assert(
    n.some(function(l) {
      return e.indexOf(l) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    n,
    e
  ) : o ? this.assert(
    n.some(function(l) {
      return a(e, l);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    n,
    e
  ) : this.assert(
    n.indexOf(e) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    n,
    e
  );
}
It(q0, "oneOf");
lt.addMethod("oneOf", q0);
function hd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  kt(this, "deltaMsgObj", l), kt(this, "initialDeltaValue", o), kt(this, "finalDeltaValue", a), kt(this, "deltaBehavior", "change"), kt(this, "realDelta", a !== o), this.assert(
    o !== a,
    "expected " + l + " to change",
    "expected " + l + " to not change"
  );
}
It(hd, "assertChanges");
lt.addMethod("change", hd);
lt.addMethod("changes", hd);
function fd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), new lt(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  kt(this, "deltaMsgObj", l), kt(this, "initialDeltaValue", o), kt(this, "finalDeltaValue", a), kt(this, "deltaBehavior", "increase"), kt(this, "realDelta", a - o), this.assert(
    a - o > 0,
    "expected " + l + " to increase",
    "expected " + l + " to not increase"
  );
}
It(fd, "assertIncreases");
lt.addMethod("increase", fd);
lt.addMethod("increases", fd);
function dd(n, t, e) {
  e && kt(this, "message", e);
  var i = kt(this, "object"), r = kt(this, "message"), s = kt(this, "ssfi");
  new lt(i, r, s, !0).is.a("function");
  var o;
  t ? (new lt(n, r, s, !0).to.have.property(t), o = n[t]) : (new lt(n, r, s, !0).is.a("function"), o = n()), new lt(o, r, s, !0).is.a("number"), i();
  var a = t == null ? n() : n[t], l = t == null ? o : "." + t;
  kt(this, "deltaMsgObj", l), kt(this, "initialDeltaValue", o), kt(this, "finalDeltaValue", a), kt(this, "deltaBehavior", "decrease"), kt(this, "realDelta", o - a), this.assert(
    a - o < 0,
    "expected " + l + " to decrease",
    "expected " + l + " to not decrease"
  );
}
It(dd, "assertDecreases");
lt.addMethod("decrease", dd);
lt.addMethod("decreases", dd);
function z0(n, t) {
  t && kt(this, "message", t);
  var e = kt(this, "deltaMsgObj"), i = kt(this, "initialDeltaValue"), r = kt(this, "finalDeltaValue"), s = kt(this, "deltaBehavior"), o = kt(this, "realDelta"), a;
  s === "change" ? a = Math.abs(r - i) === Math.abs(n) : a = o === Math.abs(n), this.assert(
    a,
    "expected " + e + " to " + s + " by " + n,
    "expected " + e + " to not " + s + " by " + n
  );
}
It(z0, "assertDelta");
lt.addMethod("by", z0);
lt.addProperty("extensible", function() {
  var n = kt(this, "object"), t = n === Object(n) && Object.isExtensible(n);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
lt.addProperty("sealed", function() {
  var n = kt(this, "object"), t = n === Object(n) ? Object.isSealed(n) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
lt.addProperty("frozen", function() {
  var n = kt(this, "object"), t = n === Object(n) ? Object.isFrozen(n) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
lt.addProperty("finite", function(n) {
  var t = kt(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function Ds(n, t) {
  return new lt(n, t);
}
It(Ds, "expect");
Ds.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "expect.fail()", new Ke(e, {
    actual: n,
    expected: t,
    operator: i
  }, Ds.fail);
};
var $0 = {};
Tf($0, {
  Should: () => vy,
  should: () => by
});
function pd() {
  function n() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new lt(this.valueOf(), null, n) : new lt(this, null, n);
  }
  It(n, "shouldGetter");
  function t(i) {
    Object.defineProperty(this, "should", {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  It(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: n,
    configurable: !0
  });
  var e = {};
  return e.fail = function(i, r, s, o) {
    throw arguments.length < 2 && (s = i, i = void 0), s = s || "should.fail()", new Ke(s, {
      actual: i,
      expected: r,
      operator: o
    }, e.fail);
  }, e.equal = function(i, r, s) {
    new lt(i, s).to.equal(r);
  }, e.Throw = function(i, r, s, o) {
    new lt(i, o).to.Throw(r, s);
  }, e.exist = function(i, r) {
    new lt(i, r).to.exist;
  }, e.not = {}, e.not.equal = function(i, r, s) {
    new lt(i, s).to.not.equal(r);
  }, e.not.Throw = function(i, r, s, o) {
    new lt(i, o).to.not.Throw(r, s);
  }, e.not.exist = function(i, r) {
    new lt(i, r).to.not.exist;
  }, e.throw = e.Throw, e.not.throw = e.not.Throw, e;
}
It(pd, "loadShould");
var by = pd, vy = pd;
function at(n, t) {
  var e = new lt(null, null, at, !0);
  e.assert(
    n,
    t,
    "[ negation message unavailable ]"
  );
}
It(at, "assert");
at.fail = function(n, t, e, i) {
  throw arguments.length < 2 && (e = n, n = void 0), e = e || "assert.fail()", new Ke(e, {
    actual: n,
    expected: t,
    operator: i
  }, at.fail);
};
at.isOk = function(n, t) {
  new lt(n, t, at.isOk, !0).is.ok;
};
at.isNotOk = function(n, t) {
  new lt(n, t, at.isNotOk, !0).is.not.ok;
};
at.equal = function(n, t, e) {
  var i = new lt(n, e, at.equal, !0);
  i.assert(
    t == Me(i, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    n,
    !0
  );
};
at.notEqual = function(n, t, e) {
  var i = new lt(n, e, at.notEqual, !0);
  i.assert(
    t != Me(i, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    n,
    !0
  );
};
at.strictEqual = function(n, t, e) {
  new lt(n, e, at.strictEqual, !0).to.equal(t);
};
at.notStrictEqual = function(n, t, e) {
  new lt(n, e, at.notStrictEqual, !0).to.not.equal(t);
};
at.deepEqual = at.deepStrictEqual = function(n, t, e) {
  new lt(n, e, at.deepEqual, !0).to.eql(t);
};
at.notDeepEqual = function(n, t, e) {
  new lt(n, e, at.notDeepEqual, !0).to.not.eql(t);
};
at.isAbove = function(n, t, e) {
  new lt(n, e, at.isAbove, !0).to.be.above(t);
};
at.isAtLeast = function(n, t, e) {
  new lt(n, e, at.isAtLeast, !0).to.be.least(t);
};
at.isBelow = function(n, t, e) {
  new lt(n, e, at.isBelow, !0).to.be.below(t);
};
at.isAtMost = function(n, t, e) {
  new lt(n, e, at.isAtMost, !0).to.be.most(t);
};
at.isTrue = function(n, t) {
  new lt(n, t, at.isTrue, !0).is.true;
};
at.isNotTrue = function(n, t) {
  new lt(n, t, at.isNotTrue, !0).to.not.equal(!0);
};
at.isFalse = function(n, t) {
  new lt(n, t, at.isFalse, !0).is.false;
};
at.isNotFalse = function(n, t) {
  new lt(n, t, at.isNotFalse, !0).to.not.equal(!1);
};
at.isNull = function(n, t) {
  new lt(n, t, at.isNull, !0).to.equal(null);
};
at.isNotNull = function(n, t) {
  new lt(n, t, at.isNotNull, !0).to.not.equal(null);
};
at.isNaN = function(n, t) {
  new lt(n, t, at.isNaN, !0).to.be.NaN;
};
at.isNotNaN = function(n, t) {
  new lt(n, t, at.isNotNaN, !0).not.to.be.NaN;
};
at.exists = function(n, t) {
  new lt(n, t, at.exists, !0).to.exist;
};
at.notExists = function(n, t) {
  new lt(n, t, at.notExists, !0).to.not.exist;
};
at.isUndefined = function(n, t) {
  new lt(n, t, at.isUndefined, !0).to.equal(void 0);
};
at.isDefined = function(n, t) {
  new lt(n, t, at.isDefined, !0).to.not.equal(void 0);
};
at.isCallable = function(n, t) {
  new lt(n, t, at.isCallable, !0).is.callable;
};
at.isNotCallable = function(n, t) {
  new lt(n, t, at.isNotCallable, !0).is.not.callable;
};
at.isObject = function(n, t) {
  new lt(n, t, at.isObject, !0).to.be.a("object");
};
at.isNotObject = function(n, t) {
  new lt(n, t, at.isNotObject, !0).to.not.be.a("object");
};
at.isArray = function(n, t) {
  new lt(n, t, at.isArray, !0).to.be.an("array");
};
at.isNotArray = function(n, t) {
  new lt(n, t, at.isNotArray, !0).to.not.be.an("array");
};
at.isString = function(n, t) {
  new lt(n, t, at.isString, !0).to.be.a("string");
};
at.isNotString = function(n, t) {
  new lt(n, t, at.isNotString, !0).to.not.be.a("string");
};
at.isNumber = function(n, t) {
  new lt(n, t, at.isNumber, !0).to.be.a("number");
};
at.isNotNumber = function(n, t) {
  new lt(n, t, at.isNotNumber, !0).to.not.be.a("number");
};
at.isNumeric = function(n, t) {
  new lt(n, t, at.isNumeric, !0).is.numeric;
};
at.isNotNumeric = function(n, t) {
  new lt(n, t, at.isNotNumeric, !0).is.not.numeric;
};
at.isFinite = function(n, t) {
  new lt(n, t, at.isFinite, !0).to.be.finite;
};
at.isBoolean = function(n, t) {
  new lt(n, t, at.isBoolean, !0).to.be.a("boolean");
};
at.isNotBoolean = function(n, t) {
  new lt(n, t, at.isNotBoolean, !0).to.not.be.a("boolean");
};
at.typeOf = function(n, t, e) {
  new lt(n, e, at.typeOf, !0).to.be.a(t);
};
at.notTypeOf = function(n, t, e) {
  new lt(n, e, at.notTypeOf, !0).to.not.be.a(t);
};
at.instanceOf = function(n, t, e) {
  new lt(n, e, at.instanceOf, !0).to.be.instanceOf(t);
};
at.notInstanceOf = function(n, t, e) {
  new lt(n, e, at.notInstanceOf, !0).to.not.be.instanceOf(t);
};
at.include = function(n, t, e) {
  new lt(n, e, at.include, !0).include(t);
};
at.notInclude = function(n, t, e) {
  new lt(n, e, at.notInclude, !0).not.include(t);
};
at.deepInclude = function(n, t, e) {
  new lt(n, e, at.deepInclude, !0).deep.include(t);
};
at.notDeepInclude = function(n, t, e) {
  new lt(n, e, at.notDeepInclude, !0).not.deep.include(t);
};
at.nestedInclude = function(n, t, e) {
  new lt(n, e, at.nestedInclude, !0).nested.include(t);
};
at.notNestedInclude = function(n, t, e) {
  new lt(n, e, at.notNestedInclude, !0).not.nested.include(t);
};
at.deepNestedInclude = function(n, t, e) {
  new lt(n, e, at.deepNestedInclude, !0).deep.nested.include(t);
};
at.notDeepNestedInclude = function(n, t, e) {
  new lt(n, e, at.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
at.ownInclude = function(n, t, e) {
  new lt(n, e, at.ownInclude, !0).own.include(t);
};
at.notOwnInclude = function(n, t, e) {
  new lt(n, e, at.notOwnInclude, !0).not.own.include(t);
};
at.deepOwnInclude = function(n, t, e) {
  new lt(n, e, at.deepOwnInclude, !0).deep.own.include(t);
};
at.notDeepOwnInclude = function(n, t, e) {
  new lt(n, e, at.notDeepOwnInclude, !0).not.deep.own.include(t);
};
at.match = function(n, t, e) {
  new lt(n, e, at.match, !0).to.match(t);
};
at.notMatch = function(n, t, e) {
  new lt(n, e, at.notMatch, !0).to.not.match(t);
};
at.property = function(n, t, e) {
  new lt(n, e, at.property, !0).to.have.property(t);
};
at.notProperty = function(n, t, e) {
  new lt(n, e, at.notProperty, !0).to.not.have.property(t);
};
at.propertyVal = function(n, t, e, i) {
  new lt(n, i, at.propertyVal, !0).to.have.property(t, e);
};
at.notPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notPropertyVal, !0).to.not.have.property(t, e);
};
at.deepPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.deepPropertyVal, !0).to.have.deep.property(t, e);
};
at.notDeepPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notDeepPropertyVal, !0).to.not.have.deep.property(t, e);
};
at.ownProperty = function(n, t, e) {
  new lt(n, e, at.ownProperty, !0).to.have.own.property(t);
};
at.notOwnProperty = function(n, t, e) {
  new lt(n, e, at.notOwnProperty, !0).to.not.have.own.property(t);
};
at.ownPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.ownPropertyVal, !0).to.have.own.property(t, e);
};
at.notOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notOwnPropertyVal, !0).to.not.have.own.property(t, e);
};
at.deepOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.deepOwnPropertyVal, !0).to.have.deep.own.property(t, e);
};
at.notDeepOwnPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, e);
};
at.nestedProperty = function(n, t, e) {
  new lt(n, e, at.nestedProperty, !0).to.have.nested.property(t);
};
at.notNestedProperty = function(n, t, e) {
  new lt(n, e, at.notNestedProperty, !0).to.not.have.nested.property(t);
};
at.nestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.nestedPropertyVal, !0).to.have.nested.property(t, e);
};
at.notNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notNestedPropertyVal, !0).to.not.have.nested.property(t, e);
};
at.deepNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, e);
};
at.notDeepNestedPropertyVal = function(n, t, e, i) {
  new lt(n, i, at.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, e);
};
at.lengthOf = function(n, t, e) {
  new lt(n, e, at.lengthOf, !0).to.have.lengthOf(t);
};
at.hasAnyKeys = function(n, t, e) {
  new lt(n, e, at.hasAnyKeys, !0).to.have.any.keys(t);
};
at.hasAllKeys = function(n, t, e) {
  new lt(n, e, at.hasAllKeys, !0).to.have.all.keys(t);
};
at.containsAllKeys = function(n, t, e) {
  new lt(n, e, at.containsAllKeys, !0).to.contain.all.keys(t);
};
at.doesNotHaveAnyKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
at.doesNotHaveAllKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
at.hasAnyDeepKeys = function(n, t, e) {
  new lt(n, e, at.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
at.hasAllDeepKeys = function(n, t, e) {
  new lt(n, e, at.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
at.containsAllDeepKeys = function(n, t, e) {
  new lt(n, e, at.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
at.doesNotHaveAnyDeepKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
at.doesNotHaveAllDeepKeys = function(n, t, e) {
  new lt(n, e, at.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
at.throws = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null);
  var r = new lt(n, i, at.throws, !0).to.throw(t, e);
  return Me(r, "object");
};
at.doesNotThrow = function(n, t, e, i) {
  (typeof t == "string" || t instanceof RegExp) && (e = t, t = null), new lt(n, i, at.doesNotThrow, !0).to.not.throw(t, e);
};
at.operator = function(n, t, e, i) {
  var r;
  switch (t) {
    case "==":
      r = n == e;
      break;
    case "===":
      r = n === e;
      break;
    case ">":
      r = n > e;
      break;
    case ">=":
      r = n >= e;
      break;
    case "<":
      r = n < e;
      break;
    case "<=":
      r = n <= e;
      break;
    case "!=":
      r = n != e;
      break;
    case "!==":
      r = n !== e;
      break;
    default:
      throw i = i && i + ": ", new Ke(
        i + 'Invalid operator "' + t + '"',
        void 0,
        at.operator
      );
  }
  var s = new lt(r, i, at.operator, !0);
  s.assert(
    Me(s, "object") === !0,
    "expected " + Ge(n) + " to be " + t + " " + Ge(e),
    "expected " + Ge(n) + " to not be " + t + " " + Ge(e)
  );
};
at.closeTo = function(n, t, e, i) {
  new lt(n, i, at.closeTo, !0).to.be.closeTo(t, e);
};
at.approximately = function(n, t, e, i) {
  new lt(n, i, at.approximately, !0).to.be.approximately(t, e);
};
at.sameMembers = function(n, t, e) {
  new lt(n, e, at.sameMembers, !0).to.have.same.members(t);
};
at.notSameMembers = function(n, t, e) {
  new lt(n, e, at.notSameMembers, !0).to.not.have.same.members(t);
};
at.sameDeepMembers = function(n, t, e) {
  new lt(n, e, at.sameDeepMembers, !0).to.have.same.deep.members(t);
};
at.notSameDeepMembers = function(n, t, e) {
  new lt(n, e, at.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
at.sameOrderedMembers = function(n, t, e) {
  new lt(n, e, at.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
at.notSameOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
at.sameDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
at.notSameDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
at.includeMembers = function(n, t, e) {
  new lt(n, e, at.includeMembers, !0).to.include.members(t);
};
at.notIncludeMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeMembers, !0).to.not.include.members(t);
};
at.includeDeepMembers = function(n, t, e) {
  new lt(n, e, at.includeDeepMembers, !0).to.include.deep.members(t);
};
at.notIncludeDeepMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
at.includeOrderedMembers = function(n, t, e) {
  new lt(n, e, at.includeOrderedMembers, !0).to.include.ordered.members(t);
};
at.notIncludeOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
at.includeDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
at.notIncludeDeepOrderedMembers = function(n, t, e) {
  new lt(n, e, at.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
at.oneOf = function(n, t, e) {
  new lt(n, e, at.oneOf, !0).to.be.oneOf(t);
};
at.isIterable = function(n, t) {
  if (n == null || !n[Symbol.iterator])
    throw t = t ? `${t} expected ${Ge(n)} to be an iterable` : `expected ${Ge(n)} to be an iterable`, new Ke(
      t,
      void 0,
      at.isIterable
    );
};
at.changes = function(n, t, e, i) {
  arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.changes, !0).to.change(t, e);
};
at.changesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.changesBy, !0).to.change(t, e).by(i);
};
at.doesNotChange = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.doesNotChange, !0).to.not.change(t, e);
};
at.changesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.changesButNotBy, !0).to.change(t, e).but.not.by(i);
};
at.increases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.increases, !0).to.increase(t, e);
};
at.increasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.increasesBy, !0).to.increase(t, e).by(i);
};
at.doesNotIncrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.doesNotIncrease, !0).to.not.increase(t, e);
};
at.increasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.increasesButNotBy, !0).to.increase(t, e).but.not.by(i);
};
at.decreases = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.decreases, !0).to.decrease(t, e);
};
at.decreasesBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.decreasesBy, !0).to.decrease(t, e).by(i);
};
at.doesNotDecrease = function(n, t, e, i) {
  return arguments.length === 3 && typeof t == "function" && (i = e, e = null), new lt(n, i, at.doesNotDecrease, !0).to.not.decrease(t, e);
};
at.doesNotDecreaseBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  return new lt(n, r, at.doesNotDecreaseBy, !0).to.not.decrease(t, e).by(i);
};
at.decreasesButNotBy = function(n, t, e, i, r) {
  if (arguments.length === 4 && typeof t == "function") {
    var s = i;
    i = e, r = s;
  } else arguments.length === 3 && (i = e, e = null);
  new lt(n, r, at.decreasesButNotBy, !0).to.decrease(t, e).but.not.by(i);
};
at.ifError = function(n) {
  if (n)
    throw n;
};
at.isExtensible = function(n, t) {
  new lt(n, t, at.isExtensible, !0).to.be.extensible;
};
at.isNotExtensible = function(n, t) {
  new lt(n, t, at.isNotExtensible, !0).to.not.be.extensible;
};
at.isSealed = function(n, t) {
  new lt(n, t, at.isSealed, !0).to.be.sealed;
};
at.isNotSealed = function(n, t) {
  new lt(n, t, at.isNotSealed, !0).to.not.be.sealed;
};
at.isFrozen = function(n, t) {
  new lt(n, t, at.isFrozen, !0).to.be.frozen;
};
at.isNotFrozen = function(n, t) {
  new lt(n, t, at.isNotFrozen, !0).to.not.be.frozen;
};
at.isEmpty = function(n, t) {
  new lt(n, t, at.isEmpty, !0).to.be.empty;
};
at.isNotEmpty = function(n, t) {
  new lt(n, t, at.isNotEmpty, !0).to.not.be.empty;
};
(/* @__PURE__ */ It(function n(t, e) {
  return at[e] = at[t], n;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var Pp = [];
function wy(n) {
  const t = {
    AssertionError: Ke,
    util: Zu,
    config: pi,
    expect: Ds,
    assert: at,
    Assertion: lt,
    ...$0
  };
  return ~Pp.indexOf(n) || (n(t, Zu), Pp.push(n)), t;
}
It(wy, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var uo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tc(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function xy(n) {
  if (n.__esModule) return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(e, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), e;
}
var ef = { exports: {} }, vh, Lp;
function _y() {
  if (Lp) return vh;
  Lp = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  vh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var g = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (g ? "s" : "");
  }
  return vh;
}
function Sy(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = s, e.enable = r, e.enabled = o, e.humanize = _y(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, g;
    function y(..._) {
      if (!y.enabled)
        return;
      const b = y, v = Number(/* @__PURE__ */ new Date()), A = v - (d || v);
      b.diff = A, b.prev = d, b.curr = v, d = v, _[0] = e.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let L = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (R, C) => {
        if (R === "%%")
          return "%";
        L++;
        const E = e.formatters[C];
        if (typeof E == "function") {
          const M = _[L];
          R = E.call(b, M), _.splice(L, 1), L--;
        }
        return R;
      }), e.formatArgs.call(b, _), (b.log || e.log).apply(b, _);
    }
    return y.namespace = u, y.useColors = e.useColors(), y.color = e.selectColor(u), y.extend = i, y.destroy = e.destroy, Object.defineProperty(y, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, g = e.enabled(u)), g),
      set: (_) => {
        p = _;
      }
    }), typeof e.init == "function" && e.init(y), y;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? e.skips.push(new RegExp("^" + u.slice(1) + "$")) : e.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [
      ...e.names.map(a),
      ...e.skips.map(a).map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = e.skips.length; d < p; d++)
      if (e.skips[d].test(u))
        return !1;
    for (d = 0, p = e.names.length; d < p; d++)
      if (e.names[d].test(u))
        return !0;
    return !1;
  }
  function a(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var ky = Sy;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = ky(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(ef, ef.exports);
var Ay = ef.exports;
const U0 = /* @__PURE__ */ Tc(Ay), Ny = {
  cacheResults: !0,
  successMetric: "efficiency",
  calculateCuts: !0,
  stack: !0,
  findDuplicatePatterns: !0,
  //dev specific
  captureProfile: !1,
  runTests: !1,
  throwErrorsOnFailedTests: !1,
  // recordPlacementPositions: isDevOrTest ? true : false,
  sample: {
    enable: !0,
    groupSize: 6,
    efficiency: 4,
    guillotine: 2
  },
  priority: {
    enable: !0,
    variationThreshold: 0.3
  },
  secondRun: {
    enabled: !1,
    efficiencyCutoff: 0.5,
    stack: !1
  },
  efficiency: {
    tidy: !1,
    //[] issue with picking winner when tidy is enabled
    rayCasting: !0
  },
  groups: {
    shapeAreaCutOff: 0.7,
    tolerance: 0.04,
    guillotine: {
      strips: !0,
      segments: !0,
      runWithout: !1
    },
    efficiency: {
      firstShapes: !0,
      position: !0,
      limit: 100
    }
  },
  guillotine: {
    viableShapeArea: 0.5,
    secondPass: !0,
    strips: {
      rearrange: !0,
      efficiencyThreshold: 0.7
    },
    stripShapes: {
      allocation: !0,
      iterations: 6,
      numPriorityShapes: 1
    }
  },
  subset: {
    shuffles: 80,
    //this is the default - can be overwritten (for example when creating groups)
    guillotine: {
      shuffles: 80
    },
    efficiency: {
      limit: 0.5
    }
  },
  evo: {
    disable: !1,
    stockLimit: 40
  }
};
pi.showDiff = !0;
const Ip = U0("tests");
U0("timers");
function W0() {
  return typeof process < "u" && (process != null && process.env), !1;
}
function H0(n, t = null) {
  if (n != null && n.length && W0() && Ny.runTests)
    for (const e of n)
      try {
        e();
      } catch (i) {
        t ? Ip(t, i.message) : Ip(i.message);
      }
}
var nf = { exports: {} }, wh, Ep;
function Cy() {
  if (Ep) return wh;
  Ep = 1;
  var n = 1e3, t = n * 60, e = t * 60, i = e * 24, r = i * 7, s = i * 365.25;
  wh = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * s;
          case "weeks":
          case "week":
          case "w":
            return p * r;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var d = Math.abs(u);
    return d >= i ? Math.round(u / i) + "d" : d >= e ? Math.round(u / e) + "h" : d >= t ? Math.round(u / t) + "m" : d >= n ? Math.round(u / n) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= i ? h(u, d, i, "day") : d >= e ? h(u, d, e, "hour") : d >= t ? h(u, d, t, "minute") : d >= n ? h(u, d, n, "second") : u + " ms";
  }
  function h(u, d, p, f) {
    var g = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (g ? "s" : "");
  }
  return wh;
}
function Py(n) {
  e.debug = e, e.default = e, e.coerce = l, e.disable = o, e.enable = r, e.enabled = a, e.humanize = Cy(), e.destroy = h, Object.keys(n).forEach((u) => {
    e[u] = n[u];
  }), e.names = [], e.skips = [], e.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return e.colors[Math.abs(d) % e.colors.length];
  }
  e.selectColor = t;
  function e(u) {
    let d, p = null, f, g;
    function y(..._) {
      if (!y.enabled)
        return;
      const b = y, v = Number(/* @__PURE__ */ new Date()), A = v - (d || v);
      b.diff = A, b.prev = d, b.curr = v, d = v, _[0] = e.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let L = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (R, C) => {
        if (R === "%%")
          return "%";
        L++;
        const E = e.formatters[C];
        if (typeof E == "function") {
          const M = _[L];
          R = E.call(b, M), _.splice(L, 1), L--;
        }
        return R;
      }), e.formatArgs.call(b, _), (b.log || e.log).apply(b, _);
    }
    return y.namespace = u, y.useColors = e.useColors(), y.color = e.selectColor(u), y.extend = i, y.destroy = e.destroy, Object.defineProperty(y, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== e.namespaces && (f = e.namespaces, g = e.enabled(u)), g),
      set: (_) => {
        p = _;
      }
    }), typeof e.init == "function" && e.init(y), y;
  }
  function i(u, d) {
    const p = e(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function r(u) {
    e.save(u), e.namespaces = u, e.names = [], e.skips = [];
    const d = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const p of d)
      p[0] === "-" ? e.skips.push(p.slice(1)) : e.names.push(p);
  }
  function s(u, d) {
    let p = 0, f = 0, g = -1, y = 0;
    for (; p < u.length; )
      if (f < d.length && (d[f] === u[p] || d[f] === "*"))
        d[f] === "*" ? (g = f, y = p, f++) : (p++, f++);
      else if (g !== -1)
        f = g + 1, y++, p = y;
      else
        return !1;
    for (; f < d.length && d[f] === "*"; )
      f++;
    return f === d.length;
  }
  function o() {
    const u = [
      ...e.names,
      ...e.skips.map((d) => "-" + d)
    ].join(",");
    return e.enable(""), u;
  }
  function a(u) {
    for (const d of e.skips)
      if (s(u, d))
        return !1;
    for (const d of e.names)
      if (s(u, d))
        return !0;
    return !1;
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return e.enable(e.load()), e;
}
var Ly = Py;
(function(n, t) {
  t.formatArgs = i, t.save = r, t.load = s, t.useColors = e, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, h);
  }
  t.log = console.debug || console.log || (() => {
  });
  function r(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = void 0), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = Ly(t);
  const { formatters: a } = n.exports;
  a.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(nf, nf.exports);
var Iy = nf.exports;
const er = /* @__PURE__ */ Tc(Iy);
er.colors = [
  2,
  3,
  4,
  5,
  7,
  9,
  10,
  11,
  14,
  159
];
er("logs");
er("cuts");
er("guillotine");
er("results");
er("scoring");
er("calculations");
er("subset");
er("secondRun");
er("stack");
const Ey = er("errors");
er("allStock");
Ey.color = 1;
function Oy(n) {
  if (n != null && n.dimension)
    switch (n.dimension) {
      case "l":
        return n.x2 - n.x1;
      case "w":
        return n.y2 - n.y1;
    }
  switch (n.type) {
    case "top":
    case "bottom":
      return n.x2 - n.x1;
    case "left":
    case "right":
      return n.y2 - n.y1;
  }
  return 0;
}
class Fc extends ma {
  //used to mark for removal
  constructor(e) {
    var i, r, s, o;
    e.x2 < e.x1 && ([e.x1, e.x2] = [e.x2, e.x1]), e.y2 < e.y1 && ([e.y1, e.y2] = [e.y2, e.y1]);
    super(e);
    et(this, "stock");
    et(this, "stockId");
    et(this, "guillotine");
    et(this, "guillotineData");
    et(this, "isTrim");
    et(this, "distances");
    et(this, "beamTrimX1");
    et(this, "beamTrimY1");
    et(this, "type", null);
    et(this, "remove");
    jt(e == null ? void 0 : e.stock) && (((r = (i = e.stock) == null ? void 0 : i.constructor) == null ? void 0 : r.name) === "Stock" ? this.stock = e.stock : this.stock = new is(e.stock), this.stockId = this.stock.id), this.stockId = (s = e == null ? void 0 : e.stock) == null ? void 0 : s.id, this.type = e.type ?? null, this.guillotine = e.guillotine, this.guillotineData = jt(e.guillotineData) ? e.guillotineData : {}, this.guillotineData.ptxDummyCut = (e == null ? void 0 : e.ptxDummyCut) || ((o = e == null ? void 0 : e.guillotineData) == null ? void 0 : o.ptxDummyCut) || !1, this.isTrim = jt(e.isTrim) ? e.isTrim : !1, this.distances = jt(e.distances) ? e.distances : {}, this.beamTrimX1 = e.beamTrimX1, this.beamTrimY1 = e.beamTrimY1;
  }
  //compress for saving / transfer
  compress() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.shapeCollisions, delete this.stock;
  }
  clone() {
    const e = structuredClone(this);
    return new Fc(e);
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
  trim() {
    this.dimension === "l" ? (this.x1 = this.x1 < 0 ? 0 : this.x1, this.x2 = this.x2 > this.stock.l ? this.stock.l : this.x2) : this.dimension === "w" && (this.y1 = this.y1 < 0 ? 0 : this.y1, this.y2 = this.y2 > this.stock.w ? this.stock.w : this.y2);
  }
  lookupDirectionByType(e) {
    const r = {
      top: "l",
      bottom: "l",
      left: "w",
      right: "w"
    }[e];
    if (r) return r;
    throw new Error("no direction found in lookupDirectionByType");
  }
  isInsideStock() {
    switch (this.type) {
      case "bottom":
        return Ve.greaterThan(
          this.y1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "left":
        return Ve.greaterThan(
          this.x1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "top":
        return Ve.lessThan(
          this.y1 - this.stock.getBladeWidth() / 2,
          this.stock.w
        );
      case "right":
        return Ve.lessThan(
          this.x1 - this.stock.getBladeWidth() / 2,
          this.stock.l
        );
      default:
        return !0;
    }
  }
  /**
      * the cuts are visualised differently from their exact dimensions
      * @param {string} coord
      */
  getVisCoords(e) {
    return this[e];
  }
  getLength() {
    return Oy(this);
  }
  getArea() {
    if (!this.stock) return 0;
    const e = this.getLength();
    return e ? e * this.stock.getBladeWidth() : 0;
  }
}
const Ty = {
  tb: {
    bottomLeft: {
      top: "topRight",
      topLeft: "topLeft"
    },
    bottomRight: {
      top: "topLeft",
      topRight: "topRight"
    }
  },
  bt: {
    topLeft: {
      bottom: "bottomRight",
      bottomLeft: "bottomLeft"
    },
    topRight: {
      bottom: "bottomLeft",
      bottomRight: "bottomRight"
    }
  },
  lr: {
    topRight: {
      left: "bottomLeft",
      topLeft: "topLeft"
    },
    bottomRight: {
      left: "topLeft",
      bottomLeft: "bottomLeft"
    }
  },
  rl: {
    topLeft: {
      right: "bottomRight",
      topRight: "topRight"
    },
    bottomLeft: {
      right: "topRight",
      bottomRight: "bottomRight"
    }
  }
}, ku = {
  topLeft: {
    top: ["topRight"],
    default: ["topRight"]
  },
  bottomRight: {
    right: ["topRight"],
    default: ["topRight"]
  }
}, Au = {
  topRight: {
    top: ["topLeft"],
    right: ["bottomRight"],
    default: ["topLeft", "bottomRight"]
  },
  topLeft: {
    top: ["topRight"],
    left: ["bottomLeft"],
    default: ["topRight", "bottomLeft"]
  },
  bottomRight: {
    bottom: ["bottomLeft"],
    right: ["topRight"],
    default: ["bottomLeft", "topRight"]
  },
  bottomLeft: {
    bottom: ["bottomRight"],
    left: ["topLeft"],
    default: ["bottomRight", "topLeft"]
  }
};
class Wn {
  constructor(t, e, i = null) {
    et(this, "x");
    et(this, "y");
    et(this, "z");
    et(this, "a");
    //shape id
    et(this, "b");
    //shape id
    et(this, "direction");
    //direction of the raay
    et(this, "type");
    //[] need to type
    et(this, "corner");
    //originating corner of this point
    et(this, "grid");
    //if a grid point, which grid position
    et(this, "stockID");
    et(this, "raycast");
    et(this, "collision");
    et(this, "tooClose");
    et(this, "adjustedForMinSpacing");
    this.x = parseFloat(t), this.y = parseFloat(e), this.z = parseFloat(i) || 0, this.validate();
  }
  /**
   * clone with the ability to change the coordinates
   * NOTE: looks odd for performance reasons
   */
  clone(t = null, e = null) {
    const i = new Wn(t ?? this.x, e ?? this.y);
    for (const r in this)
      r !== "x" && r !== "y" && (i[r] = this[r]);
    return i;
  }
  validate() {
    if (isNaN(this.x) || isNaN(this.y))
      throw new Error("invalid point coordinates");
  }
  coords() {
    return {
      x: this.x,
      y: this.y
    };
  }
  collidesWith(t) {
    return this.x >= t.x && this.x <= t.x + t.l && this.y >= t.y && this.y <= t.y + t.w;
  }
  isIdenticalTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * given a point from a shape corner or a ray, get the available positions for this shape
   * @returns the position of the shape relative to the point e.g. bottomRight means the shape is placed to the bottom right of the point
   * @remarks does not cater for diagonals
   */
  //[x] needs to cater for raycast coords, which don't originate from a shape corner
  //[x] cater for raycast corners and grid
  getAvailableShapePositions(t) {
    const e = /* @__PURE__ */ new Set();
    if (this.raycast) {
      const i = Ty[this.direction];
      return i && i[this.corner] && i[this.corner][this.grid] && e.add(i[this.corner][this.grid]), e;
    }
    return (t == null ? void 0 : t.cutType) !== "efficiency" ? (ku[this.corner] && (this.grid ? ku[this.corner][this.grid] && ku[this.corner][this.grid].forEach((i) => e.add(i)) : ku[this.corner].default.forEach((i) => e.add(i))), e) : (Au[this.corner] && (this.grid ? Au[this.corner][this.grid] && Au[this.corner][this.grid].forEach((i) => e.add(i)) : Au[this.corner].default.forEach((i) => e.add(i))), e);
  }
}
class Po {
  constructor(t = []) {
    et(this, "points", /* @__PURE__ */ new Map());
    t.forEach((e) => this.addPoint(e));
  }
  addPoint(t, e = null) {
    if (this.contains(t)) {
      const i = this.getPoint(t);
      i.type === "group" && !e && (i.type = void 0);
      return;
    }
    t.validate(), e && (t.type = e), this.points.set(this.createKey(t), t);
  }
  addPoints(t, e = null) {
    for (const i of t) {
      if (!i) return;
      i.validate(), this.addPoint(i, e);
    }
  }
  createKey(t) {
    return `${t.x},${t.y}`;
  }
  getPoint(t) {
    return this.points.get(this.createKey(t));
  }
  deletePoint(t) {
    t.validate(), this.points.delete(this.createKey(t));
  }
  deletePoints(t) {
    for (const e of t)
      e.validate(), this.deletePoint(e);
  }
  clear() {
    this.points.clear();
  }
  toArray() {
    return Array.from(this.points.values());
  }
  contains(t) {
    return this.points.has(this.createKey(t));
  }
}
function Ze(n, t, e, i, r) {
  const s = Fy[n](t, e);
  return i && (s.corner = i), r && (s.direction = r), s;
}
const Fy = {
  bottom: (n, t) => {
    const e = n.clone(n.x, n.y - t);
    return e.grid = "bottom", e;
  },
  bottomLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y - t);
    return e.grid = "bottomLeft", e;
  },
  bottomRight: (n, t) => {
    const e = n.clone(n.x + t, n.y - t);
    return e.grid = "bottomRight", e;
  },
  left: (n, t) => {
    const e = n.clone(n.x - t, n.y);
    return e.grid = "left", e;
  },
  centre: (n) => {
    const t = n.clone(n.x, n.y);
    return t.grid = "centre", t;
  },
  right: (n, t) => {
    const e = n.clone(n.x + t, n.y);
    return e.grid = "right", e;
  },
  top: (n, t) => {
    const e = n.clone(n.x, n.y + t);
    return e.grid = "top", e;
  },
  topLeft: (n, t) => {
    const e = n.clone(n.x - t, n.y + t);
    return e.grid = "topLeft", e;
  },
  topRight: (n, t) => {
    const e = n.clone(n.x + t, n.y + t);
    return e.grid = "topRight", e;
  }
};
function My(n, t, e) {
  var o, a, l, h, u, d;
  const i = new Po(), r = e.toArray().sort(G0), s = t.getBladeWidth();
  if (r.forEach((p) => {
    const f = p.corner, g = p.type;
    if (!s)
      i.addPoint(p);
    else
      switch (f) {
        case "topRight":
          i.addPoint(
            Ze("top", p, s, f),
            g
          ), i.addPoint(
            Ze("right", p, s, f),
            g
          );
          break;
        case "topLeft":
          i.addPoint(
            Ze("top", p, s, f),
            g
          ), i.addPoint(
            Ze("left", p, s, f),
            g
          );
          break;
        case "bottomRight":
          i.addPoint(
            Ze("bottom", p, s, f),
            g
          ), i.addPoint(
            Ze("right", p, s, f),
            g
          );
          break;
        case "bottomLeft":
          i.addPoint(
            Ze("bottom", p, s, f),
            g
          ), i.addPoint(
            Ze("left", p, s, f),
            g
          );
          break;
      }
    const y = i.toArray();
    if (s)
      for (let _ = y.length; _--; ) {
        const b = y[_];
        e.contains(b) && i.deletePoint(b);
      }
    else
      for (let _ = y.length; _--; ) {
        const b = y[_];
        for (let v = n.length; v--; ) {
          const A = n[v];
          if (b.x === A.x && b.y === A.y) {
            i.deletePoint(b);
            break;
          }
        }
      }
  }), s) {
    const p = /* @__PURE__ */ new Set();
    let f, g, y, _;
    ((o = t == null ? void 0 : t.constructor) == null ? void 0 : o.name) === "Stock" && (t != null && t.trimmed) || ((a = t == null ? void 0 : t.constructor) == null ? void 0 : a.name) === "Segment" ? (f = t.x, g = t.y, y = t.x + t.l, _ = t.y + t.w) : (f = t.x + ((l = t == null ? void 0 : t.trim) == null ? void 0 : l.x1), g = t.y + ((h = t == null ? void 0 : t.trim) == null ? void 0 : h.y1), y = t.x + t.l - ((u = t == null ? void 0 : t.trim) == null ? void 0 : u.x2), _ = t.y + t.w - ((d = t == null ? void 0 : t.trim) == null ? void 0 : d.y2));
    let b = i.toArray();
    for (let v = b.length; v--; ) {
      const A = b[v];
      (Ve.lessThan(A.x, f) || Ve.lessThan(A.y, g) || Ve.greaterThan(A.x, y) || Ve.greaterThan(A.y, _)) && b.splice(v, 1);
    }
    i.clear(), i.addPoints(b), p.clear(), b = i.toArray();
    for (let v = b.length; v--; ) {
      const A = b[v];
      for (let L = n.length; L--; ) {
        const O = n[L];
        if (A.collidesWith(O)) {
          i.deletePoint(A);
          break;
        }
      }
    }
  }
  return i;
}
function Ry(n, t, e) {
  let i = [];
  const r = n.getMinSpacing(e), s = t.corner, o = t.direction;
  if (t.type === "shape")
    switch (s) {
      case "topLeft":
        o === "rl" && (i.push(Ze("right", t, r, s, o)), i.push(Ze("topRight", t, r, s, o))), o === "bt" && (i.push(Ze("bottom", t, r, s, o)), i.push(Ze("bottomLeft", t, r, s, o)));
        break;
      case "topRight":
        o === "lr" && (i.push(Ze("left", t, r, s, o)), i.push(Ze("topLeft", t, r, s, o))), o === "bt" && (i.push(Ze("bottom", t, r, s, o)), i.push(Ze("bottomRight", t, r, s, o)));
        break;
      case "bottomRight":
        o === "lr" && (i.push(Ze("left", t, r, s, o)), i.push(Ze("bottomLeft", t, r, s, o))), o === "tb" && (i.push(Ze("top", t, r, s, o)), i.push(Ze("topRight", t, r, s, o)));
        break;
      case "bottomLeft":
        o === "rl" && (i.push(Ze("right", t, r, s, o)), i.push(Ze("bottomRight", t, r, s, o))), o === "tb" && (i.push(Ze("top", t, r, s, o)), i.push(Ze("topLeft", t, r, s, o)));
        break;
    }
  else if (t.type === "edge")
    switch (o) {
      case "rl":
      case "lr":
        i.push(Ze("top", t, 0)), i.push(Ze("centre", t, 0)), i.push(Ze("bottom", t, 0));
        break;
      case "tb":
      case "bt":
        i.push(Ze("left", t, 0)), i.push(Ze("right", t, 0)), i.push(Ze("centre", t, 0));
        break;
    }
  if (i = i.filter((l) => l.x >= 0 && l.y >= 0), !i.length) return null;
  const a = new Po();
  for (const l of i)
    l.raycast = !0, a.addPoints(K0(n, l, e).toArray());
  return X0(n, e, a), a;
}
function Dy(n, t) {
  const e = new Po();
  return n.sort(G0), n.forEach((i) => {
    Pr(i) ? (e.addPoints(i.getCoords(t)), i.shapes.forEach((r) => {
      const s = r.getCoords(t);
      e.addPoints(s, "group");
    })) : e.addPoints(i.getCoords(t));
  }), e.points.forEach((i) => {
    i.stockID = t.getStock().id;
  }), e;
}
function By(n = [], t, e) {
  const i = Dy(
    n === null ? t : n,
    e
  );
  return My(
    t,
    e,
    i
  );
}
function G0(n, t) {
  return n.y === t.y ? t.x - n.x : t.y - n.y;
}
function V0(n, t, e, i, r, s) {
  n.a = t.id, n.b = e ? e.id : null, n.direction = i, n.raycast = !0, n.type = r, n.corner = s;
}
function jy(n, t) {
  if (n.saw.cutType !== "efficiency" || t.length <= 1) return null;
  let e = new Po();
  const i = Y0(t, n);
  for (const a of t)
    for (const l of i) {
      if (l.shape.id === a.id) continue;
      const h = Object.values(l.rays);
      for (const u of h)
        qy(
          u,
          l.shape,
          a,
          e
        );
    }
  const s = n.saw.efficiencyOptions.primaryCompression === "x" ? "lr" : "tb", o = t.reduce((a, l) => (s === "tb" ? a.x + a.l > l.x + l.l : a.y + a.w > l.y + l.w) ? a : l);
  return i.filter(({ shape: a }) => a.id === o.id).forEach(({ shape: a, rays: l }) => {
    const h = Object.values(l);
    for (const u of h) {
      const d = new Wn(u.x2, u.y2);
      s === u.direction && (V0(d, a, null, u.direction, "edge"), e.addPoint(d));
    }
  }), e = zy(e), e;
}
function Y0(n, t) {
  return n.map((e) => {
    const i = J2(e, t);
    return {
      shape: e,
      rays: i
    };
  });
}
function qy(n, t, e, i) {
  switch (n.direction) {
    case "rl":
      Nu(
        n,
        t,
        e,
        i,
        e.x + e.l
      );
      break;
    case "lr":
      Nu(
        n,
        t,
        e,
        i,
        e.x
      );
      break;
    case "tb":
      Nu(
        n,
        t,
        e,
        i,
        e.y + e.w
      );
      break;
    case "bt":
      Nu(
        n,
        t,
        e,
        i,
        e.y
      );
      break;
  }
}
function Nu(n, t, e, i, r) {
  const s = n.dimension === "w", o = s ? "y" : "x", a = s ? "x" : "y", l = s ? "l" : "w";
  if (n[`${a}1`] >= e[a] && n[`${a}1`] <= e[a] + e[l]) {
    const h = n.direction === "lr" && n[`${o}1`] <= r && n[`${o}2`] >= r, u = n.direction === "rl" && n[`${o}1`] >= r && n[`${o}2`] <= r, d = n.direction === "bt" && n[`${o}1`] <= r && n[`${o}2`] >= r, p = n.direction === "tb" && n[`${o}1`] >= r && n[`${o}2`] <= r;
    if (h || u || d || p) {
      const g = s ? n[`${a}1`] : r, y = s ? r : n[`${a}1`], _ = new Wn(g, y), b = n.origin;
      V0(_, t, e, n.direction, "shape", b), i.addPoint(_);
    }
  }
}
function zy(n) {
  const t = new Po();
  return n.points.size === 0 || new Set(n.toArray().map((i) => i.a)).forEach((i) => {
    const r = n.toArray().filter((s) => s.a === i);
    ["right", "left", "top", "bottom"].forEach((s) => {
      const o = $y(
        r,
        s
      );
      o && t.addPoint(o);
    });
  }), t;
}
function $y(n, t) {
  return n.length === 0 ? null : n.reduce((e, i) => {
    switch (t) {
      case "left":
        return !e || i.x < e.x ? i : e;
      case "right":
        return !e || i.x > e.x ? i : e;
      case "top":
        return !e || i.y > e.y ? i : e;
      case "bottom":
        return !e || i.y < e.y ? i : e;
      default:
        return null;
    }
  }, null);
}
function K0(n, t, e) {
  const i = new Po(), r = t.getAvailableShapePositions(e);
  for (const s of r) {
    let o;
    switch (o = Uy(t, n, e), s) {
      case "bottomLeft":
        o = o.clone(o.x - n.l, o.y - n.w), o.shapePosition = "bottomLeft";
        break;
      case "bottomRight":
        o = o.clone(o.x, o.y - n.w), o.shapePosition = "bottomRight";
        break;
      case "topLeft":
        o = o.clone(o.x - n.l, o.y), o.shapePosition = "topLeft";
        break;
      case "topRight":
        o = o.clone(o.x, o.y), o.shapePosition = "topRight";
        break;
    }
    i.addPoint(o);
  }
  return X0(n, e, i), i;
}
function Uy(n, t, e) {
  if (e.saw.cutType !== "efficiency") return n;
  const i = t.getMinSpacing(e), r = e.getBladeWidth();
  if (!i || i === r) return n;
  let s;
  if (!n.grid) return n;
  switch (n.grid) {
    case "bottom":
      s = n.clone(n.x, n.y - i + r);
      break;
    case "top":
      s = n.clone(n.x, n.y + i - r);
      break;
    case "left":
      s = n.clone(n.x - i + r, n.y);
      break;
    case "right":
      s = n.clone(n.x + i - r, n.y);
      break;
  }
  return s ? (s.x < 0 && (s.x = 0), s.y < 0 && (s.y = 0), s.adjustedForMinSpacing = !0, s) : n;
}
function X0(n, t, e) {
  var l, h, u, d, p, f;
  let i, r, s, o;
  ((l = t == null ? void 0 : t.constructor) == null ? void 0 : l.name) === "Stock" && (t != null && t.trimmed) || ((h = t == null ? void 0 : t.constructor) == null ? void 0 : h.name) === "Segment" ? (i = 0, r = 0, s = t.x + t.l - n.l, o = t.y + t.w - n.w) : (i = (u = t == null ? void 0 : t.trim) == null ? void 0 : u.x1, r = (d = t == null ? void 0 : t.trim) == null ? void 0 : d.y1, s = t.l - ((p = t == null ? void 0 : t.trim) == null ? void 0 : p.x2) - n.l, o = t.w - ((f = t == null ? void 0 : t.trim) == null ? void 0 : f.y2) - n.w);
  const a = e.toArray();
  for (let g = a.length; g--; ) {
    const y = a[g];
    (Ve.lessThan(y.x, i) || Ve.lessThan(y.y, r) || Ve.greaterThan(y.x, s) || Ve.greaterThan(y.y, o) || y.x < 0 || y.y < 0) && e.deletePoint(y);
  }
}
/**
* @license Fraction.js v4.3.7 31/08/2023
* https://www.xarg.org/2014/03/rational-numbers-in-javascript/
*
* Copyright (c) 2023, Robert Eisele (robert@raw.org)
* Dual licensed under the MIT or GPL Version 2 licenses.
**/
var Wy = 2e3, ge = {
  s: 1,
  n: 0,
  d: 1
};
function Qr(n, t) {
  if (isNaN(n = parseInt(n, 10)))
    throw $u();
  return n * t;
}
function mn(n, t) {
  if (t === 0)
    throw gd();
  var e = Object.create(Es.prototype);
  e.s = n < 0 ? -1 : 1, n = n < 0 ? -n : n;
  var i = ba(n, t);
  return e.n = n / i, e.d = t / i, e;
}
function Op(n) {
  for (var t = {}, e = n, i = 2, r = 4; r <= e; ) {
    for (; e % i === 0; )
      e /= i, t[i] = (t[i] || 0) + 1;
    r += 1 + 2 * i++;
  }
  return e !== n ? e > 1 && (t[e] = (t[e] || 0) + 1) : t[n] = (t[n] || 0) + 1, t;
}
var Fi = function(n, t) {
  var e = 0, i = 1, r = 1, s = 0, o = 0, a = 0, l = 1, h = 1, u = 0, d = 1, p = 1, f = 1, g = 1e7, y;
  if (n != null) if (t !== void 0) {
    if (e = n, i = t, r = e * i, e % 1 !== 0 || i % 1 !== 0)
      throw Yy();
  } else
    switch (typeof n) {
      case "object": {
        if ("d" in n && "n" in n)
          e = n.n, i = n.d, "s" in n && (e *= n.s);
        else if (0 in n)
          e = n[0], 1 in n && (i = n[1]);
        else
          throw $u();
        r = e * i;
        break;
      }
      case "number": {
        if (n < 0 && (r = n, n = -n), n % 1 === 0)
          e = n;
        else if (n > 0) {
          for (n >= 1 && (h = Math.pow(10, Math.floor(1 + Math.log(n) / Math.LN10)), n /= h); d <= g && f <= g; )
            if (y = (u + p) / (d + f), n === y) {
              d + f <= g ? (e = u + p, i = d + f) : f > d ? (e = p, i = f) : (e = u, i = d);
              break;
            } else
              n > y ? (u += p, d += f) : (p += u, f += d), d > g ? (e = p, i = f) : (e = u, i = d);
          e *= h;
        } else (isNaN(n) || isNaN(t)) && (i = e = NaN);
        break;
      }
      case "string": {
        if (d = n.match(/\d+|./g), d === null)
          throw $u();
        if (d[u] === "-" ? (r = -1, u++) : d[u] === "+" && u++, d.length === u + 1 ? o = Qr(d[u++], r) : d[u + 1] === "." || d[u] === "." ? (d[u] !== "." && (s = Qr(d[u++], r)), u++, (u + 1 === d.length || d[u + 1] === "(" && d[u + 3] === ")" || d[u + 1] === "'" && d[u + 3] === "'") && (o = Qr(d[u], r), l = Math.pow(10, d[u].length), u++), (d[u] === "(" && d[u + 2] === ")" || d[u] === "'" && d[u + 2] === "'") && (a = Qr(d[u + 1], r), h = Math.pow(10, d[u + 1].length) - 1, u += 3)) : d[u + 1] === "/" || d[u + 1] === ":" ? (o = Qr(d[u], r), l = Qr(d[u + 2], 1), u += 3) : d[u + 3] === "/" && d[u + 1] === " " && (s = Qr(d[u], r), o = Qr(d[u + 2], r), l = Qr(d[u + 4], 1), u += 5), d.length <= u) {
          i = l * h, r = /* void */
          e = a + i * s + h * o;
          break;
        }
      }
      default:
        throw $u();
    }
  if (i === 0)
    throw gd();
  ge.s = r < 0 ? -1 : 1, ge.n = Math.abs(e), ge.d = Math.abs(i);
};
function Hy(n, t, e) {
  for (var i = 1; t > 0; n = n * n % e, t >>= 1)
    t & 1 && (i = i * n % e);
  return i;
}
function Gy(n, t) {
  for (; t % 2 === 0; t /= 2)
    ;
  for (; t % 5 === 0; t /= 5)
    ;
  if (t === 1)
    return 0;
  for (var e = 10 % t, i = 1; e !== 1; i++)
    if (e = e * 10 % t, i > Wy)
      return 0;
  return i;
}
function Vy(n, t, e) {
  for (var i = 1, r = Hy(10, e, t), s = 0; s < 300; s++) {
    if (i === r)
      return s;
    i = i * 10 % t, r = r * 10 % t;
  }
  return 0;
}
function ba(n, t) {
  if (!n)
    return t;
  if (!t)
    return n;
  for (; ; ) {
    if (n %= t, !n)
      return t;
    if (t %= n, !t)
      return n;
  }
}
function Es(n, t) {
  if (Fi(n, t), this instanceof Es)
    n = ba(ge.d, ge.n), this.s = ge.s, this.n = ge.n / n, this.d = ge.d / n;
  else
    return mn(ge.s * ge.n, ge.d);
}
var gd = function() {
  return new Error("Division by Zero");
}, $u = function() {
  return new Error("Invalid argument");
}, Yy = function() {
  return new Error("Parameters must be integer");
};
Es.prototype = {
  s: 1,
  n: 0,
  d: 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  abs: function() {
    return mn(this.n, this.d);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  neg: function() {
    return mn(-this.s * this.n, this.d);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  add: function(n, t) {
    return Fi(n, t), mn(
      this.s * this.n * ge.d + ge.s * this.d * ge.n,
      this.d * ge.d
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  sub: function(n, t) {
    return Fi(n, t), mn(
      this.s * this.n * ge.d - ge.s * this.d * ge.n,
      this.d * ge.d
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  mul: function(n, t) {
    return Fi(n, t), mn(
      this.s * ge.s * this.n * ge.n,
      this.d * ge.d
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  div: function(n, t) {
    return Fi(n, t), mn(
      this.s * ge.s * this.n * ge.d,
      this.d * ge.n
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  clone: function() {
    return mn(this.s * this.n, this.d);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  mod: function(n, t) {
    if (isNaN(this.n) || isNaN(this.d))
      return new Es(NaN);
    if (n === void 0)
      return mn(this.s * this.n % this.d, 1);
    if (Fi(n, t), ge.n === 0 && this.d === 0)
      throw gd();
    return mn(
      this.s * (ge.d * this.n) % (ge.n * this.d),
      ge.d * this.d
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  gcd: function(n, t) {
    return Fi(n, t), mn(ba(ge.n, this.n) * ba(ge.d, this.d), ge.d * this.d);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  lcm: function(n, t) {
    return Fi(n, t), ge.n === 0 && this.n === 0 ? mn(0, 1) : mn(ge.n * this.n, ba(ge.n, this.n) * ba(ge.d, this.d));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  ceil: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Es(NaN) : mn(Math.ceil(n * this.s * this.n / this.d), n);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  floor: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Es(NaN) : mn(Math.floor(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  round: function(n) {
    return n = Math.pow(10, n || 0), isNaN(this.n) || isNaN(this.d) ? new Es(NaN) : mn(Math.round(n * this.s * this.n / this.d), n);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  roundTo: function(n, t) {
    return Fi(n, t), mn(this.s * Math.round(this.n * ge.d / (this.d * ge.n)) * ge.n, ge.d);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  inverse: function() {
    return mn(this.s * this.d, this.n);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  pow: function(n, t) {
    if (Fi(n, t), ge.d === 1)
      return ge.s < 0 ? mn(Math.pow(this.s * this.d, ge.n), Math.pow(this.n, ge.n)) : mn(Math.pow(this.s * this.n, ge.n), Math.pow(this.d, ge.n));
    if (this.s < 0) return null;
    var e = Op(this.n), i = Op(this.d), r = 1, s = 1;
    for (var o in e)
      if (o !== "1") {
        if (o === "0") {
          r = 0;
          break;
        }
        if (e[o] *= ge.n, e[o] % ge.d === 0)
          e[o] /= ge.d;
        else return null;
        r *= Math.pow(o, e[o]);
      }
    for (var o in i)
      if (o !== "1") {
        if (i[o] *= ge.n, i[o] % ge.d === 0)
          i[o] /= ge.d;
        else return null;
        s *= Math.pow(o, i[o]);
      }
    return ge.s < 0 ? mn(s, r) : mn(r, s);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  equals: function(n, t) {
    return Fi(n, t), this.s * this.n * ge.d === ge.s * ge.n * this.d;
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  compare: function(n, t) {
    Fi(n, t);
    var e = this.s * this.n * ge.d - ge.s * ge.n * this.d;
    return (0 < e) - (e < 0);
  },
  simplify: function(n) {
    if (isNaN(this.n) || isNaN(this.d))
      return this;
    n = n || 1e-3;
    for (var t = this.abs(), e = t.toContinued(), i = 1; i < e.length; i++) {
      for (var r = mn(e[i - 1], 1), s = i - 2; s >= 0; s--)
        r = r.inverse().add(e[s]);
      if (Math.abs(r.sub(t).valueOf()) < n)
        return r.mul(this.s);
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  divisible: function(n, t) {
    return Fi(n, t), !(!(ge.n * this.d) || this.n * ge.d % (ge.n * this.d));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  valueOf: function() {
    return this.s * this.n / this.d;
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  toFraction: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, e += " ", i %= r), e += i, e += "/", e += r), e;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  toLatex: function(n) {
    var t, e = "", i = this.n, r = this.d;
    return this.s < 0 && (e += "-"), r === 1 ? e += i : (n && (t = Math.floor(i / r)) > 0 && (e += t, i %= r), e += "\\frac{", e += i, e += "}{", e += r, e += "}"), e;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  toContinued: function() {
    var n, t = this.n, e = this.d, i = [];
    if (isNaN(t) || isNaN(e))
      return i;
    do
      i.push(Math.floor(t / e)), n = t % e, t = e, e = n;
    while (t !== 1);
    return i;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  toString: function(n) {
    var t = this.n, e = this.d;
    if (isNaN(t) || isNaN(e))
      return "NaN";
    n = n || 15;
    var i = Gy(t, e), r = Vy(t, e, i), s = this.s < 0 ? "-" : "";
    if (s += t / e | 0, t %= e, t *= 10, t && (s += "."), i) {
      for (var o = r; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += "(";
      for (var o = i; o--; )
        s += t / e | 0, t %= e, t *= 10;
      s += ")";
    } else
      for (var o = n; t && o--; )
        s += t / e | 0, t %= e, t *= 10;
    return s;
  }
};
function Ky(n) {
  if (!n) return null;
  if (n = n.toString().trim(), typeof navigator > "u" || typeof navigator.language > "u")
    return parseFloat(n);
  const { thousandsSeparator: t, decimalSeparator: e } = Xy();
  return n = Array.from(n, (i) => i === t ? "" : i === e ? "." : i).join(""), parseFloat(n);
}
function Xy() {
  const n = navigator.language, t = 123456789e-2.toLocaleString(n), e = t.replace(/\d/g, ""), i = Array.from(new Set(e.split("")));
  let r = "", s = "";
  if (i.length === 1)
    s = i[0];
  else if (i.length === 2) {
    const o = t[t.length - 3];
    i.includes(o) ? (s = o, r = i.find((a) => a !== o)) : (s = i[1], r = i[0]);
  }
  return { thousandsSeparator: r, decimalSeparator: s };
}
function J0(n) {
  if (!n || typeof n == "number") return !1;
  n = n.toString().replace(/[^0-9/ ]/g, "");
  const t = /\b\d+\/\d+\b/g;
  return n.match(t);
}
function Jy(n, t = !1) {
  if (!jt(n)) return null;
  if (n === 0) return "0";
  let e = n.toString().trim();
  if (!e) return null;
  if (J0(n))
    return e = e.replace(/[^0-9/,. -]/g, "").replace(/  +/g, " "), e;
  {
    e = e.replace(/[^0-9,. -]/g, ""), e.startsWith(".") && (e = "0" + e);
    let i;
    return t ? i = Ky(e) : i = parseFloat(e), i ? i.toString() : null;
  }
}
function ll(n) {
  let t;
  try {
    t = new Es(n);
  } catch {
    console.log(`issue parsing ${n} to new Fraction()`), t = 0;
  }
  return t;
}
function te(n, t = "decimal", e = !1, i = !1, r = 0) {
  if (!jt(n) || !t) return null;
  if (t !== "decimal" && t !== "fraction")
    return console.error("incorrect conversion type specified for convertUnit"), null;
  try {
    const s = Jy(n, i);
    if (!s) return 0;
    let o;
    if (t === "fraction")
      if (J0(s))
        o = ll(s);
      else {
        const a = parseFloat(s);
        Number.isInteger(a) ? o = ll(s) : o = ll(a);
      }
    else o = ll(s);
    switch (t) {
      case "fraction":
        if (r > 0) {
          const a = o.valueOf(), l = Math.round(a * r) / r;
          o = ll(l);
        }
        return o.toFraction(!0);
      case "decimal":
        if (e === !1 || typeof e != "number")
          return o.valueOf();
        {
          const a = o.valueOf();
          return a === 0 ? 0 : parseFloat(a.toFixed(e));
        }
      default:
        return 0;
    }
  } catch (s) {
    return console.error(s), 0;
  }
}
function Zy(n) {
  let t = n;
  return typeof n != "number" && (t = parseFloat(n)), t % 1 !== 0;
}
const ai = {
  customData: (n, t = null) => {
    const e = [];
    return typeof n != "object" ? (e.push({ message: "Custom data must be an object." }), e) : (Object.entries(n).forEach(([i, r]) => {
      jt(r) && (["string", "number", "boolean"].includes(typeof r) || e.push({
        message: `Custom data ${i} must be a string, number or boolean.`,
        index: t
      }));
    }), e);
  },
  banding: (n, t = null) => {
    const e = [];
    if (!jt(n)) return [];
    if (typeof n != "object")
      return e.push({
        message: "Banding must be an object.",
        field: ["banding"],
        index: t
      }), e;
    Object.entries(n).forEach(([i, r]) => {
      jt(r) && r !== !0 && r !== !1 && e.push({
        message: `Banding ${i} must be a boolean.`,
        field: ["banding"],
        index: t
      });
    });
  },
  //when trim provided as number
  partTrim(n, t, e = null) {
    t = te(t);
    const i = te(n.l), r = te(n.w), s = i - t * 2, o = r - t * 2;
    return s < 0 || o < 0 ? [
      {
        message: `When applying trim of ${t}, part is ${s} x ${o}.`,
        field: ["trim"],
        index: e
      }
    ] : [];
  },
  //when trim provided as object
  trim: (n, t = null) => {
    const e = [];
    if (!jt(n.trim)) return e;
    if (mr.forEach((i) => {
      jt(n.trim[i]) || (n.trim[i] = 0);
    }), !ns(n) || ns(n) && !(n != null && n.trimmed)) {
      const i = ["l", "w"], [r, s] = i.map((d) => te(n[d])), [o, a, l, h] = mr.map((d) => te(n.trim[d]));
      Object.entries({ x1: o, x2: a, y1: l, y2: h }).forEach(([d, p]) => {
        isNaN(p) && e.push({
          message: `The value of trim ${of[d]} is not understood.`,
          field: ["trim"],
          index: t
        });
      }), r && s && r > 0 && s > 0 && (o + a >= n.l && e.push({
        message: `Trim W1 + W2 = ${o + a}, which is greater than or equal to total length of ${r}.`,
        field: ["trim"],
        subField: ["x1", "x2"],
        index: t
      }), l + h >= n.w && e.push({
        message: `Trim L1 + L2 = ${l + h}, which is greater than or equal to total width of ${s}.`,
        field: ["trim"],
        subField: ["y1", "y2"],
        index: t
      }));
    }
    return e;
  },
  x: (n, t = null) => {
    const e = [];
    return jt(n) ? (n = te(n), isNaN(n) ? (e.push({ message: `X value is not understood, got ${n}`, index: t }), e) : (n < 0 && e.push({ message: `X must be greater than or equal to zero, got ${n}` }), e)) : e;
  },
  y: (n, t = null) => {
    const e = [];
    return jt(n) && (n = te(n), isNaN(n) && e.push({ message: `Y value is not understood, got ${n}`, index: t }), n < 0 && e.push({ message: `Y must be greater than or equal to zero, got ${n}`, index: t })), e;
  },
  l: (n, t = null, e = 0) => {
    const i = [];
    return jt(n) ? (n = te(n), isNaN(n) ? (i.push({
      message: `Length value is not understood, got ${n}`,
      field: ["l"],
      index: t
    }), i) : (n < e && i.push({
      message: `Length must be greater than or equal to ${e}, got ${n}`,
      field: ["l"],
      index: t
    }), i)) : (i.push({
      message: "Length is required.",
      field: ["l"],
      index: t
    }), i);
  },
  w: (n, t = null, e = 0) => {
    const i = [];
    return jt(n) ? (n = te(n), isNaN(n) ? (i.push({
      message: `Width value is not understood, got ${n}`,
      field: ["w"],
      index: t
    }), i) : (n < e && i.push({
      message: `Width must be greater than or equal to ${e}, got ${n}`,
      field: ["w"],
      index: t
    }), i)) : (i.push({
      message: "Width is required.",
      field: ["w"],
      index: t
    }), i);
  },
  t: (n, t = null) => {
    const e = [];
    return !jt(n) || n === "" ? e : (n = te(n), isNaN(n) ? (e.push({
      message: `Thickness value is not understood, got ${n}`,
      field: ["t"],
      index: t
    }), e) : (n && n <= 0 && e.push({
      message: `Thickness must be greater than zero, got ${n}`,
      field: ["t"],
      index: t
    }), e));
  },
  q: (n, t = null, e = null) => {
    const i = [];
    return jt(n) ? (n = parseInt(n), isNaN(n) ? (i.push({
      message: `Quantity value is not understood, got ${n}`,
      field: ["q"],
      index: e
    }), i) : (Zy(n) && i.push({
      message: "Quantity should be an integer.",
      field: ["q"],
      index: e
    }), n <= 0 && (t || i.push({
      message: `Quantity should be greater than or equal to zero, got ${n}`,
      field: ["q"],
      index: e
    })), i)) : (i.push({
      message: "Quantity should be set.",
      field: ["q"],
      index: e
    }), i);
  },
  orientationLock: (n, t = null) => {
    const e = [];
    return jt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Orientation lock must be l or w, got ${n}`,
      field: ["orientationLock"],
      index: t
    })), e;
  },
  grain: (n, t = null) => {
    const e = [];
    return jt(n) && (n = n.toLowerCase(), n !== "l" && n !== "w" && e.push({
      message: `Grain must be l or w, got ${n}`,
      index: t
    })), e;
  },
  stockMatch: (n, t, e, i = 0, r = null) => {
    if (!n.q) return [];
    if (n.applyPartTrim(i), n.issues.length) return [];
    const s = Gb([n], t, e);
    if (!s) return [];
    const o = [];
    if (s.unusableShapes.length) {
      const a = s.unusableShapes[0], l = a.stockMatch;
      if (!l.fit) {
        const h = a.getTrimmedDimensions();
        o.push({
          message: `${h.l.toFixed(0)}x${h.w.toFixed(0)} will not fit on any stock - check trim, dimensions & orientation lock.`,
          field: ["l", "w"],
          index: r
        });
      }
      l.material || o.push({
        message: "No matching stock material found.",
        field: ["material"],
        index: r
      }), l.thickness || o.push({
        message: "No matching stock thickness found.",
        field: ["t"],
        index: r
      }), !l.width && e === "linear" && o.push({
        message: "No matching stock width found - required for linear calculations.",
        field: ["w"],
        index: r
      });
    }
    return o;
  },
  machining: (n, t = null) => {
    n.machining.validateEverything(n, t);
  }
};
function rf(n) {
  let t, e;
  switch (n) {
    case "l":
    case "length":
      t = "guillotine", e = "l";
      break;
    case "w":
    case "width":
      t = "guillotine", e = "w";
      break;
    case "flex":
      t = "guillotine", e = "flex";
      break;
    case "efficiency":
      t = "efficiency", e = "none";
      break;
    case "beam":
      t = "beam", e = "l";
      break;
    default:
      t = null, e = null;
      break;
  }
  return {
    cutPreference: e,
    cutType: t
  };
}
var Z0 = typeof global == "object" && global && global.Object === Object && global, Qy = typeof self == "object" && self && self.Object === Object && self, md = Z0 || Qy || Function("return this")(), sc = md.Symbol, Q0 = Object.prototype, t5 = Q0.hasOwnProperty, e5 = Q0.toString, ul = sc ? sc.toStringTag : void 0;
function n5(n) {
  var t = t5.call(n, ul), e = n[ul];
  try {
    n[ul] = void 0;
    var i = !0;
  } catch {
  }
  var r = e5.call(n);
  return i && (t ? n[ul] = e : delete n[ul]), r;
}
var i5 = Object.prototype, r5 = i5.toString;
function s5(n) {
  return r5.call(n);
}
var o5 = "[object Null]", a5 = "[object Undefined]", Tp = sc ? sc.toStringTag : void 0;
function yd(n) {
  return n == null ? n === void 0 ? a5 : o5 : Tp && Tp in Object(n) ? n5(n) : s5(n);
}
function bd(n) {
  return n != null && typeof n == "object";
}
var l5 = Array.isArray;
function Mc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
function t1(n) {
  return n;
}
var u5 = "[object AsyncFunction]", c5 = "[object Function]", h5 = "[object GeneratorFunction]", f5 = "[object Proxy]";
function e1(n) {
  if (!Mc(n))
    return !1;
  var t = yd(n);
  return t == c5 || t == h5 || t == u5 || t == f5;
}
var xh = md["__core-js_shared__"], Fp = function() {
  var n = /[^.]+$/.exec(xh && xh.keys && xh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function d5(n) {
  return !!Fp && Fp in n;
}
var p5 = Function.prototype, g5 = p5.toString;
function m5(n) {
  if (n != null) {
    try {
      return g5.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var y5 = /[\\^$.*+?()[\]{}|]/g, b5 = /^\[object .+?Constructor\]$/, v5 = Function.prototype, w5 = Object.prototype, x5 = v5.toString, _5 = w5.hasOwnProperty, S5 = RegExp(
  "^" + x5.call(_5).replace(y5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function k5(n) {
  if (!Mc(n) || d5(n))
    return !1;
  var t = e1(n) ? S5 : b5;
  return t.test(m5(n));
}
function A5(n, t) {
  return n == null ? void 0 : n[t];
}
function N5(n, t) {
  var e = A5(n, t);
  return k5(e) ? e : void 0;
}
function C5(n, t, e) {
  switch (e.length) {
    case 0:
      return n.call(t);
    case 1:
      return n.call(t, e[0]);
    case 2:
      return n.call(t, e[0], e[1]);
    case 3:
      return n.call(t, e[0], e[1], e[2]);
  }
  return n.apply(t, e);
}
var P5 = 800, L5 = 16, I5 = Date.now;
function E5(n) {
  var t = 0, e = 0;
  return function() {
    var i = I5(), r = L5 - (i - e);
    if (e = i, r > 0) {
      if (++t >= P5)
        return arguments[0];
    } else
      t = 0;
    return n.apply(void 0, arguments);
  };
}
function O5(n) {
  return function() {
    return n;
  };
}
var Mp = function() {
  try {
    var n = N5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), T5 = Mp ? function(n, t) {
  return Mp(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: O5(t),
    writable: !0
  });
} : t1, F5 = E5(T5), M5 = 9007199254740991, R5 = /^(?:0|[1-9]\d*)$/;
function n1(n, t) {
  var e = typeof n;
  return t = t ?? M5, !!t && (e == "number" || e != "symbol" && R5.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function i1(n, t) {
  return n === t || n !== n && t !== t;
}
var Rp = Math.max;
function D5(n, t, e) {
  return t = Rp(t === void 0 ? n.length - 1 : t, 0), function() {
    for (var i = arguments, r = -1, s = Rp(i.length - t, 0), o = Array(s); ++r < s; )
      o[r] = i[t + r];
    r = -1;
    for (var a = Array(t + 1); ++r < t; )
      a[r] = i[r];
    return a[t] = e(o), C5(n, this, a);
  };
}
function B5(n, t) {
  return F5(D5(n, t, t1), n + "");
}
var j5 = 9007199254740991;
function r1(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= j5;
}
function s1(n) {
  return n != null && r1(n.length) && !e1(n);
}
function q5(n, t, e) {
  if (!Mc(e))
    return !1;
  var i = typeof t;
  return (i == "number" ? s1(e) && n1(t, e.length) : i == "string" && t in e) ? i1(e[t], n) : !1;
}
var z5 = Object.prototype;
function $5(n) {
  var t = n && n.constructor, e = typeof t == "function" && t.prototype || z5;
  return n === e;
}
function U5(n, t) {
  for (var e = -1, i = Array(n); ++e < n; )
    i[e] = t(e);
  return i;
}
var W5 = "[object Arguments]";
function Dp(n) {
  return bd(n) && yd(n) == W5;
}
var o1 = Object.prototype, H5 = o1.hasOwnProperty, G5 = o1.propertyIsEnumerable, V5 = Dp(/* @__PURE__ */ function() {
  return arguments;
}()) ? Dp : function(n) {
  return bd(n) && H5.call(n, "callee") && !G5.call(n, "callee");
};
function Y5() {
  return !1;
}
var a1 = typeof exports == "object" && exports && !exports.nodeType && exports, Bp = a1 && typeof module == "object" && module && !module.nodeType && module, K5 = Bp && Bp.exports === a1, jp = K5 ? md.Buffer : void 0, X5 = jp ? jp.isBuffer : void 0, J5 = X5 || Y5, Z5 = "[object Arguments]", Q5 = "[object Array]", tb = "[object Boolean]", eb = "[object Date]", nb = "[object Error]", ib = "[object Function]", rb = "[object Map]", sb = "[object Number]", ob = "[object Object]", ab = "[object RegExp]", lb = "[object Set]", ub = "[object String]", cb = "[object WeakMap]", hb = "[object ArrayBuffer]", fb = "[object DataView]", db = "[object Float32Array]", pb = "[object Float64Array]", gb = "[object Int8Array]", mb = "[object Int16Array]", yb = "[object Int32Array]", bb = "[object Uint8Array]", vb = "[object Uint8ClampedArray]", wb = "[object Uint16Array]", xb = "[object Uint32Array]", fn = {};
fn[db] = fn[pb] = fn[gb] = fn[mb] = fn[yb] = fn[bb] = fn[vb] = fn[wb] = fn[xb] = !0;
fn[Z5] = fn[Q5] = fn[hb] = fn[tb] = fn[fb] = fn[eb] = fn[nb] = fn[ib] = fn[rb] = fn[sb] = fn[ob] = fn[ab] = fn[lb] = fn[ub] = fn[cb] = !1;
function _b(n) {
  return bd(n) && r1(n.length) && !!fn[yd(n)];
}
function Sb(n) {
  return function(t) {
    return n(t);
  };
}
var l1 = typeof exports == "object" && exports && !exports.nodeType && exports, _l = l1 && typeof module == "object" && module && !module.nodeType && module, kb = _l && _l.exports === l1, _h = kb && Z0.process, qp = function() {
  try {
    var n = _l && _l.require && _l.require("util").types;
    return n || _h && _h.binding && _h.binding("util");
  } catch {
  }
}(), zp = qp && qp.isTypedArray, Ab = zp ? Sb(zp) : _b;
function Nb(n, t) {
  var e = l5(n), i = !e && V5(n), r = !e && !i && J5(n), s = !e && !i && !r && Ab(n), o = e || i || r || s, a = o ? U5(n.length, String) : [], l = a.length;
  for (var h in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (h == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (h == "offset" || h == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (h == "buffer" || h == "byteLength" || h == "byteOffset") || // Skip index properties.
    n1(h, l)) || a.push(h);
  return a;
}
function Cb(n) {
  var t = [];
  if (n != null)
    for (var e in Object(n))
      t.push(e);
  return t;
}
var Pb = Object.prototype, Lb = Pb.hasOwnProperty;
function Ib(n) {
  if (!Mc(n))
    return Cb(n);
  var t = $5(n), e = [];
  for (var i in n)
    i == "constructor" && (t || !Lb.call(n, i)) || e.push(i);
  return e;
}
function Eb(n) {
  return s1(n) ? Nb(n) : Ib(n);
}
var u1 = Object.prototype, Ob = u1.hasOwnProperty, yl = B5(function(n, t) {
  n = Object(n);
  var e = -1, i = t.length, r = i > 2 ? t[2] : void 0;
  for (r && q5(t[0], t[1], r) && (i = 1); ++e < i; )
    for (var s = t[e], o = Eb(s), a = -1, l = o.length; ++a < l; ) {
      var h = o[a], u = n[h];
      (u === void 0 || i1(u, u1[h]) && !Ob.call(n, h)) && (n[h] = s[h]);
    }
  return n;
});
function Tb(n, t, e) {
  if (!zl.includes(t) || !n.machining.corners) return 0;
  const i = c1(n, t);
  return e * i;
}
function c1(n, t) {
  if (!zl.includes(t) || !n.machining.corners) return 0;
  const e = n.machining.corners.find((r) => r.getCorner() === t);
  return e ? e.getLength() : 0;
}
function h1(n, t, e, i) {
  Object.keys(t).forEach((r) => {
    var s, o;
    r in n && ((s = t[r]) != null && s.min && te(n[r]) < te(t[r].min) ? e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be less than ${t[r].min}.`,
      fields: [r]
    }) : (o = t[r]) != null && o.max && te(n[r]) > te(t[r].max) && e.push({
      index: i,
      message: `${r.charAt(0).toUpperCase() + r.slice(1)} cannot be greater than ${t[r].max}.`,
      fields: [r]
    }));
  });
}
class sf {
  constructor({ x: t, y: e, diameter: i, depth: r = 0, face: s = 0, type: o = null }) {
    et(this, "x");
    et(this, "y");
    et(this, "diameter");
    et(this, "depth");
    et(this, "face");
    et(this, "valid");
    et(this, "type");
    this.x = t, this.y = e, this.diameter = i, this.depth = r, this.face = s, this.type = o;
  }
  getFace() {
    return pr[this.face];
  }
  getXDrawPosition(t) {
    let e = 0;
    const i = te(this.x);
    return t.rot ? e = t.l - te(this.y) + ("x" in t ? te(t.x) : 0) : e = i + ("x" in t ? te(t.x) : 0), e;
  }
  getYDrawPosition(t, e, i) {
    let r = t.rot ? te(this.x) : te(this.y);
    return r += "y" in t ? te(t.y) : 0, e === 1 && (i ? r = te(i.w) - r : r = te(t.w) - r), r;
  }
  shouldShow(t, e) {
    return this.face === e || this.isThroughShape(t) === !0;
  }
  isThroughShape(t) {
    return !this.depth || te(this.depth) >= te(t.t);
  }
  getDistanceToEdge(t) {
    const e = this.x, i = this.y, r = this.diameter / 2, s = te(t.getLongSide()), o = te(t.getShortSide()), a = t.machining.corners.map((g) => g.type ? g.size : 0), l = [
      {
        edge: "left",
        distance: e - r
      },
      {
        edge: "right",
        distance: s - e - r
      },
      {
        edge: "bottom",
        distance: o - i - r
      },
      {
        edge: "top",
        distance: i - r
      }
    ], h = t.machining.corners.map((g, y) => {
      const _ = y === 0 || y === 3, b = y < 2, v = _ ? e : s - e;
      let A = null;
      this.face === 0 ? A = b ? i : o - i : this.face === 1 && (A = b ? o - i : i);
      const L = Math.sqrt(v * v + A * A);
      return {
        c: g,
        distance: L
      };
    }), u = Math.min(...l.map((g) => g.distance)), d = Math.min(...h.map((g) => g.distance)), p = h.findIndex((g) => g.distance === d), f = t.machining.corners[p];
    if (f && f.type === "radius") {
      let g = p === 0 || p === 3 ? 0 : s, y = p < 2 ? 0 : o;
      const _ = p < 2;
      g += p === 0 || p === 3 ? a[p] : -a[p], y += _ ? a[p] : -a[p];
      const v = e - g, A = p < 2;
      let L;
      this.face === 0 ? L = A ? i : o - i : this.face === 1 && (L = A ? o - i : i);
      const O = L - y, R = Math.sqrt(v * v + O * O), C = a[p] - R - r;
      let E = !1;
      return f.index === 0 ? E = e <= g && L <= y : f.index === 1 ? E = e >= g && L <= y : f.index === 2 ? E = e >= g && L >= y : f.index === 3 && (E = e <= g && L >= y), E && C < u ? C : u;
    } else if (f && f.type === "bevel") {
      let g, y, _;
      f.index === 0 ? (g = 1, y = 1, _ = -f.size) : f.index === 1 ? (g = 1, y = -1, _ = -s + f.size) : f.index === 2 ? (g = 1, y = 1, _ = -s - o + f.size) : f.index === 3 && (g = -1, y = 1, _ = -o + f.size);
      const b = f.index === 0 ? 1 : -1, v = (g * e + y * i + _) / Math.sqrt(g * g + y * y) * b - r;
      return v < u ? v : u;
    } else
      return u;
  }
  validate(t, e, i = null) {
    const r = [];
    if (!jt(this.x) || !jt(this.y) || !jt(this.diameter)) {
      const o = {
        index: e,
        message: "X, Y & diameter are all required.",
        fields: []
      };
      this.x || o.fields.push("x"), this.y || o.fields.push("y"), this.diameter || o.fields.push("diameter"), r.push(o);
    }
    return te(this.diameter) <= 0 && r.push({
      index: e,
      message: "Diameter cannot be negative or zero.",
      fields: ["diameter"]
    }), te(this.depth) < 0 && r.push({
      index: e,
      message: "Depth cannot be negative.",
      fields: ["depth"]
    }), "t" in t && te(t.t) > 0 && te(this.depth) > te(t.t) && r.push({
      index: e,
      message: "Depth cannot be greater than part thickness.",
      fields: ["depth"]
    }), (!("t" in t) || !t.t) && te(this.depth) > 0 && r.push({
      index: e,
      message: "Part thickness is not defined.",
      fields: ["depth"]
    }), this.getDistanceToEdge(t) < 0 && r.push({
      index: e,
      message: "Outside of part."
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class $p {
  constructor({
    position: t = null,
    //from left or bottom
    edge: e = "x1",
    face: i = 0,
    numHoles: r = null,
    diameter: s = 0,
    depth: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    hingeLength: h = 0,
    minimumHoleDistance: u = 0,
    positionLimit: d = 0
  }, p) {
    et(this, "position");
    et(this, "edge");
    et(this, "face");
    et(this, "numHoles");
    et(this, "holes", []);
    et(this, "diameter");
    et(this, "depth");
    et(this, "distanceFromEdge");
    //from edge to center of hole
    et(this, "outerSpacing");
    //from edge to center of hole
    et(this, "hingeLength");
    et(this, "minimumHoleDistance");
    et(this, "positionLimit");
    et(this, "valid");
    this.position = t, this.edge = e, this.face = i, this.numHoles = r, this.diameter = s, this.depth = o, this.distanceFromEdge = a, this.outerSpacing = l, this.hingeLength = h, this.minimumHoleDistance = u, this.positionLimit = d, p && this.createHoles(p);
  }
  getFace() {
    return pr[this.face];
  }
  getHoleSpacing() {
    const t = te(this.hingeLength) - te(this.outerSpacing) * 2, e = this.numHoles - 1;
    return t / e;
  }
  getHoleXPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
        i = this.distanceFromEdge;
        break;
      case "x2":
        i = t.getLongSide() - te(this.distanceFromEdge);
        break;
      case "y1":
      case "y2":
        i = te(this.position) + te(this.outerSpacing) + r * e;
        break;
    }
    return i;
  }
  getHoleYPosition(t, e) {
    let i = 0;
    const r = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
      case "x2":
        i = te(this.position) + te(this.outerSpacing) + r * e;
        break;
      case "y1":
        i = te(this.distanceFromEdge);
        break;
      case "y2":
        i = t.getShortSide() - te(this.distanceFromEdge);
        break;
    }
    return i;
  }
  createHoles(t) {
    this.holes = [];
    for (let e = 0; e < this.numHoles; e++) {
      const i = new sf({
        x: this.getHoleXPosition(t, e),
        y: this.getHoleYPosition(t, e),
        diameter: this.diameter,
        depth: this.depth,
        face: this.face,
        type: "hinge"
      });
      this.holes.push(i);
    }
    return this.holes;
  }
  validate(t, e, i = null) {
    const r = [];
    return this.holes.forEach((s, o) => {
      const a = s.validate(t, o).map((l) => (l.index = e, l.message = `Hole ${o + 1}: ${l.message}`, l));
      r.push(...a);
    }), i && h1(this, i, r, e), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class Up {
  constructor({ type: t = "radius", size: e, index: i }) {
    et(this, "type");
    et(this, "size");
    et(this, "index");
    et(this, "valid");
    this.type = t, this.size = e, this.index = i;
  }
  getLength() {
    return this.type === "radius" ? Math.PI * this.size / 2 : this.type === "bevel" ? Math.sqrt(2) * this.size : 0;
  }
  getCorner() {
    return ["a", "b", "c", "d"][this.index];
  }
  isPresent() {
    return (this.valid === !0 || this.valid === void 0) && this.type !== null && this.size > 0;
  }
  validate(t, e) {
    const i = t.getShortSide(), r = [];
    if (this.type === null) {
      this.size = null;
      const s = this.getCorner();
      t.banding[s] = !1;
    }
    return this.type && te(this.size) <= 0 && r.push({
      index: e,
      message: "Corner size cannot be zero or negative"
    }), this.type && te(this.size) > i / 2 && (this.size = i / 2), r.length ? this.valid = !1 : this.valid = !0, r;
  }
}
class f1 {
  //shelfHoles?: ShelfHoles[] = [];
  constructor({
    holes: t = [],
    hingeHoles: e = [],
    corners: i = []
  } = {}) {
    et(this, "holes", []);
    et(this, "corners", []);
    et(this, "hingeHoles", []);
    i && i.length === 4 ? this.corners = i.map((r) => new Up(r)) : [0, 1, 2, 3].forEach((r) => {
      this.corners.push(new Up({
        type: null,
        size: null,
        index: r
      }));
    }), t && (this.holes = t.map((r) => new sf(r))), e && (this.hingeHoles = e.map((r) => new $p(r)));
  }
  validateEverything(t, e = null) {
    const i = this.validate(t, "holes"), r = this.validate(t, "hingeHoles"), s = this.validate(t, "corners");
    t.issues.push(...i.map((o) => yr(t) ? { message: `Part ${t.id} hole issue: ${o.message}`, index: e } : { message: `Hole issue: ${o.message}`, index: e })), t.issues.push(...r.map((o) => yr(t) ? { message: `Part ${t.id} hinge hole issue: ${o.message}`, index: e } : { message: `Hinge hole issue: ${o.message}`, index: e })), t.issues.push(...s.map((o) => yr(t) ? { message: `Part ${t.id} corner issue: ${o.message}`, index: e } : { message: `Corner issue: ${o.message}`, index: e }));
  }
  validate(t, e, i = null) {
    if (!t) return [];
    if (!e) return [];
    const r = [];
    return r.push(...this.validateAll(t, e, i)), r;
  }
  validateAll(t, e, i = null) {
    if (!t) return [];
    const r = [];
    return this[e].forEach((s, o) => r.push(...s.validate(t, o, i))), r;
  }
  createHole(t, e, i, r = 0, s = 0) {
    const o = new sf({
      x: t,
      y: e,
      diameter: i,
      depth: r,
      face: s
    });
    return this.holes.push(o), o;
  }
  createHingeHoles({
    numHoles: t,
    position: e,
    diameter: i,
    depth: r = 0,
    edge: s = "x1",
    face: o = 0,
    distanceFromEdge: a = 0,
    outerSpacing: l = 0,
    minimumHoleDistance: h = 0,
    hingeLength: u = 0
  }) {
    const d = new $p({
      numHoles: t,
      position: e,
      //from left or bottom
      edge: s,
      face: o,
      diameter: i,
      depth: r,
      distanceFromEdge: a,
      outerSpacing: l,
      minimumHoleDistance: h,
      hingeLength: u
    });
    return this.hingeHoles.push(d), d;
  }
  updateHingeHoles(t) {
    this.hingeHoles.forEach((e) => e.createHoles(t));
  }
  getAllHingeHoles(t) {
    const e = [];
    return this.hingeHoles.forEach((i) => {
      i.holes.length ? e.push(...i.holes) : (i.createHoles(t), e.push(...i.holes));
    }), e;
  }
  getNumHoles() {
    return this.holes.length + this.hingeHoles.reduce(
      (t, e) => t + e.numHoles,
      0
    );
  }
  getNumCorners() {
    return this.corners.filter((t) => t.type !== null).length;
  }
}
function d1(n) {
  var t, e, i, r, s, o, a, l;
  return !n || !(n != null && n.machining) ? !1 : (e = (t = n.machining) == null ? void 0 : t.holes) != null && e.length || (r = (i = n.machining) == null ? void 0 : i.hingeHoles) != null && r.length ? !0 : (o = (s = n.machining) == null ? void 0 : s.corners) != null && o.length ? (l = (a = n.machining) == null ? void 0 : a.corners) == null ? void 0 : l.some((h) => h.type && h.size) : !1;
}
function Fb(n) {
  var t, e, i, r;
  if ("machining" in n) {
    if (!d1(n)) {
      n.machining = null;
      return;
    }
    (t = n.machining.holes) != null && t.length || (n.machining.holes = null), (e = n.machining.hingeHoles) != null && e.length || (n.machining.hingeHoles = null), (r = (i = n.machining) == null ? void 0 : i.corners) != null && r.some((s) => s.type && s.size) || (n.machining.corners = null);
  }
}
class Mb {
  constructor(t = null) {
    et(this, "id");
    //api
    et(this, "listId");
    et(this, "shapeListIds", []);
    et(this, "shapes");
    et(this, "direction");
    et(this, "q");
    et(this, "duplicate", !1);
    et(this, "issues", []);
    et(this, "stockMatch");
    var e;
    this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Math.ceil(Math.random() * 1e16), this.id = t == null ? void 0 : t.id, this.shapes = jt(t == null ? void 0 : t.shapes) ? t.shapes.map((i) => i.toString()) : [], this.shapeListIds = jt(t == null ? void 0 : t.shapeListIds) ? t.shapeListIds : [], this.direction = jt(t == null ? void 0 : t.direction) ? t.direction : "l", this.q = jt(t == null ? void 0 : t.q) ? t.q : 1, jt(t == null ? void 0 : t.shapeList) && ((e = t.shapeList) != null && e.length) && this.validate(t.shapeList);
  }
  validate(t = []) {
    var o, a;
    if (this.issues = [], !(t != null && t.length))
      throw new Error("shapeList is required to validate user group");
    const e = this.findShapes(t);
    if (!e.length)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    const i = e[0];
    if (yr(i)) {
      if (!(this != null && this.shapes) || ((o = this.shapes) == null ? void 0 : o.length) < 2)
        return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    } else if (!(this != null && this.shapeListIds) || ((a = this.shapeListIds) == null ? void 0 : a.length) < 2)
      return this.issues.push({ message: "Must have 2 or more parts." }), this.issues;
    if (e.forEach((l, h) => {
      !l.isSquare() && !["l", "w"].includes(l.orientationLock) && this.issues.push({ message: `Part in position ${h + 1} must have orientation lock set to be part of a group.` });
    }), this.issues.length) return this.issues;
    const r = So(this.direction), s = i.getTrimmedDimensions(!0)[r];
    return e.forEach((l, h) => {
      if (l.id === i.id) return;
      const u = l.getTrimmedDimensions(!0)[r];
      Ve.equalTo(u, s) || this.issues.push({ message: `Part in position ${h + 1} final ${r === "l" ? "length" : "width"} is not correct for the group. Expected ${s} and is ${u}. Check the dimensions, trim & orientation lock.` });
    }), this.issues;
  }
  findShapes(t = []) {
    var i, r;
    if (!t.length) return [];
    let e = [];
    if (Ji(t[0])) {
      if (!((i = this.shapeListIds) != null && i.length)) return [];
      if (e = this.shapeListIds.map((s) => t.find((o) => o.listId === s)).filter((s) => s), !e.length)
        throw new Error("could not map group shapes to shape list");
      return e;
    } else {
      if (!((r = this.shapes) != null && r.length)) return [];
      const s = /* @__PURE__ */ new Set();
      e = this.shapes.map((o) => {
        const a = t.find((l) => l.parentID === o && !l.inUserGroup && !s.has(l.id));
        return a ? (s.add(a.id), a) : null;
      }).filter((o) => o);
    }
    if (!e.length)
      throw new Error("could not map group shapes to shape list");
    return e;
  }
  populateParentID(t) {
    var e;
    t != null && t.length && (e = this == null ? void 0 : this.shapeListIds) != null && e.length && (this.shapes = this.shapeListIds.map((i) => (t.findIndex((s) => s.listId === i) + 1).toString()));
  }
  //create a group from a user group
  createGroup(t = 0, e = 0, i = [], r = null) {
    if (!(i != null && i.length))
      throw new Error("some parts are required to create a user group");
    if (!yr(i[0]))
      throw new Error("shapeList must be of type Shape[]");
    const s = this.findShapes(i);
    if (!s.length) return !1;
    const o = s[0];
    s.forEach((u) => {
      const d = i.findIndex((p) => !p.inUserGroup && p.parentID === u.parentID);
      if (d === -1)
        throw new Error("shape not found in shapeList while creating user group.");
      i.splice(d, 1), u.setRotationToOrientationLockWithoutContainer(), u.inUserGroup = !0;
    });
    let a = 0, l = 0;
    this.direction === "l" ? l = o.w : a = o.l;
    let h;
    try {
      const u = {
        id: `ug${t}.${e}`,
        shapes: s,
        l: a,
        w: l,
        t: o == null ? void 0 : o.t,
        material: o == null ? void 0 : o.material,
        // joinDimension:
        //     referenceShape.l === l ? referenceShape.l : referenceShape.w,
        direction: this.direction,
        preventAutoRotation: !0,
        container: r,
        type: "user"
      };
      h = new Ws(u);
    } catch (u) {
      return console.error(u), !1;
    }
    return h.parentID = `ug${t}`, r && h.updateShapeSpacing(r), h;
  }
}
const mr = ["y1", "y2", "x1", "x2"], zl = ["a", "b", "c", "d"], Ts = [...mr, ...zl], pr = ["a", "b"];
function p1(n) {
  return zl.includes(n);
}
function Rb(n) {
  return Ts.includes(n);
}
const of = {
  x: "x",
  y: "y",
  l: "length",
  w: "width",
  t: "thickness",
  q: "quantity",
  orientationLock: "rotation",
  name: "name",
  material: "material",
  banding: "banding",
  finish: "finish",
  cost: "cost",
  grain: "grain",
  trim: "trim",
  x1: "w1",
  x2: "w2",
  y1: "l1",
  y2: "l2",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  all: "all"
};
function Db(n) {
  return mr.map((t) => n[t] ?? null);
}
function Ao(n) {
  if (!jt(n) || typeof n != "object") return {};
  n = { ...n };
  for (const [t, e] of Object.entries(n))
    t !== "_id" && t.startsWith("_") && (n[t.substring(1)] = e, delete n[t]);
  return n;
}
function Bb(n, t = null) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    var i;
    return delete e.id, t ? e.units = t : e.units || (e.units = ((i = this == null ? void 0 : this.optionsStore) == null ? void 0 : i.units) ?? "decimal"), new vd(e);
  });
}
function jb({
  stockList: n,
  removeScores: t = !1,
  saw: e = null,
  preventAutoRotation: i = !1,
  preventGrainRotation: r = !1
}) {
  return !n || !(n != null && n.length) ? [] : n.filter((s) => s).map((s) => {
    e && (s.saw = e), i && (s.preventAutoRotation = !0), r && (s.preventGrainRotation = !0);
    const o = new is(s);
    if (o.issues.length)
      throw new Error(
        `Issues found when attempting to recreate stock list - ${o.issues.map((a) => a.message).join()}`,
        { cause: o.issues }
      );
    return t && delete o.algoBenchmark, o;
  }).sort(Ju.ID);
}
function qb({
  shapeList: n,
  stockList: t,
  preventAutoRotation: e = !1
}) {
  if (typeof t > "u")
    throw new Error("recreateShapeList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.filter((i) => i).map((i) => {
    var o;
    e && (i.preventAutoRotation = !0);
    let r;
    if (Yb(i) && ((o = i == null ? void 0 : i.shapes) != null && o.length)) {
      i.shapes = i.shapes.map((a) => new rs(a));
      try {
        r = new Ws(i);
      } catch {
        throw new Error("error creating group from shape data");
      }
    } else
      r = new rs(i);
    if (r.issues.length)
      throw new Error(`Issues found when attempting to recreate shape list - ${r.issues.join()}`);
    const s = t.find((a) => {
      var l;
      return a.id === (((l = i == null ? void 0 : i.stock) == null ? void 0 : l.id) ?? (i == null ? void 0 : i.stockId));
    });
    return r.stock = s, r;
  }).sort(Ju.ID);
}
function zb({
  cutList: n,
  stockList: t
}) {
  if (typeof t > "u")
    throw new Error("recreateCutList requires stockList");
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = new Fc(e), r = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return i.stock = r, i;
  });
}
function $b({
  segmentList: n,
  stockList: t
}) {
  return !n || !(n != null && n.length) ? [] : n.map((e) => {
    const i = t.find((s) => {
      var o;
      return s.id === (((o = e == null ? void 0 : e.stock) == null ? void 0 : o.id) ?? (e == null ? void 0 : e.stockId));
    });
    return e.stock = i, new y1(e);
  });
}
function g1(n = null, t = null, e = null) {
  if (!n) throw new Error("no container supplied to willItFit");
  if (!t) throw new Error("no shape supplied to willItFit");
  const i = t.rot;
  function r(p = !1, f = "l") {
    var g, y;
    return Ve.equalTo(
      t[p ? So(f) : f],
      n[f]
    ) || Ve.lessThanOrEqualTo(t[p ? So(f) : f], n[f] - (af(n) ? (y = (g = n == null ? void 0 : n.saw) == null ? void 0 : g.options) == null ? void 0 : y.minSpacing : 0));
  }
  function s(p = !0) {
    return t.forceRotate(i), p;
  }
  const o = t.getNecessaryOrientation(n);
  let a = null;
  if (o && (a = o === "l" ? 0 : 1), t.orientationLock) {
    if (jt(e) && e !== a)
      return s(!1);
    t.forceRotate(a);
  } else jt(e) && t.forceRotate(e);
  if (a && t.rot !== a)
    return s(!1);
  const l = r(!1, "l"), h = r(!1, "w"), u = r(!0, "l"), d = r(!0, "w");
  return jt(e) || o ? s(l && h) : s(l && h || u && d);
}
function oc(n, t, e = "decimal", i = !1) {
  return jt(n == null ? void 0 : n[t]) ? te(n[t], e, !1, i) : null;
}
class m1 {
  constructor(t, e = !1) {
    et(this, "readonly");
    et(this, "id");
    et(this, "listId");
    et(this, "units", "decimal");
    et(this, "l");
    et(this, "w");
    et(this, "t");
    et(this, "q");
    et(this, "name");
    et(this, "material");
    et(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    et(this, "cost", null);
    et(this, "grain", "");
    et(this, "selected", !1);
    //used for multiple editing
    et(this, "multiEdit", !1);
    //is this the multi-select stock
    et(this, "type", null);
    et(this, "autoAdd", !1);
    et(this, "used");
    et(this, "saw");
    et(this, "preventGrainRotation");
    et(this, "allowExactFitShapes");
    et(this, "issues", []);
    et(this, "warnings", []);
    et(this, "notes", "");
    var s, o;
    t = Ao(t), jt(t.units) || console.warn("Attempting to create InputStock without units"), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((a) => {
      this[a] = oc(t, a, this.units, e);
    }), this.q = jt(t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.autoAdd = jt(t.autoAdd) ? t.autoAdd : !1, this.name = jt(t.name) ? Ul(t.name).toUpperCase() : "", this.material = jt(t.material) ? t.material.trim().toUpperCase() : "";
    const r = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }, r.forEach((a) => {
      this.trim[a] = oc(t.trim, a, this.units, e);
    }), this.cost = jt(t.cost) ? t.cost : null, t.grain = (s = t == null ? void 0 : t.grain) == null ? void 0 : s.toLowerCase(), (t == null ? void 0 : t.grain) === " " && (t.grain = ""), this.grain = t.grain, this.multiEdit = t.multiEdit, this.type = t.type, this.allowExactFitShapes = jt(t == null ? void 0 : t.allowExactFitShapes) ? t.allowExactFitShapes : !1, this.preventGrainRotation = !0, this.notes = t != null && t.notes ? (o = t.notes) == null ? void 0 : o.replace(/,/g, "") : "";
  }
  //change the units of the stock
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? te(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = jt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  //change the type of stock
  changeType(t) {
    switch (t !== "sheet" && (this.grain = ""), t) {
      case "linear":
        this.trim.y1 = 0, this.trim.y2 = 0;
        break;
      case "roll":
        this.trim.x1 = 0, this.trim.x2 = 0, this.trim.y1 = 0, this.trim.y2 = 0, this.t = null;
        break;
    }
  }
  //create an id from an index
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  isSquare() {
    return this.l === this.w;
  }
  getWarnings() {
    this.warnings = [], ["q"].forEach((t) => this.warnings.push(...ai[t](this[t])));
  }
  validate() {
    return this.issues = [], ["l", "w", "t"].forEach((t) => this.issues.push(...ai[t](this[t]))), this.issues.push(...ai.trim(this)), this.getWarnings(), this.issues;
  }
}
class vd {
  constructor(t, e = !1) {
    et(this, "readonly");
    et(this, "id");
    et(this, "listId");
    et(this, "units", "decimal");
    et(this, "l");
    et(this, "w");
    et(this, "t");
    et(this, "q", 1);
    et(this, "name", "");
    et(this, "material", "");
    et(this, "cost");
    et(this, "orientationLock");
    et(this, "selectedMaterial");
    et(this, "selected", !1);
    //used for multiple editing
    et(this, "multiEdit", !1);
    et(this, "issues", []);
    et(this, "warnings", []);
    et(this, "notes", "");
    et(this, "stockLock");
    et(this, "stockMatch");
    et(this, "customData");
    //objects
    et(this, "machining");
    et(this, "trim", Object.fromEntries(
      mr.map((t) => [t, 0])
    ));
    et(this, "banding", Object.fromEntries(
      Ts.map((t) => [t, !1])
    ));
    et(this, "bandingOptions", Object.fromEntries([
      ...Ts,
      "all"
    ].map((t) => [t, {}])));
    et(this, "finish", Object.fromEntries(
      pr.map((t) => [t, ""])
    ));
    et(this, "finishOptions", Object.fromEntries(
      pr.map((t) => [t, {}])
    ));
    var r, s, o, a, l;
    t = t = Ao(t), this.units = t.units, this.readonly = t.readonly, this.id = t.id, this.listId = t != null && t.listId ? t.listId : Date.now().toString() + Qg(), ["l", "w", "t"].forEach((h) => {
      this[h] = oc(t, h, this.units, e);
    }), this.q = jt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? parseInt(t.q) : t.q : null, this.name = jt(t.name) ? Ul(t.name).toUpperCase() : "", this.material = jt(t.material) ? t.material.trim().toUpperCase() : "", this.multiEdit = t.multiEdit, this.notes = t != null && t.notes ? (r = t.notes) == null ? void 0 : r.replace(/,/g, "") : "", this.stockLock = (t == null ? void 0 : t.stockLock) ?? [];
    for (const h of Object.keys(this.trim))
      this.trim[h] = oc(t.trim, h, this.units, e);
    for (const h of Object.keys(this.banding))
      this.banding[h] = jt((s = t == null ? void 0 : t.banding) == null ? void 0 : s[h]) ? t.banding[h] : !1;
    for (const h of Object.keys(this.bandingOptions))
      this.bandingOptions[h] = jt((o = t == null ? void 0 : t.bandingOptions) == null ? void 0 : o[h]) ? t.bandingOptions[h] : {};
    for (const h of Object.keys(this.finish))
      this.finish[h] = jt((a = t == null ? void 0 : t.finish) == null ? void 0 : a[h]) ? t.finish[h] : "";
    for (const h of Object.keys(this.finishOptions))
      this.finishOptions[h] = jt((l = t == null ? void 0 : t.finishOptions) == null ? void 0 : l[h]) ? t.finishOptions[h] : {};
    this.orientationLock = jt(t.orientationLock) ? t.orientationLock.toLowerCase() : "", this.machining = new f1(t.machining ?? {
      holes: [],
      hingeHoles: [],
      corners: []
    }), this.customData = (t == null ? void 0 : t.customData) ?? {};
  }
  /**
   * change the units of the shape
   * @param {String} newUnits
   */
  changeUnits(t, e, i) {
    if (!(t === "decimal" || t === "fraction")) return;
    this.units = t;
    function r(o) {
      return o ? te(o, t, !1, !1, i) : null;
    }
    this.l = r(this.l), this.w = r(this.w), this.t = r(this.t), ["x1", "x2", "y1", "y2"].forEach((o) => {
      var a;
      this.trim[o] = jt((a = this.trim) == null ? void 0 : a[o]) ? r(this.trim[o]) : null;
    });
  }
  isSquare() {
    return this.l === this.w;
  }
  /**
   * change the type of the stock
   * @param {String} newType
   */
  changeStockType(t) {
    switch (t) {
      case "sheet":
      case "roll":
        this.orientationLock = "", t === "roll" && (this.t = null);
        break;
      case "linear":
        this.orientationLock = "", this.banding = Object.fromEntries(
          Ts.map((e) => [e, !1])
        );
        break;
    }
  }
  /**
   * create an id from an index
   * @param {Integer} index
   * @param {Integer} secondaryIndex
   */
  createId(t, e = 0) {
    this.id = `${t + 1}.${e}`;
  }
  getLongSide() {
    return te(this.l) > te(this.w) ? te(this.l) : te(this.w);
  }
  getShortSide() {
    return te(this.l) < te(this.w) ? te(this.l) : te(this.w);
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      name: this.name,
      listId: this.listId,
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      name: this.name,
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: te(this.l), w: te(this.w) };
    return t && (e = this.getRotatedDimensions()), {
      name: this.name,
      listId: this.listId,
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2),
      orientationLock: this.orientationLock
    };
  }
  //used to apply a single trim value to all sides
  applyPartTrim(t, e) {
    if (!this.readonly)
      if (t = te(t), this.trim) {
        for (const i in this.trim)
          this.trim[i] = t;
        e === "linear" && (this.trim.y1 = 0, this.trim.y2 = 0);
      } else
        this.trim = {
          x1: t,
          x2: t,
          y1: e !== "linear" ? t : 0,
          y2: e !== "linear" ? t : 0
        };
  }
  /**
   * to align with Shape
   * @remarks input shapes are always 0
   */
  get rot() {
    return 0;
  }
  validate(t, e, i, r = 0, s = !1) {
    return this.issues = [], ["l", "w", "t"].forEach((o) => {
      const a = ai[o](this[o], e);
      a.length && this.issues.push(...a);
    }), r = te(r), this.issues.push(...ai.partTrim(this, r, e)), this.issues.push(...ai.trim(this, e)), ai.machining(this, e), this.getWarnings(t, e, i, r, s), this.issues;
  }
  getWarnings(t, e = null, i, r = 0, s = !1) {
    this.warnings = [], ["q"].forEach((o) => {
      this.warnings.push(...ai[o](this[o], e));
    }), t.length && !s && this.warnings.push(...ai.stockMatch(this, t, i, r, e));
  }
}
class $l {
  constructor(t) {
    et(this, "id");
    et(this, "parentID");
    et(this, "name");
    et(this, "x");
    et(this, "y");
    et(this, "l");
    et(this, "w");
    et(this, "t");
    et(this, "q");
    et(this, "material");
    et(this, "grain");
    et(this, "orientationLock");
    et(this, "duplicate");
    et(this, "trimmed");
    et(this, "preventAutoRotation");
    et(this, "preventGrainRotation");
    et(this, "units");
    et(this, "issues", []);
    et(this, "stock");
    et(this, "stockId");
    //used when object is compressed
    et(this, "cost");
    et(this, "offcut");
    et(this, "notes");
    //for user notes
    et(this, "proximity");
    //objects
    et(this, "_trim", Object.fromEntries(
      mr.map((t) => [t, 0])
    ));
    et(this, "customData");
    this.initRectangle(t);
  }
  validateRectangle(t) {
    Pr(this) || ["x", "y", "l", "w", "t"].forEach((e) => {
      this.createIssues(ai[e](t[e]));
    }), ns(this) && "q" in t && this.createIssues(ai.q((t == null ? void 0 : t.q) ?? 0, t.autoAdd)), "q" in t && this.isShape() && !this.isGroup() && !this.isUserGroup() && this.createIssues(ai.q((t == null ? void 0 : t.q) ?? 0)), "customData" in t && this.createIssues(ai.customData((t == null ? void 0 : t.customData) ?? {}));
  }
  initRectangle(t, e = !1) {
    var r, s, o;
    if (!e) {
      if (this.validateRectangle(t), this.issues.length) return;
      this.id = jt(t.id) ? t.id.toString() : this.id || null, this.setParentID(), jt(t == null ? void 0 : t.q) ? typeof t.q == "string" ? this.q = parseInt(t.q) : this.q = t.q : this.q = 0, this.name = jt(t.name) && ((r = t == null ? void 0 : t.name) != null && r.length) ? (s = b1(Ul(t == null ? void 0 : t.name))) == null ? void 0 : s.toUpperCase() : null, jt(t == null ? void 0 : t.cost) ? typeof t.cost == "string" ? this.cost = parseFloat(t.cost) : typeof t.cost == "number" && (this.cost = t.cost) : this.cost = 0, this.material = jt(t.material) ? t.material.trim().toLowerCase() : null, this.duplicate = jt(t == null ? void 0 : t.duplicate) ? t.duplicate : !1, this.grain = typeof t.grain < "u" && jt(t == null ? void 0 : t.grain) ? t.grain.toLowerCase() : null, this.trimmed = jt(t == null ? void 0 : t.trimmed) ? t.trimmed : !1, this.offcut = jt(t == null ? void 0 : t.offcut) ? t.offcut : !1, this.notes = typeof (t == null ? void 0 : t.notes) == "string" && t.notes.length ? t.notes.replace(/,/g, "").substring(0, 200) : "", this.customData = (t == null ? void 0 : t.customData) ?? {}, this.proximity = {
        rectangle: null,
        distance: null
      };
      try {
        this.trim = t == null ? void 0 : t.trim;
      } catch (a) {
        if ((o = a == null ? void 0 : a.cause) != null && o.issues) this.issues.push(...a.cause.issues);
        else throw new Error("error when attempting to set trim");
      }
    }
    [
      {
        key: "x",
        default: 0,
        required: !1
      },
      {
        key: "y",
        default: 0,
        required: !1
      },
      {
        key: "l",
        default: null,
        required: !0
      },
      {
        key: "w",
        default: 1,
        //for linear
        required: !0
      },
      {
        key: "t",
        default: null,
        required: !1
      }
    ].forEach((a) => {
      let l = t[a.key];
      if (!jt(l))
        return this[a.key] = this[a.key] || a.default;
      typeof l == "string" && (l = te(l)), this[a.key] = l;
    }), !(t != null && t.preventAutoRotation) && !t.trimmed && this.w > this.l && ([this.l, this.w] = [this.w, this.l], this.grain && !(t != null && t.preventGrainRotation) && (this.grain = So(this.grain))), jt(t == null ? void 0 : t.stock) && (ns(t.stock) ? this.stock = t.stock : this.stock = new is(t.stock), this.stockId = this.stock.id);
  }
  updateRectangle(t) {
    t.preventAutoRotation = !0, this.initRectangle(t, !0);
  }
  set trim(t) {
    if (this._trim = Object.fromEntries(
      mr.map((e) => [e, 0])
    ), !!No(t, !0))
      for (const e of mr) {
        let i;
        if (typeof t[e] == "string") {
          const r = te(t[e]);
          isNaN(r) || r < 0 ? (this.issues.push(
            this.createIssue(
              `${t[e] ?? "N/A"} is not a valid value for trim: ${e}`
            )
          ), i = 0) : i = r;
        } else
          i = t[e];
        this._trim[e] = i;
      }
  }
  get trim() {
    return this._trim;
  }
  get rot() {
    return this.w > this.l ? 1 : 0;
  }
  setParentID() {
    this.parentID = this.getParentID();
  }
  getParentID() {
    return this.id ? this.parentID ? this.parentID : typeof this.id != "number" && this.id.includes(".") ? this.id.split(".")[0] : typeof this.id != "number" && !this.id.includes(".") ? null : this != null && this.id ? this.id.toString() : null : null;
  }
  getCopyNumber() {
    return typeof this.id != "number" && this.id.includes(".") ? parseInt(this.id.split(".")[1]) : 0;
  }
  createIssues(t) {
    t != null && t.length && t.forEach((e) => {
      this.issues.push(this.createIssue(e.message, e.field));
    });
  }
  createIssue(t, e = null) {
    var o;
    let i = "";
    const r = this.getClass();
    switch (r) {
      case "Shape":
        i = "part";
        break;
      case "Stock":
        i = "stock";
        break;
      default:
        i = r.toLowerCase();
        break;
    }
    const s = (o = this == null ? void 0 : this.name) != null && o.length ? this.name.toUpperCase() : this.parentID;
    return s ? {
      message: `${t} [${i.charAt(0).toUpperCase() + i.slice(1)} ${s}]`,
      field: e
    } : { message: t, field: e };
  }
  dimensions() {
    return {
      id: this.id,
      l: this.l,
      w: this.w,
      t: this.t
    };
  }
  getRotatedDimensions() {
    return ["l", "w"].includes(this.orientationLock) ? {
      l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
      w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
      orientationLock: this.orientationLock
    } : {
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  coords() {
    return {
      id: this.id,
      x: this.x,
      y: this.y
    };
  }
  hasCoords(t, e) {
    return this.x === t && this.y === e;
  }
  getAspect() {
    return this.l > this.w ? this.w / this.l : this.l / this.w;
  }
  getPerimeter() {
    return this.w * 2 + this.l * 2;
  }
  getLongSide() {
    return this.l > this.w ? this.l : this.w;
  }
  getShortSide() {
    return this.l < this.w ? this.l : this.w;
  }
  getSides() {
    return [
      this.getSide("bottom"),
      this.getSide("right"),
      this.getSide("top"),
      this.getSide("left")
    ];
  }
  getSide(t) {
    switch (t) {
      case "bottom":
        return new ma({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y,
          type: "bottom"
          // parentID: this.id
        });
      case "right":
        return new ma({
          x1: this.x + this.l,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y + this.w,
          type: "right"
          // parentID: this.id
        });
      case "top":
        return new ma({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y + this.w,
          y2: this.y + this.w,
          type: "top"
          // parentID: this.id
        });
      case "left":
        return new ma({
          x1: this.x,
          x2: this.x,
          y1: this.y,
          y2: this.y + this.w,
          type: "left"
          // parentID: this.id
        });
    }
  }
  getTopPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y + this.w + ((this.stock.getBladeWidth() || e) ?? 0) : this.y + this.w;
  }
  getRightPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x + this.l + ((this.stock.getBladeWidth() || e) ?? 0) : this.x + this.l;
  }
  getBottomPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.y - ((this.stock.getBladeWidth() || e) ?? 0) : this.y;
  }
  getLeftPosition(t = !0, e = null) {
    var i;
    if (t && typeof ((i = this.stock) == null ? void 0 : i.getBladeWidth) > "u" && e === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return t ? this.x - ((this.stock.getBladeWidth() || e) ?? 0) : this.x;
  }
  sharesSide(t, e = 0, i = null) {
    switch (i) {
      case "left":
        return t.x + t.l + e === this.x;
      case "right":
        return t.x === this.x + this.l + e;
      case "bottom":
        return t.y + t.w + e === this.y;
      case "top":
        return t.y === this.y + this.w + e;
    }
    return !1;
  }
  sameSide(t, e = null) {
    switch (e) {
      case "left":
        return t.x === this.x;
      case "right":
        return t.x + t.l === this.x + this.l;
      case "bottom":
        return t.y === this.y;
      case "top":
        return t.y + t.w === this.y + this.w;
    }
    return !1;
  }
  //considers if the shape can rotate
  getLongestDimension(t) {
    return this.orientationLock ? this[t] : this.getLongSide();
  }
  getArea() {
    return this.w * this.l;
  }
  getCoords(t, e = !1) {
    const i = new Wn(this.x + this.l, this.y);
    i.corner = "bottomRight";
    const r = new Wn(this.x, this.y + this.w);
    if (r.corner = "topLeft", (t == null ? void 0 : t.cutType) !== "efficiency" && !e)
      return [r, i];
    const s = new Wn(this.x, this.y);
    s.corner = "bottomLeft";
    const o = new Wn(this.x + this.l, this.y + this.w);
    return o.corner = "topRight", [s, r, o, i];
  }
  getCorners() {
    return {
      bottomLeft: new Wn(this.x, this.y),
      topLeft: new Wn(this.x, this.y + this.w),
      topRight: new Wn(this.x + this.l, this.y + this.w),
      bottomRight: new Wn(this.x + this.l, this.y)
    };
  }
  round() {
    return {
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  getClass() {
    return this.constructor.name;
  }
  getTrimmedDimensions(t = !1) {
    let e = { l: this.l, w: this.w };
    return t && (e = this.getRotatedDimensions()), this.trimmed ? e : {
      l: e.l - (this.trim.x1 + this.trim.x2),
      w: e.w - (this.trim.y1 + this.trim.y2)
    };
  }
  //trim the rectangle
  trimDimensions() {
    var t, e, i, r;
    return this.trimmed ? !1 : (this.trim && Object.values(this.trim).filter((s) => !isNaN(parseFloat(String(s)))).length && (jt(this.l) && (this.l -= ((t = this == null ? void 0 : this.trim) != null && t.x1 ? this.trim.x1 : 0) + ((e = this == null ? void 0 : this.trim) != null && e.x2 ? this.trim.x2 : 0), this.l <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative length")))), jt(this.w) && (this.w -= ((i = this == null ? void 0 : this.trim) != null && i.y1 ? this.trim.y1 : 0) + ((r = this == null ? void 0 : this.trim) != null && r.y2 ? this.trim.y2 : 0), this.w <= 0 && (console.error(this), this.issues.push(this.createIssue("Applying trim has produced a negative width"))))), this.trimmed = !0, !0);
  }
  /**
   * change the size of the rectangle back to the original size
   */
  removeTrim() {
    var t, e, i, r;
    if (this.trimmed) {
      if (this.l += (typeof ((t = this == null ? void 0 : this.trim) == null ? void 0 : t.x1) == "number" ? this.trim.x1 : 0) + (typeof ((e = this == null ? void 0 : this.trim) == null ? void 0 : e.x2) == "number" ? this.trim.x2 : 0), this.w += (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.y1) == "number" ? this.trim.y1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.y2) == "number" ? this.trim.y2 : 0), this.l <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative length`);
      if (this.w <= 0)
        throw new Error(`trimming this ${this.id} has produced a negative width`);
      this.trimmed = !1;
    }
  }
  getUntrimmedDimensions() {
    var i, r, s, o;
    if (!this.trimmed) return { l: this.l, w: this.w };
    const t = this.getLongSide(), e = this.getShortSide();
    return {
      l: t + (typeof ((i = this == null ? void 0 : this.trim) == null ? void 0 : i.x1) == "number" ? this.trim.x1 : 0) + (typeof ((r = this == null ? void 0 : this.trim) == null ? void 0 : r.x2) == "number" ? this.trim.x2 : 0),
      w: e + (typeof ((s = this == null ? void 0 : this.trim) == null ? void 0 : s.y1) == "number" ? this.trim.y1 : 0) + (typeof ((o = this == null ? void 0 : this.trim) == null ? void 0 : o.y2) == "number" ? this.trim.y2 : 0)
    };
  }
  isIdentical(t, e = !1) {
    if (this.constructor !== t.constructor || this.t !== t.t || this.orientationLock !== t.orientationLock)
      return !1;
    if (Pr(this)) {
      if (t.id === this.id) return !0;
    } else {
      if (t.parentID === this.parentID) return !0;
      if (yr(this) && e && this.parentID !== t.parentID) return !1;
    }
    const { w: i, l: r } = this, { w: s, l: o } = t;
    if (!(i === s && r === o) && !(i === o && r === s))
      return !1;
    const a = this.trim, l = t.trim;
    return !a || !l ? a === l : a.x1 === l.x1 && a.x2 === l.x2 && a.y1 === l.y1 && a.y2 === l.y2;
  }
  /**
   * is this rectangle a square
   */
  isSquare() {
    return this.l === this.w;
  }
  getDistancesToContainerEdges(t) {
    return [
      this.x - t.x,
      t.l - (this.x + this.l),
      t.w - (this.y + this.w),
      this.y - t.y
    ];
  }
  isInsideStock(t) {
    return !(this.x + this.l > t.l || this.y + this.w > t.w || this.x < 0 || this.y < 0);
  }
  /**
  * Creates or retrieves a cached rectangle used for proximity detection.
  * Optimized for frequent calls with the same distance parameter.
  */
  getProximityRectangle(t) {
    if (!t || t < 0) return null;
    const e = this.proximity;
    if ((e == null ? void 0 : e.distance) === t) {
      const r = e.rectangle;
      return this.x === 0 ? (r.x = 0, r.l = this.l + t) : (r.x = this.x - t, r.l = this.l + t * 2), this.y === 0 ? (r.y = 0, r.w = this.w + t) : (r.y = this.y - t, r.w = this.w + t * 2), r;
    }
    const i = new $l({
      id: `${this.id}-proximity`,
      name: "proximity",
      x: this.x === 0 ? 0 : this.x - t,
      y: this.y === 0 ? 0 : this.y - t,
      l: this.x === 0 ? this.l + t : this.l + t * 2,
      w: this.y === 0 ? this.w + t : this.w + t * 2,
      preventAutoRotation: !0
    });
    return this.proximity = { rectangle: i, distance: t }, i;
  }
  isShape() {
    return yr(this);
  }
  isSegment() {
    return Xb(this);
  }
  isStock() {
    return ns(this);
  }
  isGroup() {
    return Pr(this);
  }
  isUserGroup() {
    return xd(this);
  }
}
class wd extends $l {
  constructor(e) {
    super(e);
    et(this, "type");
    et(this, "saw");
    et(this, "algoBenchmark");
    //used by evo
    et(this, "shapes", []);
    switch (this.shapes = e.shapes, ["sheet", "linear", "roll", null, void 0, ""].includes(e.type) ? this.type = e.type : this.issues.push({ message: `Container type ${e.type ?? "N/A"} is not valid` }), this.type || (this.type = "sheet"), this.setSaw(e), this.cutType) {
      case "beam":
        (!jt(this.t) || this.t <= 0) && this.issues.push(this.createIssue("Stock for beam saws must have a thickness set"));
        break;
    }
  }
  setSaw(e) {
    var i, r, s, o;
    if (jt(e) || (this.saw = new qs(null)), jt(e == null ? void 0 : e.saw)) {
      if (!((r = e == null ? void 0 : e.saw) != null && r.cutType)) {
        const { cutType: a, cutPreference: l } = rf(e.saw.cutPreference);
        e.saw.cutType = a, e.saw.cutPreference = l;
      }
    } else {
      e.saw = {};
      const { cutType: a, cutPreference: l } = rf(e.cutPreference);
      e.saw.cutType = a, e.saw.cutPreference = l, jt(e == null ? void 0 : e.bladeWidth) && (e.saw.bladeWidth = e.bladeWidth), jt((i = e == null ? void 0 : e.blade) == null ? void 0 : i.width) && (e.saw.bladeWidth = e.blade.width), jt(e == null ? void 0 : e.efficiencyOptions) && (e.saw.efficiencyOptions = e.efficiencyOptions), jt(e == null ? void 0 : e.guillotineOptions) && (e.saw.guillotineOptions = e.guillotineOptions), jt(e == null ? void 0 : e.stackHeight) && (e.saw.stackHeight = e.stackHeight);
    }
    try {
      jt(e == null ? void 0 : e.saw) && (Jb(e.saw) ? this.saw = e.saw : this.saw = new qs(e.saw, this.type)), (o = (s = this.saw) == null ? void 0 : s.issues) != null && o.length && this.issues.push(...this.saw.issues);
    } catch (a) {
      throw new Error("error creating saw", { cause: a });
    }
  }
  get cutType() {
    var e, i, r, s;
    return jt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.cutType) ? this.saw.cutType : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutType) ?? null;
  }
  get cutPreference() {
    var e, i, r, s;
    return jt((e = this.saw) == null ? void 0 : e.cutPreference) ? this.saw.cutPreference : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.cutPreference) ?? null;
  }
  get guillotineOptions() {
    var e, i, r, s;
    return jt((e = this.saw) == null ? void 0 : e.guillotineOptions) ? this.saw.guillotineOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.guillotineOptions) ?? null;
  }
  get efficiencyOptions() {
    var e, i, r, s;
    return jt((e = this.saw) == null ? void 0 : e.efficiencyOptions) ? this.saw.efficiencyOptions : (i = this.stock) != null && i.isStock() ? null : ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.efficiencyOptions) ?? null;
  }
  get primaryCompression() {
    var e, i;
    if (this.cutType === "efficiency")
      return (i = (e = this.saw) == null ? void 0 : e.efficiencyOptions) != null && i.primaryCompression ? this.efficiencyOptions.primaryCompression : "y";
  }
  getHalfBladeWidth() {
    const e = this.getBladeWidth();
    return e ? e / 2 : 0;
  }
  getBladeWidth() {
    var i, r, s;
    const e = (((i = this == null ? void 0 : this.saw) == null ? void 0 : i.bladeWidth) || ((s = (r = this == null ? void 0 : this.stock) == null ? void 0 : r.saw) == null ? void 0 : s.bladeWidth)) ?? 0;
    return isNaN(e) ? 0 : e;
  }
  getStock() {
    return ns(this) ? this : this != null && this.stock ? this.stock : null;
  }
}
class qs {
  constructor(t, e = "sheet") {
    et(this, "issues");
    et(this, "bladeWidth");
    et(this, "cutType");
    et(this, "cutPreference");
    et(this, "guillotineOptions");
    et(this, "efficiencyOptions");
    et(this, "stackHeight");
    et(this, "stockType");
    et(this, "options");
    switch (t = Ao(t), this.options = yl({}, t == null ? void 0 : t.options, {
      stockSelection: "efficiency",
      stackingMode: "dimensions",
      minSpacing: 0,
      minSpacingDimension: {}
    }), this.stackHeight = (t == null ? void 0 : t.stackHeight) ?? null, this.stockType = (t == null ? void 0 : t.stockType) ?? e, this.issues = [], ["sheet", "linear", "roll"].includes(this.stockType) || this.issues.push({ message: `Saw stock type: ${this.stockType} not valid` }), this.stockType || (this.stockType = "sheet"), this.cutType = t == null ? void 0 : t.cutType, this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "roll":
        ["efficiency", "guillotine", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
      case "linear":
        break;
      default:
        ["none", null, void 0].includes(this.cutType) || this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        break;
    }
    switch (this.cutPreference = t == null ? void 0 : t.cutPreference, this.cutType) {
      case "guillotine":
        ["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.cutType === "guillotine" && this.cutPreference === "l" && this.stockType === "roll" && this.issues.push({ message: `Cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"} and stock type: ${this.stockType}` }), this.options.minSpacing = 0;
        break;
      case "beam":
        ["l", null, void 0].includes(this.cutPreference) || this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` }), this.options.minSpacing = 0;
        break;
    }
    switch (jt(t == null ? void 0 : t.bladeWidth) ? typeof t.bladeWidth == "string" ? this.bladeWidth = te(t.bladeWidth) : this.bladeWidth = t.bladeWidth : this.bladeWidth = 0, (isNaN(this.bladeWidth) || this.bladeWidth < 0) && (this.issues.push({ message: `Blade width: ${this.bladeWidth ?? "N/A"} is not valid` }), this.bladeWidth = 0), this.stockType) {
      case "sheet":
        [
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType) || this.issues.push({ message: `Invalid cut type: ${this.cutType} for stock type: ${e}, cut preference: ${this.cutPreference}` }), this.cutType === "guillotine" && (["l", "w", "flex"].includes(this.cutPreference) || this.issues.push({ message: `Invalid cut preference: ${this.cutPreference} for stock type: ${e}, cut type: ${this.cutType}` })), this.cutType === "beam" && [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" }), this.cutType === "beam" && (this.cutPreference = "l"), this.cutType || (this.cutType = "efficiency");
        break;
      case "linear":
        this.cutType = null, this.cutPreference = null;
        break;
    }
    switch (this.cutType) {
      case "efficiency":
        this.efficiencyOptions = yl({}, t == null ? void 0 : t.efficiencyOptions, { primaryCompression: "y" });
        break;
      case "guillotine":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        break;
      case "beam":
        this.guillotineOptions = yl({}, t == null ? void 0 : t.guillotineOptions, { strategy: "efficiency", maxPhase: null }), this.cutPreference = "l", [null, void 0].includes(this.stackHeight) && this.issues.push({ message: "Beam saws require a stack height to be set" });
        break;
    }
  }
  clone() {
    const t = structuredClone(this);
    return new qs(t);
  }
}
class is extends wd {
  constructor(e) {
    e = Ao(e), e.preventAutoRotation = (e == null ? void 0 : e.type) === "roll", e.autoAdd && !e.q && (e.q = 1);
    super(e);
    et(this, "_id");
    //used for mongo
    et(this, "autoAdd");
    et(this, "allowExactFitShapes");
    et(this, "analysis");
    et(this, "tidy");
    et(this, "used");
    et(this, "stack");
    et(this, "winningStrategy");
    //used for reporting
    et(this, "unusable");
    //used by stock matching
    et(this, "duplicatePattern");
    et(this, "score");
    et(this, "rootSegment");
    delete this.stock, this._id = e == null ? void 0 : e._id, this.autoAdd = jt(e == null ? void 0 : e.autoAdd) ? e.autoAdd : !1, this.allowExactFitShapes = jt(e == null ? void 0 : e.allowExactFitShapes) ? e.allowExactFitShapes : !1, this.analysis = jt(e.analysis) ? e.analysis : null, this.tidy = jt(e == null ? void 0 : e.tidy) ? e.tidy : !1, this.algoBenchmark = null, this.used = jt(e == null ? void 0 : e.used) ? e.used : !1, this.stack = jt(e == null ? void 0 : e.stack) ? e.stack : !1, this.duplicatePattern = (e == null ? void 0 : e.duplicatePattern) ?? null, this.initStock(e);
  }
  initStock(e) {
    switch (this.type) {
      case "linear":
      case "roll":
        this.trim.y1 = 0, this.trim.y2 = 0, this.grain = null;
        break;
    }
    this.validateStock(e), this.issues.length;
  }
  reset() {
    this.used = !1, this.stack = null, this.score = null, this.rootSegment = null, this.tidy = null, this.analysis = null, this.duplicatePattern = null, this.shapes = [];
  }
  validateStock(e) {
    ["grain"].forEach((i) => {
      this.createIssues(ai[i](e[i]));
    }), this.createIssues(ai.trim(this));
  }
  /**
   * compress for saving / transfer
   */
  save() {
    delete this.tidy, delete this.score, delete this.rootSegment, delete this.shapes, delete this.saw, this == null || delete this.algoBenchmark, this.stack = ns(this.stack) ? this.stack.id : this.stack, !this.trim.x1 && !this.trim.x2 && !this.trim.y1 && !this.trim.y2 && (this.trim = null);
  }
  resetStrategies() {
    this.algoBenchmark = null;
  }
  isIdentical(e) {
    let i = !1, r = !1, s = !1, o = !1;
    if (this.material === e.material && (i = !0), this.t === e.t && (r = !0), this.l === e.l && (s = !0), this.w === e.w && (o = !0), i && r && s && o) return !0;
  }
  hasStack() {
    return typeof this.stack == "number";
  }
  isStacked() {
    return ns(this.stack) || typeof this.stack == "string";
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = parseInt(i.pop()), e++), i.push(e.toString());
    const r = i.join("."), s = structuredClone(this);
    return s.id = r, s.used = !1, s.duplicate = !0, s.stack = !1, s.saw = this.saw, new is(s);
  }
}
class Ub extends $l {
  constructor(e) {
    super(e);
    et(this, "addToInventory");
    //for front end selection
    et(this, "added");
    //for adding to inputStock
    et(this, "placementOrder");
    et(this, "flex");
    this.cost = this.getCost(), this.addToInventory = (e == null ? void 0 : e.addToInventory) ?? !0, this.added = !1, this.placementOrder = (e == null ? void 0 : e.placementOrder) ?? null, this.offcut = !0;
  }
  compressForSaving() {
    var e;
    this.stockId = (this == null ? void 0 : this.stockId) || ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this._trim, delete this.trimmed;
  }
  getCost() {
    var e;
    return (e = this.stock) != null && e.isStock() && this.stock ? parseFloat((this.getArea() / this.stock.getArea() * this.stock.cost).toFixed(2)) : 0;
  }
}
function Wb({
  offcuts: n,
  stockList: t,
  preventAutoRotation: e = !0
}) {
  return !n || !(n != null && n.length) ? [] : n.map((i) => {
    const r = t.find((o) => {
      var a;
      return o.id === (((a = i == null ? void 0 : i.stock) == null ? void 0 : a.id) ?? (i == null ? void 0 : i.stockId));
    });
    return i.stock = r, e && (i.preventAutoRotation = !0), new Ub(i);
  });
}
class rs extends $l {
  constructor(e) {
    e = Ao(e);
    super(e);
    et(this, "added");
    et(this, "guillotineData");
    et(this, "stockLock");
    et(this, "score");
    et(this, "bestScore");
    et(this, "placementOrder");
    //groups
    et(this, "groupPlacementOrder");
    et(this, "group");
    et(this, "groupID");
    et(this, "inGroup");
    //is the shape currently part of at least one group
    et(this, "inUserGroup");
    //is the shape currently part of a user group`
    et(this, "addedAsGroup");
    et(this, "isFirstShape");
    et(this, "firstShapeSampleRotations", []);
    //used for setting the rotation of the first shape (guillotine)
    et(this, "index");
    //used for ptx
    et(this, "patternMatch");
    //used for stack detection
    et(this, "stockMatch");
    et(this, "minSpacing");
    et(this, "priority");
    et(this, "weighting", {});
    //objects
    et(this, "machining");
    et(this, "_banding", Object.fromEntries(
      Ts.map((e) => [e, !1])
    ));
    et(this, "_finish", Object.fromEntries(
      pr.map((e) => [e, ""])
    ));
    this.initShape(e);
  }
  initShape(e, i = !1) {
    var r;
    if (!i) {
      if (this.validateShape(e), this.issues.length) throw new Error(this.issues.map((s) => s.message).join(`
`));
      e.orientationLock = (r = e == null ? void 0 : e.orientationLock) == null ? void 0 : r.toLowerCase(), (e == null ? void 0 : e.orientationLock) === " " && (e.orientationLock = ""), this.orientationLock = jt(e == null ? void 0 : e.orientationLock) && this.l !== this.w ? e.orientationLock : null, jt(e == null ? void 0 : e.stockLock) ? Array.isArray(e == null ? void 0 : e.stockLock) && (this.stockLock = e.stockLock.map((s) => s.toString())) : this.stockLock = [], this.banding = e == null ? void 0 : e.banding, this.finish = e == null ? void 0 : e.finish, this.machining = jt(e == null ? void 0 : e.machining) ? new f1(e.machining) : null;
    }
    this.added = jt(e == null ? void 0 : e.added) ? e.added : !1, this.initGuillotineData(e), this.inGroup = jt(e == null ? void 0 : e.inGroup) ? e.inGroup : this.inGroup || !1, this.inUserGroup = jt(e == null ? void 0 : e.inUserGroup) ? e.inUserGroup : this.inUserGroup || !1, this.groupID = jt(e == null ? void 0 : e.groupID) ? e.groupID : this.groupID || null, this.addedAsGroup = jt(e == null ? void 0 : e.addedAsGroup) ? e.addedAsGroup : this.addedAsGroup || !1, this.score = jt(e == null ? void 0 : e.score) ? e.score : this.score || null, this.bestScore = jt(e == null ? void 0 : e.bestScore) ? e.bestScore : this.bestScore || {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    }, this.placementOrder = jt(e == null ? void 0 : e.placementOrder) ? e.placementOrder : this.placementOrder || null, this.groupPlacementOrder = jt(e == null ? void 0 : e.groupPlacementOrder) ? e.groupPlacementOrder : this.groupPlacementOrder || null, this.minSpacing = (e == null ? void 0 : e.minSpacing) ?? (this.minSpacing || 0), this.priority = (e == null ? void 0 : e.priority) ?? {};
  }
  initGuillotineData(e) {
    var i, r, s, o, a, l, h, u;
    this.guillotineData = yl({}, e == null ? void 0 : e.guillotineData, {
      firstShape: ((i = this == null ? void 0 : this.guillotineData) == null ? void 0 : i.firstShape) || null,
      myPhase: ((r = this == null ? void 0 : this.guillotineData) == null ? void 0 : r.myPhase) || null,
      myStripParent: ((s = this == null ? void 0 : this.guillotineData) == null ? void 0 : s.myStripParent) || null,
      myStripDirection: ((o = this == null ? void 0 : this.guillotineData) == null ? void 0 : o.myStripDirection) || null,
      stripShapeBatches: {
        subsetUsed: ((l = (a = this == null ? void 0 : this.guillotineData) == null ? void 0 : a.stripShapeBatches) == null ? void 0 : l.subsetUsed) || !1,
        groups: ((u = (h = this == null ? void 0 : this.guillotineData) == null ? void 0 : h.stripShapeBatches) == null ? void 0 : u.groups) || {}
      }
    });
  }
  cloneGuillotineData() {
    var e;
    return (e = this.guillotineData) != null && e.myStripParent && (yr(this.guillotineData.myStripParent) || Pr(this.guillotineData.myStripParent)) && (this.guillotineData.myStripParent = this.guillotineData.myStripParent.compress()), structuredClone(this.guillotineData);
  }
  getCopyNumber() {
    return parseInt(this.id.split(".").pop());
  }
  getMinSpacing(e, i = !1) {
    var o, a;
    if (!e) return 0;
    let r = (this == null ? void 0 : this.minSpacing) || ((a = (o = e.saw) == null ? void 0 : o.options) == null ? void 0 : a.minSpacing) || 0;
    const s = e.getBladeWidth();
    return s > r && (r = s), i && (r -= s), r < 0 && (r = 0), r;
  }
  validateShape(e) {
    ["orientationLock", "banding"].forEach((i) => {
      this.createIssues(ai[i](e[i]));
    }), this.machining && this.machining.validateEverything(this);
  }
  //individual shape weighting
  /* calculateWeighting()
  	{
  		// const aspect = this.w / this.l;
  		if ( aspect > 0.5 )
  		{
  			//cater for small parts
  			const area = s.getArea();
  			const areaPercentage = area / maxArea;
  
  			if ( areaPercentage <= 0.1 )
  			{
  				s.weighting.edge = areaPercentage;
  			}
  		}
  		//the closer to zero, the higher the edge weighting
  		this.weighting.edge = 1 - aspect;
  		this.weighting.edge *= 2;
  	} */
  update(e) {
    e = Ao(e), this.initShape(e, !0), this.updateRectangle(e);
  }
  //banding
  set banding(e) {
    if (this._banding = Object.fromEntries(
      Ts.map((i) => [i, !1])
    ), !!No(e, !0))
      for (const i of Ts)
        this._banding[i] = jt(e == null ? void 0 : e[i]) ? e[i] : !1;
  }
  get banding() {
    return this._banding;
  }
  //get an array of banding in the order L1, L2, W1, W2
  get bandingArray() {
    return Db(this._banding);
  }
  get finish() {
    return this._finish;
  }
  get FacesArray() {
    return pr.map((e) => {
      var i;
      return (i = this.finish) == null ? void 0 : i[e];
    });
  }
  set finish(e) {
    if (this._finish = Object.fromEntries(
      pr.map((i) => [i, ""])
    ), !!No(e, !0))
      for (const i of pr)
        this._finish[i] = jt(e == null ? void 0 : e[i]) ? e[i] : "";
  }
  //compress for saving / transfer
  save() {
    var e, i, r;
    delete this.group, (e = this == null ? void 0 : this.guillotineData) == null || delete e.stripShapeBatches, this.stockId = (i = this == null ? void 0 : this.stock) == null ? void 0 : i.id, delete this.stock, delete this.score, delete this.bestScore, Ts.every((s) => {
      var o;
      return !((o = this._banding) != null && o[s]);
    }) && (this._banding = null), pr.every((s) => {
      var o;
      return !((o = this._finish) != null && o[s]);
    }) && (this._finish = null), Fb(this), (r = this.guillotineData) == null || delete r.myStripParent, delete this.score, delete this.inGroup, delete this.groupID, delete this.addedAsGroup, delete this.proximity;
  }
  isExactFit(e) {
    return this.orientationLock === "w" && this.w === e.w || this.orientationLock === "l" && this.l === e.l || !this.orientationLock && this.w === e.w && this.l === e.l;
  }
  addToStock(e) {
    this.stock = e, this.stockId = e.id, this.added = !0, this.inGroup = !1, e.used = !0, this.grain = e.grain, e != null && e.grain && this.rot && (this.grain = So(e.grain)), H0([
      () => Ds(this.isInsideStock(e), `shape ${this.id} is not inside stock`).to.be.true
    ]);
  }
  removeFromStock() {
    this.placementOrder = null, this.stock = null, this.stockId = null, this.added = !1, this.addedAsGroup = !1, this == null || delete this.isFirstShape, Pr(this) && this.shapes.forEach((e) => e.removeFromStock());
  }
  setBestScore(e, i = null) {
    const r = {
      x: e.x,
      y: e.y,
      rot: e.rot,
      total: e.score.total,
      score: e.score,
      group: e.group,
      weighting: null,
      point: i
    };
    this.bestScore = r;
  }
  resetBestScore() {
    const e = {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.bestScore = e, this.resetGuillotineData(!0);
  }
  resetScore() {
    this.score = null, this.resetGuillotineData(!0);
  }
  resetBothScores() {
    this.resetBestScore(), this.resetScore();
  }
  resetPosition() {
    this.x = 0, this.y = 0, this.placementOrder = null, this.resetGuillotineData(!0);
  }
  resetGroupData() {
    this.inGroup = !1, this.group = null, this.groupID = null, this.groupPlacementOrder = null, this.grain = null;
  }
  resetGuillotineData(e = !1) {
    var r, s;
    const i = {
      firstShape: !1,
      myPhase: null,
      myStripDirection: null,
      stripShapeBatches: {
        subsetUsed: !1,
        groups: {}
      }
    };
    e && (i.stripShapeBatches.groups = (s = (r = this.guillotineData) == null ? void 0 : r.stripShapeBatches) == null ? void 0 : s.groups), this.guillotineData = i;
  }
  reset(e = !1, i = !0, r = !1) {
    this.removeFromStock(), this.resetPosition(), this.setRotation(0), this.placementOrder = null, this == null || delete this.isFirstShape, this.patternMatch = !1, e || this.resetBothScores(), r || this.resetGroupData(), this.resetGuillotineData(i);
  }
  round() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y),
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  //get an array of allowed rotations for this container
  getAllowedRotations(e) {
    const i = [];
    for (let r = 0; r <= 1; r++)
      this.canRotate(r, e) && this.willItFit(e, r) && i.push(r);
    return i;
  }
  /**
   * checks if a shape can rotate
   * checks for fit and grain
   * does not change the shape's rotation during the checks
   * @returns false if cannot rotate or can rotate but won't fit
   */
  canRotate(e = null, i = null) {
    if (!jt(e))
      throw new Error("no rotation provided to canRotate");
    if (e === !0 && (e = 1), e === !1 && (e = 0), this.isSquare() && e || i && !this.willItFit(i, e))
      return !1;
    const r = this.getNecessaryOrientation(i);
    return !(r === "l" && e === 1 || r === "w" && e === 0);
  }
  /**
   * can a shape rotate to produce the specified dimensions on a specific side
   * @todo tests
   */
  canRotateToDimension(e, i, r = null) {
    if (!i) throw new Error("requiredSide not supplied to canRotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (r) {
      if (i === "l") {
        if (s === e && this.canRotate(0, r) || o === e && this.canRotate(1, r)) return !0;
      } else if (i === "w" && (o === e && this.canRotate(0, r) || s === e && this.canRotate(1, r)))
        return !0;
    } else if (this.orientationLock) {
      if (this.orientationLock === "l")
        return i === "l" && e === s;
      if (this.orientationLock === "w")
        return i === "l" && e === o;
    }
    return !1;
  }
  canRotateToDimensionRange(e, i, r, s = null) {
    if (!r) throw new Error("requiredSide not supplied to canRotateToDimensionRange");
    if (this.l >= e && this.l <= i || this.w >= e && this.w <= i) {
      if (this.l === this.w) return !0;
      const o = this.getLongSide(), a = this.getShortSide();
      if (s) {
        if (r === "l") {
          if (o >= e && o <= i && this.canRotate(0, s) || a >= e && a <= i && this.canRotate(1, s)) return !0;
        } else if (r === "w" && (a >= e && a <= i && this.canRotate(0, s) || o >= e && o <= i && this.canRotate(1, s)))
          return !0;
      } else if (this.orientationLock) {
        if (this.orientationLock === "l")
          return r === "l" && o >= e && o <= i;
        if (this.orientationLock === "w")
          return r === "l" && a >= e && a <= i;
      }
    }
    return !1;
  }
  rotateToDimension(e, i, r) {
    if (!i) throw new Error("requiredSide not supplied to rotateToDimension");
    if (this.l !== e && this.w !== e) return !1;
    if (this.l === this.w) return !0;
    const s = this.getLongSide(), o = this.getShortSide();
    if (i === "l") {
      if (s === e && this.canRotate(0, r)) return this.setRotation(0);
      if (o === e && this.canRotate(1, r)) return this.setRotation(1);
    } else if (i === "w") {
      if (o === e && this.canRotate(0, r)) return this.setRotation(0);
      if (s === e && this.canRotate(1, r)) return this.setRotation(1);
    }
    return !1;
  }
  //get the orientation lock catering for container grain
  convertShapeGrainToOrientationLock(e) {
    if (!e) throw new Error("container not supplied to convertShapeGrainToOrientationLock");
    if (!af(e)) throw new Error("container is not a container");
    if (Pr(this)) return this.orientationLock;
    if (!jt(this.orientationLock)) return null;
    const i = e.getStock();
    return jt(i.grain) ? this.orientationLock === i.grain ? "l" : "w" : this.orientationLock;
  }
  /**
   * get the orientation lock catering for container grain
   */
  getNecessaryOrientation(e) {
    if (!e) return this.orientationLock;
    if (Pr(this)) return this.orientationLock;
    if (!jt(this.orientationLock)) return null;
    if (af(e))
      return this.convertShapeGrainToOrientationLock(e);
    if (Pr(this) || xd(this))
      return jt(this.orientationLock) ? this.orientationLock : null;
  }
  /**
   * get the required grain rotation
   * checks for stock grain and part orientationLock
   * does not check for fit
   */
  getGrainRotation(e) {
    if (Pr(this)) return this.rot;
    if (!jt(this.orientationLock)) return null;
    const i = e.getStock();
    return !this.orientationLock || !jt(i == null ? void 0 : i.grain) ? null : this.isGroup() ? this.orientationLock === "l" ? 0 : 1 : this.orientationLock === (i == null ? void 0 : i.grain) ? 0 : 1;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  rotate(e = null, i = null) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.canRotate(e, i) ? (this.rot === e || this.swapDimensions(), !0) : !1;
  }
  swapDimensions() {
    [this.l, this.w] = [this.w, this.l];
  }
  forceRotate(e) {
    return e === null && (e = this.rot === 0 ? 1 : 0), this.rot === e || this.swapDimensions(), !0;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotation(e = null, i = null) {
    return e ? e = 1 : e = 0, i && e && !this.willItFit(i, e) ? !1 : this.rotate(e, i);
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotationToOrientationLock(e) {
    if (!e)
      throw new Error("container not supplied to setRotationToOrientationLock");
    const i = this.getNecessaryOrientation(e);
    if (i === "l") return this.setRotation(0);
    if (i === "w") return this.setRotation(1);
  }
  setRotationToOrientationLockWithoutContainer() {
    if (this.orientationLock === "l") return this.setRotation(0);
    if (this.orientationLock === "w") return this.setRotation(1);
  }
  getBandingLength(e) {
    return !Rb(e) || !this.banding[e] ? 0 : e === "x1" || e === "x2" ? this.getShortSide() : e === "y1" || e === "y2" ? this.getLongSide() : p1(e) ? c1(this, e) : 0;
  }
  getPriority(e) {
    var r;
    if (!e) return 0;
    const i = e.parentID;
    return (r = this.priority) != null && r[i] ? this.priority[i] : 0;
  }
  clearPriority() {
    this.priority = {};
  }
  getPerimeterCutVectors() {
    var r;
    const e = (r = this.stock) != null && r.isStock() ? this.stock.getBladeWidth() / 2 : null;
    return [
      //bottom
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y - e,
        type: "bottom"
      },
      //right
      {
        x1: this.x + this.l + e,
        x2: this.x + this.l + e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "right"
      },
      //top
      {
        x1: this.x - e,
        x2: this.x + this.l + e,
        y1: this.y + this.w + e,
        y2: this.y + this.w + e,
        type: "top"
      },
      //left
      {
        x1: this.x - e,
        x2: this.x - e,
        y1: this.y - e,
        y2: this.y + this.w + e,
        type: "left"
      }
    ];
  }
  /* getTrimmedDimensions()
  	{
  		if ( this.trimmed )
  			return {
  				l: this.l,
  				w: this.w
  			};
  
  		return {
  			l: this.l - this.trim.x1 - this.trim.x2,
  			w: this.w - this.trim.y1 - this.trim.y2
  		};
  	} */
  /**
   * create cuts around the perimeter of a shape
   * @param {Stock} stock
   * @returns {Array} cuts
   */
  createPerimeterCuts(e = null) {
    let i = [];
    if (e = e || this.stock, !e) throw new Error("stock is required to create a cut");
    return this.getPerimeterCutVectors().forEach((s) => {
      var o;
      return i.push(new Fc({
        stock: (o = this.stock) != null && o.isStock() ? this.stock : e,
        x1: s.x1,
        x2: s.x2,
        y1: s.y1,
        y2: s.y2,
        type: s.type
      }));
    }), i = i.filter((s) => s.isInsideStock()), i;
  }
  createOffset(e) {
    if (!this.stock) throw new Error("createOffset - stock not defined");
    const i = {
      x: this.x - e,
      y: this.y - e,
      l: this.l + e * 2,
      w: this.w + e * 2
    };
    return i.x < 0 && (i.x = 0, i.l -= e), i.y < 0 && (i.y = 0, i.w -= e), i.x + i.l > this.stock.l && (i.l = this.stock.l - i.x), i.y + i.w > this.stock.w && (i.w = this.stock.w - i.y), i;
  }
  setPositionToBestScore() {
    this.setRotation(this.bestScore.rot), this.x = this.bestScore.x, this.y = this.bestScore.y;
  }
  /**
   * will this shape fit in a container
   */
  willItFit(e, i = null) {
    return g1(e, this, i);
  }
  clone(e = null) {
    const i = this.id.split(".");
    e ? i.pop() : (e = i.pop(), e++), i.push(e);
    const r = i.join("."), s = this.stock;
    this.stock = null;
    const o = structuredClone(this);
    return o.stock = s, o.id = r, o.added = !1, o.duplicate = !0, delete o.score, delete o.bestScore, delete o.stock, delete o.placementOrder, delete o.inGroup, delete o.addedAsGroup, delete o.groupID, delete o.isFirstShape, new rs(o);
  }
  //this is a compressed version of the shape to help with memory management
  compress() {
    const e = this.cloneGuillotineData();
    return e.myStripParent = Kb(this.guillotineData.myStripParent) ? this.guillotineData.myStripParent.id : this.guillotineData.myStripParent, {
      id: this.id,
      x: this.added ? this.x : 0,
      y: this.added ? this.y : 0,
      l: this.l,
      w: this.w,
      added: this.added,
      guillotineData: e,
      placementOrder: this.placementOrder,
      bestScore: this.bestScore,
      inGroup: this.inGroup,
      groupID: this.groupID,
      addedAsGroup: this.addedAsGroup,
      groupPlacementOrder: this.groupPlacementOrder,
      minSpacing: this.minSpacing,
      cloneType: "shape",
      priority: Object.assign({}, this.priority)
    };
  }
  isTooCloseToEdges(e) {
    var r, s;
    const i = ((s = (r = e.saw) == null ? void 0 : r.options) == null ? void 0 : s.minSpacing) || this.minSpacing;
    return i ? this.getDistancesToContainerEdges(e).some((o) => o > 0 && o <= i) : !1;
  }
  validateStripShapeBatches() {
    const e = Object.values(this.guillotineData.stripShapeBatches.groups);
    for (let i = 0; i < e.length; i++) {
      const r = e[i];
      if (r.id !== this.id)
        throw new Error(`strip shape group id does not match shape id ${this.id} ${r.id} ${i}`);
      if (![this.l, this.w].includes(r.dimension))
        throw new Error(`strip shape group dimension does not match shape dimensions ${this.id} ${r.id} ${i} ${this.l} ${this.w} ${r.dimension}`);
    }
  }
  getStripShapeBatchData(e) {
    var i;
    return typeof e != "number" || !((i = this == null ? void 0 : this.guillotineData) != null && i.stripShapeBatches) || !this.guillotineData.stripShapeBatches.groups || !(e in this.guillotineData.stripShapeBatches.groups) ? !1 : this.guillotineData.stripShapeBatches.groups[e];
  }
  isInStripShapeBatch(e) {
    return !!this.getStripShapeBatchData(e);
  }
  isStacked() {
    return this.added && this.stock && this.stock.isStacked();
  }
}
class y1 extends wd {
  constructor(e) {
    var t = (...oA) => (super(...oA), et(this, "firstShape"), et(this, "cuts"), et(this, "phase"), et(this, "merged"), et(this, "children"), et(this, "siblings"), //used by vis only
    et(this, "parent"), et(this, "segmentType"), et(this, "completed"), //used by vis only
    et(this, "rowSegment"), //used by cuts
    et(this, "placementOrder"), et(this, "hasBeamTrim"), et(this, "cutDirection"), this);
    if (e) {
      if (e.preventAutoRotation = !0, t(e), this.validateSegment(e), this.issues.length)
        throw new Error(`Segment validation failed - ${this.issues.join(" ")}`);
      delete this.trim, delete this.trimmed, this.shapes = jt(e == null ? void 0 : e.shapes) ? e.shapes : [], this.firstShape = jt(e == null ? void 0 : e.firstShape) ? e.firstShape : null, this.cuts = [], this.phase = jt(e == null ? void 0 : e.phase) ? e.phase : null, this.merged = jt(e == null ? void 0 : e.merged) ? e.merged : !1, this.parent = jt(e == null ? void 0 : e.parent) ? e.parent : null, this.children = jt(e == null ? void 0 : e.children) ? e.children : [], this.siblings = jt(e == null ? void 0 : e.siblings) ? e.siblings : [], this.offcut = jt(e == null ? void 0 : e.offcut) ? e.offcut : !1, this.segmentType = jt(e == null ? void 0 : e.segmentType) ? e.segmentType : null, this.placementOrder = null, this.cutDirection = jt(e == null ? void 0 : e.cutDirection) ? e.cutDirection : "l", this.hasBeamTrim = jt(e == null ? void 0 : e.hasBeamTrim) ? e.hasBeamTrim : !1;
    }
  }
  validateSegment(e) {
    var i, r;
    (Ve.lessThanOrEqualTo(e.w, 0) || Ve.lessThanOrEqualTo(e.l, 0)) && this.issues.push({ message: `Zero / negative dimension - l: ${e.l}, w: ${e.w}.` }), (Ve.lessThan(e.x, 0) || Ve.lessThan(e.y, 0)) && this.issues.push({ message: `Negative position - x: ${e == null ? void 0 : e.x}, y: ${e == null ? void 0 : e.y}.` }), e != null && e.stock && (Ve.greaterThan(e.x + e.l, e.stock.l) || Ve.greaterThan(e.y + e.w, e.stock.w)) && this.issues.push({ message: `Outside of stock ${e.stock.id} - x: ${e.x}, y: ${e.y}, l: ${e.l}, w: ${e.w}, sl: ${(i = e == null ? void 0 : e.stock) == null ? void 0 : i.l}, sw: ${(r = e == null ? void 0 : e.stock) == null ? void 0 : r.w}.` });
  }
  //compress for saving / transfer
  save() {
    var e;
    this.children = this.children.map((i) => ({
      id: i.id,
      x: i.x,
      y: i.y,
      l: i.l,
      w: i.w,
      offcut: i.offcut
    })), this.stockId = (this == null ? void 0 : this.stockId) ?? ((e = this == null ? void 0 : this.stock) == null ? void 0 : e.id), delete this.stock, delete this.shapes, delete this.saw, delete this.siblings, delete this.parent, delete this.trim, this.algoBenchmark = null;
  }
  getBladeWidth() {
    return this.stock.getBladeWidth();
  }
  /**
   * create a normalised shape list to allow searching for duplicates
   */
  getNormalisedShapes(e) {
    return e.map((i) => ({
      x: i.x - this.x,
      y: i.y - this.y,
      l: i.l,
      w: i.w
    }));
  }
  reset() {
    this.stock.used = !1, this.children = [], this.siblings = [], this.parent = null, this.cuts = [], this.phase = null;
  }
}
class Ws extends rs {
  //used for sorting
  constructor(e) {
    var i, r;
    if (e = Ao(e), !((i = e == null ? void 0 : e.shapes) != null && i.length))
      throw new Error("attempting to create a group with no shapes");
    e.preventAutoRotation = !0;
    super(e);
    et(this, "shapes");
    et(this, "positions");
    et(this, "direction");
    et(this, "container");
    et(this, "outOfBounds");
    et(this, "collision");
    et(this, "counter", 0);
    et(this, "type");
    et(this, "efficiency");
    this.q = 1, delete this._banding, delete this._finish, delete this._trim, this.shapes = e.shapes, this.positions = (r = e == null ? void 0 : e.positions) != null && r.length ? e.positions : [], this.direction = e.direction, this.container = e.container, this.type = (e == null ? void 0 : e.type) ?? "auto", this.initGroup();
  }
  initGroup() {
    var e;
    (e = this == null ? void 0 : this.shapes) != null && e.length && (this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]));
  }
  setShapePositions() {
    if (!this.container) return;
    this.positions = [], this.type !== "user" && this.sortShapes();
    let e = 0;
    const i = V2(this.direction);
    this.shapes.forEach((o, a) => {
      this.positions.push({
        shape: o.id,
        [i]: e,
        [Y2(i)]: 0,
        rot: o.rot.valueOf()
      }), o.inGroup = !0, e += a === this.shapes.length - 1 ? o[this.direction] : o[this.direction] + o.getMinSpacing(this.container);
    }), this[this.direction] = e;
    const r = So(this.direction), s = this.shapes.reduce((o, a) => a[r] > o ? a[r] : o, 0);
    if (this[r] = s, W0()) {
      const o = this.shapes.slice(0, -1).reduce((h, u) => h + u.getMinSpacing(this.container), 0), l = this.shapes.reduce((h, u) => h + u[this.direction], 0) + o;
      H0([
        () => Ds(Ve.equalTo(l, this[this.direction]), "group dimension is incorrect in direction").to.be.true,
        () => Ds(e, "currentPosition is incorrect in direction").to.equal(this[this.direction]),
        () => Ds(s, "group dimension in other direction is not correct").to.equal(this[r])
      ]);
    }
    if (this.w > this.container.w || this.l > this.container.l)
      throw new Error(`group ${this.id} is bigger than container - group ${this.l}x${this.w}, container ${this.container.l}x${this.container.w}`);
  }
  //update the shape spacing and overall group dimensions to account for min spacing
  updateShapeSpacing(e) {
    this.container = e, this.setShapePositions(), this.w > this.l ? this.orientationLock = "w" : this.orientationLock = "l", this.container && (this.efficiency = this[this.direction] / this.container[this.direction]);
  }
  //get the area of the shapes (does not include blade width) - overwrites the rectangle method
  getArea() {
    return this.shapes.reduce((e, i) => e + i.getArea(), 0);
  }
  destroy() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !1);
  }
  reset() {
    super.reset();
    for (const e of this.shapes) e.reset(!1, !1, !0);
  }
  /**
   * orientate all the shapes correctly to fit in the group
   */
  orientateShapes(e) {
    this.shapes.forEach((i) => {
      const r = this.positions.find((o) => o.shape === i.id);
      if (!r) throw new Error("position not found for shape in group");
      if (!i.rotate(r.rot, e)) throw new Error("orientateShapes - unable to rotate shape in group");
    });
  }
  /**
   * sort the shapes by size
   */
  sortShapes() {
    const e = So(this.direction);
    this.shapes.sort((i, r) => r[e] === i[e] ? r[this.direction] === i[this.direction] ? i.id.localeCompare(r.id, void 0, { numeric: !0 }) : r[this.direction] - i[this.direction] : r[e] - i[e]);
  }
  /**
   * place the group shapes on the stock
   */
  placeMyShapes(e) {
    if (!e) throw new Error("placeShapes requires stock");
    this.addToStock(e);
    for (let i = 0; i < this.shapes.length; i++) {
      const r = this.shapes[i];
      r.addToStock(e);
      const s = this.positions.find((l) => l.shape === r.id);
      if (!s) throw new Error("position not found for shape in group");
      if (r.x = this.x + s.x, r.y = this.y + s.y, !r.rotate(s.rot, e)) throw new Error("placeMyShapes - unable to rotate shape in group");
      i === 0 && this.x === 0 && this.y === 0 && (r.isFirstShape = !0), r.addedAsGroup = this.id, r.inGroup = !1, r.score = this.score;
      const a = r.guillotineData.stripShapeBatches;
      r.guillotineData = this.cloneGuillotineData(), r.guillotineData.stripShapeBatches = a, r.bestScore = this.bestScore, typeof this.placementOrder == "number" && (r.groupPlacementOrder = i, r.placementOrder = this.placementOrder + i / 1e6);
    }
  }
  //this is for groups which are created once and reused between stock e.g. user groups
  orientateCorrectly(e) {
    this.orientateShapes(e), this.setRotationToOrientationLock(e);
  }
  clone(e = []) {
    const r = `g${parseInt(this.id.split("g")[1]) + 1}`, s = this.shapes, o = this.container, a = this.stock;
    this.shapes = [], this.container = null, this.stock = null;
    const l = structuredClone(this);
    return this.shapes = s, this.container = o, this.stock = a, l.container = this.container, l.shapes = e, l.id = r, new Ws(l);
  }
  compress() {
    const e = super.compress.call(this);
    return e.direction = this.direction, e.positions = structuredClone(this.positions), e.shapes = this.shapes.map((i) => i.compress()), e.type = this.type, e.cloneType = "group", e;
  }
}
function Hb(n, t, e, i) {
  return t.filter((r, s) => {
    var o, a;
    return n.stockMatch.material[s] = null, n.stockMatch.thickness[s] = null, n.stockMatch.width[s] = null, n.stockMatch.fit[s] = null, (yr(n) || xd(n)) && (g1(r, n) ? n.stockMatch.fit[s] = !0 : n.stockMatch.fit[s] = !1), e ? !(r != null && r.material) && !(n != null && n.material) || ((o = r == null ? void 0 : r.material) == null ? void 0 : o.toLowerCase()) === ((a = n == null ? void 0 : n.material) == null ? void 0 : a.toLowerCase()) ? n.stockMatch.material[s] = !0 : n.stockMatch.material[s] = !1 : n.stockMatch.material[s] = !0, i ? jt(n.t) && jt(r.t) ? (yr(n) && Ve.equalTo(n.t, r.t) || n.t === r.t) && (n.stockMatch.thickness[s] = !0) : n.stockMatch.thickness[s] = !1 : n.stockMatch.thickness[s] = !0, r.type === "linear" ? yr(n) && (n.canRotate(0, r) && Ve.equalTo(n.w, r.w) || n.canRotate(1, r) && Ve.equalTo(n.l, r.w) ? n.stockMatch.width[s] = !0 : n.stockMatch.width[s] = !1) : n.stockMatch.width[s] = !0, n.stockMatch.fit[s] && n.stockMatch.material[s] && n.stockMatch.thickness[s] && n.stockMatch.width[s];
  });
}
function Gb(n, t, e) {
  const i = Ji(n[0]);
  if (i && (t = t.map((u) => {
    const d = new is(u);
    return d.trimDimensions(), d;
  }), n = n.map((u) => {
    const d = new rs(u);
    return d.trimDimensions(), d;
  })), Uu(t[0]) && (t = t.map((u, d) => (u.id = `${d.toString()}.0`, new is(u)))), n.some((u) => jt(u.stockLock) && u.stockLock.length)) return;
  t = t.filter((u) => u.autoAdd === !0 || jt(u.q) && u.q > 0);
  const s = t.some((u) => jt(u.material)), o = t.some((u) => jt(u.t)), a = /* @__PURE__ */ new Set();
  for (const u of n) {
    u.stockMatch = {
      material: [],
      thickness: [],
      width: [],
      fit: []
    };
    const d = Hb(u, t, s, o);
    if (u.stockMatch.fit = !u.stockMatch.fit.every((p) => p === !1), u.stockMatch.material = !u.stockMatch.material.every((p) => p === !1), u.stockMatch.thickness = !u.stockMatch.thickness.every((p) => p === !1), u.stockMatch.width = !u.stockMatch.width.every((p) => p === !1), !i) {
      if (d.length) {
        const p = d.map((f) => f.getParentID());
        u.stockLock = p, p.forEach((f) => a.add(f));
      } else if (u.stockMatch.fit)
        u.stockMatch.material || u.issues.push({ message: `materials must match - could not find any stock with ${u.material ? u.material + " material" : "no material set"}` }), u.stockMatch.thickness || u.issues.push({ message: `thicknesses must match - could not find any stock with ${u.t ? "thickness " + u.t : "no thickness set"}` }), e === "linear" && !u.stockMatch.width && u.issues.push({ message: `widths must match for linear calculations - could not find any stock with ${u.w ? "width " + u.w : "no width set"}` });
      else {
        const p = u.getTrimmedDimensions();
        u.issues.push({ message: `${p.l.toFixed()}x${p.w.toFixed()} will not fit on any stock - check dimensions, min spacing, trim & orientation lock` });
      }
      u.stockMatch = null;
    }
  }
  const l = n.filter((u) => !u.stockLock || !u.stockLock.length).sort(Ju.ID), h = t.filter((u) => !a.has(u.parentID)).sort(Ju.ID);
  return t = t.filter((u) => ns(u)).filter((u) => a.has(u.parentID)), (s || o) && (n = n.filter((u) => {
    var d;
    return (d = u == null ? void 0 : u.stockLock) == null ? void 0 : d.length;
  })), {
    stockList: t,
    unusableStock: h,
    shapeList: n,
    unusableShapes: l
  };
}
function Vb(n) {
  if (!n.length) return "n";
  const t = n.map((e) => e.grain).filter((e) => e);
  return t.length ? t.every((e) => e === "l") ? "l" : t.every((e) => e === "w") ? "w" : t.some((e) => e === "l" || e === "w") ? "y" : "n" : "n";
}
function Yb(n) {
  return n.shapes !== void 0;
}
function Pr(n) {
  return n instanceof Ws && n.type !== "user";
}
function xd(n) {
  return n instanceof Ws && n.type === "user";
}
function co(n) {
  return n instanceof Mb;
}
function Uu(n) {
  return n instanceof m1;
}
function Ji(n) {
  return n instanceof vd;
}
function ns(n) {
  return n instanceof is;
}
function af(n) {
  return n instanceof wd;
}
function yr(n) {
  return n instanceof rs && !(n instanceof Ws);
}
function Kb(n) {
  return n instanceof rs || n instanceof Ws;
}
function Xb(n) {
  return n instanceof y1;
}
function Jb(n) {
  return n instanceof qs;
}
function Zb(n) {
  return !n || typeof n != "string" ? "" : n.toUpperCase();
}
function ac(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n) !== void 0;
}
function Rn(n, t) {
  return t.reduce((e, i) => e && e[i] !== void 0 ? e[i] : void 0, n);
}
function jt(n) {
  return !(n === void 0 || n === null || n === "" || typeof n == "object" && !Object.values(n).length);
}
function No(n, t = !1) {
  if (!jt(n) || typeof n != "object") return !1;
  const e = Object.values(n);
  return e.length === 0 ? !1 : t ? e.some((i) => jt(i) && i) : e.some((i) => jt(i));
}
function Qb(n) {
  return n != null && n.length ? n.filter((t) => t.used && (t.stack === !1 || typeof t.stack == "number")) : [];
}
function tv() {
  const n = document.documentElement;
  return "requestFullscreen" in n || "webkitRequestFullscreen" in n || "mozRequestFullScreen" in n || "msRequestFullscreen" in n;
}
function Ul(n) {
  return n ? (n = n.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^ a-z0-9._\-|]/gim, ""), n.trim()) : null;
}
function b1(n, t = 100) {
  return n ? (n = n.trim(), n = n.substring(0, t), n) : "";
}
function nn(n) {
  "@babel/helpers - typeof";
  return nn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nn(n);
}
var li = Uint8Array, Ri = Uint16Array, _d = Int32Array, Rc = new li([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Dc = new li([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), lf = new li([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), v1 = function(n, t) {
  for (var e = new Ri(31), i = 0; i < 31; ++i)
    e[i] = t += 1 << n[i - 1];
  for (var r = new _d(e[30]), i = 1; i < 30; ++i)
    for (var s = e[i]; s < e[i + 1]; ++s)
      r[s] = s - e[i] << 5 | i;
  return { b: e, r };
}, w1 = v1(Rc, 2), x1 = w1.b, uf = w1.r;
x1[28] = 258, uf[258] = 28;
var _1 = v1(Dc, 0), ev = _1.b, Wp = _1.r, cf = new Ri(32768);
for (var dn = 0; dn < 32768; ++dn) {
  var Ls = (dn & 43690) >> 1 | (dn & 21845) << 1;
  Ls = (Ls & 52428) >> 2 | (Ls & 13107) << 2, Ls = (Ls & 61680) >> 4 | (Ls & 3855) << 4, cf[dn] = ((Ls & 65280) >> 8 | (Ls & 255) << 8) >> 1;
}
var Or = function(n, t, e) {
  for (var i = n.length, r = 0, s = new Ri(t); r < i; ++r)
    n[r] && ++s[n[r] - 1];
  var o = new Ri(t);
  for (r = 1; r < t; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  var a;
  if (e) {
    a = new Ri(1 << t);
    var l = 15 - t;
    for (r = 0; r < i; ++r)
      if (n[r])
        for (var h = r << 4 | n[r], u = t - n[r], d = o[n[r] - 1]++ << u, p = d | (1 << u) - 1; d <= p; ++d)
          a[cf[d] >> l] = h;
  } else
    for (a = new Ri(i), r = 0; r < i; ++r)
      n[r] && (a[r] = cf[o[n[r] - 1]++] >> 15 - n[r]);
  return a;
}, zs = new li(288);
for (var dn = 0; dn < 144; ++dn)
  zs[dn] = 8;
for (var dn = 144; dn < 256; ++dn)
  zs[dn] = 9;
for (var dn = 256; dn < 280; ++dn)
  zs[dn] = 7;
for (var dn = 280; dn < 288; ++dn)
  zs[dn] = 8;
var Ll = new li(32);
for (var dn = 0; dn < 32; ++dn)
  Ll[dn] = 5;
var nv = /* @__PURE__ */ Or(zs, 9, 0), iv = /* @__PURE__ */ Or(zs, 9, 1), rv = /* @__PURE__ */ Or(Ll, 5, 0), sv = /* @__PURE__ */ Or(Ll, 5, 1), Sh = function(n) {
  for (var t = n[0], e = 1; e < n.length; ++e)
    n[e] > t && (t = n[e]);
  return t;
}, ur = function(n, t, e) {
  var i = t / 8 | 0;
  return (n[i] | n[i + 1] << 8) >> (t & 7) & e;
}, kh = function(n, t) {
  var e = t / 8 | 0;
  return (n[e] | n[e + 1] << 8 | n[e + 2] << 16) >> (t & 7);
}, Sd = function(n) {
  return (n + 7) / 8 | 0;
}, S1 = function(n, t, e) {
  return (e == null || e > n.length) && (e = n.length), new li(n.subarray(t, e));
}, ov = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], hr = function(n, t, e) {
  var i = new Error(t || ov[n]);
  if (i.code = n, Error.captureStackTrace && Error.captureStackTrace(i, hr), !e)
    throw i;
  return i;
}, av = function(n, t, e, i) {
  var r = n.length, s = 0;
  if (!r || t.f && !t.l)
    return e || new li(0);
  var o = !e, a = o || t.i != 2, l = t.i;
  o && (e = new li(r * 3));
  var h = function(Dt) {
    var Yt = e.length;
    if (Dt > Yt) {
      var Xt = new li(Math.max(Yt * 2, Dt));
      Xt.set(e), e = Xt;
    }
  }, u = t.f || 0, d = t.p || 0, p = t.b || 0, f = t.l, g = t.d, y = t.m, _ = t.n, b = r * 8;
  do {
    if (!f) {
      u = ur(n, d, 1);
      var v = ur(n, d + 1, 3);
      if (d += 3, v)
        if (v == 1)
          f = iv, g = sv, y = 9, _ = 5;
        else if (v == 2) {
          var R = ur(n, d, 31) + 257, C = ur(n, d + 10, 15) + 4, E = R + ur(n, d + 5, 31) + 1;
          d += 14;
          for (var M = new li(E), q = new li(19), N = 0; N < C; ++N)
            q[lf[N]] = ur(n, d + N * 3, 7);
          d += C * 3;
          for (var S = Sh(q), T = (1 << S) - 1, x = Or(q, S, 1), N = 0; N < E; ) {
            var X = x[ur(n, d, T)];
            d += X & 15;
            var A = X >> 4;
            if (A < 16)
              M[N++] = A;
            else {
              var V = 0, D = 0;
              for (A == 16 ? (D = 3 + ur(n, d, 3), d += 2, V = M[N - 1]) : A == 17 ? (D = 3 + ur(n, d, 7), d += 3) : A == 18 && (D = 11 + ur(n, d, 127), d += 7); D--; )
                M[N++] = V;
            }
          }
          var tt = M.subarray(0, R), H = M.subarray(R);
          y = Sh(tt), _ = Sh(H), f = Or(tt, y, 1), g = Or(H, _, 1);
        } else
          hr(1);
      else {
        var A = Sd(d) + 4, L = n[A - 4] | n[A - 3] << 8, O = A + L;
        if (O > r) {
          l && hr(0);
          break;
        }
        a && h(p + L), e.set(n.subarray(A, O), p), t.b = p += L, t.p = d = O * 8, t.f = u;
        continue;
      }
      if (d > b) {
        l && hr(0);
        break;
      }
    }
    a && h(p + 131072);
    for (var ct = (1 << y) - 1, it = (1 << _) - 1, P = d; ; P = d) {
      var V = f[kh(n, d) & ct], z = V >> 4;
      if (d += V & 15, d > b) {
        l && hr(0);
        break;
      }
      if (V || hr(2), z < 256)
        e[p++] = z;
      else if (z == 256) {
        P = d, f = null;
        break;
      } else {
        var G = z - 254;
        if (z > 264) {
          var N = z - 257, Y = Rc[N];
          G = ur(n, d, (1 << Y) - 1) + x1[N], d += Y;
        }
        var ot = g[kh(n, d) & it], xt = ot >> 4;
        ot || hr(3), d += ot & 15;
        var H = ev[xt];
        if (xt > 3) {
          var Y = Dc[xt];
          H += kh(n, d) & (1 << Y) - 1, d += Y;
        }
        if (d > b) {
          l && hr(0);
          break;
        }
        a && h(p + 131072);
        var gt = p + G;
        if (p < H) {
          var wt = s - H, qt = Math.min(H, gt);
          for (wt + p < 0 && hr(3); p < qt; ++p)
            e[p] = i[wt + p];
        }
        for (; p < gt; ++p)
          e[p] = e[p - H];
      }
    }
    t.l = f, t.p = P, t.b = p, t.f = u, f && (u = 1, t.m = y, t.d = g, t.n = _);
  } while (!u);
  return p != e.length && o ? S1(e, 0, p) : e.subarray(0, p);
}, ts = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8;
}, cl = function(n, t, e) {
  e <<= t & 7;
  var i = t / 8 | 0;
  n[i] |= e, n[i + 1] |= e >> 8, n[i + 2] |= e >> 16;
}, Ah = function(n, t) {
  for (var e = [], i = 0; i < n.length; ++i)
    n[i] && e.push({ s: i, f: n[i] });
  var r = e.length, s = e.slice();
  if (!r)
    return { t: A1, l: 0 };
  if (r == 1) {
    var o = new li(e[0].s + 1);
    return o[e[0].s] = 1, { t: o, l: 1 };
  }
  e.sort(function(O, R) {
    return O.f - R.f;
  }), e.push({ s: -1, f: 25001 });
  var a = e[0], l = e[1], h = 0, u = 1, d = 2;
  for (e[0] = { s: -1, f: a.f + l.f, l: a, r: l }; u != r - 1; )
    a = e[e[h].f < e[d].f ? h++ : d++], l = e[h != u && e[h].f < e[d].f ? h++ : d++], e[u++] = { s: -1, f: a.f + l.f, l: a, r: l };
  for (var p = s[0].s, i = 1; i < r; ++i)
    s[i].s > p && (p = s[i].s);
  var f = new Ri(p + 1), g = hf(e[u - 1], f, 0);
  if (g > t) {
    var i = 0, y = 0, _ = g - t, b = 1 << _;
    for (s.sort(function(R, C) {
      return f[C.s] - f[R.s] || R.f - C.f;
    }); i < r; ++i) {
      var v = s[i].s;
      if (f[v] > t)
        y += b - (1 << g - f[v]), f[v] = t;
      else
        break;
    }
    for (y >>= _; y > 0; ) {
      var A = s[i].s;
      f[A] < t ? y -= 1 << t - f[A]++ - 1 : ++i;
    }
    for (; i >= 0 && y; --i) {
      var L = s[i].s;
      f[L] == t && (--f[L], ++y);
    }
    g = t;
  }
  return { t: new li(f), l: g };
}, hf = function(n, t, e) {
  return n.s == -1 ? Math.max(hf(n.l, t, e + 1), hf(n.r, t, e + 1)) : t[n.s] = e;
}, Hp = function(n) {
  for (var t = n.length; t && !n[--t]; )
    ;
  for (var e = new Ri(++t), i = 0, r = n[0], s = 1, o = function(l) {
    e[i++] = l;
  }, a = 1; a <= t; ++a)
    if (n[a] == r && a != t)
      ++s;
    else {
      if (!r && s > 2) {
        for (; s > 138; s -= 138)
          o(32754);
        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (o(r), --s; s > 6; s -= 6)
          o(8304);
        s > 2 && (o(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        o(r);
      s = 1, r = n[a];
    }
  return { c: e.subarray(0, i), n: t };
}, hl = function(n, t) {
  for (var e = 0, i = 0; i < t.length; ++i)
    e += n[i] * t[i];
  return e;
}, k1 = function(n, t, e) {
  var i = e.length, r = Sd(t + 2);
  n[r] = i & 255, n[r + 1] = i >> 8, n[r + 2] = n[r] ^ 255, n[r + 3] = n[r + 1] ^ 255;
  for (var s = 0; s < i; ++s)
    n[r + s + 4] = e[s];
  return (r + 4 + i) * 8;
}, Gp = function(n, t, e, i, r, s, o, a, l, h, u) {
  ts(t, u++, e), ++r[256];
  for (var d = Ah(r, 15), p = d.t, f = d.l, g = Ah(s, 15), y = g.t, _ = g.l, b = Hp(p), v = b.c, A = b.n, L = Hp(y), O = L.c, R = L.n, C = new Ri(19), E = 0; E < v.length; ++E)
    ++C[v[E] & 31];
  for (var E = 0; E < O.length; ++E)
    ++C[O[E] & 31];
  for (var M = Ah(C, 7), q = M.t, N = M.l, S = 19; S > 4 && !q[lf[S - 1]]; --S)
    ;
  var T = h + 5 << 3, x = hl(r, zs) + hl(s, Ll) + o, X = hl(r, p) + hl(s, y) + o + 14 + 3 * S + hl(C, q) + 2 * C[16] + 3 * C[17] + 7 * C[18];
  if (l >= 0 && T <= x && T <= X)
    return k1(t, u, n.subarray(l, l + h));
  var V, D, tt, H;
  if (ts(t, u, 1 + (X < x)), u += 2, X < x) {
    V = Or(p, f, 0), D = p, tt = Or(y, _, 0), H = y;
    var ct = Or(q, N, 0);
    ts(t, u, A - 257), ts(t, u + 5, R - 1), ts(t, u + 10, S - 4), u += 14;
    for (var E = 0; E < S; ++E)
      ts(t, u + 3 * E, q[lf[E]]);
    u += 3 * S;
    for (var it = [v, O], P = 0; P < 2; ++P)
      for (var z = it[P], E = 0; E < z.length; ++E) {
        var G = z[E] & 31;
        ts(t, u, ct[G]), u += q[G], G > 15 && (ts(t, u, z[E] >> 5 & 127), u += z[E] >> 12);
      }
  } else
    V = nv, D = zs, tt = rv, H = Ll;
  for (var E = 0; E < a; ++E) {
    var Y = i[E];
    if (Y > 255) {
      var G = Y >> 18 & 31;
      cl(t, u, V[G + 257]), u += D[G + 257], G > 7 && (ts(t, u, Y >> 23 & 31), u += Rc[G]);
      var ot = Y & 31;
      cl(t, u, tt[ot]), u += H[ot], ot > 3 && (cl(t, u, Y >> 5 & 8191), u += Dc[ot]);
    } else
      cl(t, u, V[Y]), u += D[Y];
  }
  return cl(t, u, V[256]), u + D[256];
}, lv = /* @__PURE__ */ new _d([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), A1 = /* @__PURE__ */ new li(0), uv = function(n, t, e, i, r, s) {
  var o = s.z || n.length, a = new li(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r), l = a.subarray(i, a.length - r), h = s.l, u = (s.r || 0) & 7;
  if (t) {
    u && (l[0] = s.r >> 3);
    for (var d = lv[t - 1], p = d >> 13, f = d & 8191, g = (1 << e) - 1, y = s.p || new Ri(32768), _ = s.h || new Ri(g + 1), b = Math.ceil(e / 3), v = 2 * b, A = function(F) {
      return (n[F] ^ n[F + 1] << b ^ n[F + 2] << v) & g;
    }, L = new _d(25e3), O = new Ri(288), R = new Ri(32), C = 0, E = 0, M = s.i || 0, q = 0, N = s.w || 0, S = 0; M + 2 < o; ++M) {
      var T = A(M), x = M & 32767, X = _[T];
      if (y[x] = X, _[T] = x, N <= M) {
        var V = o - M;
        if ((C > 7e3 || q > 24576) && (V > 423 || !h)) {
          u = Gp(n, l, 0, L, O, R, E, q, S, M - S, u), q = C = E = 0, S = M;
          for (var D = 0; D < 286; ++D)
            O[D] = 0;
          for (var D = 0; D < 30; ++D)
            R[D] = 0;
        }
        var tt = 2, H = 0, ct = f, it = x - X & 32767;
        if (V > 2 && T == A(M - it))
          for (var P = Math.min(p, V) - 1, z = Math.min(32767, M), G = Math.min(258, V); it <= z && --ct && x != X; ) {
            if (n[M + tt] == n[M + tt - it]) {
              for (var Y = 0; Y < G && n[M + Y] == n[M + Y - it]; ++Y)
                ;
              if (Y > tt) {
                if (tt = Y, H = it, Y > P)
                  break;
                for (var ot = Math.min(it, Y - 2), xt = 0, D = 0; D < ot; ++D) {
                  var gt = M - it + D & 32767, wt = y[gt], qt = gt - wt & 32767;
                  qt > xt && (xt = qt, X = gt);
                }
              }
            }
            x = X, X = y[x], it += x - X & 32767;
          }
        if (H) {
          L[q++] = 268435456 | uf[tt] << 18 | Wp[H];
          var Dt = uf[tt] & 31, Yt = Wp[H] & 31;
          E += Rc[Dt] + Dc[Yt], ++O[257 + Dt], ++R[Yt], N = M + tt, ++C;
        } else
          L[q++] = n[M], ++O[n[M]];
      }
    }
    for (M = Math.max(M, N); M < o; ++M)
      L[q++] = n[M], ++O[n[M]];
    u = Gp(n, l, h, L, O, R, E, q, S, M - S, u), h || (s.r = u & 7 | l[u / 8 | 0] << 3, u -= 7, s.h = _, s.p = y, s.i = M, s.w = N);
  } else {
    for (var M = s.w || 0; M < o + h; M += 65535) {
      var Xt = M + 65535;
      Xt >= o && (l[u / 8 | 0] = h, Xt = o), u = k1(l, u + 1, n.subarray(M, Xt));
    }
    s.i = o;
  }
  return S1(a, 0, i + Sd(u) + r);
}, N1 = function() {
  var n = 1, t = 0;
  return {
    p: function(e) {
      for (var i = n, r = t, s = e.length | 0, o = 0; o != s; ) {
        for (var a = Math.min(o + 2655, s); o < a; ++o)
          r += i += e[o];
        i = (i & 65535) + 15 * (i >> 16), r = (r & 65535) + 15 * (r >> 16);
      }
      n = i, t = r;
    },
    d: function() {
      return n %= 65521, t %= 65521, (n & 255) << 24 | (n & 65280) << 8 | (t & 255) << 8 | t >> 8;
    }
  };
}, cv = function(n, t, e, i, r) {
  if (!r && (r = { l: 1 }, t.dictionary)) {
    var s = t.dictionary.subarray(-32768), o = new li(s.length + n.length);
    o.set(s), o.set(n, s.length), n = o, r.w = s.length;
  }
  return uv(n, t.level == null ? 6 : t.level, t.mem == null ? r.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 20 : 12 + t.mem, e, i, r);
}, C1 = function(n, t, e) {
  for (; e; ++t)
    n[t] = e, e >>>= 8;
}, hv = function(n, t) {
  var e = t.level, i = e == 0 ? 0 : e < 6 ? 1 : e == 9 ? 3 : 2;
  if (n[0] = 120, n[1] = i << 6 | (t.dictionary && 32), n[1] |= 31 - (n[0] << 8 | n[1]) % 31, t.dictionary) {
    var r = N1();
    r.p(t.dictionary), C1(n, 2, r.d());
  }
}, fv = function(n, t) {
  return ((n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31) && hr(6, "invalid zlib data"), (n[1] >> 5 & 1) == +!t && hr(6, "invalid zlib data: " + (n[1] & 32 ? "need" : "unexpected") + " dictionary"), (n[1] >> 3 & 4) + 2;
};
function ff(n, t) {
  t || (t = {});
  var e = N1();
  e.p(n);
  var i = cv(n, t, t.dictionary ? 6 : 2, 4);
  return hv(i, t), C1(i, i.length - 4, e.d()), i;
}
function dv(n, t) {
  return av(n.subarray(fv(n, t), -4), { i: 2 }, t, t);
}
var pv = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), gv = 0;
try {
  pv.decode(A1, { stream: !0 }), gv = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Ae = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Nh() {
  Ae.console && typeof Ae.console.log == "function" && Ae.console.log.apply(Ae.console, arguments);
}
var an = { log: Nh, warn: function(n) {
  Ae.console && (typeof Ae.console.warn == "function" ? Ae.console.warn.apply(Ae.console, arguments) : Nh.call(null, arguments));
}, error: function(n) {
  Ae.console && (typeof Ae.console.error == "function" ? Ae.console.error.apply(Ae.console, arguments) : Nh(n));
} };
function Ch(n, t, e) {
  var i = new XMLHttpRequest();
  i.open("GET", n), i.responseType = "blob", i.onload = function() {
    oo(i.response, t, e);
  }, i.onerror = function() {
    an.error("could not download file");
  }, i.send();
}
function Vp(n) {
  var t = new XMLHttpRequest();
  t.open("HEAD", n, !1);
  try {
    t.send();
  } catch {
  }
  return t.status >= 200 && t.status <= 299;
}
function Cu(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var t = document.createEvent("MouseEvents");
    t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(t);
  }
}
var Sl, df, oo = Ae.saveAs || ((typeof window > "u" ? "undefined" : nn(window)) !== "object" || window !== Ae ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, t, e) {
  var i = Ae.URL || Ae.webkitURL, r = document.createElement("a");
  t = t || n.name || "download", r.download = t, r.rel = "noopener", typeof n == "string" ? (r.href = n, r.origin !== location.origin ? Vp(r.href) ? Ch(n, t, e) : Cu(r, r.target = "_blank") : Cu(r)) : (r.href = i.createObjectURL(n), setTimeout(function() {
    i.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Cu(r);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, t, e) {
  if (t = t || n.name || "download", typeof n == "string") if (Vp(n)) Ch(n, t, e);
  else {
    var i = document.createElement("a");
    i.href = n, i.target = "_blank", setTimeout(function() {
      Cu(i);
    });
  }
  else navigator.msSaveOrOpenBlob(function(r, s) {
    return s === void 0 ? s = { autoBom: !1 } : nn(s) !== "object" && (an.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(r.type) ? new Blob(["\uFEFF", r], { type: r.type }) : r;
  }(n, e), t);
} : function(n, t, e, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof n == "string") return Ch(n, t, e);
  var r = n.type === "application/octet-stream", s = /constructor/i.test(Ae.HTMLElement) || Ae.safari, o = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((o || r && s) && (typeof FileReader > "u" ? "undefined" : nn(FileReader)) === "object") {
    var a = new FileReader();
    a.onloadend = function() {
      var u = a.result;
      u = o ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = u : location = u, i = null;
    }, a.readAsDataURL(n);
  } else {
    var l = Ae.URL || Ae.webkitURL, h = l.createObjectURL(n);
    i ? i.location = h : location.href = h, i = null, setTimeout(function() {
      l.revokeObjectURL(h);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function P1(n) {
  var t;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var e = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(a) {
    return [parseInt(a[1]), parseInt(a[2]), parseInt(a[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(a) {
    return [parseInt(a[1], 16), parseInt(a[2], 16), parseInt(a[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(a) {
    return [parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16), parseInt(a[3] + a[3], 16)];
  } }], i = 0; i < e.length; i++) {
    var r = e[i].re, s = e[i].process, o = r.exec(n);
    o && (t = s(o), this.r = t[0], this.g = t[1], this.b = t[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var a = this.r.toString(16), l = this.g.toString(16), h = this.b.toString(16);
    return a.length == 1 && (a = "0" + a), l.length == 1 && (l = "0" + l), h.length == 1 && (h = "0" + h), "#" + a + l + h;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ph(n, t) {
  var e = n[0], i = n[1], r = n[2], s = n[3];
  e = ni(e, i, r, s, t[0], 7, -680876936), s = ni(s, e, i, r, t[1], 12, -389564586), r = ni(r, s, e, i, t[2], 17, 606105819), i = ni(i, r, s, e, t[3], 22, -1044525330), e = ni(e, i, r, s, t[4], 7, -176418897), s = ni(s, e, i, r, t[5], 12, 1200080426), r = ni(r, s, e, i, t[6], 17, -1473231341), i = ni(i, r, s, e, t[7], 22, -45705983), e = ni(e, i, r, s, t[8], 7, 1770035416), s = ni(s, e, i, r, t[9], 12, -1958414417), r = ni(r, s, e, i, t[10], 17, -42063), i = ni(i, r, s, e, t[11], 22, -1990404162), e = ni(e, i, r, s, t[12], 7, 1804603682), s = ni(s, e, i, r, t[13], 12, -40341101), r = ni(r, s, e, i, t[14], 17, -1502002290), e = ii(e, i = ni(i, r, s, e, t[15], 22, 1236535329), r, s, t[1], 5, -165796510), s = ii(s, e, i, r, t[6], 9, -1069501632), r = ii(r, s, e, i, t[11], 14, 643717713), i = ii(i, r, s, e, t[0], 20, -373897302), e = ii(e, i, r, s, t[5], 5, -701558691), s = ii(s, e, i, r, t[10], 9, 38016083), r = ii(r, s, e, i, t[15], 14, -660478335), i = ii(i, r, s, e, t[4], 20, -405537848), e = ii(e, i, r, s, t[9], 5, 568446438), s = ii(s, e, i, r, t[14], 9, -1019803690), r = ii(r, s, e, i, t[3], 14, -187363961), i = ii(i, r, s, e, t[8], 20, 1163531501), e = ii(e, i, r, s, t[13], 5, -1444681467), s = ii(s, e, i, r, t[2], 9, -51403784), r = ii(r, s, e, i, t[7], 14, 1735328473), e = ri(e, i = ii(i, r, s, e, t[12], 20, -1926607734), r, s, t[5], 4, -378558), s = ri(s, e, i, r, t[8], 11, -2022574463), r = ri(r, s, e, i, t[11], 16, 1839030562), i = ri(i, r, s, e, t[14], 23, -35309556), e = ri(e, i, r, s, t[1], 4, -1530992060), s = ri(s, e, i, r, t[4], 11, 1272893353), r = ri(r, s, e, i, t[7], 16, -155497632), i = ri(i, r, s, e, t[10], 23, -1094730640), e = ri(e, i, r, s, t[13], 4, 681279174), s = ri(s, e, i, r, t[0], 11, -358537222), r = ri(r, s, e, i, t[3], 16, -722521979), i = ri(i, r, s, e, t[6], 23, 76029189), e = ri(e, i, r, s, t[9], 4, -640364487), s = ri(s, e, i, r, t[12], 11, -421815835), r = ri(r, s, e, i, t[15], 16, 530742520), e = si(e, i = ri(i, r, s, e, t[2], 23, -995338651), r, s, t[0], 6, -198630844), s = si(s, e, i, r, t[7], 10, 1126891415), r = si(r, s, e, i, t[14], 15, -1416354905), i = si(i, r, s, e, t[5], 21, -57434055), e = si(e, i, r, s, t[12], 6, 1700485571), s = si(s, e, i, r, t[3], 10, -1894986606), r = si(r, s, e, i, t[10], 15, -1051523), i = si(i, r, s, e, t[1], 21, -2054922799), e = si(e, i, r, s, t[8], 6, 1873313359), s = si(s, e, i, r, t[15], 10, -30611744), r = si(r, s, e, i, t[6], 15, -1560198380), i = si(i, r, s, e, t[13], 21, 1309151649), e = si(e, i, r, s, t[4], 6, -145523070), s = si(s, e, i, r, t[11], 10, -1120210379), r = si(r, s, e, i, t[2], 15, 718787259), i = si(i, r, s, e, t[9], 21, -343485551), n[0] = Fs(e, n[0]), n[1] = Fs(i, n[1]), n[2] = Fs(r, n[2]), n[3] = Fs(s, n[3]);
}
function Bc(n, t, e, i, r, s) {
  return t = Fs(Fs(t, n), Fs(i, s)), Fs(t << r | t >>> 32 - r, e);
}
function ni(n, t, e, i, r, s, o) {
  return Bc(t & e | ~t & i, n, t, r, s, o);
}
function ii(n, t, e, i, r, s, o) {
  return Bc(t & i | e & ~i, n, t, r, s, o);
}
function ri(n, t, e, i, r, s, o) {
  return Bc(t ^ e ^ i, n, t, r, s, o);
}
function si(n, t, e, i, r, s, o) {
  return Bc(e ^ (t | ~i), n, t, r, s, o);
}
function L1(n) {
  var t, e = n.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (t = 64; t <= n.length; t += 64) Ph(i, mv(n.substring(t - 64, t)));
  n = n.substring(t - 64);
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (t = 0; t < n.length; t++) r[t >> 2] |= n.charCodeAt(t) << (t % 4 << 3);
  if (r[t >> 2] |= 128 << (t % 4 << 3), t > 55) for (Ph(i, r), t = 0; t < 16; t++) r[t] = 0;
  return r[14] = 8 * e, Ph(i, r), i;
}
function mv(n) {
  var t, e = [];
  for (t = 0; t < 64; t += 4) e[t >> 2] = n.charCodeAt(t) + (n.charCodeAt(t + 1) << 8) + (n.charCodeAt(t + 2) << 16) + (n.charCodeAt(t + 3) << 24);
  return e;
}
Sl = Ae.atob.bind(Ae), df = Ae.btoa.bind(Ae);
var Yp = "0123456789abcdef".split("");
function yv(n) {
  for (var t = "", e = 0; e < 4; e++) t += Yp[n >> 8 * e + 4 & 15] + Yp[n >> 8 * e & 15];
  return t;
}
function bv(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function pf(n) {
  return L1(n).map(bv).join("");
}
var vv = function(n) {
  for (var t = 0; t < n.length; t++) n[t] = yv(n[t]);
  return n.join("");
}(L1("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Fs(n, t) {
  if (vv) {
    var e = (65535 & n) + (65535 & t);
    return (n >> 16) + (t >> 16) + (e >> 16) << 16 | 65535 & e;
  }
  return n + t & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function gf(n, t) {
  var e, i, r, s;
  if (n !== e) {
    for (var o = (r = n, s = 1 + (256 / n.length >> 0), new Array(s + 1).join(r)), a = [], l = 0; l < 256; l++) a[l] = l;
    var h = 0;
    for (l = 0; l < 256; l++) {
      var u = a[l];
      h = (h + u + o.charCodeAt(l)) % 256, a[l] = a[h], a[h] = u;
    }
    e = n, i = a;
  } else a = i;
  var d = t.length, p = 0, f = 0, g = "";
  for (l = 0; l < d; l++) f = (f + (u = a[p = (p + 1) % 256])) % 256, a[p] = a[f], a[f] = u, o = a[(a[p] + a[f]) % 256], g += String.fromCharCode(t.charCodeAt(l) ^ o);
  return g;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Kp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function da(n, t, e, i) {
  this.v = 1, this.r = 2;
  var r = 192;
  n.forEach(function(a) {
    if (Kp.perm !== void 0) throw new Error("Invalid permission: " + a);
    r += Kp[a];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var s = (t + this.padding).substr(0, 32), o = (e + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, o), this.P = -(1 + (255 ^ r)), this.encryptionKey = pf(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = gf(this.encryptionKey, this.padding);
}
function pa(n) {
  if (/[^\u0000-\u00ff]/.test(n)) throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var t = "", e = n.length, i = 0; i < e; i++) {
    var r = n.charCodeAt(i);
    r < 33 || r === 35 || r === 37 || r === 40 || r === 41 || r === 47 || r === 60 || r === 62 || r === 91 || r === 93 || r === 123 || r === 125 || r > 126 ? t += "#" + ("0" + r.toString(16)).slice(-2) : t += n[i];
  }
  return t;
}
function Xp(n) {
  if (nn(n) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var t = {};
  this.subscribe = function(e, i, r) {
    if (r = r || !1, typeof e != "string" || typeof i != "function" || typeof r != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    t.hasOwnProperty(e) || (t[e] = {});
    var s = Math.random().toString(35);
    return t[e][s] = [i, !!r], s;
  }, this.unsubscribe = function(e) {
    for (var i in t) if (t[i][e]) return delete t[i][e], Object.keys(t[i]).length === 0 && delete t[i], !0;
    return !1;
  }, this.publish = function(e) {
    if (t.hasOwnProperty(e)) {
      var i = Array.prototype.slice.call(arguments, 1), r = [];
      for (var s in t[e]) {
        var o = t[e][s];
        try {
          o[0].apply(n, i);
        } catch (a) {
          Ae.console && an.error("jsPDF PubSub Error", a.message, a);
        }
        o[1] && r.push(s);
      }
      r.length && r.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return t;
  };
}
function Il(n) {
  if (!(this instanceof Il)) return new Il(n);
  var t = "opacity,stroke-opacity".split(",");
  for (var e in n) n.hasOwnProperty(e) && t.indexOf(e) >= 0 && (this[e] = n[e]);
  this.id = "", this.objectNumber = -1;
}
function I1(n, t) {
  this.gState = n, this.matrix = t, this.id = "", this.objectNumber = -1;
}
function Os(n, t, e, i, r) {
  if (!(this instanceof Os)) return new Os(n, t, e, i, r);
  this.type = n === "axial" ? 2 : 3, this.coords = t, this.colors = e, I1.call(this, i, r);
}
function ho(n, t, e, i, r) {
  if (!(this instanceof ho)) return new ho(n, t, e, i, r);
  this.boundingBox = n, this.xStep = t, this.yStep = e, this.stream = "", this.cloneIndex = 0, I1.call(this, i, r);
}
function Se(n) {
  var t, e = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], r = arguments[2], s = arguments[3], o = [], a = 1, l = 16, h = "S", u = null;
  nn(n = n || {}) === "object" && (e = n.orientation, i = n.unit || i, r = n.format || r, s = n.compress || n.compressPdf || s, (u = n.encryption || null) !== null && (u.userPassword = u.userPassword || "", u.ownerPassword = u.ownerPassword || "", u.userPermissions = u.userPermissions || []), a = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (t = n.precision), n.floatPrecision !== void 0 && (l = n.floatPrecision), h = n.defaultPathOperation || "S"), o = n.filters || (s === !0 ? ["FlateEncode"] : o), i = i || "mm", e = ("" + (e || "P")).toLowerCase();
  var d = n.putOnlyUsedFonts || !1, p = {}, f = { internal: {}, __private__: {} };
  f.__private__.PubSub = Xp;
  var g = "1.3", y = f.__private__.getPdfVersion = function() {
    return g;
  };
  f.__private__.setPdfVersion = function(w) {
    g = w;
  };
  var _ = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  f.__private__.getPageFormats = function() {
    return _;
  };
  var b = f.__private__.getPageFormat = function(w) {
    return _[w];
  };
  r = r || "a4";
  var v = { COMPAT: "compat", ADVANCED: "advanced" }, A = v.COMPAT;
  function L() {
    this.saveGraphicsState(), $(new ve(Jt, 0, 0, -Jt, 0, ms() * Jt).toString() + " cm"), this.setFontSize(this.getFontSize() / Jt), h = "n", A = v.ADVANCED;
  }
  function O() {
    this.restoreGraphicsState(), h = "S", A = v.COMPAT;
  }
  var R = f.__private__.combineFontStyleAndFontWeight = function(w, j) {
    if (w == "bold" && j == "normal" || w == "bold" && j == 400 || w == "normal" && j == "italic" || w == "bold" && j == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return j && (w = j == 400 || j === "normal" ? w === "italic" ? "italic" : "normal" : j != 700 && j !== "bold" || w !== "normal" ? (j == 700 ? "bold" : j) + "" + w : "bold"), w;
  };
  f.advancedAPI = function(w) {
    var j = A === v.COMPAT;
    return j && L.call(this), typeof w != "function" || (w(this), j && O.call(this)), this;
  }, f.compatAPI = function(w) {
    var j = A === v.ADVANCED;
    return j && O.call(this), typeof w != "function" || (w(this), j && L.call(this)), this;
  }, f.isAdvancedAPI = function() {
    return A === v.ADVANCED;
  };
  var C, E = function(w) {
    if (A !== v.ADVANCED) throw new Error(w + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, M = f.roundToPrecision = f.__private__.roundToPrecision = function(w, j) {
    var ut = t || j;
    if (isNaN(w) || isNaN(ut)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return w.toFixed(ut).replace(/0+$/, "");
  };
  C = f.hpf = f.__private__.hpf = typeof l == "number" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, l);
  } : l === "smart" ? function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, w > -1 && w < 1 ? 16 : 5);
  } : function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return M(w, 16);
  };
  var q = f.f2 = f.__private__.f2 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f2");
    return M(w, 2);
  }, N = f.__private__.f3 = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.f3");
    return M(w, 3);
  }, S = f.scale = f.__private__.scale = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.scale");
    return A === v.COMPAT ? w * Jt : A === v.ADVANCED ? w : void 0;
  }, T = function(w) {
    return A === v.COMPAT ? ms() - w : A === v.ADVANCED ? w : void 0;
  }, x = function(w) {
    return S(T(w));
  };
  f.__private__.setPrecision = f.setPrecision = function(w) {
    typeof parseInt(w, 10) == "number" && (t = parseInt(w, 10));
  };
  var X, V = "00000000000000000000000000000000", D = f.__private__.getFileId = function() {
    return V;
  }, tt = f.__private__.setFileId = function(w) {
    return V = w !== void 0 && /^[a-fA-F0-9]{32}$/.test(w) ? w.toUpperCase() : V.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), u !== null && (Be = new da(u.userPermissions, u.userPassword, u.ownerPassword, V)), V;
  };
  f.setFileId = function(w) {
    return tt(w), this;
  }, f.getFileId = function() {
    return D();
  };
  var H = f.__private__.convertDateToPDFDate = function(w) {
    var j = w.getTimezoneOffset(), ut = j < 0 ? "+" : "-", pt = Math.floor(Math.abs(j / 60)), Ct = Math.abs(j % 60), Rt = [ut, G(pt), "'", G(Ct), "'"].join("");
    return ["D:", w.getFullYear(), G(w.getMonth() + 1), G(w.getDate()), G(w.getHours()), G(w.getMinutes()), G(w.getSeconds()), Rt].join("");
  }, ct = f.__private__.convertPDFDateToDate = function(w) {
    var j = parseInt(w.substr(2, 4), 10), ut = parseInt(w.substr(6, 2), 10) - 1, pt = parseInt(w.substr(8, 2), 10), Ct = parseInt(w.substr(10, 2), 10), Rt = parseInt(w.substr(12, 2), 10), Vt = parseInt(w.substr(14, 2), 10);
    return new Date(j, ut, pt, Ct, Rt, Vt, 0);
  }, it = f.__private__.setCreationDate = function(w) {
    var j;
    if (w === void 0 && (w = /* @__PURE__ */ new Date()), w instanceof Date) j = H(w);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(w)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      j = w;
    }
    return X = j;
  }, P = f.__private__.getCreationDate = function(w) {
    var j = X;
    return w === "jsDate" && (j = ct(X)), j;
  };
  f.setCreationDate = function(w) {
    return it(w), this;
  }, f.getCreationDate = function(w) {
    return P(w);
  };
  var z, G = f.__private__.padd2 = function(w) {
    return ("0" + parseInt(w)).slice(-2);
  }, Y = f.__private__.padd2Hex = function(w) {
    return ("00" + (w = w.toString())).substr(w.length);
  }, ot = 0, xt = [], gt = [], wt = 0, qt = [], Dt = [], Yt = !1, Xt = gt, F = function() {
    ot = 0, wt = 0, gt = [], xt = [], qt = [], ir = bn(), gi = bn();
  };
  f.__private__.setCustomOutputDestination = function(w) {
    Yt = !0, Xt = w;
  };
  var ht = function(w) {
    Yt || (Xt = w);
  };
  f.__private__.resetCustomOutputDestination = function() {
    Yt = !1, Xt = gt;
  };
  var $ = f.__private__.out = function(w) {
    return w = w.toString(), wt += w.length + 1, Xt.push(w), Xt;
  }, nt = f.__private__.write = function(w) {
    return $(arguments.length === 1 ? w.toString() : Array.prototype.join.call(arguments, " "));
  }, J = f.__private__.getArrayBuffer = function(w) {
    for (var j = w.length, ut = new ArrayBuffer(j), pt = new Uint8Array(ut); j--; ) pt[j] = w.charCodeAt(j);
    return ut;
  }, st = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  f.__private__.getStandardFonts = function() {
    return st;
  };
  var vt = n.fontSize || 16;
  f.__private__.setFontSize = f.setFontSize = function(w) {
    return vt = A === v.ADVANCED ? w / Jt : w, this;
  };
  var St, ft = f.__private__.getFontSize = f.getFontSize = function() {
    return A === v.COMPAT ? vt : vt * Jt;
  }, Et = n.R2L || !1;
  f.__private__.setR2L = f.setR2L = function(w) {
    return Et = w, this;
  }, f.__private__.getR2L = f.getR2L = function() {
    return Et;
  };
  var zt, Tt = f.__private__.setZoomMode = function(w) {
    var j = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(w)) St = w;
    else if (isNaN(w)) {
      if (j.indexOf(w) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + w + '" is not recognized.');
      St = w;
    } else St = parseInt(w, 10);
  };
  f.__private__.getZoomMode = function() {
    return St;
  };
  var $t, ee = f.__private__.setPageMode = function(w) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(w) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + w + '" is not recognized.');
    zt = w;
  };
  f.__private__.getPageMode = function() {
    return zt;
  };
  var oe = f.__private__.setLayoutMode = function(w) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(w) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + w + '" is not recognized.');
    $t = w;
  };
  f.__private__.getLayoutMode = function() {
    return $t;
  }, f.__private__.setDisplayMode = f.setDisplayMode = function(w, j, ut) {
    return Tt(w), oe(j), ee(ut), this;
  };
  var ae = { title: "", subject: "", author: "", keywords: "", creator: "" };
  f.__private__.getDocumentProperty = function(w) {
    if (Object.keys(ae).indexOf(w) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ae[w];
  }, f.__private__.getDocumentProperties = function() {
    return ae;
  }, f.__private__.setDocumentProperties = f.setProperties = f.setDocumentProperties = function(w) {
    for (var j in ae) ae.hasOwnProperty(j) && w[j] && (ae[j] = w[j]);
    return this;
  }, f.__private__.setDocumentProperty = function(w, j) {
    if (Object.keys(ae).indexOf(w) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ae[w] = j;
  };
  var we, Jt, Nt, Ot, re, Zt = {}, fe = {}, ie = [], de = {}, We = {}, Te = {}, _n = {}, Fn = null, Qe = 0, Ne = [], qe = new Xp(f), nr = n.hotfixes || [], Ln = {}, Di = {}, jn = [], ve = function w(j, ut, pt, Ct, Rt, Vt) {
    if (!(this instanceof w)) return new w(j, ut, pt, Ct, Rt, Vt);
    isNaN(j) && (j = 1), isNaN(ut) && (ut = 0), isNaN(pt) && (pt = 0), isNaN(Ct) && (Ct = 1), isNaN(Rt) && (Rt = 0), isNaN(Vt) && (Vt = 0), this._matrix = [j, ut, pt, Ct, Rt, Vt];
  };
  Object.defineProperty(ve.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(ve.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(ve.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(ve.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(ve.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(ve.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(ve.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(w) {
    this._matrix[0] = w;
  } }), Object.defineProperty(ve.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(w) {
    this._matrix[1] = w;
  } }), Object.defineProperty(ve.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(w) {
    this._matrix[2] = w;
  } }), Object.defineProperty(ve.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(w) {
    this._matrix[3] = w;
  } }), Object.defineProperty(ve.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(w) {
    this._matrix[4] = w;
  } }), Object.defineProperty(ve.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(w) {
    this._matrix[5] = w;
  } }), Object.defineProperty(ve.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(ve.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(ve.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(ve.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), ve.prototype.join = function(w) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(C).join(w);
  }, ve.prototype.multiply = function(w) {
    var j = w.sx * this.sx + w.shy * this.shx, ut = w.sx * this.shy + w.shy * this.sy, pt = w.shx * this.sx + w.sy * this.shx, Ct = w.shx * this.shy + w.sy * this.sy, Rt = w.tx * this.sx + w.ty * this.shx + this.tx, Vt = w.tx * this.shy + w.ty * this.sy + this.ty;
    return new ve(j, ut, pt, Ct, Rt, Vt);
  }, ve.prototype.decompose = function() {
    var w = this.sx, j = this.shy, ut = this.shx, pt = this.sy, Ct = this.tx, Rt = this.ty, Vt = Math.sqrt(w * w + j * j), ue = (w /= Vt) * ut + (j /= Vt) * pt;
    ut -= w * ue, pt -= j * ue;
    var be = Math.sqrt(ut * ut + pt * pt);
    return ue /= be, w * (pt /= be) < j * (ut /= be) && (w = -w, j = -j, ue = -ue, Vt = -Vt), { scale: new ve(Vt, 0, 0, be, 0, 0), translate: new ve(1, 0, 0, 1, Ct, Rt), rotate: new ve(w, j, -j, w, 0, 0), skew: new ve(1, 0, ue, 1, 0, 0) };
  }, ve.prototype.toString = function(w) {
    return this.join(" ");
  }, ve.prototype.inversed = function() {
    var w = this.sx, j = this.shy, ut = this.shx, pt = this.sy, Ct = this.tx, Rt = this.ty, Vt = 1 / (w * pt - j * ut), ue = pt * Vt, be = -j * Vt, Ee = -ut * Vt, Pe = w * Vt;
    return new ve(ue, be, Ee, Pe, -ue * Ct - Ee * Rt, -be * Ct - Pe * Rt);
  }, ve.prototype.applyToPoint = function(w) {
    var j = w.x * this.sx + w.y * this.shx + this.tx, ut = w.x * this.shy + w.y * this.sy + this.ty;
    return new zo(j, ut);
  }, ve.prototype.applyToRectangle = function(w) {
    var j = this.applyToPoint(w), ut = this.applyToPoint(new zo(w.x + w.w, w.y + w.h));
    return new za(j.x, j.y, ut.x - j.x, ut.y - j.y);
  }, ve.prototype.clone = function() {
    var w = this.sx, j = this.shy, ut = this.shx, pt = this.sy, Ct = this.tx, Rt = this.ty;
    return new ve(w, j, ut, pt, Ct, Rt);
  }, f.Matrix = ve;
  var ki = f.matrixMult = function(w, j) {
    return j.multiply(w);
  }, Bi = new ve(1, 0, 0, 1, 0, 0);
  f.unitMatrix = f.identityMatrix = Bi;
  var ti = function(w, j) {
    if (!We[w]) {
      var ut = (j instanceof Os ? "Sh" : "P") + (Object.keys(de).length + 1).toString(10);
      j.id = ut, We[w] = ut, de[ut] = j, qe.publish("addPattern", j);
    }
  };
  f.ShadingPattern = Os, f.TilingPattern = ho, f.addShadingPattern = function(w, j) {
    return E("addShadingPattern()"), ti(w, j), this;
  }, f.beginTilingPattern = function(w) {
    E("beginTilingPattern()"), Xl(w.boundingBox[0], w.boundingBox[1], w.boundingBox[2] - w.boundingBox[0], w.boundingBox[3] - w.boundingBox[1], w.matrix);
  }, f.endTilingPattern = function(w, j) {
    E("endTilingPattern()"), j.stream = Dt[z].join(`
`), ti(w, j), qe.publish("endTilingPattern", j), jn.pop().restore();
  };
  var yn = f.__private__.newObject = function() {
    var w = bn();
    return ui(w, !0), w;
  }, bn = f.__private__.newObjectDeferred = function() {
    return ot++, xt[ot] = function() {
      return wt;
    }, ot;
  }, ui = function(w, j) {
    return j = typeof j == "boolean" && j, xt[w] = wt, j && $(w + " 0 obj"), w;
  }, os = f.__private__.newAdditionalObject = function() {
    var w = { objId: bn(), content: "" };
    return qt.push(w), w;
  }, ir = bn(), gi = bn(), Ai = f.__private__.decodeColorString = function(w) {
    var j = w.split(" ");
    if (j.length !== 2 || j[1] !== "g" && j[1] !== "G")
      j.length === 5 && (j[4] === "k" || j[4] === "K") && (j = [(1 - j[0]) * (1 - j[3]), (1 - j[1]) * (1 - j[3]), (1 - j[2]) * (1 - j[3]), "r"]);
    else {
      var ut = parseFloat(j[0]);
      j = [ut, ut, ut, "r"];
    }
    for (var pt = "#", Ct = 0; Ct < 3; Ct++) pt += ("0" + Math.floor(255 * parseFloat(j[Ct])).toString(16)).slice(-2);
    return pt;
  }, Ni = f.__private__.encodeColorString = function(w) {
    var j;
    typeof w == "string" && (w = { ch1: w });
    var ut = w.ch1, pt = w.ch2, Ct = w.ch3, Rt = w.ch4, Vt = w.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ut == "string" && ut.charAt(0) !== "#") {
      var ue = new P1(ut);
      if (ue.ok) ut = ue.toHex();
      else if (!/^\d*\.?\d*$/.test(ut)) throw new Error('Invalid color "' + ut + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof ut == "string" && /^#[0-9A-Fa-f]{3}$/.test(ut) && (ut = "#" + ut[1] + ut[1] + ut[2] + ut[2] + ut[3] + ut[3]), typeof ut == "string" && /^#[0-9A-Fa-f]{6}$/.test(ut)) {
      var be = parseInt(ut.substr(1), 16);
      ut = be >> 16 & 255, pt = be >> 8 & 255, Ct = 255 & be;
    }
    if (pt === void 0 || Rt === void 0 && ut === pt && pt === Ct) if (typeof ut == "string") j = ut + " " + Vt[0];
    else switch (w.precision) {
      case 2:
        j = q(ut / 255) + " " + Vt[0];
        break;
      case 3:
      default:
        j = N(ut / 255) + " " + Vt[0];
    }
    else if (Rt === void 0 || nn(Rt) === "object") {
      if (Rt && !isNaN(Rt.a) && Rt.a === 0) return j = ["1.", "1.", "1.", Vt[1]].join(" ");
      if (typeof ut == "string") j = [ut, pt, Ct, Vt[1]].join(" ");
      else switch (w.precision) {
        case 2:
          j = [q(ut / 255), q(pt / 255), q(Ct / 255), Vt[1]].join(" ");
          break;
        default:
        case 3:
          j = [N(ut / 255), N(pt / 255), N(Ct / 255), Vt[1]].join(" ");
      }
    } else if (typeof ut == "string") j = [ut, pt, Ct, Rt, Vt[2]].join(" ");
    else switch (w.precision) {
      case 2:
        j = [q(ut), q(pt), q(Ct), q(Rt), Vt[2]].join(" ");
        break;
      case 3:
      default:
        j = [N(ut), N(pt), N(Ct), N(Rt), Vt[2]].join(" ");
    }
    return j;
  }, ji = f.__private__.getFilters = function() {
    return o;
  }, Ci = f.__private__.putStream = function(w) {
    var j = (w = w || {}).data || "", ut = w.filters || ji(), pt = w.alreadyAppliedFilters || [], Ct = w.addLength1 || !1, Rt = j.length, Vt = w.objectId, ue = function(ei) {
      return ei;
    };
    if (u !== null && Vt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    u !== null && (ue = Be.encryptor(Vt, 0));
    var be = {};
    ut === !0 && (ut = ["FlateEncode"]);
    var Ee = w.additionalKeyValues || [], Pe = (be = Se.API.processDataByFilters !== void 0 ? Se.API.processDataByFilters(j, ut) : { data: j, reverseChain: [] }).reverseChain + (Array.isArray(pt) ? pt.join(" ") : pt.toString());
    if (be.data.length !== 0 && (Ee.push({ key: "Length", value: be.data.length }), Ct === !0 && Ee.push({ key: "Length1", value: Rt })), Pe.length != 0) if (Pe.split("/").length - 1 == 1) Ee.push({ key: "Filter", value: Pe });
    else {
      Ee.push({ key: "Filter", value: "[" + Pe + "]" });
      for (var Ue = 0; Ue < Ee.length; Ue += 1) if (Ee[Ue].key === "DecodeParms") {
        for (var gn = [], vn = 0; vn < be.reverseChain.split("/").length - 1; vn += 1) gn.push("null");
        gn.push(Ee[Ue].value), Ee[Ue].value = "[" + gn.join(" ") + "]";
      }
    }
    $("<<");
    for (var In = 0; In < Ee.length; In++) $("/" + Ee[In].key + " " + Ee[In].value);
    $(">>"), be.data.length !== 0 && ($("stream"), $(ue(be.data)), $("endstream"));
  }, qi = f.__private__.putPage = function(w) {
    var j = w.number, ut = w.data, pt = w.objId, Ct = w.contentsObjId;
    ui(pt, !0), $("<</Type /Page"), $("/Parent " + w.rootDictionaryObjId + " 0 R"), $("/Resources " + w.resourceDictionaryObjId + " 0 R"), $("/MediaBox [" + parseFloat(C(w.mediaBox.bottomLeftX)) + " " + parseFloat(C(w.mediaBox.bottomLeftY)) + " " + C(w.mediaBox.topRightX) + " " + C(w.mediaBox.topRightY) + "]"), w.cropBox !== null && $("/CropBox [" + C(w.cropBox.bottomLeftX) + " " + C(w.cropBox.bottomLeftY) + " " + C(w.cropBox.topRightX) + " " + C(w.cropBox.topRightY) + "]"), w.bleedBox !== null && $("/BleedBox [" + C(w.bleedBox.bottomLeftX) + " " + C(w.bleedBox.bottomLeftY) + " " + C(w.bleedBox.topRightX) + " " + C(w.bleedBox.topRightY) + "]"), w.trimBox !== null && $("/TrimBox [" + C(w.trimBox.bottomLeftX) + " " + C(w.trimBox.bottomLeftY) + " " + C(w.trimBox.topRightX) + " " + C(w.trimBox.topRightY) + "]"), w.artBox !== null && $("/ArtBox [" + C(w.artBox.bottomLeftX) + " " + C(w.artBox.bottomLeftY) + " " + C(w.artBox.topRightX) + " " + C(w.artBox.topRightY) + "]"), typeof w.userUnit == "number" && w.userUnit !== 1 && $("/UserUnit " + w.userUnit), qe.publish("putPage", { objId: pt, pageContext: Ne[j], pageNumber: j, page: ut }), $("/Contents " + Ct + " 0 R"), $(">>"), $("endobj");
    var Rt = ut.join(`
`);
    return A === v.ADVANCED && (Rt += `
Q`), ui(Ct, !0), Ci({ data: Rt, filters: ji(), objectId: Ct }), $("endobj"), pt;
  }, xr = f.__private__.putPages = function() {
    var w, j, ut = [];
    for (w = 1; w <= Qe; w++) Ne[w].objId = bn(), Ne[w].contentsObjId = bn();
    for (w = 1; w <= Qe; w++) ut.push(qi({ number: w, data: Dt[w], objId: Ne[w].objId, contentsObjId: Ne[w].contentsObjId, mediaBox: Ne[w].mediaBox, cropBox: Ne[w].cropBox, bleedBox: Ne[w].bleedBox, trimBox: Ne[w].trimBox, artBox: Ne[w].artBox, userUnit: Ne[w].userUnit, rootDictionaryObjId: ir, resourceDictionaryObjId: gi }));
    ui(ir, !0), $("<</Type /Pages");
    var pt = "/Kids [";
    for (j = 0; j < Qe; j++) pt += ut[j] + " 0 R ";
    $(pt + "]"), $("/Count " + Qe), $(">>"), $("endobj"), qe.publish("postPutPages");
  }, Br = function(w) {
    qe.publish("putFont", { font: w, out: $, newObject: yn, putStream: Ci }), w.isAlreadyPutted !== !0 && (w.objectNumber = yn(), $("<<"), $("/Type /Font"), $("/BaseFont /" + pa(w.postScriptName)), $("/Subtype /Type1"), typeof w.encoding == "string" && $("/Encoding /" + w.encoding), $("/FirstChar 32"), $("/LastChar 255"), $(">>"), $("endobj"));
  }, rr = function() {
    for (var w in Zt) Zt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && Br(Zt[w]);
  }, jr = function(w) {
    w.objectNumber = yn();
    var j = [];
    j.push({ key: "Type", value: "/XObject" }), j.push({ key: "Subtype", value: "/Form" }), j.push({ key: "BBox", value: "[" + [C(w.x), C(w.y), C(w.x + w.width), C(w.y + w.height)].join(" ") + "]" }), j.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" });
    var ut = w.pages[1].join(`
`);
    Ci({ data: ut, additionalKeyValues: j, objectId: w.objectNumber }), $("endobj");
  }, qr = function() {
    for (var w in Ln) Ln.hasOwnProperty(w) && jr(Ln[w]);
  }, zr = function(w, j) {
    var ut, pt = [], Ct = 1 / (j - 1);
    for (ut = 0; ut < 1; ut += Ct) pt.push(ut);
    if (pt.push(1), w[0].offset != 0) {
      var Rt = { offset: 0, color: w[0].color };
      w.unshift(Rt);
    }
    if (w[w.length - 1].offset != 1) {
      var Vt = { offset: 1, color: w[w.length - 1].color };
      w.push(Vt);
    }
    for (var ue = "", be = 0, Ee = 0; Ee < pt.length; Ee++) {
      for (ut = pt[Ee]; ut > w[be + 1].offset; ) be++;
      var Pe = w[be].offset, Ue = (ut - Pe) / (w[be + 1].offset - Pe), gn = w[be].color, vn = w[be + 1].color;
      ue += Y(Math.round((1 - Ue) * gn[0] + Ue * vn[0]).toString(16)) + Y(Math.round((1 - Ue) * gn[1] + Ue * vn[1]).toString(16)) + Y(Math.round((1 - Ue) * gn[2] + Ue * vn[2]).toString(16));
    }
    return ue.trim();
  }, as = function(w, j) {
    j || (j = 21);
    var ut = yn(), pt = zr(w.colors, j), Ct = [];
    Ct.push({ key: "FunctionType", value: "0" }), Ct.push({ key: "Domain", value: "[0.0 1.0]" }), Ct.push({ key: "Size", value: "[" + j + "]" }), Ct.push({ key: "BitsPerSample", value: "8" }), Ct.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ct.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ci({ data: pt, additionalKeyValues: Ct, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: ut }), $("endobj"), w.objectNumber = yn(), $("<< /ShadingType " + w.type), $("/ColorSpace /DeviceRGB");
    var Rt = "/Coords [" + C(parseFloat(w.coords[0])) + " " + C(parseFloat(w.coords[1])) + " ";
    w.type === 2 ? Rt += C(parseFloat(w.coords[2])) + " " + C(parseFloat(w.coords[3])) : Rt += C(parseFloat(w.coords[2])) + " " + C(parseFloat(w.coords[3])) + " " + C(parseFloat(w.coords[4])) + " " + C(parseFloat(w.coords[5])), $(Rt += "]"), w.matrix && $("/Matrix [" + w.matrix.toString() + "]"), $("/Function " + ut + " 0 R"), $("/Extend [true true]"), $(">>"), $("endobj");
  }, Eo = function(w, j) {
    var ut = bn(), pt = yn();
    j.push({ resourcesOid: ut, objectOid: pt }), w.objectNumber = pt;
    var Ct = [];
    Ct.push({ key: "Type", value: "/Pattern" }), Ct.push({ key: "PatternType", value: "1" }), Ct.push({ key: "PaintType", value: "1" }), Ct.push({ key: "TilingType", value: "1" }), Ct.push({ key: "BBox", value: "[" + w.boundingBox.map(C).join(" ") + "]" }), Ct.push({ key: "XStep", value: C(w.xStep) }), Ct.push({ key: "YStep", value: C(w.yStep) }), Ct.push({ key: "Resources", value: ut + " 0 R" }), w.matrix && Ct.push({ key: "Matrix", value: "[" + w.matrix.toString() + "]" }), Ci({ data: w.stream, additionalKeyValues: Ct, objectId: w.objectNumber }), $("endobj");
  }, ls = function(w) {
    var j;
    for (j in de) de.hasOwnProperty(j) && (de[j] instanceof Os ? as(de[j]) : de[j] instanceof ho && Eo(de[j], w));
  }, Oo = function(w) {
    for (var j in w.objectNumber = yn(), $("<<"), w) switch (j) {
      case "opacity":
        $("/ca " + q(w[j]));
        break;
      case "stroke-opacity":
        $("/CA " + q(w[j]));
    }
    $(">>"), $("endobj");
  }, us = function() {
    var w;
    for (w in Te) Te.hasOwnProperty(w) && Oo(Te[w]);
  }, Hs = function() {
    for (var w in $("/XObject <<"), Ln) Ln.hasOwnProperty(w) && Ln[w].objectNumber >= 0 && $("/" + w + " " + Ln[w].objectNumber + " 0 R");
    qe.publish("putXobjectDict"), $(">>");
  }, $r = function() {
    Be.oid = yn(), $("<<"), $("/Filter /Standard"), $("/V " + Be.v), $("/R " + Be.r), $("/U <" + Be.toHexString(Be.U) + ">"), $("/O <" + Be.toHexString(Be.O) + ">"), $("/P " + Be.P), $(">>"), $("endobj");
  }, To = function() {
    for (var w in $("/Font <<"), Zt) Zt.hasOwnProperty(w) && (d === !1 || d === !0 && p.hasOwnProperty(w)) && $("/" + w + " " + Zt[w].objectNumber + " 0 R");
    $(">>");
  }, Ea = function() {
    if (Object.keys(de).length > 0) {
      for (var w in $("/Shading <<"), de) de.hasOwnProperty(w) && de[w] instanceof Os && de[w].objectNumber >= 0 && $("/" + w + " " + de[w].objectNumber + " 0 R");
      qe.publish("putShadingPatternDict"), $(">>");
    }
  }, cs = function(w) {
    if (Object.keys(de).length > 0) {
      for (var j in $("/Pattern <<"), de) de.hasOwnProperty(j) && de[j] instanceof f.TilingPattern && de[j].objectNumber >= 0 && de[j].objectNumber < w && $("/" + j + " " + de[j].objectNumber + " 0 R");
      qe.publish("putTilingPatternDict"), $(">>");
    }
  }, Oa = function() {
    if (Object.keys(Te).length > 0) {
      var w;
      for (w in $("/ExtGState <<"), Te) Te.hasOwnProperty(w) && Te[w].objectNumber >= 0 && $("/" + w + " " + Te[w].objectNumber + " 0 R");
      qe.publish("putGStateDict"), $(">>");
    }
  }, pn = function(w) {
    ui(w.resourcesOid, !0), $("<<"), $("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), To(), Ea(), cs(w.objectOid), Oa(), Hs(), $(">>"), $("endobj");
  }, Fo = function() {
    var w = [];
    rr(), us(), qr(), ls(w), qe.publish("putResources"), w.forEach(pn), pn({ resourcesOid: gi, objectOid: Number.MAX_SAFE_INTEGER }), qe.publish("postPutResources");
  }, Gs = function() {
    qe.publish("putAdditionalObjects");
    for (var w = 0; w < qt.length; w++) {
      var j = qt[w];
      ui(j.objId, !0), $(j.content), $("endobj");
    }
    qe.publish("postPutAdditionalObjects");
  }, Mo = function(w) {
    fe[w.fontName] = fe[w.fontName] || {}, fe[w.fontName][w.fontStyle] = w.id;
  }, Vs = function(w, j, ut, pt, Ct) {
    var Rt = { id: "F" + (Object.keys(Zt).length + 1).toString(10), postScriptName: w, fontName: j, fontStyle: ut, encoding: pt, isStandardFont: Ct || !1, metadata: {} };
    return qe.publish("addFont", { font: Rt, instance: this }), Zt[Rt.id] = Rt, Mo(Rt), Rt.id;
  }, zi = function(w) {
    for (var j = 0, ut = st.length; j < ut; j++) {
      var pt = Vs.call(this, w[j][0], w[j][1], w[j][2], st[j][3], !0);
      d === !1 && (p[pt] = !0);
      var Ct = w[j][0].split("-");
      Mo({ id: pt, fontName: Ct[0], fontStyle: Ct[1] || "" });
    }
    qe.publish("addFonts", { fonts: Zt, dictionary: fe });
  }, Pi = function(w) {
    return w.foo = function() {
      try {
        return w.apply(this, arguments);
      } catch (pt) {
        var j = pt.stack || "";
        ~j.indexOf(" at ") && (j = j.split(" at ")[1]);
        var ut = "Error in function " + j.split(`
`)[0].split("<")[0] + ": " + pt.message;
        if (!Ae.console) throw new Error(ut);
        Ae.console.error(ut, pt), Ae.alert && alert(ut);
      }
    }, w.foo.bar = w, w.foo;
  }, hs = function(w, j) {
    var ut, pt, Ct, Rt, Vt, ue, be, Ee, Pe;
    if (Ct = (j = j || {}).sourceEncoding || "Unicode", Vt = j.outputEncoding, (j.autoencode || Vt) && Zt[we].metadata && Zt[we].metadata[Ct] && Zt[we].metadata[Ct].encoding && (Rt = Zt[we].metadata[Ct].encoding, !Vt && Zt[we].encoding && (Vt = Zt[we].encoding), !Vt && Rt.codePages && (Vt = Rt.codePages[0]), typeof Vt == "string" && (Vt = Rt[Vt]), Vt)) {
      for (be = !1, ue = [], ut = 0, pt = w.length; ut < pt; ut++) (Ee = Vt[w.charCodeAt(ut)]) ? ue.push(String.fromCharCode(Ee)) : ue.push(w[ut]), ue[ut].charCodeAt(0) >> 8 && (be = !0);
      w = ue.join("");
    }
    for (ut = w.length; be === void 0 && ut !== 0; ) w.charCodeAt(ut - 1) >> 8 && (be = !0), ut--;
    if (!be) return w;
    for (ue = j.noBOM ? [] : [254, 255], ut = 0, pt = w.length; ut < pt; ut++) {
      if ((Pe = (Ee = w.charCodeAt(ut)) >> 8) >> 8) throw new Error("Character at position " + ut + " of string '" + w + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      ue.push(Pe), ue.push(Ee - (Pe << 8));
    }
    return String.fromCharCode.apply(void 0, ue);
  }, Gn = f.__private__.pdfEscape = f.pdfEscape = function(w, j) {
    return hs(w, j).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, fs = f.__private__.beginPage = function(w) {
    Dt[++Qe] = [], Ne[Qe] = { objId: 0, contentsObjId: 0, userUnit: Number(a), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(w[0]), topRightY: Number(w[1]) } }, Do(Qe), ht(Dt[z]);
  }, Ur = function(w, j) {
    var ut, pt, Ct;
    switch (e = j || e, typeof w == "string" && (ut = b(w.toLowerCase()), Array.isArray(ut) && (pt = ut[0], Ct = ut[1])), Array.isArray(w) && (pt = w[0] * Jt, Ct = w[1] * Jt), isNaN(pt) && (pt = r[0], Ct = r[1]), (pt > 14400 || Ct > 14400) && (an.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), pt = Math.min(14400, pt), Ct = Math.min(14400, Ct)), r = [pt, Ct], e.substr(0, 1)) {
      case "l":
        Ct > pt && (r = [Ct, pt]);
        break;
      case "p":
        pt > Ct && (r = [Ct, pt]);
    }
    fs(r), Hl(Da), $(sr), ja !== 0 && $(ja + " J"), qa !== 0 && $(qa + " j"), qe.publish("addPage", { pageNumber: Qe });
  }, Ro = function(w) {
    w > 0 && w <= Qe && (Dt.splice(w, 1), Ne.splice(w, 1), Qe--, z > Qe && (z = Qe), this.setPage(z));
  }, Do = function(w) {
    w > 0 && w <= Qe && (z = w);
  }, Ta = f.__private__.getNumberOfPages = f.getNumberOfPages = function() {
    return Dt.length - 1;
  }, Bo = function(w, j, ut) {
    var pt, Ct = void 0;
    return ut = ut || {}, w = w !== void 0 ? w : Zt[we].fontName, j = j !== void 0 ? j : Zt[we].fontStyle, pt = w.toLowerCase(), fe[pt] !== void 0 && fe[pt][j] !== void 0 ? Ct = fe[pt][j] : fe[w] !== void 0 && fe[w][j] !== void 0 ? Ct = fe[w][j] : ut.disableWarning === !1 && an.warn("Unable to look up font label for font '" + w + "', '" + j + "'. Refer to getFontList() for available fonts."), Ct || ut.noFallback || (Ct = fe.times[j]) == null && (Ct = fe.times.normal), Ct;
  }, Q = f.__private__.putInfo = function() {
    var w = yn(), j = function(pt) {
      return pt;
    };
    for (var ut in u !== null && (j = Be.encryptor(w, 0)), $("<<"), $("/Producer (" + Gn(j("jsPDF " + Se.version)) + ")"), ae) ae.hasOwnProperty(ut) && ae[ut] && $("/" + ut.substr(0, 1).toUpperCase() + ut.substr(1) + " (" + Gn(j(ae[ut])) + ")");
    $("/CreationDate (" + Gn(j(X)) + ")"), $(">>"), $("endobj");
  }, mt = f.__private__.putCatalog = function(w) {
    var j = (w = w || {}).rootDictionaryObjId || ir;
    switch (yn(), $("<<"), $("/Type /Catalog"), $("/Pages " + j + " 0 R"), St || (St = "fullwidth"), St) {
      case "fullwidth":
        $("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        $("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        $("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        $("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var ut = "" + St;
        ut.substr(ut.length - 1) === "%" && (St = parseInt(St) / 100), typeof St == "number" && $("/OpenAction [3 0 R /XYZ null null " + q(St) + "]");
    }
    switch ($t || ($t = "continuous"), $t) {
      case "continuous":
        $("/PageLayout /OneColumn");
        break;
      case "single":
        $("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        $("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        $("/PageLayout /TwoColumnRight");
    }
    zt && $("/PageMode /" + zt), qe.publish("putCatalog"), $(">>"), $("endobj");
  }, dt = f.__private__.putTrailer = function() {
    $("trailer"), $("<<"), $("/Size " + (ot + 1)), $("/Root " + ot + " 0 R"), $("/Info " + (ot - 1) + " 0 R"), u !== null && $("/Encrypt " + Be.oid + " 0 R"), $("/ID [ <" + V + "> <" + V + "> ]"), $(">>");
  }, Bt = f.__private__.putHeader = function() {
    $("%PDF-" + g), $("%ºß¬à");
  }, Mt = f.__private__.putXRef = function() {
    var w = "0000000000";
    $("xref"), $("0 " + (ot + 1)), $("0000000000 65535 f ");
    for (var j = 1; j <= ot; j++)
      typeof xt[j] == "function" ? $((w + xt[j]()).slice(-10) + " 00000 n ") : xt[j] !== void 0 ? $((w + xt[j]).slice(-10) + " 00000 n ") : $("0000000000 00000 n ");
  }, pe = f.__private__.buildDocument = function() {
    F(), ht(gt), qe.publish("buildDocument"), Bt(), xr(), Gs(), Fo(), u !== null && $r(), Q(), mt();
    var w = wt;
    return Mt(), dt(), $("startxref"), $("" + w), $("%%EOF"), ht(Dt[z]), gt.join(`
`);
  }, me = f.__private__.getBlob = function(w) {
    return new Blob([J(w)], { type: "application/pdf" });
  }, Ce = f.output = f.__private__.output = Pi(function(w, j) {
    switch (typeof (j = j || {}) == "string" ? j = { filename: j } : j.filename = j.filename || "generated.pdf", w) {
      case void 0:
        return pe();
      case "save":
        f.save(j.filename);
        break;
      case "arraybuffer":
        return J(pe());
      case "blob":
        return me(pe());
      case "bloburi":
      case "bloburl":
        if (Ae.URL !== void 0 && typeof Ae.URL.createObjectURL == "function") return Ae.URL && Ae.URL.createObjectURL(me(pe())) || void 0;
        an.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var ut = "", pt = pe();
        try {
          ut = df(pt);
        } catch {
          ut = df(unescape(encodeURIComponent(pt)));
        }
        return "data:application/pdf;filename=" + j.filename + ";base64," + ut;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Ae) === "[object Window]") {
          var Ct = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Rt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          j.pdfObjectUrl && (Ct = j.pdfObjectUrl, Rt = "");
          var Vt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ct + '"' + Rt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(j) + ");<\/script></body></html>", ue = Ae.open();
          return ue !== null && ue.document.write(Vt), ue;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Ae) === "[object Window]") {
          var be = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (j.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + j.filename + '" width="500px" height="400px" /></body></html>', Ee = Ae.open();
          if (Ee !== null) {
            Ee.document.write(be);
            var Pe = this;
            Ee.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Ee.document.title = j.filename, Ee.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Pe.output("bloburl"));
            };
          }
          return Ee;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Ae) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Ue = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", j) + '"></iframe></body></html>', gn = Ae.open();
        if (gn !== null && (gn.document.write(Ue), gn.document.title = j.filename), gn || typeof safari > "u") return gn;
        break;
      case "datauri":
      case "dataurl":
        return Ae.document.location.href = this.output("datauristring", j);
      default:
        return null;
    }
  }), ln = function(w) {
    return Array.isArray(nr) === !0 && nr.indexOf(w) > -1;
  };
  switch (i) {
    case "pt":
      Jt = 1;
      break;
    case "mm":
      Jt = 72 / 25.4;
      break;
    case "cm":
      Jt = 72 / 2.54;
      break;
    case "in":
      Jt = 72;
      break;
    case "px":
      Jt = ln("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Jt = 12;
      break;
    case "ex":
      Jt = 6;
      break;
    default:
      if (typeof i != "number") throw new Error("Invalid unit: " + i);
      Jt = i;
  }
  var Be = null;
  it(), tt();
  var Ie = function(w) {
    return u !== null ? Be.encryptor(w, 0) : function(j) {
      return j;
    };
  }, $e = f.__private__.getPageInfo = f.getPageInfo = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Ne[w].objId, pageNumber: w, pageContext: Ne[w] };
  }, Kt = f.__private__.getPageInfoByObjId = function(w) {
    if (isNaN(w) || w % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var j in Ne) if (Ne[j].objId === w) break;
    return $e(j);
  }, Li = f.__private__.getCurrentPageInfo = f.getCurrentPageInfo = function() {
    return { objId: Ne[z].objId, pageNumber: z, pageContext: Ne[z] };
  };
  f.addPage = function() {
    return Ur.apply(this, arguments), this;
  }, f.setPage = function() {
    return Do.apply(this, arguments), ht.call(this, Dt[z]), this;
  }, f.insertPage = function(w) {
    return this.addPage(), this.movePage(z, w), this;
  }, f.movePage = function(w, j) {
    var ut, pt;
    if (w > j) {
      ut = Dt[w], pt = Ne[w];
      for (var Ct = w; Ct > j; Ct--) Dt[Ct] = Dt[Ct - 1], Ne[Ct] = Ne[Ct - 1];
      Dt[j] = ut, Ne[j] = pt, this.setPage(j);
    } else if (w < j) {
      ut = Dt[w], pt = Ne[w];
      for (var Rt = w; Rt < j; Rt++) Dt[Rt] = Dt[Rt + 1], Ne[Rt] = Ne[Rt + 1];
      Dt[j] = ut, Ne[j] = pt, this.setPage(j);
    }
    return this;
  }, f.deletePage = function() {
    return Ro.apply(this, arguments), this;
  }, f.__private__.text = f.text = function(w, j, ut, pt, Ct) {
    var Rt, Vt, ue, be, Ee, Pe, Ue, gn, vn, In = (pt = pt || {}).scope || this;
    if (typeof w == "number" && typeof j == "number" && (typeof ut == "string" || Array.isArray(ut))) {
      var ei = ut;
      ut = j, j = w, w = ei;
    }
    if (arguments[3] instanceof ve ? (E("The transform parameter of text() with a Matrix value"), vn = Ct) : (ue = arguments[4], be = arguments[5], nn(Ue = arguments[3]) === "object" && Ue !== null || (typeof ue == "string" && (be = ue, ue = null), typeof Ue == "string" && (be = Ue, Ue = null), typeof Ue == "number" && (ue = Ue, Ue = null), pt = { flags: Ue, angle: ue, align: be })), isNaN(j) || isNaN(ut) || w == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (w.length === 0) return In;
    var qn = "", or = !1, Ii = typeof pt.lineHeightFactor == "number" ? pt.lineHeightFactor : Xs, Sr = In.internal.scaleFactor;
    function Jl(un) {
      return un = un.split("	").join(Array(pt.TabLen || 9).join(" ")), Gn(un, Ue);
    }
    function Ha(un) {
      for (var cn, kn = un.concat(), Mn = [], Kr = kn.length; Kr--; ) typeof (cn = kn.shift()) == "string" ? Mn.push(cn) : Array.isArray(un) && (cn.length === 1 || cn[1] === void 0 && cn[2] === void 0) ? Mn.push(cn[0]) : Mn.push([cn[0], cn[1], cn[2]]);
      return Mn;
    }
    function Ga(un, cn) {
      var kn;
      if (typeof un == "string") kn = cn(un)[0];
      else if (Array.isArray(un)) {
        for (var Mn, Kr, tl = un.concat(), Zo = [], nu = tl.length; nu--; ) typeof (Mn = tl.shift()) == "string" ? Zo.push(cn(Mn)[0]) : Array.isArray(Mn) && typeof Mn[0] == "string" && (Kr = cn(Mn[0], Mn[1], Mn[2]), Zo.push([Kr[0], Kr[1], Kr[2]]));
        kn = Zo;
      }
      return kn;
    }
    var Uo = !1, Va = !0;
    if (typeof w == "string") Uo = !0;
    else if (Array.isArray(w)) {
      var Ya = w.concat();
      Vt = [];
      for (var Wo, Vn = Ya.length; Vn--; ) (typeof (Wo = Ya.shift()) != "string" || Array.isArray(Wo) && typeof Wo[0] != "string") && (Va = !1);
      Uo = Va;
    }
    if (Uo === !1) throw new Error('Type of text must be string or Array. "' + w + '" is not recognized.');
    typeof w == "string" && (w = w.match(/[\r?\n]/) ? w.split(/\r\n|\r|\n/g) : [w]);
    var Ho = vt / In.internal.scaleFactor, Go = Ho * (Ii - 1);
    switch (pt.baseline) {
      case "bottom":
        ut -= Go;
        break;
      case "top":
        ut += Ho - Go;
        break;
      case "hanging":
        ut += Ho - 2 * Go;
        break;
      case "middle":
        ut += Ho / 2 - Go;
    }
    if ((Pe = pt.maxWidth || 0) > 0 && (typeof w == "string" ? w = In.splitTextToSize(w, Pe) : Object.prototype.toString.call(w) === "[object Array]" && (w = w.reduce(function(un, cn) {
      return un.concat(In.splitTextToSize(cn, Pe));
    }, []))), Rt = { text: w, x: j, y: ut, options: pt, mutex: { pdfEscape: Gn, activeFontKey: we, fonts: Zt, activeFontSize: vt } }, qe.publish("preProcessText", Rt), w = Rt.text, ue = (pt = Rt.options).angle, !(vn instanceof ve) && ue && typeof ue == "number") {
      ue *= Math.PI / 180, pt.rotationDirection === 0 && (ue = -ue), A === v.ADVANCED && (ue = -ue);
      var Vo = Math.cos(ue), Ka = Math.sin(ue);
      vn = new ve(Vo, Ka, -Ka, Vo, 0, 0);
    } else ue && ue instanceof ve && (vn = ue);
    A !== v.ADVANCED || vn || (vn = Bi), (Ee = pt.charSpace || qo) !== void 0 && (qn += C(S(Ee)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (gn = pt.horizontalScale) !== void 0 && (qn += C(100 * gn) + ` Tz
`), pt.lang;
    var mi = -1, Qc = pt.renderingMode !== void 0 ? pt.renderingMode : pt.stroke, Xa = In.internal.getCurrentPageInfo().pageContext;
    switch (Qc) {
      case 0:
      case !1:
      case "fill":
        mi = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        mi = 1;
        break;
      case 2:
      case "fillThenStroke":
        mi = 2;
        break;
      case 3:
      case "invisible":
        mi = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        mi = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        mi = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        mi = 6;
        break;
      case 7:
      case "addToPathForClipping":
        mi = 7;
    }
    var Zl = Xa.usedRenderingMode !== void 0 ? Xa.usedRenderingMode : -1;
    mi !== -1 ? qn += mi + ` Tr
` : Zl !== -1 && (qn += `0 Tr
`), mi !== -1 && (Xa.usedRenderingMode = mi), be = pt.align || "left";
    var Ui, Yo = vt * Ii, Ql = In.internal.pageSize.getWidth(), tu = Zt[we];
    Ee = pt.charSpace || qo, Pe = pt.maxWidth || 0, Ue = Object.assign({ autoencode: !0, noBOM: !0 }, pt.flags);
    var ys = [], Qs = function(un) {
      return In.getStringUnitWidth(un, { font: tu, charSpace: Ee, fontSize: vt, doKerning: !1 }) * vt / Sr;
    };
    if (Object.prototype.toString.call(w) === "[object Array]") {
      var yi;
      Vt = Ha(w), be !== "left" && (Ui = Vt.map(Qs));
      var ci, bs = 0;
      if (be === "right") {
        j -= Ui[0], w = [], Vn = Vt.length;
        for (var Gr = 0; Gr < Vn; Gr++) Gr === 0 ? (ci = _r(j), yi = Hr(ut)) : (ci = S(bs - Ui[Gr]), yi = -Yo), w.push([Vt[Gr], ci, yi]), bs = Ui[Gr];
      } else if (be === "center") {
        j -= Ui[0] / 2, w = [], Vn = Vt.length;
        for (var Vr = 0; Vr < Vn; Vr++) Vr === 0 ? (ci = _r(j), yi = Hr(ut)) : (ci = S((bs - Ui[Vr]) / 2), yi = -Yo), w.push([Vt[Vr], ci, yi]), bs = Ui[Vr];
      } else if (be === "left") {
        w = [], Vn = Vt.length;
        for (var Ko = 0; Ko < Vn; Ko++) w.push(Vt[Ko]);
      } else if (be === "justify" && tu.encoding === "Identity-H") {
        w = [], Vn = Vt.length, Pe = Pe !== 0 ? Pe : Ql;
        for (var Yr = 0, Sn = 0; Sn < Vn; Sn++) if (yi = Sn === 0 ? Hr(ut) : -Yo, ci = Sn === 0 ? _r(j) : Yr, Sn < Vn - 1) {
          var Ja = S((Pe - Ui[Sn]) / (Vt[Sn].split(" ").length - 1)), hi = Vt[Sn].split(" ");
          w.push([hi[0] + " ", ci, yi]), Yr = 0;
          for (var Wi = 1; Wi < hi.length; Wi++) {
            var Xo = (Qs(hi[Wi - 1] + " " + hi[Wi]) - Qs(hi[Wi])) * Sr + Ja;
            Wi == hi.length - 1 ? w.push([hi[Wi], Xo, 0]) : w.push([hi[Wi] + " ", Xo, 0]), Yr -= Xo;
          }
        } else w.push([Vt[Sn], ci, yi]);
        w.push(["", Yr, 0]);
      } else {
        if (be !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (w = [], Vn = Vt.length, Pe = Pe !== 0 ? Pe : Ql, Sn = 0; Sn < Vn; Sn++) yi = Sn === 0 ? Hr(ut) : -Yo, ci = Sn === 0 ? _r(j) : 0, Sn < Vn - 1 ? ys.push(C(S((Pe - Ui[Sn]) / (Vt[Sn].split(" ").length - 1)))) : ys.push(0), w.push([Vt[Sn], ci, yi]);
      }
    }
    var eu = typeof pt.R2L == "boolean" ? pt.R2L : Et;
    eu === !0 && (w = Ga(w, function(un, cn, kn) {
      return [un.split("").reverse().join(""), cn, kn];
    })), Rt = { text: w, x: j, y: ut, options: pt, mutex: { pdfEscape: Gn, activeFontKey: we, fonts: Zt, activeFontSize: vt } }, qe.publish("postProcessText", Rt), w = Rt.text, or = Rt.mutex.isHex || !1;
    var Za = Zt[we].encoding;
    Za !== "WinAnsiEncoding" && Za !== "StandardEncoding" || (w = Ga(w, function(un, cn, kn) {
      return [Jl(un), cn, kn];
    })), Vt = Ha(w), w = [];
    for (var to, eo, vs, no = 0, Jo = 1, io = Array.isArray(Vt[0]) ? Jo : no, ws = "", Qa = function(un, cn, kn) {
      var Mn = "";
      return kn instanceof ve ? (kn = typeof pt.angle == "number" ? ki(kn, new ve(1, 0, 0, 1, un, cn)) : ki(new ve(1, 0, 0, 1, un, cn), kn), A === v.ADVANCED && (kn = ki(new ve(1, 0, 0, -1, 0, 0), kn)), Mn = kn.join(" ") + ` Tm
`) : Mn = C(un) + " " + C(cn) + ` Td
`, Mn;
    }, Hi = 0; Hi < Vt.length; Hi++) {
      switch (ws = "", io) {
        case Jo:
          vs = (or ? "<" : "(") + Vt[Hi][0] + (or ? ">" : ")"), to = parseFloat(Vt[Hi][1]), eo = parseFloat(Vt[Hi][2]);
          break;
        case no:
          vs = (or ? "<" : "(") + Vt[Hi] + (or ? ">" : ")"), to = _r(j), eo = Hr(ut);
      }
      ys !== void 0 && ys[Hi] !== void 0 && (ws = ys[Hi] + ` Tw
`), Hi === 0 ? w.push(ws + Qa(to, eo, vn) + vs) : io === no ? w.push(ws + vs) : io === Jo && w.push(ws + Qa(to, eo, vn) + vs);
    }
    w = io === no ? w.join(` Tj
T* `) : w.join(` Tj
`), w += ` Tj
`;
    var Gi = `BT
/`;
    return Gi += we + " " + vt + ` Tf
`, Gi += C(vt * Ii) + ` TL
`, Gi += Js + `
`, Gi += qn, Gi += w, $(Gi += "ET"), p[we] = !0, In;
  };
  var Fa = f.__private__.clip = f.clip = function(w) {
    return $(w === "evenodd" ? "W*" : "W"), this;
  };
  f.clipEvenOdd = function() {
    return Fa("evenodd");
  }, f.__private__.discardPath = f.discardPath = function() {
    return $("n"), this;
  };
  var $i = f.__private__.isValidStyle = function(w) {
    var j = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(w) !== -1 && (j = !0), j;
  };
  f.__private__.setDefaultPathOperation = f.setDefaultPathOperation = function(w) {
    return $i(w) && (h = w), this;
  };
  var ds = f.__private__.getStyle = f.getStyle = function(w) {
    var j = h;
    switch (w) {
      case "D":
      case "S":
        j = "S";
        break;
      case "F":
        j = "f";
        break;
      case "FD":
      case "DF":
        j = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        j = w;
    }
    return j;
  }, Ys = f.close = function() {
    return $("h"), this;
  };
  f.stroke = function() {
    return $("S"), this;
  }, f.fill = function(w) {
    return Wr("f", w), this;
  }, f.fillEvenOdd = function(w) {
    return Wr("f*", w), this;
  }, f.fillStroke = function(w) {
    return Wr("B", w), this;
  }, f.fillStrokeEvenOdd = function(w) {
    return Wr("B*", w), this;
  };
  var Wr = function(w, j) {
    nn(j) === "object" ? Gc(j, w) : $(w);
  }, Ma = function(w) {
    w === null || A === v.ADVANCED && w === void 0 || (w = ds(w), $(w));
  };
  function Hc(w, j, ut, pt, Ct) {
    var Rt = new ho(j || this.boundingBox, ut || this.xStep, pt || this.yStep, this.gState, Ct || this.matrix);
    Rt.stream = this.stream;
    var Vt = w + "$$" + this.cloneIndex++ + "$$";
    return ti(Vt, Rt), Rt;
  }
  var Gc = function(w, j) {
    var ut = We[w.key], pt = de[ut];
    if (pt instanceof Os) $("q"), $(Vc(j)), pt.gState && f.setGState(pt.gState), $(w.matrix.toString() + " cm"), $("/" + ut + " sh"), $("Q");
    else if (pt instanceof ho) {
      var Ct = new ve(1, 0, 0, -1, 0, ms());
      w.matrix && (Ct = Ct.multiply(w.matrix || Bi), ut = Hc.call(pt, w.key, w.boundingBox, w.xStep, w.yStep, Ct).id), $("q"), $("/Pattern cs"), $("/" + ut + " scn"), pt.gState && f.setGState(pt.gState), $(j), $("Q");
    }
  }, Vc = function(w) {
    switch (w) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Ra = f.moveTo = function(w, j) {
    return $(C(S(w)) + " " + C(x(j)) + " m"), this;
  }, Ks = f.lineTo = function(w, j) {
    return $(C(S(w)) + " " + C(x(j)) + " l"), this;
  }, ps = f.curveTo = function(w, j, ut, pt, Ct, Rt) {
    return $([C(S(w)), C(x(j)), C(S(ut)), C(x(pt)), C(S(Ct)), C(x(Rt)), "c"].join(" ")), this;
  };
  f.__private__.line = f.line = function(w, j, ut, pt, Ct) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || !$i(Ct)) throw new Error("Invalid arguments passed to jsPDF.line");
    return A === v.COMPAT ? this.lines([[ut - w, pt - j]], w, j, [1, 1], Ct || "S") : this.lines([[ut - w, pt - j]], w, j, [1, 1]).stroke();
  }, f.__private__.lines = f.lines = function(w, j, ut, pt, Ct, Rt) {
    var Vt, ue, be, Ee, Pe, Ue, gn, vn, In, ei, qn, or;
    if (typeof w == "number" && (or = ut, ut = j, j = w, w = or), pt = pt || [1, 1], Rt = Rt || !1, isNaN(j) || isNaN(ut) || !Array.isArray(w) || !Array.isArray(pt) || !$i(Ct) || typeof Rt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Ra(j, ut), Vt = pt[0], ue = pt[1], Ee = w.length, ei = j, qn = ut, be = 0; be < Ee; be++) (Pe = w[be]).length === 2 ? (ei = Pe[0] * Vt + ei, qn = Pe[1] * ue + qn, Ks(ei, qn)) : (Ue = Pe[0] * Vt + ei, gn = Pe[1] * ue + qn, vn = Pe[2] * Vt + ei, In = Pe[3] * ue + qn, ei = Pe[4] * Vt + ei, qn = Pe[5] * ue + qn, ps(Ue, gn, vn, In, ei, qn));
    return Rt && Ys(), Ma(Ct), this;
  }, f.path = function(w) {
    for (var j = 0; j < w.length; j++) {
      var ut = w[j], pt = ut.c;
      switch (ut.op) {
        case "m":
          Ra(pt[0], pt[1]);
          break;
        case "l":
          Ks(pt[0], pt[1]);
          break;
        case "c":
          ps.apply(this, pt);
          break;
        case "h":
          Ys();
      }
    }
    return this;
  }, f.__private__.rect = f.rect = function(w, j, ut, pt, Ct) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || !$i(Ct)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return A === v.COMPAT && (pt = -pt), $([C(S(w)), C(x(j)), C(S(ut)), C(S(pt)), "re"].join(" ")), Ma(Ct), this;
  }, f.__private__.triangle = f.triangle = function(w, j, ut, pt, Ct, Rt, Vt) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || isNaN(Ct) || isNaN(Rt) || !$i(Vt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[ut - w, pt - j], [Ct - ut, Rt - pt], [w - Ct, j - Rt]], w, j, [1, 1], Vt, !0), this;
  }, f.__private__.roundedRect = f.roundedRect = function(w, j, ut, pt, Ct, Rt, Vt) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || isNaN(Ct) || isNaN(Rt) || !$i(Vt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var ue = 4 / 3 * (Math.SQRT2 - 1);
    return Ct = Math.min(Ct, 0.5 * ut), Rt = Math.min(Rt, 0.5 * pt), this.lines([[ut - 2 * Ct, 0], [Ct * ue, 0, Ct, Rt - Rt * ue, Ct, Rt], [0, pt - 2 * Rt], [0, Rt * ue, -Ct * ue, Rt, -Ct, Rt], [2 * Ct - ut, 0], [-Ct * ue, 0, -Ct, -Rt * ue, -Ct, -Rt], [0, 2 * Rt - pt], [0, -Rt * ue, Ct * ue, -Rt, Ct, -Rt]], w + Ct, j, [1, 1], Vt, !0), this;
  }, f.__private__.ellipse = f.ellipse = function(w, j, ut, pt, Ct) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || isNaN(pt) || !$i(Ct)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Rt = 4 / 3 * (Math.SQRT2 - 1) * ut, Vt = 4 / 3 * (Math.SQRT2 - 1) * pt;
    return Ra(w + ut, j), ps(w + ut, j - Vt, w + Rt, j - pt, w, j - pt), ps(w - Rt, j - pt, w - ut, j - Vt, w - ut, j), ps(w - ut, j + Vt, w - Rt, j + pt, w, j + pt), ps(w + Rt, j + pt, w + ut, j + Vt, w + ut, j), Ma(Ct), this;
  }, f.__private__.circle = f.circle = function(w, j, ut, pt) {
    if (isNaN(w) || isNaN(j) || isNaN(ut) || !$i(pt)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(w, j, ut, ut, pt);
  }, f.setFont = function(w, j, ut) {
    return ut && (j = R(j, ut)), we = Bo(w, j, { disableWarning: !1 }), this;
  };
  var Yc = f.__private__.getFont = f.getFont = function() {
    return Zt[Bo.apply(f, arguments)];
  };
  f.__private__.getFontList = f.getFontList = function() {
    var w, j, ut = {};
    for (w in fe) if (fe.hasOwnProperty(w)) for (j in ut[w] = [], fe[w]) fe[w].hasOwnProperty(j) && ut[w].push(j);
    return ut;
  }, f.addFont = function(w, j, ut, pt, Ct) {
    var Rt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Rt.indexOf(arguments[3]) !== -1 ? Ct = arguments[3] : arguments[3] && Rt.indexOf(arguments[3]) == -1 && (ut = R(ut, pt)), Ct = Ct || "Identity-H", Vs.call(this, w, j, ut, Ct);
  };
  var Xs, Da = n.lineWidth || 0.200025, jo = f.__private__.getLineWidth = f.getLineWidth = function() {
    return Da;
  }, Hl = f.__private__.setLineWidth = f.setLineWidth = function(w) {
    return Da = w, $(C(S(w)) + " w"), this;
  };
  f.__private__.setLineDash = Se.API.setLineDash = Se.API.setLineDashPattern = function(w, j) {
    if (w = w || [], j = j || 0, isNaN(j) || !Array.isArray(w)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return w = w.map(function(ut) {
      return C(S(ut));
    }).join(" "), j = C(S(j)), $("[" + w + "] " + j + " d"), this;
  };
  var Gl = f.__private__.getLineHeight = f.getLineHeight = function() {
    return vt * Xs;
  };
  f.__private__.getLineHeight = f.getLineHeight = function() {
    return vt * Xs;
  };
  var Vl = f.__private__.setLineHeightFactor = f.setLineHeightFactor = function(w) {
    return typeof (w = w || 1.15) == "number" && (Xs = w), this;
  }, Yl = f.__private__.getLineHeightFactor = f.getLineHeightFactor = function() {
    return Xs;
  };
  Vl(n.lineHeight);
  var _r = f.__private__.getHorizontalCoordinate = function(w) {
    return S(w);
  }, Hr = f.__private__.getVerticalCoordinate = function(w) {
    return A === v.ADVANCED ? w : Ne[z].mediaBox.topRightY - Ne[z].mediaBox.bottomLeftY - S(w);
  }, Kc = f.__private__.getHorizontalCoordinateString = f.getHorizontalCoordinateString = function(w) {
    return C(_r(w));
  }, gs = f.__private__.getVerticalCoordinateString = f.getVerticalCoordinateString = function(w) {
    return C(Hr(w));
  }, sr = n.strokeColor || "0 G";
  f.__private__.getStrokeColor = f.getDrawColor = function() {
    return Ai(sr);
  }, f.__private__.setStrokeColor = f.setDrawColor = function(w, j, ut, pt) {
    return sr = Ni({ ch1: w, ch2: j, ch3: ut, ch4: pt, pdfColorType: "draw", precision: 2 }), $(sr), this;
  };
  var Ba = n.fillColor || "0 g";
  f.__private__.getFillColor = f.getFillColor = function() {
    return Ai(Ba);
  }, f.__private__.setFillColor = f.setFillColor = function(w, j, ut, pt) {
    return Ba = Ni({ ch1: w, ch2: j, ch3: ut, ch4: pt, pdfColorType: "fill", precision: 2 }), $(Ba), this;
  };
  var Js = n.textColor || "0 g", Xc = f.__private__.getTextColor = f.getTextColor = function() {
    return Ai(Js);
  };
  f.__private__.setTextColor = f.setTextColor = function(w, j, ut, pt) {
    return Js = Ni({ ch1: w, ch2: j, ch3: ut, ch4: pt, pdfColorType: "text", precision: 3 }), this;
  };
  var qo = n.charSpace, Jc = f.__private__.getCharSpace = f.getCharSpace = function() {
    return parseFloat(qo || 0);
  };
  f.__private__.setCharSpace = f.setCharSpace = function(w) {
    if (isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return qo = w, this;
  };
  var ja = 0;
  f.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, f.__private__.setLineCap = f.setLineCap = function(w) {
    var j = f.CapJoinStyles[w];
    if (j === void 0) throw new Error("Line cap style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return ja = j, $(j + " J"), this;
  };
  var qa = 0;
  f.__private__.setLineJoin = f.setLineJoin = function(w) {
    var j = f.CapJoinStyles[w];
    if (j === void 0) throw new Error("Line join style of '" + w + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return qa = j, $(j + " j"), this;
  }, f.__private__.setLineMiterLimit = f.__private__.setMiterLimit = f.setLineMiterLimit = f.setMiterLimit = function(w) {
    if (w = w || 0, isNaN(w)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return $(C(S(w)) + " M"), this;
  }, f.GState = Il, f.setGState = function(w) {
    (w = typeof w == "string" ? Te[_n[w]] : Kl(null, w)).equals(Fn) || ($("/" + w.id + " gs"), Fn = w);
  };
  var Kl = function(w, j) {
    if (!w || !_n[w]) {
      var ut = !1;
      for (var pt in Te) if (Te.hasOwnProperty(pt) && Te[pt].equals(j)) {
        ut = !0;
        break;
      }
      if (ut) j = Te[pt];
      else {
        var Ct = "GS" + (Object.keys(Te).length + 1).toString(10);
        Te[Ct] = j, j.id = Ct;
      }
      return w && (_n[w] = j.id), qe.publish("addGState", j), j;
    }
  };
  f.addGState = function(w, j) {
    return Kl(w, j), this;
  }, f.saveGraphicsState = function() {
    return $("q"), ie.push({ key: we, size: vt, color: Js }), this;
  }, f.restoreGraphicsState = function() {
    $("Q");
    var w = ie.pop();
    return we = w.key, vt = w.size, Js = w.color, Fn = null, this;
  }, f.setCurrentTransformationMatrix = function(w) {
    return $(w.toString() + " cm"), this;
  }, f.comment = function(w) {
    return $("#" + w), this;
  };
  var zo = function(w, j) {
    var ut = w || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return ut;
    }, set: function(Rt) {
      isNaN(Rt) || (ut = parseFloat(Rt));
    } });
    var pt = j || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return pt;
    }, set: function(Rt) {
      isNaN(Rt) || (pt = parseFloat(Rt));
    } });
    var Ct = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Rt) {
      Ct = Rt.toString();
    } }), this;
  }, za = function(w, j, ut, pt) {
    zo.call(this, w, j), this.type = "rect";
    var Ct = ut || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Vt) {
      isNaN(Vt) || (Ct = parseFloat(Vt));
    } });
    var Rt = pt || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Rt;
    }, set: function(Vt) {
      isNaN(Vt) || (Rt = parseFloat(Vt));
    } }), this;
  }, $a = function() {
    this.page = Qe, this.currentPage = z, this.pages = Dt.slice(0), this.pagesContext = Ne.slice(0), this.x = Nt, this.y = Ot, this.matrix = re, this.width = Zs(z), this.height = ms(z), this.outputDestination = Xt, this.id = "", this.objectNumber = -1;
  };
  $a.prototype.restore = function() {
    Qe = this.page, z = this.currentPage, Ne = this.pagesContext, Dt = this.pages, Nt = this.x, Ot = this.y, re = this.matrix, Ua(z, this.width), Wa(z, this.height), Xt = this.outputDestination;
  };
  var Xl = function(w, j, ut, pt, Ct) {
    jn.push(new $a()), Qe = z = 0, Dt = [], Nt = w, Ot = j, re = Ct, fs([ut, pt]);
  }, Zc = function(w) {
    if (Di[w]) jn.pop().restore();
    else {
      var j = new $a(), ut = "Xo" + (Object.keys(Ln).length + 1).toString(10);
      j.id = ut, Di[w] = ut, Ln[ut] = j, qe.publish("addFormObject", j), jn.pop().restore();
    }
  };
  for (var $o in f.beginFormObject = function(w, j, ut, pt, Ct) {
    return Xl(w, j, ut, pt, Ct), this;
  }, f.endFormObject = function(w) {
    return Zc(w), this;
  }, f.doFormObject = function(w, j) {
    var ut = Ln[Di[w]];
    return $("q"), $(j.toString() + " cm"), $("/" + ut.id + " Do"), $("Q"), this;
  }, f.getFormObject = function(w) {
    var j = Ln[Di[w]];
    return { x: j.x, y: j.y, width: j.width, height: j.height, matrix: j.matrix };
  }, f.save = function(w, j) {
    return w = w || "generated.pdf", (j = j || {}).returnPromise = j.returnPromise || !1, j.returnPromise === !1 ? (oo(me(pe()), w), typeof oo.unload == "function" && Ae.setTimeout && setTimeout(oo.unload, 911), this) : new Promise(function(ut, pt) {
      try {
        var Ct = oo(me(pe()), w);
        typeof oo.unload == "function" && Ae.setTimeout && setTimeout(oo.unload, 911), ut(Ct);
      } catch (Rt) {
        pt(Rt.message);
      }
    });
  }, Se.API) Se.API.hasOwnProperty($o) && ($o === "events" && Se.API.events.length ? function(w, j) {
    var ut, pt, Ct;
    for (Ct = j.length - 1; Ct !== -1; Ct--) ut = j[Ct][0], pt = j[Ct][1], w.subscribe.apply(w, [ut].concat(typeof pt == "function" ? [pt] : pt));
  }(qe, Se.API.events) : f[$o] = Se.API[$o]);
  var Zs = f.getPageWidth = function(w) {
    return (Ne[w = w || z].mediaBox.topRightX - Ne[w].mediaBox.bottomLeftX) / Jt;
  }, Ua = f.setPageWidth = function(w, j) {
    Ne[w].mediaBox.topRightX = j * Jt + Ne[w].mediaBox.bottomLeftX;
  }, ms = f.getPageHeight = function(w) {
    return (Ne[w = w || z].mediaBox.topRightY - Ne[w].mediaBox.bottomLeftY) / Jt;
  }, Wa = f.setPageHeight = function(w, j) {
    Ne[w].mediaBox.topRightY = j * Jt + Ne[w].mediaBox.bottomLeftY;
  };
  return f.internal = { pdfEscape: Gn, getStyle: ds, getFont: Yc, getFontSize: ft, getCharSpace: Jc, getTextColor: Xc, getLineHeight: Gl, getLineHeightFactor: Yl, getLineWidth: jo, write: nt, getHorizontalCoordinate: _r, getVerticalCoordinate: Hr, getCoordinateString: Kc, getVerticalCoordinateString: gs, collections: {}, newObject: yn, newAdditionalObject: os, newObjectDeferred: bn, newObjectDeferredBegin: ui, getFilters: ji, putStream: Ci, events: qe, scaleFactor: Jt, pageSize: { getWidth: function() {
    return Zs(z);
  }, setWidth: function(w) {
    Ua(z, w);
  }, getHeight: function() {
    return ms(z);
  }, setHeight: function(w) {
    Wa(z, w);
  } }, encryptionOptions: u, encryption: Be, getEncryptor: Ie, output: Ce, getNumberOfPages: Ta, pages: Dt, out: $, f2: q, f3: N, getPageInfo: $e, getPageInfoByObjId: Kt, getCurrentPageInfo: Li, getPDFVersion: y, Point: zo, Rectangle: za, Matrix: ve, hasHotfix: ln }, Object.defineProperty(f.internal.pageSize, "width", { get: function() {
    return Zs(z);
  }, set: function(w) {
    Ua(z, w);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(f.internal.pageSize, "height", { get: function() {
    return ms(z);
  }, set: function(w) {
    Wa(z, w);
  }, enumerable: !0, configurable: !0 }), zi.call(f, st), we = "F1", Ur(r, e), qe.publish("initialized"), f;
}
da.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, da.prototype.toHexString = function(n) {
  return n.split("").map(function(t) {
    return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, da.prototype.hexToBytes = function(n) {
  for (var t = [], e = 0; e < n.length; e += 2) t.push(String.fromCharCode(parseInt(n.substr(e, 2), 16)));
  return t.join("");
}, da.prototype.processOwnerPassword = function(n, t) {
  return gf(pf(t).substr(0, 5), n);
}, da.prototype.encryptor = function(n, t) {
  var e = pf(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & t, t >> 8 & 255)).substr(0, 10);
  return function(i) {
    return gf(e, i);
  };
}, Il.prototype.equals = function(n) {
  var t, e = "id,objectNumber,equals";
  if (!n || nn(n) !== nn(this)) return !1;
  var i = 0;
  for (t in this) if (!(e.indexOf(t) >= 0)) {
    if (this.hasOwnProperty(t) && !n.hasOwnProperty(t) || this[t] !== n[t]) return !1;
    i++;
  }
  for (t in n) n.hasOwnProperty(t) && e.indexOf(t) < 0 && i--;
  return i === 0;
}, Se.API = { events: [] }, Se.version = "2.5.2";
var xn = Se.API, kd = 1, Lo = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, ia = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Le = function(n) {
  return n.toFixed(2);
}, Is = function(n) {
  return n.toFixed(5);
};
xn.__acroform__ = {};
var Si = function(n, t) {
  n.prototype = Object.create(t.prototype), n.prototype.constructor = n;
}, Jp = function(n) {
  return n * kd;
}, Cr = function(n) {
  var t = new O1(), e = he.internal.getHeight(n) || 0, i = he.internal.getWidth(n) || 0;
  return t.BBox = [0, 0, Number(Le(i)), Number(Le(e))], t;
}, wv = xn.__acroform__.setBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << t;
}, xv = xn.__acroform__.clearBit = function(n, t) {
  if (n = n || 0, t = t || 0, isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << t);
}, _v = xn.__acroform__.getBit = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << t ? 1 : 0;
}, Nn = xn.__acroform__.getBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return _v(n, t - 1);
}, Cn = xn.__acroform__.setBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return wv(n, t - 1);
}, Pn = xn.__acroform__.clearBitForPdf = function(n, t) {
  if (isNaN(n) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return xv(n, t - 1);
}, Sv = xn.__acroform__.calculateCoordinates = function(n, t) {
  var e = t.internal.getHorizontalCoordinate, i = t.internal.getVerticalCoordinate, r = n[0], s = n[1], o = n[2], a = n[3], l = {};
  return l.lowerLeft_X = e(r) || 0, l.lowerLeft_Y = i(s + a) || 0, l.upperRight_X = e(r + o) || 0, l.upperRight_Y = i(s) || 0, [Number(Le(l.lowerLeft_X)), Number(Le(l.lowerLeft_Y)), Number(Le(l.upperRight_X)), Number(Le(l.upperRight_Y))];
}, kv = function(n) {
  if (n.appearanceStreamContent) return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var t = [], e = n._V || n.DV, i = mf(n, e), r = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    t.push("/Tx BMC"), t.push("q"), t.push("BT"), t.push(n.scope.__private__.encodeColorString(n.color)), t.push("/" + r + " " + Le(i.fontSize) + " Tf"), t.push("1 0 0 1 0 0 Tm"), t.push(i.text), t.push("ET"), t.push("Q"), t.push("EMC");
    var s = Cr(n);
    return s.scope = n.scope, s.stream = t.join(`
`), s;
  }
}, mf = function(n, t) {
  var e = n.fontSize === 0 ? n.maxFontSize : n.fontSize, i = { text: "", fontSize: "" }, r = (t = (t = t.substr(0, 1) == "(" ? t.substr(1) : t).substr(t.length - 1) == ")" ? t.substr(0, t.length - 1) : t).split(" ");
  r = n.multiline ? r.map(function(N) {
    return N.split(`
`);
  }) : r.map(function(N) {
    return [N];
  });
  var s = e, o = he.internal.getHeight(n) || 0;
  o = o < 0 ? -o : o;
  var a = he.internal.getWidth(n) || 0;
  a = a < 0 ? -a : a;
  var l = function(N, S, T) {
    if (N + 1 < r.length) {
      var x = S + " " + r[N + 1][0];
      return Pu(x, n, T).width <= a - 4;
    }
    return !1;
  };
  s++;
  t: for (; s > 0; ) {
    t = "", s--;
    var h, u, d = Pu("3", n, s).height, p = n.multiline ? o - s : (o - d) / 2, f = p += 2, g = 0, y = 0, _ = 0;
    if (s <= 0) {
      t = `(...) Tj
`, t += "% Width of Text: " + Pu(t, n, s = 12).width + ", FieldWidth:" + a + `
`;
      break;
    }
    for (var b = "", v = 0, A = 0; A < r.length; A++) if (r.hasOwnProperty(A)) {
      var L = !1;
      if (r[A].length !== 1 && _ !== r[A].length - 1) {
        if ((d + 2) * (v + 2) + 2 > o) continue t;
        b += r[A][_], L = !0, y = A, A--;
      } else {
        b = (b += r[A][_] + " ").substr(b.length - 1) == " " ? b.substr(0, b.length - 1) : b;
        var O = parseInt(A), R = l(O, b, s), C = A >= r.length - 1;
        if (R && !C) {
          b += " ", _ = 0;
          continue;
        }
        if (R || C) {
          if (C) y = O;
          else if (n.multiline && (d + 2) * (v + 2) + 2 > o) continue t;
        } else {
          if (!n.multiline || (d + 2) * (v + 2) + 2 > o) continue t;
          y = O;
        }
      }
      for (var E = "", M = g; M <= y; M++) {
        var q = r[M];
        if (n.multiline) {
          if (M === y) {
            E += q[_] + " ", _ = (_ + 1) % q.length;
            continue;
          }
          if (M === g) {
            E += q[q.length - 1] + " ";
            continue;
          }
        }
        E += q[0] + " ";
      }
      switch (E = E.substr(E.length - 1) == " " ? E.substr(0, E.length - 1) : E, u = Pu(E, n, s).width, n.textAlign) {
        case "right":
          h = a - u - 2;
          break;
        case "center":
          h = (a - u) / 2;
          break;
        case "left":
        default:
          h = 2;
      }
      t += Le(h) + " " + Le(f) + ` Td
`, t += "(" + Lo(E) + `) Tj
`, t += -Le(h) + ` 0 Td
`, f = -(s + 2), u = 0, g = L ? y : y + 1, v++, b = "";
    }
    break;
  }
  return i.text = t, i.fontSize = s, i;
}, Pu = function(n, t, e) {
  var i = t.scope.internal.getFont(t.fontName, t.fontStyle), r = t.scope.getStringUnitWidth(n, { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e);
  return { height: t.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(e), charSpace: 0 }) * parseFloat(e) * 1.5, width: r };
}, Av = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Nv = function(n, t) {
  var e = { type: "reference", object: n };
  t.internal.getPageInfo(n.page).pageContext.annotations.find(function(i) {
    return i.type === e.type && i.object === e.object;
  }) === void 0 && t.internal.getPageInfo(n.page).pageContext.annotations.push(e);
}, Cv = function(n, t) {
  for (var e in n) if (n.hasOwnProperty(e)) {
    var i = e, r = n[e];
    t.internal.newObjectDeferredBegin(r.objId, !0), nn(r) === "object" && typeof r.putStream == "function" && r.putStream(), delete n[i];
  }
}, Pv = function(n, t) {
  if (t.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (vr.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(Av)), n.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    kd = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new T1(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(e) {
        e.internal.events.unsubscribe(e.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete e.internal.acroformPlugin.acroFormDictionaryRoot._eventID, e.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(e) {
        e.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = e.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r in i) if (i.hasOwnProperty(r)) {
          var s = i[r];
          s.objId = void 0, s.hasAnnotation && Nv(s, e);
        }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(e) {
        if (e.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        e.internal.write("/AcroForm " + e.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(e) {
      (function(i, r) {
        var s = !i;
        for (var o in i || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (i.hasOwnProperty(o)) {
          var a = i[o], l = [], h = a.Rect;
          if (a.Rect && (a.Rect = Sv(a.Rect, r)), r.internal.newObjectDeferredBegin(a.objId, !0), a.DA = he.createDefaultAppearanceStream(a), nn(a) === "object" && typeof a.getKeyValueListForStream == "function" && (l = a.getKeyValueListForStream()), a.Rect = h, a.hasAppearanceStream && !a.appearanceStreamContent) {
            var u = kv(a);
            l.push({ key: "AP", value: "<</N " + u + ">>" }), r.internal.acroformPlugin.xForms.push(u);
          }
          if (a.appearanceStreamContent) {
            var d = "";
            for (var p in a.appearanceStreamContent) if (a.appearanceStreamContent.hasOwnProperty(p)) {
              var f = a.appearanceStreamContent[p];
              if (d += "/" + p + " ", d += "<<", Object.keys(f).length >= 1 || Array.isArray(f)) {
                for (var o in f) if (f.hasOwnProperty(o)) {
                  var g = f[o];
                  typeof g == "function" && (g = g.call(r, a)), d += "/" + o + " " + g + " ", r.internal.acroformPlugin.xForms.indexOf(g) >= 0 || r.internal.acroformPlugin.xForms.push(g);
                }
              } else typeof (g = f) == "function" && (g = g.call(r, a)), d += "/" + o + " " + g, r.internal.acroformPlugin.xForms.indexOf(g) >= 0 || r.internal.acroformPlugin.xForms.push(g);
              d += ">>";
            }
            l.push({ key: "AP", value: `<<
` + d + ">>" });
          }
          r.internal.putStream({ additionalKeyValues: l, objectId: a.objId }), r.internal.out("endobj");
        }
        s && Cv(r.internal.acroformPlugin.xForms, r);
      })(e, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, E1 = xn.__acroform__.arrayToPdfArray = function(n, t, e) {
  var i = function(o) {
    return o;
  };
  if (Array.isArray(n)) {
    for (var r = "[", s = 0; s < n.length; s++) switch (s !== 0 && (r += " "), nn(n[s])) {
      case "boolean":
      case "number":
      case "object":
        r += n[s].toString();
        break;
      case "string":
        n[s].substr(0, 1) !== "/" ? (t !== void 0 && e && (i = e.internal.getEncryptor(t)), r += "(" + Lo(i(n[s].toString())) + ")") : r += n[s].toString();
    }
    return r += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Lh = function(n, t, e) {
  var i = function(r) {
    return r;
  };
  return t !== void 0 && e && (i = e.internal.getEncryptor(t)), (n = n || "").toString(), n = "(" + Lo(i(n)) + ")";
}, Ir = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Ir.prototype.toString = function() {
  return this.objId + " 0 R";
}, Ir.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, Ir.prototype.getKeyValueListForStream = function() {
  var n = [], t = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var e in t) if (Object.getOwnPropertyDescriptor(this, t[e]).configurable === !1) {
    var i = t[e], r = this[i];
    r && (Array.isArray(r) ? n.push({ key: i, value: E1(r, this.objId, this.scope) }) : r instanceof Ir ? (r.scope = this.scope, n.push({ key: i, value: r.objId + " 0 R" })) : typeof r != "function" && n.push({ key: i, value: r }));
  }
  return n;
};
var O1 = function() {
  Ir.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, t = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return t;
  }, set: function(e) {
    t = e;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(e) {
    n = e.trim();
  }, get: function() {
    return n || null;
  } });
};
Si(O1, Ir);
var T1 = function() {
  Ir.call(this);
  var n, t = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return t.length > 0 ? t : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return t;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var e = function(i) {
        return i;
      };
      return this.scope && (e = this.scope.internal.getEncryptor(this.objId)), "(" + Lo(e(n)) + ")";
    }
  }, set: function(e) {
    n = e;
  } });
};
Si(T1, Ir);
var vr = function n() {
  Ir.call(this);
  var t = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(b) {
    if (isNaN(b)) throw new Error('Invalid value "' + b + '" for attribute F supplied.');
    t = b;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(t, 3);
  }, set: function(b) {
    b ? this.F = Cn(t, 3) : this.F = Pn(t, 3);
  } });
  var e = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(b) {
    if (isNaN(b)) throw new Error('Invalid value "' + b + '" for attribute Ff supplied.');
    e = b;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0) return i;
  }, set: function(b) {
    i = b !== void 0 ? b : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(b) {
    i[0] = b;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(b) {
    i[1] = b;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(b) {
    i[2] = b;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(b) {
    i[3] = b;
  } });
  var r = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(b) {
    switch (b) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        r = b;
        break;
      default:
        throw new Error('Invalid value "' + b + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof lc) return;
      s = "FieldObject" + n.FieldNum++;
    }
    var b = function(v) {
      return v;
    };
    return this.scope && (b = this.scope.internal.getEncryptor(this.objId)), "(" + Lo(b(s)) + ")";
  }, set: function(b) {
    s = b.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(b) {
    s = b;
  } });
  var o = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(b) {
    o = b;
  } });
  var a = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(b) {
    a = b;
  } });
  var l = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(b) {
    l = b;
  } });
  var h = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return h === void 0 ? 50 / kd : h;
  }, set: function(b) {
    h = b;
  } });
  var u = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return u;
  }, set: function(b) {
    u = b;
  } });
  var d = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!d || this instanceof lc || this instanceof Bs)) return Lh(d, this.objId, this.scope);
  }, set: function(b) {
    b = b.toString(), d = b;
  } });
  var p = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (p) return this instanceof Bn ? p : Lh(p, this.objId, this.scope);
  }, set: function(b) {
    b = b.toString(), p = this instanceof Bn ? b : b.substr(0, 1) === "(" ? ia(b.substr(1, b.length - 2)) : ia(b);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Bn ? ia(p.substr(1, p.length - 1)) : p;
  }, set: function(b) {
    b = b.toString(), p = this instanceof Bn ? "/" + b : b;
  } });
  var f = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return f;
  }, set: function(b) {
    this.V = b;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (f) return this instanceof Bn ? f : Lh(f, this.objId, this.scope);
  }, set: function(b) {
    b = b.toString(), f = this instanceof Bn ? b : b.substr(0, 1) === "(" ? ia(b.substr(1, b.length - 2)) : ia(b);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Bn ? ia(f.substr(1, f.length - 1)) : f;
  }, set: function(b) {
    b = b.toString(), f = this instanceof Bn ? "/" + b : b;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var g, y = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return y;
  }, set: function(b) {
    b = !!b, y = b;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (g) return g;
  }, set: function(b) {
    g = b;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 1);
  }, set: function(b) {
    b ? this.Ff = Cn(this.Ff, 1) : this.Ff = Pn(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 2);
  }, set: function(b) {
    b ? this.Ff = Cn(this.Ff, 2) : this.Ff = Pn(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 3);
  }, set: function(b) {
    b ? this.Ff = Cn(this.Ff, 3) : this.Ff = Pn(this.Ff, 3);
  } });
  var _ = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (_ !== null) return _;
  }, set: function(b) {
    if ([0, 1, 2].indexOf(b) === -1) throw new Error('Invalid value "' + b + '" for attribute Q supplied.');
    _ = b;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var b;
    switch (_) {
      case 0:
      default:
        b = "left";
        break;
      case 1:
        b = "center";
        break;
      case 2:
        b = "right";
    }
    return b;
  }, configurable: !0, enumerable: !0, set: function(b) {
    switch (b) {
      case "right":
      case 2:
        _ = 2;
        break;
      case "center":
      case 1:
        _ = 1;
        break;
      case "left":
      case 0:
      default:
        _ = 0;
    }
  } });
};
Si(vr, Ir);
var mo = function() {
  vr.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } });
  var t = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return E1(t, this.objId, this.scope);
  }, set: function(e) {
    var i, r;
    r = [], typeof (i = e) == "string" && (r = function(s, o, a) {
      a || (a = 1);
      for (var l, h = []; l = o.exec(s); ) h.push(l[a]);
      return h;
    }(i, /\((.*?)\)/g)), t = r;
  } }), this.getOptions = function() {
    return t;
  }, this.setOptions = function(e) {
    t = e, this.sort && t.sort();
  }, this.addOption = function(e) {
    e = (e = e || "").toString(), t.push(e), this.sort && t.sort();
  }, this.removeOption = function(e, i) {
    for (i = i || !1, e = (e = e || "").toString(); t.indexOf(e) !== -1 && (t.splice(t.indexOf(e), 1), i !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 18);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 18) : this.Ff = Pn(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 19);
  }, set: function(e) {
    this.combo === !0 && (e ? this.Ff = Cn(this.Ff, 19) : this.Ff = Pn(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 20);
  }, set: function(e) {
    e ? (this.Ff = Cn(this.Ff, 20), t.sort()) : this.Ff = Pn(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 22);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 22) : this.Ff = Pn(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 23) : this.Ff = Pn(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 27);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 27) : this.Ff = Pn(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Si(mo, vr);
var yo = function() {
  mo.call(this), this.fontName = "helvetica", this.combo = !1;
};
Si(yo, mo);
var bo = function() {
  yo.call(this), this.combo = !0;
};
Si(bo, yo);
var kl = function() {
  bo.call(this), this.edit = !0;
};
Si(kl, bo);
var Bn = function() {
  vr.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 15);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 15) : this.Ff = Pn(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 16);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 16) : this.Ff = Pn(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 17);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 17) : this.Ff = Pn(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Cn(this.Ff, 26) : this.Ff = Pn(this.Ff, 26);
  } });
  var n, t = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var e = function(s) {
      return s;
    };
    if (this.scope && (e = this.scope.internal.getEncryptor(this.objId)), Object.keys(t).length !== 0) {
      var i, r = [];
      for (i in r.push("<<"), t) r.push("/" + i + " (" + Lo(e(t[i])) + ")");
      return r.push(">>"), r.join(`
`);
    }
  }, set: function(e) {
    nn(e) === "object" && (t = e);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return t.CA || "";
  }, set: function(e) {
    typeof e == "string" && (t.CA = e);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(e) {
    n = "/" + e;
  } });
};
Si(Bn, vr);
var Al = function() {
  Bn.call(this), this.pushButton = !0;
};
Si(Al, Bn);
var vo = function() {
  Bn.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t !== void 0 ? t : [];
  } });
};
Si(vo, Bn);
var lc = function() {
  var n, t;
  vr.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(r) {
    n = r;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return t;
  }, set: function(r) {
    t = r;
  } });
  var e, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var r = function(a) {
      return a;
    };
    this.scope && (r = this.scope.internal.getEncryptor(this.objId));
    var s, o = [];
    for (s in o.push("<<"), i) o.push("/" + s + " (" + Lo(r(i[s])) + ")");
    return o.push(">>"), o.join(`
`);
  }, set: function(r) {
    nn(r) === "object" && (i = r);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(r) {
    typeof r == "string" && (i.CA = r);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(r) {
    e = r;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(r) {
    e = "/" + r;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = he.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Si(lc, vr), vo.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var t in this.Kids) if (this.Kids.hasOwnProperty(t)) {
    var e = this.Kids[t];
    e.appearanceStreamContent = n.createAppearanceStream(e.optionName), e.caption = n.getCA();
  }
}, vo.prototype.createOption = function(n) {
  var t = new lc();
  return t.Parent = this, t.optionName = n, this.Kids.push(t), Lv.call(this.scope, t), t;
};
var Nl = function() {
  Bn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = he.CheckBox.createAppearanceStream();
};
Si(Nl, Bn);
var Bs = function() {
  vr.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 13);
  }, set: function(t) {
    t ? this.Ff = Cn(this.Ff, 13) : this.Ff = Pn(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 21);
  }, set: function(t) {
    t ? this.Ff = Cn(this.Ff, 21) : this.Ff = Pn(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Cn(this.Ff, 23) : this.Ff = Pn(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 24);
  }, set: function(t) {
    t ? this.Ff = Cn(this.Ff, 24) : this.Ff = Pn(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 25);
  }, set: function(t) {
    t ? this.Ff = Cn(this.Ff, 25) : this.Ff = Pn(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Cn(this.Ff, 26) : this.Ff = Pn(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    Number.isInteger(t) && (n = t);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Si(Bs, vr);
var Cl = function() {
  Bs.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Nn(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = Cn(this.Ff, 14) : this.Ff = Pn(this.Ff, 14);
  } }), this.password = !0;
};
Si(Cl, Bs);
var he = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: he.CheckBox.YesNormal }, D: { On: he.CheckBox.YesPushDown, Off: he.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), s = mf(n, n.caption);
  return e.push("0.749023 g"), e.push("0 0 " + Le(he.internal.getWidth(n)) + " " + Le(he.internal.getHeight(n)) + " re"), e.push("f"), e.push("BMC"), e.push("q"), e.push("0 0 1 rg"), e.push("/" + i + " " + Le(s.fontSize) + " Tf " + r), e.push("BT"), e.push(s.text), e.push("ET"), e.push("Q"), e.push("EMC"), t.stream = e.join(`
`), t;
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), r = [], s = he.internal.getHeight(n), o = he.internal.getWidth(n), a = mf(n, n.caption);
  return r.push("1 g"), r.push("0 0 " + Le(o) + " " + Le(s) + " re"), r.push("f"), r.push("q"), r.push("0 0 1 rg"), r.push("0 0 " + Le(o - 1) + " " + Le(s - 1) + " re"), r.push("W"), r.push("n"), r.push("0 g"), r.push("BT"), r.push("/" + e + " " + Le(a.fontSize) + " Tf " + i), r.push(a.text), r.push("ET"), r.push("Q"), t.stream = r.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Le(he.internal.getWidth(n)) + " " + Le(he.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var t = { D: { Off: he.RadioButton.Circle.OffPushDown }, N: {} };
  return t.N[n] = he.RadioButton.Circle.YesNormal, t.D[n] = he.RadioButton.Circle.YesPushDown, t;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = he.internal.getWidth(n) <= he.internal.getHeight(n) ? he.internal.getWidth(n) / 4 : he.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = he.internal.Bezier_C, s = Number((i * r).toFixed(5));
  return e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), e.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), e.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), e.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = he.internal.getWidth(n) <= he.internal.getHeight(n) ? he.internal.getWidth(n) / 4 : he.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * he.internal.Bezier_C).toFixed(5)), o = Number((i * he.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), e.push("0 g"), e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(i + " 0 m"), e.push(i + " " + o + " " + o + " " + i + " 0 " + i + " c"), e.push("-" + o + " " + i + " -" + i + " " + o + " -" + i + " 0 c"), e.push("-" + i + " -" + o + " -" + o + " -" + i + " 0 -" + i + " c"), e.push(o + " -" + i + " " + i + " -" + o + " " + i + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = he.internal.getWidth(n) <= he.internal.getHeight(n) ? he.internal.getWidth(n) / 4 : he.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), s = Number((r * he.internal.Bezier_C).toFixed(5));
  return e.push("0.749023 g"), e.push("q"), e.push("1 0 0 1 " + Is(he.internal.getWidth(n) / 2) + " " + Is(he.internal.getHeight(n) / 2) + " cm"), e.push(r + " 0 m"), e.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), e.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), e.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), e.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), e.push("f"), e.push("Q"), t.stream = e.join(`
`), t;
} }, Cross: { createAppearanceStream: function(n) {
  var t = { D: { Off: he.RadioButton.Cross.OffPushDown }, N: {} };
  return t.N[n] = he.RadioButton.Cross.YesNormal, t.D[n] = he.RadioButton.Cross.YesPushDown, t;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [], i = he.internal.calculateCross(n);
  return e.push("q"), e.push("1 1 " + Le(he.internal.getWidth(n) - 2) + " " + Le(he.internal.getHeight(n) - 2) + " re"), e.push("W"), e.push("n"), e.push(Le(i.x1.x) + " " + Le(i.x1.y) + " m"), e.push(Le(i.x2.x) + " " + Le(i.x2.y) + " l"), e.push(Le(i.x4.x) + " " + Le(i.x4.y) + " m"), e.push(Le(i.x3.x) + " " + Le(i.x3.y) + " l"), e.push("s"), e.push("Q"), t.stream = e.join(`
`), t;
}, YesPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = he.internal.calculateCross(n), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + Le(he.internal.getWidth(n)) + " " + Le(he.internal.getHeight(n)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + Le(he.internal.getWidth(n) - 2) + " " + Le(he.internal.getHeight(n) - 2) + " re"), i.push("W"), i.push("n"), i.push(Le(e.x1.x) + " " + Le(e.x1.y) + " m"), i.push(Le(e.x2.x) + " " + Le(e.x2.y) + " l"), i.push(Le(e.x4.x) + " " + Le(e.x4.y) + " m"), i.push(Le(e.x3.x) + " " + Le(e.x3.y) + " l"), i.push("s"), i.push("Q"), t.stream = i.join(`
`), t;
}, OffPushDown: function(n) {
  var t = Cr(n);
  t.scope = n.scope;
  var e = [];
  return e.push("0.749023 g"), e.push("0 0 " + Le(he.internal.getWidth(n)) + " " + Le(he.internal.getHeight(n)) + " re"), e.push("f"), t.stream = e.join(`
`), t;
} } }, createDefaultAppearanceStream: function(n) {
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, e = n.scope.__private__.encodeColorString(n.color);
  return "/" + t + " " + n.fontSize + " Tf " + e;
} };
he.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var t = he.internal.getWidth(n), e = he.internal.getHeight(n), i = Math.min(t, e);
  return { x1: { x: (t - i) / 2, y: (e - i) / 2 + i }, x2: { x: (t - i) / 2 + i, y: (e - i) / 2 }, x3: { x: (t - i) / 2, y: (e - i) / 2 }, x4: { x: (t - i) / 2 + i, y: (e - i) / 2 + i } };
} }, he.internal.getWidth = function(n) {
  var t = 0;
  return nn(n) === "object" && (t = Jp(n.Rect[2])), t;
}, he.internal.getHeight = function(n) {
  var t = 0;
  return nn(n) === "object" && (t = Jp(n.Rect[3])), t;
};
var Lv = xn.addField = function(n) {
  if (Pv(this, n), !(n instanceof vr)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var t;
  return (t = n).scope.internal.acroformPlugin.printedOut && (t.scope.internal.acroformPlugin.printedOut = !1, t.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), t.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
xn.AcroFormChoiceField = mo, xn.AcroFormListBox = yo, xn.AcroFormComboBox = bo, xn.AcroFormEditBox = kl, xn.AcroFormButton = Bn, xn.AcroFormPushButton = Al, xn.AcroFormRadioButton = vo, xn.AcroFormCheckBox = Nl, xn.AcroFormTextField = Bs, xn.AcroFormPasswordField = Cl, xn.AcroFormAppearance = he, xn.AcroForm = { ChoiceField: mo, ListBox: yo, ComboBox: bo, EditBox: kl, Button: Bn, PushButton: Al, RadioButton: vo, CheckBox: Nl, TextField: Bs, PasswordField: Cl, Appearance: he }, Se.AcroForm = { ChoiceField: mo, ListBox: yo, ComboBox: bo, EditBox: kl, Button: Bn, PushButton: Al, RadioButton: vo, CheckBox: Nl, TextField: Bs, PasswordField: Cl, Appearance: he };
var Iv = Se.AcroForm;
function F1(n) {
  return n.reduce(function(t, e, i) {
    return t[e] = i, t;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var t = "UNKNOWN", e = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = n.__addimage__.getImageFileTypeByImageData = function(N, S) {
    var T, x, X, V, D, tt = t;
    if ((S = S || t) === "RGBA" || N.data !== void 0 && N.data instanceof Uint8ClampedArray && "height" in N && "width" in N) return "RGBA";
    if (R(N)) for (D in e) for (X = e[D], T = 0; T < X.length; T += 1) {
      for (V = !0, x = 0; x < X[T].length; x += 1) if (X[T][x] !== void 0 && X[T][x] !== N[x]) {
        V = !1;
        break;
      }
      if (V === !0) {
        tt = D;
        break;
      }
    }
    else for (D in e) for (X = e[D], T = 0; T < X.length; T += 1) {
      for (V = !0, x = 0; x < X[T].length; x += 1) if (X[T][x] !== void 0 && X[T][x] !== N.charCodeAt(x)) {
        V = !1;
        break;
      }
      if (V === !0) {
        tt = D;
        break;
      }
    }
    return tt === t && S !== t && (tt = S), tt;
  }, r = function N(S) {
    for (var T = this.internal.write, x = this.internal.putStream, X = (0, this.internal.getFilters)(); X.indexOf("FlateEncode") !== -1; ) X.splice(X.indexOf("FlateEncode"), 1);
    S.objectId = this.internal.newObject();
    var V = [];
    if (V.push({ key: "Type", value: "/XObject" }), V.push({ key: "Subtype", value: "/Image" }), V.push({ key: "Width", value: S.width }), V.push({ key: "Height", value: S.height }), S.colorSpace === _.INDEXED ? V.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (S.palette.length / 3 - 1) + " " + ("sMask" in S && S.sMask !== void 0 ? S.objectId + 2 : S.objectId + 1) + " 0 R]" }) : (V.push({ key: "ColorSpace", value: "/" + S.colorSpace }), S.colorSpace === _.DEVICE_CMYK && V.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), V.push({ key: "BitsPerComponent", value: S.bitsPerComponent }), "decodeParameters" in S && S.decodeParameters !== void 0 && V.push({ key: "DecodeParms", value: "<<" + S.decodeParameters + ">>" }), "transparency" in S && Array.isArray(S.transparency)) {
      for (var D = "", tt = 0, H = S.transparency.length; tt < H; tt++) D += S.transparency[tt] + " " + S.transparency[tt] + " ";
      V.push({ key: "Mask", value: "[" + D + "]" });
    }
    S.sMask !== void 0 && V.push({ key: "SMask", value: S.objectId + 1 + " 0 R" });
    var ct = S.filter !== void 0 ? ["/" + S.filter] : void 0;
    if (x({ data: S.data, additionalKeyValues: V, alreadyAppliedFilters: ct, objectId: S.objectId }), T("endobj"), "sMask" in S && S.sMask !== void 0) {
      var it = "/Predictor " + S.predictor + " /Colors 1 /BitsPerComponent " + S.bitsPerComponent + " /Columns " + S.width, P = { width: S.width, height: S.height, colorSpace: "DeviceGray", bitsPerComponent: S.bitsPerComponent, decodeParameters: it, data: S.sMask };
      "filter" in S && (P.filter = S.filter), N.call(this, P);
    }
    if (S.colorSpace === _.INDEXED) {
      var z = this.internal.newObject();
      x({ data: E(new Uint8Array(S.palette)), objectId: z }), T("endobj");
    }
  }, s = function() {
    var N = this.internal.collections.addImage_images;
    for (var S in N) r.call(this, N[S]);
  }, o = function() {
    var N, S = this.internal.collections.addImage_images, T = this.internal.write;
    for (var x in S) T("/I" + (N = S[x]).index, N.objectId, "0", "R");
  }, a = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", o));
  }, l = function() {
    var N = this.internal.collections.addImage_images;
    return a.call(this), N;
  }, h = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, u = function(N) {
    return typeof n["process" + N.toUpperCase()] == "function";
  }, d = function(N) {
    return nn(N) === "object" && N.nodeType === 1;
  }, p = function(N, S) {
    if (N.nodeName === "IMG" && N.hasAttribute("src")) {
      var T = "" + N.getAttribute("src");
      if (T.indexOf("data:image/") === 0) return Sl(unescape(T).split("base64,").pop());
      var x = n.loadFile(T, !0);
      if (x !== void 0) return x;
    }
    if (N.nodeName === "CANVAS") {
      if (N.width === 0 || N.height === 0) throw new Error("Given canvas must have data. Canvas width: " + N.width + ", height: " + N.height);
      var X;
      switch (S) {
        case "PNG":
          X = "image/png";
          break;
        case "WEBP":
          X = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          X = "image/jpeg";
      }
      return Sl(N.toDataURL(X, 1).split("base64,").pop());
    }
  }, f = function(N) {
    var S = this.internal.collections.addImage_images;
    if (S) {
      for (var T in S) if (N === S[T].alias) return S[T];
    }
  }, g = function(N, S, T) {
    return N || S || (N = -96, S = -96), N < 0 && (N = -1 * T.width * 72 / N / this.internal.scaleFactor), S < 0 && (S = -1 * T.height * 72 / S / this.internal.scaleFactor), N === 0 && (N = S * T.width / T.height), S === 0 && (S = N * T.height / T.width), [N, S];
  }, y = function(N, S, T, x, X, V) {
    var D = g.call(this, T, x, X), tt = this.internal.getCoordinateString, H = this.internal.getVerticalCoordinateString, ct = l.call(this);
    if (T = D[0], x = D[1], ct[X.index] = X, V) {
      V *= Math.PI / 180;
      var it = Math.cos(V), P = Math.sin(V), z = function(Y) {
        return Y.toFixed(4);
      }, G = [z(it), z(P), z(-1 * P), z(it), 0, 0, "cm"];
    }
    this.internal.write("q"), V ? (this.internal.write([1, "0", "0", 1, tt(N), H(S + x), "cm"].join(" ")), this.internal.write(G.join(" ")), this.internal.write([tt(T), "0", "0", tt(x), "0", "0", "cm"].join(" "))) : this.internal.write([tt(T), "0", "0", tt(x), tt(N), H(S + x), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + X.index + " Do"), this.internal.write("Q");
  }, _ = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var b = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, v = n.__addimage__.sHashCode = function(N) {
    var S, T, x = 0;
    if (typeof N == "string") for (T = N.length, S = 0; S < T; S++) x = (x << 5) - x + N.charCodeAt(S), x |= 0;
    else if (R(N)) for (T = N.byteLength / 2, S = 0; S < T; S++) x = (x << 5) - x + N[S], x |= 0;
    return x;
  }, A = n.__addimage__.validateStringAsBase64 = function(N) {
    (N = N || "").toString().trim();
    var S = !0;
    return N.length === 0 && (S = !1), N.length % 4 != 0 && (S = !1), /^[A-Za-z0-9+/]+$/.test(N.substr(0, N.length - 2)) === !1 && (S = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(N.substr(-2)) === !1 && (S = !1), S;
  }, L = n.__addimage__.extractImageFromDataUrl = function(N) {
    var S = (N = N || "").split("base64,"), T = null;
    if (S.length === 2) {
      var x = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(S[0]);
      Array.isArray(x) && (T = { mimeType: x[1], charset: x[2], data: S[1] });
    }
    return T;
  }, O = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(N) {
    return O() && N instanceof ArrayBuffer;
  };
  var R = n.__addimage__.isArrayBufferView = function(N) {
    return O() && typeof Uint32Array < "u" && (N instanceof Int8Array || N instanceof Uint8Array || typeof Uint8ClampedArray < "u" && N instanceof Uint8ClampedArray || N instanceof Int16Array || N instanceof Uint16Array || N instanceof Int32Array || N instanceof Uint32Array || N instanceof Float32Array || N instanceof Float64Array);
  }, C = n.__addimage__.binaryStringToUint8Array = function(N) {
    for (var S = N.length, T = new Uint8Array(S), x = 0; x < S; x++) T[x] = N.charCodeAt(x);
    return T;
  }, E = n.__addimage__.arrayBufferToBinaryString = function(N) {
    for (var S = "", T = R(N) ? N : new Uint8Array(N), x = 0; x < T.length; x += 8192) S += String.fromCharCode.apply(null, T.subarray(x, x + 8192));
    return S;
  };
  n.addImage = function() {
    var N, S, T, x, X, V, D, tt, H;
    if (typeof arguments[1] == "number" ? (S = t, T = arguments[1], x = arguments[2], X = arguments[3], V = arguments[4], D = arguments[5], tt = arguments[6], H = arguments[7]) : (S = arguments[1], T = arguments[2], x = arguments[3], X = arguments[4], V = arguments[5], D = arguments[6], tt = arguments[7], H = arguments[8]), nn(N = arguments[0]) === "object" && !d(N) && "imageData" in N) {
      var ct = N;
      N = ct.imageData, S = ct.format || S || t, T = ct.x || T || 0, x = ct.y || x || 0, X = ct.w || ct.width || X, V = ct.h || ct.height || V, D = ct.alias || D, tt = ct.compression || tt, H = ct.rotation || ct.angle || H;
    }
    var it = this.internal.getFilters();
    if (tt === void 0 && it.indexOf("FlateEncode") !== -1 && (tt = "SLOW"), isNaN(T) || isNaN(x)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    a.call(this);
    var P = M.call(this, N, S, D, tt);
    return y.call(this, T, x, X, V, P, H), this;
  };
  var M = function(N, S, T, x) {
    var X, V, D;
    if (typeof N == "string" && i(N) === t) {
      N = unescape(N);
      var tt = q(N, !1);
      (tt !== "" || (tt = n.loadFile(N, !0)) !== void 0) && (N = tt);
    }
    if (d(N) && (N = p(N, S)), S = i(N, S), !u(S)) throw new Error("addImage does not support files of type '" + S + "', please ensure that a plugin for '" + S + "' support is added.");
    if (((D = T) == null || D.length === 0) && (T = function(H) {
      return typeof H == "string" || R(H) ? v(H) : R(H.data) ? v(H.data) : null;
    }(N)), (X = f.call(this, T)) || (O() && (N instanceof Uint8Array || S === "RGBA" || (V = N, N = C(N))), X = this["process" + S.toUpperCase()](N, h.call(this), T, function(H) {
      return H && typeof H == "string" && (H = H.toUpperCase()), H in n.image_compression ? H : b.NONE;
    }(x), V)), !X) throw new Error("An unknown error occurred whilst processing the image.");
    return X;
  }, q = n.__addimage__.convertBase64ToBinaryString = function(N, S) {
    var T;
    S = typeof S != "boolean" || S;
    var x, X = "";
    if (typeof N == "string") {
      x = (T = L(N)) !== null ? T.data : N;
      try {
        X = Sl(x);
      } catch (V) {
        if (S) throw A(x) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + V.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return X;
  };
  n.getImageProperties = function(N) {
    var S, T, x = "";
    if (d(N) && (N = p(N)), typeof N == "string" && i(N) === t && ((x = q(N, !1)) === "" && (x = n.loadFile(N) || ""), N = x), T = i(N), !u(T)) throw new Error("addImage does not support files of type '" + T + "', please ensure that a plugin for '" + T + "' support is added.");
    if (!O() || N instanceof Uint8Array || (N = C(N)), !(S = this["process" + T.toUpperCase()](N))) throw new Error("An unknown error occurred whilst processing the image");
    return S.fileType = T, S;
  };
})(Se.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    if (e !== void 0 && e != "") return !0;
  };
  Se.API.events.push(["addPage", function(e) {
    this.internal.getPageInfo(e.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(e) {
    for (var i, r, s, o = this.internal.getCoordinateString, a = this.internal.getVerticalCoordinateString, l = this.internal.getPageInfoByObjId(e.objId), h = e.pageContext.annotations, u = !1, d = 0; d < h.length && !u; d++) switch ((i = h[d]).type) {
      case "link":
        (t(i.options.url) || t(i.options.pageNumber)) && (u = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        u = !0;
    }
    if (u != 0) {
      this.internal.write("/Annots [");
      for (var p = 0; p < h.length; p++) {
        i = h[p];
        var f = this.internal.pdfEscape, g = this.internal.getEncryptor(e.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var y = this.internal.newAdditionalObject(), _ = this.internal.newAdditionalObject(), b = this.internal.getEncryptor(y.objId), v = i.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y) + "] ") + "/Contents (" + f(b(i.contents)) + ")", s += " /Popup " + _.objId + " 0 R", s += " /P " + l.objId + " 0 R", s += " /T (" + f(b(v)) + ") >>", y.content = s;
            var A = y.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + o(i.bounds.x + 30) + " " + a(i.bounds.y + i.bounds.h) + " " + o(i.bounds.x + i.bounds.w + 30) + " " + a(i.bounds.y) + "] ") + " /Parent " + A, i.open && (s += " /Open true"), s += " >>", _.content = s, this.internal.write(y.objId, "0 R", _.objId, "0 R");
            break;
          case "freetext":
            r = "/Rect [" + o(i.bounds.x) + " " + a(i.bounds.y) + " " + o(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y + i.bounds.h) + "] ";
            var L = i.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + f(g(i.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + L + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (i.options.name) {
              var O = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = O.page, i.options.top = O.y;
            } else i.options.top || (i.options.top = 0);
            if (r = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", s = "", i.options.url) s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + f(g(i.options.url)) + ") >>";
            else if (i.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + i.options.top + "]";
                  break;
                case "FitV":
                  i.options.left = i.options.left || 0, s += " /FitV " + i.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var R = a(i.options.top);
                  i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), s += " /XYZ " + i.options.left + " " + R + " " + i.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(e) {
    var i = this.internal.getCurrentPageInfo();
    switch (e.type) {
      case "link":
        this.link(e.bounds.x, e.bounds.y, e.bounds.w, e.bounds.h, e);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(e);
    }
  }, n.link = function(e, i, r, s, o) {
    var a = this.internal.getCurrentPageInfo(), l = this.internal.getCoordinateString, h = this.internal.getVerticalCoordinateString;
    a.pageContext.annotations.push({ finalBounds: { x: l(e), y: h(i), w: l(e + r), h: h(i + s) }, options: o, type: "link" });
  }, n.textWithLink = function(e, i, r, s) {
    var o, a, l = this.getTextWidth(e), h = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      a = s.maxWidth;
      var u = this.splitTextToSize(e, a).length;
      o = Math.ceil(h * u);
    } else a = l, o = h;
    return this.text(e, i, r, s), r += 0.2 * h, s.align === "center" && (i -= l / 2), s.align === "right" && (i -= l), this.link(i, r - h, a, o, s), l;
  }, n.getTextWidth = function(e) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(e) * i / this.internal.scaleFactor;
  };
}(Se.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, e = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, r = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var s = n.__arabicParser__.isInArabicSubstitutionA = function(y) {
    return t[y.charCodeAt(0)] !== void 0;
  }, o = n.__arabicParser__.isArabicLetter = function(y) {
    return typeof y == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(y);
  }, a = n.__arabicParser__.isArabicEndLetter = function(y) {
    return o(y) && s(y) && t[y.charCodeAt(0)].length <= 2;
  }, l = n.__arabicParser__.isArabicAlfLetter = function(y) {
    return o(y) && r.indexOf(y.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(y) {
    return o(y) && s(y) && t[y.charCodeAt(0)].length >= 1;
  };
  var h = n.__arabicParser__.arabicLetterHasFinalForm = function(y) {
    return o(y) && s(y) && t[y.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(y) {
    return o(y) && s(y) && t[y.charCodeAt(0)].length >= 3;
  };
  var u = n.__arabicParser__.arabicLetterHasMedialForm = function(y) {
    return o(y) && s(y) && t[y.charCodeAt(0)].length == 4;
  }, d = n.__arabicParser__.resolveLigatures = function(y) {
    var _ = 0, b = e, v = "", A = 0;
    for (_ = 0; _ < y.length; _ += 1) b[y.charCodeAt(_)] !== void 0 ? (A++, typeof (b = b[y.charCodeAt(_)]) == "number" && (v += String.fromCharCode(b), b = e, A = 0), _ === y.length - 1 && (b = e, v += y.charAt(_ - (A - 1)), _ -= A - 1, A = 0)) : (b = e, v += y.charAt(_ - A), _ -= A, A = 0);
    return v;
  };
  n.__arabicParser__.isArabicDiacritic = function(y) {
    return y !== void 0 && i[y.charCodeAt(0)] !== void 0;
  };
  var p = n.__arabicParser__.getCorrectForm = function(y, _, b) {
    return o(y) ? s(y) === !1 ? -1 : !h(y) || !o(_) && !o(b) || !o(b) && a(_) || a(y) && !o(_) || a(y) && l(_) || a(y) && a(_) ? 0 : u(y) && o(_) && !a(_) && o(b) && h(b) ? 3 : a(y) || !o(b) ? 1 : 2 : -1;
  }, f = function(y) {
    var _ = 0, b = 0, v = 0, A = "", L = "", O = "", R = (y = y || "").split("\\s+"), C = [];
    for (_ = 0; _ < R.length; _ += 1) {
      for (C.push(""), b = 0; b < R[_].length; b += 1) A = R[_][b], L = R[_][b - 1], O = R[_][b + 1], o(A) ? (v = p(A, L, O), C[_] += v !== -1 ? String.fromCharCode(t[A.charCodeAt(0)][v]) : A) : C[_] += A;
      C[_] = d(C[_]);
    }
    return C.join(" ");
  }, g = n.__arabicParser__.processArabic = n.processArabic = function() {
    var y, _ = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, b = [];
    if (Array.isArray(_)) {
      var v = 0;
      for (b = [], v = 0; v < _.length; v += 1) Array.isArray(_[v]) ? b.push([f(_[v][0]), _[v][1], _[v][2]]) : b.push([f(_[v])]);
      y = b;
    } else y = f(_);
    return typeof arguments[0] == "string" ? y : (arguments[0].text = y, arguments[0]);
  };
  n.events.push(["preProcessText", g]);
}(Se.API), Se.API.autoPrint = function(n) {
  var t;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        t = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + t + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    var e = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return e;
    }, set: function(a) {
      e = a;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(a) {
      i = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 150 : a, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(a) {
      r = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 300 : a, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(a) {
      s = a;
    } });
    var o = {};
    Object.defineProperty(this, "style", { get: function() {
      return o;
    }, set: function(a) {
      o = a;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  t.prototype.getContext = function(e, i) {
    var r;
    if ((e = e || "2d") !== "2d") return null;
    for (r in i) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = i[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, t.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new t(), this.canvas.pdf = this;
  }]);
}(Se.API), function(n) {
  var t = { left: 0, top: 0, bottom: 0, right: 0 }, e = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, t), this.internal.__cell__.margins.width = this.getPageWidth(), r.call(this));
  }, r = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var l = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return l;
    }, set: function(y) {
      l = y;
    } });
    var h = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return h;
    }, set: function(y) {
      h = y;
    } });
    var u = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return u;
    }, set: function(y) {
      u = y;
    } });
    var d = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return d;
    }, set: function(y) {
      d = y;
    } });
    var p = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return p;
    }, set: function(y) {
      p = y;
    } });
    var f = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return f;
    }, set: function(y) {
      f = y;
    } });
    var g = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return g;
    }, set: function(y) {
      g = y;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(l) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof l == "function" ? l : void 0, this;
  }, n.getTextDimensions = function(l, h) {
    i.call(this);
    var u = (h = h || {}).fontSize || this.getFontSize(), d = h.font || this.getFont(), p = h.scaleFactor || this.internal.scaleFactor, f = 0, g = 0, y = 0, _ = this;
    if (!Array.isArray(l) && typeof l != "string") {
      if (typeof l != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      l = String(l);
    }
    var b = h.maxWidth;
    b > 0 ? typeof l == "string" ? l = this.splitTextToSize(l, b) : Object.prototype.toString.call(l) === "[object Array]" && (l = l.reduce(function(A, L) {
      return A.concat(_.splitTextToSize(L, b));
    }, [])) : l = Array.isArray(l) ? l : [l];
    for (var v = 0; v < l.length; v++) f < (y = this.getStringUnitWidth(l[v], { font: d }) * u) && (f = y);
    return f !== 0 && (g = l.length), { w: f /= p, h: Math.max((g * u * this.getLineHeightFactor() - u * (this.getLineHeightFactor() - 1)) / p, 0) };
  }, n.cellAddPage = function() {
    i.call(this), this.addPage();
    var l = this.internal.__cell__.margins || t;
    return this.internal.__cell__.lastCell = new s(l.left, l.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var o = n.cell = function() {
    var l;
    l = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var h = this.internal.__cell__.lastCell, u = this.internal.__cell__.padding, d = this.internal.__cell__.margins || t, p = this.internal.__cell__.tableHeaderRow, f = this.internal.__cell__.printHeaders;
    return h.lineNumber !== void 0 && (h.lineNumber === l.lineNumber ? (l.x = (h.x || 0) + (h.width || 0), l.y = h.y || 0) : h.y + h.height + l.height + d.bottom > this.getPageHeight() ? (this.cellAddPage(), l.y = d.top, f && p && (this.printHeaderRow(l.lineNumber, !0), l.y += p[0].height)) : l.y = h.y + h.height || l.y), l.text[0] !== void 0 && (this.rect(l.x, l.y, l.width, l.height, e === !0 ? "FD" : void 0), l.align === "right" ? this.text(l.text, l.x + l.width - u, l.y + u, { align: "right", baseline: "top" }) : l.align === "center" ? this.text(l.text, l.x + l.width / 2, l.y + u, { align: "center", baseline: "top", maxWidth: l.width - u - u }) : this.text(l.text, l.x + u, l.y + u, { align: "left", baseline: "top", maxWidth: l.width - u - u })), this.internal.__cell__.lastCell = l, this;
  };
  n.table = function(l, h, u, d, p) {
    if (i.call(this), !u) throw new Error("No data for PDF table.");
    var f, g, y, _, b = [], v = [], A = [], L = {}, O = {}, R = [], C = [], E = (p = p || {}).autoSize || !1, M = p.printHeaders !== !1, q = p.css && p.css["font-size"] !== void 0 ? 16 * p.css["font-size"] : p.fontSize || 12, N = p.margins || Object.assign({ width: this.getPageWidth() }, t), S = typeof p.padding == "number" ? p.padding : 3, T = p.headerBackgroundColor || "#c8c8c8", x = p.headerTextColor || "#000";
    if (r.call(this), this.internal.__cell__.printHeaders = M, this.internal.__cell__.margins = N, this.internal.__cell__.table_font_size = q, this.internal.__cell__.padding = S, this.internal.__cell__.headerBackgroundColor = T, this.internal.__cell__.headerTextColor = x, this.setFontSize(q), d == null) v = b = Object.keys(u[0]), A = b.map(function() {
      return "left";
    });
    else if (Array.isArray(d) && nn(d[0]) === "object") for (b = d.map(function(ct) {
      return ct.name;
    }), v = d.map(function(ct) {
      return ct.prompt || ct.name || "";
    }), A = d.map(function(ct) {
      return ct.align || "left";
    }), f = 0; f < d.length; f += 1) O[d[f].name] = d[f].width * (19.049976 / 25.4);
    else Array.isArray(d) && typeof d[0] == "string" && (v = b = d, A = b.map(function() {
      return "left";
    }));
    if (E || Array.isArray(d) && typeof d[0] == "string") for (f = 0; f < b.length; f += 1) {
      for (L[_ = b[f]] = u.map(function(ct) {
        return ct[_];
      }), this.setFont(void 0, "bold"), R.push(this.getTextDimensions(v[f], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), g = L[_], this.setFont(void 0, "normal"), y = 0; y < g.length; y += 1) R.push(this.getTextDimensions(g[y], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      O[_] = Math.max.apply(null, R) + S + S, R = [];
    }
    if (M) {
      var X = {};
      for (f = 0; f < b.length; f += 1) X[b[f]] = {}, X[b[f]].text = v[f], X[b[f]].align = A[f];
      var V = a.call(this, X, O);
      C = b.map(function(ct) {
        return new s(l, h, O[ct], V, X[ct].text, void 0, X[ct].align);
      }), this.setTableHeaderRow(C), this.printHeaderRow(1, !1);
    }
    var D = d.reduce(function(ct, it) {
      return ct[it.name] = it.align, ct;
    }, {});
    for (f = 0; f < u.length; f += 1) {
      "rowStart" in p && p.rowStart instanceof Function && p.rowStart({ row: f, data: u[f] }, this);
      var tt = a.call(this, u[f], O);
      for (y = 0; y < b.length; y += 1) {
        var H = u[f][b[y]];
        "cellStart" in p && p.cellStart instanceof Function && p.cellStart({ row: f, col: y, data: H }, this), o.call(this, new s(l, h, O[b[y]], tt, H, f + 2, D[b[y]]));
      }
    }
    return this.internal.__cell__.table_x = l, this.internal.__cell__.table_y = h, this;
  };
  var a = function(l, h) {
    var u = this.internal.__cell__.padding, d = this.internal.__cell__.table_font_size, p = this.internal.scaleFactor;
    return Object.keys(l).map(function(f) {
      var g = l[f];
      return this.splitTextToSize(g.hasOwnProperty("text") ? g.text : g, h[f] - u - u);
    }, this).map(function(f) {
      return this.getLineHeightFactor() * f.length * d / p + u + u;
    }, this).reduce(function(f, g) {
      return Math.max(f, g);
    }, 0);
  };
  n.setTableHeaderRow = function(l) {
    i.call(this), this.internal.__cell__.tableHeaderRow = l;
  }, n.printHeaderRow = function(l, h) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var u;
    if (e = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var d = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(d[0], d[1], d[2], d[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var p = [], f = 0; f < this.internal.__cell__.tableHeaderRow.length; f += 1) {
      u = this.internal.__cell__.tableHeaderRow[f].clone(), h && (u.y = this.internal.__cell__.margins.top || 0, p.push(u)), u.lineNumber = l;
      var g = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), o.call(this, u), this.setTextColor(g);
    }
    p.length > 0 && this.setTableHeaderRow(p), this.setFont(void 0, "normal"), e = !1;
  };
}(Se.API);
var M1 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, R1 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], yf = F1(R1), D1 = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ev = F1(D1);
function bf(n) {
  var t = n.family.replace(/"|'/g, "").toLowerCase(), e = function(s) {
    return M1[s = s || "normal"] ? s : "normal";
  }(n.style), i = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), r = function(s) {
    return typeof yf[s = s || "normal"] == "number" ? s : "normal";
  }(n.stretch);
  return { family: t, style: e, weight: i, stretch: r, src: n.src || [], ref: n.ref || { name: t, style: [r, e, i].join(" ") } };
}
function Zp(n, t, e, i) {
  var r;
  for (r = e; r >= 0 && r < t.length; r += i) if (n[t[r]]) return n[t[r]];
  for (r = e; r >= 0 && r < t.length; r -= i) if (n[t[r]]) return n[t[r]];
}
var Ov = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Qp = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function tg(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function Tv(n, t, e) {
  for (var i = (e = e || {}).defaultFontFamily || "times", r = Object.assign({}, Ov, e.genericFontFamilies || {}), s = null, o = null, a = 0; a < t.length; ++a) if (r[(s = bf(t[a])).family] && (s.family = r[s.family]), n.hasOwnProperty(s.family)) {
    o = n[s.family];
    break;
  }
  if (!(o = o || n[i])) throw new Error("Could not find a font-family for the rule '" + tg(s) + "' and default family '" + i + "'.");
  if (o = function(l, h) {
    if (h[l]) return h[l];
    var u = yf[l], d = u <= yf.normal ? -1 : 1, p = Zp(h, R1, u, d);
    if (!p) throw new Error("Could not find a matching font-stretch value for " + l);
    return p;
  }(s.stretch, o), o = function(l, h) {
    if (h[l]) return h[l];
    for (var u = M1[l], d = 0; d < u.length; ++d) if (h[u[d]]) return h[u[d]];
    throw new Error("Could not find a matching font-style for " + l);
  }(s.style, o), !(o = function(l, h) {
    if (h[l]) return h[l];
    if (l === 400 && h[500]) return h[500];
    if (l === 500 && h[400]) return h[400];
    var u = Ev[l], d = Zp(h, D1, u, l < 400 ? -1 : 1);
    if (!d) throw new Error("Could not find a matching font-weight for value " + l);
    return d;
  }(s.weight, o))) throw new Error("Failed to resolve a font for the rule '" + tg(s) + "'.");
  return o;
}
function eg(n) {
  return n.trimLeft();
}
function Fv(n, t) {
  for (var e = 0; e < n.length; ) {
    if (n.charAt(e) === t) return [n.substring(0, e), n.substring(e + 1)];
    e += 1;
  }
  return null;
}
function Mv(n) {
  var t = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return t === null ? null : [t[0], n.substring(t[0].length)];
}
var Lu, ng, ig, Ih = ["times"];
(function(n) {
  var t, e, i, r, s, o, a, l, h, u = function(P) {
    return P = P || {}, this.isStrokeTransparent = P.isStrokeTransparent || !1, this.strokeOpacity = P.strokeOpacity || 1, this.strokeStyle = P.strokeStyle || "#000000", this.fillStyle = P.fillStyle || "#000000", this.isFillTransparent = P.isFillTransparent || !1, this.fillOpacity = P.fillOpacity || 1, this.font = P.font || "10px sans-serif", this.textBaseline = P.textBaseline || "alphabetic", this.textAlign = P.textAlign || "left", this.lineWidth = P.lineWidth || 1, this.lineJoin = P.lineJoin || "miter", this.lineCap = P.lineCap || "butt", this.path = P.path || [], this.transform = P.transform !== void 0 ? P.transform.clone() : new l(), this.globalCompositeOperation = P.globalCompositeOperation || "normal", this.globalAlpha = P.globalAlpha || 1, this.clip_path = P.clip_path || [], this.currentPoint = P.currentPoint || new o(), this.miterLimit = P.miterLimit || 10, this.lastPoint = P.lastPoint || new o(), this.lineDashOffset = P.lineDashOffset || 0, this.lineDash = P.lineDash || [], this.margin = P.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = P.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof P.ignoreClearRect != "boolean" || P.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new d(this), t = this.internal.f2, e = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, r = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, o = this.internal.Point, a = this.internal.Rectangle, l = this.internal.Matrix, h = new u();
  }]);
  var d = function(P) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var z = P;
    Object.defineProperty(this, "pdf", { get: function() {
      return z;
    } });
    var G = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return G;
    }, set: function(ht) {
      G = !!ht;
    } });
    var Y = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Y;
    }, set: function(ht) {
      Y = !!ht;
    } });
    var ot = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ot;
    }, set: function(ht) {
      isNaN(ht) || (ot = ht);
    } });
    var xt = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return xt;
    }, set: function(ht) {
      isNaN(ht) || (xt = ht);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return h.margin;
    }, set: function(ht) {
      var $;
      typeof ht == "number" ? $ = [ht, ht, ht, ht] : (($ = new Array(4))[0] = ht[0], $[1] = ht.length >= 2 ? ht[1] : $[0], $[2] = ht.length >= 3 ? ht[2] : $[0], $[3] = ht.length >= 4 ? ht[3] : $[1]), h.margin = $;
    } });
    var gt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return gt;
    }, set: function(ht) {
      gt = ht;
    } });
    var wt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return wt;
    }, set: function(ht) {
      wt = ht;
    } });
    var qt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return qt;
    }, set: function(ht) {
      qt = ht;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return h;
    }, set: function(ht) {
      ht instanceof u && (h = ht);
    } }), Object.defineProperty(this, "path", { get: function() {
      return h.path;
    }, set: function(ht) {
      h.path = ht;
    } });
    var Dt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Dt;
    }, set: function(ht) {
      Dt = ht;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ht) {
      var $;
      $ = p(ht), this.ctx.fillStyle = $.style, this.ctx.isFillTransparent = $.a === 0, this.ctx.fillOpacity = $.a, this.pdf.setFillColor($.r, $.g, $.b, { a: $.a }), this.pdf.setTextColor($.r, $.g, $.b, { a: $.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ht) {
      var $ = p(ht);
      this.ctx.strokeStyle = $.style, this.ctx.isStrokeTransparent = $.a === 0, this.ctx.strokeOpacity = $.a, $.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : ($.a, this.pdf.setDrawColor($.r, $.g, $.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ht) {
      ["butt", "round", "square"].indexOf(ht) !== -1 && (this.ctx.lineCap = ht, this.pdf.setLineCap(ht));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ht) {
      isNaN(ht) || (this.ctx.lineWidth = ht, this.pdf.setLineWidth(ht));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ht) {
      ["bevel", "round", "miter"].indexOf(ht) !== -1 && (this.ctx.lineJoin = ht, this.pdf.setLineJoin(ht));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ht) {
      isNaN(ht) || (this.ctx.miterLimit = ht, this.pdf.setMiterLimit(ht));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ht) {
      this.ctx.textBaseline = ht;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ht) {
      ["right", "end", "center", "left", "start"].indexOf(ht) !== -1 && (this.ctx.textAlign = ht);
    } });
    var Yt = null;
    function Xt(ht, $) {
      if (Yt === null) {
        var nt = function(J) {
          var st = [];
          return Object.keys(J).forEach(function(vt) {
            J[vt].forEach(function(St) {
              var ft = null;
              switch (St) {
                case "bold":
                  ft = { family: vt, weight: "bold" };
                  break;
                case "italic":
                  ft = { family: vt, style: "italic" };
                  break;
                case "bolditalic":
                  ft = { family: vt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  ft = { family: vt };
              }
              ft !== null && (ft.ref = { name: vt, style: St }, st.push(ft));
            });
          }), st;
        }(ht.getFontList());
        Yt = function(J) {
          for (var st = {}, vt = 0; vt < J.length; ++vt) {
            var St = bf(J[vt]), ft = St.family, Et = St.stretch, zt = St.style, Tt = St.weight;
            st[ft] = st[ft] || {}, st[ft][Et] = st[ft][Et] || {}, st[ft][Et][zt] = st[ft][Et][zt] || {}, st[ft][Et][zt][Tt] = St;
          }
          return st;
        }(nt.concat($));
      }
      return Yt;
    }
    var F = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return F;
    }, set: function(ht) {
      Yt = null, F = ht;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ht) {
      var $;
      if (this.ctx.font = ht, ($ = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ht)) !== null) {
        var nt = $[1], J = ($[2], $[3]), st = $[4], vt = ($[5], $[6]), St = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(st)[2];
        st = Math.floor(St === "px" ? parseFloat(st) * this.pdf.internal.scaleFactor : St === "em" ? parseFloat(st) * this.pdf.getFontSize() : parseFloat(st) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(st);
        var ft = function(ae) {
          var we, Jt, Nt = [], Ot = ae.trim();
          if (Ot === "") return Ih;
          if (Ot in Qp) return [Qp[Ot]];
          for (; Ot !== ""; ) {
            switch (Jt = null, we = (Ot = eg(Ot)).charAt(0)) {
              case '"':
              case "'":
                Jt = Fv(Ot.substring(1), we);
                break;
              default:
                Jt = Mv(Ot);
            }
            if (Jt === null || (Nt.push(Jt[0]), (Ot = eg(Jt[1])) !== "" && Ot.charAt(0) !== ",")) return Ih;
            Ot = Ot.replace(/^,/, "");
          }
          return Nt;
        }(vt);
        if (this.fontFaces) {
          var Et = Tv(Xt(this.pdf, this.fontFaces), ft.map(function(ae) {
            return { family: ae, stretch: "normal", weight: J, style: nt };
          }));
          this.pdf.setFont(Et.ref.name, Et.ref.style);
        } else {
          var zt = "";
          (J === "bold" || parseInt(J, 10) >= 700 || nt === "bold") && (zt = "bold"), nt === "italic" && (zt += "italic"), zt.length === 0 && (zt = "normal");
          for (var Tt = "", $t = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, ee = 0; ee < ft.length; ee++) {
            if (this.pdf.internal.getFont(ft[ee], zt, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Tt = ft[ee];
              break;
            }
            if (zt === "bolditalic" && this.pdf.internal.getFont(ft[ee], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Tt = ft[ee], zt = "bold";
            else if (this.pdf.internal.getFont(ft[ee], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Tt = ft[ee], zt = "normal";
              break;
            }
          }
          if (Tt === "") {
            for (var oe = 0; oe < ft.length; oe++) if ($t[ft[oe]]) {
              Tt = $t[ft[oe]];
              break;
            }
          }
          Tt = Tt === "" ? "Times" : Tt, this.pdf.setFont(Tt, zt);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ht) {
      this.ctx.globalCompositeOperation = ht;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ht) {
      this.ctx.globalAlpha = ht;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ht) {
      this.ctx.lineDashOffset = ht, it.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ht) {
      this.ctx.lineDash = ht, it.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ht) {
      this.ctx.ignoreClearRect = !!ht;
    } });
  };
  d.prototype.setLineDash = function(P) {
    this.lineDash = P;
  }, d.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, d.prototype.fill = function() {
    L.call(this, "fill", !1);
  }, d.prototype.stroke = function() {
    L.call(this, "stroke", !1);
  }, d.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, d.prototype.moveTo = function(P, z) {
    if (isNaN(P) || isNaN(z)) throw an.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var G = this.ctx.transform.applyToPoint(new o(P, z));
    this.path.push({ type: "mt", x: G.x, y: G.y }), this.ctx.lastPoint = new o(P, z);
  }, d.prototype.closePath = function() {
    var P = new o(0, 0), z = 0;
    for (z = this.path.length - 1; z !== -1; z--) if (this.path[z].type === "begin" && nn(this.path[z + 1]) === "object" && typeof this.path[z + 1].x == "number") {
      P = new o(this.path[z + 1].x, this.path[z + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new o(P.x, P.y);
  }, d.prototype.lineTo = function(P, z) {
    if (isNaN(P) || isNaN(z)) throw an.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var G = this.ctx.transform.applyToPoint(new o(P, z));
    this.path.push({ type: "lt", x: G.x, y: G.y }), this.ctx.lastPoint = new o(G.x, G.y);
  }, d.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), L.call(this, null, !0);
  }, d.prototype.quadraticCurveTo = function(P, z, G, Y) {
    if (isNaN(G) || isNaN(Y) || isNaN(P) || isNaN(z)) throw an.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ot = this.ctx.transform.applyToPoint(new o(G, Y)), xt = this.ctx.transform.applyToPoint(new o(P, z));
    this.path.push({ type: "qct", x1: xt.x, y1: xt.y, x: ot.x, y: ot.y }), this.ctx.lastPoint = new o(ot.x, ot.y);
  }, d.prototype.bezierCurveTo = function(P, z, G, Y, ot, xt) {
    if (isNaN(ot) || isNaN(xt) || isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var gt = this.ctx.transform.applyToPoint(new o(ot, xt)), wt = this.ctx.transform.applyToPoint(new o(P, z)), qt = this.ctx.transform.applyToPoint(new o(G, Y));
    this.path.push({ type: "bct", x1: wt.x, y1: wt.y, x2: qt.x, y2: qt.y, x: gt.x, y: gt.y }), this.ctx.lastPoint = new o(gt.x, gt.y);
  }, d.prototype.arc = function(P, z, G, Y, ot, xt) {
    if (isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y) || isNaN(ot)) throw an.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (xt = !!xt, !this.ctx.transform.isIdentity) {
      var gt = this.ctx.transform.applyToPoint(new o(P, z));
      P = gt.x, z = gt.y;
      var wt = this.ctx.transform.applyToPoint(new o(0, G)), qt = this.ctx.transform.applyToPoint(new o(0, 0));
      G = Math.sqrt(Math.pow(wt.x - qt.x, 2) + Math.pow(wt.y - qt.y, 2));
    }
    Math.abs(ot - Y) >= 2 * Math.PI && (Y = 0, ot = 2 * Math.PI), this.path.push({ type: "arc", x: P, y: z, radius: G, startAngle: Y, endAngle: ot, counterclockwise: xt });
  }, d.prototype.arcTo = function(P, z, G, Y, ot) {
    throw new Error("arcTo not implemented.");
  }, d.prototype.rect = function(P, z, G, Y) {
    if (isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(P, z), this.lineTo(P + G, z), this.lineTo(P + G, z + Y), this.lineTo(P, z + Y), this.lineTo(P, z), this.lineTo(P + G, z), this.lineTo(P, z);
  }, d.prototype.fillRect = function(P, z, G, Y) {
    if (isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!f.call(this)) {
      var ot = {};
      this.lineCap !== "butt" && (ot.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ot.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(P, z, G, Y), this.fill(), ot.hasOwnProperty("lineCap") && (this.lineCap = ot.lineCap), ot.hasOwnProperty("lineJoin") && (this.lineJoin = ot.lineJoin);
    }
  }, d.prototype.strokeRect = function(P, z, G, Y) {
    if (isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    g.call(this) || (this.beginPath(), this.rect(P, z, G, Y), this.stroke());
  }, d.prototype.clearRect = function(P, z, G, Y) {
    if (isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y)) throw an.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(P, z, G, Y));
  }, d.prototype.save = function(P) {
    P = typeof P != "boolean" || P;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(z), P) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Y = new u(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Y;
    }
  }, d.prototype.restore = function(P) {
    P = typeof P != "boolean" || P;
    for (var z = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(z), P && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, d.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var p = function(P) {
    var z, G, Y, ot;
    if (P.isCanvasGradient === !0 && (P = P.getColor()), !P) return { r: 0, g: 0, b: 0, a: 0, style: P };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(P)) z = 0, G = 0, Y = 0, ot = 0;
    else {
      var xt = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(P);
      if (xt !== null) z = parseInt(xt[1]), G = parseInt(xt[2]), Y = parseInt(xt[3]), ot = 1;
      else if ((xt = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(P)) !== null) z = parseInt(xt[1]), G = parseInt(xt[2]), Y = parseInt(xt[3]), ot = parseFloat(xt[4]);
      else {
        if (ot = 1, typeof P == "string" && P.charAt(0) !== "#") {
          var gt = new P1(P);
          P = gt.ok ? gt.toHex() : "#000000";
        }
        P.length === 4 ? (z = P.substring(1, 2), z += z, G = P.substring(2, 3), G += G, Y = P.substring(3, 4), Y += Y) : (z = P.substring(1, 3), G = P.substring(3, 5), Y = P.substring(5, 7)), z = parseInt(z, 16), G = parseInt(G, 16), Y = parseInt(Y, 16);
      }
    }
    return { r: z, g: G, b: Y, a: ot, style: P };
  }, f = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, g = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  d.prototype.fillText = function(P, z, G, Y) {
    if (isNaN(z) || isNaN(G) || typeof P != "string") throw an.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Y = isNaN(Y) ? void 0 : Y, !f.call(this)) {
      var ot = tt(this.ctx.transform.rotation), xt = this.ctx.transform.scaleX;
      S.call(this, { text: P, x: z, y: G, scale: xt, angle: ot, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.strokeText = function(P, z, G, Y) {
    if (isNaN(z) || isNaN(G) || typeof P != "string") throw an.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!g.call(this)) {
      Y = isNaN(Y) ? void 0 : Y;
      var ot = tt(this.ctx.transform.rotation), xt = this.ctx.transform.scaleX;
      S.call(this, { text: P, x: z, y: G, scale: xt, renderingMode: "stroke", angle: ot, align: this.textAlign, maxWidth: Y });
    }
  }, d.prototype.measureText = function(P) {
    if (typeof P != "string") throw an.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var z = this.pdf, G = this.pdf.internal.scaleFactor, Y = z.internal.getFontSize(), ot = z.getStringUnitWidth(P) * Y / z.internal.scaleFactor, xt = function(gt) {
      var wt = (gt = gt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return wt;
      } }), this;
    };
    return new xt({ width: ot *= Math.round(96 * G / 72 * 1e4) / 1e4 });
  }, d.prototype.scale = function(P, z) {
    if (isNaN(P) || isNaN(z)) throw an.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var G = new l(P, 0, 0, z, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, d.prototype.rotate = function(P) {
    if (isNaN(P)) throw an.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var z = new l(Math.cos(P), Math.sin(P), -Math.sin(P), Math.cos(P), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(z);
  }, d.prototype.translate = function(P, z) {
    if (isNaN(P) || isNaN(z)) throw an.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var G = new l(1, 0, 0, 1, P, z);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, d.prototype.transform = function(P, z, G, Y, ot, xt) {
    if (isNaN(P) || isNaN(z) || isNaN(G) || isNaN(Y) || isNaN(ot) || isNaN(xt)) throw an.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var gt = new l(P, z, G, Y, ot, xt);
    this.ctx.transform = this.ctx.transform.multiply(gt);
  }, d.prototype.setTransform = function(P, z, G, Y, ot, xt) {
    P = isNaN(P) ? 1 : P, z = isNaN(z) ? 0 : z, G = isNaN(G) ? 0 : G, Y = isNaN(Y) ? 1 : Y, ot = isNaN(ot) ? 0 : ot, xt = isNaN(xt) ? 0 : xt, this.ctx.transform = new l(P, z, G, Y, ot, xt);
  };
  var y = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  d.prototype.drawImage = function(P, z, G, Y, ot, xt, gt, wt, qt) {
    var Dt = this.pdf.getImageProperties(P), Yt = 1, Xt = 1, F = 1, ht = 1;
    Y !== void 0 && wt !== void 0 && (F = wt / Y, ht = qt / ot, Yt = Dt.width / Y * wt / Y, Xt = Dt.height / ot * qt / ot), xt === void 0 && (xt = z, gt = G, z = 0, G = 0), Y !== void 0 && wt === void 0 && (wt = Y, qt = ot), Y === void 0 && wt === void 0 && (wt = Dt.width, qt = Dt.height);
    for (var $, nt = this.ctx.transform.decompose(), J = tt(nt.rotate.shx), st = new l(), vt = (st = (st = (st = st.multiply(nt.translate)).multiply(nt.skew)).multiply(nt.scale)).applyToRectangle(new a(xt - z * F, gt - G * ht, Y * Yt, ot * Xt)), St = _.call(this, vt), ft = [], Et = 0; Et < St.length; Et += 1) ft.indexOf(St[Et]) === -1 && ft.push(St[Et]);
    if (A(ft), this.autoPaging) for (var zt = ft[0], Tt = ft[ft.length - 1], $t = zt; $t < Tt + 1; $t++) {
      this.pdf.setPage($t);
      var ee = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], oe = $t === 1 ? this.posY + this.margin[0] : this.margin[0], ae = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], we = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Jt = $t === 1 ? 0 : ae + ($t - 2) * we;
      if (this.ctx.clip_path.length !== 0) {
        var Nt = this.path;
        $ = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v($, this.posX + this.margin[3], -Jt + oe + this.ctx.prevPageLastElemOffset), O.call(this, "fill", !0), this.path = Nt;
      }
      var Ot = JSON.parse(JSON.stringify(vt));
      Ot = v([Ot], this.posX + this.margin[3], -Jt + oe + this.ctx.prevPageLastElemOffset)[0];
      var re = ($t > zt || $t < Tt) && y.call(this);
      re && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ee, we, null).clip().discardPath()), this.pdf.addImage(P, "JPEG", Ot.x, Ot.y, Ot.w, Ot.h, null, null, J), re && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(P, "JPEG", vt.x, vt.y, vt.w, vt.h, null, null, J);
  };
  var _ = function(P, z, G) {
    var Y = [];
    z = z || this.pdf.internal.pageSize.width, G = G || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ot = this.posY + this.ctx.prevPageLastElemOffset;
    switch (P.type) {
      default:
      case "mt":
      case "lt":
        Y.push(Math.floor((P.y + ot) / G) + 1);
        break;
      case "arc":
        Y.push(Math.floor((P.y + ot - P.radius) / G) + 1), Y.push(Math.floor((P.y + ot + P.radius) / G) + 1);
        break;
      case "qct":
        var xt = H(this.ctx.lastPoint.x, this.ctx.lastPoint.y, P.x1, P.y1, P.x, P.y);
        Y.push(Math.floor((xt.y + ot) / G) + 1), Y.push(Math.floor((xt.y + xt.h + ot) / G) + 1);
        break;
      case "bct":
        var gt = ct(this.ctx.lastPoint.x, this.ctx.lastPoint.y, P.x1, P.y1, P.x2, P.y2, P.x, P.y);
        Y.push(Math.floor((gt.y + ot) / G) + 1), Y.push(Math.floor((gt.y + gt.h + ot) / G) + 1);
        break;
      case "rect":
        Y.push(Math.floor((P.y + ot) / G) + 1), Y.push(Math.floor((P.y + P.h + ot) / G) + 1);
    }
    for (var wt = 0; wt < Y.length; wt += 1) for (; this.pdf.internal.getNumberOfPages() < Y[wt]; ) b.call(this);
    return Y;
  }, b = function() {
    var P = this.fillStyle, z = this.strokeStyle, G = this.font, Y = this.lineCap, ot = this.lineWidth, xt = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = P, this.strokeStyle = z, this.font = G, this.lineCap = Y, this.lineWidth = ot, this.lineJoin = xt;
  }, v = function(P, z, G) {
    for (var Y = 0; Y < P.length; Y++) switch (P[Y].type) {
      case "bct":
        P[Y].x2 += z, P[Y].y2 += G;
      case "qct":
        P[Y].x1 += z, P[Y].y1 += G;
      case "mt":
      case "lt":
      case "arc":
      default:
        P[Y].x += z, P[Y].y += G;
    }
    return P;
  }, A = function(P) {
    return P.sort(function(z, G) {
      return z - G;
    });
  }, L = function(P, z) {
    for (var G, Y, ot = this.fillStyle, xt = this.strokeStyle, gt = this.lineCap, wt = this.lineWidth, qt = Math.abs(wt * this.ctx.transform.scaleX), Dt = this.lineJoin, Yt = JSON.parse(JSON.stringify(this.path)), Xt = JSON.parse(JSON.stringify(this.path)), F = [], ht = 0; ht < Xt.length; ht++) if (Xt[ht].x !== void 0) for (var $ = _.call(this, Xt[ht]), nt = 0; nt < $.length; nt += 1) F.indexOf($[nt]) === -1 && F.push($[nt]);
    for (var J = 0; J < F.length; J++) for (; this.pdf.internal.getNumberOfPages() < F[J]; ) b.call(this);
    if (A(F), this.autoPaging) for (var st = F[0], vt = F[F.length - 1], St = st; St < vt + 1; St++) {
      this.pdf.setPage(St), this.fillStyle = ot, this.strokeStyle = xt, this.lineCap = gt, this.lineWidth = qt, this.lineJoin = Dt;
      var ft = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Et = St === 1 ? this.posY + this.margin[0] : this.margin[0], zt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Tt = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], $t = St === 1 ? 0 : zt + (St - 2) * Tt;
      if (this.ctx.clip_path.length !== 0) {
        var ee = this.path;
        G = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(G, this.posX + this.margin[3], -$t + Et + this.ctx.prevPageLastElemOffset), O.call(this, P, !0), this.path = ee;
      }
      if (Y = JSON.parse(JSON.stringify(Yt)), this.path = v(Y, this.posX + this.margin[3], -$t + Et + this.ctx.prevPageLastElemOffset), z === !1 || St === 0) {
        var oe = (St > st || St < vt) && y.call(this);
        oe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ft, Tt, null).clip().discardPath()), O.call(this, P, z), oe && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = wt;
    }
    else this.lineWidth = qt, O.call(this, P, z), this.lineWidth = wt;
    this.path = Yt;
  }, O = function(P, z) {
    if ((P !== "stroke" || z || !g.call(this)) && (P === "stroke" || z || !f.call(this))) {
      for (var G, Y, ot = [], xt = this.path, gt = 0; gt < xt.length; gt++) {
        var wt = xt[gt];
        switch (wt.type) {
          case "begin":
            ot.push({ begin: !0 });
            break;
          case "close":
            ot.push({ close: !0 });
            break;
          case "mt":
            ot.push({ start: wt, deltas: [], abs: [] });
            break;
          case "lt":
            var qt = ot.length;
            if (xt[gt - 1] && !isNaN(xt[gt - 1].x) && (G = [wt.x - xt[gt - 1].x, wt.y - xt[gt - 1].y], qt > 0)) {
              for (; qt >= 0; qt--) if (ot[qt - 1].close !== !0 && ot[qt - 1].begin !== !0) {
                ot[qt - 1].deltas.push(G), ot[qt - 1].abs.push(wt);
                break;
              }
            }
            break;
          case "bct":
            G = [wt.x1 - xt[gt - 1].x, wt.y1 - xt[gt - 1].y, wt.x2 - xt[gt - 1].x, wt.y2 - xt[gt - 1].y, wt.x - xt[gt - 1].x, wt.y - xt[gt - 1].y], ot[ot.length - 1].deltas.push(G);
            break;
          case "qct":
            var Dt = xt[gt - 1].x + 2 / 3 * (wt.x1 - xt[gt - 1].x), Yt = xt[gt - 1].y + 2 / 3 * (wt.y1 - xt[gt - 1].y), Xt = wt.x + 2 / 3 * (wt.x1 - wt.x), F = wt.y + 2 / 3 * (wt.y1 - wt.y), ht = wt.x, $ = wt.y;
            G = [Dt - xt[gt - 1].x, Yt - xt[gt - 1].y, Xt - xt[gt - 1].x, F - xt[gt - 1].y, ht - xt[gt - 1].x, $ - xt[gt - 1].y], ot[ot.length - 1].deltas.push(G);
            break;
          case "arc":
            ot.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ot[ot.length - 1].abs) && ot[ot.length - 1].abs.push(wt);
        }
      }
      Y = z ? null : P === "stroke" ? "stroke" : "fill";
      for (var nt = !1, J = 0; J < ot.length; J++) if (ot[J].arc) for (var st = ot[J].abs, vt = 0; vt < st.length; vt++) {
        var St = st[vt];
        St.type === "arc" ? E.call(this, St.x, St.y, St.radius, St.startAngle, St.endAngle, St.counterclockwise, void 0, z, !nt) : T.call(this, St.x, St.y), nt = !0;
      }
      else if (ot[J].close === !0) this.pdf.internal.out("h"), nt = !1;
      else if (ot[J].begin !== !0) {
        var ft = ot[J].start.x, Et = ot[J].start.y;
        x.call(this, ot[J].deltas, ft, Et), nt = !0;
      }
      Y && M.call(this, Y), z && q.call(this);
    }
  }, R = function(P) {
    var z = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, G = z * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return P - G;
      case "top":
        return P + z - G;
      case "hanging":
        return P + z - 2 * G;
      case "middle":
        return P + z / 2 - G;
      case "ideographic":
        return P;
      case "alphabetic":
      default:
        return P;
    }
  }, C = function(P) {
    return P + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  d.prototype.createLinearGradient = function() {
    var P = function() {
    };
    return P.colorStops = [], P.addColorStop = function(z, G) {
      this.colorStops.push([z, G]);
    }, P.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, P.isCanvasGradient = !0, P;
  }, d.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, d.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var E = function(P, z, G, Y, ot, xt, gt, wt, qt) {
    for (var Dt = V.call(this, G, Y, ot, xt), Yt = 0; Yt < Dt.length; Yt++) {
      var Xt = Dt[Yt];
      Yt === 0 && (qt ? N.call(this, Xt.x1 + P, Xt.y1 + z) : T.call(this, Xt.x1 + P, Xt.y1 + z)), X.call(this, P, z, Xt.x2, Xt.y2, Xt.x3, Xt.y3, Xt.x4, Xt.y4);
    }
    wt ? q.call(this) : M.call(this, gt);
  }, M = function(P) {
    switch (P) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, q = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, N = function(P, z) {
    this.pdf.internal.out(e(P) + " " + i(z) + " m");
  }, S = function(P) {
    var z;
    switch (P.align) {
      case "right":
      case "end":
        z = "right";
        break;
      case "center":
        z = "center";
        break;
      case "left":
      case "start":
      default:
        z = "left";
    }
    var G = this.pdf.getTextDimensions(P.text), Y = R.call(this, P.y), ot = C.call(this, Y) - G.h, xt = this.ctx.transform.applyToPoint(new o(P.x, Y)), gt = this.ctx.transform.decompose(), wt = new l();
    wt = (wt = (wt = wt.multiply(gt.translate)).multiply(gt.skew)).multiply(gt.scale);
    for (var qt, Dt, Yt, Xt = this.ctx.transform.applyToRectangle(new a(P.x, Y, G.w, G.h)), F = wt.applyToRectangle(new a(P.x, ot, G.w, G.h)), ht = _.call(this, F), $ = [], nt = 0; nt < ht.length; nt += 1) $.indexOf(ht[nt]) === -1 && $.push(ht[nt]);
    if (A($), this.autoPaging) for (var J = $[0], st = $[$.length - 1], vt = J; vt < st + 1; vt++) {
      this.pdf.setPage(vt);
      var St = vt === 1 ? this.posY + this.margin[0] : this.margin[0], ft = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Et = this.pdf.internal.pageSize.height - this.margin[2], zt = Et - this.margin[0], Tt = this.pdf.internal.pageSize.width - this.margin[1], $t = Tt - this.margin[3], ee = vt === 1 ? 0 : ft + (vt - 2) * zt;
      if (this.ctx.clip_path.length !== 0) {
        var oe = this.path;
        qt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = v(qt, this.posX + this.margin[3], -1 * ee + St), O.call(this, "fill", !0), this.path = oe;
      }
      var ae = v([JSON.parse(JSON.stringify(F))], this.posX + this.margin[3], -ee + St + this.ctx.prevPageLastElemOffset)[0];
      P.scale >= 0.01 && (Dt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Dt * P.scale), Yt = this.lineWidth, this.lineWidth = Yt * P.scale);
      var we = this.autoPaging !== "text";
      if (we || ae.y + ae.h <= Et) {
        if (we || ae.y >= St && ae.x <= Tt) {
          var Jt = we ? P.text : this.pdf.splitTextToSize(P.text, P.maxWidth || Tt - ae.x)[0], Nt = v([JSON.parse(JSON.stringify(Xt))], this.posX + this.margin[3], -ee + St + this.ctx.prevPageLastElemOffset)[0], Ot = we && (vt > J || vt < st) && y.call(this);
          Ot && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], $t, zt, null).clip().discardPath()), this.pdf.text(Jt, Nt.x, Nt.y, { angle: P.angle, align: z, renderingMode: P.renderingMode }), Ot && this.pdf.restoreGraphicsState();
        }
      } else ae.y < Et && (this.ctx.prevPageLastElemOffset += Et - ae.y);
      P.scale >= 0.01 && (this.pdf.setFontSize(Dt), this.lineWidth = Yt);
    }
    else P.scale >= 0.01 && (Dt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Dt * P.scale), Yt = this.lineWidth, this.lineWidth = Yt * P.scale), this.pdf.text(P.text, xt.x + this.posX, xt.y + this.posY, { angle: P.angle, align: z, renderingMode: P.renderingMode, maxWidth: P.maxWidth }), P.scale >= 0.01 && (this.pdf.setFontSize(Dt), this.lineWidth = Yt);
  }, T = function(P, z, G, Y) {
    G = G || 0, Y = Y || 0, this.pdf.internal.out(e(P + G) + " " + i(z + Y) + " l");
  }, x = function(P, z, G) {
    return this.pdf.lines(P, z, G, null, null);
  }, X = function(P, z, G, Y, ot, xt, gt, wt) {
    this.pdf.internal.out([t(r(G + P)), t(s(Y + z)), t(r(ot + P)), t(s(xt + z)), t(r(gt + P)), t(s(wt + z)), "c"].join(" "));
  }, V = function(P, z, G, Y) {
    for (var ot = 2 * Math.PI, xt = Math.PI / 2; z > G; ) z -= ot;
    var gt = Math.abs(G - z);
    gt < ot && Y && (gt = ot - gt);
    for (var wt = [], qt = Y ? -1 : 1, Dt = z; gt > 1e-5; ) {
      var Yt = Dt + qt * Math.min(gt, xt);
      wt.push(D.call(this, P, Dt, Yt)), gt -= Math.abs(Yt - Dt), Dt = Yt;
    }
    return wt;
  }, D = function(P, z, G) {
    var Y = (G - z) / 2, ot = P * Math.cos(Y), xt = P * Math.sin(Y), gt = ot, wt = -xt, qt = gt * gt + wt * wt, Dt = qt + gt * ot + wt * xt, Yt = 4 / 3 * (Math.sqrt(2 * qt * Dt) - Dt) / (gt * xt - wt * ot), Xt = gt - Yt * wt, F = wt + Yt * gt, ht = Xt, $ = -F, nt = Y + z, J = Math.cos(nt), st = Math.sin(nt);
    return { x1: P * Math.cos(z), y1: P * Math.sin(z), x2: Xt * J - F * st, y2: Xt * st + F * J, x3: ht * J - $ * st, y3: ht * st + $ * J, x4: P * Math.cos(G), y4: P * Math.sin(G) };
  }, tt = function(P) {
    return 180 * P / Math.PI;
  }, H = function(P, z, G, Y, ot, xt) {
    var gt = P + 0.5 * (G - P), wt = z + 0.5 * (Y - z), qt = ot + 0.5 * (G - ot), Dt = xt + 0.5 * (Y - xt), Yt = Math.min(P, ot, gt, qt), Xt = Math.max(P, ot, gt, qt), F = Math.min(z, xt, wt, Dt), ht = Math.max(z, xt, wt, Dt);
    return new a(Yt, F, Xt - Yt, ht - F);
  }, ct = function(P, z, G, Y, ot, xt, gt, wt) {
    var qt, Dt, Yt, Xt, F, ht, $, nt, J, st, vt, St, ft, Et, zt = G - P, Tt = Y - z, $t = ot - G, ee = xt - Y, oe = gt - ot, ae = wt - xt;
    for (Dt = 0; Dt < 41; Dt++) J = ($ = (Yt = P + (qt = Dt / 40) * zt) + qt * ((F = G + qt * $t) - Yt)) + qt * (F + qt * (ot + qt * oe - F) - $), st = (nt = (Xt = z + qt * Tt) + qt * ((ht = Y + qt * ee) - Xt)) + qt * (ht + qt * (xt + qt * ae - ht) - nt), Dt == 0 ? (vt = J, St = st, ft = J, Et = st) : (vt = Math.min(vt, J), St = Math.min(St, st), ft = Math.max(ft, J), Et = Math.max(Et, st));
    return new a(Math.round(vt), Math.round(St), Math.round(ft - vt), Math.round(Et - St));
  }, it = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var P, z, G = (P = this.ctx.lineDash, z = this.ctx.lineDashOffset, JSON.stringify({ lineDash: P, lineDashOffset: z }));
      this.prevLineDash !== G && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = G);
    }
  };
})(Se.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(s) {
    var o, a, l, h, u, d, p, f, g, y;
    for (a = [], l = 0, h = (s += o = "\0\0\0\0".slice(s.length % 4 || 4)).length; h > l; l += 4) (u = (s.charCodeAt(l) << 24) + (s.charCodeAt(l + 1) << 16) + (s.charCodeAt(l + 2) << 8) + s.charCodeAt(l + 3)) !== 0 ? (d = (u = ((u = ((u = ((u = (u - (y = u % 85)) / 85) - (g = u % 85)) / 85) - (f = u % 85)) / 85) - (p = u % 85)) / 85) % 85, a.push(d + 33, p + 33, f + 33, g + 33, y + 33)) : a.push(122);
    return function(_, b) {
      for (var v = b; v > 0; v--) _.pop();
    }(a, o.length), String.fromCharCode.apply(String, a) + "~>";
  }, e = function(s) {
    var o, a, l, h, u, d = String, p = "length", f = 255, g = "charCodeAt", y = "slice", _ = "replace";
    for (s[y](-2), s = s[y](0, -2)[_](/\s/g, "")[_]("z", "!!!!!"), l = [], h = 0, u = (s += o = "uuuuu"[y](s[p] % 5 || 5))[p]; u > h; h += 5) a = 52200625 * (s[g](h) - 33) + 614125 * (s[g](h + 1) - 33) + 7225 * (s[g](h + 2) - 33) + 85 * (s[g](h + 3) - 33) + (s[g](h + 4) - 33), l.push(f & a >> 24, f & a >> 16, f & a >> 8, f & a);
    return function(b, v) {
      for (var A = v; A > 0; A--) b.pop();
    }(l, o[p]), d.fromCharCode.apply(d, l);
  }, i = function(s) {
    var o = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), o.test(s) === !1) return "";
    for (var a = "", l = 0; l < s.length; l += 2) a += String.fromCharCode("0x" + (s[l] + s[l + 1]));
    return a;
  }, r = function(s) {
    for (var o = new Uint8Array(s.length), a = s.length; a--; ) o[a] = s.charCodeAt(a);
    return s = (o = ff(o)).reduce(function(l, h) {
      return l + String.fromCharCode(h);
    }, "");
  };
  n.processDataByFilters = function(s, o) {
    var a = 0, l = s || "", h = [];
    for (typeof (o = o || []) == "string" && (o = [o]), a = 0; a < o.length; a += 1) switch (o[a]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        l = e(l), h.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        l = t(l), h.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        l = i(l), h.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        l = l.split("").map(function(u) {
          return ("0" + u.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", h.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        l = r(l), h.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + o[a] + '" is not implemented');
    }
    return { data: l, reverseChain: h.reverse().join(" ") };
  };
}(Se.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.loadFile = function(t, e, i) {
    return function(r, s, o) {
      s = s !== !1, o = typeof o == "function" ? o : function() {
      };
      var a = void 0;
      try {
        a = function(l, h, u) {
          var d = new XMLHttpRequest(), p = 0, f = function(g) {
            var y = g.length, _ = [], b = String.fromCharCode;
            for (p = 0; p < y; p += 1) _.push(b(255 & g.charCodeAt(p)));
            return _.join("");
          };
          if (d.open("GET", l, !h), d.overrideMimeType("text/plain; charset=x-user-defined"), h === !1 && (d.onload = function() {
            d.status === 200 ? u(f(this.responseText)) : u(void 0);
          }), d.send(null), h && d.status === 200) return f(d.responseText);
        }(r, s, o);
      } catch {
      }
      return a;
    }(t, e, i);
  }, n.loadImageFile = n.loadFile;
}(Se.API), function(n) {
  function t() {
    return (Ae.html2canvas ? Promise.resolve(Ae.html2canvas) : import("./html2canvas.esm-d2sM-0Wm.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load html2canvas: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  function e() {
    return (Ae.DOMPurify ? Promise.resolve(Ae.DOMPurify) : import("./purify.es-DD-6ZaCo.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load dompurify: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  var i = function(o) {
    var a = nn(o);
    return a === "undefined" ? "undefined" : a === "string" || o instanceof String ? "string" : a === "number" || o instanceof Number ? "number" : a === "function" || o instanceof Function ? "function" : o && o.constructor === Array ? "array" : o && o.nodeType === 1 ? "element" : a === "object" ? "object" : "unknown";
  }, r = function(o, a) {
    var l = document.createElement(o);
    for (var h in a.className && (l.className = a.className), a.innerHTML && a.dompurify && (l.innerHTML = a.dompurify.sanitize(a.innerHTML)), a.style) l.style[h] = a.style[h];
    return l;
  }, s = function o(a) {
    var l = Object.assign(o.convert(Promise.resolve()), JSON.parse(JSON.stringify(o.template))), h = o.convert(Promise.resolve(), l);
    return h = (h = h.setProgress(1, o, 1, [o])).set(a);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(o, a) {
    return o.__proto__ = a || s.prototype, o;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(o, a) {
    return this.then(function() {
      switch (a = a || function(l) {
        switch (i(l)) {
          case "string":
            return "string";
          case "element":
            return l.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(o)) {
        case "string":
          return this.then(e).then(function(l) {
            return this.set({ src: r("div", { innerHTML: o, dompurify: l }) });
          });
        case "element":
          return this.set({ src: o });
        case "canvas":
          return this.set({ canvas: o });
        case "img":
          return this.set({ img: o });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(o) {
    switch (o) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var o = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, a = function l(h, u) {
        for (var d = h.nodeType === 3 ? document.createTextNode(h.nodeValue) : h.cloneNode(!1), p = h.firstChild; p; p = p.nextSibling) u !== !0 && p.nodeType === 1 && p.nodeName === "SCRIPT" || d.appendChild(l(p, u));
        return h.nodeType === 1 && (h.nodeName === "CANVAS" ? (d.width = h.width, d.height = h.height, d.getContext("2d").drawImage(h, 0, 0)) : h.nodeName !== "TEXTAREA" && h.nodeName !== "SELECT" || (d.value = h.value), d.addEventListener("load", function() {
          d.scrollTop = h.scrollTop, d.scrollLeft = h.scrollLeft;
        }, !0)), d;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      a.tagName === "BODY" && (o.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = r("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = r("div", { className: "html2pdf__container", style: o }), this.prop.container.appendChild(a), this.prop.container.firstChild.appendChild(r("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = Object.assign({}, this.opt.html2canvas);
      return delete l.onrendered, a(this.prop.container, l);
    }).then(function(a) {
      (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(a) {
      var l = this.opt.jsPDF, h = this.opt.fontFaces, u = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, d = Object.assign({ async: !0, allowTaint: !0, scale: u, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete d.onrendered, l.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, l.context2d.posX = this.opt.x, l.context2d.posY = this.opt.y, l.context2d.margin = this.opt.margin, l.context2d.fontFaces = h, h) for (var p = 0; p < h.length; ++p) {
        var f = h[p], g = f.src.find(function(y) {
          return y.format === "truetype";
        });
        g && l.addFont(g.url, f.ref.name, f.ref.style);
      }
      return d.windowHeight = d.windowHeight || 0, d.windowHeight = d.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : d.windowHeight, l.context2d.save(!0), a(this.prop.container, d);
    }).then(function(a) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var o = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = o;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(o, a, l) {
    return (l = l || "pdf").toLowerCase() === "img" || l.toLowerCase() === "image" ? this.outputImg(o, a) : this.outputPdf(o, a);
  }, s.prototype.outputPdf = function(o, a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(o, a);
    });
  }, s.prototype.outputImg = function(o) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (o) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + o + '" is not supported.';
      }
    });
  }, s.prototype.save = function(o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(o ? { filename: o } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(o) {
    if (i(o) !== "object") return this;
    var a = Object.keys(o || {}).map(function(l) {
      if (l in s.template.prop) return function() {
        this.prop[l] = o[l];
      };
      switch (l) {
        case "margin":
          return this.setMargin.bind(this, o.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = o.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, o.pageSize);
        default:
          return function() {
            this.opt[l] = o[l];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(a);
    });
  }, s.prototype.get = function(o, a) {
    return this.then(function() {
      var l = o in s.template.prop ? this.prop[o] : this.opt[o];
      return a ? a(l) : l;
    });
  }, s.prototype.setMargin = function(o) {
    return this.then(function() {
      switch (i(o)) {
        case "number":
          o = [o, o, o, o];
        case "array":
          if (o.length === 2 && (o = [o[0], o[1], o[0], o[1]]), o.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = o;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(o) {
    function a(l, h) {
      return Math.floor(l * h / 72 * 96);
    }
    return this.then(function() {
      (o = o || Se.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (o.inner = { width: o.width - this.opt.margin[1] - this.opt.margin[3], height: o.height - this.opt.margin[0] - this.opt.margin[2] }, o.inner.px = { width: a(o.inner.width, o.k), height: a(o.inner.height, o.k) }, o.inner.ratio = o.inner.height / o.inner.width), this.prop.pageSize = o;
    });
  }, s.prototype.setProgress = function(o, a, l, h) {
    return o != null && (this.progress.val = o), a != null && (this.progress.state = a), l != null && (this.progress.n = l), h != null && (this.progress.stack = h), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(o, a, l, h) {
    return this.setProgress(o ? this.progress.val + o : null, a || null, l ? this.progress.n + l : null, h ? this.progress.stack.concat(h) : null);
  }, s.prototype.then = function(o, a) {
    var l = this;
    return this.thenCore(o, a, function(h, u) {
      return l.updateProgress(null, null, 1, [h]), Promise.prototype.then.call(this, function(d) {
        return l.updateProgress(null, h), d;
      }).then(h, u).then(function(d) {
        return l.updateProgress(1), d;
      });
    });
  }, s.prototype.thenCore = function(o, a, l) {
    l = l || Promise.prototype.then, o && (o = o.bind(this)), a && (a = a.bind(this));
    var h = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), u = l.call(h, o, a);
    return s.convert(u, this.__proto__);
  }, s.prototype.thenExternal = function(o, a) {
    return Promise.prototype.then.call(this, o, a);
  }, s.prototype.thenList = function(o) {
    var a = this;
    return o.forEach(function(l) {
      a = a.thenCore(l);
    }), a;
  }, s.prototype.catch = function(o) {
    o && (o = o.bind(this));
    var a = Promise.prototype.catch.call(this, o);
    return s.convert(a, this);
  }, s.prototype.catchExternal = function(o) {
    return Promise.prototype.catch.call(this, o);
  }, s.prototype.error = function(o) {
    return this.then(function() {
      throw new Error(o);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Se.getPageSize = function(o, a, l) {
    if (nn(o) === "object") {
      var h = o;
      o = h.orientation, a = h.unit || a, l = h.format || l;
    }
    a = a || "mm", l = l || "a4", o = ("" + (o || "P")).toLowerCase();
    var u, d = ("" + l).toLowerCase(), p = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (a) {
      case "pt":
        u = 1;
        break;
      case "mm":
        u = 72 / 25.4;
        break;
      case "cm":
        u = 72 / 2.54;
        break;
      case "in":
        u = 72;
        break;
      case "px":
        u = 0.75;
        break;
      case "pc":
      case "em":
        u = 12;
        break;
      case "ex":
        u = 6;
        break;
      default:
        throw "Invalid unit: " + a;
    }
    var f, g = 0, y = 0;
    if (p.hasOwnProperty(d)) g = p[d][1] / u, y = p[d][0] / u;
    else try {
      g = l[1], y = l[0];
    } catch {
      throw new Error("Invalid format: " + l);
    }
    if (o === "p" || o === "portrait") o = "p", y > g && (f = y, y = g, g = f);
    else {
      if (o !== "l" && o !== "landscape") throw "Invalid orientation: " + o;
      o = "l", g > y && (f = y, y = g, g = f);
    }
    return { width: y, height: g, unit: a, k: u, orientation: o };
  }, n.html = function(o, a) {
    (a = a || {}).callback = a.callback || function() {
    }, a.html2canvas = a.html2canvas || {}, a.html2canvas.canvas = a.html2canvas.canvas || this.canvas, a.jsPDF = a.jsPDF || this, a.fontFaces = a.fontFaces ? a.fontFaces.map(bf) : null;
    var l = new s(a);
    return a.worker ? l : l.from(o).doCallback();
  };
}(Se.API), Se.API.addJS = function(n) {
  return ig = n, this.internal.events.subscribe("postPutResources", function() {
    Lu = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Lu + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), ng = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + ig + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Lu !== void 0 && ng !== void 0 && this.internal.out("/Names <</JavaScript " + Lu + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t;
  n.events.push(["postPutResources", function() {
    var e = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var r = e.outline.render().split(/\r\n/), s = 0; s < r.length; s++) {
      var o = r[s], a = i.exec(o);
      if (a != null) {
        var l = a[1];
        e.internal.newObjectDeferredBegin(l, !1);
      }
      e.internal.write(o);
    }
    if (this.outline.createNamedDestinations) {
      var h = this.internal.pages.length, u = [];
      for (s = 0; s < h; s++) {
        var d = e.internal.newObject();
        u.push(d);
        var p = e.internal.getPageInfo(s + 1);
        e.internal.write("<< /D[" + p.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f = e.internal.newObject();
      for (e.internal.write("<< /Names [ "), s = 0; s < u.length; s++) e.internal.write("(page_" + (s + 1) + ")" + u[s] + " 0 R");
      e.internal.write(" ] >>", "endobj"), t = e.internal.newObject(), e.internal.write("<< /Dests " + f + " 0 R"), e.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + t + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var e = this;
    e.outline = { createNamedDestinations: !1, root: { children: [] } }, e.outline.add = function(i, r, s) {
      var o = { title: r, options: s, children: [] };
      return i == null && (i = this.root), i.children.push(o), o;
    }, e.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = e, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, e.outline.genIds_r = function(i) {
      i.id = e.internal.newObjectDeferred();
      for (var r = 0; r < i.children.length; r++) this.genIds_r(i.children[r]);
    }, e.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, e.outline.renderItems = function(i) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < i.children.length; s++) {
        var o = i.children[s];
        this.objStart(o), this.line("/Title " + this.makeString(o.title)), this.line("/Parent " + this.makeRef(i)), s > 0 && this.line("/Prev " + this.makeRef(i.children[s - 1])), s < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[s + 1])), o.children.length > 0 && (this.line("/First " + this.makeRef(o.children[0])), this.line("/Last " + this.makeRef(o.children[o.children.length - 1])));
        var a = this.count = this.count_r({ count: 0 }, o);
        if (a > 0 && this.line("/Count " + a), o.options && o.options.pageNumber) {
          var l = e.internal.getPageInfo(o.options.pageNumber);
          this.line("/Dest [" + l.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var h = 0; h < i.children.length; h++) this.renderItems(i.children[h]);
    }, e.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, e.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, e.outline.makeString = function(i) {
      return "(" + e.internal.pdfEscape(i) + ")";
    }, e.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, e.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, e.outline.count_r = function(i, r) {
      for (var s = 0; s < r.children.length; s++) i.count++, this.count_r(i, r.children[s]);
      return i.count;
    };
  }]);
}(Se.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(e, i, r, s, o, a) {
    var l, h = this.decode.DCT_DECODE, u = null;
    if (typeof e == "string" || this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) {
      switch (e = o || e, e = this.__addimage__.isArrayBuffer(e) ? new Uint8Array(e) : e, (l = function(d) {
        for (var p, f = 256 * d.charCodeAt(4) + d.charCodeAt(5), g = d.length, y = { width: 0, height: 0, numcomponents: 1 }, _ = 4; _ < g; _ += 2) {
          if (_ += f, t.indexOf(d.charCodeAt(_ + 1)) !== -1) {
            p = 256 * d.charCodeAt(_ + 5) + d.charCodeAt(_ + 6), y = { width: 256 * d.charCodeAt(_ + 7) + d.charCodeAt(_ + 8), height: p, numcomponents: d.charCodeAt(_ + 9) };
            break;
          }
          f = 256 * d.charCodeAt(_ + 2) + d.charCodeAt(_ + 3);
        }
        return y;
      }(e = this.__addimage__.isArrayBufferView(e) ? this.__addimage__.arrayBufferToBinaryString(e) : e)).numcomponents) {
        case 1:
          a = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          a = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          a = this.color_spaces.DEVICE_RGB;
      }
      u = { data: e, width: l.width, height: l.height, colorSpace: a, bitsPerComponent: 8, filter: h, index: i, alias: r };
    }
    return u;
  };
}(Se.API);
var ra, Iu, rg, sg, og, Rv = function() {
  var n, t, e;
  function i(s) {
    var o, a, l, h, u, d, p, f, g, y, _, b, v, A;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, d = null; ; ) {
      switch (o = this.readUInt32(), g = (function() {
        var L, O;
        for (O = [], L = 0; L < 4; ++L) O.push(String.fromCharCode(this.data[this.pos++]));
        return O;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(o);
          break;
        case "fcTL":
          d && this.animation.frames.push(d), this.pos += 4, d = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, u = this.readUInt16(), h = this.readUInt16() || 100, d.delay = 1e3 * u / h, d.disposeOp = this.data[this.pos++], d.blendOp = this.data[this.pos++], d.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (g === "fdAT" && (this.pos += 4, o -= 4), s = (d != null ? d.data : void 0) || this.imgData, b = 0; 0 <= o ? b < o : b > o; 0 <= o ? ++b : --b) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (l = this.palette.length / 3, this.transparency.indexed = this.read(o), this.transparency.indexed.length > l) throw new Error("More transparent colors than palette size");
              if ((y = l - this.transparency.indexed.length) > 0) for (v = 0; 0 <= y ? v < y : v > y; 0 <= y ? ++v : --v) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(o)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(o);
          }
          break;
        case "tEXt":
          p = (_ = this.read(o)).indexOf(0), f = String.fromCharCode.apply(String, _.slice(0, p)), this.text[f] = String.fromCharCode.apply(String, _.slice(p + 1));
          break;
        case "IEND":
          return d && this.animation.frames.push(d), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (A = this.colorType) === 4 || A === 6, a = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += o;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  i.prototype.read = function(s) {
    var o, a;
    for (a = [], o = 0; 0 <= s ? o < s : o > s; 0 <= s ? ++o : --o) a.push(this.data[this.pos++]);
    return a;
  }, i.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.decodePixels = function(s) {
    var o = this.pixelBitlength / 8, a = new Uint8Array(this.width * this.height * o), l = 0, h = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function u(d, p, f, g) {
      var y, _, b, v, A, L, O, R, C, E, M, q, N, S, T, x, X, V, D, tt, H, ct = Math.ceil((h.width - d) / f), it = Math.ceil((h.height - p) / g), P = h.width == ct && h.height == it;
      for (S = o * ct, q = P ? a : new Uint8Array(S * it), L = s.length, N = 0, _ = 0; N < it && l < L; ) {
        switch (s[l++]) {
          case 0:
            for (v = X = 0; X < S; v = X += 1) q[_++] = s[l++];
            break;
          case 1:
            for (v = V = 0; V < S; v = V += 1) y = s[l++], A = v < o ? 0 : q[_ - o], q[_++] = (y + A) % 256;
            break;
          case 2:
            for (v = D = 0; D < S; v = D += 1) y = s[l++], b = (v - v % o) / o, T = N && q[(N - 1) * S + b * o + v % o], q[_++] = (T + y) % 256;
            break;
          case 3:
            for (v = tt = 0; tt < S; v = tt += 1) y = s[l++], b = (v - v % o) / o, A = v < o ? 0 : q[_ - o], T = N && q[(N - 1) * S + b * o + v % o], q[_++] = (y + Math.floor((A + T) / 2)) % 256;
            break;
          case 4:
            for (v = H = 0; H < S; v = H += 1) y = s[l++], b = (v - v % o) / o, A = v < o ? 0 : q[_ - o], N === 0 ? T = x = 0 : (T = q[(N - 1) * S + b * o + v % o], x = b && q[(N - 1) * S + (b - 1) * o + v % o]), O = A + T - x, R = Math.abs(O - A), E = Math.abs(O - T), M = Math.abs(O - x), C = R <= E && R <= M ? A : E <= M ? T : x, q[_++] = (y + C) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[l - 1]);
        }
        if (!P) {
          var z = ((p + N * g) * h.width + d) * o, G = N * S;
          for (v = 0; v < ct; v += 1) {
            for (var Y = 0; Y < o; Y += 1) a[z++] = q[G++];
            z += (f - 1) * o;
          }
        }
        N++;
      }
    }
    return s = dv(s), h.interlaceMethod == 1 ? (u(0, 0, 8, 8), u(4, 0, 8, 8), u(0, 4, 4, 8), u(2, 0, 4, 4), u(0, 2, 2, 4), u(1, 0, 2, 2), u(0, 1, 1, 2)) : u(0, 0, 1, 1), a;
  }, i.prototype.decodePalette = function() {
    var s, o, a, l, h, u, d, p, f;
    for (a = this.palette, u = this.transparency.indexed || [], h = new Uint8Array((u.length || 0) + a.length), l = 0, s = 0, o = d = 0, p = a.length; d < p; o = d += 3) h[l++] = a[o], h[l++] = a[o + 1], h[l++] = a[o + 2], h[l++] = (f = u[s++]) != null ? f : 255;
    return h;
  }, i.prototype.copyToImageData = function(s, o) {
    var a, l, h, u, d, p, f, g, y, _, b;
    if (l = this.colors, y = null, a = this.hasAlphaChannel, this.palette.length && (y = (b = this._decodedPalette) != null ? b : this._decodedPalette = this.decodePalette(), l = 4, a = !0), g = (h = s.data || s).length, d = y || o, u = p = 0, l === 1) for (; u < g; ) f = y ? 4 * o[u / 4] : p, _ = d[f++], h[u++] = _, h[u++] = _, h[u++] = _, h[u++] = a ? d[f++] : 255, p = f;
    else for (; u < g; ) f = y ? 4 * o[u / 4] : p, h[u++] = d[f++], h[u++] = d[f++], h[u++] = d[f++], h[u++] = a ? d[f++] : 255, p = f;
  }, i.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var r = function() {
    if (Object.prototype.toString.call(Ae) === "[object Window]") {
      try {
        t = Ae.document.createElement("canvas"), e = t.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return r(), n = function(s) {
    var o;
    if (r() === !0) return e.width = s.width, e.height = s.height, e.clearRect(0, 0, s.width, s.height), e.putImageData(s, 0, 0), (o = new Image()).src = t.toDataURL(), o;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, i.prototype.decodeFrames = function(s) {
    var o, a, l, h, u, d, p, f;
    if (this.animation) {
      for (f = [], a = u = 0, d = (p = this.animation.frames).length; u < d; a = ++u) o = p[a], l = s.createImageData(o.width, o.height), h = this.decodePixels(new Uint8Array(o.data)), this.copyToImageData(l, h), o.imageData = l, f.push(o.image = n(l));
      return f;
    }
  }, i.prototype.renderFrame = function(s, o) {
    var a, l, h;
    return a = (l = this.animation.frames)[o], h = l[o - 1], o === 0 && s.clearRect(0, 0, this.width, this.height), (h != null ? h.disposeOp : void 0) === 1 ? s.clearRect(h.xOffset, h.yOffset, h.width, h.height) : (h != null ? h.disposeOp : void 0) === 2 && s.putImageData(h.imageData, h.xOffset, h.yOffset), a.blendOp === 0 && s.clearRect(a.xOffset, a.yOffset, a.width, a.height), s.drawImage(a.image, a.xOffset, a.yOffset);
  }, i.prototype.animate = function(s) {
    var o, a, l, h, u, d, p = this;
    return a = 0, d = this.animation, h = d.numFrames, l = d.frames, u = d.numPlays, (o = function() {
      var f, g;
      if (f = a++ % h, g = l[f], p.renderFrame(s, f), h > 1 && a / h < u) return p.animation._timeout = setTimeout(o, g.delay);
    })();
  }, i.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, i.prototype.render = function(s) {
    var o, a;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, o = s.getContext("2d"), this.animation ? (this.decodeFrames(o), this.animate(o)) : (a = o.createImageData(this.width, this.height), this.copyToImageData(a, this.decodePixels()), o.putImageData(a, 0, 0));
  }, i;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Dv(n) {
  var t = 0;
  if (n[t++] !== 71 || n[t++] !== 73 || n[t++] !== 70 || n[t++] !== 56 || (n[t++] + 1 & 253) != 56 || n[t++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var e = n[t++] | n[t++] << 8, i = n[t++] | n[t++] << 8, r = n[t++], s = r >> 7, o = 1 << (7 & r) + 1;
  n[t++], n[t++];
  var a = null, l = null;
  s && (a = t, l = o, t += 3 * o);
  var h = !0, u = [], d = 0, p = null, f = 0, g = null;
  for (this.width = e, this.height = i; h && t < n.length; ) switch (n[t++]) {
    case 33:
      switch (n[t++]) {
        case 255:
          if (n[t] !== 11 || n[t + 1] == 78 && n[t + 2] == 69 && n[t + 3] == 84 && n[t + 4] == 83 && n[t + 5] == 67 && n[t + 6] == 65 && n[t + 7] == 80 && n[t + 8] == 69 && n[t + 9] == 50 && n[t + 10] == 46 && n[t + 11] == 48 && n[t + 12] == 3 && n[t + 13] == 1 && n[t + 16] == 0) t += 14, g = n[t++] | n[t++] << 8, t++;
          else for (t += 12; ; ) {
            if (!((N = n[t++]) >= 0)) throw Error("Invalid block size");
            if (N === 0) break;
            t += N;
          }
          break;
        case 249:
          if (n[t++] !== 4 || n[t + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var y = n[t++];
          d = n[t++] | n[t++] << 8, p = n[t++], !(1 & y) && (p = null), f = y >> 2 & 7, t++;
          break;
        case 254:
          for (; ; ) {
            if (!((N = n[t++]) >= 0)) throw Error("Invalid block size");
            if (N === 0) break;
            t += N;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + n[t - 1].toString(16));
      }
      break;
    case 44:
      var _ = n[t++] | n[t++] << 8, b = n[t++] | n[t++] << 8, v = n[t++] | n[t++] << 8, A = n[t++] | n[t++] << 8, L = n[t++], O = L >> 6 & 1, R = 1 << (7 & L) + 1, C = a, E = l, M = !1;
      L >> 7 && (M = !0, C = t, E = R, t += 3 * R);
      var q = t;
      for (t++; ; ) {
        var N;
        if (!((N = n[t++]) >= 0)) throw Error("Invalid block size");
        if (N === 0) break;
        t += N;
      }
      u.push({ x: _, y: b, width: v, height: A, has_local_palette: M, palette_offset: C, palette_size: E, data_offset: q, data_length: t - q, transparent_index: p, interlaced: !!O, delay: d, disposal: f });
      break;
    case 59:
      h = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + n[t - 1].toString(16));
  }
  this.numFrames = function() {
    return u.length;
  }, this.loopCount = function() {
    return g;
  }, this.frameInfo = function(S) {
    if (S < 0 || S >= u.length) throw new Error("Frame index out of range.");
    return u[S];
  }, this.decodeAndBlitFrameBGRA = function(S, T) {
    var x = this.frameInfo(S), X = x.width * x.height, V = new Uint8Array(X);
    ag(n, x.data_offset, V, X);
    var D = x.palette_offset, tt = x.transparent_index;
    tt === null && (tt = 256);
    var H = x.width, ct = e - H, it = H, P = 4 * (x.y * e + x.x), z = 4 * ((x.y + x.height) * e + x.x), G = P, Y = 4 * ct;
    x.interlaced === !0 && (Y += 4 * e * 7);
    for (var ot = 8, xt = 0, gt = V.length; xt < gt; ++xt) {
      var wt = V[xt];
      if (it === 0 && (it = H, (G += Y) >= z && (Y = 4 * ct + 4 * e * (ot - 1), G = P + (H + ct) * (ot << 1), ot >>= 1)), wt === tt) G += 4;
      else {
        var qt = n[D + 3 * wt], Dt = n[D + 3 * wt + 1], Yt = n[D + 3 * wt + 2];
        T[G++] = Yt, T[G++] = Dt, T[G++] = qt, T[G++] = 255;
      }
      --it;
    }
  }, this.decodeAndBlitFrameRGBA = function(S, T) {
    var x = this.frameInfo(S), X = x.width * x.height, V = new Uint8Array(X);
    ag(n, x.data_offset, V, X);
    var D = x.palette_offset, tt = x.transparent_index;
    tt === null && (tt = 256);
    var H = x.width, ct = e - H, it = H, P = 4 * (x.y * e + x.x), z = 4 * ((x.y + x.height) * e + x.x), G = P, Y = 4 * ct;
    x.interlaced === !0 && (Y += 4 * e * 7);
    for (var ot = 8, xt = 0, gt = V.length; xt < gt; ++xt) {
      var wt = V[xt];
      if (it === 0 && (it = H, (G += Y) >= z && (Y = 4 * ct + 4 * e * (ot - 1), G = P + (H + ct) * (ot << 1), ot >>= 1)), wt === tt) G += 4;
      else {
        var qt = n[D + 3 * wt], Dt = n[D + 3 * wt + 1], Yt = n[D + 3 * wt + 2];
        T[G++] = qt, T[G++] = Dt, T[G++] = Yt, T[G++] = 255;
      }
      --it;
    }
  };
}
function ag(n, t, e, i) {
  for (var r = n[t++], s = 1 << r, o = s + 1, a = o + 1, l = r + 1, h = (1 << l) - 1, u = 0, d = 0, p = 0, f = n[t++], g = new Int32Array(4096), y = null; ; ) {
    for (; u < 16 && f !== 0; ) d |= n[t++] << u, u += 8, f === 1 ? f = n[t++] : --f;
    if (u < l) break;
    var _ = d & h;
    if (d >>= l, u -= l, _ !== s) {
      if (_ === o) break;
      for (var b = _ < a ? _ : y, v = 0, A = b; A > s; ) A = g[A] >> 8, ++v;
      var L = A;
      if (p + v + (b !== _ ? 1 : 0) > i) return void an.log("Warning, gif stream longer than expected.");
      e[p++] = L;
      var O = p += v;
      for (b !== _ && (e[p++] = L), A = b; v--; ) A = g[A], e[--O] = 255 & A, A >>= 8;
      y !== null && a < 4096 && (g[a++] = y << 8 | L, a >= h + 1 && l < 12 && (++l, h = h << 1 | 1)), y = _;
    } else a = o + 1, h = (1 << (l = r + 1)) - 1, y = null;
  }
  return p !== i && an.log("Warning, gif stream shorter than expected."), e;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Eh(n) {
  var t, e, i, r, s, o = Math.floor, a = new Array(64), l = new Array(64), h = new Array(64), u = new Array(64), d = new Array(65535), p = new Array(65535), f = new Array(64), g = new Array(64), y = [], _ = 0, b = 7, v = new Array(64), A = new Array(64), L = new Array(64), O = new Array(256), R = new Array(2048), C = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], E = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], q = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], N = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], S = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], T = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], x = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], X = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function V(P, z) {
    for (var G = 0, Y = 0, ot = new Array(), xt = 1; xt <= 16; xt++) {
      for (var gt = 1; gt <= P[xt]; gt++) ot[z[Y]] = [], ot[z[Y]][0] = G, ot[z[Y]][1] = xt, Y++, G++;
      G *= 2;
    }
    return ot;
  }
  function D(P) {
    for (var z = P[0], G = P[1] - 1; G >= 0; ) z & 1 << G && (_ |= 1 << b), G--, --b < 0 && (_ == 255 ? (tt(255), tt(0)) : tt(_), b = 7, _ = 0);
  }
  function tt(P) {
    y.push(P);
  }
  function H(P) {
    tt(P >> 8 & 255), tt(255 & P);
  }
  function ct(P, z, G, Y, ot) {
    for (var xt, gt = ot[0], wt = ot[240], qt = function(st, vt) {
      var St, ft, Et, zt, Tt, $t, ee, oe, ae, we, Jt = 0;
      for (ae = 0; ae < 8; ++ae) {
        St = st[Jt], ft = st[Jt + 1], Et = st[Jt + 2], zt = st[Jt + 3], Tt = st[Jt + 4], $t = st[Jt + 5], ee = st[Jt + 6];
        var Nt = St + (oe = st[Jt + 7]), Ot = St - oe, re = ft + ee, Zt = ft - ee, fe = Et + $t, ie = Et - $t, de = zt + Tt, We = zt - Tt, Te = Nt + de, _n = Nt - de, Fn = re + fe, Qe = re - fe;
        st[Jt] = Te + Fn, st[Jt + 4] = Te - Fn;
        var Ne = 0.707106781 * (Qe + _n);
        st[Jt + 2] = _n + Ne, st[Jt + 6] = _n - Ne;
        var qe = 0.382683433 * ((Te = We + ie) - (Qe = Zt + Ot)), nr = 0.5411961 * Te + qe, Ln = 1.306562965 * Qe + qe, Di = 0.707106781 * (Fn = ie + Zt), jn = Ot + Di, ve = Ot - Di;
        st[Jt + 5] = ve + nr, st[Jt + 3] = ve - nr, st[Jt + 1] = jn + Ln, st[Jt + 7] = jn - Ln, Jt += 8;
      }
      for (Jt = 0, ae = 0; ae < 8; ++ae) {
        St = st[Jt], ft = st[Jt + 8], Et = st[Jt + 16], zt = st[Jt + 24], Tt = st[Jt + 32], $t = st[Jt + 40], ee = st[Jt + 48];
        var ki = St + (oe = st[Jt + 56]), Bi = St - oe, ti = ft + ee, yn = ft - ee, bn = Et + $t, ui = Et - $t, os = zt + Tt, ir = zt - Tt, gi = ki + os, Ai = ki - os, Ni = ti + bn, ji = ti - bn;
        st[Jt] = gi + Ni, st[Jt + 32] = gi - Ni;
        var Ci = 0.707106781 * (ji + Ai);
        st[Jt + 16] = Ai + Ci, st[Jt + 48] = Ai - Ci;
        var qi = 0.382683433 * ((gi = ir + ui) - (ji = yn + Bi)), xr = 0.5411961 * gi + qi, Br = 1.306562965 * ji + qi, rr = 0.707106781 * (Ni = ui + yn), jr = Bi + rr, qr = Bi - rr;
        st[Jt + 40] = qr + xr, st[Jt + 24] = qr - xr, st[Jt + 8] = jr + Br, st[Jt + 56] = jr - Br, Jt++;
      }
      for (ae = 0; ae < 64; ++ae) we = st[ae] * vt[ae], f[ae] = we > 0 ? we + 0.5 | 0 : we - 0.5 | 0;
      return f;
    }(P, z), Dt = 0; Dt < 64; ++Dt) g[C[Dt]] = qt[Dt];
    var Yt = g[0] - G;
    G = g[0], Yt == 0 ? D(Y[0]) : (D(Y[p[xt = 32767 + Yt]]), D(d[xt]));
    for (var Xt = 63; Xt > 0 && g[Xt] == 0; ) Xt--;
    if (Xt == 0) return D(gt), G;
    for (var F, ht = 1; ht <= Xt; ) {
      for (var $ = ht; g[ht] == 0 && ht <= Xt; ) ++ht;
      var nt = ht - $;
      if (nt >= 16) {
        F = nt >> 4;
        for (var J = 1; J <= F; ++J) D(wt);
        nt &= 15;
      }
      xt = 32767 + g[ht], D(ot[(nt << 4) + p[xt]]), D(d[xt]), ht++;
    }
    return Xt != 63 && D(gt), G;
  }
  function it(P) {
    P = Math.min(Math.max(P, 1), 100), s != P && (function(z) {
      for (var G = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Y = 0; Y < 64; Y++) {
        var ot = o((G[Y] * z + 50) / 100);
        ot = Math.min(Math.max(ot, 1), 255), a[C[Y]] = ot;
      }
      for (var xt = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], gt = 0; gt < 64; gt++) {
        var wt = o((xt[gt] * z + 50) / 100);
        wt = Math.min(Math.max(wt, 1), 255), l[C[gt]] = wt;
      }
      for (var qt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Dt = 0, Yt = 0; Yt < 8; Yt++) for (var Xt = 0; Xt < 8; Xt++) h[Dt] = 1 / (a[C[Dt]] * qt[Yt] * qt[Xt] * 8), u[Dt] = 1 / (l[C[Dt]] * qt[Yt] * qt[Xt] * 8), Dt++;
    }(P < 50 ? Math.floor(5e3 / P) : Math.floor(200 - 2 * P)), s = P);
  }
  this.encode = function(P, z) {
    z && it(z), y = new Array(), _ = 0, b = 7, H(65496), H(65504), H(16), tt(74), tt(70), tt(73), tt(70), tt(0), tt(1), tt(1), tt(0), H(1), H(1), tt(0), tt(0), function() {
      H(65499), H(132), tt(0);
      for (var ft = 0; ft < 64; ft++) tt(a[ft]);
      tt(1);
      for (var Et = 0; Et < 64; Et++) tt(l[Et]);
    }(), function(ft, Et) {
      H(65472), H(17), tt(8), H(Et), H(ft), tt(3), tt(1), tt(17), tt(0), tt(2), tt(17), tt(1), tt(3), tt(17), tt(1);
    }(P.width, P.height), function() {
      H(65476), H(418), tt(0);
      for (var ft = 0; ft < 16; ft++) tt(E[ft + 1]);
      for (var Et = 0; Et <= 11; Et++) tt(M[Et]);
      tt(16);
      for (var zt = 0; zt < 16; zt++) tt(q[zt + 1]);
      for (var Tt = 0; Tt <= 161; Tt++) tt(N[Tt]);
      tt(1);
      for (var $t = 0; $t < 16; $t++) tt(S[$t + 1]);
      for (var ee = 0; ee <= 11; ee++) tt(T[ee]);
      tt(17);
      for (var oe = 0; oe < 16; oe++) tt(x[oe + 1]);
      for (var ae = 0; ae <= 161; ae++) tt(X[ae]);
    }(), H(65498), H(12), tt(3), tt(1), tt(0), tt(2), tt(17), tt(3), tt(17), tt(0), tt(63), tt(0);
    var G = 0, Y = 0, ot = 0;
    _ = 0, b = 7, this.encode.displayName = "_encode_";
    for (var xt, gt, wt, qt, Dt, Yt, Xt, F, ht, $ = P.data, nt = P.width, J = P.height, st = 4 * nt, vt = 0; vt < J; ) {
      for (xt = 0; xt < st; ) {
        for (Dt = st * vt + xt, Xt = -1, F = 0, ht = 0; ht < 64; ht++) Yt = Dt + (F = ht >> 3) * st + (Xt = 4 * (7 & ht)), vt + F >= J && (Yt -= st * (vt + 1 + F - J)), xt + Xt >= st && (Yt -= xt + Xt - st + 4), gt = $[Yt++], wt = $[Yt++], qt = $[Yt++], v[ht] = (R[gt] + R[wt + 256 >> 0] + R[qt + 512 >> 0] >> 16) - 128, A[ht] = (R[gt + 768 >> 0] + R[wt + 1024 >> 0] + R[qt + 1280 >> 0] >> 16) - 128, L[ht] = (R[gt + 1280 >> 0] + R[wt + 1536 >> 0] + R[qt + 1792 >> 0] >> 16) - 128;
        G = ct(v, h, G, t, i), Y = ct(A, u, Y, e, r), ot = ct(L, u, ot, e, r), xt += 32;
      }
      vt += 8;
    }
    if (b >= 0) {
      var St = [];
      St[1] = b + 1, St[0] = (1 << b + 1) - 1, D(St);
    }
    return H(65497), new Uint8Array(y);
  }, n = n || 50, function() {
    for (var P = String.fromCharCode, z = 0; z < 256; z++) O[z] = P(z);
  }(), t = V(E, M), e = V(S, T), i = V(q, N), r = V(x, X), function() {
    for (var P = 1, z = 2, G = 1; G <= 15; G++) {
      for (var Y = P; Y < z; Y++) p[32767 + Y] = G, d[32767 + Y] = [], d[32767 + Y][1] = G, d[32767 + Y][0] = Y;
      for (var ot = -(z - 1); ot <= -P; ot++) p[32767 + ot] = G, d[32767 + ot] = [], d[32767 + ot][1] = G, d[32767 + ot][0] = z - 1 + ot;
      P <<= 1, z <<= 1;
    }
  }(), function() {
    for (var P = 0; P < 256; P++) R[P] = 19595 * P, R[P + 256 >> 0] = 38470 * P, R[P + 512 >> 0] = 7471 * P + 32768, R[P + 768 >> 0] = -11059 * P, R[P + 1024 >> 0] = -21709 * P, R[P + 1280 >> 0] = 32768 * P + 8421375, R[P + 1536 >> 0] = -27439 * P, R[P + 1792 >> 0] = -5329 * P;
  }(), it(n);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function cr(n, t) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!t, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function lg(n) {
  function t(E) {
    if (!E) throw Error("assert :P");
  }
  function e(E, M, q) {
    for (var N = 0; 4 > N; N++) if (E[M + N] != q.charCodeAt(N)) return !0;
    return !1;
  }
  function i(E, M, q, N, S) {
    for (var T = 0; T < S; T++) E[M + T] = q[N + T];
  }
  function r(E, M, q, N) {
    for (var S = 0; S < N; S++) E[M + S] = q;
  }
  function s(E) {
    return new Int32Array(E);
  }
  function o(E, M) {
    for (var q = [], N = 0; N < E; N++) q.push(new M());
    return q;
  }
  function a(E, M) {
    var q = [];
    return function N(S, T, x) {
      for (var X = x[T], V = 0; V < X && (S.push(x.length > T + 1 ? [] : new M()), !(x.length < T + 1)); V++) N(S[V], T + 1, x);
    }(q, 0, E), q;
  }
  var l = function() {
    var E = this;
    function M(c, m) {
      for (var k = 1 << m - 1 >>> 0; c & k; ) k >>>= 1;
      return k ? (c & k - 1) + k : c;
    }
    function q(c, m, k, I, B) {
      t(!(I % k));
      do
        c[m + (I -= k)] = B;
      while (0 < I);
    }
    function N(c, m, k, I, B) {
      if (t(2328 >= B), 512 >= B) var U = s(512);
      else if ((U = s(B)) == null) return 0;
      return function(W, K, Z, rt, yt, Pt) {
        var Lt, At, Ht = K, Ft = 1 << Z, bt = s(16), _t = s(16);
        for (t(yt != 0), t(rt != null), t(W != null), t(0 < Z), At = 0; At < yt; ++At) {
          if (15 < rt[At]) return 0;
          ++bt[rt[At]];
        }
        if (bt[0] == yt) return 0;
        for (_t[1] = 0, Lt = 1; 15 > Lt; ++Lt) {
          if (bt[Lt] > 1 << Lt) return 0;
          _t[Lt + 1] = _t[Lt] + bt[Lt];
        }
        for (At = 0; At < yt; ++At) Lt = rt[At], 0 < rt[At] && (Pt[_t[Lt]++] = At);
        if (_t[15] == 1) return (rt = new S()).g = 0, rt.value = Pt[0], q(W, Ht, 1, Ft, rt), Ft;
        var Ut, Gt = -1, Wt = Ft - 1, ce = 0, ne = 1, xe = 1, se = 1 << Z;
        for (At = 0, Lt = 1, yt = 2; Lt <= Z; ++Lt, yt <<= 1) {
          if (ne += xe <<= 1, 0 > (xe -= bt[Lt])) return 0;
          for (; 0 < bt[Lt]; --bt[Lt]) (rt = new S()).g = Lt, rt.value = Pt[At++], q(W, Ht + ce, yt, se, rt), ce = M(ce, Lt);
        }
        for (Lt = Z + 1, yt = 2; 15 >= Lt; ++Lt, yt <<= 1) {
          if (ne += xe <<= 1, 0 > (xe -= bt[Lt])) return 0;
          for (; 0 < bt[Lt]; --bt[Lt]) {
            if (rt = new S(), (ce & Wt) != Gt) {
              for (Ht += se, Ut = 1 << (Gt = Lt) - Z; 15 > Gt && !(0 >= (Ut -= bt[Gt])); ) ++Gt, Ut <<= 1;
              Ft += se = 1 << (Ut = Gt - Z), W[K + (Gt = ce & Wt)].g = Ut + Z, W[K + Gt].value = Ht - K - Gt;
            }
            rt.g = Lt - Z, rt.value = Pt[At++], q(W, Ht + (ce >> Z), yt, se, rt), ce = M(ce, Lt);
          }
        }
        return ne != 2 * _t[15] - 1 ? 0 : Ft;
      }(c, m, k, I, B, U);
    }
    function S() {
      this.value = this.g = 0;
    }
    function T() {
      this.value = this.g = 0;
    }
    function x() {
      this.G = o(5, S), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o(Vn, T);
    }
    function X(c, m, k, I) {
      t(c != null), t(m != null), t(2147483648 > I), c.Ca = 254, c.I = 0, c.b = -8, c.Ka = 0, c.oa = m, c.pa = k, c.Jd = m, c.Yc = k + I, c.Zc = 4 <= I ? k + I - 4 + 1 : k, xt(c);
    }
    function V(c, m) {
      for (var k = 0; 0 < m--; ) k |= wt(c, 128) << m;
      return k;
    }
    function D(c, m) {
      var k = V(c, m);
      return gt(c) ? -k : k;
    }
    function tt(c, m, k, I) {
      var B, U = 0;
      for (t(c != null), t(m != null), t(4294967288 > I), c.Sb = I, c.Ra = 0, c.u = 0, c.h = 0, 4 < I && (I = 4), B = 0; B < I; ++B) U += m[k + B] << 8 * B;
      c.Ra = U, c.bb = I, c.oa = m, c.pa = k;
    }
    function H(c) {
      for (; 8 <= c.u && c.bb < c.Sb; ) c.Ra >>>= 8, c.Ra += c.oa[c.pa + c.bb] << Vo - 8 >>> 0, ++c.bb, c.u -= 8;
      G(c) && (c.h = 1, c.u = 0);
    }
    function ct(c, m) {
      if (t(0 <= m), !c.h && m <= Go) {
        var k = z(c) & Ho[m];
        return c.u += m, H(c), k;
      }
      return c.h = 1, c.u = 0;
    }
    function it() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function P() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function z(c) {
      return c.Ra >>> (c.u & Vo - 1) >>> 0;
    }
    function G(c) {
      return t(c.bb <= c.Sb), c.h || c.bb == c.Sb && c.u > Vo;
    }
    function Y(c, m) {
      c.u = m, c.h = G(c);
    }
    function ot(c) {
      c.u >= Ka && (t(c.u >= Ka), H(c));
    }
    function xt(c) {
      t(c != null && c.oa != null), c.pa < c.Zc ? (c.I = (c.oa[c.pa++] | c.I << 8) >>> 0, c.b += 8) : (t(c != null && c.oa != null), c.pa < c.Yc ? (c.b += 8, c.I = c.oa[c.pa++] | c.I << 8) : c.Ka ? c.b = 0 : (c.I <<= 8, c.b += 8, c.Ka = 1));
    }
    function gt(c) {
      return V(c, 1);
    }
    function wt(c, m) {
      var k = c.Ca;
      0 > c.b && xt(c);
      var I = c.b, B = k * m >>> 8, U = (c.I >>> I > B) + 0;
      for (U ? (k -= B, c.I -= B + 1 << I >>> 0) : k = B + 1, I = k, B = 0; 256 <= I; ) B += 8, I >>= 8;
      return I = 7 ^ B + mi[I], c.b -= I, c.Ca = (k << I) - 1, U;
    }
    function qt(c, m, k) {
      c[m + 0] = k >> 24 & 255, c[m + 1] = k >> 16 & 255, c[m + 2] = k >> 8 & 255, c[m + 3] = k >> 0 & 255;
    }
    function Dt(c, m) {
      return c[m + 0] << 0 | c[m + 1] << 8;
    }
    function Yt(c, m) {
      return Dt(c, m) | c[m + 2] << 16;
    }
    function Xt(c, m) {
      return Dt(c, m) | Dt(c, m + 2) << 16;
    }
    function F(c, m) {
      var k = 1 << m;
      return t(c != null), t(0 < m), c.X = s(k), c.X == null ? 0 : (c.Mb = 32 - m, c.Xa = m, 1);
    }
    function ht(c, m) {
      t(c != null), t(m != null), t(c.Xa == m.Xa), i(m.X, 0, c.X, 0, 1 << m.Xa);
    }
    function $() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function nt(c, m, k, I) {
      t(k != null), t(I != null);
      var B = k[0], U = I[0];
      return B == 0 && (B = (c * U + m / 2) / m), U == 0 && (U = (m * B + c / 2) / c), 0 >= B || 0 >= U ? 0 : (k[0] = B, I[0] = U, 1);
    }
    function J(c, m) {
      return c + (1 << m) - 1 >>> m;
    }
    function st(c, m) {
      return ((4278255360 & c) + (4278255360 & m) >>> 0 & 4278255360) + ((16711935 & c) + (16711935 & m) >>> 0 & 16711935) >>> 0;
    }
    function vt(c, m) {
      E[m] = function(k, I, B, U, W, K, Z) {
        var rt;
        for (rt = 0; rt < W; ++rt) {
          var yt = E[c](K[Z + rt - 1], B, U + rt);
          K[Z + rt] = st(k[I + rt], yt);
        }
      };
    }
    function St() {
      this.ud = this.hd = this.jd = 0;
    }
    function ft(c, m) {
      return ((4278124286 & (c ^ m)) >>> 1) + (c & m) >>> 0;
    }
    function Et(c) {
      return 0 <= c && 256 > c ? c : 0 > c ? 0 : 255 < c ? 255 : void 0;
    }
    function zt(c, m) {
      return Et(c + (c - m + 0.5 >> 1));
    }
    function Tt(c, m, k) {
      return Math.abs(m - k) - Math.abs(c - k);
    }
    function $t(c, m, k, I, B, U, W) {
      for (I = U[W - 1], k = 0; k < B; ++k) U[W + k] = I = st(c[m + k], I);
    }
    function ee(c, m, k, I, B) {
      var U;
      for (U = 0; U < k; ++U) {
        var W = c[m + U], K = W >> 8 & 255, Z = 16711935 & (Z = (Z = 16711935 & W) + ((K << 16) + K));
        I[B + U] = (4278255360 & W) + Z >>> 0;
      }
    }
    function oe(c, m) {
      m.jd = c >> 0 & 255, m.hd = c >> 8 & 255, m.ud = c >> 16 & 255;
    }
    function ae(c, m, k, I, B, U) {
      var W;
      for (W = 0; W < I; ++W) {
        var K = m[k + W], Z = K >>> 8, rt = K, yt = 255 & (yt = (yt = K >>> 16) + ((c.jd << 24 >> 24) * (Z << 24 >> 24) >>> 5));
        rt = 255 & (rt = (rt = rt + ((c.hd << 24 >> 24) * (Z << 24 >> 24) >>> 5)) + ((c.ud << 24 >> 24) * (yt << 24 >> 24) >>> 5)), B[U + W] = (4278255360 & K) + (yt << 16) + rt;
      }
    }
    function we(c, m, k, I, B) {
      E[m] = function(U, W, K, Z, rt, yt, Pt, Lt, At) {
        for (Z = Pt; Z < Lt; ++Z) for (Pt = 0; Pt < At; ++Pt) rt[yt++] = B(K[I(U[W++])]);
      }, E[c] = function(U, W, K, Z, rt, yt, Pt) {
        var Lt = 8 >> U.b, At = U.Ea, Ht = U.K[0], Ft = U.w;
        if (8 > Lt) for (U = (1 << U.b) - 1, Ft = (1 << Lt) - 1; W < K; ++W) {
          var bt, _t = 0;
          for (bt = 0; bt < At; ++bt) bt & U || (_t = I(Z[rt++])), yt[Pt++] = B(Ht[_t & Ft]), _t >>= Lt;
        }
        else E["VP8LMapColor" + k](Z, rt, Ht, Ft, yt, Pt, W, K, At);
      };
    }
    function Jt(c, m, k, I, B) {
      for (k = m + k; m < k; ) {
        var U = c[m++];
        I[B++] = U >> 16 & 255, I[B++] = U >> 8 & 255, I[B++] = U >> 0 & 255;
      }
    }
    function Nt(c, m, k, I, B) {
      for (k = m + k; m < k; ) {
        var U = c[m++];
        I[B++] = U >> 16 & 255, I[B++] = U >> 8 & 255, I[B++] = U >> 0 & 255, I[B++] = U >> 24 & 255;
      }
    }
    function Ot(c, m, k, I, B) {
      for (k = m + k; m < k; ) {
        var U = (W = c[m++]) >> 16 & 240 | W >> 12 & 15, W = W >> 0 & 240 | W >> 28 & 15;
        I[B++] = U, I[B++] = W;
      }
    }
    function re(c, m, k, I, B) {
      for (k = m + k; m < k; ) {
        var U = (W = c[m++]) >> 16 & 248 | W >> 13 & 7, W = W >> 5 & 224 | W >> 3 & 31;
        I[B++] = U, I[B++] = W;
      }
    }
    function Zt(c, m, k, I, B) {
      for (k = m + k; m < k; ) {
        var U = c[m++];
        I[B++] = U >> 0 & 255, I[B++] = U >> 8 & 255, I[B++] = U >> 16 & 255;
      }
    }
    function fe(c, m, k, I, B, U) {
      if (U == 0) for (k = m + k; m < k; ) qt(I, ((U = c[m++])[0] >> 24 | U[1] >> 8 & 65280 | U[2] << 8 & 16711680 | U[3] << 24) >>> 0), B += 32;
      else i(I, B, c, m, k);
    }
    function ie(c, m) {
      E[m][0] = E[c + "0"], E[m][1] = E[c + "1"], E[m][2] = E[c + "2"], E[m][3] = E[c + "3"], E[m][4] = E[c + "4"], E[m][5] = E[c + "5"], E[m][6] = E[c + "6"], E[m][7] = E[c + "7"], E[m][8] = E[c + "8"], E[m][9] = E[c + "9"], E[m][10] = E[c + "10"], E[m][11] = E[c + "11"], E[m][12] = E[c + "12"], E[m][13] = E[c + "13"], E[m][14] = E[c + "0"], E[m][15] = E[c + "0"];
    }
    function de(c) {
      return c == nh || c == ih || c == lu || c == rh;
    }
    function We() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Te() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function _n() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new We(), this.f.kb = new Te(), this.sd = null;
    }
    function Fn() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Qe() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function Ne(c) {
      return alert("todo:WebPSamplerProcessPlane"), c.T;
    }
    function qe(c, m) {
      var k = c.T, I = m.ba.f.RGBA, B = I.eb, U = I.fb + c.ka * I.A, W = Yi[m.ba.S], K = c.y, Z = c.O, rt = c.f, yt = c.N, Pt = c.ea, Lt = c.W, At = m.cc, Ht = m.dc, Ft = m.Mc, bt = m.Nc, _t = c.ka, Ut = c.ka + c.T, Gt = c.U, Wt = Gt + 1 >> 1;
      for (_t == 0 ? W(K, Z, null, null, rt, yt, Pt, Lt, rt, yt, Pt, Lt, B, U, null, null, Gt) : (W(m.ec, m.fc, K, Z, At, Ht, Ft, bt, rt, yt, Pt, Lt, B, U - I.A, B, U, Gt), ++k); _t + 2 < Ut; _t += 2) At = rt, Ht = yt, Ft = Pt, bt = Lt, yt += c.Rc, Lt += c.Rc, U += 2 * I.A, W(K, (Z += 2 * c.fa) - c.fa, K, Z, At, Ht, Ft, bt, rt, yt, Pt, Lt, B, U - I.A, B, U, Gt);
      return Z += c.fa, c.j + Ut < c.o ? (i(m.ec, m.fc, K, Z, Gt), i(m.cc, m.dc, rt, yt, Wt), i(m.Mc, m.Nc, Pt, Lt, Wt), k--) : 1 & Ut || W(K, Z, null, null, rt, yt, Pt, Lt, rt, yt, Pt, Lt, B, U + I.A, null, null, Gt), k;
    }
    function nr(c, m, k) {
      var I = c.F, B = [c.J];
      if (I != null) {
        var U = c.U, W = m.ba.S, K = W == au || W == lu;
        m = m.ba.f.RGBA;
        var Z = [0], rt = c.ka;
        Z[0] = c.T, c.Kb && (rt == 0 ? --Z[0] : (--rt, B[0] -= c.width), c.j + c.ka + c.T == c.o && (Z[0] = c.o - c.j - rt));
        var yt = m.eb;
        rt = m.fb + rt * m.A, c = cn(I, B[0], c.width, U, Z, yt, rt + (K ? 0 : 3), m.A), t(k == Z), c && de(W) && Gi(yt, rt, K, U, Z, m.A);
      }
      return 0;
    }
    function Ln(c) {
      var m = c.ma, k = m.ba.S, I = 11 > k, B = k == su || k == ou || k == au || k == eh || k == 12 || de(k);
      if (m.memory = null, m.Ib = null, m.Jb = null, m.Nd = null, !Va(m.Oa, c, B ? 11 : 12)) return 0;
      if (B && de(k) && Vt(), c.da) alert("todo:use_scaling");
      else {
        if (I) {
          if (m.Ib = Ne, c.Kb) {
            if (k = c.U + 1 >> 1, m.memory = s(c.U + 2 * k), m.memory == null) return 0;
            m.ec = m.memory, m.fc = 0, m.cc = m.ec, m.dc = m.fc + c.U, m.Mc = m.cc, m.Nc = m.dc + k, m.Ib = qe, Vt();
          }
        } else alert("todo:EmitYUV");
        B && (m.Jb = nr, I && Ct());
      }
      if (I && !tp) {
        for (c = 0; 256 > c; ++c) s2[c] = 89858 * (c - 128) + cu >> uu, l2[c] = -22014 * (c - 128) + cu, a2[c] = -45773 * (c - 128), o2[c] = 113618 * (c - 128) + cu >> uu;
        for (c = nl; c < ah; ++c) m = 76283 * (c - 16) + cu >> uu, u2[c - nl] = Ii(m, 255), c2[c - nl] = Ii(m + 8 >> 4, 15);
        tp = 1;
      }
      return 1;
    }
    function Di(c) {
      var m = c.ma, k = c.U, I = c.T;
      return t(!(1 & c.ka)), 0 >= k || 0 >= I ? 0 : (k = m.Ib(c, m), m.Jb != null && m.Jb(c, m, k), m.Dc += k, 1);
    }
    function jn(c) {
      c.ma.memory = null;
    }
    function ve(c, m, k, I) {
      return ct(c, 8) != 47 ? 0 : (m[0] = ct(c, 14) + 1, k[0] = ct(c, 14) + 1, I[0] = ct(c, 1), ct(c, 3) != 0 ? 0 : !c.h);
    }
    function ki(c, m) {
      if (4 > c) return c + 1;
      var k = c - 2 >> 1;
      return (2 + (1 & c) << k) + ct(m, k) + 1;
    }
    function Bi(c, m) {
      return 120 < m ? m - 120 : 1 <= (k = ((k = Hm[m - 1]) >> 4) * c + (8 - (15 & k))) ? k : 1;
      var k;
    }
    function ti(c, m, k) {
      var I = z(k), B = c[m += 255 & I].g - 8;
      return 0 < B && (Y(k, k.u + 8), I = z(k), m += c[m].value, m += I & (1 << B) - 1), Y(k, k.u + c[m].g), c[m].value;
    }
    function yn(c, m, k) {
      return k.g += c.g, k.value += c.value << m >>> 0, t(8 >= k.g), c.g;
    }
    function bn(c, m, k) {
      var I = c.xc;
      return t((m = I == 0 ? 0 : c.vc[c.md * (k >> I) + (m >> I)]) < c.Wb), c.Ya[m];
    }
    function ui(c, m, k, I) {
      var B = c.ab, U = c.c * m, W = c.C;
      m = W + m;
      var K = k, Z = I;
      for (I = c.Ta, k = c.Ua; 0 < B--; ) {
        var rt = c.gc[B], yt = W, Pt = m, Lt = K, At = Z, Ht = (Z = I, K = k, rt.Ea);
        switch (t(yt < Pt), t(Pt <= rt.nc), rt.hc) {
          case 2:
            Zl(Lt, At, (Pt - yt) * Ht, Z, K);
            break;
          case 0:
            var Ft = yt, bt = Pt, _t = Z, Ut = K, Gt = (se = rt).Ea;
            Ft == 0 && (Qc(Lt, At, null, null, 1, _t, Ut), $t(Lt, At + 1, 0, 0, Gt - 1, _t, Ut + 1), At += Gt, Ut += Gt, ++Ft);
            for (var Wt = 1 << se.b, ce = Wt - 1, ne = J(Gt, se.b), xe = se.K, se = se.w + (Ft >> se.b) * ne; Ft < bt; ) {
              var Xe = xe, tn = se, He = 1;
              for (Xa(Lt, At, _t, Ut - Gt, 1, _t, Ut); He < Gt; ) {
                var je = (He & ~ce) + Wt;
                je > Gt && (je = Gt), (0, ys[Xe[tn++] >> 8 & 15])(Lt, At + +He, _t, Ut + He - Gt, je - He, _t, Ut + He), He = je;
              }
              At += Gt, Ut += Gt, ++Ft & ce || (se += ne);
            }
            Pt != rt.nc && i(Z, K - Ht, Z, K + (Pt - yt - 1) * Ht, Ht);
            break;
          case 1:
            for (Ht = Lt, bt = At, Gt = (Lt = rt.Ea) - (Ut = Lt & ~(_t = (At = 1 << rt.b) - 1)), Ft = J(Lt, rt.b), Wt = rt.K, rt = rt.w + (yt >> rt.b) * Ft; yt < Pt; ) {
              for (ce = Wt, ne = rt, xe = new St(), se = bt + Ut, Xe = bt + Lt; bt < se; ) oe(ce[ne++], xe), Qs(xe, Ht, bt, At, Z, K), bt += At, K += At;
              bt < Xe && (oe(ce[ne++], xe), Qs(xe, Ht, bt, Gt, Z, K), bt += Gt, K += Gt), ++yt & _t || (rt += Ft);
            }
            break;
          case 3:
            if (Lt == Z && At == K && 0 < rt.b) {
              for (bt = Z, Lt = Ht = K + (Pt - yt) * Ht - (Ut = (Pt - yt) * J(rt.Ea, rt.b)), At = Z, _t = K, Ft = [], Ut = (Gt = Ut) - 1; 0 <= Ut; --Ut) Ft[Ut] = At[_t + Ut];
              for (Ut = Gt - 1; 0 <= Ut; --Ut) bt[Lt + Ut] = Ft[Ut];
              Ui(rt, yt, Pt, Z, Ht, Z, K);
            } else Ui(rt, yt, Pt, Lt, At, Z, K);
        }
        K = I, Z = k;
      }
      Z != k && i(I, k, K, Z, U);
    }
    function os(c, m) {
      var k = c.V, I = c.Ba + c.c * c.C, B = m - c.C;
      if (t(m <= c.l.o), t(16 >= B), 0 < B) {
        var U = c.l, W = c.Ta, K = c.Ua, Z = U.width;
        if (ui(c, B, k, I), B = K = [K], t((k = c.C) < (I = m)), t(U.v < U.va), I > U.o && (I = U.o), k < U.j) {
          var rt = U.j - k;
          k = U.j, B[0] += rt * Z;
        }
        if (k >= I ? k = 0 : (B[0] += 4 * U.v, U.ka = k - U.j, U.U = U.va - U.v, U.T = I - k, k = 1), k) {
          if (K = K[0], 11 > (k = c.ca).S) {
            var yt = k.f.RGBA, Pt = (I = k.S, B = U.U, U = U.T, rt = yt.eb, yt.A), Lt = U;
            for (yt = yt.fb + c.Ma * yt.A; 0 < Lt--; ) {
              var At = W, Ht = K, Ft = B, bt = rt, _t = yt;
              switch (I) {
                case ru:
                  yi(At, Ht, Ft, bt, _t);
                  break;
                case su:
                  ci(At, Ht, Ft, bt, _t);
                  break;
                case nh:
                  ci(At, Ht, Ft, bt, _t), Gi(bt, _t, 0, Ft, 1, 0);
                  break;
                case Wd:
                  Vr(At, Ht, Ft, bt, _t);
                  break;
                case ou:
                  fe(At, Ht, Ft, bt, _t, 1);
                  break;
                case ih:
                  fe(At, Ht, Ft, bt, _t, 1), Gi(bt, _t, 0, Ft, 1, 0);
                  break;
                case au:
                  fe(At, Ht, Ft, bt, _t, 0);
                  break;
                case lu:
                  fe(At, Ht, Ft, bt, _t, 0), Gi(bt, _t, 1, Ft, 1, 0);
                  break;
                case eh:
                  bs(At, Ht, Ft, bt, _t);
                  break;
                case rh:
                  bs(At, Ht, Ft, bt, _t), un(bt, _t, Ft, 1, 0);
                  break;
                case Hd:
                  Gr(At, Ht, Ft, bt, _t);
                  break;
                default:
                  t(0);
              }
              K += Z, yt += Pt;
            }
            c.Ma += U;
          } else alert("todo:EmitRescaledRowsYUVA");
          t(c.Ma <= k.height);
        }
      }
      c.C = m, t(c.C <= c.i);
    }
    function ir(c) {
      var m;
      if (0 < c.ua) return 0;
      for (m = 0; m < c.Wb; ++m) {
        var k = c.Ya[m].G, I = c.Ya[m].H;
        if (0 < k[1][I[1] + 0].g || 0 < k[2][I[2] + 0].g || 0 < k[3][I[3] + 0].g) return 0;
      }
      return 1;
    }
    function gi(c, m, k, I, B, U) {
      if (c.Z != 0) {
        var W = c.qd, K = c.rd;
        for (t(_s[c.Z] != null); m < k; ++m) _s[c.Z](W, K, I, B, I, B, U), W = I, K = B, B += U;
        c.qd = W, c.rd = K;
      }
    }
    function Ai(c, m) {
      var k = c.l.ma, I = k.Z == 0 || k.Z == 1 ? c.l.j : c.C;
      if (I = c.C < I ? I : c.C, t(m <= c.l.o), m > I) {
        var B = c.l.width, U = k.ca, W = k.tb + B * I, K = c.V, Z = c.Ba + c.c * I, rt = c.gc;
        t(c.ab == 1), t(rt[0].hc == 3), Ql(rt[0], I, m, K, Z, U, W), gi(k, I, m, U, W, B);
      }
      c.C = c.Ma = m;
    }
    function Ni(c, m, k, I, B, U, W) {
      var K = c.$ / I, Z = c.$ % I, rt = c.m, yt = c.s, Pt = k + c.$, Lt = Pt;
      B = k + I * B;
      var At = k + I * U, Ht = 280 + yt.ua, Ft = c.Pb ? K : 16777216, bt = 0 < yt.ua ? yt.Wa : null, _t = yt.wc, Ut = Pt < At ? bn(yt, Z, K) : null;
      t(c.C < U), t(At <= B);
      var Gt = !1;
      t: for (; ; ) {
        for (; Gt || Pt < At; ) {
          var Wt = 0;
          if (K >= Ft) {
            var ce = Pt - k;
            t((Ft = c).Pb), Ft.wd = Ft.m, Ft.xd = ce, 0 < Ft.s.ua && ht(Ft.s.Wa, Ft.s.vb), Ft = K + Vm;
          }
          if (Z & _t || (Ut = bn(yt, Z, K)), t(Ut != null), Ut.Qb && (m[Pt] = Ut.qb, Gt = !0), !Gt) if (ot(rt), Ut.jc) {
            Wt = rt, ce = m;
            var ne = Pt, xe = Ut.pd[z(Wt) & Vn - 1];
            t(Ut.jc), 256 > xe.g ? (Y(Wt, Wt.u + xe.g), ce[ne] = xe.value, Wt = 0) : (Y(Wt, Wt.u + xe.g - 256), t(256 <= xe.value), Wt = xe.value), Wt == 0 && (Gt = !0);
          } else Wt = ti(Ut.G[0], Ut.H[0], rt);
          if (rt.h) break;
          if (Gt || 256 > Wt) {
            if (!Gt) if (Ut.nd) m[Pt] = (Ut.qb | Wt << 8) >>> 0;
            else {
              if (ot(rt), Gt = ti(Ut.G[1], Ut.H[1], rt), ot(rt), ce = ti(Ut.G[2], Ut.H[2], rt), ne = ti(Ut.G[3], Ut.H[3], rt), rt.h) break;
              m[Pt] = (ne << 24 | Gt << 16 | Wt << 8 | ce) >>> 0;
            }
            if (Gt = !1, ++Pt, ++Z >= I && (Z = 0, ++K, W != null && K <= U && !(K % 16) && W(c, K), bt != null)) for (; Lt < Pt; ) Wt = m[Lt++], bt.X[(506832829 * Wt & 4294967295) >>> bt.Mb] = Wt;
          } else if (280 > Wt) {
            if (Wt = ki(Wt - 256, rt), ce = ti(Ut.G[4], Ut.H[4], rt), ot(rt), ce = Bi(I, ce = ki(ce, rt)), rt.h) break;
            if (Pt - k < ce || B - Pt < Wt) break t;
            for (ne = 0; ne < Wt; ++ne) m[Pt + ne] = m[Pt + ne - ce];
            for (Pt += Wt, Z += Wt; Z >= I; ) Z -= I, ++K, W != null && K <= U && !(K % 16) && W(c, K);
            if (t(Pt <= B), Z & _t && (Ut = bn(yt, Z, K)), bt != null) for (; Lt < Pt; ) Wt = m[Lt++], bt.X[(506832829 * Wt & 4294967295) >>> bt.Mb] = Wt;
          } else {
            if (!(Wt < Ht)) break t;
            for (Gt = Wt - 280, t(bt != null); Lt < Pt; ) Wt = m[Lt++], bt.X[(506832829 * Wt & 4294967295) >>> bt.Mb] = Wt;
            Wt = Pt, t(!(Gt >>> (ce = bt).Xa)), m[Wt] = ce.X[Gt], Gt = !0;
          }
          Gt || t(rt.h == G(rt));
        }
        if (c.Pb && rt.h && Pt < B) t(c.m.h), c.a = 5, c.m = c.wd, c.$ = c.xd, 0 < c.s.ua && ht(c.s.vb, c.s.Wa);
        else {
          if (rt.h) break t;
          W != null && W(c, K > U ? U : K), c.a = 0, c.$ = Pt - k;
        }
        return 1;
      }
      return c.a = 3, 0;
    }
    function ji(c) {
      t(c != null), c.vc = null, c.yc = null, c.Ya = null;
      var m = c.Wa;
      m != null && (m.X = null), c.vb = null, t(c != null);
    }
    function Ci() {
      var c = new Zc();
      return c == null ? null : (c.a = 0, c.xb = Yd, ie("Predictor", "VP8LPredictors"), ie("Predictor", "VP8LPredictors_C"), ie("PredictorAdd", "VP8LPredictorsAdd"), ie("PredictorAdd", "VP8LPredictorsAdd_C"), Zl = ee, Qs = ae, yi = Jt, ci = Nt, bs = Ot, Gr = re, Vr = Zt, E.VP8LMapColor32b = Yo, E.VP8LMapColor8b = tu, c);
    }
    function qi(c, m, k, I, B) {
      var U = 1, W = [c], K = [m], Z = I.m, rt = I.s, yt = null, Pt = 0;
      t: for (; ; ) {
        if (k) for (; U && ct(Z, 1); ) {
          var Lt = W, At = K, Ht = I, Ft = 1, bt = Ht.m, _t = Ht.gc[Ht.ab], Ut = ct(bt, 2);
          if (Ht.Oc & 1 << Ut) U = 0;
          else {
            switch (Ht.Oc |= 1 << Ut, _t.hc = Ut, _t.Ea = Lt[0], _t.nc = At[0], _t.K = [null], ++Ht.ab, t(4 >= Ht.ab), Ut) {
              case 0:
              case 1:
                _t.b = ct(bt, 3) + 2, Ft = qi(J(_t.Ea, _t.b), J(_t.nc, _t.b), 0, Ht, _t.K), _t.K = _t.K[0];
                break;
              case 3:
                var Gt, Wt = ct(bt, 8) + 1, ce = 16 < Wt ? 0 : 4 < Wt ? 1 : 2 < Wt ? 2 : 3;
                if (Lt[0] = J(_t.Ea, ce), _t.b = ce, Gt = Ft = qi(Wt, 1, 0, Ht, _t.K)) {
                  var ne, xe = Wt, se = _t, Xe = 1 << (8 >> se.b), tn = s(Xe);
                  if (tn == null) Gt = 0;
                  else {
                    var He = se.K[0], je = se.w;
                    for (tn[0] = se.K[0][0], ne = 1; ne < 1 * xe; ++ne) tn[ne] = st(He[je + ne], tn[ne - 1]);
                    for (; ne < 4 * Xe; ++ne) tn[ne] = 0;
                    se.K[0] = null, se.K[0] = tn, Gt = 1;
                  }
                }
                Ft = Gt;
                break;
              case 2:
                break;
              default:
                t(0);
            }
            U = Ft;
          }
        }
        if (W = W[0], K = K[0], U && ct(Z, 1) && !(U = 1 <= (Pt = ct(Z, 4)) && 11 >= Pt)) {
          I.a = 3;
          break t;
        }
        var on;
        if (on = U) e: {
          var rn, Fe, En, bi = I, On = W, vi = K, en = Pt, Oi = k, Ti = bi.m, zn = bi.s, Yn = [null], fi = 1, Ki = 0, kr = Gm[en];
          n: for (; ; ) {
            if (Oi && ct(Ti, 1)) {
              var $n = ct(Ti, 3) + 2, Jr = J(On, $n), ro = J(vi, $n), Qo = Jr * ro;
              if (!qi(Jr, ro, 0, bi, Yn)) break n;
              for (Yn = Yn[0], zn.xc = $n, rn = 0; rn < Qo; ++rn) {
                var Ss = Yn[rn] >> 8 & 65535;
                Yn[rn] = Ss, Ss >= fi && (fi = Ss + 1);
              }
            }
            if (Ti.h) break n;
            for (Fe = 0; 5 > Fe; ++Fe) {
              var wn = Gd[Fe];
              !Fe && 0 < en && (wn += 1 << en), Ki < wn && (Ki = wn);
            }
            var lh = o(fi * kr, S), ip = fi, rp = o(ip, x);
            if (rp == null) var fu = null;
            else t(65536 >= ip), fu = rp;
            var il = s(Ki);
            if (fu == null || il == null || lh == null) {
              bi.a = 1;
              break n;
            }
            var du = lh;
            for (rn = En = 0; rn < fi; ++rn) {
              var lr = fu[rn], ta = lr.G, ea = lr.H, sp = 0, pu = 1, op = 0;
              for (Fe = 0; 5 > Fe; ++Fe) {
                wn = Gd[Fe], ta[Fe] = du, ea[Fe] = En, !Fe && 0 < en && (wn += 1 << en);
                r: {
                  var gu, uh = wn, mu = bi, rl = il, d2 = du, p2 = En, ch = 0, ks = mu.m, g2 = ct(ks, 1);
                  if (r(rl, 0, 0, uh), g2) {
                    var m2 = ct(ks, 1) + 1, y2 = ct(ks, 1), ap = ct(ks, y2 == 0 ? 1 : 8);
                    rl[ap] = 1, m2 == 2 && (rl[ap = ct(ks, 8)] = 1);
                    var yu = 1;
                  } else {
                    var lp = s(19), up = ct(ks, 4) + 4;
                    if (19 < up) {
                      mu.a = 3;
                      var bu = 0;
                      break r;
                    }
                    for (gu = 0; gu < up; ++gu) lp[Wm[gu]] = ct(ks, 3);
                    var hh = void 0, sl = void 0, cp = mu, b2 = lp, vu = uh, hp = rl, fh = 0, As = cp.m, fp = 8, dp = o(128, S);
                    i: for (; N(dp, 0, 7, b2, 19); ) {
                      if (ct(As, 1)) {
                        var v2 = 2 + 2 * ct(As, 3);
                        if ((hh = 2 + ct(As, v2)) > vu) break i;
                      } else hh = vu;
                      for (sl = 0; sl < vu && hh--; ) {
                        ot(As);
                        var pp = dp[0 + (127 & z(As))];
                        Y(As, As.u + pp.g);
                        var na = pp.value;
                        if (16 > na) hp[sl++] = na, na != 0 && (fp = na);
                        else {
                          var w2 = na == 16, gp = na - 16, x2 = $m[gp], mp = ct(As, zm[gp]) + x2;
                          if (sl + mp > vu) break i;
                          for (var _2 = w2 ? fp : 0; 0 < mp--; ) hp[sl++] = _2;
                        }
                      }
                      fh = 1;
                      break i;
                    }
                    fh || (cp.a = 3), yu = fh;
                  }
                  (yu = yu && !ks.h) && (ch = N(d2, p2, 8, rl, uh)), yu && ch != 0 ? bu = ch : (mu.a = 3, bu = 0);
                }
                if (bu == 0) break n;
                if (pu && Um[Fe] == 1 && (pu = du[En].g == 0), sp += du[En].g, En += bu, 3 >= Fe) {
                  var ol, dh = il[0];
                  for (ol = 1; ol < wn; ++ol) il[ol] > dh && (dh = il[ol]);
                  op += dh;
                }
              }
              if (lr.nd = pu, lr.Qb = 0, pu && (lr.qb = (ta[3][ea[3] + 0].value << 24 | ta[1][ea[1] + 0].value << 16 | ta[2][ea[2] + 0].value) >>> 0, sp == 0 && 256 > ta[0][ea[0] + 0].value && (lr.Qb = 1, lr.qb += ta[0][ea[0] + 0].value << 8)), lr.jc = !lr.Qb && 6 > op, lr.jc) {
                var wu, Zr = lr;
                for (wu = 0; wu < Vn; ++wu) {
                  var Ns = wu, Cs = Zr.pd[Ns], xu = Zr.G[0][Zr.H[0] + Ns];
                  256 <= xu.value ? (Cs.g = xu.g + 256, Cs.value = xu.value) : (Cs.g = 0, Cs.value = 0, Ns >>= yn(xu, 8, Cs), Ns >>= yn(Zr.G[1][Zr.H[1] + Ns], 16, Cs), Ns >>= yn(Zr.G[2][Zr.H[2] + Ns], 0, Cs), yn(Zr.G[3][Zr.H[3] + Ns], 24, Cs));
                }
              }
            }
            zn.vc = Yn, zn.Wb = fi, zn.Ya = fu, zn.yc = lh, on = 1;
            break e;
          }
          on = 0;
        }
        if (!(U = on)) {
          I.a = 3;
          break t;
        }
        if (0 < Pt) {
          if (rt.ua = 1 << Pt, !F(rt.Wa, Pt)) {
            I.a = 1, U = 0;
            break t;
          }
        } else rt.ua = 0;
        var ph = I, yp = W, S2 = K, gh = ph.s, mh = gh.xc;
        if (ph.c = yp, ph.i = S2, gh.md = J(yp, mh), gh.wc = mh == 0 ? -1 : (1 << mh) - 1, k) {
          I.xb = t2;
          break t;
        }
        if ((yt = s(W * K)) == null) {
          I.a = 1, U = 0;
          break t;
        }
        U = (U = Ni(I, yt, 0, W, K, K, null)) && !Z.h;
        break t;
      }
      return U ? (B != null ? B[0] = yt : (t(yt == null), t(k)), I.$ = 0, k || ji(rt)) : ji(rt), U;
    }
    function xr(c, m) {
      var k = c.c * c.i, I = k + m + 16 * m;
      return t(c.c <= m), c.V = s(I), c.V == null ? (c.Ta = null, c.Ua = 0, c.a = 1, 0) : (c.Ta = c.V, c.Ua = c.Ba + k + m, 1);
    }
    function Br(c, m) {
      var k = c.C, I = m - k, B = c.V, U = c.Ba + c.c * k;
      for (t(m <= c.l.o); 0 < I; ) {
        var W = 16 < I ? 16 : I, K = c.l.ma, Z = c.l.width, rt = Z * W, yt = K.ca, Pt = K.tb + Z * k, Lt = c.Ta, At = c.Ua;
        ui(c, W, B, U), kn(Lt, At, yt, Pt, rt), gi(K, k, k + W, yt, Pt, Z), I -= W, B += W * c.c, k += W;
      }
      t(k == m), c.C = c.Ma = m;
    }
    function rr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function jr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function qr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function zr() {
      this.Yb = function() {
        var c = [];
        return function m(k, I, B) {
          for (var U = B[I], W = 0; W < U && (k.push(B.length > I + 1 ? [] : 0), !(B.length < I + 1)); W++) m(k[W], I + 1, B);
        }(c, 0, [3, 11]), c;
      }();
    }
    function as() {
      this.jb = s(3), this.Wc = a([4, 8], zr), this.Xc = a([4, 17], zr);
    }
    function Eo() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function ls() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Oo() {
      this.Na = this.la = 0;
    }
    function us() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Hs() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function $r() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new ls()), this.Y = 0, this.ya = Array(new Hs()), this.aa = 0, this.l = new cs();
    }
    function To() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Ea() {
      this.cb = this.a = 0, this.sc = "", this.m = new it(), this.Od = new rr(), this.Kc = new jr(), this.ed = new Eo(), this.Qa = new qr(), this.Ic = this.$c = this.Aa = 0, this.D = new $r(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o(8, it), this.ia = 0, this.pb = o(4, us), this.Pa = new as(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new To()), this.Hd = 0, this.rb = Array(new Oo()), this.sb = 0, this.wa = Array(new ls()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Hs()), this.L = this.aa = 0, this.gd = a([4, 2], ls), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function cs() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Oa() {
      var c = new Ea();
      return c != null && (c.a = 0, c.sc = "OK", c.cb = 0, c.Xb = 0, el || (el = Mo)), c;
    }
    function pn(c, m, k) {
      return c.a == 0 && (c.a = m, c.sc = k, c.cb = 0), 0;
    }
    function Fo(c, m, k) {
      return 3 <= k && c[m + 0] == 157 && c[m + 1] == 1 && c[m + 2] == 42;
    }
    function Gs(c, m) {
      if (c == null) return 0;
      if (c.a = 0, c.sc = "OK", m == null) return pn(c, 2, "null VP8Io passed to VP8GetHeaders()");
      var k = m.data, I = m.w, B = m.ha;
      if (4 > B) return pn(c, 7, "Truncated header.");
      var U = k[I + 0] | k[I + 1] << 8 | k[I + 2] << 16, W = c.Od;
      if (W.Rb = !(1 & U), W.td = U >> 1 & 7, W.yd = U >> 4 & 1, W.ub = U >> 5, 3 < W.td) return pn(c, 3, "Incorrect keyframe parameters.");
      if (!W.yd) return pn(c, 4, "Frame not displayable.");
      I += 3, B -= 3;
      var K = c.Kc;
      if (W.Rb) {
        if (7 > B) return pn(c, 7, "cannot parse picture header");
        if (!Fo(k, I, B)) return pn(c, 3, "Bad code word");
        K.c = 16383 & (k[I + 4] << 8 | k[I + 3]), K.Td = k[I + 4] >> 6, K.i = 16383 & (k[I + 6] << 8 | k[I + 5]), K.Ud = k[I + 6] >> 6, I += 7, B -= 7, c.za = K.c + 15 >> 4, c.Ub = K.i + 15 >> 4, m.width = K.c, m.height = K.i, m.Da = 0, m.j = 0, m.v = 0, m.va = m.width, m.o = m.height, m.da = 0, m.ib = m.width, m.hb = m.height, m.U = m.width, m.T = m.height, r((U = c.Pa).jb, 0, 255, U.jb.length), t((U = c.Qa) != null), U.Cb = 0, U.Bb = 0, U.Fb = 1, r(U.Zb, 0, 0, U.Zb.length), r(U.Lb, 0, 0, U.Lb);
      }
      if (W.ub > B) return pn(c, 7, "bad partition length");
      X(U = c.m, k, I, W.ub), I += W.ub, B -= W.ub, W.Rb && (K.Ld = gt(U), K.Kd = gt(U)), K = c.Qa;
      var Z, rt = c.Pa;
      if (t(U != null), t(K != null), K.Cb = gt(U), K.Cb) {
        if (K.Bb = gt(U), gt(U)) {
          for (K.Fb = gt(U), Z = 0; 4 > Z; ++Z) K.Zb[Z] = gt(U) ? D(U, 7) : 0;
          for (Z = 0; 4 > Z; ++Z) K.Lb[Z] = gt(U) ? D(U, 6) : 0;
        }
        if (K.Bb) for (Z = 0; 3 > Z; ++Z) rt.jb[Z] = gt(U) ? V(U, 8) : 255;
      } else K.Bb = 0;
      if (U.Ka) return pn(c, 3, "cannot parse segment header");
      if ((K = c.ed).zd = gt(U), K.Tb = V(U, 6), K.wb = V(U, 3), K.Pc = gt(U), K.Pc && gt(U)) {
        for (rt = 0; 4 > rt; ++rt) gt(U) && (K.vd[rt] = D(U, 6));
        for (rt = 0; 4 > rt; ++rt) gt(U) && (K.od[rt] = D(U, 6));
      }
      if (c.L = K.Tb == 0 ? 0 : K.zd ? 1 : 2, U.Ka) return pn(c, 3, "cannot parse filter header");
      var yt = B;
      if (B = Z = I, I = Z + yt, K = yt, c.Xb = (1 << V(c.m, 2)) - 1, yt < 3 * (rt = c.Xb)) k = 7;
      else {
        for (Z += 3 * rt, K -= 3 * rt, yt = 0; yt < rt; ++yt) {
          var Pt = k[B + 0] | k[B + 1] << 8 | k[B + 2] << 16;
          Pt > K && (Pt = K), X(c.Jc[+yt], k, Z, Pt), Z += Pt, K -= Pt, B += 3;
        }
        X(c.Jc[+rt], k, Z, K), k = Z < I ? 0 : 5;
      }
      if (k != 0) return pn(c, k, "cannot parse partitions");
      for (k = V(Z = c.m, 7), B = gt(Z) ? D(Z, 4) : 0, I = gt(Z) ? D(Z, 4) : 0, K = gt(Z) ? D(Z, 4) : 0, rt = gt(Z) ? D(Z, 4) : 0, Z = gt(Z) ? D(Z, 4) : 0, yt = c.Qa, Pt = 0; 4 > Pt; ++Pt) {
        if (yt.Cb) {
          var Lt = yt.Zb[Pt];
          yt.Fb || (Lt += k);
        } else {
          if (0 < Pt) {
            c.pb[Pt] = c.pb[0];
            continue;
          }
          Lt = k;
        }
        var At = c.pb[Pt];
        At.Sc[0] = sh[Ii(Lt + B, 127)], At.Sc[1] = oh[Ii(Lt + 0, 127)], At.Eb[0] = 2 * sh[Ii(Lt + I, 127)], At.Eb[1] = 101581 * oh[Ii(Lt + K, 127)] >> 16, 8 > At.Eb[1] && (At.Eb[1] = 8), At.Qc[0] = sh[Ii(Lt + rt, 117)], At.Qc[1] = oh[Ii(Lt + Z, 127)], At.lc = Lt + Z;
      }
      if (!W.Rb) return pn(c, 4, "Not a key frame.");
      for (gt(U), W = c.Pa, k = 0; 4 > k; ++k) {
        for (B = 0; 8 > B; ++B) for (I = 0; 3 > I; ++I) for (K = 0; 11 > K; ++K) rt = wt(U, Zm[k][B][I][K]) ? V(U, 8) : Xm[k][B][I][K], W.Wc[k][B].Yb[I][K] = rt;
        for (B = 0; 17 > B; ++B) W.Xc[k][B] = W.Wc[k][Qm[B]];
      }
      return c.kc = gt(U), c.kc && (c.Bd = V(U, 8)), c.cb = 1;
    }
    function Mo(c, m, k, I, B, U, W) {
      var K = m[B].Yb[k];
      for (k = 0; 16 > B; ++B) {
        if (!wt(c, K[k + 0])) return B;
        for (; !wt(c, K[k + 1]); ) if (K = m[++B].Yb[0], k = 0, B == 16) return 16;
        var Z = m[B + 1].Yb;
        if (wt(c, K[k + 2])) {
          var rt = c, yt = 0;
          if (wt(rt, (Lt = K)[(Pt = k) + 3])) if (wt(rt, Lt[Pt + 6])) {
            for (K = 0, Pt = 2 * (yt = wt(rt, Lt[Pt + 8])) + (Lt = wt(rt, Lt[Pt + 9 + yt])), yt = 0, Lt = Ym[Pt]; Lt[K]; ++K) yt += yt + wt(rt, Lt[K]);
            yt += 3 + (8 << Pt);
          } else wt(rt, Lt[Pt + 7]) ? (yt = 7 + 2 * wt(rt, 165), yt += wt(rt, 145)) : yt = 5 + wt(rt, 159);
          else yt = wt(rt, Lt[Pt + 4]) ? 3 + wt(rt, Lt[Pt + 5]) : 2;
          K = Z[2];
        } else yt = 1, K = Z[1];
        Z = W + Km[B], 0 > (rt = c).b && xt(rt);
        var Pt, Lt = rt.b, At = (Pt = rt.Ca >> 1) - (rt.I >> Lt) >> 31;
        --rt.b, rt.Ca += At, rt.Ca |= 1, rt.I -= (Pt + 1 & At) << Lt, U[Z] = ((yt ^ At) - At) * I[(0 < B) + 0];
      }
      return 16;
    }
    function Vs(c) {
      var m = c.rb[c.sb - 1];
      m.la = 0, m.Na = 0, r(c.zc, 0, 0, c.zc.length), c.ja = 0;
    }
    function zi(c, m) {
      if (c == null) return 0;
      if (m == null) return pn(c, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!c.cb && !Gs(c, m)) return 0;
      if (t(c.cb), m.ac == null || m.ac(m)) {
        m.ob && (c.L = 0);
        var k = hu[c.L];
        if (c.L == 2 ? (c.yb = 0, c.zb = 0) : (c.yb = m.v - k >> 4, c.zb = m.j - k >> 4, 0 > c.yb && (c.yb = 0), 0 > c.zb && (c.zb = 0)), c.Va = m.o + 15 + k >> 4, c.Hb = m.va + 15 + k >> 4, c.Hb > c.za && (c.Hb = c.za), c.Va > c.Ub && (c.Va = c.Ub), 0 < c.L) {
          var I = c.ed;
          for (k = 0; 4 > k; ++k) {
            var B;
            if (c.Qa.Cb) {
              var U = c.Qa.Lb[k];
              c.Qa.Fb || (U += I.Tb);
            } else U = I.Tb;
            for (B = 0; 1 >= B; ++B) {
              var W = c.gd[k][B], K = U;
              if (I.Pc && (K += I.vd[0], B && (K += I.od[0])), 0 < (K = 0 > K ? 0 : 63 < K ? 63 : K)) {
                var Z = K;
                0 < I.wb && (Z = 4 < I.wb ? Z >> 2 : Z >> 1) > 9 - I.wb && (Z = 9 - I.wb), 1 > Z && (Z = 1), W.dd = Z, W.tc = 2 * K + Z, W.ld = 40 <= K ? 2 : 15 <= K ? 1 : 0;
              } else W.tc = 0;
              W.La = B;
            }
          }
        }
        k = 0;
      } else pn(c, 6, "Frame setup failed"), k = c.a;
      if (k = k == 0) {
        if (k) {
          c.$c = 0, 0 < c.Aa || (c.Ic = f2);
          t: {
            k = c.Ic, I = 4 * (Z = c.za);
            var rt = 32 * Z, yt = Z + 1, Pt = 0 < c.L ? Z * (0 < c.Aa ? 2 : 1) : 0, Lt = (c.Aa == 2 ? 2 : 1) * Z;
            if ((W = I + 832 + (B = 3 * (16 * k + hu[c.L]) / 2 * rt) + (U = c.Fa != null && 0 < c.Fa.length ? c.Kc.c * c.Kc.i : 0)) != W) k = 0;
            else {
              if (W > c.Vb) {
                if (c.Vb = 0, c.Ec = s(W), c.Fc = 0, c.Ec == null) {
                  k = pn(c, 1, "no memory during frame initialization.");
                  break t;
                }
                c.Vb = W;
              }
              W = c.Ec, K = c.Fc, c.Ac = W, c.Bc = K, K += I, c.Gd = o(rt, To), c.Hd = 0, c.rb = o(yt + 1, Oo), c.sb = 1, c.wa = Pt ? o(Pt, ls) : null, c.Y = 0, c.D.Nb = 0, c.D.wa = c.wa, c.D.Y = c.Y, 0 < c.Aa && (c.D.Y += Z), t(!0), c.oc = W, c.pc = K, K += 832, c.ya = o(Lt, Hs), c.aa = 0, c.D.ya = c.ya, c.D.aa = c.aa, c.Aa == 2 && (c.D.aa += Z), c.R = 16 * Z, c.B = 8 * Z, Z = (rt = hu[c.L]) * c.R, rt = rt / 2 * c.B, c.sa = W, c.ta = K + Z, c.qa = c.sa, c.ra = c.ta + 16 * k * c.R + rt, c.Ha = c.qa, c.Ia = c.ra + 8 * k * c.B + rt, c.$c = 0, K += B, c.mb = U ? W : null, c.nb = U ? K : null, t(K + U <= c.Fc + c.Vb), Vs(c), r(c.Ac, c.Bc, 0, I), k = 1;
            }
          }
          if (k) {
            if (m.ka = 0, m.y = c.sa, m.O = c.ta, m.f = c.qa, m.N = c.ra, m.ea = c.Ha, m.Vd = c.Ia, m.fa = c.R, m.Rc = c.B, m.F = null, m.J = 0, !nu) {
              for (k = -255; 255 >= k; ++k) Mn[255 + k] = 0 > k ? -k : k;
              for (k = -1020; 1020 >= k; ++k) Kr[1020 + k] = -128 > k ? -128 : 127 < k ? 127 : k;
              for (k = -112; 112 >= k; ++k) tl[112 + k] = -16 > k ? -16 : 15 < k ? 15 : k;
              for (k = -255; 510 >= k; ++k) Zo[255 + k] = 0 > k ? 0 : 255 < k ? 255 : k;
              nu = 1;
            }
            Ko = Q, Yr = Ro, Ja = Do, hi = Ta, Wi = Bo, Sn = Ur, Xo = Ba, eu = Js, Za = Jc, to = ja, eo = Xc, vs = qo, no = qa, Jo = Kl, io = Yl, ws = _r, Qa = Hr, Hi = Kc, ar[0] = $i, ar[1] = dt, ar[2] = Li, ar[3] = Fa, ar[4] = ds, ar[5] = Wr, ar[6] = Ys, ar[7] = Ma, ar[8] = Gc, ar[9] = Hc, xs[0] = ln, xs[1] = Mt, xs[2] = pe, xs[3] = me, xs[4] = Be, xs[5] = Ie, xs[6] = $e, Xr[0] = ps, Xr[1] = Bt, Xr[2] = Vc, Xr[3] = Ra, Xr[4] = Xs, Xr[5] = Yc, Xr[6] = Da, k = 1;
          } else k = 0;
        }
        k && (k = function(At, Ht) {
          for (At.M = 0; At.M < At.Va; ++At.M) {
            var Ft, bt = At.Jc[At.M & At.Xb], _t = At.m, Ut = At;
            for (Ft = 0; Ft < Ut.za; ++Ft) {
              var Gt = _t, Wt = Ut, ce = Wt.Ac, ne = Wt.Bc + 4 * Ft, xe = Wt.zc, se = Wt.ya[Wt.aa + Ft];
              if (Wt.Qa.Bb ? se.$b = wt(Gt, Wt.Pa.jb[0]) ? 2 + wt(Gt, Wt.Pa.jb[2]) : wt(Gt, Wt.Pa.jb[1]) : se.$b = 0, Wt.kc && (se.Ad = wt(Gt, Wt.Bd)), se.Za = !wt(Gt, 145) + 0, se.Za) {
                var Xe = se.Ob, tn = 0;
                for (Wt = 0; 4 > Wt; ++Wt) {
                  var He, je = xe[0 + Wt];
                  for (He = 0; 4 > He; ++He) {
                    je = Jm[ce[ne + He]][je];
                    for (var on = Vd[wt(Gt, je[0])]; 0 < on; ) on = Vd[2 * on + wt(Gt, je[on])];
                    je = -on, ce[ne + He] = je;
                  }
                  i(Xe, tn, ce, ne, 4), tn += 4, xe[0 + Wt] = je;
                }
              } else je = wt(Gt, 156) ? wt(Gt, 128) ? 1 : 3 : wt(Gt, 163) ? 2 : 0, se.Ob[0] = je, r(ce, ne, je, 4), r(xe, 0, je, 4);
              se.Dd = wt(Gt, 142) ? wt(Gt, 114) ? wt(Gt, 183) ? 1 : 3 : 2 : 0;
            }
            if (Ut.m.Ka) return pn(At, 7, "Premature end-of-partition0 encountered.");
            for (; At.ja < At.za; ++At.ja) {
              if (Ut = bt, Gt = (_t = At).rb[_t.sb - 1], ce = _t.rb[_t.sb + _t.ja], Ft = _t.ya[_t.aa + _t.ja], ne = _t.kc ? Ft.Ad : 0) Gt.la = ce.la = 0, Ft.Za || (Gt.Na = ce.Na = 0), Ft.Hc = 0, Ft.Gc = 0, Ft.ia = 0;
              else {
                var rn, Fe;
                if (Gt = ce, ce = Ut, ne = _t.Pa.Xc, xe = _t.ya[_t.aa + _t.ja], se = _t.pb[xe.$b], Wt = xe.ad, Xe = 0, tn = _t.rb[_t.sb - 1], je = He = 0, r(Wt, Xe, 0, 384), xe.Za) var En = 0, bi = ne[3];
                else {
                  on = s(16);
                  var On = Gt.Na + tn.Na;
                  if (On = el(ce, ne[1], On, se.Eb, 0, on, 0), Gt.Na = tn.Na = (0 < On) + 0, 1 < On) Ko(on, 0, Wt, Xe);
                  else {
                    var vi = on[0] + 3 >> 3;
                    for (on = 0; 256 > on; on += 16) Wt[Xe + on] = vi;
                  }
                  En = 1, bi = ne[0];
                }
                var en = 15 & Gt.la, Oi = 15 & tn.la;
                for (on = 0; 4 > on; ++on) {
                  var Ti = 1 & Oi;
                  for (vi = Fe = 0; 4 > vi; ++vi) en = en >> 1 | (Ti = (On = el(ce, bi, On = Ti + (1 & en), se.Sc, En, Wt, Xe)) > En) << 7, Fe = Fe << 2 | (3 < On ? 3 : 1 < On ? 2 : Wt[Xe + 0] != 0), Xe += 16;
                  en >>= 4, Oi = Oi >> 1 | Ti << 7, He = (He << 8 | Fe) >>> 0;
                }
                for (bi = en, En = Oi >> 4, rn = 0; 4 > rn; rn += 2) {
                  for (Fe = 0, en = Gt.la >> 4 + rn, Oi = tn.la >> 4 + rn, on = 0; 2 > on; ++on) {
                    for (Ti = 1 & Oi, vi = 0; 2 > vi; ++vi) On = Ti + (1 & en), en = en >> 1 | (Ti = 0 < (On = el(ce, ne[2], On, se.Qc, 0, Wt, Xe))) << 3, Fe = Fe << 2 | (3 < On ? 3 : 1 < On ? 2 : Wt[Xe + 0] != 0), Xe += 16;
                    en >>= 2, Oi = Oi >> 1 | Ti << 5;
                  }
                  je |= Fe << 4 * rn, bi |= en << 4 << rn, En |= (240 & Oi) << rn;
                }
                Gt.la = bi, tn.la = En, xe.Hc = He, xe.Gc = je, xe.ia = 43690 & je ? 0 : se.ia, ne = !(He | je);
              }
              if (0 < _t.L && (_t.wa[_t.Y + _t.ja] = _t.gd[Ft.$b][Ft.Za], _t.wa[_t.Y + _t.ja].La |= !ne), Ut.Ka) return pn(At, 7, "Premature end-of-file encountered.");
            }
            if (Vs(At), _t = Ht, Ut = 1, Ft = (bt = At).D, Gt = 0 < bt.L && bt.M >= bt.zb && bt.M <= bt.Va, bt.Aa == 0) t: {
              if (Ft.M = bt.M, Ft.uc = Gt, Ga(bt, Ft), Ut = 1, Ft = (Fe = bt.D).Nb, Gt = (je = hu[bt.L]) * bt.R, ce = je / 2 * bt.B, on = 16 * Ft * bt.R, vi = 8 * Ft * bt.B, ne = bt.sa, xe = bt.ta - Gt + on, se = bt.qa, Wt = bt.ra - ce + vi, Xe = bt.Ha, tn = bt.Ia - ce + vi, Oi = (en = Fe.M) == 0, He = en >= bt.Va - 1, bt.Aa == 2 && Ga(bt, Fe), Fe.uc) for (Ti = (On = bt).D.M, t(On.D.uc), Fe = On.yb; Fe < On.Hb; ++Fe) {
                En = Fe, bi = Ti;
                var zn = (Yn = (wn = On).D).Nb;
                rn = wn.R;
                var Yn = Yn.wa[Yn.Y + En], fi = wn.sa, Ki = wn.ta + 16 * zn * rn + 16 * En, kr = Yn.dd, $n = Yn.tc;
                if ($n != 0) if (t(3 <= $n), wn.L == 1) 0 < En && ws(fi, Ki, rn, $n + 4), Yn.La && Hi(fi, Ki, rn, $n), 0 < bi && io(fi, Ki, rn, $n + 4), Yn.La && Qa(fi, Ki, rn, $n);
                else {
                  var Jr = wn.B, ro = wn.qa, Qo = wn.ra + 8 * zn * Jr + 8 * En, Ss = wn.Ha, wn = wn.Ia + 8 * zn * Jr + 8 * En;
                  zn = Yn.ld, 0 < En && (eu(fi, Ki, rn, $n + 4, kr, zn), to(ro, Qo, Ss, wn, Jr, $n + 4, kr, zn)), Yn.La && (vs(fi, Ki, rn, $n, kr, zn), Jo(ro, Qo, Ss, wn, Jr, $n, kr, zn)), 0 < bi && (Xo(fi, Ki, rn, $n + 4, kr, zn), Za(ro, Qo, Ss, wn, Jr, $n + 4, kr, zn)), Yn.La && (eo(fi, Ki, rn, $n, kr, zn), no(ro, Qo, Ss, wn, Jr, $n, kr, zn));
                }
              }
              if (bt.ia && alert("todo:DitherRow"), _t.put != null) {
                if (Fe = 16 * en, en = 16 * (en + 1), Oi ? (_t.y = bt.sa, _t.O = bt.ta + on, _t.f = bt.qa, _t.N = bt.ra + vi, _t.ea = bt.Ha, _t.W = bt.Ia + vi) : (Fe -= je, _t.y = ne, _t.O = xe, _t.f = se, _t.N = Wt, _t.ea = Xe, _t.W = tn), He || (en -= je), en > _t.o && (en = _t.o), _t.F = null, _t.J = null, bt.Fa != null && 0 < bt.Fa.length && Fe < en && (_t.J = Wa(bt, _t, Fe, en - Fe), _t.F = bt.mb, _t.F == null && _t.F.length == 0)) {
                  Ut = pn(bt, 3, "Could not decode alpha data.");
                  break t;
                }
                Fe < _t.j && (je = _t.j - Fe, Fe = _t.j, t(!(1 & je)), _t.O += bt.R * je, _t.N += bt.B * (je >> 1), _t.W += bt.B * (je >> 1), _t.F != null && (_t.J += _t.width * je)), Fe < en && (_t.O += _t.v, _t.N += _t.v >> 1, _t.W += _t.v >> 1, _t.F != null && (_t.J += _t.v), _t.ka = Fe - _t.j, _t.U = _t.va - _t.v, _t.T = en - Fe, Ut = _t.put(_t));
              }
              Ft + 1 != bt.Ic || He || (i(bt.sa, bt.ta - Gt, ne, xe + 16 * bt.R, Gt), i(bt.qa, bt.ra - ce, se, Wt + 8 * bt.B, ce), i(bt.Ha, bt.Ia - ce, Xe, tn + 8 * bt.B, ce));
            }
            if (!Ut) return pn(At, 6, "Output aborted.");
          }
          return 1;
        }(c, m)), m.bc != null && m.bc(m), k &= 1;
      }
      return k ? (c.cb = 0, k) : 0;
    }
    function Pi(c, m, k, I, B) {
      B = c[m + k + 32 * I] + (B >> 3), c[m + k + 32 * I] = -256 & B ? 0 > B ? 0 : 255 : B;
    }
    function hs(c, m, k, I, B, U) {
      Pi(c, m, 0, k, I + B), Pi(c, m, 1, k, I + U), Pi(c, m, 2, k, I - U), Pi(c, m, 3, k, I - B);
    }
    function Gn(c) {
      return (20091 * c >> 16) + c;
    }
    function fs(c, m, k, I) {
      var B, U = 0, W = s(16);
      for (B = 0; 4 > B; ++B) {
        var K = c[m + 0] + c[m + 8], Z = c[m + 0] - c[m + 8], rt = (35468 * c[m + 4] >> 16) - Gn(c[m + 12]), yt = Gn(c[m + 4]) + (35468 * c[m + 12] >> 16);
        W[U + 0] = K + yt, W[U + 1] = Z + rt, W[U + 2] = Z - rt, W[U + 3] = K - yt, U += 4, m++;
      }
      for (B = U = 0; 4 > B; ++B) K = (c = W[U + 0] + 4) + W[U + 8], Z = c - W[U + 8], rt = (35468 * W[U + 4] >> 16) - Gn(W[U + 12]), Pi(k, I, 0, 0, K + (yt = Gn(W[U + 4]) + (35468 * W[U + 12] >> 16))), Pi(k, I, 1, 0, Z + rt), Pi(k, I, 2, 0, Z - rt), Pi(k, I, 3, 0, K - yt), U++, I += 32;
    }
    function Ur(c, m, k, I) {
      var B = c[m + 0] + 4, U = 35468 * c[m + 4] >> 16, W = Gn(c[m + 4]), K = 35468 * c[m + 1] >> 16;
      hs(k, I, 0, B + W, c = Gn(c[m + 1]), K), hs(k, I, 1, B + U, c, K), hs(k, I, 2, B - U, c, K), hs(k, I, 3, B - W, c, K);
    }
    function Ro(c, m, k, I, B) {
      fs(c, m, k, I), B && fs(c, m + 16, k, I + 4);
    }
    function Do(c, m, k, I) {
      Yr(c, m + 0, k, I, 1), Yr(c, m + 32, k, I + 128, 1);
    }
    function Ta(c, m, k, I) {
      var B;
      for (c = c[m + 0] + 4, B = 0; 4 > B; ++B) for (m = 0; 4 > m; ++m) Pi(k, I, m, B, c);
    }
    function Bo(c, m, k, I) {
      c[m + 0] && hi(c, m + 0, k, I), c[m + 16] && hi(c, m + 16, k, I + 4), c[m + 32] && hi(c, m + 32, k, I + 128), c[m + 48] && hi(c, m + 48, k, I + 128 + 4);
    }
    function Q(c, m, k, I) {
      var B, U = s(16);
      for (B = 0; 4 > B; ++B) {
        var W = c[m + 0 + B] + c[m + 12 + B], K = c[m + 4 + B] + c[m + 8 + B], Z = c[m + 4 + B] - c[m + 8 + B], rt = c[m + 0 + B] - c[m + 12 + B];
        U[0 + B] = W + K, U[8 + B] = W - K, U[4 + B] = rt + Z, U[12 + B] = rt - Z;
      }
      for (B = 0; 4 > B; ++B) W = (c = U[0 + 4 * B] + 3) + U[3 + 4 * B], K = U[1 + 4 * B] + U[2 + 4 * B], Z = U[1 + 4 * B] - U[2 + 4 * B], rt = c - U[3 + 4 * B], k[I + 0] = W + K >> 3, k[I + 16] = rt + Z >> 3, k[I + 32] = W - K >> 3, k[I + 48] = rt - Z >> 3, I += 64;
    }
    function mt(c, m, k) {
      var I, B = m - 32, U = Ei, W = 255 - c[B - 1];
      for (I = 0; I < k; ++I) {
        var K, Z = U, rt = W + c[m - 1];
        for (K = 0; K < k; ++K) c[m + K] = Z[rt + c[B + K]];
        m += 32;
      }
    }
    function dt(c, m) {
      mt(c, m, 4);
    }
    function Bt(c, m) {
      mt(c, m, 8);
    }
    function Mt(c, m) {
      mt(c, m, 16);
    }
    function pe(c, m) {
      var k;
      for (k = 0; 16 > k; ++k) i(c, m + 32 * k, c, m - 32, 16);
    }
    function me(c, m) {
      var k;
      for (k = 16; 0 < k; --k) r(c, m, c[m - 1], 16), m += 32;
    }
    function Ce(c, m, k) {
      var I;
      for (I = 0; 16 > I; ++I) r(m, k + 32 * I, c, 16);
    }
    function ln(c, m) {
      var k, I = 16;
      for (k = 0; 16 > k; ++k) I += c[m - 1 + 32 * k] + c[m + k - 32];
      Ce(I >> 5, c, m);
    }
    function Be(c, m) {
      var k, I = 8;
      for (k = 0; 16 > k; ++k) I += c[m - 1 + 32 * k];
      Ce(I >> 4, c, m);
    }
    function Ie(c, m) {
      var k, I = 8;
      for (k = 0; 16 > k; ++k) I += c[m + k - 32];
      Ce(I >> 4, c, m);
    }
    function $e(c, m) {
      Ce(128, c, m);
    }
    function Kt(c, m, k) {
      return c + 2 * m + k + 2 >> 2;
    }
    function Li(c, m) {
      var k, I = m - 32;
      for (I = new Uint8Array([Kt(c[I - 1], c[I + 0], c[I + 1]), Kt(c[I + 0], c[I + 1], c[I + 2]), Kt(c[I + 1], c[I + 2], c[I + 3]), Kt(c[I + 2], c[I + 3], c[I + 4])]), k = 0; 4 > k; ++k) i(c, m + 32 * k, I, 0, I.length);
    }
    function Fa(c, m) {
      var k = c[m - 1], I = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 + 96];
      qt(c, m + 0, 16843009 * Kt(c[m - 1 - 32], k, I)), qt(c, m + 32, 16843009 * Kt(k, I, B)), qt(c, m + 64, 16843009 * Kt(I, B, U)), qt(c, m + 96, 16843009 * Kt(B, U, U));
    }
    function $i(c, m) {
      var k, I = 4;
      for (k = 0; 4 > k; ++k) I += c[m + k - 32] + c[m - 1 + 32 * k];
      for (I >>= 3, k = 0; 4 > k; ++k) r(c, m + 32 * k, I, 4);
    }
    function ds(c, m) {
      var k = c[m - 1 + 0], I = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 - 32], W = c[m + 0 - 32], K = c[m + 1 - 32], Z = c[m + 2 - 32], rt = c[m + 3 - 32];
      c[m + 0 + 96] = Kt(I, B, c[m - 1 + 96]), c[m + 1 + 96] = c[m + 0 + 64] = Kt(k, I, B), c[m + 2 + 96] = c[m + 1 + 64] = c[m + 0 + 32] = Kt(U, k, I), c[m + 3 + 96] = c[m + 2 + 64] = c[m + 1 + 32] = c[m + 0 + 0] = Kt(W, U, k), c[m + 3 + 64] = c[m + 2 + 32] = c[m + 1 + 0] = Kt(K, W, U), c[m + 3 + 32] = c[m + 2 + 0] = Kt(Z, K, W), c[m + 3 + 0] = Kt(rt, Z, K);
    }
    function Ys(c, m) {
      var k = c[m + 1 - 32], I = c[m + 2 - 32], B = c[m + 3 - 32], U = c[m + 4 - 32], W = c[m + 5 - 32], K = c[m + 6 - 32], Z = c[m + 7 - 32];
      c[m + 0 + 0] = Kt(c[m + 0 - 32], k, I), c[m + 1 + 0] = c[m + 0 + 32] = Kt(k, I, B), c[m + 2 + 0] = c[m + 1 + 32] = c[m + 0 + 64] = Kt(I, B, U), c[m + 3 + 0] = c[m + 2 + 32] = c[m + 1 + 64] = c[m + 0 + 96] = Kt(B, U, W), c[m + 3 + 32] = c[m + 2 + 64] = c[m + 1 + 96] = Kt(U, W, K), c[m + 3 + 64] = c[m + 2 + 96] = Kt(W, K, Z), c[m + 3 + 96] = Kt(K, Z, Z);
    }
    function Wr(c, m) {
      var k = c[m - 1 + 0], I = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 - 32], W = c[m + 0 - 32], K = c[m + 1 - 32], Z = c[m + 2 - 32], rt = c[m + 3 - 32];
      c[m + 0 + 0] = c[m + 1 + 64] = U + W + 1 >> 1, c[m + 1 + 0] = c[m + 2 + 64] = W + K + 1 >> 1, c[m + 2 + 0] = c[m + 3 + 64] = K + Z + 1 >> 1, c[m + 3 + 0] = Z + rt + 1 >> 1, c[m + 0 + 96] = Kt(B, I, k), c[m + 0 + 64] = Kt(I, k, U), c[m + 0 + 32] = c[m + 1 + 96] = Kt(k, U, W), c[m + 1 + 32] = c[m + 2 + 96] = Kt(U, W, K), c[m + 2 + 32] = c[m + 3 + 96] = Kt(W, K, Z), c[m + 3 + 32] = Kt(K, Z, rt);
    }
    function Ma(c, m) {
      var k = c[m + 0 - 32], I = c[m + 1 - 32], B = c[m + 2 - 32], U = c[m + 3 - 32], W = c[m + 4 - 32], K = c[m + 5 - 32], Z = c[m + 6 - 32], rt = c[m + 7 - 32];
      c[m + 0 + 0] = k + I + 1 >> 1, c[m + 1 + 0] = c[m + 0 + 64] = I + B + 1 >> 1, c[m + 2 + 0] = c[m + 1 + 64] = B + U + 1 >> 1, c[m + 3 + 0] = c[m + 2 + 64] = U + W + 1 >> 1, c[m + 0 + 32] = Kt(k, I, B), c[m + 1 + 32] = c[m + 0 + 96] = Kt(I, B, U), c[m + 2 + 32] = c[m + 1 + 96] = Kt(B, U, W), c[m + 3 + 32] = c[m + 2 + 96] = Kt(U, W, K), c[m + 3 + 64] = Kt(W, K, Z), c[m + 3 + 96] = Kt(K, Z, rt);
    }
    function Hc(c, m) {
      var k = c[m - 1 + 0], I = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 + 96];
      c[m + 0 + 0] = k + I + 1 >> 1, c[m + 2 + 0] = c[m + 0 + 32] = I + B + 1 >> 1, c[m + 2 + 32] = c[m + 0 + 64] = B + U + 1 >> 1, c[m + 1 + 0] = Kt(k, I, B), c[m + 3 + 0] = c[m + 1 + 32] = Kt(I, B, U), c[m + 3 + 32] = c[m + 1 + 64] = Kt(B, U, U), c[m + 3 + 64] = c[m + 2 + 64] = c[m + 0 + 96] = c[m + 1 + 96] = c[m + 2 + 96] = c[m + 3 + 96] = U;
    }
    function Gc(c, m) {
      var k = c[m - 1 + 0], I = c[m - 1 + 32], B = c[m - 1 + 64], U = c[m - 1 + 96], W = c[m - 1 - 32], K = c[m + 0 - 32], Z = c[m + 1 - 32], rt = c[m + 2 - 32];
      c[m + 0 + 0] = c[m + 2 + 32] = k + W + 1 >> 1, c[m + 0 + 32] = c[m + 2 + 64] = I + k + 1 >> 1, c[m + 0 + 64] = c[m + 2 + 96] = B + I + 1 >> 1, c[m + 0 + 96] = U + B + 1 >> 1, c[m + 3 + 0] = Kt(K, Z, rt), c[m + 2 + 0] = Kt(W, K, Z), c[m + 1 + 0] = c[m + 3 + 32] = Kt(k, W, K), c[m + 1 + 32] = c[m + 3 + 64] = Kt(I, k, W), c[m + 1 + 64] = c[m + 3 + 96] = Kt(B, I, k), c[m + 1 + 96] = Kt(U, B, I);
    }
    function Vc(c, m) {
      var k;
      for (k = 0; 8 > k; ++k) i(c, m + 32 * k, c, m - 32, 8);
    }
    function Ra(c, m) {
      var k;
      for (k = 0; 8 > k; ++k) r(c, m, c[m - 1], 8), m += 32;
    }
    function Ks(c, m, k) {
      var I;
      for (I = 0; 8 > I; ++I) r(m, k + 32 * I, c, 8);
    }
    function ps(c, m) {
      var k, I = 8;
      for (k = 0; 8 > k; ++k) I += c[m + k - 32] + c[m - 1 + 32 * k];
      Ks(I >> 4, c, m);
    }
    function Yc(c, m) {
      var k, I = 4;
      for (k = 0; 8 > k; ++k) I += c[m + k - 32];
      Ks(I >> 3, c, m);
    }
    function Xs(c, m) {
      var k, I = 4;
      for (k = 0; 8 > k; ++k) I += c[m - 1 + 32 * k];
      Ks(I >> 3, c, m);
    }
    function Da(c, m) {
      Ks(128, c, m);
    }
    function jo(c, m, k) {
      var I = c[m - k], B = c[m + 0], U = 3 * (B - I) + th[1020 + c[m - 2 * k] - c[m + k]], W = iu[112 + (U + 4 >> 3)];
      c[m - k] = Ei[255 + I + iu[112 + (U + 3 >> 3)]], c[m + 0] = Ei[255 + B - W];
    }
    function Hl(c, m, k, I) {
      var B = c[m + 0], U = c[m + k];
      return Vi[255 + c[m - 2 * k] - c[m - k]] > I || Vi[255 + U - B] > I;
    }
    function Gl(c, m, k, I) {
      return 4 * Vi[255 + c[m - k] - c[m + 0]] + Vi[255 + c[m - 2 * k] - c[m + k]] <= I;
    }
    function Vl(c, m, k, I, B) {
      var U = c[m - 3 * k], W = c[m - 2 * k], K = c[m - k], Z = c[m + 0], rt = c[m + k], yt = c[m + 2 * k], Pt = c[m + 3 * k];
      return 4 * Vi[255 + K - Z] + Vi[255 + W - rt] > I ? 0 : Vi[255 + c[m - 4 * k] - U] <= B && Vi[255 + U - W] <= B && Vi[255 + W - K] <= B && Vi[255 + Pt - yt] <= B && Vi[255 + yt - rt] <= B && Vi[255 + rt - Z] <= B;
    }
    function Yl(c, m, k, I) {
      var B = 2 * I + 1;
      for (I = 0; 16 > I; ++I) Gl(c, m + I, k, B) && jo(c, m + I, k);
    }
    function _r(c, m, k, I) {
      var B = 2 * I + 1;
      for (I = 0; 16 > I; ++I) Gl(c, m + I * k, 1, B) && jo(c, m + I * k, 1);
    }
    function Hr(c, m, k, I) {
      var B;
      for (B = 3; 0 < B; --B) Yl(c, m += 4 * k, k, I);
    }
    function Kc(c, m, k, I) {
      var B;
      for (B = 3; 0 < B; --B) _r(c, m += 4, k, I);
    }
    function gs(c, m, k, I, B, U, W, K) {
      for (U = 2 * U + 1; 0 < B--; ) {
        if (Vl(c, m, k, U, W)) if (Hl(c, m, k, K)) jo(c, m, k);
        else {
          var Z = c, rt = m, yt = k, Pt = Z[rt - 2 * yt], Lt = Z[rt - yt], At = Z[rt + 0], Ht = Z[rt + yt], Ft = Z[rt + 2 * yt], bt = 27 * (Ut = th[1020 + 3 * (At - Lt) + th[1020 + Pt - Ht]]) + 63 >> 7, _t = 18 * Ut + 63 >> 7, Ut = 9 * Ut + 63 >> 7;
          Z[rt - 3 * yt] = Ei[255 + Z[rt - 3 * yt] + Ut], Z[rt - 2 * yt] = Ei[255 + Pt + _t], Z[rt - yt] = Ei[255 + Lt + bt], Z[rt + 0] = Ei[255 + At - bt], Z[rt + yt] = Ei[255 + Ht - _t], Z[rt + 2 * yt] = Ei[255 + Ft - Ut];
        }
        m += I;
      }
    }
    function sr(c, m, k, I, B, U, W, K) {
      for (U = 2 * U + 1; 0 < B--; ) {
        if (Vl(c, m, k, U, W)) if (Hl(c, m, k, K)) jo(c, m, k);
        else {
          var Z = c, rt = m, yt = k, Pt = Z[rt - yt], Lt = Z[rt + 0], At = Z[rt + yt], Ht = iu[112 + ((Ft = 3 * (Lt - Pt)) + 4 >> 3)], Ft = iu[112 + (Ft + 3 >> 3)], bt = Ht + 1 >> 1;
          Z[rt - 2 * yt] = Ei[255 + Z[rt - 2 * yt] + bt], Z[rt - yt] = Ei[255 + Pt + Ft], Z[rt + 0] = Ei[255 + Lt - Ht], Z[rt + yt] = Ei[255 + At - bt];
        }
        m += I;
      }
    }
    function Ba(c, m, k, I, B, U) {
      gs(c, m, k, 1, 16, I, B, U);
    }
    function Js(c, m, k, I, B, U) {
      gs(c, m, 1, k, 16, I, B, U);
    }
    function Xc(c, m, k, I, B, U) {
      var W;
      for (W = 3; 0 < W; --W) sr(c, m += 4 * k, k, 1, 16, I, B, U);
    }
    function qo(c, m, k, I, B, U) {
      var W;
      for (W = 3; 0 < W; --W) sr(c, m += 4, 1, k, 16, I, B, U);
    }
    function Jc(c, m, k, I, B, U, W, K) {
      gs(c, m, B, 1, 8, U, W, K), gs(k, I, B, 1, 8, U, W, K);
    }
    function ja(c, m, k, I, B, U, W, K) {
      gs(c, m, 1, B, 8, U, W, K), gs(k, I, 1, B, 8, U, W, K);
    }
    function qa(c, m, k, I, B, U, W, K) {
      sr(c, m + 4 * B, B, 1, 8, U, W, K), sr(k, I + 4 * B, B, 1, 8, U, W, K);
    }
    function Kl(c, m, k, I, B, U, W, K) {
      sr(c, m + 4, 1, B, 8, U, W, K), sr(k, I + 4, 1, B, 8, U, W, K);
    }
    function zo() {
      this.ba = new _n(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Qe(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function za() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function $a() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Xl() {
      this.ua = 0, this.Wa = new $(), this.vb = new $(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new x(), this.yc = new S();
    }
    function Zc() {
      this.xb = this.a = 0, this.l = new cs(), this.ca = new _n(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new P(), this.Pb = 0, this.wd = new P(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Xl(), this.ab = 0, this.gc = o(4, $a), this.Oc = 0;
    }
    function $o() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new cs(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Zs(c, m, k, I, B, U, W) {
      for (c = c == null ? 0 : c[m + 0], m = 0; m < W; ++m) B[U + m] = c + k[I + m] & 255, c = B[U + m];
    }
    function Ua(c, m, k, I, B, U, W) {
      var K;
      if (c == null) Zs(null, null, k, I, B, U, W);
      else for (K = 0; K < W; ++K) B[U + K] = c[m + K] + k[I + K] & 255;
    }
    function ms(c, m, k, I, B, U, W) {
      if (c == null) Zs(null, null, k, I, B, U, W);
      else {
        var K, Z = c[m + 0], rt = Z, yt = Z;
        for (K = 0; K < W; ++K) rt = yt + (Z = c[m + K]) - rt, yt = k[I + K] + (-256 & rt ? 0 > rt ? 0 : 255 : rt) & 255, rt = Z, B[U + K] = yt;
      }
    }
    function Wa(c, m, k, I) {
      var B = m.width, U = m.o;
      if (t(c != null && m != null), 0 > k || 0 >= I || k + I > U) return null;
      if (!c.Cc) {
        if (c.ga == null) {
          var W;
          if (c.ga = new $o(), (W = c.ga == null) || (W = m.width * m.o, t(c.Gb.length == 0), c.Gb = s(W), c.Uc = 0, c.Gb == null ? W = 0 : (c.mb = c.Gb, c.nb = c.Uc, c.rc = null, W = 1), W = !W), !W) {
            W = c.ga;
            var K = c.Fa, Z = c.P, rt = c.qc, yt = c.mb, Pt = c.nb, Lt = Z + 1, At = rt - 1, Ht = W.l;
            if (t(K != null && yt != null && m != null), _s[0] = null, _s[1] = Zs, _s[2] = Ua, _s[3] = ms, W.ca = yt, W.tb = Pt, W.c = m.width, W.i = m.height, t(0 < W.c && 0 < W.i), 1 >= rt) m = 0;
            else if (W.$a = K[Z + 0] >> 0 & 3, W.Z = K[Z + 0] >> 2 & 3, W.Lc = K[Z + 0] >> 4 & 3, Z = K[Z + 0] >> 6 & 3, 0 > W.$a || 1 < W.$a || 4 <= W.Z || 1 < W.Lc || Z) m = 0;
            else if (Ht.put = Di, Ht.ac = Ln, Ht.bc = jn, Ht.ma = W, Ht.width = m.width, Ht.height = m.height, Ht.Da = m.Da, Ht.v = m.v, Ht.va = m.va, Ht.j = m.j, Ht.o = m.o, W.$a) t: {
              t(W.$a == 1), m = Ci();
              e: for (; ; ) {
                if (m == null) {
                  m = 0;
                  break t;
                }
                if (t(W != null), W.mc = m, m.c = W.c, m.i = W.i, m.l = W.l, m.l.ma = W, m.l.width = W.c, m.l.height = W.i, m.a = 0, tt(m.m, K, Lt, At), !qi(W.c, W.i, 1, m, null) || (m.ab == 1 && m.gc[0].hc == 3 && ir(m.s) ? (W.ic = 1, K = m.c * m.i, m.Ta = null, m.Ua = 0, m.V = s(K), m.Ba = 0, m.V == null ? (m.a = 1, m = 0) : m = 1) : (W.ic = 0, m = xr(m, W.c)), !m)) break e;
                m = 1;
                break t;
              }
              W.mc = null, m = 0;
            }
            else m = At >= W.c * W.i;
            W = !m;
          }
          if (W) return null;
          c.ga.Lc != 1 ? c.Ga = 0 : I = U - k;
        }
        t(c.ga != null), t(k + I <= U);
        t: {
          if (m = (K = c.ga).c, U = K.l.o, K.$a == 0) {
            if (Lt = c.rc, At = c.Vc, Ht = c.Fa, Z = c.P + 1 + k * m, rt = c.mb, yt = c.nb + k * m, t(Z <= c.P + c.qc), K.Z != 0) for (t(_s[K.Z] != null), W = 0; W < I; ++W) _s[K.Z](Lt, At, Ht, Z, rt, yt, m), Lt = rt, At = yt, yt += m, Z += m;
            else for (W = 0; W < I; ++W) i(rt, yt, Ht, Z, m), Lt = rt, At = yt, yt += m, Z += m;
            c.rc = Lt, c.Vc = At;
          } else {
            if (t(K.mc != null), m = k + I, t((W = K.mc) != null), t(m <= W.i), W.C >= m) m = 1;
            else if (K.ic || Ct(), K.ic) {
              K = W.V, Lt = W.Ba, At = W.c;
              var Ft = W.i, bt = (Ht = 1, Z = W.$ / At, rt = W.$ % At, yt = W.m, Pt = W.s, W.$), _t = At * Ft, Ut = At * m, Gt = Pt.wc, Wt = bt < Ut ? bn(Pt, rt, Z) : null;
              t(bt <= _t), t(m <= Ft), t(ir(Pt));
              e: for (; ; ) {
                for (; !yt.h && bt < Ut; ) {
                  if (rt & Gt || (Wt = bn(Pt, rt, Z)), t(Wt != null), ot(yt), 256 > (Ft = ti(Wt.G[0], Wt.H[0], yt))) K[Lt + bt] = Ft, ++bt, ++rt >= At && (rt = 0, ++Z <= m && !(Z % 16) && Ai(W, Z));
                  else {
                    if (!(280 > Ft)) {
                      Ht = 0;
                      break e;
                    }
                    Ft = ki(Ft - 256, yt);
                    var ce, ne = ti(Wt.G[4], Wt.H[4], yt);
                    if (ot(yt), !(bt >= (ne = Bi(At, ne = ki(ne, yt))) && _t - bt >= Ft)) {
                      Ht = 0;
                      break e;
                    }
                    for (ce = 0; ce < Ft; ++ce) K[Lt + bt + ce] = K[Lt + bt + ce - ne];
                    for (bt += Ft, rt += Ft; rt >= At; ) rt -= At, ++Z <= m && !(Z % 16) && Ai(W, Z);
                    bt < Ut && rt & Gt && (Wt = bn(Pt, rt, Z));
                  }
                  t(yt.h == G(yt));
                }
                Ai(W, Z > m ? m : Z);
                break e;
              }
              !Ht || yt.h && bt < _t ? (Ht = 0, W.a = yt.h ? 5 : 3) : W.$ = bt, m = Ht;
            } else m = Ni(W, W.V, W.Ba, W.c, W.i, m, Br);
            if (!m) {
              I = 0;
              break t;
            }
          }
          k + I >= U && (c.Cc = 1), I = 1;
        }
        if (!I) return null;
        if (c.Cc && ((I = c.ga) != null && (I.mc = null), c.ga = null, 0 < c.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return c.nb + k * B;
    }
    function w(c, m, k, I, B, U) {
      for (; 0 < B--; ) {
        var W, K = c, Z = m + (k ? 1 : 0), rt = c, yt = m + (k ? 0 : 3);
        for (W = 0; W < I; ++W) {
          var Pt = rt[yt + 4 * W];
          Pt != 255 && (Pt *= 32897, K[Z + 4 * W + 0] = K[Z + 4 * W + 0] * Pt >> 23, K[Z + 4 * W + 1] = K[Z + 4 * W + 1] * Pt >> 23, K[Z + 4 * W + 2] = K[Z + 4 * W + 2] * Pt >> 23);
        }
        m += U;
      }
    }
    function j(c, m, k, I, B) {
      for (; 0 < I--; ) {
        var U;
        for (U = 0; U < k; ++U) {
          var W = c[m + 2 * U + 0], K = 15 & (rt = c[m + 2 * U + 1]), Z = 4369 * K, rt = (240 & rt | rt >> 4) * Z >> 16;
          c[m + 2 * U + 0] = (240 & W | W >> 4) * Z >> 16 & 240 | (15 & W | W << 4) * Z >> 16 >> 4 & 15, c[m + 2 * U + 1] = 240 & rt | K;
        }
        m += B;
      }
    }
    function ut(c, m, k, I, B, U, W, K) {
      var Z, rt, yt = 255;
      for (rt = 0; rt < B; ++rt) {
        for (Z = 0; Z < I; ++Z) {
          var Pt = c[m + Z];
          U[W + 4 * Z] = Pt, yt &= Pt;
        }
        m += k, W += K;
      }
      return yt != 255;
    }
    function pt(c, m, k, I, B) {
      var U;
      for (U = 0; U < B; ++U) k[I + U] = c[m + U] >> 8;
    }
    function Ct() {
      Gi = w, un = j, cn = ut, kn = pt;
    }
    function Rt(c, m, k) {
      E[c] = function(I, B, U, W, K, Z, rt, yt, Pt, Lt, At, Ht, Ft, bt, _t, Ut, Gt) {
        var Wt, ce = Gt - 1 >> 1, ne = K[Z + 0] | rt[yt + 0] << 16, xe = Pt[Lt + 0] | At[Ht + 0] << 16;
        t(I != null);
        var se = 3 * ne + xe + 131074 >> 2;
        for (m(I[B + 0], 255 & se, se >> 16, Ft, bt), U != null && (se = 3 * xe + ne + 131074 >> 2, m(U[W + 0], 255 & se, se >> 16, _t, Ut)), Wt = 1; Wt <= ce; ++Wt) {
          var Xe = K[Z + Wt] | rt[yt + Wt] << 16, tn = Pt[Lt + Wt] | At[Ht + Wt] << 16, He = ne + Xe + xe + tn + 524296, je = He + 2 * (Xe + xe) >> 3;
          se = je + ne >> 1, ne = (He = He + 2 * (ne + tn) >> 3) + Xe >> 1, m(I[B + 2 * Wt - 1], 255 & se, se >> 16, Ft, bt + (2 * Wt - 1) * k), m(I[B + 2 * Wt - 0], 255 & ne, ne >> 16, Ft, bt + (2 * Wt - 0) * k), U != null && (se = He + xe >> 1, ne = je + tn >> 1, m(U[W + 2 * Wt - 1], 255 & se, se >> 16, _t, Ut + (2 * Wt - 1) * k), m(U[W + 2 * Wt + 0], 255 & ne, ne >> 16, _t, Ut + (2 * Wt + 0) * k)), ne = Xe, xe = tn;
        }
        1 & Gt || (se = 3 * ne + xe + 131074 >> 2, m(I[B + Gt - 1], 255 & se, se >> 16, Ft, bt + (Gt - 1) * k), U != null && (se = 3 * xe + ne + 131074 >> 2, m(U[W + Gt - 1], 255 & se, se >> 16, _t, Ut + (Gt - 1) * k)));
      };
    }
    function Vt() {
      Yi[ru] = e2, Yi[su] = Kd, Yi[Wd] = n2, Yi[ou] = Xd, Yi[au] = Jd, Yi[eh] = Zd, Yi[Hd] = i2, Yi[nh] = Kd, Yi[ih] = Xd, Yi[lu] = Jd, Yi[rh] = Zd;
    }
    function ue(c) {
      return c & ~r2 ? 0 > c ? 0 : 255 : c >> Qd;
    }
    function be(c, m) {
      return ue((19077 * c >> 8) + (26149 * m >> 8) - 14234);
    }
    function Ee(c, m, k) {
      return ue((19077 * c >> 8) - (6419 * m >> 8) - (13320 * k >> 8) + 8708);
    }
    function Pe(c, m) {
      return ue((19077 * c >> 8) + (33050 * m >> 8) - 17685);
    }
    function Ue(c, m, k, I, B) {
      I[B + 0] = be(c, k), I[B + 1] = Ee(c, m, k), I[B + 2] = Pe(c, m);
    }
    function gn(c, m, k, I, B) {
      I[B + 0] = Pe(c, m), I[B + 1] = Ee(c, m, k), I[B + 2] = be(c, k);
    }
    function vn(c, m, k, I, B) {
      var U = Ee(c, m, k);
      m = U << 3 & 224 | Pe(c, m) >> 3, I[B + 0] = 248 & be(c, k) | U >> 5, I[B + 1] = m;
    }
    function In(c, m, k, I, B) {
      var U = 240 & Pe(c, m) | 15;
      I[B + 0] = 240 & be(c, k) | Ee(c, m, k) >> 4, I[B + 1] = U;
    }
    function ei(c, m, k, I, B) {
      I[B + 0] = 255, Ue(c, m, k, I, B + 1);
    }
    function qn(c, m, k, I, B) {
      gn(c, m, k, I, B), I[B + 3] = 255;
    }
    function or(c, m, k, I, B) {
      Ue(c, m, k, I, B), I[B + 3] = 255;
    }
    function Ii(c, m) {
      return 0 > c ? 0 : c > m ? m : c;
    }
    function Sr(c, m, k) {
      E[c] = function(I, B, U, W, K, Z, rt, yt, Pt) {
        for (var Lt = yt + (-2 & Pt) * k; yt != Lt; ) m(I[B + 0], U[W + 0], K[Z + 0], rt, yt), m(I[B + 1], U[W + 0], K[Z + 0], rt, yt + k), B += 2, ++W, ++Z, yt += 2 * k;
        1 & Pt && m(I[B + 0], U[W + 0], K[Z + 0], rt, yt);
      };
    }
    function Jl(c, m, k) {
      return k == 0 ? c == 0 ? m == 0 ? 6 : 5 : m == 0 ? 4 : 0 : k;
    }
    function Ha(c, m, k, I, B) {
      switch (c >>> 30) {
        case 3:
          Yr(m, k, I, B, 0);
          break;
        case 2:
          Sn(m, k, I, B);
          break;
        case 1:
          hi(m, k, I, B);
      }
    }
    function Ga(c, m) {
      var k, I, B = m.M, U = m.Nb, W = c.oc, K = c.pc + 40, Z = c.oc, rt = c.pc + 584, yt = c.oc, Pt = c.pc + 600;
      for (k = 0; 16 > k; ++k) W[K + 32 * k - 1] = 129;
      for (k = 0; 8 > k; ++k) Z[rt + 32 * k - 1] = 129, yt[Pt + 32 * k - 1] = 129;
      for (0 < B ? W[K - 1 - 32] = Z[rt - 1 - 32] = yt[Pt - 1 - 32] = 129 : (r(W, K - 32 - 1, 127, 21), r(Z, rt - 32 - 1, 127, 9), r(yt, Pt - 32 - 1, 127, 9)), I = 0; I < c.za; ++I) {
        var Lt = m.ya[m.aa + I];
        if (0 < I) {
          for (k = -1; 16 > k; ++k) i(W, K + 32 * k - 4, W, K + 32 * k + 12, 4);
          for (k = -1; 8 > k; ++k) i(Z, rt + 32 * k - 4, Z, rt + 32 * k + 4, 4), i(yt, Pt + 32 * k - 4, yt, Pt + 32 * k + 4, 4);
        }
        var At = c.Gd, Ht = c.Hd + I, Ft = Lt.ad, bt = Lt.Hc;
        if (0 < B && (i(W, K - 32, At[Ht].y, 0, 16), i(Z, rt - 32, At[Ht].f, 0, 8), i(yt, Pt - 32, At[Ht].ea, 0, 8)), Lt.Za) {
          var _t = W, Ut = K - 32 + 16;
          for (0 < B && (I >= c.za - 1 ? r(_t, Ut, At[Ht].y[15], 4) : i(_t, Ut, At[Ht + 1].y, 0, 4)), k = 0; 4 > k; k++) _t[Ut + 128 + k] = _t[Ut + 256 + k] = _t[Ut + 384 + k] = _t[Ut + 0 + k];
          for (k = 0; 16 > k; ++k, bt <<= 2) _t = W, Ut = K + ep[k], ar[Lt.Ob[k]](_t, Ut), Ha(bt, Ft, 16 * +k, _t, Ut);
        } else if (_t = Jl(I, B, Lt.Ob[0]), xs[_t](W, K), bt != 0) for (k = 0; 16 > k; ++k, bt <<= 2) Ha(bt, Ft, 16 * +k, W, K + ep[k]);
        for (k = Lt.Gc, _t = Jl(I, B, Lt.Dd), Xr[_t](Z, rt), Xr[_t](yt, Pt), bt = Ft, _t = Z, Ut = rt, 255 & (Lt = k >> 0) && (170 & Lt ? Ja(bt, 256, _t, Ut) : Wi(bt, 256, _t, Ut)), Lt = yt, bt = Pt, 255 & (k >>= 8) && (170 & k ? Ja(Ft, 320, Lt, bt) : Wi(Ft, 320, Lt, bt)), B < c.Ub - 1 && (i(At[Ht].y, 0, W, K + 480, 16), i(At[Ht].f, 0, Z, rt + 224, 8), i(At[Ht].ea, 0, yt, Pt + 224, 8)), k = 8 * U * c.B, At = c.sa, Ht = c.ta + 16 * I + 16 * U * c.R, Ft = c.qa, Lt = c.ra + 8 * I + k, bt = c.Ha, _t = c.Ia + 8 * I + k, k = 0; 16 > k; ++k) i(At, Ht + k * c.R, W, K + 32 * k, 16);
        for (k = 0; 8 > k; ++k) i(Ft, Lt + k * c.B, Z, rt + 32 * k, 8), i(bt, _t + k * c.B, yt, Pt + 32 * k, 8);
      }
    }
    function Uo(c, m, k, I, B, U, W, K, Z) {
      var rt = [0], yt = [0], Pt = 0, Lt = Z != null ? Z.kd : 0, At = Z ?? new za();
      if (c == null || 12 > k) return 7;
      At.data = c, At.w = m, At.ha = k, m = [m], k = [k], At.gb = [At.gb];
      t: {
        var Ht = m, Ft = k, bt = At.gb;
        if (t(c != null), t(Ft != null), t(bt != null), bt[0] = 0, 12 <= Ft[0] && !e(c, Ht[0], "RIFF")) {
          if (e(c, Ht[0] + 8, "WEBP")) {
            bt = 3;
            break t;
          }
          var _t = Xt(c, Ht[0] + 4);
          if (12 > _t || 4294967286 < _t) {
            bt = 3;
            break t;
          }
          if (Lt && _t > Ft[0] - 8) {
            bt = 7;
            break t;
          }
          bt[0] = _t, Ht[0] += 12, Ft[0] -= 12;
        }
        bt = 0;
      }
      if (bt != 0) return bt;
      for (_t = 0 < At.gb[0], k = k[0]; ; ) {
        t: {
          var Ut = c;
          Ft = m, bt = k;
          var Gt = rt, Wt = yt, ce = Ht = [0];
          if ((se = Pt = [Pt])[0] = 0, 8 > bt[0]) bt = 7;
          else {
            if (!e(Ut, Ft[0], "VP8X")) {
              if (Xt(Ut, Ft[0] + 4) != 10) {
                bt = 3;
                break t;
              }
              if (18 > bt[0]) {
                bt = 7;
                break t;
              }
              var ne = Xt(Ut, Ft[0] + 8), xe = 1 + Yt(Ut, Ft[0] + 12);
              if (2147483648 <= xe * (Ut = 1 + Yt(Ut, Ft[0] + 15))) {
                bt = 3;
                break t;
              }
              ce != null && (ce[0] = ne), Gt != null && (Gt[0] = xe), Wt != null && (Wt[0] = Ut), Ft[0] += 18, bt[0] -= 18, se[0] = 1;
            }
            bt = 0;
          }
        }
        if (Pt = Pt[0], Ht = Ht[0], bt != 0) return bt;
        if (Ft = !!(2 & Ht), !_t && Pt) return 3;
        if (U != null && (U[0] = !!(16 & Ht)), W != null && (W[0] = Ft), K != null && (K[0] = 0), W = rt[0], Ht = yt[0], Pt && Ft && Z == null) {
          bt = 0;
          break;
        }
        if (4 > k) {
          bt = 7;
          break;
        }
        if (_t && Pt || !_t && !Pt && !e(c, m[0], "ALPH")) {
          k = [k], At.na = [At.na], At.P = [At.P], At.Sa = [At.Sa];
          t: {
            ne = c, bt = m, _t = k;
            var se = At.gb;
            Gt = At.na, Wt = At.P, ce = At.Sa, xe = 22, t(ne != null), t(_t != null), Ut = bt[0];
            var Xe = _t[0];
            for (t(Gt != null), t(ce != null), Gt[0] = null, Wt[0] = null, ce[0] = 0; ; ) {
              if (bt[0] = Ut, _t[0] = Xe, 8 > Xe) {
                bt = 7;
                break t;
              }
              var tn = Xt(ne, Ut + 4);
              if (4294967286 < tn) {
                bt = 3;
                break t;
              }
              var He = 8 + tn + 1 & -2;
              if (xe += He, 0 < se && xe > se) {
                bt = 3;
                break t;
              }
              if (!e(ne, Ut, "VP8 ") || !e(ne, Ut, "VP8L")) {
                bt = 0;
                break t;
              }
              if (Xe[0] < He) {
                bt = 7;
                break t;
              }
              e(ne, Ut, "ALPH") || (Gt[0] = ne, Wt[0] = Ut + 8, ce[0] = tn), Ut += He, Xe -= He;
            }
          }
          if (k = k[0], At.na = At.na[0], At.P = At.P[0], At.Sa = At.Sa[0], bt != 0) break;
        }
        k = [k], At.Ja = [At.Ja], At.xa = [At.xa];
        t: if (se = c, bt = m, _t = k, Gt = At.gb[0], Wt = At.Ja, ce = At.xa, ne = bt[0], Ut = !e(se, ne, "VP8 "), xe = !e(se, ne, "VP8L"), t(se != null), t(_t != null), t(Wt != null), t(ce != null), 8 > _t[0]) bt = 7;
        else {
          if (Ut || xe) {
            if (se = Xt(se, ne + 4), 12 <= Gt && se > Gt - 12) {
              bt = 3;
              break t;
            }
            if (Lt && se > _t[0] - 8) {
              bt = 7;
              break t;
            }
            Wt[0] = se, bt[0] += 8, _t[0] -= 8, ce[0] = xe;
          } else ce[0] = 5 <= _t[0] && se[ne + 0] == 47 && !(se[ne + 4] >> 5), Wt[0] = _t[0];
          bt = 0;
        }
        if (k = k[0], At.Ja = At.Ja[0], At.xa = At.xa[0], m = m[0], bt != 0) break;
        if (4294967286 < At.Ja) return 3;
        if (K == null || Ft || (K[0] = At.xa ? 2 : 1), W = [W], Ht = [Ht], At.xa) {
          if (5 > k) {
            bt = 7;
            break;
          }
          K = W, Lt = Ht, Ft = U, c == null || 5 > k ? c = 0 : 5 <= k && c[m + 0] == 47 && !(c[m + 4] >> 5) ? (_t = [0], se = [0], Gt = [0], tt(Wt = new P(), c, m, k), ve(Wt, _t, se, Gt) ? (K != null && (K[0] = _t[0]), Lt != null && (Lt[0] = se[0]), Ft != null && (Ft[0] = Gt[0]), c = 1) : c = 0) : c = 0;
        } else {
          if (10 > k) {
            bt = 7;
            break;
          }
          K = Ht, c == null || 10 > k || !Fo(c, m + 3, k - 3) ? c = 0 : (Lt = c[m + 0] | c[m + 1] << 8 | c[m + 2] << 16, Ft = 16383 & (c[m + 7] << 8 | c[m + 6]), c = 16383 & (c[m + 9] << 8 | c[m + 8]), 1 & Lt || 3 < (Lt >> 1 & 7) || !(Lt >> 4 & 1) || Lt >> 5 >= At.Ja || !Ft || !c ? c = 0 : (W && (W[0] = Ft), K && (K[0] = c), c = 1));
        }
        if (!c || (W = W[0], Ht = Ht[0], Pt && (rt[0] != W || yt[0] != Ht))) return 3;
        Z != null && (Z[0] = At, Z.offset = m - Z.w, t(4294967286 > m - Z.w), t(Z.offset == Z.ha - k));
        break;
      }
      return bt == 0 || bt == 7 && Pt && Z == null ? (U != null && (U[0] |= At.na != null && 0 < At.na.length), I != null && (I[0] = W), B != null && (B[0] = Ht), 0) : bt;
    }
    function Va(c, m, k) {
      var I = m.width, B = m.height, U = 0, W = 0, K = I, Z = B;
      if (m.Da = c != null && 0 < c.Da, m.Da && (K = c.cd, Z = c.bd, U = c.v, W = c.j, 11 > k || (U &= -2, W &= -2), 0 > U || 0 > W || 0 >= K || 0 >= Z || U + K > I || W + Z > B)) return 0;
      if (m.v = U, m.j = W, m.va = U + K, m.o = W + Z, m.U = K, m.T = Z, m.da = c != null && 0 < c.da, m.da) {
        if (!nt(K, Z, k = [c.ib], U = [c.hb])) return 0;
        m.ib = k[0], m.hb = U[0];
      }
      return m.ob = c != null && c.ob, m.Kb = c == null || !c.Sd, m.da && (m.ob = m.ib < 3 * I / 4 && m.hb < 3 * B / 4, m.Kb = 0), 1;
    }
    function Ya(c) {
      if (c == null) return 2;
      if (11 > c.S) {
        var m = c.f.RGBA;
        m.fb += (c.height - 1) * m.A, m.A = -m.A;
      } else m = c.f.kb, c = c.height, m.O += (c - 1) * m.fa, m.fa = -m.fa, m.N += (c - 1 >> 1) * m.Ab, m.Ab = -m.Ab, m.W += (c - 1 >> 1) * m.Db, m.Db = -m.Db, m.F != null && (m.J += (c - 1) * m.lb, m.lb = -m.lb);
      return 0;
    }
    function Wo(c, m, k, I) {
      if (I == null || 0 >= c || 0 >= m) return 2;
      if (k != null) {
        if (k.Da) {
          var B = k.cd, U = k.bd, W = -2 & k.v, K = -2 & k.j;
          if (0 > W || 0 > K || 0 >= B || 0 >= U || W + B > c || K + U > m) return 2;
          c = B, m = U;
        }
        if (k.da) {
          if (!nt(c, m, B = [k.ib], U = [k.hb])) return 2;
          c = B[0], m = U[0];
        }
      }
      I.width = c, I.height = m;
      t: {
        var Z = I.width, rt = I.height;
        if (c = I.S, 0 >= Z || 0 >= rt || !(c >= ru && 13 > c)) c = 2;
        else {
          if (0 >= I.Rd && I.sd == null) {
            W = U = B = m = 0;
            var yt = (K = Z * np[c]) * rt;
            if (11 > c || (U = (rt + 1) / 2 * (m = (Z + 1) / 2), c == 12 && (W = (B = Z) * rt)), (rt = s(yt + 2 * U + W)) == null) {
              c = 1;
              break t;
            }
            I.sd = rt, 11 > c ? ((Z = I.f.RGBA).eb = rt, Z.fb = 0, Z.A = K, Z.size = yt) : ((Z = I.f.kb).y = rt, Z.O = 0, Z.fa = K, Z.Fd = yt, Z.f = rt, Z.N = 0 + yt, Z.Ab = m, Z.Cd = U, Z.ea = rt, Z.W = 0 + yt + U, Z.Db = m, Z.Ed = U, c == 12 && (Z.F = rt, Z.J = 0 + yt + 2 * U), Z.Tc = W, Z.lb = B);
          }
          if (m = 1, B = I.S, U = I.width, W = I.height, B >= ru && 13 > B) if (11 > B) c = I.f.RGBA, m &= (K = Math.abs(c.A)) * (W - 1) + U <= c.size, m &= K >= U * np[B], m &= c.eb != null;
          else {
            c = I.f.kb, K = (U + 1) / 2, yt = (W + 1) / 2, Z = Math.abs(c.fa), rt = Math.abs(c.Ab);
            var Pt = Math.abs(c.Db), Lt = Math.abs(c.lb), At = Lt * (W - 1) + U;
            m &= Z * (W - 1) + U <= c.Fd, m &= rt * (yt - 1) + K <= c.Cd, m = (m &= Pt * (yt - 1) + K <= c.Ed) & Z >= U & rt >= K & Pt >= K, m &= c.y != null, m &= c.f != null, m &= c.ea != null, B == 12 && (m &= Lt >= U, m &= At <= c.Tc, m &= c.F != null);
          }
          else m = 0;
          c = m ? 0 : 2;
        }
      }
      return c != 0 || k != null && k.fd && (c = Ya(I)), c;
    }
    var Vn = 64, Ho = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Go = 24, Vo = 32, Ka = 8, mi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    vt("Predictor0", "PredictorAdd0"), E.Predictor0 = function() {
      return 4278190080;
    }, E.Predictor1 = function(c) {
      return c;
    }, E.Predictor2 = function(c, m, k) {
      return m[k + 0];
    }, E.Predictor3 = function(c, m, k) {
      return m[k + 1];
    }, E.Predictor4 = function(c, m, k) {
      return m[k - 1];
    }, E.Predictor5 = function(c, m, k) {
      return ft(ft(c, m[k + 1]), m[k + 0]);
    }, E.Predictor6 = function(c, m, k) {
      return ft(c, m[k - 1]);
    }, E.Predictor7 = function(c, m, k) {
      return ft(c, m[k + 0]);
    }, E.Predictor8 = function(c, m, k) {
      return ft(m[k - 1], m[k + 0]);
    }, E.Predictor9 = function(c, m, k) {
      return ft(m[k + 0], m[k + 1]);
    }, E.Predictor10 = function(c, m, k) {
      return ft(ft(c, m[k - 1]), ft(m[k + 0], m[k + 1]));
    }, E.Predictor11 = function(c, m, k) {
      var I = m[k + 0];
      return 0 >= Tt(I >> 24 & 255, c >> 24 & 255, (m = m[k - 1]) >> 24 & 255) + Tt(I >> 16 & 255, c >> 16 & 255, m >> 16 & 255) + Tt(I >> 8 & 255, c >> 8 & 255, m >> 8 & 255) + Tt(255 & I, 255 & c, 255 & m) ? I : c;
    }, E.Predictor12 = function(c, m, k) {
      var I = m[k + 0];
      return (Et((c >> 24 & 255) + (I >> 24 & 255) - ((m = m[k - 1]) >> 24 & 255)) << 24 | Et((c >> 16 & 255) + (I >> 16 & 255) - (m >> 16 & 255)) << 16 | Et((c >> 8 & 255) + (I >> 8 & 255) - (m >> 8 & 255)) << 8 | Et((255 & c) + (255 & I) - (255 & m))) >>> 0;
    }, E.Predictor13 = function(c, m, k) {
      var I = m[k - 1];
      return (zt((c = ft(c, m[k + 0])) >> 24 & 255, I >> 24 & 255) << 24 | zt(c >> 16 & 255, I >> 16 & 255) << 16 | zt(c >> 8 & 255, I >> 8 & 255) << 8 | zt(c >> 0 & 255, I >> 0 & 255)) >>> 0;
    };
    var Qc = E.PredictorAdd0;
    E.PredictorAdd1 = $t, vt("Predictor2", "PredictorAdd2"), vt("Predictor3", "PredictorAdd3"), vt("Predictor4", "PredictorAdd4"), vt("Predictor5", "PredictorAdd5"), vt("Predictor6", "PredictorAdd6"), vt("Predictor7", "PredictorAdd7"), vt("Predictor8", "PredictorAdd8"), vt("Predictor9", "PredictorAdd9"), vt("Predictor10", "PredictorAdd10"), vt("Predictor11", "PredictorAdd11"), vt("Predictor12", "PredictorAdd12"), vt("Predictor13", "PredictorAdd13");
    var Xa = E.PredictorAdd2;
    we("ColorIndexInverseTransform", "MapARGB", "32b", function(c) {
      return c >> 8 & 255;
    }, function(c) {
      return c;
    }), we("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(c) {
      return c;
    }, function(c) {
      return c >> 8 & 255;
    });
    var Zl, Ui = E.ColorIndexInverseTransform, Yo = E.MapARGB, Ql = E.VP8LColorIndexInverseTransformAlpha, tu = E.MapAlpha, ys = E.VP8LPredictorsAdd = [];
    ys.length = 16, (E.VP8LPredictors = []).length = 16, (E.VP8LPredictorsAdd_C = []).length = 16, (E.VP8LPredictors_C = []).length = 16;
    var Qs, yi, ci, bs, Gr, Vr, Ko, Yr, Sn, Ja, hi, Wi, Xo, eu, Za, to, eo, vs, no, Jo, io, ws, Qa, Hi, Gi, un, cn, kn, Mn = s(511), Kr = s(2041), tl = s(225), Zo = s(767), nu = 0, th = Kr, iu = tl, Ei = Zo, Vi = Mn, ru = 0, su = 1, Wd = 2, ou = 3, au = 4, eh = 5, Hd = 6, nh = 7, ih = 8, lu = 9, rh = 10, zm = [2, 3, 7], $m = [3, 3, 11], Gd = [280, 256, 256, 256, 40], Um = [0, 1, 1, 1, 0], Wm = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Hm = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Gm = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Vm = 8, sh = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], oh = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], el = null, Ym = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Km = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Vd = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Xm = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Jm = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Zm = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Qm = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], xs = [], ar = [], Xr = [], t2 = 1, Yd = 2, _s = [], Yi = [];
    Rt("UpsampleRgbLinePair", Ue, 3), Rt("UpsampleBgrLinePair", gn, 3), Rt("UpsampleRgbaLinePair", or, 4), Rt("UpsampleBgraLinePair", qn, 4), Rt("UpsampleArgbLinePair", ei, 4), Rt("UpsampleRgba4444LinePair", In, 2), Rt("UpsampleRgb565LinePair", vn, 2);
    var e2 = E.UpsampleRgbLinePair, n2 = E.UpsampleBgrLinePair, Kd = E.UpsampleRgbaLinePair, Xd = E.UpsampleBgraLinePair, Jd = E.UpsampleArgbLinePair, Zd = E.UpsampleRgba4444LinePair, i2 = E.UpsampleRgb565LinePair, uu = 16, cu = 1 << uu - 1, nl = -227, ah = 482, Qd = 6, r2 = (256 << Qd) - 1, tp = 0, s2 = s(256), o2 = s(256), a2 = s(256), l2 = s(256), u2 = s(ah - nl), c2 = s(ah - nl);
    Sr("YuvToRgbRow", Ue, 3), Sr("YuvToBgrRow", gn, 3), Sr("YuvToRgbaRow", or, 4), Sr("YuvToBgraRow", qn, 4), Sr("YuvToArgbRow", ei, 4), Sr("YuvToRgba4444Row", In, 2), Sr("YuvToRgb565Row", vn, 2);
    var ep = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], hu = [0, 2, 8], h2 = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], f2 = 1;
    this.WebPDecodeRGBA = function(c, m, k, I, B) {
      var U = su, W = new zo(), K = new _n();
      W.ba = K, K.S = U, K.width = [K.width], K.height = [K.height];
      var Z = K.width, rt = K.height, yt = new Fn();
      if (yt == null || c == null) var Pt = 2;
      else t(yt != null), Pt = Uo(c, m, k, yt.width, yt.height, yt.Pd, yt.Qd, yt.format, null);
      if (Pt != 0 ? Z = 0 : (Z != null && (Z[0] = yt.width[0]), rt != null && (rt[0] = yt.height[0]), Z = 1), Z) {
        K.width = K.width[0], K.height = K.height[0], I != null && (I[0] = K.width), B != null && (B[0] = K.height);
        t: {
          if (I = new cs(), (B = new za()).data = c, B.w = m, B.ha = k, B.kd = 1, m = [0], t(B != null), ((c = Uo(B.data, B.w, B.ha, null, null, null, m, null, B)) == 0 || c == 7) && m[0] && (c = 4), (m = c) == 0) {
            if (t(W != null), I.data = B.data, I.w = B.w + B.offset, I.ha = B.ha - B.offset, I.put = Di, I.ac = Ln, I.bc = jn, I.ma = W, B.xa) {
              if ((c = Ci()) == null) {
                W = 1;
                break t;
              }
              if (function(Lt, At) {
                var Ht = [0], Ft = [0], bt = [0];
                e: for (; ; ) {
                  if (Lt == null) return 0;
                  if (At == null) return Lt.a = 2, 0;
                  if (Lt.l = At, Lt.a = 0, tt(Lt.m, At.data, At.w, At.ha), !ve(Lt.m, Ht, Ft, bt)) {
                    Lt.a = 3;
                    break e;
                  }
                  if (Lt.xb = Yd, At.width = Ht[0], At.height = Ft[0], !qi(Ht[0], Ft[0], 1, Lt, null)) break e;
                  return 1;
                }
                return t(Lt.a != 0), 0;
              }(c, I)) {
                if (I = (m = Wo(I.width, I.height, W.Oa, W.ba)) == 0) {
                  e: {
                    I = c;
                    n: for (; ; ) {
                      if (I == null) {
                        I = 0;
                        break e;
                      }
                      if (t(I.s.yc != null), t(I.s.Ya != null), t(0 < I.s.Wb), t((k = I.l) != null), t((B = k.ma) != null), I.xb != 0) {
                        if (I.ca = B.ba, I.tb = B.tb, t(I.ca != null), !Va(B.Oa, k, ou)) {
                          I.a = 2;
                          break n;
                        }
                        if (!xr(I, k.width) || k.da) break n;
                        if ((k.da || de(I.ca.S)) && Ct(), 11 > I.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), I.ca.f.kb.F != null && Ct()), I.Pb && 0 < I.s.ua && I.s.vb.X == null && !F(I.s.vb, I.s.Wa.Xa)) {
                          I.a = 1;
                          break n;
                        }
                        I.xb = 0;
                      }
                      if (!Ni(I, I.V, I.Ba, I.c, I.i, k.o, os)) break n;
                      B.Dc = I.Ma, I = 1;
                      break e;
                    }
                    t(I.a != 0), I = 0;
                  }
                  I = !I;
                }
                I && (m = c.a);
              } else m = c.a;
            } else {
              if ((c = new Oa()) == null) {
                W = 1;
                break t;
              }
              if (c.Fa = B.na, c.P = B.P, c.qc = B.Sa, Gs(c, I)) {
                if ((m = Wo(I.width, I.height, W.Oa, W.ba)) == 0) {
                  if (c.Aa = 0, k = W.Oa, t((B = c) != null), k != null) {
                    if (0 < (Z = 0 > (Z = k.Md) ? 0 : 100 < Z ? 255 : 255 * Z / 100)) {
                      for (rt = yt = 0; 4 > rt; ++rt) 12 > (Pt = B.pb[rt]).lc && (Pt.ia = Z * h2[0 > Pt.lc ? 0 : Pt.lc] >> 3), yt |= Pt.ia;
                      yt && (alert("todo:VP8InitRandom"), B.ia = 1);
                    }
                    B.Ga = k.Id, 100 < B.Ga ? B.Ga = 100 : 0 > B.Ga && (B.Ga = 0);
                  }
                  zi(c, I) || (m = c.a);
                }
              } else m = c.a;
            }
            m == 0 && W.Oa != null && W.Oa.fd && (m = Ya(W.ba));
          }
          W = m;
        }
        U = W != 0 ? null : 11 > U ? K.f.RGBA.eb : K.f.kb.y;
      } else U = null;
      return U;
    };
    var np = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function h(E, M) {
    for (var q = "", N = 0; N < 4; N++) q += String.fromCharCode(E[M++]);
    return q;
  }
  function u(E, M) {
    return (E[M + 0] << 0 | E[M + 1] << 8 | E[M + 2] << 16) >>> 0;
  }
  function d(E, M) {
    return (E[M + 0] << 0 | E[M + 1] << 8 | E[M + 2] << 16 | E[M + 3] << 24) >>> 0;
  }
  new l();
  var p = [0], f = [0], g = [], y = new l(), _ = n, b = function(E, M) {
    var q = {}, N = 0, S = !1, T = 0, x = 0;
    if (q.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(z, G, Y, ot) {
      for (var xt = 0; xt < ot; xt++) if (z[G + xt] != Y.charCodeAt(xt)) return !0;
      return !1;
    }(E, M, "RIFF", 4)) {
      var X, V;
      for (d(E, M += 4), M += 8; M < E.length; ) {
        var D = h(E, M), tt = d(E, M += 4);
        M += 4;
        var H = tt + (1 & tt);
        switch (D) {
          case "VP8 ":
          case "VP8L":
            q.frames[N] === void 0 && (q.frames[N] = {}), (P = q.frames[N]).src_off = S ? x : M - 8, P.src_size = T + tt + 8, N++, S && (S = !1, T = 0, x = 0);
            break;
          case "VP8X":
            (P = q.header = {}).feature_flags = E[M];
            var ct = M + 4;
            P.canvas_width = 1 + u(E, ct), ct += 3, P.canvas_height = 1 + u(E, ct), ct += 3;
            break;
          case "ALPH":
            S = !0, T = H + 8, x = M - 8;
            break;
          case "ANIM":
            (P = q.header).bgcolor = d(E, M), ct = M + 4, P.loop_count = (X = E)[(V = ct) + 0] << 0 | X[V + 1] << 8, ct += 2;
            break;
          case "ANMF":
            var it, P;
            (P = q.frames[N] = {}).offset_x = 2 * u(E, M), M += 3, P.offset_y = 2 * u(E, M), M += 3, P.width = 1 + u(E, M), M += 3, P.height = 1 + u(E, M), M += 3, P.duration = u(E, M), M += 3, it = E[M++], P.dispose = 1 & it, P.blend = it >> 1 & 1;
        }
        D != "ANMF" && (M += H);
      }
      return q;
    }
  }(_, 0);
  b.response = _, b.rgbaoutput = !0, b.dataurl = !1;
  var v = b.header ? b.header : null, A = b.frames ? b.frames : null;
  if (v) {
    v.loop_counter = v.loop_count, p = [v.canvas_height], f = [v.canvas_width];
    for (var L = 0; L < A.length && A[L].blend != 0; L++) ;
  }
  var O = A[0], R = y.WebPDecodeRGBA(_, O.src_off, O.src_size, f, p);
  O.rgba = R, O.imgwidth = f[0], O.imgheight = p[0];
  for (var C = 0; C < f[0] * p[0] * 4; C++) g[C] = R[C];
  return this.width = f, this.height = p, this.data = g, this;
}
(function(n) {
  var t = function() {
    return typeof ff == "function";
  }, e = function(p, f, g, y) {
    var _ = 4, b = o;
    switch (y) {
      case n.image_compression.FAST:
        _ = 1, b = s;
        break;
      case n.image_compression.MEDIUM:
        _ = 6, b = a;
        break;
      case n.image_compression.SLOW:
        _ = 9, b = l;
    }
    p = i(p, f, g, b);
    var v = ff(p, { level: _ });
    return n.__addimage__.arrayBufferToBinaryString(v);
  }, i = function(p, f, g, y) {
    for (var _, b, v, A = p.length / f, L = new Uint8Array(p.length + A), O = u(), R = 0; R < A; R += 1) {
      if (v = R * f, _ = p.subarray(v, v + f), y) L.set(y(_, g, b), v + R);
      else {
        for (var C, E = O.length, M = []; C < E; C += 1) M[C] = O[C](_, g, b);
        var q = d(M.concat());
        L.set(M[q], v + R);
      }
      b = _;
    }
    return L;
  }, r = function(p) {
    var f = Array.apply([], p);
    return f.unshift(0), f;
  }, s = function(p, f) {
    var g, y = [], _ = p.length;
    y[0] = 1;
    for (var b = 0; b < _; b += 1) g = p[b - f] || 0, y[b + 1] = p[b] - g + 256 & 255;
    return y;
  }, o = function(p, f, g) {
    var y, _ = [], b = p.length;
    _[0] = 2;
    for (var v = 0; v < b; v += 1) y = g && g[v] || 0, _[v + 1] = p[v] - y + 256 & 255;
    return _;
  }, a = function(p, f, g) {
    var y, _, b = [], v = p.length;
    b[0] = 3;
    for (var A = 0; A < v; A += 1) y = p[A - f] || 0, _ = g && g[A] || 0, b[A + 1] = p[A] + 256 - (y + _ >>> 1) & 255;
    return b;
  }, l = function(p, f, g) {
    var y, _, b, v, A = [], L = p.length;
    A[0] = 4;
    for (var O = 0; O < L; O += 1) y = p[O - f] || 0, _ = g && g[O] || 0, b = g && g[O - f] || 0, v = h(y, _, b), A[O + 1] = p[O] - v + 256 & 255;
    return A;
  }, h = function(p, f, g) {
    if (p === f && f === g) return p;
    var y = Math.abs(f - g), _ = Math.abs(p - g), b = Math.abs(p + f - g - g);
    return y <= _ && y <= b ? p : _ <= b ? f : g;
  }, u = function() {
    return [r, s, o, a, l];
  }, d = function(p) {
    var f = p.map(function(g) {
      return g.reduce(function(y, _) {
        return y + Math.abs(_);
      }, 0);
    });
    return f.indexOf(Math.min.apply(null, f));
  };
  n.processPNG = function(p, f, g, y) {
    var _, b, v, A, L, O, R, C, E, M, q, N, S, T, x, X = this.decode.FLATE_DECODE, V = "";
    if (this.__addimage__.isArrayBuffer(p) && (p = new Uint8Array(p)), this.__addimage__.isArrayBufferView(p)) {
      if (p = (v = new Rv(p)).imgData, b = v.bits, _ = v.colorSpace, L = v.colors, [4, 6].indexOf(v.colorType) !== -1) {
        if (v.bits === 8) {
          E = (C = v.pixelBitlength == 32 ? new Uint32Array(v.decodePixels().buffer) : v.pixelBitlength == 16 ? new Uint16Array(v.decodePixels().buffer) : new Uint8Array(v.decodePixels().buffer)).length, q = new Uint8Array(E * v.colors), M = new Uint8Array(E);
          var D, tt = v.pixelBitlength - v.bits;
          for (T = 0, x = 0; T < E; T++) {
            for (S = C[T], D = 0; D < tt; ) q[x++] = S >>> D & 255, D += v.bits;
            M[T] = S >>> D & 255;
          }
        }
        if (v.bits === 16) {
          E = (C = new Uint32Array(v.decodePixels().buffer)).length, q = new Uint8Array(E * (32 / v.pixelBitlength) * v.colors), M = new Uint8Array(E * (32 / v.pixelBitlength)), N = v.colors > 1, T = 0, x = 0;
          for (var H = 0; T < E; ) S = C[T++], q[x++] = S >>> 0 & 255, N && (q[x++] = S >>> 16 & 255, S = C[T++], q[x++] = S >>> 0 & 255), M[H++] = S >>> 16 & 255;
          b = 8;
        }
        y !== n.image_compression.NONE && t() ? (p = e(q, v.width * v.colors, v.colors, y), R = e(M, v.width, 1, y)) : (p = q, R = M, X = void 0);
      }
      if (v.colorType === 3 && (_ = this.color_spaces.INDEXED, O = v.palette, v.transparency.indexed)) {
        var ct = v.transparency.indexed, it = 0;
        for (T = 0, E = ct.length; T < E; ++T) it += ct[T];
        if ((it /= 255) === E - 1 && ct.indexOf(0) !== -1) A = [ct.indexOf(0)];
        else if (it !== E) {
          for (C = v.decodePixels(), M = new Uint8Array(C.length), T = 0, E = C.length; T < E; T++) M[T] = ct[C[T]];
          R = e(M, v.width, 1);
        }
      }
      var P = function(z) {
        var G;
        switch (z) {
          case n.image_compression.FAST:
            G = 11;
            break;
          case n.image_compression.MEDIUM:
            G = 13;
            break;
          case n.image_compression.SLOW:
            G = 14;
            break;
          default:
            G = 12;
        }
        return G;
      }(y);
      return X === this.decode.FLATE_DECODE && (V = "/Predictor " + P + " "), V += "/Colors " + L + " /BitsPerComponent " + b + " /Columns " + v.width, (this.__addimage__.isArrayBuffer(p) || this.__addimage__.isArrayBufferView(p)) && (p = this.__addimage__.arrayBufferToBinaryString(p)), (R && this.__addimage__.isArrayBuffer(R) || this.__addimage__.isArrayBufferView(R)) && (R = this.__addimage__.arrayBufferToBinaryString(R)), { alias: g, data: p, index: f, filter: X, decodeParameters: V, transparency: A, palette: O, sMask: R, predictor: P, width: v.width, height: v.height, bitsPerComponent: b, colorSpace: _ };
    }
  };
})(Se.API), function(n) {
  n.processGIF89A = function(t, e, i, r) {
    var s = new Dv(t), o = s.width, a = s.height, l = [];
    s.decodeAndBlitFrameRGBA(0, l);
    var h = { data: l, width: o, height: a }, u = new Eh(100).encode(h, 100);
    return n.processJPEG.call(this, u, e, i, r);
  }, n.processGIF87A = n.processGIF89A;
}(Se.API), cr.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var t = 0; t < n; t++) {
      var e = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[t] = { red: r, green: i, blue: e, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, cr.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, t = this.width * this.height * 4;
    this.data = new Uint8Array(t), this[n]();
  } catch (e) {
    an.log("bit decode error:" + e);
  }
}, cr.prototype.bit1 = function() {
  var n, t = Math.ceil(this.width / 8), e = t % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, r = 0; r < t; r++) for (var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 8 * r * 4, a = 0; a < 8 && 8 * r + a < this.width; a++) {
      var l = this.palette[s >> 7 - a & 1];
      this.data[o + 4 * a] = l.blue, this.data[o + 4 * a + 1] = l.green, this.data[o + 4 * a + 2] = l.red, this.data[o + 4 * a + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, cr.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), t = n % 4, e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < n; r++) {
      var s = this.datav.getUint8(this.pos++, !0), o = i * this.width * 4 + 2 * r * 4, a = s >> 4, l = 15 & s, h = this.palette[a];
      if (this.data[o] = h.blue, this.data[o + 1] = h.green, this.data[o + 2] = h.red, this.data[o + 3] = 255, 2 * r + 1 >= this.width) break;
      h = this.palette[l], this.data[o + 4] = h.blue, this.data[o + 4 + 1] = h.green, this.data[o + 4 + 2] = h.red, this.data[o + 4 + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, cr.prototype.bit8 = function() {
  for (var n = this.width % 4, t = this.height - 1; t >= 0; t--) {
    for (var e = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var r = this.datav.getUint8(this.pos++, !0), s = e * this.width * 4 + 4 * i;
      if (r < this.palette.length) {
        var o = this.palette[r];
        this.data[s] = o.red, this.data[s + 1] = o.green, this.data[s + 2] = o.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, cr.prototype.bit15 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = this.height - 1; e >= 0; e--) {
    for (var i = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (s & t) / t * 255 | 0, a = (s >> 5 & t) / t * 255 | 0, l = (s >> 10 & t) / t * 255 | 0, h = s >> 15 ? 255 : 0, u = i * this.width * 4 + 4 * r;
      this.data[u] = l, this.data[u + 1] = a, this.data[u + 2] = o, this.data[u + 3] = h;
    }
    this.pos += n;
  }
}, cr.prototype.bit16 = function() {
  for (var n = this.width % 3, t = parseInt("11111", 2), e = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, s = 0; s < this.width; s++) {
      var o = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (o & t) / t * 255 | 0, l = (o >> 5 & e) / e * 255 | 0, h = (o >> 11) / t * 255 | 0, u = r * this.width * 4 + 4 * s;
      this.data[u] = h, this.data[u + 1] = l, this.data[u + 2] = a, this.data[u + 3] = 255;
    }
    this.pos += n;
  }
}, cr.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = t * this.width * 4 + 4 * e;
      this.data[o] = s, this.data[o + 1] = r, this.data[o + 2] = i, this.data[o + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, cr.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--) for (var t = this.bottom_up ? n : this.height - 1 - n, e = 0; e < this.width; e++) {
    var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = this.datav.getUint8(this.pos++, !0), a = t * this.width * 4 + 4 * e;
    this.data[a] = s, this.data[a + 1] = r, this.data[a + 2] = i, this.data[a + 3] = o;
  }
}, cr.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processBMP = function(t, e, i, r) {
    var s = new cr(t, !1), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Eh(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(Se.API), lg.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  n.processWEBP = function(t, e, i, r) {
    var s = new lg(t), o = s.width, a = s.height, l = { data: s.getData(), width: o, height: a }, h = new Eh(100).encode(l, 100);
    return n.processJPEG.call(this, h, e, i, r);
  };
}(Se.API), Se.API.processRGBA = function(n, t, e) {
  for (var i = n.data, r = i.length, s = new Uint8Array(r / 4 * 3), o = new Uint8Array(r / 4), a = 0, l = 0, h = 0; h < r; h += 4) {
    var u = i[h], d = i[h + 1], p = i[h + 2], f = i[h + 3];
    s[a++] = u, s[a++] = d, s[a++] = p, o[l++] = f;
  }
  var g = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o), data: g, index: t, alias: e, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, Se.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, ra = Se.API, Iu = ra.getCharWidthsArray = function(n, t) {
  var e, i, r = (t = t || {}).font || this.internal.getFont(), s = t.fontSize || this.internal.getFontSize(), o = t.charSpace || this.internal.getCharSpace(), a = t.widths ? t.widths : r.metadata.Unicode.widths, l = a.fof ? a.fof : 1, h = t.kerning ? t.kerning : r.metadata.Unicode.kerning, u = h.fof ? h.fof : 1, d = t.doKerning !== !1, p = 0, f = n.length, g = 0, y = a[0] || l, _ = [];
  for (e = 0; e < f; e++) i = n.charCodeAt(e), typeof r.metadata.widthOfString == "function" ? _.push((r.metadata.widthOfGlyph(r.metadata.characterToGlyph(i)) + o * (1e3 / s) || 0) / 1e3) : (p = d && nn(h[i]) === "object" && !isNaN(parseInt(h[i][g], 10)) ? h[i][g] / u : 0, _.push((a[i] || y) / l + p)), g = i;
  return _;
}, rg = ra.getStringUnitWidth = function(n, t) {
  var e = (t = t || {}).fontSize || this.internal.getFontSize(), i = t.font || this.internal.getFont(), r = t.charSpace || this.internal.getCharSpace();
  return ra.processArabic && (n = ra.processArabic(n)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(n, e, r) / e : Iu.apply(this, arguments).reduce(function(s, o) {
    return s + o;
  }, 0);
}, sg = function(n, t, e, i) {
  for (var r = [], s = 0, o = n.length, a = 0; s !== o && a + t[s] < e; ) a += t[s], s++;
  r.push(n.slice(0, s));
  var l = s;
  for (a = 0; s !== o; ) a + t[s] > i && (r.push(n.slice(l, s)), a = 0, l = s), a += t[s], s++;
  return l !== s && r.push(n.slice(l, s)), r;
}, og = function(n, t, e) {
  e || (e = {});
  var i, r, s, o, a, l, h, u = [], d = [u], p = e.textIndent || 0, f = 0, g = 0, y = n.split(" "), _ = Iu.apply(this, [" ", e])[0];
  if (l = e.lineIndent === -1 ? y[0].length + 2 : e.lineIndent || 0) {
    var b = Array(l).join(" "), v = [];
    y.map(function(L) {
      (L = L.split(/\s*\n/)).length > 1 ? v = v.concat(L.map(function(O, R) {
        return (R && O.length ? `
` : "") + O;
      })) : v.push(L[0]);
    }), y = v, l = rg.apply(this, [b, e]);
  }
  for (s = 0, o = y.length; s < o; s++) {
    var A = 0;
    if (i = y[s], l && i[0] == `
` && (i = i.substr(1), A = 1), p + f + (g = (r = Iu.apply(this, [i, e])).reduce(function(L, O) {
      return L + O;
    }, 0)) > t || A) {
      if (g > t) {
        for (a = sg.apply(this, [i, r, t - (p + f), t]), u.push(a.shift()), u = [a.pop()]; a.length; ) d.push([a.shift()]);
        g = r.slice(i.length - (u[0] ? u[0].length : 0)).reduce(function(L, O) {
          return L + O;
        }, 0);
      } else u = [i];
      d.push(u), p = g + l, f = _;
    } else u.push(i), p += f + g, f = _;
  }
  return h = l ? function(L, O) {
    return (O ? b : "") + L.join(" ");
  } : function(L) {
    return L.join(" ");
  }, d.map(h);
}, ra.splitTextToSize = function(n, t, e) {
  var i, r = (e = e || {}).fontSize || this.internal.getFontSize(), s = (function(u) {
    if (u.widths && u.kerning) return { widths: u.widths, kerning: u.kerning };
    var d = this.internal.getFont(u.fontName, u.fontStyle);
    return d.metadata.Unicode ? { widths: d.metadata.Unicode.widths || { 0: 1 }, kerning: d.metadata.Unicode.kerning || {} } : { font: d.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, e);
  i = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var o = 1 * this.internal.scaleFactor * t / r;
  s.textIndent = e.textIndent ? 1 * e.textIndent * this.internal.scaleFactor / r : 0, s.lineIndent = e.lineIndent;
  var a, l, h = [];
  for (a = 0, l = i.length; a < l; a++) h = h.concat(og.apply(this, [i[a], o, s]));
  return h;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var t = "klmnopqrstuvwxyz", e = {}, i = {}, r = 0; r < t.length; r++) e[t[r]] = "0123456789abcdef"[r], i["0123456789abcdef"[r]] = t[r];
  var s = function(d) {
    return "0x" + parseInt(d, 10).toString(16);
  }, o = n.__fontmetrics__.compress = function(d) {
    var p, f, g, y, _ = ["{"];
    for (var b in d) {
      if (p = d[b], isNaN(parseInt(b, 10)) ? f = "'" + b + "'" : (b = parseInt(b, 10), f = (f = s(b).slice(2)).slice(0, -1) + i[f.slice(-1)]), typeof p == "number") p < 0 ? (g = s(p).slice(3), y = "-") : (g = s(p).slice(2), y = ""), g = y + g.slice(0, -1) + i[g.slice(-1)];
      else {
        if (nn(p) !== "object") throw new Error("Don't know what to do with value type " + nn(p) + ".");
        g = o(p);
      }
      _.push(f + g);
    }
    return _.push("}"), _.join("");
  }, a = n.__fontmetrics__.uncompress = function(d) {
    if (typeof d != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var p, f, g, y, _ = {}, b = 1, v = _, A = [], L = "", O = "", R = d.length - 1, C = 1; C < R; C += 1) (y = d[C]) == "'" ? p ? (g = p.join(""), p = void 0) : p = [] : p ? p.push(y) : y == "{" ? (A.push([v, g]), v = {}, g = void 0) : y == "}" ? ((f = A.pop())[0][f[1]] = v, g = void 0, v = f[0]) : y == "-" ? b = -1 : g === void 0 ? e.hasOwnProperty(y) ? (L += e[y], g = parseInt(L, 16) * b, b = 1, L = "") : L += y : e.hasOwnProperty(y) ? (O += e[y], v[g] = parseInt(O, 16) * b, b = 1, g = void 0, O = "") : O += y;
    return _;
  }, l = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: a("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h = { Unicode: { Courier: l, "Courier-Bold": l, "Courier-BoldOblique": l, "Courier-Oblique": l, Helvetica: l, "Helvetica-Bold": l, "Helvetica-BoldOblique": l, "Helvetica-Oblique": l, "Times-Roman": l, "Times-Bold": l, "Times-BoldItalic": l, "Times-Italic": l } }, u = { Unicode: { "Courier-Oblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": a("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": a("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: a("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: a("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": a("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": a("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(d) {
    var p = d.font, f = u.Unicode[p.postScriptName];
    f && (p.metadata.Unicode = {}, p.metadata.Unicode.widths = f.widths, p.metadata.Unicode.kerning = f.kerning);
    var g = h.Unicode[p.postScriptName];
    g && (p.metadata.Unicode.encoding = g, p.encoding = g.codePages[0]);
  }]);
}(Se.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function(e) {
    for (var i = e.length, r = new Uint8Array(i), s = 0; s < i; s++) r[s] = e.charCodeAt(s);
    return r;
  };
  n.API.events.push(["addFont", function(e) {
    var i = void 0, r = e.font, s = e.instance;
    if (!r.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      if (typeof (i = s.existsFileInVFS(r.postScriptName) === !1 ? s.loadFile(r.postScriptName) : s.getFileFromVFS(r.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      (function(o, a) {
        a = /^\x00\x01\x00\x00/.test(a) ? t(a) : t(Sl(a)), o.metadata = n.API.TTFFont.open(a), o.metadata.Unicode = o.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, o.metadata.glyIdsUsed = [0];
      })(r, i);
    }
  }]);
}(Se), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  function t() {
    return (Ae.canvg ? Promise.resolve(Ae.canvg) : import("./index.es-eVyqwS38.js")).catch(function(e) {
      return Promise.reject(new Error("Could not load canvg: " + e));
    }).then(function(e) {
      return e.default ? e.default : e;
    });
  }
  Se.API.addSvgAsImage = function(e, i, r, s, o, a, l, h) {
    if (isNaN(i) || isNaN(r)) throw an.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(o)) throw an.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var u = document.createElement("canvas");
    u.width = s, u.height = o;
    var d = u.getContext("2d");
    d.fillStyle = "#fff", d.fillRect(0, 0, u.width, u.height);
    var p = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, f = this;
    return t().then(function(g) {
      return g.fromString(d, e, p);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(g) {
      return g.render(p);
    }).then(function() {
      f.addImage(u.toDataURL("image/jpeg", 1), i, r, s, o, l, h);
    });
  };
}(), Se.API.putTotalPages = function(n) {
  var t, e = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (t = new RegExp(n, "g"), e = this.internal.getNumberOfPages()) : (t = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), e = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++) for (var r = 0; r < this.internal.pages[i].length; r++) this.internal.pages[i][r] = this.internal.pages[i][r].replace(t, e);
  return this;
}, Se.API.viewerPreferences = function(n, t) {
  var e;
  n = n || {}, t = t || !1;
  var i, r, s, o = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, a = Object.keys(o), l = [], h = 0, u = 0, d = 0;
  function p(g, y) {
    var _, b = !1;
    for (_ = 0; _ < g.length; _ += 1) g[_] === y && (b = !0);
    return b;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(o)), this.internal.viewerpreferences.isSubscribed = !1), e = this.internal.viewerpreferences.configuration, n === "reset" || t === !0) {
    var f = a.length;
    for (d = 0; d < f; d += 1) e[a[d]].value = e[a[d]].defaultValue, e[a[d]].explicitSet = !1;
  }
  if (nn(n) === "object") {
    for (r in n) if (s = n[r], p(a, r) && s !== void 0) {
      if (e[r].type === "boolean" && typeof s == "boolean") e[r].value = s;
      else if (e[r].type === "name" && p(e[r].valueSet, s)) e[r].value = s;
      else if (e[r].type === "integer" && Number.isInteger(s)) e[r].value = s;
      else if (e[r].type === "array") {
        for (h = 0; h < s.length; h += 1) if (i = !0, s[h].length === 1 && typeof s[h][0] == "number") l.push(String(s[h] - 1));
        else if (s[h].length > 1) {
          for (u = 0; u < s[h].length; u += 1) typeof s[h][u] != "number" && (i = !1);
          i === !0 && l.push([s[h][0] - 1, s[h][1] - 1].join(" "));
        }
        e[r].value = "[" + l.join(" ") + "]";
      } else e[r].value = e[r].defaultValue;
      e[r].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var g, y = [];
    for (g in e) e[g].explicitSet === !0 && (e[g].type === "name" ? y.push("/" + g + " /" + e[g].value) : y.push("/" + g + " " + e[g].value));
    y.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + y.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = e, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(n) {
  var t = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', r = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(i)), o = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), a = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), l = unescape(encodeURIComponent("</x:xmpmeta>")), h = s.length + o.length + a.length + r.length + l.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + h + " >>"), this.internal.write("stream"), this.internal.write(r + s + o + a + l), this.internal.write("endstream"), this.internal.write("endobj");
  }, e = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(i, r) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", e), this.internal.events.subscribe("postPutResources", t)), this;
  };
}(Se.API), function(n) {
  var t = n.API, e = t.pdfEscape16 = function(s, o) {
    for (var a, l = o.metadata.Unicode.widths, h = ["", "0", "00", "000", "0000"], u = [""], d = 0, p = s.length; d < p; ++d) {
      if (a = o.metadata.characterToGlyph(s.charCodeAt(d)), o.metadata.glyIdsUsed.push(a), o.metadata.toUnicode[a] = s.charCodeAt(d), l.indexOf(a) == -1 && (l.push(a), l.push([parseInt(o.metadata.widthOfGlyph(a), 10)])), a == "0") return u.join("");
      a = a.toString(16), u.push(h[4 - a.length], a);
    }
    return u.join("");
  }, i = function(s) {
    var o, a, l, h, u, d, p;
    for (u = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, l = [], d = 0, p = (a = Object.keys(s).sort(function(f, g) {
      return f - g;
    })).length; d < p; d++) o = a[d], l.length >= 100 && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar`, l = []), s[o] !== void 0 && s[o] !== null && typeof s[o].toString == "function" && (h = ("0000" + s[o].toString(16)).slice(-4), o = ("0000" + (+o).toString(16)).slice(-4), l.push("<" + o + "><" + h + ">"));
    return l.length && (u += `
` + l.length + ` beginbfchar
` + l.join(`
`) + `
endbfchar
`), u += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "Identity-H") {
        for (var d = a.metadata.Unicode.widths, p = a.metadata.subset.encode(a.metadata.glyIdsUsed, 1), f = "", g = 0; g < p.length; g++) f += String.fromCharCode(p[g]);
        var y = h();
        u({ data: f, addLength1: !0, objectId: y }), l("endobj");
        var _ = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: _ }), l("endobj");
        var b = h();
        l("<<"), l("/Type /FontDescriptor"), l("/FontName /" + pa(a.fontName)), l("/FontFile2 " + y + " 0 R"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/Flags " + a.metadata.flags), l("/StemV " + a.metadata.stemV), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l(">>"), l("endobj");
        var v = h();
        l("<<"), l("/Type /Font"), l("/BaseFont /" + pa(a.fontName)), l("/FontDescriptor " + b + " 0 R"), l("/W " + n.API.PDFObject.convert(d)), l("/CIDToGIDMap /Identity"), l("/DW 1000"), l("/Subtype /CIDFontType2"), l("/CIDSystemInfo"), l("<<"), l("/Supplement 0"), l("/Registry (Adobe)"), l("/Ordering (" + a.encoding + ")"), l(">>"), l(">>"), l("endobj"), a.objectNumber = h(), l("<<"), l("/Type /Font"), l("/Subtype /Type0"), l("/ToUnicode " + _ + " 0 R"), l("/BaseFont /" + pa(a.fontName)), l("/Encoding /" + a.encoding), l("/DescendantFonts [" + v + " 0 R]"), l(">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]), t.events.push(["putFont", function(s) {
    (function(o) {
      var a = o.font, l = o.out, h = o.newObject, u = o.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "WinAnsiEncoding") {
        for (var d = a.metadata.rawData, p = "", f = 0; f < d.length; f++) p += String.fromCharCode(d[f]);
        var g = h();
        u({ data: p, addLength1: !0, objectId: g }), l("endobj");
        var y = h();
        u({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: y }), l("endobj");
        var _ = h();
        l("<<"), l("/Descent " + a.metadata.decender), l("/CapHeight " + a.metadata.capHeight), l("/StemV " + a.metadata.stemV), l("/Type /FontDescriptor"), l("/FontFile2 " + g + " 0 R"), l("/Flags 96"), l("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), l("/FontName /" + pa(a.fontName)), l("/ItalicAngle " + a.metadata.italicAngle), l("/Ascent " + a.metadata.ascender), l(">>"), l("endobj"), a.objectNumber = h();
        for (var b = 0; b < a.metadata.hmtx.widths.length; b++) a.metadata.hmtx.widths[b] = parseInt(a.metadata.hmtx.widths[b] * (1e3 / a.metadata.head.unitsPerEm));
        l("<</Subtype/TrueType/Type/Font/ToUnicode " + y + " 0 R/BaseFont/" + pa(a.fontName) + "/FontDescriptor " + _ + " 0 R/Encoding/" + a.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(a.metadata.hmtx.widths) + ">>"), l("endobj"), a.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var r = function(s) {
    var o, a = s.text || "", l = s.x, h = s.y, u = s.options || {}, d = s.mutex || {}, p = d.pdfEscape, f = d.activeFontKey, g = d.fonts, y = f, _ = "", b = 0, v = "", A = g[y].encoding;
    if (g[y].encoding !== "Identity-H") return { text: a, x: l, y: h, options: u, mutex: d };
    for (v = a, y = f, Array.isArray(a) && (v = a[0]), b = 0; b < v.length; b += 1) g[y].metadata.hasOwnProperty("cmap") && (o = g[y].metadata.cmap.unicode.codeMap[v[b].charCodeAt(0)]), o || v[b].charCodeAt(0) < 256 && g[y].metadata.hasOwnProperty("Unicode") ? _ += v[b] : _ += "";
    var L = "";
    return parseInt(y.slice(1)) < 14 || A === "WinAnsiEncoding" ? L = p(_, y).split("").map(function(O) {
      return O.charCodeAt(0).toString(16);
    }).join("") : A === "Identity-H" && (L = e(_, g[y])), d.isHex = !0, { text: L, x: l, y: h, options: u, mutex: d };
  };
  t.events.push(["postProcessText", function(s) {
    var o = s.text || "", a = [], l = { text: o, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(o)) {
      var h = 0;
      for (h = 0; h < o.length; h += 1) Array.isArray(o[h]) && o[h].length === 3 ? a.push([r(Object.assign({}, l, { text: o[h][0] })).text, o[h][1], o[h][2]]) : a.push(r(Object.assign({}, l, { text: o[h] })).text);
      s.text = a;
    } else s.text = r(Object.assign({}, l, { text: o })).text;
  }]);
}(Se), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(n) {
  var t = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0;
  }, n.addFileToVFS = function(e, i) {
    return t.call(this), this.internal.vFS[e] = i, this;
  }, n.getFileFromVFS = function(e) {
    return t.call(this), this.internal.vFS[e] !== void 0 ? this.internal.vFS[e] : null;
  };
}(Se.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(i) {
    var r, s, o, a, l, h, u, d = t, p = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], f = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], g = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, y = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, _ = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], b = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), v = !1, A = 0;
    this.__bidiEngine__ = {};
    var L = function(N) {
      var S = N.charCodeAt(), T = S >> 8, x = y[T];
      return x !== void 0 ? d[256 * x + (255 & S)] : T === 252 || T === 253 ? "AL" : b.test(T) ? "L" : T === 8 ? "R" : "N";
    }, O = function(N) {
      for (var S, T = 0; T < N.length; T++) {
        if ((S = L(N.charAt(T))) === "L") return !1;
        if (S === "R") return !0;
      }
      return !1;
    }, R = function(N, S, T, x) {
      var X, V, D, tt, H = S[x];
      switch (H) {
        case "L":
        case "R":
          v = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          v && (H = "AN");
          break;
        case "AL":
          v = !0, H = "R";
          break;
        case "WS":
          H = "N";
          break;
        case "CS":
          x < 1 || x + 1 >= S.length || (X = T[x - 1]) !== "EN" && X !== "AN" || (V = S[x + 1]) !== "EN" && V !== "AN" ? H = "N" : v && (V = "AN"), H = V === X ? V : "N";
          break;
        case "ES":
          H = (X = x > 0 ? T[x - 1] : "B") === "EN" && x + 1 < S.length && S[x + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (x > 0 && T[x - 1] === "EN") {
            H = "EN";
            break;
          }
          if (v) {
            H = "N";
            break;
          }
          for (D = x + 1, tt = S.length; D < tt && S[D] === "ET"; ) D++;
          H = D < tt && S[D] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (o && !a) {
            for (tt = S.length, D = x + 1; D < tt && S[D] === "NSM"; ) D++;
            if (D < tt) {
              var ct = N[x], it = ct >= 1425 && ct <= 2303 || ct === 64286;
              if (X = S[D], it && (X === "R" || X === "AL")) {
                H = "R";
                break;
              }
            }
          }
          H = x < 1 || (X = S[x - 1]) === "B" ? "N" : T[x - 1];
          break;
        case "B":
          v = !1, r = !0, H = A;
          break;
        case "S":
          s = !0, H = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          v = !1;
          break;
        case "BN":
          H = "N";
      }
      return H;
    }, C = function(N, S, T) {
      var x = N.split("");
      return T && E(x, T, { hiLevel: A }), x.reverse(), S && S.reverse(), x.join("");
    }, E = function(N, S, T) {
      var x, X, V, D, tt, H = -1, ct = N.length, it = 0, P = [], z = A ? f : p, G = [];
      for (v = !1, r = !1, s = !1, X = 0; X < ct; X++) G[X] = L(N[X]);
      for (V = 0; V < ct; V++) {
        if (tt = it, P[V] = R(N, G, P, V), x = 240 & (it = z[tt][g[P[V]]]), it &= 15, S[V] = D = z[it][5], x > 0) if (x === 16) {
          for (X = H; X < V; X++) S[X] = 1;
          H = -1;
        } else H = -1;
        if (z[it][6]) H === -1 && (H = V);
        else if (H > -1) {
          for (X = H; X < V; X++) S[X] = D;
          H = -1;
        }
        G[V] === "B" && (S[V] = 0), T.hiLevel |= D;
      }
      s && function(Y, ot, xt) {
        for (var gt = 0; gt < xt; gt++) if (Y[gt] === "S") {
          ot[gt] = A;
          for (var wt = gt - 1; wt >= 0 && Y[wt] === "WS"; wt--) ot[wt] = A;
        }
      }(G, S, ct);
    }, M = function(N, S, T, x, X) {
      if (!(X.hiLevel < N)) {
        if (N === 1 && A === 1 && !r) return S.reverse(), void (T && T.reverse());
        for (var V, D, tt, H, ct = S.length, it = 0; it < ct; ) {
          if (x[it] >= N) {
            for (tt = it + 1; tt < ct && x[tt] >= N; ) tt++;
            for (H = it, D = tt - 1; H < D; H++, D--) V = S[H], S[H] = S[D], S[D] = V, T && (V = T[H], T[H] = T[D], T[D] = V);
            it = tt;
          }
          it++;
        }
      }
    }, q = function(N, S, T) {
      var x = N.split(""), X = { hiLevel: A };
      return T || (T = []), E(x, T, X), function(V, D, tt) {
        if (tt.hiLevel !== 0 && u) for (var H, ct = 0; ct < V.length; ct++) D[ct] === 1 && (H = _.indexOf(V[ct])) >= 0 && (V[ct] = _[H + 1]);
      }(x, T, X), M(2, x, S, T, X), M(1, x, S, T, X), x.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(N, S, T) {
      if (function(X, V) {
        if (V) for (var D = 0; D < X.length; D++) V[D] = D;
        a === void 0 && (a = O(X)), h === void 0 && (h = O(X));
      }(N, S), o || !l || h) if (o && l && a ^ h) A = a ? 1 : 0, N = C(N, S, T);
      else if (!o && l && h) A = a ? 1 : 0, N = q(N, S, T), N = C(N, S);
      else if (!o || a || l || h) {
        if (o && !l && a ^ h) N = C(N, S), a ? (A = 0, N = q(N, S, T)) : (A = 1, N = q(N, S, T), N = C(N, S));
        else if (o && a && !l && h) A = 1, N = q(N, S, T), N = C(N, S);
        else if (!o && !l && a ^ h) {
          var x = u;
          a ? (A = 1, N = q(N, S, T), A = 0, u = !1, N = q(N, S, T), u = x) : (A = 0, N = q(N, S, T), N = C(N, S), A = 1, u = !1, N = q(N, S, T), u = x, N = C(N, S));
        }
      } else A = 0, N = q(N, S, T);
      else A = a ? 1 : 0, N = q(N, S, T);
      return N;
    }, this.__bidiEngine__.setOptions = function(N) {
      N && (o = N.isInputVisual, l = N.isOutputVisual, a = N.isInputRtl, h = N.isOutputRtl, u = N.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var t = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], e = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(i) {
    var r = i.text, s = (i.x, i.y, i.options || {}), o = (i.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, e.setOptions(s), Object.prototype.toString.call(r) === "[object Array]") {
      var a = 0;
      for (o = [], a = 0; a < r.length; a += 1) Object.prototype.toString.call(r[a]) === "[object Array]" ? o.push([e.doBidiReorder(r[a][0]), r[a][1], r[a][2]]) : o.push([e.doBidiReorder(r[a])]);
      i.text = o;
    } else i.text = e.doBidiReorder(r);
    e.setOptions({ isInputVisual: !0 });
  }]);
}(Se), Se.API.TTFFont = function() {
  function n(t) {
    var e;
    if (this.rawData = t, e = this.contents = new $s(t), this.contents.pos = 4, e.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Zv(this), this.registerTTF();
  }
  return n.open = function(t) {
    return new n(t);
  }, n.prototype.parse = function() {
    return this.directory = new Bv(this.contents), this.head = new qv(this), this.name = new Hv(this), this.cmap = new B1(this), this.toUnicode = {}, this.hhea = new zv(this), this.maxp = new Gv(this), this.hmtx = new Vv(this), this.post = new Uv(this), this.os2 = new $v(this), this.loca = new Jv(this), this.glyf = new Yv(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var t, e, i, r, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var o, a, l, h;
      for (h = [], o = 0, a = (l = this.bbox).length; o < a; o++) t = l[o], h.push(Math.round(t * this.scaleFactor));
      return h;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (r = this.post.italic_angle), 32768 & (e = r >> 16) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(t) {
    var e;
    return ((e = this.cmap.unicode) != null ? e.codeMap[t] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(t) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * e;
  }, n.prototype.widthOfString = function(t, e, i) {
    var r, s, o, a;
    for (o = 0, s = 0, a = (t = "" + t).length; 0 <= a ? s < a : s > a; s = 0 <= a ? ++s : --s) r = t.charCodeAt(s), o += this.widthOfGlyph(this.characterToGlyph(r)) + i * (1e3 / e) || 0;
    return o * (e / 1e3);
  }, n.prototype.lineHeight = function(t, e) {
    var i;
    return e == null && (e = !1), i = e ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * t;
  }, n;
}();
var wr, $s = function() {
  function n(t) {
    this.data = t ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(t) {
    return this.data[this.pos++] = t;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(t) {
    return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt32 = function() {
    var t;
    return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t;
  }, n.prototype.writeInt32 = function(t) {
    return t < 0 && (t += 4294967296), this.writeUInt32(t);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(t) {
    return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, n.prototype.readInt16 = function() {
    var t;
    return (t = this.readUInt16()) >= 32768 ? t - 65536 : t;
  }, n.prototype.writeInt16 = function(t) {
    return t < 0 && (t += 65536), this.writeUInt16(t);
  }, n.prototype.readString = function(t) {
    var e, i;
    for (i = [], e = 0; 0 <= t ? e < t : e > t; e = 0 <= t ? ++e : --e) i[e] = String.fromCharCode(this.readByte());
    return i.join("");
  }, n.prototype.writeString = function(t) {
    var e, i, r;
    for (r = [], e = 0, i = t.length; 0 <= i ? e < i : e > i; e = 0 <= i ? ++e : --e) r.push(this.writeByte(t.charCodeAt(e)));
    return r;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(t) {
    return this.writeInt16(t);
  }, n.prototype.readLongLong = function() {
    var t, e, i, r, s, o, a, l;
    return t = this.readByte(), e = this.readByte(), i = this.readByte(), r = this.readByte(), s = this.readByte(), o = this.readByte(), a = this.readByte(), l = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ s) + 65536 * (255 ^ o) + 256 * (255 ^ a) + (255 ^ l) + 1) : 72057594037927940 * t + 281474976710656 * e + 1099511627776 * i + 4294967296 * r + 16777216 * s + 65536 * o + 256 * a + l;
  }, n.prototype.writeLongLong = function(t) {
    var e, i;
    return e = Math.floor(t / 4294967296), i = 4294967295 & t, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(t) {
    return this.writeInt32(t);
  }, n.prototype.read = function(t) {
    var e, i;
    for (e = [], i = 0; 0 <= t ? i < t : i > t; i = 0 <= t ? ++i : --i) e.push(this.readByte());
    return e;
  }, n.prototype.write = function(t) {
    var e, i, r, s;
    for (s = [], i = 0, r = t.length; i < r; i++) e = t[i], s.push(this.writeByte(e));
    return s;
  }, n;
}(), Bv = function() {
  var n;
  function t(e) {
    var i, r, s;
    for (this.scalarType = e.readInt(), this.tableCount = e.readShort(), this.searchRange = e.readShort(), this.entrySelector = e.readShort(), this.rangeShift = e.readShort(), this.tables = {}, r = 0, s = this.tableCount; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = { tag: e.readString(4), checksum: e.readInt(), offset: e.readInt(), length: e.readInt() }, this.tables[i.tag] = i;
  }
  return t.prototype.encode = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, y;
    for (y in f = Object.keys(e).length, l = Math.log(2), d = 16 * Math.floor(Math.log(f) / l), o = Math.floor(d / l), u = 16 * f - d, (r = new $s()).writeInt(this.scalarType), r.writeShort(f), r.writeShort(d), r.writeShort(o), r.writeShort(u), s = 16 * f, h = r.pos + s, a = null, g = [], e) for (p = e[y], r.writeString(y), r.writeInt(n(p)), r.writeInt(h), r.writeInt(p.length), g = g.concat(p), y === "head" && (a = h), h += p.length; h % 4; ) g.push(0), h++;
    return r.write(g), i = 2981146554 - n(r.data), r.pos = a + 8, r.writeUInt32(i), r.data;
  }, n = function(e) {
    var i, r, s, o;
    for (e = j1.call(e); e.length % 4; ) e.push(0);
    for (s = new $s(e), r = 0, i = 0, o = e.length; i < o; i = i += 4) r += s.readUInt32();
    return 4294967295 & r;
  }, t;
}(), jv = {}.hasOwnProperty, Dr = function(n, t) {
  for (var e in t) jv.call(t, e) && (n[e] = t[e]);
  function i() {
    this.constructor = n;
  }
  return i.prototype = t.prototype, n.prototype = new i(), n.__super__ = t.prototype, n;
};
wr = function() {
  function n(t) {
    var e;
    this.file = t, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var qv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "head", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.revision = e.readInt(), this.checkSumAdjustment = e.readInt(), this.magicNumber = e.readInt(), this.flags = e.readShort(), this.unitsPerEm = e.readShort(), this.created = e.readLongLong(), this.modified = e.readLongLong(), this.xMin = e.readShort(), this.yMin = e.readShort(), this.xMax = e.readShort(), this.yMax = e.readShort(), this.macStyle = e.readShort(), this.lowestRecPPEM = e.readShort(), this.fontDirectionHint = e.readShort(), this.indexToLocFormat = e.readShort(), this.glyphDataFormat = e.readShort();
  }, t.prototype.encode = function(e) {
    var i;
    return (i = new $s()).writeInt(this.version), i.writeInt(this.revision), i.writeInt(this.checkSumAdjustment), i.writeInt(this.magicNumber), i.writeShort(this.flags), i.writeShort(this.unitsPerEm), i.writeLongLong(this.created), i.writeLongLong(this.modified), i.writeShort(this.xMin), i.writeShort(this.yMin), i.writeShort(this.xMax), i.writeShort(this.yMax), i.writeShort(this.macStyle), i.writeShort(this.lowestRecPPEM), i.writeShort(this.fontDirectionHint), i.writeShort(e), i.writeShort(this.glyphDataFormat), i.data;
  }, t;
}(), ug = function() {
  function n(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, y, _, b, v, A;
    switch (this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = e + t.readInt(), d = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (l = 0; l < 256; ++l) this.codeMap[l] = t.readByte();
        break;
      case 4:
        for (f = t.readUInt16(), p = f / 2, t.pos += 6, s = function() {
          var L, O;
          for (O = [], l = L = 0; 0 <= p ? L < p : L > p; l = 0 <= p ? ++L : --L) O.push(t.readUInt16());
          return O;
        }(), t.pos += 2, y = function() {
          var L, O;
          for (O = [], l = L = 0; 0 <= p ? L < p : L > p; l = 0 <= p ? ++L : --L) O.push(t.readUInt16());
          return O;
        }(), h = function() {
          var L, O;
          for (O = [], l = L = 0; 0 <= p ? L < p : L > p; l = 0 <= p ? ++L : --L) O.push(t.readUInt16());
          return O;
        }(), u = function() {
          var L, O;
          for (O = [], l = L = 0; 0 <= p ? L < p : L > p; l = 0 <= p ? ++L : --L) O.push(t.readUInt16());
          return O;
        }(), r = (this.length - t.pos + this.offset) / 2, a = function() {
          var L, O;
          for (O = [], l = L = 0; 0 <= r ? L < r : L > r; l = 0 <= r ? ++L : --L) O.push(t.readUInt16());
          return O;
        }(), l = b = 0, A = s.length; b < A; l = ++b) for (_ = s[l], i = v = g = y[l]; g <= _ ? v <= _ : v >= _; i = g <= _ ? ++v : --v) u[l] === 0 ? o = i + h[l] : (o = a[u[l] / 2 + (i - g) - (p - l)] || 0) !== 0 && (o += h[l]), this.codeMap[i] = 65535 & o;
    }
    t.pos = d;
  }
  return n.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, y, _, b, v, A, L, O, R, C, E, M, q, N, S, T, x, X, V, D, tt, H, ct, it, P, z, G, Y, ot, xt, gt, wt, qt, Dt, Yt;
    switch (x = new $s(), o = Object.keys(t).sort(function(Xt, F) {
      return Xt - F;
    }), e) {
      case "macroman":
        for (y = 0, _ = function() {
          var Xt = [];
          for (g = 0; g < 256; ++g) Xt.push(0);
          return Xt;
        }(), v = { 0: 0 }, s = {}, X = 0, H = o.length; X < H; X++) v[wt = t[r = o[X]]] == null && (v[wt] = ++y), s[r] = { old: t[r], new: v[t[r]] }, _[r] = v[t[r]];
        return x.writeUInt16(1), x.writeUInt16(0), x.writeUInt32(12), x.writeUInt16(0), x.writeUInt16(262), x.writeUInt16(0), x.write(_), { charMap: s, subtable: x.data, maxGlyphID: y + 1 };
      case "unicode":
        for (S = [], d = [], A = 0, v = {}, i = {}, b = h = null, V = 0, ct = o.length; V < ct; V++) v[O = t[r = o[V]]] == null && (v[O] = ++A), i[r] = { old: O, new: v[O] }, a = v[O] - r, b != null && a === h || (b && d.push(b), S.push(r), h = a), b = r;
        for (b && d.push(b), d.push(65535), S.push(65535), q = 2 * (M = S.length), E = 2 * Math.pow(Math.log(M) / Math.LN2, 2), p = Math.log(E / 2) / Math.LN2, C = 2 * M - E, l = [], R = [], f = [], g = D = 0, it = S.length; D < it; g = ++D) {
          if (N = S[g], u = d[g], N === 65535) {
            l.push(0), R.push(0);
            break;
          }
          if (N - (T = i[N].new) >= 32768) for (l.push(0), R.push(2 * (f.length + M - g)), r = tt = N; N <= u ? tt <= u : tt >= u; r = N <= u ? ++tt : --tt) f.push(i[r].new);
          else l.push(T - N), R.push(0);
        }
        for (x.writeUInt16(3), x.writeUInt16(1), x.writeUInt32(12), x.writeUInt16(4), x.writeUInt16(16 + 8 * M + 2 * f.length), x.writeUInt16(0), x.writeUInt16(q), x.writeUInt16(E), x.writeUInt16(p), x.writeUInt16(C), xt = 0, P = d.length; xt < P; xt++) r = d[xt], x.writeUInt16(r);
        for (x.writeUInt16(0), gt = 0, z = S.length; gt < z; gt++) r = S[gt], x.writeUInt16(r);
        for (qt = 0, G = l.length; qt < G; qt++) a = l[qt], x.writeUInt16(a);
        for (Dt = 0, Y = R.length; Dt < Y; Dt++) L = R[Dt], x.writeUInt16(L);
        for (Yt = 0, ot = f.length; Yt < ot; Yt++) y = f[Yt], x.writeUInt16(y);
        return { charMap: i, subtable: x.data, maxGlyphID: A + 1 };
    }
  }, n;
}(), B1 = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "cmap", t.prototype.parse = function(e) {
    var i, r, s;
    for (e.pos = this.offset, this.version = e.readUInt16(), s = e.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= s ? r < s : r > s; r = 0 <= s ? ++r : --r) i = new ug(e, this.offset), this.tables.push(i), i.isUnicode && this.unicode == null && (this.unicode = i);
    return !0;
  }, t.encode = function(e, i) {
    var r, s;
    return i == null && (i = "macroman"), r = ug.encode(e, i), (s = new $s()).writeUInt16(0), s.writeUInt16(1), r.table = s.data.concat(r.subtable), r;
  }, t;
}(), zv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "hhea", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.ascender = e.readShort(), this.decender = e.readShort(), this.lineGap = e.readShort(), this.advanceWidthMax = e.readShort(), this.minLeftSideBearing = e.readShort(), this.minRightSideBearing = e.readShort(), this.xMaxExtent = e.readShort(), this.caretSlopeRise = e.readShort(), this.caretSlopeRun = e.readShort(), this.caretOffset = e.readShort(), e.pos += 8, this.metricDataFormat = e.readShort(), this.numberOfMetrics = e.readUInt16();
  }, t;
}(), $v = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "OS/2", t.prototype.parse = function(e) {
    if (e.pos = this.offset, this.version = e.readUInt16(), this.averageCharWidth = e.readShort(), this.weightClass = e.readUInt16(), this.widthClass = e.readUInt16(), this.type = e.readShort(), this.ySubscriptXSize = e.readShort(), this.ySubscriptYSize = e.readShort(), this.ySubscriptXOffset = e.readShort(), this.ySubscriptYOffset = e.readShort(), this.ySuperscriptXSize = e.readShort(), this.ySuperscriptYSize = e.readShort(), this.ySuperscriptXOffset = e.readShort(), this.ySuperscriptYOffset = e.readShort(), this.yStrikeoutSize = e.readShort(), this.yStrikeoutPosition = e.readShort(), this.familyClass = e.readShort(), this.panose = function() {
      var i, r;
      for (r = [], i = 0; i < 10; ++i) r.push(e.readByte());
      return r;
    }(), this.charRange = function() {
      var i, r;
      for (r = [], i = 0; i < 4; ++i) r.push(e.readInt());
      return r;
    }(), this.vendorID = e.readString(4), this.selection = e.readShort(), this.firstCharIndex = e.readShort(), this.lastCharIndex = e.readShort(), this.version > 0 && (this.ascent = e.readShort(), this.descent = e.readShort(), this.lineGap = e.readShort(), this.winAscent = e.readShort(), this.winDescent = e.readShort(), this.codePageRange = function() {
      var i, r;
      for (r = [], i = 0; i < 2; i = ++i) r.push(e.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = e.readShort(), this.capHeight = e.readShort(), this.defaultChar = e.readShort(), this.breakChar = e.readShort(), this.maxContext = e.readShort();
  }, t;
}(), Uv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "post", t.prototype.parse = function(e) {
    var i, r, s;
    switch (e.pos = this.offset, this.format = e.readInt(), this.italicAngle = e.readInt(), this.underlinePosition = e.readShort(), this.underlineThickness = e.readShort(), this.isFixedPitch = e.readInt(), this.minMemType42 = e.readInt(), this.maxMemType42 = e.readInt(), this.minMemType1 = e.readInt(), this.maxMemType1 = e.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var o;
        for (r = e.readUInt16(), this.glyphNameIndex = [], o = 0; 0 <= r ? o < r : o > r; o = 0 <= r ? ++o : --o) this.glyphNameIndex.push(e.readUInt16());
        for (this.names = [], s = []; e.pos < this.offset + this.length; ) i = e.readByte(), s.push(this.names.push(e.readString(i)));
        return s;
      case 151552:
        return r = e.readUInt16(), this.offsets = e.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var a, l, h;
          for (h = [], o = a = 0, l = this.file.maxp.numGlyphs; 0 <= l ? a < l : a > l; o = 0 <= l ? ++a : --a) h.push(e.readUInt32());
          return h;
        }).call(this);
    }
  }, t;
}(), Wv = function(n, t) {
  this.raw = n, this.length = n.length, this.platformID = t.platformID, this.encodingID = t.encodingID, this.languageID = t.languageID;
}, Hv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "name", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h, u, d, p, f;
    for (e.pos = this.offset, e.readShort(), i = e.readShort(), l = e.readShort(), r = [], o = 0; 0 <= i ? o < i : o > i; o = 0 <= i ? ++o : --o) r.push({ platformID: e.readShort(), encodingID: e.readShort(), languageID: e.readShort(), nameID: e.readShort(), length: e.readShort(), offset: this.offset + l + e.readShort() });
    for (h = {}, o = d = 0, p = r.length; d < p; o = ++d) s = r[o], e.pos = s.offset, u = e.readString(s.length), a = new Wv(u, s), h[f = s.nameID] == null && (h[f] = []), h[s.nameID].push(a);
    this.strings = h, this.copyright = h[0], this.fontFamily = h[1], this.fontSubfamily = h[2], this.uniqueSubfamily = h[3], this.fontName = h[4], this.version = h[5];
    try {
      this.postscriptName = h[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = h[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = h[7], this.manufacturer = h[8], this.designer = h[9], this.description = h[10], this.vendorUrl = h[11], this.designerUrl = h[12], this.license = h[13], this.licenseUrl = h[14], this.preferredFamily = h[15], this.preferredSubfamily = h[17], this.compatibleFull = h[18], this.sampleText = h[19];
  }, t;
}(), Gv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "maxp", t.prototype.parse = function(e) {
    return e.pos = this.offset, this.version = e.readInt(), this.numGlyphs = e.readUInt16(), this.maxPoints = e.readUInt16(), this.maxContours = e.readUInt16(), this.maxCompositePoints = e.readUInt16(), this.maxComponentContours = e.readUInt16(), this.maxZones = e.readUInt16(), this.maxTwilightPoints = e.readUInt16(), this.maxStorage = e.readUInt16(), this.maxFunctionDefs = e.readUInt16(), this.maxInstructionDefs = e.readUInt16(), this.maxStackElements = e.readUInt16(), this.maxSizeOfInstructions = e.readUInt16(), this.maxComponentElements = e.readUInt16(), this.maxComponentDepth = e.readUInt16();
  }, t;
}(), Vv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "hmtx", t.prototype.parse = function(e) {
    var i, r, s, o, a, l, h;
    for (e.pos = this.offset, this.metrics = [], i = 0, l = this.file.hhea.numberOfMetrics; 0 <= l ? i < l : i > l; i = 0 <= l ? ++i : --i) this.metrics.push({ advance: e.readUInt16(), lsb: e.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var u, d;
      for (d = [], i = u = 0; 0 <= s ? u < s : u > s; i = 0 <= s ? ++u : --u) d.push(e.readInt16());
      return d;
    }(), this.widths = (function() {
      var u, d, p, f;
      for (f = [], u = 0, d = (p = this.metrics).length; u < d; u++) o = p[u], f.push(o.advance);
      return f;
    }).call(this), r = this.widths[this.widths.length - 1], h = [], i = a = 0; 0 <= s ? a < s : a > s; i = 0 <= s ? ++a : --a) h.push(this.widths.push(r));
    return h;
  }, t.prototype.forGlyph = function(e) {
    return e in this.metrics ? this.metrics[e] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[e - this.metrics.length] };
  }, t;
}(), j1 = [].slice, Yv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "glyf", t.prototype.parse = function() {
    return this.cache = {};
  }, t.prototype.glyphFor = function(e) {
    var i, r, s, o, a, l, h, u, d, p;
    return e in this.cache ? this.cache[e] : (o = this.file.loca, i = this.file.contents, r = o.indexOf(e), (s = o.lengthOf(e)) === 0 ? this.cache[e] = null : (i.pos = this.offset + r, a = (l = new $s(i.read(s))).readShort(), u = l.readShort(), p = l.readShort(), h = l.readShort(), d = l.readShort(), this.cache[e] = a === -1 ? new Xv(l, u, p, h, d) : new Kv(l, a, u, p, h, d), this.cache[e]));
  }, t.prototype.encode = function(e, i, r) {
    var s, o, a, l, h;
    for (a = [], o = [], l = 0, h = i.length; l < h; l++) s = e[i[l]], o.push(a.length), s && (a = a.concat(s.encode(r)));
    return o.push(a.length), { table: a, offsets: o };
  }, t;
}(), Kv = function() {
  function n(t, e, i, r, s, o) {
    this.raw = t, this.numberOfContours = e, this.xMin = i, this.yMin = r, this.xMax = s, this.yMax = o, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), Xv = function() {
  function n(t, e, i, r, s) {
    var o, a;
    for (this.raw = t, this.xMin = e, this.yMin = i, this.xMax = r, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], o = this.raw; a = o.readShort(), this.glyphOffsets.push(o.pos), this.glyphIDs.push(o.readUInt16()), 32 & a; ) o.pos += 1 & a ? 4 : 2, 128 & a ? o.pos += 8 : 64 & a ? o.pos += 4 : 8 & a && (o.pos += 2);
  }
  return n.prototype.encode = function() {
    var t, e, i;
    for (e = new $s(j1.call(this.raw.data)), t = 0, i = this.glyphIDs.length; t < i; ++t) e.pos = this.glyphOffsets[t];
    return e.data;
  }, n;
}(), Jv = function(n) {
  function t() {
    return t.__super__.constructor.apply(this, arguments);
  }
  return Dr(t, wr), t.prototype.tag = "loca", t.prototype.parse = function(e) {
    var i, r;
    return e.pos = this.offset, i = this.file.head.indexToLocFormat, this.offsets = i === 0 ? (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 2) o.push(2 * e.readUInt16());
      return o;
    }).call(this) : (function() {
      var s, o;
      for (o = [], r = 0, s = this.length; r < s; r += 4) o.push(e.readUInt32());
      return o;
    }).call(this);
  }, t.prototype.indexOf = function(e) {
    return this.offsets[e];
  }, t.prototype.lengthOf = function(e) {
    return this.offsets[e + 1] - this.offsets[e];
  }, t.prototype.encode = function(e, i) {
    for (var r = new Uint32Array(this.offsets.length), s = 0, o = 0, a = 0; a < r.length; ++a) if (r[a] = s, o < i.length && i[o] == a) {
      ++o, r[a] = s;
      var l = this.offsets[a], h = this.offsets[a + 1] - l;
      h > 0 && (s += h);
    }
    for (var u = new Array(4 * r.length), d = 0; d < r.length; ++d) u[4 * d + 3] = 255 & r[d], u[4 * d + 2] = (65280 & r[d]) >> 8, u[4 * d + 1] = (16711680 & r[d]) >> 16, u[4 * d] = (4278190080 & r[d]) >> 24;
    return u;
  }, t;
}(), Zv = function() {
  function n(t) {
    this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var t, e, i, r, s;
    for (e in r = this.font.cmap.tables[0].codeMap, t = {}, s = this.subset) i = s[e], t[e] = r[i];
    return t;
  }, n.prototype.glyphsFor = function(t) {
    var e, i, r, s, o, a, l;
    for (r = {}, o = 0, a = t.length; o < a; o++) r[s = t[o]] = this.font.glyf.glyphFor(s);
    for (s in e = [], r) (i = r[s]) != null && i.compound && e.push.apply(e, i.glyphIDs);
    if (e.length > 0) for (s in l = this.glyphsFor(e)) i = l[s], r[s] = i;
    return r;
  }, n.prototype.encode = function(t, e) {
    var i, r, s, o, a, l, h, u, d, p, f, g, y, _, b;
    for (r in i = B1.encode(this.generateCmap(), "unicode"), o = this.glyphsFor(t), f = { 0: 0 }, b = i.charMap) f[(l = b[r]).old] = l.new;
    for (g in p = i.maxGlyphID, o) g in f || (f[g] = p++);
    return u = function(v) {
      var A, L;
      for (A in L = {}, v) L[v[A]] = A;
      return L;
    }(f), d = Object.keys(u).sort(function(v, A) {
      return v - A;
    }), y = function() {
      var v, A, L;
      for (L = [], v = 0, A = d.length; v < A; v++) a = d[v], L.push(u[a]);
      return L;
    }(), s = this.font.glyf.encode(o, y, f), h = this.font.loca.encode(s.offsets, y), _ = { cmap: this.font.cmap.raw(), glyf: s.table, loca: h, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (_["OS/2"] = this.font.os2.raw()), this.font.directory.encode(_);
  }, n;
}();
Se.API.PDFObject = function() {
  var n;
  function t() {
  }
  return n = function(e, i) {
    return (Array(i + 1).join("0") + e).slice(-i);
  }, t.convert = function(e) {
    var i, r, s, o;
    if (Array.isArray(e)) return "[" + function() {
      var a, l, h;
      for (h = [], a = 0, l = e.length; a < l; a++) i = e[a], h.push(t.convert(i));
      return h;
    }().join(" ") + "]";
    if (typeof e == "string") return "/" + e;
    if (e != null && e.isString) return "(" + e + ")";
    if (e instanceof Date) return "(D:" + n(e.getUTCFullYear(), 4) + n(e.getUTCMonth(), 2) + n(e.getUTCDate(), 2) + n(e.getUTCHours(), 2) + n(e.getUTCMinutes(), 2) + n(e.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(e) === "[object Object]") {
      for (r in s = ["<<"], e) o = e[r], s.push("/" + r + " " + t.convert(o));
      return s.push(">>"), s.join(`
`);
    }
    return "" + e;
  }, t;
}();
const Qv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, AcroForm: Iv, AcroFormAppearance: he, AcroFormButton: Bn, AcroFormCheckBox: Nl, AcroFormChoiceField: mo, AcroFormComboBox: bo, AcroFormEditBox: kl, AcroFormListBox: yo, AcroFormPasswordField: Cl, AcroFormPushButton: Al, AcroFormRadioButton: vo, AcroFormTextField: Bs, GState: Il, ShadingPattern: Os, TilingPattern: ho, default: Se, jsPDF: Se }, Symbol.toStringTag, { value: "Module" }));
var q1 = { exports: {} };
const tw = /* @__PURE__ */ xy(Qv);
/*!
* 
*               jsPDF AutoTable plugin v3.8.4
*
*               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
*               Licensed under the MIT License.
*               http://opensource.org/licenses/mit-license
*
*/
(function(n, t) {
  (function(i, r) {
    n.exports = r(function() {
      try {
        return tw;
      } catch {
      }
    }());
  })(typeof globalThis < "u" ? globalThis : typeof uo < "u" ? uo : typeof window < "u" ? window : typeof self < "u" ? self : uo, function(e) {
    return (
      /******/
      function() {
        var i = {
          /***/
          172: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var p = function(f, g) {
                  return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(y, _) {
                    y.__proto__ = _;
                  } || function(y, _) {
                    for (var b in _) Object.prototype.hasOwnProperty.call(_, b) && (y[b] = _[b]);
                  }, p(f, g);
                };
                return function(f, g) {
                  if (typeof g != "function" && g !== null)
                    throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                  p(f, g);
                  function y() {
                    this.constructor = f;
                  }
                  f.prototype = g === null ? Object.create(g) : (y.prototype = g.prototype, new y());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.CellHookData = l.HookData = void 0;
              var u = (
                /** @class */
                /* @__PURE__ */ function() {
                  function p(f, g, y) {
                    this.table = g, this.pageNumber = g.pageNumber, this.pageCount = this.pageNumber, this.settings = g.settings, this.cursor = y, this.doc = f.getDocument();
                  }
                  return p;
                }()
              );
              l.HookData = u;
              var d = (
                /** @class */
                function(p) {
                  h(f, p);
                  function f(g, y, _, b, v, A) {
                    var L = p.call(this, g, y, A) || this;
                    return L.cell = _, L.row = b, L.column = v, L.section = b.section, L;
                  }
                  return f;
                }(u)
              );
              l.CellHookData = d;
            }
          ),
          /***/
          340: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              var u = h(4), d = h(136), p = h(744), f = h(776), g = h(664), y = h(972);
              function _(b) {
                b.API.autoTable = function() {
                  for (var v = [], A = 0; A < arguments.length; A++)
                    v[A] = arguments[A];
                  var L;
                  v.length === 1 ? L = v[0] : (console.error("Use of deprecated autoTable initiation"), L = v[2] || {}, L.columns = v[0], L.body = v[1]);
                  var O = (0, f.parseInput)(this, L), R = (0, y.createTable)(this, O);
                  return (0, g.drawTable)(this, R), this;
                }, b.API.lastAutoTable = !1, b.API.previousAutoTable = !1, b.API.autoTable.previous = !1, b.API.autoTableText = function(v, A, L, O) {
                  (0, d.default)(v, A, L, O, this);
                }, b.API.autoTableSetDefaults = function(v) {
                  return p.DocHandler.setDefaults(v, this), this;
                }, b.autoTableSetDefaults = function(v, A) {
                  p.DocHandler.setDefaults(v, A);
                }, b.API.autoTableHtmlToJson = function(v, A) {
                  var L;
                  if (A === void 0 && (A = !1), typeof window > "u")
                    return console.error("Cannot run autoTableHtmlToJson in non browser environment"), null;
                  var O = new p.DocHandler(this), R = (0, u.parseHtml)(O, v, window, A, !1), C = R.head, E = R.body, M = ((L = C[0]) === null || L === void 0 ? void 0 : L.map(function(q) {
                    return q.content;
                  })) || [];
                  return { columns: M, rows: E, data: E };
                }, b.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var v = this.lastAutoTable;
                  return v && v.finalY ? v.finalY : 0;
                }, b.API.autoTableAddPageContent = function(v) {
                  return console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead."), b.API.autoTable.globalDefaults || (b.API.autoTable.globalDefaults = {}), b.API.autoTable.globalDefaults.addPageContent = v, this;
                }, b.API.autoTableAddPage = function() {
                  return console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()"), this.addPage(), this;
                };
              }
              l.default = _;
            }
          ),
          /***/
          136: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(u, d, p, f, g) {
                f = f || {};
                var y = 1.15, _ = g.internal.scaleFactor, b = g.internal.getFontSize() / _, v = g.getLineHeightFactor ? g.getLineHeightFactor() : y, A = b * v, L = /\r\n|\r|\n/g, O = "", R = 1;
                if ((f.valign === "middle" || f.valign === "bottom" || f.halign === "center" || f.halign === "right") && (O = typeof u == "string" ? u.split(L) : u, R = O.length || 1), p += b * (2 - y), f.valign === "middle" ? p -= R / 2 * A : f.valign === "bottom" && (p -= R * A), f.halign === "center" || f.halign === "right") {
                  var C = b;
                  if (f.halign === "center" && (C *= 0.5), O && R >= 1) {
                    for (var E = 0; E < O.length; E++)
                      g.text(O[E], d - g.getStringUnitWidth(O[E]) * C, p), p += A;
                    return g;
                  }
                  d -= g.getStringUnitWidth(u) * C;
                }
                return f.halign === "justify" ? g.text(u, d, p, {
                  maxWidth: f.maxWidth || 100,
                  align: "justify"
                }) : g.text(u, d, p), g;
              }
              l.default = h;
            }
          ),
          /***/
          420: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getPageAvailableWidth = l.parseSpacing = l.getFillStyle = l.addTableBorder = l.getStringWidth = void 0;
              function h(g, y, _) {
                _.applyStyles(y, !0);
                var b = Array.isArray(g) ? g : [g], v = b.map(function(A) {
                  return _.getTextWidth(A);
                }).reduce(function(A, L) {
                  return Math.max(A, L);
                }, 0);
                return v;
              }
              l.getStringWidth = h;
              function u(g, y, _, b) {
                var v = y.settings.tableLineWidth, A = y.settings.tableLineColor;
                g.applyStyles({ lineWidth: v, lineColor: A });
                var L = d(v, !1);
                L && g.rect(_.x, _.y, y.getWidth(g.pageSize().width), b.y - _.y, L);
              }
              l.addTableBorder = u;
              function d(g, y) {
                var _ = g > 0, b = y || y === 0;
                return _ && b ? "DF" : _ ? "S" : b ? "F" : null;
              }
              l.getFillStyle = d;
              function p(g, y) {
                var _, b, v, A;
                if (g = g || y, Array.isArray(g)) {
                  if (g.length >= 4)
                    return {
                      top: g[0],
                      right: g[1],
                      bottom: g[2],
                      left: g[3]
                    };
                  if (g.length === 3)
                    return {
                      top: g[0],
                      right: g[1],
                      bottom: g[2],
                      left: g[1]
                    };
                  if (g.length === 2)
                    return {
                      top: g[0],
                      right: g[1],
                      bottom: g[0],
                      left: g[1]
                    };
                  g.length === 1 ? g = g[0] : g = y;
                }
                return typeof g == "object" ? (typeof g.vertical == "number" && (g.top = g.vertical, g.bottom = g.vertical), typeof g.horizontal == "number" && (g.right = g.horizontal, g.left = g.horizontal), {
                  left: (_ = g.left) !== null && _ !== void 0 ? _ : y,
                  top: (b = g.top) !== null && b !== void 0 ? b : y,
                  right: (v = g.right) !== null && v !== void 0 ? v : y,
                  bottom: (A = g.bottom) !== null && A !== void 0 ? A : y
                }) : (typeof g != "number" && (g = y), { top: g, right: g, bottom: g, left: g });
              }
              l.parseSpacing = p;
              function f(g, y) {
                var _ = p(y.settings.margin, 0);
                return g.pageSize().width - (_.left + _.right);
              }
              l.getPageAvailableWidth = f;
            }
          ),
          /***/
          796: (
            /***/
            function(a, l) {
              var h = this && this.__extends || /* @__PURE__ */ function() {
                var f = function(g, y) {
                  return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(_, b) {
                    _.__proto__ = b;
                  } || function(_, b) {
                    for (var v in b) Object.prototype.hasOwnProperty.call(b, v) && (_[v] = b[v]);
                  }, f(g, y);
                };
                return function(g, y) {
                  if (typeof y != "function" && y !== null)
                    throw new TypeError("Class extends value " + String(y) + " is not a constructor or null");
                  f(g, y);
                  function _() {
                    this.constructor = g;
                  }
                  g.prototype = y === null ? Object.create(y) : (_.prototype = y.prototype, new _());
                };
              }();
              Object.defineProperty(l, "__esModule", { value: !0 }), l.getTheme = l.defaultStyles = l.HtmlRowInput = void 0;
              var u = (
                /** @class */
                function(f) {
                  h(g, f);
                  function g(y) {
                    var _ = f.call(this) || this;
                    return _._element = y, _;
                  }
                  return g;
                }(Array)
              );
              l.HtmlRowInput = u;
              function d(f) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: !1,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / f,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              l.defaultStyles = d;
              function p(f) {
                var g = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return g[f];
              }
              l.getTheme = p;
            }
          ),
          /***/
          903: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseCss = void 0;
              var u = h(420);
              function d(_, b, v, A, L) {
                var O = {}, R = 1.3333333333333333, C = f(b, function(H) {
                  return L.getComputedStyle(H).backgroundColor;
                });
                C != null && (O.fillColor = C);
                var E = f(b, function(H) {
                  return L.getComputedStyle(H).color;
                });
                E != null && (O.textColor = E);
                var M = y(A, v);
                M && (O.cellPadding = M);
                var q = "borderTopColor", N = R * v, S = A.borderTopWidth;
                if (A.borderBottomWidth === S && A.borderRightWidth === S && A.borderLeftWidth === S) {
                  var T = (parseFloat(S) || 0) / N;
                  T && (O.lineWidth = T);
                } else
                  O.lineWidth = {
                    top: (parseFloat(A.borderTopWidth) || 0) / N,
                    right: (parseFloat(A.borderRightWidth) || 0) / N,
                    bottom: (parseFloat(A.borderBottomWidth) || 0) / N,
                    left: (parseFloat(A.borderLeftWidth) || 0) / N
                  }, O.lineWidth.top || (O.lineWidth.right ? q = "borderRightColor" : O.lineWidth.bottom ? q = "borderBottomColor" : O.lineWidth.left && (q = "borderLeftColor"));
                var x = f(b, function(H) {
                  return L.getComputedStyle(H)[q];
                });
                x != null && (O.lineColor = x);
                var X = ["left", "right", "center", "justify"];
                X.indexOf(A.textAlign) !== -1 && (O.halign = A.textAlign), X = ["middle", "bottom", "top"], X.indexOf(A.verticalAlign) !== -1 && (O.valign = A.verticalAlign);
                var V = parseInt(A.fontSize || "");
                isNaN(V) || (O.fontSize = V / R);
                var D = p(A);
                D && (O.fontStyle = D);
                var tt = (A.fontFamily || "").toLowerCase();
                return _.indexOf(tt) !== -1 && (O.font = tt), O;
              }
              l.parseCss = d;
              function p(_) {
                var b = "";
                return (_.fontWeight === "bold" || _.fontWeight === "bolder" || parseInt(_.fontWeight) >= 700) && (b = "bold"), (_.fontStyle === "italic" || _.fontStyle === "oblique") && (b += "italic"), b;
              }
              function f(_, b) {
                var v = g(_, b);
                if (!v)
                  return null;
                var A = v.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!A || !Array.isArray(A))
                  return null;
                var L = [
                  parseInt(A[1]),
                  parseInt(A[2]),
                  parseInt(A[3])
                ], O = parseInt(A[4]);
                return O === 0 || isNaN(L[0]) || isNaN(L[1]) || isNaN(L[2]) ? null : L;
              }
              function g(_, b) {
                var v = b(_);
                return v === "rgba(0, 0, 0, 0)" || v === "transparent" || v === "initial" || v === "inherit" ? _.parentElement == null ? null : g(_.parentElement, b) : v;
              }
              function y(_, b) {
                var v = [
                  _.paddingTop,
                  _.paddingRight,
                  _.paddingBottom,
                  _.paddingLeft
                ], A = 96 / (72 / b), L = (parseInt(_.lineHeight) - parseInt(_.fontSize)) / b / 2, O = v.map(function(C) {
                  return parseInt(C || "0") / A;
                }), R = (0, u.parseSpacing)(O, 0);
                return L > R.top && (R.top = L), L > R.bottom && (R.bottom = L), R;
              }
            }
          ),
          /***/
          744: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.DocHandler = void 0;
              var h = {}, u = (
                /** @class */
                function() {
                  function d(p) {
                    this.jsPDFDocument = p, this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: p.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: p.internal.getFontSize(),
                      fontStyle: p.internal.getFont().fontStyle,
                      font: p.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: p.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: p.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  return d.setDefaults = function(p, f) {
                    f === void 0 && (f = null), f ? f.__autoTableDocumentDefaults = p : h = p;
                  }, d.unifyColor = function(p) {
                    return Array.isArray(p) ? p : typeof p == "number" ? [p, p, p] : typeof p == "string" ? [p] : null;
                  }, d.prototype.applyStyles = function(p, f) {
                    var g, y, _;
                    f === void 0 && (f = !1), p.fontStyle && this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(p.fontStyle);
                    var b = this.jsPDFDocument.internal.getFont(), v = b.fontStyle, A = b.fontName;
                    if (p.font && (A = p.font), p.fontStyle) {
                      v = p.fontStyle;
                      var L = this.getFontList()[A];
                      L && L.indexOf(v) === -1 && (this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(L[0]), v = L[0]);
                    }
                    if (this.jsPDFDocument.setFont(A, v), p.fontSize && this.jsPDFDocument.setFontSize(p.fontSize), !f) {
                      var O = d.unifyColor(p.fillColor);
                      O && (g = this.jsPDFDocument).setFillColor.apply(g, O), O = d.unifyColor(p.textColor), O && (y = this.jsPDFDocument).setTextColor.apply(y, O), O = d.unifyColor(p.lineColor), O && (_ = this.jsPDFDocument).setDrawColor.apply(_, O), typeof p.lineWidth == "number" && this.jsPDFDocument.setLineWidth(p.lineWidth);
                    }
                  }, d.prototype.splitTextToSize = function(p, f, g) {
                    return this.jsPDFDocument.splitTextToSize(p, f, g);
                  }, d.prototype.rect = function(p, f, g, y, _) {
                    return this.jsPDFDocument.rect(p, f, g, y, _);
                  }, d.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  }, d.prototype.getTextWidth = function(p) {
                    return this.jsPDFDocument.getTextWidth(p);
                  }, d.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  }, d.prototype.setPage = function(p) {
                    this.jsPDFDocument.setPage(p);
                  }, d.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  }, d.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  }, d.prototype.getGlobalOptions = function() {
                    return h || {};
                  }, d.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  }, d.prototype.pageSize = function() {
                    var p = this.jsPDFDocument.internal.pageSize;
                    return p.width == null && (p = {
                      width: p.getWidth(),
                      height: p.getHeight()
                    }), p;
                  }, d.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  }, d.prototype.getLineHeightFactor = function() {
                    var p = this.jsPDFDocument;
                    return p.getLineHeightFactor ? p.getLineHeightFactor() : 1.15;
                  }, d.prototype.getLineHeight = function(p) {
                    return p / this.scaleFactor() * this.getLineHeightFactor();
                  }, d.prototype.pageNumber = function() {
                    var p = this.jsPDFDocument.internal.getCurrentPageInfo();
                    return p ? p.pageNumber : this.jsPDFDocument.internal.getNumberOfPages();
                  }, d;
                }()
              );
              l.DocHandler = u;
            }
          ),
          /***/
          4: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseHtml = void 0;
              var u = h(903), d = h(796);
              function p(y, _, b, v, A) {
                var L, O;
                v === void 0 && (v = !1), A === void 0 && (A = !1);
                var R;
                typeof _ == "string" ? R = b.document.querySelector(_) : R = _;
                var C = Object.keys(y.getFontList()), E = y.scaleFactor(), M = [], q = [], N = [];
                if (!R)
                  return console.error("Html table could not be found with input: ", _), { head: M, body: q, foot: N };
                for (var S = 0; S < R.rows.length; S++) {
                  var T = R.rows[S], x = (O = (L = T == null ? void 0 : T.parentElement) === null || L === void 0 ? void 0 : L.tagName) === null || O === void 0 ? void 0 : O.toLowerCase(), X = f(C, E, b, T, v, A);
                  X && (x === "thead" ? M.push(X) : x === "tfoot" ? N.push(X) : q.push(X));
                }
                return { head: M, body: q, foot: N };
              }
              l.parseHtml = p;
              function f(y, _, b, v, A, L) {
                for (var O = new d.HtmlRowInput(v), R = 0; R < v.cells.length; R++) {
                  var C = v.cells[R], E = b.getComputedStyle(C);
                  if (A || E.display !== "none") {
                    var M = void 0;
                    L && (M = (0, u.parseCss)(y, C, _, E, b)), O.push({
                      rowSpan: C.rowSpan,
                      colSpan: C.colSpan,
                      styles: M,
                      _element: C,
                      content: g(C)
                    });
                  }
                }
                var q = b.getComputedStyle(v);
                if (O.length > 0 && (A || q.display !== "none"))
                  return O;
              }
              function g(y) {
                var _ = y.cloneNode(!0);
                return _.innerHTML = _.innerHTML.replace(/\n/g, "").replace(/ +/g, " "), _.innerHTML = _.innerHTML.split(/<br.*?>/).map(function(b) {
                  return b.trim();
                }).join(`
`), _.innerText || _.textContent || "";
              }
            }
          ),
          /***/
          776: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.parseInput = void 0;
              var u = h(4), d = h(356), p = h(420), f = h(744), g = h(792);
              function y(R, C) {
                var E = new f.DocHandler(R), M = E.getDocumentOptions(), q = E.getGlobalOptions();
                (0, g.default)(E, q, M, C);
                var N = (0, d.assign)({}, q, M, C), S;
                typeof window < "u" && (S = window);
                var T = _(q, M, C), x = b(q, M, C), X = v(E, N), V = L(E, N, S);
                return {
                  id: C.tableId,
                  content: V,
                  hooks: x,
                  styles: T,
                  settings: X
                };
              }
              l.parseInput = y;
              function _(R, C, E) {
                for (var M = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                }, q = function(x) {
                  if (x === "columnStyles") {
                    var X = R[x], V = C[x], D = E[x];
                    M.columnStyles = (0, d.assign)({}, X, V, D);
                  } else {
                    var tt = [R, C, E], H = tt.map(function(ct) {
                      return ct[x] || {};
                    });
                    M[x] = (0, d.assign)({}, H[0], H[1], H[2]);
                  }
                }, N = 0, S = Object.keys(M); N < S.length; N++) {
                  var T = S[N];
                  q(T);
                }
                return M;
              }
              function b(R, C, E) {
                for (var M = [R, C, E], q = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                }, N = 0, S = M; N < S.length; N++) {
                  var T = S[N];
                  T.didParseCell && q.didParseCell.push(T.didParseCell), T.willDrawCell && q.willDrawCell.push(T.willDrawCell), T.didDrawCell && q.didDrawCell.push(T.didDrawCell), T.willDrawPage && q.willDrawPage.push(T.willDrawPage), T.didDrawPage && q.didDrawPage.push(T.didDrawPage);
                }
                return q;
              }
              function v(R, C) {
                var E, M, q, N, S, T, x, X, V, D, tt, H, ct = (0, p.parseSpacing)(C.margin, 40 / R.scaleFactor()), it = (E = A(R, C.startY)) !== null && E !== void 0 ? E : ct.top, P;
                C.showFoot === !0 ? P = "everyPage" : C.showFoot === !1 ? P = "never" : P = (M = C.showFoot) !== null && M !== void 0 ? M : "everyPage";
                var z;
                C.showHead === !0 ? z = "everyPage" : C.showHead === !1 ? z = "never" : z = (q = C.showHead) !== null && q !== void 0 ? q : "everyPage";
                var G = (N = C.useCss) !== null && N !== void 0 ? N : !1, Y = C.theme || (G ? "plain" : "striped"), ot = !!C.horizontalPageBreak, xt = (S = C.horizontalPageBreakRepeat) !== null && S !== void 0 ? S : null;
                return {
                  includeHiddenHtml: (T = C.includeHiddenHtml) !== null && T !== void 0 ? T : !1,
                  useCss: G,
                  theme: Y,
                  startY: it,
                  margin: ct,
                  pageBreak: (x = C.pageBreak) !== null && x !== void 0 ? x : "auto",
                  rowPageBreak: (X = C.rowPageBreak) !== null && X !== void 0 ? X : "auto",
                  tableWidth: (V = C.tableWidth) !== null && V !== void 0 ? V : "auto",
                  showHead: z,
                  showFoot: P,
                  tableLineWidth: (D = C.tableLineWidth) !== null && D !== void 0 ? D : 0,
                  tableLineColor: (tt = C.tableLineColor) !== null && tt !== void 0 ? tt : 200,
                  horizontalPageBreak: ot,
                  horizontalPageBreakRepeat: xt,
                  horizontalPageBreakBehaviour: (H = C.horizontalPageBreakBehaviour) !== null && H !== void 0 ? H : "afterAllRows"
                };
              }
              function A(R, C) {
                var E = R.getLastAutoTable(), M = R.scaleFactor(), q = R.pageNumber(), N = !1;
                if (E && E.startPageNumber) {
                  var S = E.startPageNumber + E.pageNumber - 1;
                  N = S === q;
                }
                return typeof C == "number" ? C : (C == null || C === !1) && N && (E == null ? void 0 : E.finalY) != null ? E.finalY + 20 / M : null;
              }
              function L(R, C, E) {
                var M = C.head || [], q = C.body || [], N = C.foot || [];
                if (C.html) {
                  var S = C.includeHiddenHtml;
                  if (E) {
                    var T = (0, u.parseHtml)(R, C.html, E, S, C.useCss) || {};
                    M = T.head || M, q = T.body || M, N = T.foot || M;
                  } else
                    console.error("Cannot parse html in non browser environment");
                }
                var x = C.columns || O(M, q, N);
                return {
                  columns: x,
                  head: M,
                  body: q,
                  foot: N
                };
              }
              function O(R, C, E) {
                var M = R[0] || C[0] || E[0] || [], q = [];
                return Object.keys(M).filter(function(N) {
                  return N !== "_element";
                }).forEach(function(N) {
                  var S = 1, T;
                  Array.isArray(M) ? T = M[parseInt(N)] : T = M[N], typeof T == "object" && !Array.isArray(T) && (S = (T == null ? void 0 : T.colSpan) || 1);
                  for (var x = 0; x < S; x++) {
                    var X = void 0;
                    Array.isArray(M) ? X = q.length : X = N + (x > 0 ? "_".concat(x) : "");
                    var V = { dataKey: X };
                    q.push(V);
                  }
                }), q;
              }
            }
          ),
          /***/
          792: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 });
              function h(d, p, f, g) {
                for (var y = function(A) {
                  A && typeof A != "object" && console.error("The options parameter should be of type object, is: " + typeof A), typeof A.extendWidth < "u" && (A.tableWidth = A.extendWidth ? "auto" : "wrap", console.error("Use of deprecated option: extendWidth, use tableWidth instead.")), typeof A.margins < "u" && (typeof A.margin > "u" && (A.margin = A.margins), console.error("Use of deprecated option: margins, use margin instead.")), A.startY && typeof A.startY != "number" && (console.error("Invalid value for startY option", A.startY), delete A.startY), !A.didDrawPage && (A.afterPageContent || A.beforePageContent || A.afterPageAdd) && (console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead"), A.didDrawPage = function(N) {
                    d.applyStyles(d.userStyles), A.beforePageContent && A.beforePageContent(N), d.applyStyles(d.userStyles), A.afterPageContent && A.afterPageContent(N), d.applyStyles(d.userStyles), A.afterPageAdd && N.pageNumber > 1 && N.afterPageAdd(N), d.applyStyles(d.userStyles);
                  }), [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(N) {
                    A[N] && console.error('The "'.concat(N, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                  }), [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(N) {
                    var S = N[0], T = N[1];
                    A[T] && (console.error("Use of deprecated option ".concat(T, ". Use ").concat(S, " instead")), A[S] = A[T]);
                  }), [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(N) {
                    var S = typeof N == "string" ? N : N[0], T = typeof N == "string" ? N : N[1];
                    typeof A[S] < "u" && (typeof A.styles[T] > "u" && (A.styles[T] = A[S]), console.error("Use of deprecated option: " + S + ", use the style " + T + " instead."));
                  });
                  for (var L = 0, O = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; L < O.length; L++) {
                    var R = O[L];
                    u(A[R] || {});
                  }
                  for (var C = A.columnStyles || {}, E = 0, M = Object.keys(C); E < M.length; E++) {
                    var q = M[E];
                    u(C[q] || {});
                  }
                }, _ = 0, b = [p, f, g]; _ < b.length; _++) {
                  var v = b[_];
                  y(v);
                }
              }
              l.default = h;
              function u(d) {
                d.rowHeight ? (console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight."), d.minCellHeight || (d.minCellHeight = d.rowHeight)) : d.columnWidth && (console.error("Use of deprecated style columnWidth. It is renamed to cellWidth."), d.cellWidth || (d.cellWidth = d.columnWidth));
              }
            }
          ),
          /***/
          260: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.Column = l.Cell = l.Row = l.Table = void 0;
              var u = h(796), d = h(172), p = h(420), f = (
                /** @class */
                function() {
                  function b(v, A) {
                    this.pageNumber = 1, this.pageCount = 1, this.id = v.id, this.settings = v.settings, this.styles = v.styles, this.hooks = v.hooks, this.columns = A.columns, this.head = A.head, this.body = A.body, this.foot = A.foot;
                  }
                  return b.prototype.getHeadHeight = function(v) {
                    return this.head.reduce(function(A, L) {
                      return A + L.getMaxCellHeight(v);
                    }, 0);
                  }, b.prototype.getFootHeight = function(v) {
                    return this.foot.reduce(function(A, L) {
                      return A + L.getMaxCellHeight(v);
                    }, 0);
                  }, b.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  }, b.prototype.callCellHooks = function(v, A, L, O, R, C) {
                    for (var E = 0, M = A; E < M.length; E++) {
                      var q = M[E], N = new d.CellHookData(v, this, L, O, R, C), S = q(N) === !1;
                      if (L.text = Array.isArray(L.text) ? L.text : [L.text], S)
                        return !1;
                    }
                    return !0;
                  }, b.prototype.callEndPageHooks = function(v, A) {
                    v.applyStyles(v.userStyles);
                    for (var L = 0, O = this.hooks.didDrawPage; L < O.length; L++) {
                      var R = O[L];
                      R(new d.HookData(v, this, A));
                    }
                  }, b.prototype.callWillDrawPageHooks = function(v, A) {
                    for (var L = 0, O = this.hooks.willDrawPage; L < O.length; L++) {
                      var R = O[L];
                      R(new d.HookData(v, this, A));
                    }
                  }, b.prototype.getWidth = function(v) {
                    if (typeof this.settings.tableWidth == "number")
                      return this.settings.tableWidth;
                    if (this.settings.tableWidth === "wrap") {
                      var A = this.columns.reduce(function(O, R) {
                        return O + R.wrappedWidth;
                      }, 0);
                      return A;
                    } else {
                      var L = this.settings.margin;
                      return v - L.left - L.right;
                    }
                  }, b;
                }()
              );
              l.Table = f;
              var g = (
                /** @class */
                function() {
                  function b(v, A, L, O, R) {
                    R === void 0 && (R = !1), this.height = 0, this.raw = v, v instanceof u.HtmlRowInput && (this.raw = v._element, this.element = v._element), this.index = A, this.section = L, this.cells = O, this.spansMultiplePages = R;
                  }
                  return b.prototype.getMaxCellHeight = function(v) {
                    var A = this;
                    return v.reduce(function(L, O) {
                      var R;
                      return Math.max(L, ((R = A.cells[O.index]) === null || R === void 0 ? void 0 : R.height) || 0);
                    }, 0);
                  }, b.prototype.hasRowSpan = function(v) {
                    var A = this;
                    return v.filter(function(L) {
                      var O = A.cells[L.index];
                      return O ? O.rowSpan > 1 : !1;
                    }).length > 0;
                  }, b.prototype.canEntireRowFit = function(v, A) {
                    return this.getMaxCellHeight(A) <= v;
                  }, b.prototype.getMinimumRowHeight = function(v, A) {
                    var L = this;
                    return v.reduce(function(O, R) {
                      var C = L.cells[R.index];
                      if (!C)
                        return 0;
                      var E = A.getLineHeight(C.styles.fontSize), M = C.padding("vertical"), q = M + E;
                      return q > O ? q : O;
                    }, 0);
                  }, b;
                }()
              );
              l.Row = g;
              var y = (
                /** @class */
                function() {
                  function b(v, A, L) {
                    var O, R;
                    this.contentHeight = 0, this.contentWidth = 0, this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.height = 0, this.x = 0, this.y = 0, this.styles = A, this.section = L, this.raw = v;
                    var C = v;
                    v != null && typeof v == "object" && !Array.isArray(v) ? (this.rowSpan = v.rowSpan || 1, this.colSpan = v.colSpan || 1, C = (R = (O = v.content) !== null && O !== void 0 ? O : v.title) !== null && R !== void 0 ? R : v, v._element && (this.raw = v._element)) : (this.rowSpan = 1, this.colSpan = 1);
                    var E = C != null ? "" + C : "", M = /\r\n|\r|\n/g;
                    this.text = E.split(M);
                  }
                  return b.prototype.getTextPos = function() {
                    var v;
                    if (this.styles.valign === "top")
                      v = this.y + this.padding("top");
                    else if (this.styles.valign === "bottom")
                      v = this.y + this.height - this.padding("bottom");
                    else {
                      var A = this.height - this.padding("vertical");
                      v = this.y + A / 2 + this.padding("top");
                    }
                    var L;
                    if (this.styles.halign === "right")
                      L = this.x + this.width - this.padding("right");
                    else if (this.styles.halign === "center") {
                      var O = this.width - this.padding("horizontal");
                      L = this.x + O / 2 + this.padding("left");
                    } else
                      L = this.x + this.padding("left");
                    return { x: L, y: v };
                  }, b.prototype.getContentHeight = function(v, A) {
                    A === void 0 && (A = 1.15);
                    var L = Array.isArray(this.text) ? this.text.length : 1, O = this.styles.fontSize / v * A, R = L * O + this.padding("vertical");
                    return Math.max(R, this.styles.minCellHeight);
                  }, b.prototype.padding = function(v) {
                    var A = (0, p.parseSpacing)(this.styles.cellPadding, 0);
                    return v === "vertical" ? A.top + A.bottom : v === "horizontal" ? A.left + A.right : A[v];
                  }, b;
                }()
              );
              l.Cell = y;
              var _ = (
                /** @class */
                function() {
                  function b(v, A, L) {
                    this.wrappedWidth = 0, this.minReadableWidth = 0, this.minWidth = 0, this.width = 0, this.dataKey = v, this.raw = A, this.index = L;
                  }
                  return b.prototype.getMaxCustomCellWidth = function(v) {
                    for (var A = 0, L = 0, O = v.allRows(); L < O.length; L++) {
                      var R = O[L], C = R.cells[this.index];
                      C && typeof C.styles.cellWidth == "number" && (A = Math.max(A, C.styles.cellWidth));
                    }
                    return A;
                  }, b;
                }()
              );
              l.Column = _;
            }
          ),
          /***/
          356: (
            /***/
            function(a, l) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.assign = void 0;
              function h(u, d, p, f, g) {
                if (u == null)
                  throw new TypeError("Cannot convert undefined or null to object");
                for (var y = Object(u), _ = 1; _ < arguments.length; _++) {
                  var b = arguments[_];
                  if (b != null)
                    for (var v in b)
                      Object.prototype.hasOwnProperty.call(b, v) && (y[v] = b[v]);
                }
                return y;
              }
              l.assign = h;
            }
          ),
          /***/
          972: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.createTable = void 0;
              var u = h(744), d = h(260), p = h(324), f = h(796), g = h(356);
              function y(R, C) {
                var E = new u.DocHandler(R), M = _(C, E.scaleFactor()), q = new d.Table(C, M);
                return (0, p.calculateWidths)(E, q), E.applyStyles(E.userStyles), q;
              }
              l.createTable = y;
              function _(R, C) {
                var E = R.content, M = L(E.columns);
                if (E.head.length === 0) {
                  var q = v(M, "head");
                  q && E.head.push(q);
                }
                if (E.foot.length === 0) {
                  var q = v(M, "foot");
                  q && E.foot.push(q);
                }
                var N = R.settings.theme, S = R.styles;
                return {
                  columns: M,
                  head: b("head", E.head, M, S, N, C),
                  body: b("body", E.body, M, S, N, C),
                  foot: b("foot", E.foot, M, S, N, C)
                };
              }
              function b(R, C, E, M, q, N) {
                var S = {}, T = C.map(function(x, X) {
                  for (var V = 0, D = {}, tt = 0, H = 0, ct = 0, it = E; ct < it.length; ct++) {
                    var P = it[ct];
                    if (S[P.index] == null || S[P.index].left === 0)
                      if (H === 0) {
                        var z = void 0;
                        Array.isArray(x) ? z = x[P.index - tt - V] : z = x[P.dataKey];
                        var G = {};
                        typeof z == "object" && !Array.isArray(z) && (G = (z == null ? void 0 : z.styles) || {});
                        var Y = O(R, P, X, q, M, N, G), ot = new d.Cell(z, Y, R);
                        D[P.dataKey] = ot, D[P.index] = ot, H = ot.colSpan - 1, S[P.index] = {
                          left: ot.rowSpan - 1,
                          times: H
                        };
                      } else
                        H--, tt++;
                    else
                      S[P.index].left--, H = S[P.index].times, V++;
                  }
                  return new d.Row(x, X, R, D);
                });
                return T;
              }
              function v(R, C) {
                var E = {};
                return R.forEach(function(M) {
                  if (M.raw != null) {
                    var q = A(C, M.raw);
                    q != null && (E[M.dataKey] = q);
                  }
                }), Object.keys(E).length > 0 ? E : null;
              }
              function A(R, C) {
                if (R === "head") {
                  if (typeof C == "object")
                    return C.header || C.title || null;
                  if (typeof C == "string" || typeof C == "number")
                    return C;
                } else if (R === "foot" && typeof C == "object")
                  return C.footer;
                return null;
              }
              function L(R) {
                return R.map(function(C, E) {
                  var M, q, N;
                  return typeof C == "object" ? N = (q = (M = C.dataKey) !== null && M !== void 0 ? M : C.key) !== null && q !== void 0 ? q : E : N = E, new d.Column(N, C, E);
                });
              }
              function O(R, C, E, M, q, N, S) {
                var T = (0, f.getTheme)(M), x;
                R === "head" ? x = q.headStyles : R === "body" ? x = q.bodyStyles : R === "foot" && (x = q.footStyles);
                var X = (0, g.assign)({}, T.table, T[R], q.styles, x), V = q.columnStyles[C.dataKey] || q.columnStyles[C.index] || {}, D = R === "body" ? V : {}, tt = R === "body" && E % 2 === 0 ? (0, g.assign)({}, T.alternateRow, q.alternateRowStyles) : {}, H = (0, f.defaultStyles)(N), ct = (0, g.assign)({}, H, X, tt, D);
                return (0, g.assign)(ct, S);
              }
            }
          ),
          /***/
          664: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.addPage = l.drawTable = void 0;
              var u = h(420), d = h(260), p = h(744), f = h(356), g = h(136), y = h(224);
              function _(V, D) {
                var tt = D.settings, H = tt.startY, ct = tt.margin, it = {
                  x: ct.left,
                  y: H
                }, P = D.getHeadHeight(D.columns) + D.getFootHeight(D.columns), z = H + ct.bottom + P;
                if (tt.pageBreak === "avoid") {
                  var G = D.body, Y = G.reduce(function(gt, wt) {
                    return gt + wt.height;
                  }, 0);
                  z += Y;
                }
                var ot = new p.DocHandler(V);
                (tt.pageBreak === "always" || tt.startY != null && z > ot.pageSize().height) && (X(ot), it.y = ct.top), D.callWillDrawPageHooks(ot, it);
                var xt = (0, f.assign)({}, it);
                D.startPageNumber = ot.pageNumber(), tt.horizontalPageBreak ? b(ot, D, xt, it) : (ot.applyStyles(ot.userStyles), (tt.showHead === "firstPage" || tt.showHead === "everyPage") && D.head.forEach(function(gt) {
                  return q(ot, D, gt, it, D.columns);
                }), ot.applyStyles(ot.userStyles), D.body.forEach(function(gt, wt) {
                  var qt = wt === D.body.length - 1;
                  M(ot, D, gt, qt, xt, it, D.columns);
                }), ot.applyStyles(ot.userStyles), (tt.showFoot === "lastPage" || tt.showFoot === "everyPage") && D.foot.forEach(function(gt) {
                  return q(ot, D, gt, it, D.columns);
                })), (0, u.addTableBorder)(ot, D, xt, it), D.callEndPageHooks(ot, it), D.finalY = it.y, V.lastAutoTable = D, V.previousAutoTable = D, V.autoTable && (V.autoTable.previous = D), ot.applyStyles(ot.userStyles);
              }
              l.drawTable = _;
              function b(V, D, tt, H) {
                var ct = (0, y.calculateAllColumnsCanFitInPage)(V, D), it = D.settings;
                if (it.horizontalPageBreakBehaviour === "afterAllRows")
                  ct.forEach(function(Y, ot) {
                    V.applyStyles(V.userStyles), ot > 0 ? x(V, D, tt, H, Y.columns, !0) : v(V, D, H, Y.columns), A(V, D, tt, H, Y.columns), O(V, D, H, Y.columns);
                  });
                else
                  for (var P = -1, z = ct[0], G = function() {
                    var Y = P;
                    if (z) {
                      V.applyStyles(V.userStyles);
                      var ot = z.columns;
                      P >= 0 ? x(V, D, tt, H, ot, !0) : v(V, D, H, ot), Y = L(V, D, P + 1, H, ot), O(V, D, H, ot);
                    }
                    var xt = Y - P;
                    ct.slice(1).forEach(function(gt) {
                      V.applyStyles(V.userStyles), x(V, D, tt, H, gt.columns, !0), L(V, D, P + 1, H, gt.columns, xt), O(V, D, H, gt.columns);
                    }), P = Y;
                  }; P < D.body.length - 1; )
                    G();
              }
              function v(V, D, tt, H) {
                var ct = D.settings;
                V.applyStyles(V.userStyles), (ct.showHead === "firstPage" || ct.showHead === "everyPage") && D.head.forEach(function(it) {
                  return q(V, D, it, tt, H);
                });
              }
              function A(V, D, tt, H, ct) {
                V.applyStyles(V.userStyles), D.body.forEach(function(it, P) {
                  var z = P === D.body.length - 1;
                  M(V, D, it, z, tt, H, ct);
                });
              }
              function L(V, D, tt, H, ct, it) {
                V.applyStyles(V.userStyles), it = it ?? D.body.length;
                var P = Math.min(tt + it, D.body.length), z = -1;
                return D.body.slice(tt, P).forEach(function(G, Y) {
                  var ot = tt + Y === D.body.length - 1, xt = T(V, D, ot, H);
                  G.canEntireRowFit(xt, ct) && (q(V, D, G, H, ct), z = tt + Y);
                }), z;
              }
              function O(V, D, tt, H) {
                var ct = D.settings;
                V.applyStyles(V.userStyles), (ct.showFoot === "lastPage" || ct.showFoot === "everyPage") && D.foot.forEach(function(it) {
                  return q(V, D, it, tt, H);
                });
              }
              function R(V, D, tt) {
                var H = tt.getLineHeight(V.styles.fontSize), ct = V.padding("vertical"), it = Math.floor((D - ct) / H);
                return Math.max(0, it);
              }
              function C(V, D, tt, H) {
                var ct = {};
                V.spansMultiplePages = !0, V.height = 0;
                for (var it = 0, P = 0, z = tt.columns; P < z.length; P++) {
                  var G = z[P], Y = V.cells[G.index];
                  if (Y) {
                    Array.isArray(Y.text) || (Y.text = [Y.text]);
                    var ot = new d.Cell(Y.raw, Y.styles, Y.section);
                    ot = (0, f.assign)(ot, Y), ot.text = [];
                    var xt = R(Y, D, H);
                    Y.text.length > xt && (ot.text = Y.text.splice(xt, Y.text.length));
                    var gt = H.scaleFactor(), wt = H.getLineHeightFactor();
                    Y.contentHeight = Y.getContentHeight(gt, wt), Y.contentHeight >= D && (Y.contentHeight = D, ot.styles.minCellHeight -= D), Y.contentHeight > V.height && (V.height = Y.contentHeight), ot.contentHeight = ot.getContentHeight(gt, wt), ot.contentHeight > it && (it = ot.contentHeight), ct[G.index] = ot;
                  }
                }
                var qt = new d.Row(V.raw, -1, V.section, ct, !0);
                qt.height = it;
                for (var Dt = 0, Yt = tt.columns; Dt < Yt.length; Dt++) {
                  var G = Yt[Dt], ot = qt.cells[G.index];
                  ot && (ot.height = qt.height);
                  var Y = V.cells[G.index];
                  Y && (Y.height = V.height);
                }
                return qt;
              }
              function E(V, D, tt, H) {
                var ct = V.pageSize().height, it = H.settings.margin, P = it.top + it.bottom, z = ct - P;
                D.section === "body" && (z -= H.getHeadHeight(H.columns) + H.getFootHeight(H.columns));
                var G = D.getMinimumRowHeight(H.columns, V), Y = G < tt;
                if (G > z)
                  return console.error("Will not be able to print row ".concat(D.index, " correctly since it's minimum height is larger than page height")), !0;
                if (!Y)
                  return !1;
                var ot = D.hasRowSpan(H.columns), xt = D.getMaxCellHeight(H.columns) > z;
                return xt ? (ot && console.error("The content of row ".concat(D.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.")), !0) : !(ot || H.settings.rowPageBreak === "avoid");
              }
              function M(V, D, tt, H, ct, it, P) {
                var z = T(V, D, H, it);
                if (tt.canEntireRowFit(z, P))
                  q(V, D, tt, it, P);
                else if (E(V, tt, z, D)) {
                  var G = C(tt, z, D, V);
                  q(V, D, tt, it, P), x(V, D, ct, it, P), M(V, D, G, H, ct, it, P);
                } else
                  x(V, D, ct, it, P), M(V, D, tt, H, ct, it, P);
              }
              function q(V, D, tt, H, ct) {
                H.x = D.settings.margin.left;
                for (var it = 0, P = ct; it < P.length; it++) {
                  var z = P[it], G = tt.cells[z.index];
                  if (!G) {
                    H.x += z.width;
                    continue;
                  }
                  V.applyStyles(G.styles), G.x = H.x, G.y = H.y;
                  var Y = D.callCellHooks(V, D.hooks.willDrawCell, G, tt, z, H);
                  if (Y === !1) {
                    H.x += z.width;
                    continue;
                  }
                  N(V, G, H);
                  var ot = G.getTextPos();
                  (0, g.default)(G.text, ot.x, ot.y, {
                    halign: G.styles.halign,
                    valign: G.styles.valign,
                    maxWidth: Math.ceil(G.width - G.padding("left") - G.padding("right"))
                  }, V.getDocument()), D.callCellHooks(V, D.hooks.didDrawCell, G, tt, z, H), H.x += z.width;
                }
                H.y += tt.height;
              }
              function N(V, D, tt) {
                var H = D.styles;
                if (V.getDocument().setFillColor(V.getDocument().getFillColor()), typeof H.lineWidth == "number") {
                  var ct = (0, u.getFillStyle)(H.lineWidth, H.fillColor);
                  ct && V.rect(D.x, tt.y, D.width, D.height, ct);
                } else typeof H.lineWidth == "object" && (H.fillColor && V.rect(D.x, tt.y, D.width, D.height, "F"), S(V, D, tt, H.lineWidth));
              }
              function S(V, D, tt, H) {
                var ct, it, P, z;
                H.top && (ct = tt.x, it = tt.y, P = tt.x + D.width, z = tt.y, H.right && (P += 0.5 * H.right), H.left && (ct -= 0.5 * H.left), G(H.top, ct, it, P, z)), H.bottom && (ct = tt.x, it = tt.y + D.height, P = tt.x + D.width, z = tt.y + D.height, H.right && (P += 0.5 * H.right), H.left && (ct -= 0.5 * H.left), G(H.bottom, ct, it, P, z)), H.left && (ct = tt.x, it = tt.y, P = tt.x, z = tt.y + D.height, H.top && (it -= 0.5 * H.top), H.bottom && (z += 0.5 * H.bottom), G(H.left, ct, it, P, z)), H.right && (ct = tt.x + D.width, it = tt.y, P = tt.x + D.width, z = tt.y + D.height, H.top && (it -= 0.5 * H.top), H.bottom && (z += 0.5 * H.bottom), G(H.right, ct, it, P, z));
                function G(Y, ot, xt, gt, wt) {
                  V.getDocument().setLineWidth(Y), V.getDocument().line(ot, xt, gt, wt, "S");
                }
              }
              function T(V, D, tt, H) {
                var ct = D.settings.margin.bottom, it = D.settings.showFoot;
                return (it === "everyPage" || it === "lastPage" && tt) && (ct += D.getFootHeight(D.columns)), V.pageSize().height - H.y - ct;
              }
              function x(V, D, tt, H, ct, it) {
                ct === void 0 && (ct = []), it === void 0 && (it = !1), V.applyStyles(V.userStyles), D.settings.showFoot === "everyPage" && !it && D.foot.forEach(function(z) {
                  return q(V, D, z, H, ct);
                }), D.callEndPageHooks(V, H);
                var P = D.settings.margin;
                (0, u.addTableBorder)(V, D, tt, H), X(V), D.pageNumber++, D.pageCount++, H.x = P.left, H.y = P.top, tt.y = P.top, D.callWillDrawPageHooks(V, H), D.settings.showHead === "everyPage" && (D.head.forEach(function(z) {
                  return q(V, D, z, H, ct);
                }), V.applyStyles(V.userStyles));
              }
              l.addPage = x;
              function X(V) {
                var D = V.pageNumber();
                V.setPage(D + 1);
                var tt = V.pageNumber();
                return tt === D ? (V.addPage(), !0) : !1;
              }
            }
          ),
          /***/
          224: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.calculateAllColumnsCanFitInPage = void 0;
              var u = h(420);
              function d(f, g, y) {
                var _;
                y === void 0 && (y = {});
                var b = (0, u.getPageAvailableWidth)(f, g), v = /* @__PURE__ */ new Map(), A = [], L = [], O = [];
                g.settings.horizontalPageBreakRepeat, Array.isArray(g.settings.horizontalPageBreakRepeat) ? O = g.settings.horizontalPageBreakRepeat : (typeof g.settings.horizontalPageBreakRepeat == "string" || typeof g.settings.horizontalPageBreakRepeat == "number") && (O = [g.settings.horizontalPageBreakRepeat]), O.forEach(function(M) {
                  var q = g.columns.find(function(N) {
                    return N.dataKey === M || N.index === M;
                  });
                  q && !v.has(q.index) && (v.set(q.index, !0), A.push(q.index), L.push(g.columns[q.index]), b -= q.wrappedWidth);
                });
                for (var R = !0, C = (_ = y == null ? void 0 : y.start) !== null && _ !== void 0 ? _ : 0; C < g.columns.length; ) {
                  if (v.has(C)) {
                    C++;
                    continue;
                  }
                  var E = g.columns[C].wrappedWidth;
                  if (R || b >= E)
                    R = !1, A.push(C), L.push(g.columns[C]), b -= E;
                  else
                    break;
                  C++;
                }
                return { colIndexes: A, columns: L, lastIndex: C - 1 };
              }
              function p(f, g) {
                for (var y = [], _ = 0; _ < g.columns.length; _++) {
                  var b = d(f, g, { start: _ });
                  b.columns.length && (y.push(b), _ = b.lastIndex);
                }
                return y;
              }
              l.calculateAllColumnsCanFitInPage = p;
            }
          ),
          /***/
          324: (
            /***/
            function(a, l, h) {
              Object.defineProperty(l, "__esModule", { value: !0 }), l.ellipsize = l.resizeColumns = l.calculateWidths = void 0;
              var u = h(420);
              function d(A, L) {
                p(A, L);
                var O = [], R = 0;
                L.columns.forEach(function(E) {
                  var M = E.getMaxCustomCellWidth(L);
                  M ? E.width = M : (E.width = E.wrappedWidth, O.push(E)), R += E.width;
                });
                var C = L.getWidth(A.pageSize().width) - R;
                C && (C = f(O, C, function(E) {
                  return Math.max(E.minReadableWidth, E.minWidth);
                })), C && (C = f(O, C, function(E) {
                  return E.minWidth;
                })), C = Math.abs(C), !L.settings.horizontalPageBreak && C > 0.1 / A.scaleFactor() && (C = C < 1 ? C : Math.round(C), console.warn("Of the table content, ".concat(C, " units width could not fit page"))), y(L), _(L, A), g(L);
              }
              l.calculateWidths = d;
              function p(A, L) {
                var O = A.scaleFactor(), R = L.settings.horizontalPageBreak, C = (0, u.getPageAvailableWidth)(A, L);
                L.allRows().forEach(function(E) {
                  for (var M = 0, q = L.columns; M < q.length; M++) {
                    var N = q[M], S = E.cells[N.index];
                    if (S) {
                      var T = L.hooks.didParseCell;
                      L.callCellHooks(A, T, S, E, N, null);
                      var x = S.padding("horizontal");
                      S.contentWidth = (0, u.getStringWidth)(S.text, S.styles, A) + x;
                      var X = (0, u.getStringWidth)(S.text.join(" ").split(/[^\S\u00A0]+/), S.styles, A);
                      if (S.minReadableWidth = X + S.padding("horizontal"), typeof S.styles.cellWidth == "number")
                        S.minWidth = S.styles.cellWidth, S.wrappedWidth = S.styles.cellWidth;
                      else if (S.styles.cellWidth === "wrap" || R === !0)
                        S.contentWidth > C ? (S.minWidth = C, S.wrappedWidth = C) : (S.minWidth = S.contentWidth, S.wrappedWidth = S.contentWidth);
                      else {
                        var V = 10 / O;
                        S.minWidth = S.styles.minCellWidth || V, S.wrappedWidth = S.contentWidth, S.minWidth > S.wrappedWidth && (S.wrappedWidth = S.minWidth);
                      }
                    }
                  }
                }), L.allRows().forEach(function(E) {
                  for (var M = 0, q = L.columns; M < q.length; M++) {
                    var N = q[M], S = E.cells[N.index];
                    if (S && S.colSpan === 1)
                      N.wrappedWidth = Math.max(N.wrappedWidth, S.wrappedWidth), N.minWidth = Math.max(N.minWidth, S.minWidth), N.minReadableWidth = Math.max(N.minReadableWidth, S.minReadableWidth);
                    else {
                      var T = L.styles.columnStyles[N.dataKey] || L.styles.columnStyles[N.index] || {}, x = T.cellWidth || T.minCellWidth;
                      x && typeof x == "number" && (N.minWidth = x, N.wrappedWidth = x);
                    }
                    S && (S.colSpan > 1 && !N.minWidth && (N.minWidth = S.minWidth), S.colSpan > 1 && !N.wrappedWidth && (N.wrappedWidth = S.minWidth));
                  }
                });
              }
              function f(A, L, O) {
                for (var R = L, C = A.reduce(function(V, D) {
                  return V + D.wrappedWidth;
                }, 0), E = 0; E < A.length; E++) {
                  var M = A[E], q = M.wrappedWidth / C, N = R * q, S = M.width + N, T = O(M), x = S < T ? T : S;
                  L -= x - M.width, M.width = x;
                }
                if (L = Math.round(L * 1e10) / 1e10, L) {
                  var X = A.filter(function(V) {
                    return L < 0 ? V.width > O(V) : !0;
                  });
                  X.length && (L = f(X, L, O));
                }
                return L;
              }
              l.resizeColumns = f;
              function g(A) {
                for (var L = {}, O = 1, R = A.allRows(), C = 0; C < R.length; C++)
                  for (var E = R[C], M = 0, q = A.columns; M < q.length; M++) {
                    var N = q[M], S = L[N.index];
                    if (O > 1)
                      O--, delete E.cells[N.index];
                    else if (S)
                      S.cell.height += E.height, O = S.cell.colSpan, delete E.cells[N.index], S.left--, S.left <= 1 && delete L[N.index];
                    else {
                      var T = E.cells[N.index];
                      if (!T)
                        continue;
                      if (T.height = E.height, T.rowSpan > 1) {
                        var x = R.length - C, X = T.rowSpan > x ? x : T.rowSpan;
                        L[N.index] = { cell: T, left: X, row: E };
                      }
                    }
                  }
              }
              function y(A) {
                for (var L = A.allRows(), O = 0; O < L.length; O++)
                  for (var R = L[O], C = null, E = 0, M = 0, q = 0; q < A.columns.length; q++) {
                    var N = A.columns[q];
                    if (M -= 1, M > 1 && A.columns[q + 1])
                      E += N.width, delete R.cells[N.index];
                    else if (C) {
                      var S = C;
                      delete R.cells[N.index], C = null, S.width = N.width + E;
                    } else {
                      var S = R.cells[N.index];
                      if (!S)
                        continue;
                      if (M = S.colSpan, E = 0, S.colSpan > 1) {
                        C = S, E += N.width;
                        continue;
                      }
                      S.width = N.width + E;
                    }
                  }
              }
              function _(A, L) {
                for (var O = { count: 0, height: 0 }, R = 0, C = A.allRows(); R < C.length; R++) {
                  for (var E = C[R], M = 0, q = A.columns; M < q.length; M++) {
                    var N = q[M], S = E.cells[N.index];
                    if (S) {
                      L.applyStyles(S.styles, !0);
                      var T = S.width - S.padding("horizontal");
                      if (S.styles.overflow === "linebreak")
                        S.text = L.splitTextToSize(S.text, T + 1 / L.scaleFactor(), { fontSize: S.styles.fontSize });
                      else if (S.styles.overflow === "ellipsize")
                        S.text = b(S.text, T, S.styles, L, "...");
                      else if (S.styles.overflow === "hidden")
                        S.text = b(S.text, T, S.styles, L, "");
                      else if (typeof S.styles.overflow == "function") {
                        var x = S.styles.overflow(S.text, T);
                        typeof x == "string" ? S.text = [x] : S.text = x;
                      }
                      S.contentHeight = S.getContentHeight(L.scaleFactor(), L.getLineHeightFactor());
                      var X = S.contentHeight / S.rowSpan;
                      S.rowSpan > 1 && O.count * O.height < X * S.rowSpan ? O = { height: X, count: S.rowSpan } : O && O.count > 0 && O.height > X && (X = O.height), X > E.height && (E.height = X);
                    }
                  }
                  O.count--;
                }
              }
              function b(A, L, O, R, C) {
                return A.map(function(E) {
                  return v(E, L, O, R, C);
                });
              }
              l.ellipsize = b;
              function v(A, L, O, R, C) {
                var E = 1e4 * R.scaleFactor();
                if (L = Math.ceil(L * E) / E, L >= (0, u.getStringWidth)(A, O, R))
                  return A;
                for (; L < (0, u.getStringWidth)(A + C, O, R) && !(A.length <= 1); )
                  A = A.substring(0, A.length - 1);
                return A.trim() + C;
              }
            }
          ),
          /***/
          964: (
            /***/
            function(a) {
              if (typeof e > "u") {
                var l = new Error("Cannot find module 'undefined'");
                throw l.code = "MODULE_NOT_FOUND", l;
              }
              a.exports = e;
            }
          )
          /******/
        }, r = {};
        function s(a) {
          var l = r[a];
          if (l !== void 0)
            return l.exports;
          var h = r[a] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return i[a].call(h.exports, h, h.exports, s), h.exports;
        }
        var o = {};
        return function() {
          var a = o;
          Object.defineProperty(a, "__esModule", { value: !0 }), a.Cell = a.Column = a.Row = a.Table = a.CellHookData = a.__drawTable = a.__createTable = a.applyPlugin = void 0;
          var l = s(340), h = s(776), u = s(664), d = s(972), p = s(260);
          Object.defineProperty(a, "Table", { enumerable: !0, get: function() {
            return p.Table;
          } });
          var f = s(172);
          Object.defineProperty(a, "CellHookData", { enumerable: !0, get: function() {
            return f.CellHookData;
          } });
          var g = s(260);
          Object.defineProperty(a, "Cell", { enumerable: !0, get: function() {
            return g.Cell;
          } }), Object.defineProperty(a, "Column", { enumerable: !0, get: function() {
            return g.Column;
          } }), Object.defineProperty(a, "Row", { enumerable: !0, get: function() {
            return g.Row;
          } });
          function y(L) {
            (0, l.default)(L);
          }
          a.applyPlugin = y;
          function _(L, O) {
            var R = (0, h.parseInput)(L, O), C = (0, d.createTable)(L, R);
            (0, u.drawTable)(L, C);
          }
          function b(L, O) {
            var R = (0, h.parseInput)(L, O);
            return (0, d.createTable)(L, R);
          }
          a.__createTable = b;
          function v(L, O) {
            (0, u.drawTable)(L, O);
          }
          a.__drawTable = v;
          try {
            var A = s(964);
            A.jsPDF && (A = A.jsPDF), y(A);
          } catch {
          }
          a.default = _;
        }(), o;
      }()
    );
  });
})(q1);
var ew = q1.exports;
const sa = /* @__PURE__ */ Tc(ew), oa = 5, fl = 10, Eu = ",", aa = {
  fillColor: [7, 59, 76],
  fontStyle: "normal"
}, la = {
  fontSize: 9
}, ua = { left: 10 };
let ca = [];
const nw = (n, t, e = (i) => i.toString()) => {
  var h;
  const { t: i } = N2.global, r = new Se({ orientation: "landscape" });
  let s = 10;
  r.setFontSize(20), r.text(i("pdf.orderSummary"), 10, s), s += 15, r.setFontSize(14), r.text("Your parts", 10, s), s += oa, ca = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity"),
    i("name"),
    `Banding (${mr.join(Eu)})`,
    `Finish (${pr.join(Eu)})`
  ];
  const o = n.parts.map((u) => {
    var f;
    const d = mr.map((g) => u.banding[g] || "-").join(Eu), p = pr.map((g) => u.banding[g] || "-").join(Eu);
    return [
      e(u.l),
      e(u.w),
      e(u.t) || "-",
      ((f = u == null ? void 0 : u.material) == null ? void 0 : f.toUpperCase()) || "-",
      e(u.q),
      u.name || "-",
      d,
      p
    ];
  });
  sa(r, {
    startY: s,
    head: [ca],
    body: o,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + fl, r.setFontSize(14), r.text(i("pdf.stockRequirements"), 10, s), s += oa, ca = [
    i("length"),
    i("width"),
    i("thickness"),
    i("material"),
    i("quantity")
    // 'Cost'
  ];
  const a = n.stock.map((u) => {
    var d;
    return [
      e(u.l),
      e(u.w),
      e(u.t) || "-",
      ((d = u == null ? void 0 : u.material) == null ? void 0 : d.toUpperCase()) || "-",
      e(u.q)
      // stock.cost
    ];
  });
  if (sa(r, {
    startY: s,
    head: [ca],
    body: a,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + fl, n.metadata.totalRollLength > 0) {
    r.setFontSize(14), r.text(i("pdf.rollRequirements"), 10, s), s += oa, ca = [
      i("name"),
      i("material"),
      i("length")
    ];
    const u = n.stock.map((d) => {
      var p, f;
      return [
        ((p = d == null ? void 0 : d.name) == null ? void 0 : p.toUpperCase()) || "-",
        ((f = d == null ? void 0 : d.material) == null ? void 0 : f.toUpperCase()) || "-",
        e(d.analysis.rollLength)
      ];
    });
    sa(r, {
      startY: s,
      head: [ca],
      body: u,
      margin: ua,
      headStyles: aa,
      styles: la
    }), s = r.autoTable.previous.finalY + fl;
  }
  if (t && Object.values(t)) {
    r.setFontSize(14), r.text("Hardware", 10, s), s += oa;
    const u = Object.values(t).map((d) => [
      d.name.toUpperCase(),
      e(d.q)
      // item.totalCost.toFixed( 2 )
    ]);
    sa(r, {
      startY: s,
      head: [[i("pdf.item"), i("quantity")]],
      body: u,
      margin: ua,
      headStyles: aa,
      styles: la
    }), s = r.autoTable.previous.finalY + fl;
  }
  r.setFontSize(14), r.text(i("pdf.totals"), 10, s), s += oa;
  const l = [
    [i("pdf.totalParts"), e(n.metadata.totalPartsProduced)],
    [i("pdf.partArea"), e(n.metadata.totalPartArea)],
    [i("pdf.totalStockRequired"), e(n.metadata.totalUsedStock)],
    [i("pdf.totalBandingLength"), e(n.metadata.totalBandingLength)],
    [i("pdf.totalFinishArea"), e(n.metadata.totalFinishArea)],
    [i("pdf.totalRollLength"), e(n.metadata.totalRollLength)]
  ];
  if (sa(r, {
    startY: s,
    body: l,
    margin: ua,
    headStyles: aa,
    styles: la
  }), s = r.autoTable.previous.finalY + fl, (h = window == null ? void 0 : window.smartcutImages) != null && h.length) {
    r.addPage();
    let u = 10;
    r.setFontSize(14), r.text(i("pdf.images"), 10, u), u += oa;
    const d = window.smartcutImages.flatMap((p, f) => p.metadata.map((g) => [
      f + 1,
      g.newName
    ]));
    sa(r, {
      startY: u,
      body: d,
      head: [[i("pdf.partIndex"), i("pdf.fileName")]],
      margin: ua,
      headStyles: aa,
      styles: la
    });
  }
  return r.output("datauristring");
};
function iw(n) {
  return P2() ? (L2(n), !0) : !1;
}
function Ad(n) {
  return typeof n == "function" ? n() : Oe(n);
}
const rw = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const sw = Object.prototype.toString, ow = (n) => sw.call(n) === "[object Object]", aw = () => {
};
function lw(n, t) {
  function e(...i) {
    return new Promise((r, s) => {
      Promise.resolve(n(() => t.apply(this, i), { fn: t, thisArg: this, args: i })).then(r).catch(s);
    });
  }
  return e;
}
const z1 = (n) => n();
function uw(n = z1) {
  const t = _e(!0);
  function e() {
    t.value = !1;
  }
  function i() {
    t.value = !0;
  }
  const r = (...s) => {
    t.value && n(...s);
  };
  return { isActive: C2(t), pause: e, resume: i, eventFilter: r };
}
function cw(n) {
  return I2();
}
function hw(n, t, e = {}) {
  const {
    eventFilter: i = z1,
    ...r
  } = e;
  return Qi(
    n,
    lw(
      i,
      t
    ),
    r
  );
}
function fw(n, t, e = {}) {
  const {
    eventFilter: i,
    ...r
  } = e, { eventFilter: s, pause: o, resume: a, isActive: l } = uw(i);
  return { stop: hw(
    n,
    t,
    {
      ...r,
      eventFilter: s
    }
  ), pause: o, resume: a, isActive: l };
}
function dw(n, t = !0, e) {
  cw() ? Us(n, e) : t ? n() : dr(n);
}
function pw(n) {
  var t;
  const e = Ad(n);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const uc = rw ? window : void 0;
function cg(...n) {
  let t, e, i, r;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([e, i, r] = n, t = uc) : [t, e, i, r] = n, !t)
    return aw;
  Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
  const s = [], o = () => {
    s.forEach((u) => u()), s.length = 0;
  }, a = (u, d, p, f) => (u.addEventListener(d, p, f), () => u.removeEventListener(d, p, f)), l = Qi(
    () => [pw(t), Ad(r)],
    ([u, d]) => {
      if (o(), !u)
        return;
      const p = ow(d) ? { ...d } : d;
      s.push(
        ...e.flatMap((f) => i.map((g) => a(u, f, g, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), h = () => {
    l(), o();
  };
  return iw(h), h;
}
const Ou = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Tu = "__vueuse_ssr_handlers__", gw = /* @__PURE__ */ mw();
function mw() {
  return Tu in Ou || (Ou[Tu] = Ou[Tu] || {}), Ou[Tu];
}
function yw(n, t) {
  return gw[n] || t;
}
function bw(n) {
  return n == null ? "any" : n instanceof Set ? "set" : n instanceof Map ? "map" : n instanceof Date ? "date" : typeof n == "boolean" ? "boolean" : typeof n == "string" ? "string" : typeof n == "object" ? "object" : Number.isNaN(n) ? "any" : "number";
}
const vw = {
  boolean: {
    read: (n) => n === "true",
    write: (n) => String(n)
  },
  object: {
    read: (n) => JSON.parse(n),
    write: (n) => JSON.stringify(n)
  },
  number: {
    read: (n) => Number.parseFloat(n),
    write: (n) => String(n)
  },
  any: {
    read: (n) => n,
    write: (n) => String(n)
  },
  string: {
    read: (n) => n,
    write: (n) => String(n)
  },
  map: {
    read: (n) => new Map(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n.entries()))
  },
  set: {
    read: (n) => new Set(JSON.parse(n)),
    write: (n) => JSON.stringify(Array.from(n))
  },
  date: {
    read: (n) => new Date(n),
    write: (n) => n.toISOString()
  }
}, hg = "vueuse-storage";
function ww(n, t, e, i = {}) {
  var r;
  const {
    flush: s = "pre",
    deep: o = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: h = !1,
    shallow: u,
    window: d = uc,
    eventFilter: p,
    onError: f = (q) => {
      console.error(q);
    },
    initOnMounted: g
  } = i, y = (u ? lo : _e)(typeof t == "function" ? t() : t);
  if (!e)
    try {
      e = yw("getDefaultStorage", () => {
        var q;
        return (q = uc) == null ? void 0 : q.localStorage;
      })();
    } catch (q) {
      f(q);
    }
  if (!e)
    return y;
  const _ = Ad(t), b = bw(_), v = (r = i.serializer) != null ? r : vw[b], { pause: A, resume: L } = fw(
    y,
    () => R(y.value),
    { flush: s, deep: o, eventFilter: p }
  );
  d && a && dw(() => {
    cg(d, "storage", E), cg(d, hg, M), g && E();
  }), g || E();
  function O(q, N) {
    d && d.dispatchEvent(new CustomEvent(hg, {
      detail: {
        key: n,
        oldValue: q,
        newValue: N,
        storageArea: e
      }
    }));
  }
  function R(q) {
    try {
      const N = e.getItem(n);
      if (q == null)
        O(N, null), e.removeItem(n);
      else {
        const S = v.write(q);
        N !== S && (e.setItem(n, S), O(N, S));
      }
    } catch (N) {
      f(N);
    }
  }
  function C(q) {
    const N = q ? q.newValue : e.getItem(n);
    if (N == null)
      return l && _ != null && e.setItem(n, v.write(_)), _;
    if (!q && h) {
      const S = v.read(N);
      return typeof h == "function" ? h(S, _) : b === "object" && !Array.isArray(S) ? { ..._, ...S } : S;
    } else return typeof N != "string" ? N : v.read(N);
  }
  function E(q) {
    if (!(q && q.storageArea !== e)) {
      if (q && q.key == null) {
        y.value = _;
        return;
      }
      if (!(q && q.key !== n)) {
        A();
        try {
          (q == null ? void 0 : q.newValue) !== v.write(y.value) && (y.value = C(q));
        } catch (N) {
          f(N);
        } finally {
          q ? dr(L) : L();
        }
      }
    }
  }
  function M(q) {
    E(q.detail);
  }
  return y;
}
function fg(n, t, e = {}) {
  const { window: i = uc } = e;
  return ww(n, t, i == null ? void 0 : i.localStorage, e);
}
const Xn = [];
for (let n = 0; n < 256; ++n)
  Xn.push((n + 256).toString(16).slice(1));
function xw(n, t = 0) {
  return (Xn[n[t + 0]] + Xn[n[t + 1]] + Xn[n[t + 2]] + Xn[n[t + 3]] + "-" + Xn[n[t + 4]] + Xn[n[t + 5]] + "-" + Xn[n[t + 6]] + Xn[n[t + 7]] + "-" + Xn[n[t + 8]] + Xn[n[t + 9]] + "-" + Xn[n[t + 10]] + Xn[n[t + 11]] + Xn[n[t + 12]] + Xn[n[t + 13]] + Xn[n[t + 14]] + Xn[n[t + 15]]).toLowerCase();
}
let Oh;
const _w = new Uint8Array(16);
function Sw() {
  if (!Oh) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Oh = crypto.getRandomValues.bind(crypto);
  }
  return Oh(_w);
}
const kw = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), dg = { randomUUID: kw };
function Aw(n, t, e) {
  if (dg.randomUUID && !t && !n)
    return dg.randomUUID();
  n = n || {};
  const i = n.random || (n.rng || Sw)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, xw(i);
}
const Mr = /* @__PURE__ */ Object.create(null);
Mr.open = "0";
Mr.close = "1";
Mr.ping = "2";
Mr.pong = "3";
Mr.message = "4";
Mr.upgrade = "5";
Mr.noop = "6";
const Wu = /* @__PURE__ */ Object.create(null);
Object.keys(Mr).forEach((n) => {
  Wu[Mr[n]] = n;
});
const vf = { type: "error", data: "parser error" }, $1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", U1 = typeof ArrayBuffer == "function", W1 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, Nd = ({ type: n, data: t }, e, i) => $1 && t instanceof Blob ? e ? i(t) : pg(t, i) : U1 && (t instanceof ArrayBuffer || W1(t)) ? e ? i(t) : pg(new Blob([t]), i) : i(Mr[n] + (t || "")), pg = (n, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const i = e.result.split(",")[1];
    t("b" + (i || ""));
  }, e.readAsDataURL(n);
};
function gg(n) {
  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
}
let Th;
function Nw(n, t) {
  if ($1 && n.data instanceof Blob)
    return n.data.arrayBuffer().then(gg).then(t);
  if (U1 && (n.data instanceof ArrayBuffer || W1(n.data)))
    return t(gg(n.data));
  Nd(n, !1, (e) => {
    Th || (Th = new TextEncoder()), t(Th.encode(e));
  });
}
const mg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bl = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < mg.length; n++)
  bl[mg.charCodeAt(n)] = n;
const Cw = (n) => {
  let t = n.length * 0.75, e = n.length, i, r = 0, s, o, a, l;
  n[n.length - 1] === "=" && (t--, n[n.length - 2] === "=" && t--);
  const h = new ArrayBuffer(t), u = new Uint8Array(h);
  for (i = 0; i < e; i += 4)
    s = bl[n.charCodeAt(i)], o = bl[n.charCodeAt(i + 1)], a = bl[n.charCodeAt(i + 2)], l = bl[n.charCodeAt(i + 3)], u[r++] = s << 2 | o >> 4, u[r++] = (o & 15) << 4 | a >> 2, u[r++] = (a & 3) << 6 | l & 63;
  return h;
}, Pw = typeof ArrayBuffer == "function", Cd = (n, t) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: H1(n, t)
    };
  const e = n.charAt(0);
  return e === "b" ? {
    type: "message",
    data: Lw(n.substring(1), t)
  } : Wu[e] ? n.length > 1 ? {
    type: Wu[e],
    data: n.substring(1)
  } : {
    type: Wu[e]
  } : vf;
}, Lw = (n, t) => {
  if (Pw) {
    const e = Cw(n);
    return H1(e, t);
  } else
    return { base64: !0, data: n };
}, H1 = (n, t) => {
  switch (t) {
    case "blob":
      return n instanceof Blob ? n : new Blob([n]);
    case "arraybuffer":
    default:
      return n instanceof ArrayBuffer ? n : n.buffer;
  }
}, G1 = "", Iw = (n, t) => {
  const e = n.length, i = new Array(e);
  let r = 0;
  n.forEach((s, o) => {
    Nd(s, !1, (a) => {
      i[o] = a, ++r === e && t(i.join(G1));
    });
  });
}, Ew = (n, t) => {
  const e = n.split(G1), i = [];
  for (let r = 0; r < e.length; r++) {
    const s = Cd(e[r], t);
    if (i.push(s), s.type === "error")
      break;
  }
  return i;
};
function Ow() {
  return new TransformStream({
    transform(n, t) {
      Nw(n, (e) => {
        const i = e.length;
        let r;
        if (i < 126)
          r = new Uint8Array(1), new DataView(r.buffer).setUint8(0, i);
        else if (i < 65536) {
          r = new Uint8Array(3);
          const s = new DataView(r.buffer);
          s.setUint8(0, 126), s.setUint16(1, i);
        } else {
          r = new Uint8Array(9);
          const s = new DataView(r.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(i));
        }
        n.data && typeof n.data != "string" && (r[0] |= 128), t.enqueue(r), t.enqueue(e);
      });
    }
  });
}
let Fh;
function Fu(n) {
  return n.reduce((t, e) => t + e.length, 0);
}
function Mu(n, t) {
  if (n[0].length === t)
    return n.shift();
  const e = new Uint8Array(t);
  let i = 0;
  for (let r = 0; r < t; r++)
    e[r] = n[0][i++], i === n[0].length && (n.shift(), i = 0);
  return n.length && i < n[0].length && (n[0] = n[0].slice(i)), e;
}
function Tw(n, t) {
  Fh || (Fh = new TextDecoder());
  const e = [];
  let i = 0, r = -1, s = !1;
  return new TransformStream({
    transform(o, a) {
      for (e.push(o); ; ) {
        if (i === 0) {
          if (Fu(e) < 1)
            break;
          const l = Mu(e, 1);
          s = (l[0] & 128) === 128, r = l[0] & 127, r < 126 ? i = 3 : r === 126 ? i = 1 : i = 2;
        } else if (i === 1) {
          if (Fu(e) < 2)
            break;
          const l = Mu(e, 2);
          r = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), i = 3;
        } else if (i === 2) {
          if (Fu(e) < 8)
            break;
          const l = Mu(e, 8), h = new DataView(l.buffer, l.byteOffset, l.length), u = h.getUint32(0);
          if (u > Math.pow(2, 21) - 1) {
            a.enqueue(vf);
            break;
          }
          r = u * Math.pow(2, 32) + h.getUint32(4), i = 3;
        } else {
          if (Fu(e) < r)
            break;
          const l = Mu(e, r);
          a.enqueue(Cd(s ? l : Fh.decode(l), t)), i = 0;
        }
        if (r === 0 || r > n) {
          a.enqueue(vf);
          break;
        }
      }
    }
  });
}
const V1 = 4;
function Tn(n) {
  if (n) return Fw(n);
}
function Fw(n) {
  for (var t in Tn.prototype)
    n[t] = Tn.prototype[t];
  return n;
}
Tn.prototype.on = Tn.prototype.addEventListener = function(n, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(t), this;
};
Tn.prototype.once = function(n, t) {
  function e() {
    this.off(n, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(n, e), this;
};
Tn.prototype.off = Tn.prototype.removeListener = Tn.prototype.removeAllListeners = Tn.prototype.removeEventListener = function(n, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + n];
  if (!e) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var i, r = 0; r < e.length; r++)
    if (i = e[r], i === t || i.fn === t) {
      e.splice(r, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + n], this;
};
Tn.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + n], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  if (e) {
    e = e.slice(0);
    for (var i = 0, r = e.length; i < r; ++i)
      e[i].apply(this, t);
  }
  return this;
};
Tn.prototype.emitReserved = Tn.prototype.emit;
Tn.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Tn.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const jc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0), Zi = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), Mw = "arraybuffer";
function Y1(n, ...t) {
  return t.reduce((e, i) => (n.hasOwnProperty(i) && (e[i] = n[i]), e), {});
}
const Rw = Zi.setTimeout, Dw = Zi.clearTimeout;
function qc(n, t) {
  t.useNativeTimers ? (n.setTimeoutFn = Rw.bind(Zi), n.clearTimeoutFn = Dw.bind(Zi)) : (n.setTimeoutFn = Zi.setTimeout.bind(Zi), n.clearTimeoutFn = Zi.clearTimeout.bind(Zi));
}
const Bw = 1.33;
function jw(n) {
  return typeof n == "string" ? qw(n) : Math.ceil((n.byteLength || n.size) * Bw);
}
function qw(n) {
  let t = 0, e = 0;
  for (let i = 0, r = n.length; i < r; i++)
    t = n.charCodeAt(i), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (i++, e += 4);
  return e;
}
function K1() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function zw(n) {
  let t = "";
  for (let e in n)
    n.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(n[e]));
  return t;
}
function $w(n) {
  let t = {}, e = n.split("&");
  for (let i = 0, r = e.length; i < r; i++) {
    let s = e[i].split("=");
    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return t;
}
class Uw extends Error {
  constructor(t, e, i) {
    super(t), this.description = e, this.context = i, this.type = "TransportError";
  }
}
class Pd extends Tn {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, qc(this, t), this.opts = t, this.query = t.query, this.socket = t.socket, this.supportsBinary = !t.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, e, i) {
    return super.emitReserved("error", new Uw(t, e, i)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const e = Cd(t, this.socket.binaryType);
    this.onPacket(e);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, e = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(e);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const e = zw(t);
    return e.length ? "?" + e : "";
  }
}
class Ww extends Pd {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || e();
      })), this.writable || (i++, this.once("drain", function() {
        --i || e();
      }));
    } else
      e();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    const e = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(i);
    };
    Ew(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, Iw(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", e = this.query || {};
    return this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = K1()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.createUri(t, e);
  }
}
let X1 = !1;
try {
  X1 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Hw = X1;
function Gw() {
}
class Vw extends Ww {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), typeof location < "u") {
      const e = location.protocol === "https:";
      let i = location.port;
      i || (i = e ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, e) {
    const i = this.request({
      method: "POST",
      data: t
    });
    i.on("success", e), i.on("error", (r, s) => {
      this.onError("xhr post error", r, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, i) => {
      this.onError("xhr poll error", e, i);
    }), this.pollXhr = t;
  }
}
class Tr extends Tn {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, e, i) {
    super(), this.createRequest = t, qc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = e, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var t;
    const e = Y1(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(e);
    try {
      i.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(!0);
          for (let r in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(r) && i.setRequestHeader(r, this._opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this._opts.cookieJar) === null || t === void 0 || t.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var r;
        i.readyState === 3 && ((r = this._opts.cookieJar) === null || r === void 0 || r.parseCookies(
          // @ts-ignore
          i.getResponseHeader("set-cookie")
        )), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this._onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Tr.requestsCount++, Tr.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(t) {
    this.emitReserved("error", t, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(t) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = Gw, t)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Tr.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const t = this._xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Tr.requestsCount = 0;
Tr.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", yg);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in Zi ? "pagehide" : "unload";
    addEventListener(n, yg, !1);
  }
}
function yg() {
  for (let n in Tr.requests)
    Tr.requests.hasOwnProperty(n) && Tr.requests[n].abort();
}
const Yw = function() {
  const n = J1({
    xdomain: !1
  });
  return n && n.responseType !== null;
}();
class Kw extends Vw {
  constructor(t) {
    super(t);
    const e = t && t.forceBase64;
    this.supportsBinary = Yw && !e;
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd }, this.opts), new Tr(J1, this.uri(), t);
  }
}
function J1(n) {
  const t = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || Hw))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new Zi[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Z1 = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Xw extends Pd {
  get name() {
    return "websocket";
  }
  doOpen() {
    const t = this.uri(), e = this.opts.protocols, i = Z1 ? {} : Y1(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(t, e, i);
    } catch (r) {
      return this.emitReserved("error", r);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      Nd(i, this.supportsBinary, (s) => {
        try {
          this.doWrite(i, s);
        } catch {
        }
        r && jc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", e = this.query || {};
    return this.opts.timestampRequests && (e[this.opts.timestampParam] = K1()), this.supportsBinary || (e.b64 = 1), this.createUri(t, e);
  }
}
const Mh = Zi.WebSocket || Zi.MozWebSocket;
class Jw extends Xw {
  createSocket(t, e, i) {
    return Z1 ? new Mh(t, e, i) : e ? new Mh(t, e) : new Mh(t);
  }
  doWrite(t, e) {
    this.ws.send(e);
  }
}
class Zw extends Pd {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (t) {
      return this.emitReserved("error", t);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((t) => {
      this.onError("webtransport error", t);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((t) => {
        const e = Tw(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = t.readable.pipeThrough(e).getReader(), r = Ow();
        r.readable.pipeTo(t.writable), this._writer = r.writable.getWriter();
        const s = () => {
          i.read().then(({ done: a, value: l }) => {
            a || (this.onPacket(l), s());
          }).catch((a) => {
          });
        };
        s();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen());
      });
    });
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = e === t.length - 1;
      this._writer.write(i).then(() => {
        r && jc(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this._transport) === null || t === void 0 || t.close();
  }
}
const Qw = {
  websocket: Jw,
  webtransport: Zw,
  polling: Kw
}, t3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, e3 = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function wf(n) {
  if (n.length > 8e3)
    throw "URI too long";
  const t = n, e = n.indexOf("["), i = n.indexOf("]");
  e != -1 && i != -1 && (n = n.substring(0, e) + n.substring(e, i).replace(/:/g, ";") + n.substring(i, n.length));
  let r = t3.exec(n || ""), s = {}, o = 14;
  for (; o--; )
    s[e3[o]] = r[o] || "";
  return e != -1 && i != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = n3(s, s.path), s.queryKey = i3(s, s.query), s;
}
function n3(n, t) {
  const e = /\/{2,9}/g, i = t.replace(e, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && i.splice(0, 1), t.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function i3(n, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, r, s) {
    r && (e[r] = s);
  }), e;
}
const xf = typeof addEventListener == "function" && typeof removeEventListener == "function", Hu = [];
xf && addEventListener("offline", () => {
  Hu.forEach((n) => n());
}, !1);
class js extends Tn {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, e) {
    if (super(), this.binaryType = Mw, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, t && typeof t == "object" && (e = t, t = null), t) {
      const i = wf(t);
      e.hostname = i.host, e.secure = i.protocol === "https" || i.protocol === "wss", e.port = i.port, i.query && (e.query = i.query);
    } else e.host && (e.hostname = wf(e.host).host);
    qc(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, e.transports.forEach((i) => {
      const r = i.prototype.name;
      this.transports.push(r), this._transportsByName[r] = i;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = $w(this.opts.query)), xf && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, Hu.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = V1, e.transport = t, this.id && (e.sid = this.id);
    const i = Object.assign({}, this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return new this._transportsByName[t](i);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const t = this.opts.rememberUpgrade && js.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const e = this.createTransport(t);
    e.open(), this.setTransport(e);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (e) => this._onClose("transport close", e));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", js.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this._onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this._pingInterval = t.pingInterval, this._pingTimeout = t.pingTimeout, this._maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const t = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + t, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, t), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this._getWritablePackets();
      this.transport.send(t), this._prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const r = this.writeBuffer[i].data;
      if (r && (e += jw(r)), i > 0 && e > this._maxPayload)
        return this.writeBuffer.slice(0, i);
      e += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const t = Date.now() > this._pingTimeoutTime;
    return t && (this._pingTimeoutTime = 0, jc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), t;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(t, e, i) {
    return this._sendPacket("message", t, e, i), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(t, e, i, r) {
    if (typeof e == "function" && (r = e, e = void 0), typeof i == "function" && (r = i, i = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    i = i || {}, i.compress = i.compress !== !1;
    const s = {
      type: t,
      data: e,
      options: i
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), r && this.once("flush", r), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this._onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, i = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : t();
    }) : this.upgrading ? i() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(t) {
    if (js.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", t), this._onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(t, e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), xf && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const i = Hu.indexOf(this._offlineEventListener);
        i !== -1 && Hu.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
js.protocol = V1;
class r3 extends js {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let t = 0; t < this._upgrades.length; t++)
        this._probe(this._upgrades[t]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(t) {
    let e = this.createTransport(t), i = !1;
    js.priorWebsocketSuccess = !1;
    const r = () => {
      i || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (d) => {
        if (!i)
          if (d.type === "pong" && d.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            js.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              i || this.readyState !== "closed" && (u(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const p = new Error("probe error");
            p.transport = e.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function s() {
      i || (i = !0, u(), e.close(), e = null);
    }
    const o = (d) => {
      const p = new Error("probe error: " + d);
      p.transport = e.name, s(), this.emitReserved("upgradeError", p);
    };
    function a() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function h(d) {
      e && d.name !== e.name && s();
    }
    const u = () => {
      e.removeListener("open", r), e.removeListener("error", o), e.removeListener("close", a), this.off("close", l), this.off("upgrading", h);
    };
    e.once("open", r), e.once("error", o), e.once("close", a), this.once("close", l), this.once("upgrading", h), this._upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      i || e.open();
    }, 200) : e.open();
  }
  onHandshake(t) {
    this._upgrades = this._filterUpgrades(t.upgrades), super.onHandshake(t);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(t) {
    const e = [];
    for (let i = 0; i < t.length; i++)
      ~this.transports.indexOf(t[i]) && e.push(t[i]);
    return e;
  }
}
let s3 = class extends r3 {
  constructor(t, e = {}) {
    const i = typeof t == "object" ? t : e;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((r) => Qw[r]).filter((r) => !!r)), super(t, i);
  }
};
function o3(n, t = "", e) {
  let i = n;
  e = e || typeof location < "u" && location, n == null && (n = e.protocol + "//" + e.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = e.protocol + n : n = e.host + n), /^(https?|wss?):\/\//.test(n) || (typeof e < "u" ? n = e.protocol + "//" + n : n = "https://" + n), i = wf(n)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const s = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + s + ":" + i.port + t, i.href = i.protocol + "://" + s + (e && e.port === i.port ? "" : ":" + i.port), i;
}
const a3 = typeof ArrayBuffer == "function", l3 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Q1 = Object.prototype.toString, u3 = typeof Blob == "function" || typeof Blob < "u" && Q1.call(Blob) === "[object BlobConstructor]", c3 = typeof File == "function" || typeof File < "u" && Q1.call(File) === "[object FileConstructor]";
function Ld(n) {
  return a3 && (n instanceof ArrayBuffer || l3(n)) || u3 && n instanceof Blob || c3 && n instanceof File;
}
function Gu(n, t) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let e = 0, i = n.length; e < i; e++)
      if (Gu(n[e]))
        return !0;
    return !1;
  }
  if (Ld(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return Gu(n.toJSON(), !0);
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e) && Gu(n[e]))
      return !0;
  return !1;
}
function h3(n) {
  const t = [], e = n.data, i = n;
  return i.data = _f(e, t), i.attachments = t.length, { packet: i, buffers: t };
}
function _f(n, t) {
  if (!n)
    return n;
  if (Ld(n)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(n), e;
  } else if (Array.isArray(n)) {
    const e = new Array(n.length);
    for (let i = 0; i < n.length; i++)
      e[i] = _f(n[i], t);
    return e;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const e = {};
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = _f(n[i], t));
    return e;
  }
  return n;
}
function f3(n, t) {
  return n.data = Sf(n.data, t), delete n.attachments, n;
}
function Sf(n, t) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < t.length)
      return t[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let e = 0; e < n.length; e++)
      n[e] = Sf(n[e], t);
  else if (typeof n == "object")
    for (const e in n)
      Object.prototype.hasOwnProperty.call(n, e) && (n[e] = Sf(n[e], t));
  return n;
}
const d3 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], p3 = 5;
var ze;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(ze || (ze = {}));
class g3 {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(t) {
    this.replacer = t;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(t) {
    return (t.type === ze.EVENT || t.type === ze.ACK) && Gu(t) ? this.encodeAsBinary({
      type: t.type === ze.EVENT ? ze.BINARY_EVENT : ze.BINARY_ACK,
      nsp: t.nsp,
      data: t.data,
      id: t.id
    }) : [this.encodeAsString(t)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === ze.BINARY_EVENT || t.type === ze.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(t) {
    const e = h3(t), i = this.encodeAsString(e.packet), r = e.buffers;
    return r.unshift(i), r;
  }
}
function bg(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
class Id extends Tn {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(t) {
    super(), this.reviver = t;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t);
      const i = e.type === ze.BINARY_EVENT;
      i || e.type === ze.BINARY_ACK ? (e.type = i ? ze.EVENT : ze.ACK, this.reconstructor = new m3(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (Ld(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(t) {
    let e = 0;
    const i = {
      type: Number(t.charAt(0))
    };
    if (ze[i.type] === void 0)
      throw new Error("unknown packet type " + i.type);
    if (i.type === ze.BINARY_EVENT || i.type === ze.BINARY_ACK) {
      const s = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const o = t.substring(s, e);
      if (o != Number(o) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      i.attachments = Number(o);
    }
    if (t.charAt(e + 1) === "/") {
      const s = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      i.nsp = t.substring(s, e);
    } else
      i.nsp = "/";
    const r = t.charAt(e + 1);
    if (r !== "" && Number(r) == r) {
      const s = e + 1;
      for (; ++e; ) {
        const o = t.charAt(e);
        if (o == null || Number(o) != o) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      i.id = Number(t.substring(s, e + 1));
    }
    if (t.charAt(++e)) {
      const s = this.tryParse(t.substr(e));
      if (Id.isPayloadValid(i.type, s))
        i.data = s;
      else
        throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case ze.CONNECT:
        return bg(e);
      case ze.DISCONNECT:
        return e === void 0;
      case ze.CONNECT_ERROR:
        return typeof e == "string" || bg(e);
      case ze.EVENT:
      case ze.BINARY_EVENT:
        return Array.isArray(e) && (typeof e[0] == "number" || typeof e[0] == "string" && d3.indexOf(e[0]) === -1);
      case ze.ACK:
      case ze.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class m3 {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = f3(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const y3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Decoder: Id, Encoder: g3, get PacketType() {
  return ze;
}, protocol: p3 }, Symbol.toStringTag, { value: "Module" }));
function fr(n, t, e) {
  return n.on(t, e), function() {
    n.off(t, e);
  };
}
const b3 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class tm extends Tn {
  /**
   * `Socket` constructor.
   */
  constructor(t, e, i) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      fr(t, "open", this.onopen.bind(this)),
      fr(t, "packet", this.onpacket.bind(this)),
      fr(t, "error", this.onerror.bind(this)),
      fr(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...e) {
    var i, r, s;
    if (b3.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(e), this;
    const o = {
      type: ze.EVENT,
      data: e
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const u = this.ids++, d = e.pop();
      this._registerAckCallback(u, d), o.id = u;
    }
    const a = (r = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || r === void 0 ? void 0 : r.writable, l = this.connected && !(!((s = this.io.engine) === null || s === void 0) && s._hasPingExpired());
    return this.flags.volatile && !a || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, e) {
    var i;
    const r = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (r === void 0) {
      this.acks[t] = e;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let a = 0; a < this.sendBuffer.length; a++)
        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);
      e.call(this, new Error("operation has timed out"));
    }, r), o = (...a) => {
      this.io.clearTimeoutFn(s), e.apply(this, a);
    };
    o.withError = !0, this.acks[t] = o;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...e) {
    return new Promise((i, r) => {
      const s = (o, a) => o ? r(o) : i(a);
      s.withError = !0, e.push(s), this.emit(t, ...e);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let e;
    typeof t[t.length - 1] == "function" && (e = t.pop());
    const i = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((r, ...s) => i !== this._queue[0] ? void 0 : (r !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), e && e(r)) : (this._queue.shift(), e && e(null, ...s)), i.pending = !1, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const e = this._queue[0];
    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: ze.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((t) => {
      if (!this.sendBuffer.some((i) => String(i.id) === t)) {
        const i = this.acks[t];
        delete this.acks[t], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case ze.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case ze.EVENT:
        case ze.BINARY_EVENT:
          this.onevent(t);
          break;
        case ze.ACK:
        case ze.BINARY_ACK:
          this.onack(t);
          break;
        case ze.DISCONNECT:
          this.ondisconnect();
          break;
        case ze.CONNECT_ERROR:
          this.destroy();
          const i = new Error(t.data.message);
          i.data = t.data.data, this.emitReserved("connect_error", i);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const i of e)
        i.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const e = this;
    let i = !1;
    return function(...r) {
      i || (i = !0, e.packet({
        type: ze.ACK,
        id: t,
        data: r
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (delete this.acks[t.id], e.withError && t.data.unshift(null), e.apply(this, t.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, e) {
    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: ze.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let i = 0; i < e.length; i++)
        if (t === e[i])
          return e.splice(i, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const i of e)
        i.apply(this, t.data);
    }
  }
}
function Pa(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
Pa.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * n);
    n = Math.floor(t * 10) & 1 ? n + e : n - e;
  }
  return Math.min(n, this.max) | 0;
};
Pa.prototype.reset = function() {
  this.attempts = 0;
};
Pa.prototype.setMin = function(n) {
  this.ms = n;
};
Pa.prototype.setMax = function(n) {
  this.max = n;
};
Pa.prototype.setJitter = function(n) {
  this.jitter = n;
};
class kf extends Tn {
  constructor(t, e) {
    var i;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, qc(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((i = e.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Pa({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const r = e.parser || y3;
    this.encoder = new r.Encoder(), this.decoder = new r.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, t || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new s3(this.uri, this.opts);
    const e = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const r = fr(e, "open", function() {
      i.onopen(), t && t();
    }), s = (a) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a), t ? t(a) : this.maybeReconnectOnOpen();
    }, o = fr(e, "error", s);
    if (this._timeout !== !1) {
      const a = this._timeout, l = this.setTimeoutFn(() => {
        r(), s(new Error("timeout")), e.close();
      }, a);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(r), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(
      fr(t, "ping", this.onping.bind(this)),
      fr(t, "data", this.ondata.bind(this)),
      fr(t, "error", this.onerror.bind(this)),
      fr(t, "close", this.onclose.bind(this)),
      // @ts-ignore
      fr(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    jc(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, e) {
    let i = this.nsps[t];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new tm(this, t, e), this.nsps[t] = i), i;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const i of e)
      if (this.nsps[i].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let i = 0; i < e.length; i++)
      this.engine.write(e[i], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(t, e) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const i = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((r) => {
          r ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", r)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const dl = {};
function Vu(n, t) {
  typeof n == "object" && (t = n, n = void 0), t = t || {};
  const e = o3(n, t.path || "/socket.io"), i = e.source, r = e.id, s = e.path, o = dl[r] && s in dl[r].nsps, a = t.forceNew || t["force new connection"] || t.multiplex === !1 || o;
  let l;
  return a ? l = new kf(i, t) : (dl[r] || (dl[r] = new kf(i, t)), l = dl[r]), e.query && !t.query && (t.query = e.queryKey), l.socket(e.path, t);
}
Object.assign(Vu, {
  Manager: kf,
  Socket: tm,
  io: Vu,
  connect: Vu
});
var v3 = typeof global == "object" && global && global.Object === Object && global, w3 = typeof self == "object" && self && self.Object === Object && self, Ed = v3 || w3 || Function("return this")(), Sa = Ed.Symbol, em = Object.prototype, x3 = em.hasOwnProperty, _3 = em.toString, pl = Sa ? Sa.toStringTag : void 0;
function S3(n) {
  var t = x3.call(n, pl), e = n[pl];
  try {
    n[pl] = void 0;
    var i = !0;
  } catch {
  }
  var r = _3.call(n);
  return i && (t ? n[pl] = e : delete n[pl]), r;
}
var k3 = Object.prototype, A3 = k3.toString;
function N3(n) {
  return A3.call(n);
}
var C3 = "[object Null]", P3 = "[object Undefined]", vg = Sa ? Sa.toStringTag : void 0;
function nm(n) {
  return n == null ? n === void 0 ? P3 : C3 : vg && vg in Object(n) ? S3(n) : N3(n);
}
function L3(n) {
  return n != null && typeof n == "object";
}
var I3 = "[object Symbol]";
function Od(n) {
  return typeof n == "symbol" || L3(n) && nm(n) == I3;
}
function E3(n, t) {
  for (var e = -1, i = n == null ? 0 : n.length, r = Array(i); ++e < i; )
    r[e] = t(n[e], e, n);
  return r;
}
var Td = Array.isArray, O3 = 1 / 0, wg = Sa ? Sa.prototype : void 0, xg = wg ? wg.toString : void 0;
function im(n) {
  if (typeof n == "string")
    return n;
  if (Td(n))
    return E3(n, im) + "";
  if (Od(n))
    return xg ? xg.call(n) : "";
  var t = n + "";
  return t == "0" && 1 / n == -O3 ? "-0" : t;
}
function cc(n) {
  var t = typeof n;
  return n != null && (t == "object" || t == "function");
}
var T3 = "[object AsyncFunction]", F3 = "[object Function]", M3 = "[object GeneratorFunction]", R3 = "[object Proxy]";
function D3(n) {
  if (!cc(n))
    return !1;
  var t = nm(n);
  return t == F3 || t == M3 || t == T3 || t == R3;
}
var Rh = Ed["__core-js_shared__"], _g = function() {
  var n = /[^.]+$/.exec(Rh && Rh.keys && Rh.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function B3(n) {
  return !!_g && _g in n;
}
var j3 = Function.prototype, q3 = j3.toString;
function z3(n) {
  if (n != null) {
    try {
      return q3.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var $3 = /[\\^$.*+?()[\]{}|]/g, U3 = /^\[object .+?Constructor\]$/, W3 = Function.prototype, H3 = Object.prototype, G3 = W3.toString, V3 = H3.hasOwnProperty, Y3 = RegExp(
  "^" + G3.call(V3).replace($3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function K3(n) {
  if (!cc(n) || B3(n))
    return !1;
  var t = D3(n) ? Y3 : U3;
  return t.test(z3(n));
}
function X3(n, t) {
  return n == null ? void 0 : n[t];
}
function Fd(n, t) {
  var e = X3(n, t);
  return K3(e) ? e : void 0;
}
var Sg = function() {
  try {
    var n = Fd(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), J3 = 9007199254740991, Z3 = /^(?:0|[1-9]\d*)$/;
function Q3(n, t) {
  var e = typeof n;
  return t = t ?? J3, !!t && (e == "number" || e != "symbol" && Z3.test(n)) && n > -1 && n % 1 == 0 && n < t;
}
function tx(n, t, e) {
  t == "__proto__" && Sg ? Sg(n, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : n[t] = e;
}
function rm(n, t) {
  return n === t || n !== n && t !== t;
}
var ex = Object.prototype, nx = ex.hasOwnProperty;
function ix(n, t, e) {
  var i = n[t];
  (!(nx.call(n, t) && rm(i, e)) || e === void 0 && !(t in n)) && tx(n, t, e);
}
var rx = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, sx = /^\w*$/;
function ox(n, t) {
  if (Td(n))
    return !1;
  var e = typeof n;
  return e == "number" || e == "symbol" || e == "boolean" || n == null || Od(n) ? !0 : sx.test(n) || !rx.test(n) || t != null && n in Object(t);
}
var El = Fd(Object, "create");
function ax() {
  this.__data__ = El ? El(null) : {}, this.size = 0;
}
function lx(n) {
  var t = this.has(n) && delete this.__data__[n];
  return this.size -= t ? 1 : 0, t;
}
var ux = "__lodash_hash_undefined__", cx = Object.prototype, hx = cx.hasOwnProperty;
function fx(n) {
  var t = this.__data__;
  if (El) {
    var e = t[n];
    return e === ux ? void 0 : e;
  }
  return hx.call(t, n) ? t[n] : void 0;
}
var dx = Object.prototype, px = dx.hasOwnProperty;
function gx(n) {
  var t = this.__data__;
  return El ? t[n] !== void 0 : px.call(t, n);
}
var mx = "__lodash_hash_undefined__";
function yx(n, t) {
  var e = this.__data__;
  return this.size += this.has(n) ? 0 : 1, e[n] = El && t === void 0 ? mx : t, this;
}
function Co(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Co.prototype.clear = ax;
Co.prototype.delete = lx;
Co.prototype.get = fx;
Co.prototype.has = gx;
Co.prototype.set = yx;
function bx() {
  this.__data__ = [], this.size = 0;
}
function zc(n, t) {
  for (var e = n.length; e--; )
    if (rm(n[e][0], t))
      return e;
  return -1;
}
var vx = Array.prototype, wx = vx.splice;
function xx(n) {
  var t = this.__data__, e = zc(t, n);
  if (e < 0)
    return !1;
  var i = t.length - 1;
  return e == i ? t.pop() : wx.call(t, e, 1), --this.size, !0;
}
function _x(n) {
  var t = this.__data__, e = zc(t, n);
  return e < 0 ? void 0 : t[e][1];
}
function Sx(n) {
  return zc(this.__data__, n) > -1;
}
function kx(n, t) {
  var e = this.__data__, i = zc(e, n);
  return i < 0 ? (++this.size, e.push([n, t])) : e[i][1] = t, this;
}
function La(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
La.prototype.clear = bx;
La.prototype.delete = xx;
La.prototype.get = _x;
La.prototype.has = Sx;
La.prototype.set = kx;
var Ax = Fd(Ed, "Map");
function Nx() {
  this.size = 0, this.__data__ = {
    hash: new Co(),
    map: new (Ax || La)(),
    string: new Co()
  };
}
function Cx(n) {
  var t = typeof n;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? n !== "__proto__" : n === null;
}
function $c(n, t) {
  var e = n.__data__;
  return Cx(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function Px(n) {
  var t = $c(this, n).delete(n);
  return this.size -= t ? 1 : 0, t;
}
function Lx(n) {
  return $c(this, n).get(n);
}
function Ix(n) {
  return $c(this, n).has(n);
}
function Ex(n, t) {
  var e = $c(this, n), i = e.size;
  return e.set(n, t), this.size += e.size == i ? 0 : 1, this;
}
function Io(n) {
  var t = -1, e = n == null ? 0 : n.length;
  for (this.clear(); ++t < e; ) {
    var i = n[t];
    this.set(i[0], i[1]);
  }
}
Io.prototype.clear = Nx;
Io.prototype.delete = Px;
Io.prototype.get = Lx;
Io.prototype.has = Ix;
Io.prototype.set = Ex;
var Ox = "Expected a function";
function Md(n, t) {
  if (typeof n != "function" || t != null && typeof t != "function")
    throw new TypeError(Ox);
  var e = function() {
    var i = arguments, r = t ? t.apply(this, i) : i[0], s = e.cache;
    if (s.has(r))
      return s.get(r);
    var o = n.apply(this, i);
    return e.cache = s.set(r, o) || s, o;
  };
  return e.cache = new (Md.Cache || Io)(), e;
}
Md.Cache = Io;
var Tx = 500;
function Fx(n) {
  var t = Md(n, function(i) {
    return e.size === Tx && e.clear(), i;
  }), e = t.cache;
  return t;
}
var Mx = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Rx = /\\(\\)?/g, Dx = Fx(function(n) {
  var t = [];
  return n.charCodeAt(0) === 46 && t.push(""), n.replace(Mx, function(e, i, r, s) {
    t.push(r ? s.replace(Rx, "$1") : i || e);
  }), t;
});
function Bx(n) {
  return n == null ? "" : im(n);
}
function sm(n, t) {
  return Td(n) ? n : ox(n, t) ? [n] : Dx(Bx(n));
}
var jx = 1 / 0;
function om(n) {
  if (typeof n == "string" || Od(n))
    return n;
  var t = n + "";
  return t == "0" && 1 / n == -jx ? "-0" : t;
}
function qx(n, t) {
  t = sm(t, n);
  for (var e = 0, i = t.length; n != null && e < i; )
    n = n[om(t[e++])];
  return e && e == i ? n : void 0;
}
function wo(n, t, e) {
  var i = n == null ? void 0 : qx(n, t);
  return i === void 0 ? e : i;
}
function zx(n, t, e, i) {
  if (!cc(n))
    return n;
  t = sm(t, n);
  for (var r = -1, s = t.length, o = s - 1, a = n; a != null && ++r < s; ) {
    var l = om(t[r]), h = e;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return n;
    if (r != o) {
      var u = a[l];
      h = void 0, h === void 0 && (h = cc(u) ? u : Q3(t[r + 1]) ? [] : {});
    }
    ix(a, l, h), a = a[l];
  }
  return n;
}
function kg(n, t, e) {
  return n == null ? n : zx(n, t, e);
}
var Af = "http://www.w3.org/1999/xhtml";
const Ag = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Af,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function am(n) {
  var t = n += "", e = t.indexOf(":");
  return e >= 0 && (t = n.slice(0, e)) !== "xmlns" && (n = n.slice(e + 1)), Ag.hasOwnProperty(t) ? { space: Ag[t], local: n } : n;
}
function $x(n) {
  return function() {
    var t = this.ownerDocument, e = this.namespaceURI;
    return e === Af && t.documentElement.namespaceURI === Af ? t.createElement(n) : t.createElementNS(e, n);
  };
}
function Ux(n) {
  return function() {
    return this.ownerDocument.createElementNS(n.space, n.local);
  };
}
function lm(n) {
  var t = am(n);
  return (t.local ? Ux : $x)(t);
}
function Wx() {
}
function um(n) {
  return n == null ? Wx : function() {
    return this.querySelector(n);
  };
}
function Hx(n) {
  typeof n != "function" && (n = um(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = new Array(o), l, h, u = 0; u < o; ++u)
      (l = s[u]) && (h = n.call(l, l.__data__, u, s)) && ("__data__" in l && (h.__data__ = l.__data__), a[u] = h);
  return new _i(i, this._parents);
}
function cm(n) {
  return n == null ? [] : Array.isArray(n) ? n : Array.from(n);
}
function Gx() {
  return [];
}
function Vx(n) {
  return n == null ? Gx : function() {
    return this.querySelectorAll(n);
  };
}
function Yx(n) {
  return function() {
    return cm(n.apply(this, arguments));
  };
}
function Kx(n) {
  typeof n == "function" ? n = Yx(n) : n = Vx(n);
  for (var t = this._groups, e = t.length, i = [], r = [], s = 0; s < e; ++s)
    for (var o = t[s], a = o.length, l, h = 0; h < a; ++h)
      (l = o[h]) && (i.push(n.call(l, l.__data__, h, o)), r.push(l));
  return new _i(i, r);
}
function Xx(n) {
  return function() {
    return this.matches(n);
  };
}
function hm(n) {
  return function(t) {
    return t.matches(n);
  };
}
var Jx = Array.prototype.find;
function Zx(n) {
  return function() {
    return Jx.call(this.children, n);
  };
}
function Qx() {
  return this.firstElementChild;
}
function t4(n) {
  return this.select(n == null ? Qx : Zx(typeof n == "function" ? n : hm(n)));
}
var e4 = Array.prototype.filter;
function n4() {
  return Array.from(this.children);
}
function i4(n) {
  return function() {
    return e4.call(this.children, n);
  };
}
function r4(n) {
  return this.selectAll(n == null ? n4 : i4(typeof n == "function" ? n : hm(n)));
}
function s4(n) {
  typeof n != "function" && (n = Xx(n));
  for (var t = this._groups, e = t.length, i = new Array(e), r = 0; r < e; ++r)
    for (var s = t[r], o = s.length, a = i[r] = [], l, h = 0; h < o; ++h)
      (l = s[h]) && n.call(l, l.__data__, h, s) && a.push(l);
  return new _i(i, this._parents);
}
function fm(n) {
  return new Array(n.length);
}
function o4() {
  return new _i(this._enter || this._groups.map(fm), this._parents);
}
function hc(n, t) {
  this.ownerDocument = n.ownerDocument, this.namespaceURI = n.namespaceURI, this._next = null, this._parent = n, this.__data__ = t;
}
hc.prototype = {
  constructor: hc,
  appendChild: function(n) {
    return this._parent.insertBefore(n, this._next);
  },
  insertBefore: function(n, t) {
    return this._parent.insertBefore(n, t);
  },
  querySelector: function(n) {
    return this._parent.querySelector(n);
  },
  querySelectorAll: function(n) {
    return this._parent.querySelectorAll(n);
  }
};
function a4(n) {
  return function() {
    return n;
  };
}
function l4(n, t, e, i, r, s) {
  for (var o = 0, a, l = t.length, h = s.length; o < h; ++o)
    (a = t[o]) ? (a.__data__ = s[o], i[o] = a) : e[o] = new hc(n, s[o]);
  for (; o < l; ++o)
    (a = t[o]) && (r[o] = a);
}
function u4(n, t, e, i, r, s, o) {
  var a, l, h = /* @__PURE__ */ new Map(), u = t.length, d = s.length, p = new Array(u), f;
  for (a = 0; a < u; ++a)
    (l = t[a]) && (p[a] = f = o.call(l, l.__data__, a, t) + "", h.has(f) ? r[a] = l : h.set(f, l));
  for (a = 0; a < d; ++a)
    f = o.call(n, s[a], a, s) + "", (l = h.get(f)) ? (i[a] = l, l.__data__ = s[a], h.delete(f)) : e[a] = new hc(n, s[a]);
  for (a = 0; a < u; ++a)
    (l = t[a]) && h.get(p[a]) === l && (r[a] = l);
}
function c4(n) {
  return n.__data__;
}
function h4(n, t) {
  if (!arguments.length) return Array.from(this, c4);
  var e = t ? u4 : l4, i = this._parents, r = this._groups;
  typeof n != "function" && (n = a4(n));
  for (var s = r.length, o = new Array(s), a = new Array(s), l = new Array(s), h = 0; h < s; ++h) {
    var u = i[h], d = r[h], p = d.length, f = f4(n.call(u, u && u.__data__, h, i)), g = f.length, y = a[h] = new Array(g), _ = o[h] = new Array(g), b = l[h] = new Array(p);
    e(u, d, y, _, b, f, t);
    for (var v = 0, A = 0, L, O; v < g; ++v)
      if (L = y[v]) {
        for (v >= A && (A = v + 1); !(O = _[A]) && ++A < g; ) ;
        L._next = O || null;
      }
  }
  return o = new _i(o, i), o._enter = a, o._exit = l, o;
}
function f4(n) {
  return typeof n == "object" && "length" in n ? n : Array.from(n);
}
function d4() {
  return new _i(this._exit || this._groups.map(fm), this._parents);
}
function p4(n, t, e) {
  var i = this.enter(), r = this, s = this.exit();
  return typeof n == "function" ? (i = n(i), i && (i = i.selection())) : i = i.append(n + ""), t != null && (r = t(r), r && (r = r.selection())), e == null ? s.remove() : e(s), i && r ? i.merge(r).order() : r;
}
function g4(n) {
  for (var t = n.selection ? n.selection() : n, e = this._groups, i = t._groups, r = e.length, s = i.length, o = Math.min(r, s), a = new Array(r), l = 0; l < o; ++l)
    for (var h = e[l], u = i[l], d = h.length, p = a[l] = new Array(d), f, g = 0; g < d; ++g)
      (f = h[g] || u[g]) && (p[g] = f);
  for (; l < r; ++l)
    a[l] = e[l];
  return new _i(a, this._parents);
}
function m4() {
  for (var n = this._groups, t = -1, e = n.length; ++t < e; )
    for (var i = n[t], r = i.length - 1, s = i[r], o; --r >= 0; )
      (o = i[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function y4(n) {
  n || (n = b4);
  function t(d, p) {
    return d && p ? n(d.__data__, p.__data__) : !d - !p;
  }
  for (var e = this._groups, i = e.length, r = new Array(i), s = 0; s < i; ++s) {
    for (var o = e[s], a = o.length, l = r[s] = new Array(a), h, u = 0; u < a; ++u)
      (h = o[u]) && (l[u] = h);
    l.sort(t);
  }
  return new _i(r, this._parents).order();
}
function b4(n, t) {
  return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function v4() {
  var n = arguments[0];
  return arguments[0] = this, n.apply(null, arguments), this;
}
function w4() {
  return Array.from(this);
}
function x4() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length; r < s; ++r) {
      var o = i[r];
      if (o) return o;
    }
  return null;
}
function _4() {
  let n = 0;
  for (const t of this) ++n;
  return n;
}
function S4() {
  return !this.node();
}
function k4(n) {
  for (var t = this._groups, e = 0, i = t.length; e < i; ++e)
    for (var r = t[e], s = 0, o = r.length, a; s < o; ++s)
      (a = r[s]) && n.call(a, a.__data__, s, r);
  return this;
}
function A4(n) {
  return function() {
    this.removeAttribute(n);
  };
}
function N4(n) {
  return function() {
    this.removeAttributeNS(n.space, n.local);
  };
}
function C4(n, t) {
  return function() {
    this.setAttribute(n, t);
  };
}
function P4(n, t) {
  return function() {
    this.setAttributeNS(n.space, n.local, t);
  };
}
function L4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttribute(n) : this.setAttribute(n, e);
  };
}
function I4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e);
  };
}
function E4(n, t) {
  var e = am(n);
  if (arguments.length < 2) {
    var i = this.node();
    return e.local ? i.getAttributeNS(e.space, e.local) : i.getAttribute(e);
  }
  return this.each((t == null ? e.local ? N4 : A4 : typeof t == "function" ? e.local ? I4 : L4 : e.local ? P4 : C4)(e, t));
}
function dm(n) {
  return n.ownerDocument && n.ownerDocument.defaultView || n.document && n || n.defaultView;
}
function O4(n) {
  return function() {
    this.style.removeProperty(n);
  };
}
function T4(n, t, e) {
  return function() {
    this.style.setProperty(n, t, e);
  };
}
function F4(n, t, e) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.style.removeProperty(n) : this.style.setProperty(n, i, e);
  };
}
function M4(n, t, e) {
  return arguments.length > 1 ? this.each((t == null ? O4 : typeof t == "function" ? F4 : T4)(n, t, e ?? "")) : R4(this.node(), n);
}
function R4(n, t) {
  return n.style.getPropertyValue(t) || dm(n).getComputedStyle(n, null).getPropertyValue(t);
}
function D4(n) {
  return function() {
    delete this[n];
  };
}
function B4(n, t) {
  return function() {
    this[n] = t;
  };
}
function j4(n, t) {
  return function() {
    var e = t.apply(this, arguments);
    e == null ? delete this[n] : this[n] = e;
  };
}
function q4(n, t) {
  return arguments.length > 1 ? this.each((t == null ? D4 : typeof t == "function" ? j4 : B4)(n, t)) : this.node()[n];
}
function pm(n) {
  return n.trim().split(/^|\s+/);
}
function Rd(n) {
  return n.classList || new gm(n);
}
function gm(n) {
  this._node = n, this._names = pm(n.getAttribute("class") || "");
}
gm.prototype = {
  add: function(n) {
    var t = this._names.indexOf(n);
    t < 0 && (this._names.push(n), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(n) {
    var t = this._names.indexOf(n);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(n) {
    return this._names.indexOf(n) >= 0;
  }
};
function mm(n, t) {
  for (var e = Rd(n), i = -1, r = t.length; ++i < r; ) e.add(t[i]);
}
function ym(n, t) {
  for (var e = Rd(n), i = -1, r = t.length; ++i < r; ) e.remove(t[i]);
}
function z4(n) {
  return function() {
    mm(this, n);
  };
}
function $4(n) {
  return function() {
    ym(this, n);
  };
}
function U4(n, t) {
  return function() {
    (t.apply(this, arguments) ? mm : ym)(this, n);
  };
}
function W4(n, t) {
  var e = pm(n + "");
  if (arguments.length < 2) {
    for (var i = Rd(this.node()), r = -1, s = e.length; ++r < s; ) if (!i.contains(e[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? U4 : t ? z4 : $4)(e, t));
}
function H4() {
  this.textContent = "";
}
function G4(n) {
  return function() {
    this.textContent = n;
  };
}
function V4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Y4(n) {
  return arguments.length ? this.each(n == null ? H4 : (typeof n == "function" ? V4 : G4)(n)) : this.node().textContent;
}
function K4() {
  this.innerHTML = "";
}
function X4(n) {
  return function() {
    this.innerHTML = n;
  };
}
function J4(n) {
  return function() {
    var t = n.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Z4(n) {
  return arguments.length ? this.each(n == null ? K4 : (typeof n == "function" ? J4 : X4)(n)) : this.node().innerHTML;
}
function Q4() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function t_() {
  return this.each(Q4);
}
function e_() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function n_() {
  return this.each(e_);
}
function i_(n) {
  var t = typeof n == "function" ? n : lm(n);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function r_() {
  return null;
}
function s_(n, t) {
  var e = typeof n == "function" ? n : lm(n), i = t == null ? r_ : typeof t == "function" ? t : um(t);
  return this.select(function() {
    return this.insertBefore(e.apply(this, arguments), i.apply(this, arguments) || null);
  });
}
function o_() {
  var n = this.parentNode;
  n && n.removeChild(this);
}
function a_() {
  return this.each(o_);
}
function l_() {
  var n = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function u_() {
  var n = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(n, this.nextSibling) : n;
}
function c_(n) {
  return this.select(n ? u_ : l_);
}
function h_(n) {
  return arguments.length ? this.property("__data__", n) : this.node().__data__;
}
function f_(n) {
  return function(t) {
    n.call(this, t, this.__data__);
  };
}
function d_(n) {
  return n.trim().split(/^|\s+/).map(function(t) {
    var e = "", i = t.indexOf(".");
    return i >= 0 && (e = t.slice(i + 1), t = t.slice(0, i)), { type: t, name: e };
  });
}
function p_(n) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var e = 0, i = -1, r = t.length, s; e < r; ++e)
        s = t[e], (!n.type || s.type === n.type) && s.name === n.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++i] = s;
      ++i ? t.length = i : delete this.__on;
    }
  };
}
function g_(n, t, e) {
  return function() {
    var i = this.__on, r, s = f_(t);
    if (i) {
      for (var o = 0, a = i.length; o < a; ++o)
        if ((r = i[o]).type === n.type && r.name === n.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = e), r.value = t;
          return;
        }
    }
    this.addEventListener(n.type, s, e), r = { type: n.type, name: n.name, value: t, listener: s, options: e }, i ? i.push(r) : this.__on = [r];
  };
}
function m_(n, t, e) {
  var i = d_(n + ""), r, s = i.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, h = a.length, u; l < h; ++l)
        for (r = 0, u = a[l]; r < s; ++r)
          if ((o = i[r]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (a = t ? g_ : p_, r = 0; r < s; ++r) this.each(a(i[r], t, e));
  return this;
}
function bm(n, t, e) {
  var i = dm(n), r = i.CustomEvent;
  typeof r == "function" ? r = new r(t, e) : (r = i.document.createEvent("Event"), e ? (r.initEvent(t, e.bubbles, e.cancelable), r.detail = e.detail) : r.initEvent(t, !1, !1)), n.dispatchEvent(r);
}
function y_(n, t) {
  return function() {
    return bm(this, n, t);
  };
}
function b_(n, t) {
  return function() {
    return bm(this, n, t.apply(this, arguments));
  };
}
function v_(n, t) {
  return this.each((typeof t == "function" ? b_ : y_)(n, t));
}
function* w_() {
  for (var n = this._groups, t = 0, e = n.length; t < e; ++t)
    for (var i = n[t], r = 0, s = i.length, o; r < s; ++r)
      (o = i[r]) && (yield o);
}
var vm = [null];
function _i(n, t) {
  this._groups = n, this._parents = t;
}
function x_() {
  return this;
}
_i.prototype = {
  constructor: _i,
  select: Hx,
  selectAll: Kx,
  selectChild: t4,
  selectChildren: r4,
  filter: s4,
  data: h4,
  enter: o4,
  exit: d4,
  join: p4,
  merge: g4,
  selection: x_,
  order: m4,
  sort: y4,
  call: v4,
  nodes: w4,
  node: x4,
  size: _4,
  empty: S4,
  each: k4,
  attr: E4,
  style: M4,
  property: q4,
  classed: W4,
  text: Y4,
  html: Z4,
  raise: t_,
  lower: n_,
  append: i_,
  insert: s_,
  remove: a_,
  clone: c_,
  datum: h_,
  on: m_,
  dispatch: v_,
  [Symbol.iterator]: w_
};
function __(n) {
  return typeof n == "string" ? new _i([[document.querySelector(n)]], [document.documentElement]) : new _i([[n]], vm);
}
function S_(n) {
  return typeof n == "string" ? new _i([document.querySelectorAll(n)], [document.documentElement]) : new _i([cm(n)], vm);
}
function Yu(n, t) {
  return n == null || t == null ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function k_(n, t) {
  return n == null || t == null ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
}
function wm(n) {
  let t, e, i;
  n.length !== 2 ? (t = Yu, e = (a, l) => Yu(n(a), l), i = (a, l) => n(a) - l) : (t = n === Yu || n === k_ ? n : A_, e = n, i = n);
  function r(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) < 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function s(a, l, h = 0, u = a.length) {
    if (h < u) {
      if (t(l, l) !== 0) return u;
      do {
        const d = h + u >>> 1;
        e(a[d], l) <= 0 ? h = d + 1 : u = d;
      } while (h < u);
    }
    return h;
  }
  function o(a, l, h = 0, u = a.length) {
    const d = r(a, l, h, u - 1);
    return d > h && i(a[d - 1], l) > -i(a[d], l) ? d - 1 : d;
  }
  return { left: r, center: o, right: s };
}
function A_() {
  return 0;
}
function N_(n) {
  return n === null ? NaN : +n;
}
const C_ = wm(Yu), P_ = C_.right;
wm(N_).center;
const L_ = Math.sqrt(50), I_ = Math.sqrt(10), E_ = Math.sqrt(2);
function fc(n, t, e) {
  const i = (t - n) / Math.max(0, e), r = Math.floor(Math.log10(i)), s = i / Math.pow(10, r), o = s >= L_ ? 10 : s >= I_ ? 5 : s >= E_ ? 2 : 1;
  let a, l, h;
  return r < 0 ? (h = Math.pow(10, -r) / o, a = Math.round(n * h), l = Math.round(t * h), a / h < n && ++a, l / h > t && --l, h = -h) : (h = Math.pow(10, r) * o, a = Math.round(n / h), l = Math.round(t / h), a * h < n && ++a, l * h > t && --l), l < a && 0.5 <= e && e < 2 ? fc(n, t, e * 2) : [a, l, h];
}
function O_(n, t, e) {
  if (t = +t, n = +n, e = +e, !(e > 0)) return [];
  if (n === t) return [n];
  const i = t < n, [r, s, o] = i ? fc(t, n, e) : fc(n, t, e);
  if (!(s >= r)) return [];
  const a = s - r + 1, l = new Array(a);
  if (i)
    if (o < 0) for (let h = 0; h < a; ++h) l[h] = (s - h) / -o;
    else for (let h = 0; h < a; ++h) l[h] = (s - h) * o;
  else if (o < 0) for (let h = 0; h < a; ++h) l[h] = (r + h) / -o;
  else for (let h = 0; h < a; ++h) l[h] = (r + h) * o;
  return l;
}
function Nf(n, t, e) {
  return t = +t, n = +n, e = +e, fc(n, t, e)[2];
}
function T_(n, t, e) {
  t = +t, n = +n, e = +e;
  const i = t < n, r = i ? Nf(t, n, e) : Nf(n, t, e);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function F_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(n);
      break;
    default:
      this.range(t).domain(n);
      break;
  }
  return this;
}
function M_(n, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof n == "function" ? this.interpolator(n) : this.range(n);
      break;
    }
    default: {
      this.domain(n), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
function Dd(n, t, e) {
  n.prototype = t.prototype = e, e.constructor = n;
}
function xm(n, t) {
  var e = Object.create(n.prototype);
  for (var i in t) e[i] = t[i];
  return e;
}
function Wl() {
}
var Ol = 0.7, dc = 1 / Ol, wa = "\\s*([+-]?\\d+)\\s*", Tl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Fr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", R_ = /^#([0-9a-f]{3,8})$/, D_ = new RegExp(`^rgb\\(${wa},${wa},${wa}\\)$`), B_ = new RegExp(`^rgb\\(${Fr},${Fr},${Fr}\\)$`), j_ = new RegExp(`^rgba\\(${wa},${wa},${wa},${Tl}\\)$`), q_ = new RegExp(`^rgba\\(${Fr},${Fr},${Fr},${Tl}\\)$`), z_ = new RegExp(`^hsl\\(${Tl},${Fr},${Fr}\\)$`), $_ = new RegExp(`^hsla\\(${Tl},${Fr},${Fr},${Tl}\\)$`), Ng = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Dd(Wl, ka, {
  copy(n) {
    return Object.assign(new this.constructor(), this, n);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Cg,
  // Deprecated! Use color.formatHex.
  formatHex: Cg,
  formatHex8: U_,
  formatHsl: W_,
  formatRgb: Pg,
  toString: Pg
});
function Cg() {
  return this.rgb().formatHex();
}
function U_() {
  return this.rgb().formatHex8();
}
function W_() {
  return _m(this).formatHsl();
}
function Pg() {
  return this.rgb().formatRgb();
}
function ka(n) {
  var t, e;
  return n = (n + "").trim().toLowerCase(), (t = R_.exec(n)) ? (e = t[1].length, t = parseInt(t[1], 16), e === 6 ? Lg(t) : e === 3 ? new xi(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : e === 8 ? Ru(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : e === 4 ? Ru(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = D_.exec(n)) ? new xi(t[1], t[2], t[3], 1) : (t = B_.exec(n)) ? new xi(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = j_.exec(n)) ? Ru(t[1], t[2], t[3], t[4]) : (t = q_.exec(n)) ? Ru(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = z_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, 1) : (t = $_.exec(n)) ? Og(t[1], t[2] / 100, t[3] / 100, t[4]) : Ng.hasOwnProperty(n) ? Lg(Ng[n]) : n === "transparent" ? new xi(NaN, NaN, NaN, 0) : null;
}
function Lg(n) {
  return new xi(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function Ru(n, t, e, i) {
  return i <= 0 && (n = t = e = NaN), new xi(n, t, e, i);
}
function H_(n) {
  return n instanceof Wl || (n = ka(n)), n ? (n = n.rgb(), new xi(n.r, n.g, n.b, n.opacity)) : new xi();
}
function An(n, t, e, i) {
  return arguments.length === 1 ? H_(n) : new xi(n, t, e, i ?? 1);
}
function xi(n, t, e, i) {
  this.r = +n, this.g = +t, this.b = +e, this.opacity = +i;
}
Dd(xi, An, xm(Wl, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new xi(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? Ol : Math.pow(Ol, n), new xi(this.r * n, this.g * n, this.b * n, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new xi(xo(this.r), xo(this.g), xo(this.b), pc(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ig,
  // Deprecated! Use color.formatHex.
  formatHex: Ig,
  formatHex8: G_,
  formatRgb: Eg,
  toString: Eg
}));
function Ig() {
  return `#${fo(this.r)}${fo(this.g)}${fo(this.b)}`;
}
function G_() {
  return `#${fo(this.r)}${fo(this.g)}${fo(this.b)}${fo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Eg() {
  const n = pc(this.opacity);
  return `${n === 1 ? "rgb(" : "rgba("}${xo(this.r)}, ${xo(this.g)}, ${xo(this.b)}${n === 1 ? ")" : `, ${n})`}`;
}
function pc(n) {
  return isNaN(n) ? 1 : Math.max(0, Math.min(1, n));
}
function xo(n) {
  return Math.max(0, Math.min(255, Math.round(n) || 0));
}
function fo(n) {
  return n = xo(n), (n < 16 ? "0" : "") + n.toString(16);
}
function Og(n, t, e, i) {
  return i <= 0 ? n = t = e = NaN : e <= 0 || e >= 1 ? n = t = NaN : t <= 0 && (n = NaN), new gr(n, t, e, i);
}
function _m(n) {
  if (n instanceof gr) return new gr(n.h, n.s, n.l, n.opacity);
  if (n instanceof Wl || (n = ka(n)), !n) return new gr();
  if (n instanceof gr) return n;
  n = n.rgb();
  var t = n.r / 255, e = n.g / 255, i = n.b / 255, r = Math.min(t, e, i), s = Math.max(t, e, i), o = NaN, a = s - r, l = (s + r) / 2;
  return a ? (t === s ? o = (e - i) / a + (e < i) * 6 : e === s ? o = (i - t) / a + 2 : o = (t - e) / a + 4, a /= l < 0.5 ? s + r : 2 - s - r, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new gr(o, a, l, n.opacity);
}
function V_(n, t, e, i) {
  return arguments.length === 1 ? _m(n) : new gr(n, t, e, i ?? 1);
}
function gr(n, t, e, i) {
  this.h = +n, this.s = +t, this.l = +e, this.opacity = +i;
}
Dd(gr, V_, xm(Wl, {
  brighter(n) {
    return n = n == null ? dc : Math.pow(dc, n), new gr(this.h, this.s, this.l * n, this.opacity);
  },
  darker(n) {
    return n = n == null ? Ol : Math.pow(Ol, n), new gr(this.h, this.s, this.l * n, this.opacity);
  },
  rgb() {
    var n = this.h % 360 + (this.h < 0) * 360, t = isNaN(n) || isNaN(this.s) ? 0 : this.s, e = this.l, i = e + (e < 0.5 ? e : 1 - e) * t, r = 2 * e - i;
    return new xi(
      Dh(n >= 240 ? n - 240 : n + 120, r, i),
      Dh(n, r, i),
      Dh(n < 120 ? n + 240 : n - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new gr(Tg(this.h), Du(this.s), Du(this.l), pc(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const n = pc(this.opacity);
    return `${n === 1 ? "hsl(" : "hsla("}${Tg(this.h)}, ${Du(this.s) * 100}%, ${Du(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`;
  }
}));
function Tg(n) {
  return n = (n || 0) % 360, n < 0 ? n + 360 : n;
}
function Du(n) {
  return Math.max(0, Math.min(1, n || 0));
}
function Dh(n, t, e) {
  return (n < 60 ? t + (e - t) * n / 60 : n < 180 ? e : n < 240 ? t + (e - t) * (240 - n) / 60 : t) * 255;
}
const Bd = (n) => () => n;
function Y_(n, t) {
  return function(e) {
    return n + e * t;
  };
}
function K_(n, t, e) {
  return n = Math.pow(n, e), t = Math.pow(t, e) - n, e = 1 / e, function(i) {
    return Math.pow(n + i * t, e);
  };
}
function X_(n) {
  return (n = +n) == 1 ? Sm : function(t, e) {
    return e - t ? K_(t, e, n) : Bd(isNaN(t) ? e : t);
  };
}
function Sm(n, t) {
  var e = t - n;
  return e ? Y_(n, e) : Bd(isNaN(n) ? t : n);
}
const Fg = function n(t) {
  var e = X_(t);
  function i(r, s) {
    var o = e((r = An(r)).r, (s = An(s)).r), a = e(r.g, s.g), l = e(r.b, s.b), h = Sm(r.opacity, s.opacity);
    return function(u) {
      return r.r = o(u), r.g = a(u), r.b = l(u), r.opacity = h(u), r + "";
    };
  }
  return i.gamma = n, i;
}(1);
function J_(n, t) {
  t || (t = []);
  var e = n ? Math.min(t.length, n.length) : 0, i = t.slice(), r;
  return function(s) {
    for (r = 0; r < e; ++r) i[r] = n[r] * (1 - s) + t[r] * s;
    return i;
  };
}
function Z_(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function Q_(n, t) {
  var e = t ? t.length : 0, i = n ? Math.min(e, n.length) : 0, r = new Array(i), s = new Array(e), o;
  for (o = 0; o < i; ++o) r[o] = Uc(n[o], t[o]);
  for (; o < e; ++o) s[o] = t[o];
  return function(a) {
    for (o = 0; o < i; ++o) s[o] = r[o](a);
    return s;
  };
}
function tS(n, t) {
  var e = /* @__PURE__ */ new Date();
  return n = +n, t = +t, function(i) {
    return e.setTime(n * (1 - i) + t * i), e;
  };
}
function gc(n, t) {
  return n = +n, t = +t, function(e) {
    return n * (1 - e) + t * e;
  };
}
function eS(n, t) {
  var e = {}, i = {}, r;
  (n === null || typeof n != "object") && (n = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in n ? e[r] = Uc(n[r], t[r]) : i[r] = t[r];
  return function(s) {
    for (r in e) i[r] = e[r](s);
    return i;
  };
}
var Cf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Bh = new RegExp(Cf.source, "g");
function nS(n) {
  return function() {
    return n;
  };
}
function iS(n) {
  return function(t) {
    return n(t) + "";
  };
}
function rS(n, t) {
  var e = Cf.lastIndex = Bh.lastIndex = 0, i, r, s, o = -1, a = [], l = [];
  for (n = n + "", t = t + ""; (i = Cf.exec(n)) && (r = Bh.exec(t)); )
    (s = r.index) > e && (s = t.slice(e, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, l.push({ i: o, x: gc(i, r) })), e = Bh.lastIndex;
  return e < t.length && (s = t.slice(e), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? iS(l[0].x) : nS(t) : (t = l.length, function(h) {
    for (var u = 0, d; u < t; ++u) a[(d = l[u]).i] = d.x(h);
    return a.join("");
  });
}
function Uc(n, t) {
  var e = typeof t, i;
  return t == null || e === "boolean" ? Bd(t) : (e === "number" ? gc : e === "string" ? (i = ka(t)) ? (t = i, Fg) : rS : t instanceof ka ? Fg : t instanceof Date ? tS : Z_(t) ? J_ : Array.isArray(t) ? Q_ : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? eS : gc)(n, t);
}
function km(n, t) {
  return n = +n, t = +t, function(e) {
    return Math.round(n * (1 - e) + t * e);
  };
}
function sS(n) {
  return function() {
    return n;
  };
}
function oS(n) {
  return +n;
}
var Mg = [0, 1];
function Ms(n) {
  return n;
}
function Pf(n, t) {
  return (t -= n = +n) ? function(e) {
    return (e - n) / t;
  } : sS(isNaN(t) ? NaN : 0.5);
}
function aS(n, t) {
  var e;
  return n > t && (e = n, n = t, t = e), function(i) {
    return Math.max(n, Math.min(t, i));
  };
}
function lS(n, t, e) {
  var i = n[0], r = n[1], s = t[0], o = t[1];
  return r < i ? (i = Pf(r, i), s = e(o, s)) : (i = Pf(i, r), s = e(s, o)), function(a) {
    return s(i(a));
  };
}
function uS(n, t, e) {
  var i = Math.min(n.length, t.length) - 1, r = new Array(i), s = new Array(i), o = -1;
  for (n[i] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o < i; )
    r[o] = Pf(n[o], n[o + 1]), s[o] = e(t[o], t[o + 1]);
  return function(a) {
    var l = P_(n, a, 1, i) - 1;
    return s[l](r[l](a));
  };
}
function cS(n, t) {
  return t.domain(n.domain()).range(n.range()).interpolate(n.interpolate()).clamp(n.clamp()).unknown(n.unknown());
}
function hS() {
  var n = Mg, t = Mg, e = Uc, i, r, s, o = Ms, a, l, h;
  function u() {
    var p = Math.min(n.length, t.length);
    return o !== Ms && (o = aS(n[0], n[p - 1])), a = p > 2 ? uS : lS, l = h = null, d;
  }
  function d(p) {
    return p == null || isNaN(p = +p) ? s : (l || (l = a(n.map(i), t, e)))(i(o(p)));
  }
  return d.invert = function(p) {
    return o(r((h || (h = a(t, n.map(i), gc)))(p)));
  }, d.domain = function(p) {
    return arguments.length ? (n = Array.from(p, oS), u()) : n.slice();
  }, d.range = function(p) {
    return arguments.length ? (t = Array.from(p), u()) : t.slice();
  }, d.rangeRound = function(p) {
    return t = Array.from(p), e = km, u();
  }, d.clamp = function(p) {
    return arguments.length ? (o = p ? !0 : Ms, u()) : o !== Ms;
  }, d.interpolate = function(p) {
    return arguments.length ? (e = p, u()) : e;
  }, d.unknown = function(p) {
    return arguments.length ? (s = p, d) : s;
  }, function(p, f) {
    return i = p, r = f, u();
  };
}
function fS() {
  return hS()(Ms, Ms);
}
function dS(n) {
  return Math.abs(n = Math.round(n)) >= 1e21 ? n.toLocaleString("en").replace(/,/g, "") : n.toString(10);
}
function mc(n, t) {
  if ((e = (n = t ? n.toExponential(t - 1) : n.toExponential()).indexOf("e")) < 0) return null;
  var e, i = n.slice(0, e);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +n.slice(e + 1)
  ];
}
function Aa(n) {
  return n = mc(Math.abs(n)), n ? n[1] : NaN;
}
function pS(n, t) {
  return function(e, i) {
    for (var r = e.length, s = [], o = 0, a = n[0], l = 0; r > 0 && a > 0 && (l + a + 1 > i && (a = Math.max(1, i - l)), s.push(e.substring(r -= a, r + a)), !((l += a + 1) > i)); )
      a = n[o = (o + 1) % n.length];
    return s.reverse().join(t);
  };
}
function gS(n) {
  return function(t) {
    return t.replace(/[0-9]/g, function(e) {
      return n[+e];
    });
  };
}
var mS = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function yc(n) {
  if (!(t = mS.exec(n))) throw new Error("invalid format: " + n);
  var t;
  return new jd({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
yc.prototype = jd.prototype;
function jd(n) {
  this.fill = n.fill === void 0 ? " " : n.fill + "", this.align = n.align === void 0 ? ">" : n.align + "", this.sign = n.sign === void 0 ? "-" : n.sign + "", this.symbol = n.symbol === void 0 ? "" : n.symbol + "", this.zero = !!n.zero, this.width = n.width === void 0 ? void 0 : +n.width, this.comma = !!n.comma, this.precision = n.precision === void 0 ? void 0 : +n.precision, this.trim = !!n.trim, this.type = n.type === void 0 ? "" : n.type + "";
}
jd.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function yS(n) {
  t: for (var t = n.length, e = 1, i = -1, r; e < t; ++e)
    switch (n[e]) {
      case ".":
        i = r = e;
        break;
      case "0":
        i === 0 && (i = e), r = e;
        break;
      default:
        if (!+n[e]) break t;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? n.slice(0, i) + n.slice(r + 1) : n;
}
var Am;
function bS(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1], s = r - (Am = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = i.length;
  return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + mc(n, Math.max(0, t + s - 1))[0];
}
function Rg(n, t) {
  var e = mc(n, t);
  if (!e) return n + "";
  var i = e[0], r = e[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const Dg = {
  "%": (n, t) => (n * 100).toFixed(t),
  b: (n) => Math.round(n).toString(2),
  c: (n) => n + "",
  d: dS,
  e: (n, t) => n.toExponential(t),
  f: (n, t) => n.toFixed(t),
  g: (n, t) => n.toPrecision(t),
  o: (n) => Math.round(n).toString(8),
  p: (n, t) => Rg(n * 100, t),
  r: Rg,
  s: bS,
  X: (n) => Math.round(n).toString(16).toUpperCase(),
  x: (n) => Math.round(n).toString(16)
};
function Bg(n) {
  return n;
}
var jg = Array.prototype.map, qg = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function vS(n) {
  var t = n.grouping === void 0 || n.thousands === void 0 ? Bg : pS(jg.call(n.grouping, Number), n.thousands + ""), e = n.currency === void 0 ? "" : n.currency[0] + "", i = n.currency === void 0 ? "" : n.currency[1] + "", r = n.decimal === void 0 ? "." : n.decimal + "", s = n.numerals === void 0 ? Bg : gS(jg.call(n.numerals, String)), o = n.percent === void 0 ? "%" : n.percent + "", a = n.minus === void 0 ? "−" : n.minus + "", l = n.nan === void 0 ? "NaN" : n.nan + "";
  function h(d) {
    d = yc(d);
    var p = d.fill, f = d.align, g = d.sign, y = d.symbol, _ = d.zero, b = d.width, v = d.comma, A = d.precision, L = d.trim, O = d.type;
    O === "n" ? (v = !0, O = "g") : Dg[O] || (A === void 0 && (A = 12), L = !0, O = "g"), (_ || p === "0" && f === "=") && (_ = !0, p = "0", f = "=");
    var R = y === "$" ? e : y === "#" && /[boxX]/.test(O) ? "0" + O.toLowerCase() : "", C = y === "$" ? i : /[%p]/.test(O) ? o : "", E = Dg[O], M = /[defgprs%]/.test(O);
    A = A === void 0 ? 6 : /[gprs]/.test(O) ? Math.max(1, Math.min(21, A)) : Math.max(0, Math.min(20, A));
    function q(N) {
      var S = R, T = C, x, X, V;
      if (O === "c")
        T = E(N) + T, N = "";
      else {
        N = +N;
        var D = N < 0 || 1 / N < 0;
        if (N = isNaN(N) ? l : E(Math.abs(N), A), L && (N = yS(N)), D && +N == 0 && g !== "+" && (D = !1), S = (D ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + S, T = (O === "s" ? qg[8 + Am / 3] : "") + T + (D && g === "(" ? ")" : ""), M) {
          for (x = -1, X = N.length; ++x < X; )
            if (V = N.charCodeAt(x), 48 > V || V > 57) {
              T = (V === 46 ? r + N.slice(x + 1) : N.slice(x)) + T, N = N.slice(0, x);
              break;
            }
        }
      }
      v && !_ && (N = t(N, 1 / 0));
      var tt = S.length + N.length + T.length, H = tt < b ? new Array(b - tt + 1).join(p) : "";
      switch (v && _ && (N = t(H + N, H.length ? b - T.length : 1 / 0), H = ""), f) {
        case "<":
          N = S + N + T + H;
          break;
        case "=":
          N = S + H + N + T;
          break;
        case "^":
          N = H.slice(0, tt = H.length >> 1) + S + N + T + H.slice(tt);
          break;
        default:
          N = H + S + N + T;
          break;
      }
      return s(N);
    }
    return q.toString = function() {
      return d + "";
    }, q;
  }
  function u(d, p) {
    var f = h((d = yc(d), d.type = "f", d)), g = Math.max(-8, Math.min(8, Math.floor(Aa(p) / 3))) * 3, y = Math.pow(10, -g), _ = qg[8 + g / 3];
    return function(b) {
      return f(y * b) + _;
    };
  }
  return {
    format: h,
    formatPrefix: u
  };
}
var Bu, qd, Nm;
wS({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function wS(n) {
  return Bu = vS(n), qd = Bu.format, Nm = Bu.formatPrefix, Bu;
}
function Cm(n) {
  return Math.max(0, -Aa(Math.abs(n)));
}
function xS(n, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Aa(t) / 3))) * 3 - Aa(Math.abs(n)));
}
function _S(n, t) {
  return n = Math.abs(n), t = Math.abs(t) - n, Math.max(0, Aa(t) - Aa(n)) + 1;
}
function SS(n, t, e, i) {
  var r = T_(n, t, e), s;
  switch (i = yc(i ?? ",f"), i.type) {
    case "s": {
      var o = Math.max(Math.abs(n), Math.abs(t));
      return i.precision == null && !isNaN(s = xS(r, o)) && (i.precision = s), Nm(i, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(s = _S(r, Math.max(Math.abs(n), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(s = Cm(r)) && (i.precision = s - (i.type === "%") * 2);
      break;
    }
  }
  return qd(i);
}
function Pm(n) {
  var t = n.domain;
  return n.ticks = function(e) {
    var i = t();
    return O_(i[0], i[i.length - 1], e ?? 10);
  }, n.tickFormat = function(e, i) {
    var r = t();
    return SS(r[0], r[r.length - 1], e ?? 10, i);
  }, n.nice = function(e) {
    e == null && (e = 10);
    var i = t(), r = 0, s = i.length - 1, o = i[r], a = i[s], l, h, u = 10;
    for (a < o && (h = o, o = a, a = h, h = r, r = s, s = h); u-- > 0; ) {
      if (h = Nf(o, a, e), h === l)
        return i[r] = o, i[s] = a, t(i);
      if (h > 0)
        o = Math.floor(o / h) * h, a = Math.ceil(a / h) * h;
      else if (h < 0)
        o = Math.ceil(o * h) / h, a = Math.floor(a * h) / h;
      else
        break;
      l = h;
    }
    return n;
  }, n;
}
function Lm() {
  var n = fS();
  return n.copy = function() {
    return cS(n, Lm());
  }, F_.apply(n, arguments), Pm(n);
}
function kS() {
  var n = 0, t = 1, e, i, r, s, o = Ms, a = !1, l;
  function h(d) {
    return d == null || isNaN(d = +d) ? l : o(r === 0 ? 0.5 : (d = (s(d) - e) * r, a ? Math.max(0, Math.min(1, d)) : d));
  }
  h.domain = function(d) {
    return arguments.length ? ([n, t] = d, e = s(n = +n), i = s(t = +t), r = e === i ? 0 : 1 / (i - e), h) : [n, t];
  }, h.clamp = function(d) {
    return arguments.length ? (a = !!d, h) : a;
  }, h.interpolator = function(d) {
    return arguments.length ? (o = d, h) : o;
  };
  function u(d) {
    return function(p) {
      var f, g;
      return arguments.length ? ([f, g] = p, o = d(f, g), h) : [o(0), o(1)];
    };
  }
  return h.range = u(Uc), h.rangeRound = u(km), h.unknown = function(d) {
    return arguments.length ? (l = d, h) : l;
  }, function(d) {
    return s = d, e = d(n), i = d(t), r = e === i ? 0 : 1 / (i - e), h;
  };
}
function AS(n, t) {
  return t.domain(n.domain()).interpolator(n.interpolator()).clamp(n.clamp()).unknown(n.unknown());
}
function Im() {
  var n = Pm(kS()(Ms));
  return n.copy = function() {
    return AS(n, Im());
  }, M_.apply(n, arguments);
}
function NS(n) {
  return n;
}
var Ku = 1, Xu = 2, Lf = 3, vl = 4, zg = 1e-6;
function CS(n) {
  return "translate(" + n + ",0)";
}
function PS(n) {
  return "translate(0," + n + ")";
}
function LS(n) {
  return (t) => +n(t);
}
function IS(n, t) {
  return t = Math.max(0, n.bandwidth() - t * 2) / 2, n.round() && (t = Math.round(t)), (e) => +n(e) + t;
}
function ES() {
  return !this.__axis;
}
function Wc(n, t) {
  var e = [], i = null, r = null, s = 6, o = 6, a = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, h = n === Ku || n === vl ? -1 : 1, u = n === vl || n === Xu ? "x" : "y", d = n === Ku || n === Lf ? CS : PS;
  function p(f) {
    var g = i ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), y = r ?? (t.tickFormat ? t.tickFormat.apply(t, e) : NS), _ = Math.max(s, 0) + a, b = t.range(), v = +b[0] + l, A = +b[b.length - 1] + l, L = (t.bandwidth ? IS : LS)(t.copy(), l), O = f.selection ? f.selection() : f, R = O.selectAll(".domain").data([null]), C = O.selectAll(".tick").data(g, t).order(), E = C.exit(), M = C.enter().append("g").attr("class", "tick"), q = C.select("line"), N = C.select("text");
    R = R.merge(R.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), C = C.merge(M), q = q.merge(M.append("line").attr("stroke", "currentColor").attr(u + "2", h * s)), N = N.merge(M.append("text").attr("fill", "currentColor").attr(u, h * _).attr("dy", n === Ku ? "0em" : n === Lf ? "0.71em" : "0.32em")), f !== O && (R = R.transition(f), C = C.transition(f), q = q.transition(f), N = N.transition(f), E = E.transition(f).attr("opacity", zg).attr("transform", function(S) {
      return isFinite(S = L(S)) ? d(S + l) : this.getAttribute("transform");
    }), M.attr("opacity", zg).attr("transform", function(S) {
      var T = this.parentNode.__axis;
      return d((T && isFinite(T = T(S)) ? T : L(S)) + l);
    })), E.remove(), R.attr("d", n === vl || n === Xu ? o ? "M" + h * o + "," + v + "H" + l + "V" + A + "H" + h * o : "M" + l + "," + v + "V" + A : o ? "M" + v + "," + h * o + "V" + l + "H" + A + "V" + h * o : "M" + v + "," + l + "H" + A), C.attr("opacity", 1).attr("transform", function(S) {
      return d(L(S) + l);
    }), q.attr(u + "2", h * s), N.attr(u, h * _).text(y), O.filter(ES).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", n === Xu ? "start" : n === vl ? "end" : "middle"), O.each(function() {
      this.__axis = L;
    });
  }
  return p.scale = function(f) {
    return arguments.length ? (t = f, p) : t;
  }, p.ticks = function() {
    return e = Array.from(arguments), p;
  }, p.tickArguments = function(f) {
    return arguments.length ? (e = f == null ? [] : Array.from(f), p) : e.slice();
  }, p.tickValues = function(f) {
    return arguments.length ? (i = f == null ? null : Array.from(f), p) : i && i.slice();
  }, p.tickFormat = function(f) {
    return arguments.length ? (r = f, p) : r;
  }, p.tickSize = function(f) {
    return arguments.length ? (s = o = +f, p) : s;
  }, p.tickSizeInner = function(f) {
    return arguments.length ? (s = +f, p) : s;
  }, p.tickSizeOuter = function(f) {
    return arguments.length ? (o = +f, p) : o;
  }, p.tickPadding = function(f) {
    return arguments.length ? (a = +f, p) : a;
  }, p.offset = function(f) {
    return arguments.length ? (l = +f, p) : l;
  }, p;
}
function OS(n) {
  return Wc(Ku, n);
}
function TS(n) {
  return Wc(Xu, n);
}
function FS(n) {
  return Wc(Lf, n);
}
function MS(n) {
  return Wc(vl, n);
}
const If = Math.PI, Ef = 2 * If, ao = 1e-6, RS = Ef - ao;
function Em(n) {
  this._ += n[0];
  for (let t = 1, e = n.length; t < e; ++t)
    this._ += arguments[t] + n[t];
}
function DS(n) {
  let t = Math.floor(n);
  if (!(t >= 0)) throw new Error(`invalid digits: ${n}`);
  if (t > 15) return Em;
  const e = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, s = i.length; r < s; ++r)
      this._ += Math.round(arguments[r] * e) / e + i[r];
  };
}
class zd {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Em : DS(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, i, r) {
    this._append`Q${+t},${+e},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, e, i, r, s, o) {
    this._append`C${+t},${+e},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, e, i, r, s) {
    if (t = +t, e = +e, i = +i, r = +r, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, l = i - t, h = r - e, u = o - t, d = a - e, p = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (p > ao) if (!(Math.abs(d * l - h * u) > ao) || !s)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let f = i - o, g = r - a, y = l * l + h * h, _ = f * f + g * g, b = Math.sqrt(y), v = Math.sqrt(p), A = s * Math.tan((If - Math.acos((y + p - _) / (2 * b * v))) / 2), L = A / v, O = A / b;
      Math.abs(L - 1) > ao && this._append`L${t + L * u},${e + L * d}`, this._append`A${s},${s},0,0,${+(d * f > u * g)},${this._x1 = t + O * l},${this._y1 = e + O * h}`;
    }
  }
  arc(t, e, i, r, s, o) {
    if (t = +t, e = +e, i = +i, o = !!o, i < 0) throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(r), l = i * Math.sin(r), h = t + a, u = e + l, d = 1 ^ o, p = o ? r - s : s - r;
    this._x1 === null ? this._append`M${h},${u}` : (Math.abs(this._x1 - h) > ao || Math.abs(this._y1 - u) > ao) && this._append`L${h},${u}`, i && (p < 0 && (p = p % Ef + Ef), p > RS ? this._append`A${i},${i},0,1,${d},${t - a},${e - l}A${i},${i},0,1,${d},${this._x1 = h},${this._y1 = u}` : p > ao && this._append`A${i},${i},0,${+(p >= If)},${d},${this._x1 = t + i * Math.cos(s)},${this._y1 = e + i * Math.sin(s)}`);
  }
  rect(t, e, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
}
function Om() {
  return new zd();
}
Om.prototype = zd.prototype;
function Xi(n) {
  return function() {
    return n;
  };
}
const $g = Math.abs, oi = Math.atan2, so = Math.cos, BS = Math.max, jh = Math.min, Ar = Math.sin, Er = Math.sqrt, wi = 1e-12, Na = Math.PI, bc = Na / 2, Tm = 2 * Na;
function jS(n) {
  return n > 1 ? 0 : n < -1 ? Na : Math.acos(n);
}
function Ug(n) {
  return n >= 1 ? bc : n <= -1 ? -bc : Math.asin(n);
}
function Fm(n) {
  let t = 3;
  return n.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const i = Math.floor(e);
      if (!(i >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = i;
    }
    return n;
  }, () => new zd(t);
}
function qS(n) {
  return n.innerRadius;
}
function zS(n) {
  return n.outerRadius;
}
function $S(n) {
  return n.startAngle;
}
function US(n) {
  return n.endAngle;
}
function WS(n) {
  return n && n.padAngle;
}
function HS(n, t, e, i, r, s, o, a) {
  var l = e - n, h = i - t, u = o - r, d = a - s, p = d * l - u * h;
  if (!(p * p < wi))
    return p = (u * (t - s) - d * (n - r)) / p, [n + p * l, t + p * h];
}
function ju(n, t, e, i, r, s, o) {
  var a = n - e, l = t - i, h = (o ? s : -s) / Er(a * a + l * l), u = h * l, d = -h * a, p = n + u, f = t + d, g = e + u, y = i + d, _ = (p + g) / 2, b = (f + y) / 2, v = g - p, A = y - f, L = v * v + A * A, O = r - s, R = p * y - g * f, C = (A < 0 ? -1 : 1) * Er(BS(0, O * O * L - R * R)), E = (R * A - v * C) / L, M = (-R * v - A * C) / L, q = (R * A + v * C) / L, N = (-R * v + A * C) / L, S = E - _, T = M - b, x = q - _, X = N - b;
  return S * S + T * T > x * x + X * X && (E = q, M = N), {
    cx: E,
    cy: M,
    x01: -u,
    y01: -d,
    x11: E * (r / O - 1),
    y11: M * (r / O - 1)
  };
}
function GS() {
  var n = qS, t = zS, e = Xi(0), i = null, r = $S, s = US, o = WS, a = null, l = Fm(h);
  function h() {
    var u, d, p = +n.apply(this, arguments), f = +t.apply(this, arguments), g = r.apply(this, arguments) - bc, y = s.apply(this, arguments) - bc, _ = $g(y - g), b = y > g;
    if (a || (a = u = l()), f < p && (d = f, f = p, p = d), !(f > wi)) a.moveTo(0, 0);
    else if (_ > Tm - wi)
      a.moveTo(f * so(g), f * Ar(g)), a.arc(0, 0, f, g, y, !b), p > wi && (a.moveTo(p * so(y), p * Ar(y)), a.arc(0, 0, p, y, g, b));
    else {
      var v = g, A = y, L = g, O = y, R = _, C = _, E = o.apply(this, arguments) / 2, M = E > wi && (i ? +i.apply(this, arguments) : Er(p * p + f * f)), q = jh($g(f - p) / 2, +e.apply(this, arguments)), N = q, S = q, T, x;
      if (M > wi) {
        var X = Ug(M / p * Ar(E)), V = Ug(M / f * Ar(E));
        (R -= X * 2) > wi ? (X *= b ? 1 : -1, L += X, O -= X) : (R = 0, L = O = (g + y) / 2), (C -= V * 2) > wi ? (V *= b ? 1 : -1, v += V, A -= V) : (C = 0, v = A = (g + y) / 2);
      }
      var D = f * so(v), tt = f * Ar(v), H = p * so(O), ct = p * Ar(O);
      if (q > wi) {
        var it = f * so(A), P = f * Ar(A), z = p * so(L), G = p * Ar(L), Y;
        if (_ < Na)
          if (Y = HS(D, tt, z, G, it, P, H, ct)) {
            var ot = D - Y[0], xt = tt - Y[1], gt = it - Y[0], wt = P - Y[1], qt = 1 / Ar(jS((ot * gt + xt * wt) / (Er(ot * ot + xt * xt) * Er(gt * gt + wt * wt))) / 2), Dt = Er(Y[0] * Y[0] + Y[1] * Y[1]);
            N = jh(q, (p - Dt) / (qt - 1)), S = jh(q, (f - Dt) / (qt + 1));
          } else
            N = S = 0;
      }
      C > wi ? S > wi ? (T = ju(z, G, D, tt, f, S, b), x = ju(it, P, H, ct, f, S, b), a.moveTo(T.cx + T.x01, T.cy + T.y01), S < q ? a.arc(T.cx, T.cy, S, oi(T.y01, T.x01), oi(x.y01, x.x01), !b) : (a.arc(T.cx, T.cy, S, oi(T.y01, T.x01), oi(T.y11, T.x11), !b), a.arc(0, 0, f, oi(T.cy + T.y11, T.cx + T.x11), oi(x.cy + x.y11, x.cx + x.x11), !b), a.arc(x.cx, x.cy, S, oi(x.y11, x.x11), oi(x.y01, x.x01), !b))) : (a.moveTo(D, tt), a.arc(0, 0, f, v, A, !b)) : a.moveTo(D, tt), !(p > wi) || !(R > wi) ? a.lineTo(H, ct) : N > wi ? (T = ju(H, ct, it, P, p, -N, b), x = ju(D, tt, z, G, p, -N, b), a.lineTo(T.cx + T.x01, T.cy + T.y01), N < q ? a.arc(T.cx, T.cy, N, oi(T.y01, T.x01), oi(x.y01, x.x01), !b) : (a.arc(T.cx, T.cy, N, oi(T.y01, T.x01), oi(T.y11, T.x11), !b), a.arc(0, 0, p, oi(T.cy + T.y11, T.cx + T.x11), oi(x.cy + x.y11, x.cx + x.x11), b), a.arc(x.cx, x.cy, N, oi(x.y11, x.x11), oi(x.y01, x.x01), !b))) : a.arc(0, 0, p, O, L, b);
    }
    if (a.closePath(), u) return a = null, u + "" || null;
  }
  return h.centroid = function() {
    var u = (+n.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Na / 2;
    return [so(d) * u, Ar(d) * u];
  }, h.innerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Xi(+u), h) : n;
  }, h.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Xi(+u), h) : t;
  }, h.cornerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Xi(+u), h) : e;
  }, h.padRadius = function(u) {
    return arguments.length ? (i = u == null ? null : typeof u == "function" ? u : Xi(+u), h) : i;
  }, h.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Xi(+u), h) : r;
  }, h.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : Xi(+u), h) : s;
  }, h.padAngle = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Xi(+u), h) : o;
  }, h.context = function(u) {
    return arguments.length ? (a = u ?? null, h) : a;
  }, h;
}
const VS = {
  draw(n, t) {
    const e = Er(t / Na);
    n.moveTo(e, 0), n.arc(0, 0, e, 0, Tm);
  }
}, YS = {
  draw(n, t) {
    const e = Er(t), i = -e / 2;
    n.rect(i, i, e, e);
  }
}, qh = Er(3), KS = {
  draw(n, t) {
    const e = -Er(t / (qh * 3));
    n.moveTo(0, e * 2), n.lineTo(-qh * e, -e), n.lineTo(qh * e, -e), n.closePath();
  }
};
function XS(n, t) {
  let e = null, i = Fm(r);
  n = typeof n == "function" ? n : Xi(n || VS), t = typeof t == "function" ? t : Xi(t === void 0 ? 64 : +t);
  function r() {
    let s;
    if (e || (e = s = i()), n.apply(this, arguments).draw(e, +t.apply(this, arguments)), s) return e = null, s + "" || null;
  }
  return r.type = function(s) {
    return arguments.length ? (n = typeof s == "function" ? s : Xi(s), r) : n;
  }, r.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Xi(+s), r) : t;
  }, r.context = function(s) {
    return arguments.length ? (e = s ?? null, r) : e;
  }, r;
}
const De = {
  precisionFixed: Cm,
  format: qd,
  select: __,
  selectAll: S_,
  scaleLinear: Lm,
  scaleSequential: Im,
  axisTop: OS,
  axisBottom: FS,
  axisRight: TS,
  axisLeft: MS,
  symbol: XS,
  path: Om,
  arc: GS,
  symbolTriangle: KS,
  symbolSquare: YS
};
function ha(n) {
  return typeof n == "string" && n.length === 6 && !isNaN(+("0x" + n.replace("#", "")));
}
class JS {
  constructor({
    elementID: t,
    env: e = "production",
    main: i = !0,
    units: r = "decimal",
    decimalPlaces: s = 2,
    fractionRoundTo: o = 0,
    saw: a = null,
    app: l = !1,
    embed: h = !1,
    height: u = 0,
    width: d = 0,
    flipY: p = !1,
    flipX: f = !1,
    colors: g = {
      partA: "#1d9bc4",
      partB: "#127da1",
      partHover: "#29c778",
      partSelected: "#1bc319",
      stock: "#ffd166",
      text: "#ffffff"
    },
    options: y = {
      disableClick: !1,
      enableStretch: !0
    },
    vueComponent: _
  }) {
    et(this, "env");
    et(this, "main");
    //is this the main vis or not
    et(this, "units", "decimal");
    et(this, "decimalPlaces");
    et(this, "fractionRoundTo");
    et(this, "formatNumber", (t) => te(
      t,
      this.units,
      this.decimalPlaces ?? 2,
      !1,
      this.fractionRoundTo ?? 0
    ).toString());
    et(this, "saw");
    et(this, "stockType");
    et(this, "numUniqueShapes");
    et(this, "app");
    et(this, "embed");
    et(this, "height");
    et(this, "width");
    et(this, "device");
    et(this, "vueComponent");
    et(this, "elWidth");
    et(this, "elHeight");
    et(this, "w");
    et(this, "h");
    et(this, "padding");
    et(this, "mobileBreakpoint");
    //scales
    et(this, "xScale", De.scaleLinear());
    et(this, "yScale", De.scaleLinear());
    et(this, "yPositionScale", De.scaleLinear());
    et(this, "xPositionScale", De.scaleLinear());
    et(this, "yAxisScale", De.scaleLinear());
    et(this, "measurementScale", De.scaleLinear());
    et(this, "xAxis");
    et(this, "yAxis");
    et(this, "stretched");
    et(this, "shapeXAxis");
    et(this, "shapeYAxis");
    et(this, "cutMeasurementXAxes");
    et(this, "cutMeasurementYAxes");
    et(this, "axisSpacing");
    et(this, "flipY");
    et(this, "flipX");
    et(this, "colors");
    et(this, "options");
    et(this, "moveMode");
    et(this, "moveRotation");
    et(this, "moving");
    et(this, "shape");
    et(this, "shapeColorScale");
    et(this, "scoreColorScale");
    et(this, "hasTouch");
    et(this, "highlightguillotine");
    et(this, "debug", "");
    //groups | guillotine | positions
    et(this, "elementID");
    //the id of the element to draw the vis in
    et(this, "el");
    et(this, "htmlEl");
    et(this, "svgCanvas");
    et(this, "axisGroup");
    et(this, "stockGroup");
    et(this, "stockWrappers");
    et(this, "stock");
    et(this, "shapeGroup");
    et(this, "shapeWrappers");
    et(this, "shapes");
    et(this, "shapeIDText");
    et(this, "shapeNameText");
    et(this, "shapeLengthText");
    et(this, "shapeWidthText");
    et(this, "groupGroup");
    et(this, "groups");
    et(this, "bandingGroup");
    et(this, "bandingWrappers");
    et(this, "banding");
    et(this, "segmentGroup");
    et(this, "segments");
    et(this, "segment");
    et(this, "positionGroup");
    et(this, "position");
    et(this, "dotGroup");
    et(this, "placementPositionGroup");
    et(this, "dot");
    et(this, "cutGroup");
    et(this, "cuts");
    et(this, "cut");
    if (!t) throw new Error("elementID is required");
    if (this.el = De.select(t), this.el === null) return;
    const b = this.el.node();
    if (b !== null) {
      this.htmlEl = b, this.vueComponent = _, this.env = Ye.call(this.vueComponent, ["env"]) === "development" ? "development" : "production", this.debug = this.env === "development" ? "groups" : "", this.app = l || !1, this.embed = h || !1, this.height = u, this.width = d, this.device = l ? "app" : "desktop", this.stretched = !1, this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.w = 0, this.h = 0, this.padding = 0, this.mobileBreakpoint = 450, this.main = i, this.saw = a, this.cutMeasurementXAxes = [], this.cutMeasurementYAxes = [], this.axisSpacing = 16, this.flipY = p, this.flipX = f, g = {
        ...g
      };
      for (const [v, A] of Object.entries(g))
        A && (g[v] = A.replace("#", ""));
      this.colors = {
        partA: ha(g == null ? void 0 : g.partA) ? An("#" + g.partA) : An("#1d9bc4"),
        partB: ha(g == null ? void 0 : g.partB) ? An("#" + g.partB) : An("#127da1"),
        partHover: ha(g == null ? void 0 : g.partHover) ? An("#" + g.partHover) : An("#29c778"),
        partSelected: ha(g == null ? void 0 : g.partSelected) ? An("#" + g.partSelected) : An("#1bc319"),
        stock: ha(g == null ? void 0 : g.stock) ? An("#" + g.stock) : An("#ffd166"),
        text: ha(g == null ? void 0 : g.text) ? An("#" + g.text) : An("#ffffff")
      }, this.shapeColorScale = De.scaleSequential([
        this.colors.partA,
        this.colors.partB
      ]), this.env = e, this.moveMode = !1, this.moving = !1, this.moveRotation = !1, this.units = r, this.decimalPlaces = s, this.fractionRoundTo = o, this.hasTouch = !1, this.options = y, this.init();
    }
  }
  /**
      * sets up the various wrappers - only needs to be called once
      * the z index is set by the order drawn
      */
  init() {
    if (!this.el) return !1;
    if ((this.decimalPlaces === null || this.decimalPlaces === void 0 || isNaN(this.decimalPlaces)) && (this.decimalPlaces = 2), (this.fractionRoundTo === null || this.fractionRoundTo === void 0 || isNaN(this.fractionRoundTo)) && (this.fractionRoundTo = 0), !this.svgCanvas) {
      if (this.htmlEl.querySelector("svg") === null) {
        const e = this.el.append("svg").attr("class", "vis");
        if (e === null) return;
        e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").attr("id", "stripes").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(90)").attr("id", "grain-l").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), e.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("id", "grain-w").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1"), this.svgCanvas = e;
      }
      this.axisGroup = this.svgCanvas.append("g").attr("class", "axis-group"), this.stockGroup = this.svgCanvas.append("g").attr("class", "stock-group"), this.shapeGroup = this.svgCanvas.append("g").attr("class", "shapes"), this.bandingGroup = this.svgCanvas.append("g").attr("class", "banding-group"), this.segmentGroup = this.svgCanvas.append("g").attr("class", "segments").attr("display", "none"), this.groupGroup = this.svgCanvas.append("g").attr("class", "groups").attr("display", "none"), this.positionGroup = this.svgCanvas.append("g").attr("class", "positions"), this.dotGroup = this.svgCanvas.append("g").attr("class", "dots"), this.env === "development" && (this.placementPositionGroup = this.svgCanvas.append("g").attr("class", "placements")), this.cutGroup = this.svgCanvas.append("g").attr("class", "cuts");
    }
    this.elWidth > 0 && this.updateSize(!0), this.hasTouch = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
  updateUnits(t, e, i) {
    t && (this.units = t), e && (this.decimalPlaces = e), i && (this.fractionRoundTo = i), this.refreshShapes(), this.refreshStock();
  }
  trimNameToFit(t, e) {
    function i(r, s, o) {
      const a = o[s], l = De.select(a);
      l.text(r.name);
      let h = l.text();
      const u = l.node();
      if (!u) return;
      let d = u.getComputedTextLength();
      const p = this.getWidthAttribute(r) - 20;
      for (; d > p && h.length > 0; )
        h = h.slice(0, -1), l.text(h.length ? h + "..." : ""), d = l.node().getComputedTextLength();
    }
    t.each(i.bind(e));
  }
  getShapeColor(t) {
    var e;
    if (this.env === "development")
      switch (this.debug) {
        case "guillotine":
          if (t.guillotineData.firstShape)
            return An(252, 3, 182);
          if (t.addedAsGroup)
            return An(43, 156, 16);
          if (typeof t.guillotineData.myPhase == "number") {
            const i = [0, 115, 255], r = [176, 255, 231];
            return `rgb(${i.map((o, a) => Math.round(o + t.guillotineData.myPhase / 5 * (r[a] - o))).join(",")})`;
          }
          break;
        case "groups":
          if (t.addedAsGroup !== !1)
            return An(43, 156, 16);
          break;
        case "priorityShapes":
          if (t != null && t.priority && ((e = t.priority) != null && e[t.stock.parentID]))
            return An(139, 171, 46);
          break;
        case "score":
          return this.scoreColorScale(t.bestScore.total);
      }
    return this.shapeColorScale(t.parentID - 1);
  }
  setDevice() {
    if (!(!this.htmlEl || this.htmlEl.style.display === "none") && this.htmlEl.offsetWidth) {
      if (this.elWidth = this.htmlEl.offsetWidth, this.elHeight = this.htmlEl.offsetHeight, this.elWidth === 0) return !1;
      this.main ? this.elWidth <= this.mobileBreakpoint || this.app ? (this.device = "mobile", this.padding = 0) : (this.device = "desktop", this.padding = 50) : this.padding = 0, this.w = this.elWidth;
    }
  }
  //find the largest dimensions of all the stock (not just the active one)
  findLargestStockDimensions() {
    const t = Ye.call(this.vueComponent, ["stockList"]).filter((r) => r.used);
    if (!(t != null && t.length)) return [null, null];
    const e = t.reduce((r, s) => r.l > s.l ? r : s), i = t.reduce((r, s) => r.w > s.w ? r : s);
    return [e, i];
  }
  debounce(t, e, i = !1) {
    let r;
    return (...s) => new Promise((o) => {
      const a = () => {
        r = null, i || o(t.apply(this, s));
      };
      clearTimeout(r), i && !r && o(t.apply(this, s)), r = setTimeout(a, e);
    });
  }
  updateSize(t = !1) {
    return this.debounce(this._updateSize.bind(this), 10, t)();
  }
  requiresStretch(t, e = null) {
    return t ? (e === null && (e = t.w / t.l), e < 0.15) : !1;
  }
  setAspectRatio(t) {
    if (t) {
      this.w = this.elWidth;
      const e = t.w / t.l;
      this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.requiresStretch(t, e) && this.options.enableStretch ? (this.h = this.htmlEl.clientWidth * 0.15 + this.padding * 2, this.stretched = !0) : (this.h = this.xScale(t.getShortSide()) + this.padding, this.stretched = !1), this.yScale.domain([0, t.w]).range([this.padding, this.h - this.padding]), this.yAxisScale.domain(this.flipY ? [0, t.w] : [t.w, 0]).range([this.padding, this.h - this.padding]), this.yPositionScale.domain([0, t.w]).range(this.flipY ? [this.padding, this.h - this.padding] : [this.h - this.padding, this.padding]), e > 2 && (this.w = this.htmlEl.clientWidth / e + this.padding * 2, this.xScale.domain([0, t.l]).range([this.padding, this.w - this.padding]), this.h = this.xScale(t.getShortSide()) + this.padding), this.xPositionScale.domain([0, t.l]).range(this.flipX ? [this.w - this.padding, this.padding] : [this.padding, this.w - this.padding]), this.measurementScale.domain([0, t.l]).range([0, this.w - this.padding * 2]), this.w > 0 && this.h > 0 && (e > 2 ? this.el.style("width", this.w + "px") : this.el.style("width", ""), this.el.style("height", this.h + "px"));
    }
  }
  _updateSize() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    this.vueComponent && "suppressResizeObserver" in this.vueComponent && (this.vueComponent.suppressResizeObserver = !0);
    const t = Ye.call(this.vueComponent, ["stockList"]), e = Ye.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length) || !(e != null && e.length)) return !1;
    this.setDevice(), this.refreshStock(), this.refreshShapes(), this.env === "development" && this.refreshPlacementPositions();
  }
  refreshCuts() {
    const t = Ye.call(this.vueComponent, ["activeCuts"]);
    this.resetSegments(), this.initCuts(t);
  }
  refreshStock() {
    const t = Ye.call(this.vueComponent, ["stockList"]);
    if (!(t != null && t.length)) return !1;
    const e = Ye.call(this.vueComponent, ["activeStock"]);
    this.initStock(e), this.refreshCuts();
    const i = Ye.call(this.vueComponent, ["activeSegments"]);
    this.initSegments(i), this.resetPositions(), typeof this.vueComponent.toggleSegments == "function" && this.vueComponent.toggleSegments(!1);
  }
  refreshShapes() {
    const t = Ye.call(this.vueComponent, ["shapeList"]);
    if (!(t != null && t.length)) return !1;
    this.resetPositions();
    const e = Ye.call(this.vueComponent, ["activeShapes"]);
    this.initShapes(e, t);
  }
  refreshPlacementPositions() {
    const t = Ye.call(this.vueComponent, ["placementPositions"]);
    if (!(t != null && t.length)) return !1;
    this.resetPlacementPositions();
    const e = t.filter((i) => i.stockID === Ye.call(this.vueComponent, ["activeStock"]).id);
    this.initPlacementPositions(e);
  }
  recreateUerGroups(t) {
    t.filter((r) => r.inUserGroup);
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r].addedAsGroup, a = t.filter((l) => l.addedAsGroup === o);
      e.push(a), r += a.length;
    }
    const i = [];
    e.forEach((r) => {
      const s = Math.min(...r.map((u) => u.x)), o = Math.min(...r.map((u) => u.y)), a = Math.max(...r.map((u) => u.x + u.l)) - s, l = Math.max(...r.map((u) => u.y + u.w)) - o, h = {
        x: s,
        y: o,
        l: a,
        w: l,
        shapes: r
      };
      i.push(h);
    }), this.initGroups(i);
  }
  //init or update the stock
  initStock(t) {
    if (this.resetStock(), this.setAspectRatio(t), !t || !(t != null && t.w) || !(t != null && t.l) || !this.elWidth)
      return !1;
    this.stockType = t.type;
    let e;
    if (typeof t == "object" && (e = [t]), this.device === "desktop" && this.main) {
      this.xAxis = this.axisGroup.append("g").attr("transform", `translate(0, ${this.padding})`).attr("class", "axis stock x").call(De.axisTop(this.xScale).ticks(5).tickSize(5)).selectAll("text").attr("dy", -5);
      const i = this.requiresStretch(t);
      (!i || i && this.stretched) && (this.yAxis = this.axisGroup.append("g").attr(
        "transform",
        `translate(${this.w - this.padding}, 0)`
      ).attr("class", "axis stock y").call(De.axisRight(this.yAxisScale).ticks(5).tickSize(5)).selectAll("text").attr("dx", 5));
    }
    this.stockGroup.data(e).attr(
      "transform",
      () => `translate(${this.padding},${this.padding})`
    ), this.stockGroup.append("rect").attr("class", "background stock").style("fill", this.colors.stock).attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr("x", (i) => {
      i.x = 0;
      const r = i.x;
      i.x = 0;
      const s = this.getRectangleCoordinate(i, "x") - this.padding;
      return i.x = r, s;
    }).attr("y", (i) => {
      i.y = 0;
      const r = i.y;
      i.y = 0;
      const s = this.getRectangleCoordinate(i, "y") - this.padding;
      return i.y = r, s;
    }), this.stock = this.stockGroup.append("rect").attr("width", (i) => this.getWidthAttribute(i)).attr("height", (i) => this.getHeightAttribute(i)).attr(
      "x",
      (i) => this.getRectangleCoordinate(i, "x") - this.padding
    ).attr(
      "y",
      (i) => this.getRectangleCoordinate(i, "y") - this.padding
    ).attr("class", "stock-pattern").style("fill", (i) => i != null && i.grain ? `url(#grain-${i.grain.toLowerCase()})` : "url(#stripes)");
  }
  getWidthAttribute(t) {
    return this.xScale(t.l) - this.padding;
  }
  getHeightAttribute(t) {
    return this.yScale(t.w) - this.padding;
  }
  //init or update the shapes
  initShapes(t, e) {
    var i, r, s;
    if (this.resetShapes(), !(!t || !t.length || !this.elWidth)) {
      if (this.numUniqueShapes = e.filter((o) => !o.duplicate).length, this.shapeColorScale.domain([0, this.numUniqueShapes]), (i = this == null ? void 0 : this.vueComponent) != null && i.gs) {
        Je.call(this.vueComponent, ["shapeColors"], {});
        for (let o = t.length; o--; ) {
          const a = t[o];
          a.parentID && Ye.call(this.vueComponent, ["shapeColors", a.parentID]) || a.parentID && Je.call(this.vueComponent, ["shapeColors", a.parentID], ka(this.shapeColorScale(parseInt(a.parentID) - 1)).formatHex());
        }
      }
      if (this.env === "development") {
        let o = 1 / 0, a = -1 / 0;
        for (const u of t) {
          const d = (r = u == null ? void 0 : u.bestScore) == null ? void 0 : r.total;
          if (d !== 0 && d !== null && d !== void 0) {
            o = d, a = d;
            break;
          }
        }
        const l = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p === 0 || p === null || p === void 0 ? u : p < u ? p : u;
        }, o), h = t.reduce((u, d) => {
          var f;
          const p = (f = d == null ? void 0 : d.bestScore) == null ? void 0 : f.total;
          return p == null ? u : p > u ? p : u;
        }, a);
        this.scoreColorScale = De.scaleSequential([An(251, 224, 255), An(122, 0, 138)]).domain([l, h]);
      }
      if (!t || !t.length || (this.shapeWrappers = this.shapeGroup.selectAll("g").data(t).join("g").attr("class", "shape-group"), !this.shapeWrappers.size())) return !1;
      if (this.shapes = this.shapeWrappers.append("rect").attr("class", "shape").attr("fill", (o) => this.getShapeColor(o)).attr("stroke-width", () => this.env === "development" ? 3 : 0).attr("width", (o) => this.getWidthAttribute(o)).attr("height", (o) => this.getHeightAttribute(o)), this.main) {
        const o = [];
        t.forEach((a) => {
          if (a != null && a._banding)
            for (const [l, h] of Object.entries(a._banding)) {
              if (!h || ["a", "b", "c", "d"].includes(l)) continue;
              let u = l;
              if (a.rot)
                switch (l) {
                  case "x1":
                    u = "y1";
                    break;
                  case "x2":
                    u = "y2";
                    break;
                  case "y1":
                    u = "x2";
                    break;
                  case "y2":
                    u = "x1";
                    break;
                }
              switch (u) {
                case "x1":
                  o.push({
                    x1: a.x,
                    x2: a.x,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x1"
                  });
                  break;
                case "x2":
                  o.push({
                    x1: a.x + a.l,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y + a.w,
                    type: "x2"
                  });
                  break;
                case "y1":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y,
                    y2: a.y,
                    type: "y1"
                  });
                  break;
                case "y2":
                  o.push({
                    x1: a.x,
                    x2: a.x + a.l,
                    y1: a.y + a.w,
                    y2: a.y + a.w,
                    type: "y2"
                  });
                  break;
              }
            }
        }), this.bandingWrappers = this.bandingGroup.selectAll("g").data(o).join("line").attr("class", "banding").attr(
          "x1",
          (a) => this.xPositionScale(a.x1) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "x2",
          (a) => this.xPositionScale(a.x2) + this.getBandingAdjustment(a.type, "x")
        ).attr(
          "y1",
          (a) => this.yPositionScale(a.y1) + this.getBandingAdjustment(a.type, "y")
        ).attr(
          "y2",
          (a) => this.yPositionScale(a.y2) + this.getBandingAdjustment(a.type, "y")
        ).attr("stroke-width", 2).attr("stroke", "white"), this.shapeIDText = this.shapeWrappers.append("text").attr("class", "shape-text id").text((a) => {
          var l, h;
          if (this.env === "development")
            switch (this.debug) {
              case "guillotine": {
                const u = a.guillotineData.myStripDirection, d = a.addedAsGroup;
                let p = "";
                return u === "l" ? p = `→ ${a.parentID}` : u === "w" && (p = `↑ ${a.parentID}`), (h = a == null ? void 0 : a.priotity) != null && h[(l = a == null ? void 0 : a.stock) == null ? void 0 : l.parentID] && (p += "P"), d && (p += "G"), p.length ? p : this.shapeNameText;
              }
              case "groups":
                {
                  const u = a.addedAsGroup;
                  if (u) return u.split(".")[0].toUpperCase();
                }
                break;
              case "positions":
                return a.id;
            }
          return a.parentID ? a.parentID : a.getParentID();
        }).classed("hidden", (a, l, h) => {
          const u = h[l].getBBox();
          return u.width >= this.measurementScale(a.l) || u.height >= this.yScale(a.w) - this.padding;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeNameText = this.shapeWrappers.append("text").attr("class", "shape-text name").text((a) => !(a != null && a.name) || typeof (a == null ? void 0 : a.name) != "string" ? null : a.name.toUpperCase().trim()).call(this.trimNameToFit, this).classed("hidden", (a, l, h) => h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 40).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeLengthText = this.shapeWrappers.append("text").attr("class", "shape-text length").text((a) => this.debug === "guillotine" ? "" : te(
          a.l,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          var d;
          return this.app ? this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50 : ((d = a == null ? void 0 : a.stock) == null ? void 0 : d.type) === "linear" ? !1 : h[l].getBBox().width >= this.measurementScale(a.l) || this.measurementScale(a.w) < 30;
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text), this.shapeWidthText = this.shapeWrappers.append("text").attr("class", "shape-text width").text((a) => this.debug === "guillotine" ? "" : te(
          a.w,
          this.units,
          this.decimalPlaces,
          !1,
          this.fractionRoundTo
        )).classed("hidden", (a, l, h) => {
          if (this.app)
            return this.measurementScale(a.l) < 50 || this.measurementScale(a.w) < 50;
          const u = h[l].getBBox();
          return this.measurementScale(a.l) < 30 || u.height >= this.measurementScale(a.w);
        }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      }
      (this.main || this.app) && !((s = this == null ? void 0 : this.options) != null && s.disableClick) && (this.shapes.on("mousedown", (o, a) => {
        var l, h, u, d, p;
        if (this.moving) return !1;
        if (this.env === "development") {
          if (console.clear(), a) {
            let f = ["id", "placementOrder", "priority", "addedAsGroup", "bestScore.score"];
            this.debug === "guillotine" ? f = [
              "id",
              "placementOrder",
              "priority",
              "guillotineData.myPhase",
              "guillotineData.myStripDirection",
              "guillotineData.myStripParent",
              "guillotineData.firstShape",
              "addedAsGroup"
            ] : this.debug === "groups" ? f = [
              "id",
              "addedAsGroup"
            ] : this.debug === "score" && (f = [
              "id",
              "bestScore.score"
            ]), console.table(f.reduce((g, y) => {
              const _ = Wg(a, y);
              return g[y] = Array.isArray(_) ? _.join(", ") : _, g;
            }, {}));
          }
          if (this.debug === "guillotine") {
            this.shapeWrappers.selectAll(".highlight-a").classed("highlight-a", !1), this.shapeWrappers.selectAll(".highlight-b").classed("highlight-b", !1), this.shapeWrappers.selectAll(".highlight-c").classed("highlight-c", !1);
            const f = (l = a.guillotineData) == null ? void 0 : l.myStripParent, g = (u = (h = t.find((y) => y.id === f)) == null ? void 0 : h.guillotineData) == null ? void 0 : u.myStripParent;
            f && this.shapeWrappers.filter((b) => b.id === f || b.addedAsGroup === f).select("rect").classed("highlight-a", !0), g && this.shapeWrappers.filter((b) => b.id === g || b.addedAsGroup === f).select("rect").classed("highlight-b", !0);
          }
        }
        if (this.app || this.embed) {
          const f = {
            name: a.name,
            id: a.id,
            x: a.x,
            y: a.y,
            l: a.l,
            w: a.w,
            banding: a != null && a.banding && typeof a.banding == "object" ? a.banding : null,
            rot: a.rot,
            stock: (d = a == null ? void 0 : a.stock) == null ? void 0 : d.id,
            color: (p = this.getShapeColor(a)) == null ? void 0 : p.toString(),
            notes: a == null ? void 0 : a.notes
          }, g = new CustomEvent("partClick", {
            detail: f
          });
          if (this.env === "development" && console.log(f), this.htmlEl.dispatchEvent(g), this.app) return !1;
        }
        if (this.device === "desktop" && (this.resetCutMeasurementAxes(), this.addShapeAxes(a)), this.moveMode) {
          const f = Pl.call(this.vueComponent, "partsBin");
          f && f.addToPartBin(a);
        } else
          this.findShape(a.id);
      }), !this.app && !this.hasTouch && this.shapes.on(
        "mouseover",
        (o) => {
          this != null && this.moveMode && this.moving || (De.select(o.target).classed("hover", !0), De.select(o.target).classed("selected") || De.select(o.target).style(
            "fill",
            this.colors.partHover.toString()
          ));
        },
        {
          passive: !0
        }
      ).on(
        "mouseout",
        (o, a) => {
          var l;
          De.select(o.target).classed("hover", !1), De.select(o.target).classed("selected") || De.select(o.target).style(
            "fill",
            (l = this.getShapeColor(a)) == null ? void 0 : l.toString()
          );
        },
        {
          passive: !0
        }
      )), this.setShapePosition();
    }
  }
  findShapeElement(t) {
    const e = this.shapeWrappers.filter((i) => i.id === t);
    return e.empty() ? null : e.node();
  }
  findShape(t) {
    const e = this.findShapeElement(t), i = Ye.call(this.vueComponent, ["shapeList"]).find((r) => r.id === t);
    e && this.selectShape(e, i);
  }
  selectShape(t, e) {
    Je.call(this.vueComponent, ["examineShape"], e), this.shapes.classed("selected", !1), this.shapes.style("fill", (r) => this.getShapeColor(r));
    const i = De.select(t).select("rect");
    i && (i.classed("selected", !0), i.style("fill", this.colors.partSelected.toString()));
  }
  /**
      * update SHAPE visibility - used for replay
      * @param {Number} number
      */
  updateShapeVisibility(t) {
    var e;
    (e = this == null ? void 0 : this.shapeWrappers) == null || e.style("visibility", (i) => (i == null ? void 0 : i.placementOrder) >= t ? "hidden" : "visible");
  }
  isCutComplete(t, e, i) {
    return t.guillotineData.parentSegmentID === e && i && t.guillotineData.segmentCutOrder < i;
  }
  isCutInsideSegment(t, e) {
    var i;
    return ((i = t.guillotineData) == null ? void 0 : i.parentSegmentID) !== null && !(t != null && t.isTrim) ? t.guillotineData.parentSegmentID === e : !1;
  }
  //update CUT visibility
  updateCutVisibility(t, e = null, i = "") {
    var h, u, d, p, f, g, y, _, b;
    if (e === null || t == null || this != null && this.cuts.empty()) return;
    this.resetShapeAxes(), this.resetCutMeasurementAxes(), De.select(this.cuts.nodes()[e].parentNode).raise();
    const r = (h = t.guillotineData) == null ? void 0 : h.parentSegmentID, s = this.getHalfBladeWidth(t.stock), o = t.dimension === "l" ? "y" : "x", a = (u = t == null ? void 0 : t.stock) == null ? void 0 : u.trim, l = i === "ptx" ? "ptxOrder" : "order";
    if ((((d = t == null ? void 0 : t.stock) == null ? void 0 : d.cutType) === "guillotine" || ((p = t == null ? void 0 : t.stock) == null ? void 0 : p.cutType) === "beam") && r !== null && typeof r < "u") {
      if (this.cuts.style("visibility", (v) => typeof t.guillotineData[l] == "number" && v.guillotineData[l] <= t.guillotineData[l] || !i && v.guillotineData.parentSegmentID === r ? "visible" : "hidden"), this.cuts.classed("highlight", (v) => t.stock.cutType === "guillotine" && v.isTrim ? v.type === t.type : v.guillotineData[l] === t.guillotineData[l]), this.cuts.classed("ptx-dummy", (v) => v.guillotineData.ptxDummyCut), !i) {
        const v = (f = t == null ? void 0 : t.guillotineData) == null ? void 0 : f.segmentCutOrder;
        if (v == null)
          return;
        this.cuts.classed("completed", (C) => this.isCutComplete(C, r, v)), this.cuts.classed("inside-segment", (C) => this.isCutInsideSegment(C, r));
        let A, L;
        const O = this.getCutSegments(t);
        if (O === !1) return;
        const R = (y = O == null ? void 0 : O.siblings) == null ? void 0 : y[(g = O.main) != null && g.hasBeamTrim ? v - 1 : v];
        R && ((t == null ? void 0 : t.dimension) === "l" ? A = [
          [
            R.y,
            R.y + R.w
          ],
          [
            t.y1 + s,
            (O == null ? void 0 : O.main.y) + (O == null ? void 0 : O.main.w)
          ]
        ] : (t == null ? void 0 : t.dimension) === "w" && (A = [
          [
            R.x,
            R.x + R.l
          ],
          [
            t.x1 + s,
            (O == null ? void 0 : O.main.x) + (O == null ? void 0 : O.main.l)
          ]
        ]), (t == null ? void 0 : t.dimension) === "l" ? L = [(_ = t == null ? void 0 : t.distances) == null ? void 0 : _.bottom, t == null ? void 0 : t.distances.top] : (t == null ? void 0 : t.dimension) === "w" && (L = [t == null ? void 0 : t.distances.left, (b = t == null ? void 0 : t.distances) == null ? void 0 : b.right]), this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(A, L, o));
      }
    } else {
      this.cuts.style("visibility", (A, L) => L <= e ? "visible" : "hidden");
      let v;
      if ((t == null ? void 0 : t.dimension) === "l" ? v = [
        [0 + (a.y1 ?? 0), t.y1 - s],
        [
          t.y1 + s,
          t.stock.w - (a != null && a.y2 ? a.y2 : 0)
        ]
      ] : (t == null ? void 0 : t.dimension) === "w" && (v = [
        [0 + (a.x1 ?? 0), t.x1 - s],
        [
          t.x1 + s,
          t.stock.l - (a != null && a.x2 ? a.x2 : 0)
        ]
      ]), v != null && v.length) {
        const A = [
          v[0][1] - v[0][0],
          v[1][1] - v[1][0]
        ];
        this.device === "desktop" && !t.isTrim && this.addCutMeasurementAxes(v, A, o);
      }
      this.cuts.classed(
        "highlight",
        (A, L) => L === e
      );
    }
    this.cuts.attr("stroke-width", (v, A) => {
      var R;
      let L = Math.ceil(this.measurementScale(this.getBladeWidth(v.stock)));
      const O = (R = t == null ? void 0 : t.guillotineData) == null ? void 0 : R.segmentCutOrder;
      return (this.isCutComplete(v, r, O) || this.isCutInsideSegment(v, r)) && (L += 1), A === e && Math.ceil(this.measurementScale(this.getBladeWidth(v.stock))) < 5 && (L = 5), L;
    });
  }
  //highlight a specific cut (by order or index), segments and related measurements
  showCut(t, e = null, i = "") {
    var h;
    if (e === null) return !1;
    if (this.updateCutVisibility(t, e, i), i === "ptx") {
      this.resetSegments();
      return;
    }
    const r = this.getCutSegments(t);
    if (r === !1) return;
    const { main: s, siblings: o } = r;
    if (!((h = t == null ? void 0 : t.guillotineData) != null && h.parentSegmentID))
      return this.initSegments([s]);
    const a = o == null ? void 0 : o.length;
    let l = [];
    if (a) {
      for (let d = a; d--; )
        o[d] && (o[d].completed = !1);
      if (t.guillotineData.segmentCutOrder === void 0 || t.guillotineData.segmentCutOrder === null)
        return;
      const u = t.guillotineData.segmentCutOrder;
      for (let d = 0; d < a; d++)
        d < u && (o[d].completed = !0);
      l.push(...o), l = l.filter((d) => d);
    }
    l.length && (this.resetSegments(), this.initSegments(l));
  }
  /**
      * toggle the visibility of the shapes
      * @param {Boolean} show
      */
  toggleShapes(t = !1) {
    t ? (this.shapeGroup.attr("display", "block"), this.bandingGroup.attr("display", "block")) : (this.shapeGroup.attr("display", "none"), this.bandingGroup.attr("display", "none"));
  }
  /**
      * add measurements to an axis
      * @param {Array} measurements array of arrays
      * @param {Array} values array of values
      * @param {String} axis x | y
      */
  addCutMeasurementAxes(t, e, i) {
    !i || !(t != null && t.length) || t.forEach((r, s) => {
      const o = r[0], a = r[1];
      if (i === "x") {
        const l = De.scaleLinear().domain([o, a]).range([
          this.xPositionScale(o),
          this.xPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(0, ${this.h - this.padding + this.axisSpacing})`
        ).attr("class", "axis measurement x").call(De.axisBottom(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ), this.cutMeasurementXAxes.push(u);
      } else {
        const l = De.scaleLinear().domain([o, a]).range([
          this.yPositionScale(o),
          this.yPositionScale(a)
        ]), h = (l.domain()[1] - l.domain()[0]) / 2 + l.domain()[0], u = this.axisGroup.append("g").attr(
          "transform",
          `translate(${this.padding - this.axisSpacing}, 0)`
        ).attr("class", "axis measurement y").call(De.axisLeft(l).tickValues([h]).tickSize(4).tickFormat(() => this.formatNumber(e[s])));
        u.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (d, p, f) => f[p].getBBox().height + 10
        ).attr(
          "dx",
          (d, p, f) => f[p].getBBox().width / 4
        ).attr(
          "transform",
          (d, p, f) => "rotate(90) translate(" + f[p].getBBox().width / 4 + ")"
        ), this.cutMeasurementYAxes.push(u);
      }
    });
  }
  /**
      * add the shape axes
      * @param {Shape} shape
      */
  addShapeAxes(t) {
    var l;
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
    const e = t.x, i = t.x + t.l, r = De.scaleLinear().domain([e, i]).range([this.xPositionScale(e), this.xPositionScale(i)]), s = t.y, o = t.y + t.w, a = De.scaleLinear().domain([s, o]).range([this.yPositionScale(s), this.yPositionScale(o)]);
    this.shapeXAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(0, ${this.h - this.padding + this.axisSpacing})`
    ).attr("class", "axis shape x").call(De.axisBottom(r).tickValues(r.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeXAxis.selectAll("text").attr("dx", (h, u, d) => {
      const p = d[u];
      if (p === null) return;
      const f = p.getBBox();
      return u === 0 ? -f.width / 2 : f.width / 2;
    }), ((l = t == null ? void 0 : t.stock) == null ? void 0 : l.type) !== "linear" && (this.shapeYAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(${this.padding - this.axisSpacing}, 0)`
    ).attr("class", "axis shape y").call(De.axisLeft(a).tickValues(a.domain()).tickSize(4).tickFormat(this.formatNumber)), this.shapeYAxis.selectAll("text").attr("x", 0).attr("y", 0).attr(
      "dy",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.height) + 2;
      }
    ).attr(
      "dx",
      (h, u, d) => {
        var p, f;
        return ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2;
      }
    ).attr("transform", (h, u, d) => {
      var p, f, g, y, _, b, v, A;
      return this.flipY ? u === 0 ? "rotate(90) translate(-" + ((f = (p = d[u]) == null ? void 0 : p.getBBox()) == null ? void 0 : f.width) / 2 + ")" : "rotate(90) translate(" + ((y = (g = d[u]) == null ? void 0 : g.getBBox()) == null ? void 0 : y.width) / 2 + ")" : u === 0 ? "rotate(90) translate(" + ((b = (_ = d[u]) == null ? void 0 : _.getBBox()) == null ? void 0 : b.width) / 2 + ")" : "rotate(90) translate(-" + ((A = (v = d[u]) == null ? void 0 : v.getBBox()) == null ? void 0 : A.width) / 2 + ")";
    }));
  }
  getBandingAdjustment(t, e) {
    switch (t) {
      case "y1":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? 1 : -1;
        break;
      case "y2":
        if (e === "x") return 0;
        if (e === "y") return this.flipY ? -1 : 1;
        break;
      case "x1":
        if (e === "x") return this.flipX ? -1 : 1;
        if (e === "y") return 0;
        break;
      case "x2":
        if (e === "x") return this.flipX ? 1 : -1;
        if (e === "y") return 0;
        break;
    }
    return 0;
  }
  getRectangleCoordinate(t, e, i, r) {
    let s;
    if (e === "x") {
      let o;
      switch (i) {
        case "center":
          o = this.xPositionScale(t.x + t.l / 2), r && (o += r);
          break;
        case "right":
          o = this.xPositionScale(t.x + t.l), r && (o -= r);
          break;
        case "left":
        default:
          o = this.xPositionScale(this.flipX ? t.x - t.l : t.x), r && (o -= r);
      }
      s = o;
    } else if (e === "y") {
      let o;
      switch (i) {
        case "center":
          o = this.yPositionScale(t.y + t.w / 2), r && (o += r);
          break;
        case "bottom":
          o = this.yPositionScale(this.flipY ? t.y + t.w : t.y), r && (o += r);
          break;
        case "top":
        default:
          o = this.yPositionScale(this.flipY ? t.y : t.y + t.w), r && (o -= r);
      }
      s = o;
    }
    return s;
  }
  getRotatedSide(t) {
    switch (t) {
      case "x1":
      case "l1":
        return "w1";
      case "x2":
      case "l2":
        return "w2";
      case "y1":
      case "w1":
        return "l2";
      case "y2":
      case "w2":
        return "l1";
    }
  }
  /**
      * update the position of the shapes and the content within
      */
  setShapePosition() {
    if (!this.shapes) return !1;
    this.shapes.attr("x", (t) => this.getRectangleCoordinate(t, "x")).attr("y", (t) => this.getRectangleCoordinate(t, "y")).attr("width", (t) => this.getWidthAttribute(t)).attr("height", (t) => this.getHeightAttribute(t)), this.main && (this.shapeIDText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t) => this.getRectangleCoordinate(t, "y", "center")).attr("dy", 1), this.shapeNameText && this.shapeNameText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "bottom",
      -(i[e].getBBox().height / 2 + 1)
    )), this.shapeLengthText.attr("x", (t) => this.getRectangleCoordinate(t, "x", "center")).attr("y", (t, e, i) => this.getRectangleCoordinate(
      t,
      "y",
      "top",
      -(i[e].getBBox().height / 2 + 2)
    )), this.shapeWidthText.attr(
      "transform",
      (t, e, i) => `translate(${this.getRectangleCoordinate(
        t,
        "x",
        "left",
        -(i[e].getBBox().height / 2 + 2)
      )},${this.getRectangleCoordinate(t, "y", "center")}) ${this.device === "mobile" ? "rotate(90)" : "rotate(-90)"}`
    ));
  }
  //init or update the cuts
  initCuts(t) {
    if (this.resetCuts(), !t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.cuts = this.cutGroup.selectAll("line").data(t).join("line").attr("class", "cut").attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    }).attr("x1", (e) => this.xPositionScale(e.getVisCoords("x1"))).attr("x2", (e) => this.xPositionScale(e.getVisCoords("x2"))).attr("y1", (e) => this.yPositionScale(e.getVisCoords("y1"))).attr("y2", (e) => this.yPositionScale(e.getVisCoords("y2"))).classed("trim", (e) => e.isTrim);
  }
  //init or update the segments
  initSegments(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetSegments(), this.segments = this.segmentGroup.selectAll("rect").data(t).join("rect").attr("class", "segment").style("opacity", (e) => {
      if ((e == null ? void 0 : e.offcut) === !0) return 0.5;
    }).classed("offcut", (e) => e.offcut).classed("merged", (e) => e.merged).classed("near", (e) => e.shapePosition === "near").classed("far", (e) => e.shapePosition === "far").classed("completed", (e) => e.completed).attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.segmentGroup.selectAll("text").data(t).join("text").attr("class", "segment-text").attr("x", (e) => this.getRectangleCoordinate(e, "x", "center")).attr("y", (e) => this.getRectangleCoordinate(e, "y", "center")).attr("text-anchor", "middle").text((e) => {
      if (this.env !== "development" || e.offcut) return null;
      if (e.cutDirection === "l")
        return this.env === "development" ? `→ ${e.id}` : "→";
      if (e.cutDirection === "w")
        return this.env === "development" ? `↑ ${e.id}` : "↑";
    }).attr("dominant-baseline", "middle"), !this.app && this.env === "development" && this.segments.on("mousedown", function(e, i) {
      const r = structuredClone(i);
      console.log([
        "id",
        "x",
        "y",
        "l",
        "w",
        "cutDirection",
        "cutPreference"
      ].reduce((o, a) => (o[a] = Wg(r, a), o), {}));
    });
  }
  initGroups(t) {
    if (!t || !(t != null && t.length) || !this.main || !this.elWidth)
      return !1;
    this.resetGroups(), this.groups = this.groupGroup.selectAll("rect").data(t).join("rect").attr("class", "group").attr("x", (e) => this.getRectangleCoordinate(e, "x")).attr("y", (e) => this.getRectangleCoordinate(e, "y")).attr("width", (e) => this.getWidthAttribute(e)).attr("height", (e) => this.getHeightAttribute(e)), this.groupGroup.attr("display", "block");
  }
  //get relevant segments for a specific cut
  getCutSegments(t) {
    var o, a, l, h;
    const e = (o = t == null ? void 0 : t.guillotineData) == null ? void 0 : o.parentSegmentID, i = ((l = (a = this.vueComponent) == null ? void 0 : a.gs) == null ? void 0 : l.activeSegments) ?? ((h = this.vueComponent) == null ? void 0 : h.activeSegments);
    if (!i.length) return !1;
    let r;
    if (e ? r = i.find((u) => u.id === e) : r = i.find((u) => u.segmentType === "root"), r === void 0) return !1;
    const s = r == null ? void 0 : r.children;
    if (s != null && s.length) {
      const u = s.map((p) => {
        const f = i.find((g) => g.x === p.x && g.y === p.y && g.l === p.l && g.w === p.w);
        return f !== void 0 ? f : null;
      }).filter((p) => p !== null);
      return {
        main: r,
        siblings: u
      };
    }
    return !1;
  }
  /**
      * toggle the visibility of the segments
      * @param {Boolean} show
      */
  toggleSegments(t = !0) {
    t ? this.segmentGroup.attr("display", "block") : this.segmentGroup.attr("display", "none");
  }
  /**
      * show a list of possible movement positions
      */
  initPositions(t, e) {
    if (!e || !t || !this.main) return !1;
    let i;
    if (e.trimDimensions(), !t.willItFit(e, t.rot)) return !1;
    e.removeTrim();
    const r = Ye.call(this.vueComponent, ["shapeList"]).filter((l) => {
      var h;
      return l.added && ((h = l == null ? void 0 : l.stock) == null ? void 0 : h.id) === e.id;
    }), s = By(
      null,
      r,
      e
    );
    let o;
    if (e.cutType === "efficiency") {
      if (this.env === "development") {
        const l = Y0(r, e);
        this.positionGroup.selectAll("line").remove();
        const h = l.flatMap((u) => Object.values(u.rays));
        this.positionGroup.selectAll("line").data(h).enter().append("line").attr("x1", (u) => this.xPositionScale(u.x1)).attr("x2", (u) => this.xPositionScale(u.x2)).attr("y1", (u) => this.yPositionScale(u.y1)).attr("y2", (u) => this.yPositionScale(u.y2)).attr("stroke", "rgba(245, 66, 227, 0.5)").attr("stroke-width", 2).on("mousedown", (u, d) => console.log(d));
      }
      o = jy(
        e,
        r
      );
    }
    const a = new Po();
    for (const l of s.toArray()) {
      const h = K0(t, l, e);
      h && a.addPoints(h.toArray());
    }
    if (o) {
      const l = o.toArray();
      for (const h of l) {
        const u = Ry(t, h, e);
        u && a.addPoints(u.toArray());
      }
    }
    e.cutType === "efficiency" ? ([
      new Wn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Wn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0)),
      new Wn(
        e.l - t.l - (e.trim.x2 ?? 0),
        0 + (e.trim.y1 ?? 0)
      ),
      new Wn(
        0 + (e.trim.x1 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      ),
      new Wn(
        e.l - t.l - (e.trim.x2 ?? 0),
        e.w - t.w - (e.trim.y2 ?? 0)
      )
    ].forEach((l) => a.addPoint(l)), i = a.toArray()) : (a.addPoint(new Wn(0 + (e.trim.x1 ?? 0), 0 + (e.trim.y1 ?? 0))), i = a.toArray());
    for (let l = i.length; l--; ) {
      const h = i[l];
      t.x = h.x, t.y = h.y;
      for (const u of r)
        if (this.collision(t, u, e)) {
          i.splice(l, 1);
          break;
        }
    }
    return this.positionGroup.selectAll("rect").data(i).join("rect").attr("data-id", (l, h) => h).attr("class", "shape ghost").attr("x", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("y", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y"))).attr("width", this.getWidthAttribute(t)).attr("height", this.getHeightAttribute(t)).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = Pl.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), this.hasTouch || this.positionGroup.selectAll("rect").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), De.select(this).classed("hover", !0), De.select(this).raise();
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), De.select(this).classed("hover", !1);
      },
      {
        passive: !0
      }
    ), this.dotGroup.selectAll("circle").data(i).join("circle").attr("data-id", (l, h) => h).attr("class", "dot").classed("raycast", (l) => this.env !== "development" ? !1 : l.raycast).attr("cx", (l) => (t.x = l.x, this.getRectangleCoordinate(t, "x"))).attr("cy", (l) => (t.y = l.y, this.getRectangleCoordinate(t, "y", "bottom"))).attr("r", 8).on("mousedown", (l, h) => {
      l.stopPropagation();
      const u = Pl.call(this.vueComponent, "partsBin");
      u && u.moveShape(
        l.currentTarget,
        t,
        h
      );
    }), t.x = 0, t.y = 0, this.hasTouch || this.dotGroup.selectAll("circle").on(
      "mouseover",
      function(l) {
        l.stopPropagation(), De.select(this).classed("hover", !0);
        const h = De.select(this).attr("data-id"), u = De.select(`.ghost[data-id="${h}"]`);
        u.raise(), u.classed("highlight", !0);
      },
      {
        passive: !0
      }
    ).on(
      "mouseout",
      function(l) {
        l.stopPropagation(), De.select(this).classed("hover", !1);
        const h = De.select(this).attr("data-id");
        De.select(`.ghost[data-id="${h}"]`).classed(
          "highlight",
          !1
        );
      },
      {
        passive: !0
      }
    ), !!(i != null && i.length);
  }
  /**
      * show a list of placement positions
      */
  initPlacementPositions(t) {
    if (!(this.env !== "development" || this.debug !== "positions")) {
      if (!(t != null && t.length)) return !1;
      this.placementPositionGroup.selectAll("circle").data(t).join("circle").attr("data-id", (e, i) => i).attr("class", "dot").attr("cx", (e) => this.xPositionScale(e.x)).attr("cy", (e) => this.yPositionScale(e.y)).attr("r", 3).on("mousedown", (e) => {
        e.stopPropagation();
      });
    }
  }
  /**
      * toggle the visibility of the cuts
      * @param {Boolean} show
      */
  toggleCuts(t = !0) {
    t ? this.cutGroup.attr("display", "block") : this.cutGroup.attr("display", "none");
  }
  clearSelection() {
    var t;
    this != null && this.shapes && (this.shapes.classed("selected", !1), this.shapes.classed("hover", !1), this.shapes.style("fill", (e) => this.getShapeColor(e))), this != null && this.cuts && (this.cuts.classed("selected", !1), this.cuts.classed("highlight", !1), this.cuts.classed("inside-segment", !1), this.cuts.style("visibility", "visible"), this.cuts.attr("stroke-width", (e) => {
      const i = this.measurementScale(this.getBladeWidth(e.stock));
      return i < 1 ? 1 : Math.ceil(i);
    })), (t = this == null ? void 0 : this.shapes) != null && t.length && this.shapes.classed("selected", !1);
  }
  /**
      * add padding
      * this.padding will be 0 when necessary
      * @param {number} value
      */
  addPadding(t) {
    return t + this.padding;
  }
  /**
      * @param {Container} container
      * @returns {number} blade width
      */
  getBladeWidth(t = null) {
    var e, i;
    return jt((e = this == null ? void 0 : this.saw) == null ? void 0 : e.bladeWidth) ? (i = this.saw) == null ? void 0 : i.bladeWidth : jt(t) && t !== null ? t.getBladeWidth() : 0;
  }
  getHalfBladeWidth(t = null) {
    const e = this.getBladeWidth(t);
    return e !== void 0 && e > 0 ? e / 2 : 0;
  }
  resetShapes() {
    this.shapeGroup && this.shapeGroup.selectAll("*").remove(), this.bandingGroup && this.bandingGroup.selectAll("*").remove(), this.resetShapeAxes();
  }
  resetShapeAxes() {
    this.shapeXAxis && this.shapeXAxis.remove(), this.shapeYAxis && this.shapeYAxis.remove();
  }
  resetStock() {
    this.stockGroup && this.stockGroup.selectAll("*").remove(), this.axisGroup && this.axisGroup.selectAll("*").remove(), this.resetStockAxes();
  }
  resetStockAxes() {
    this.xAxis && this.xAxis.remove(), this.yAxis && this.yAxis.remove();
  }
  resetCuts() {
    this.cutGroup && this.cutGroup.selectAll("*").remove(), this.resetCutMeasurementAxes();
  }
  resetSegments() {
    this.segmentGroup && this.segmentGroup.selectAll("*").remove();
  }
  resetGroups() {
    this.groupGroup && this.groupGroup.selectAll("*").remove();
  }
  resetCutMeasurementAxes() {
    var t, e;
    (t = this.cutMeasurementXAxes) != null && t.length && (this.cutMeasurementXAxes.forEach((i) => i.remove()), this.cutMeasurementXAxes.length = 0), (e = this.cutMeasurementYAxes) != null && e.length && (this.cutMeasurementYAxes.forEach((i) => i.remove()), this.cutMeasurementYAxes.length = 0);
  }
  resetPositions() {
    this.positionGroup && this.positionGroup.selectAll("*").remove(), this.dotGroup && this.dotGroup.selectAll("*").remove();
  }
  resetPlacementPositions() {
    this.placementPositionGroup && this.dotGroup.selectAll("*").remove();
  }
  reset() {
    this.resetPositions(), this.resetPlacementPositions(), this.resetShapes(), this.resetStock(), this.resetCuts(), this.resetSegments();
  }
  /**
      * detect collision - required for move mode
      * @param {object} thisShape
      * @param {object} testShape
      * @param {object} container
      * @returns {boolean} true if collision
      */
  collision(t, e, i) {
    if (t.id === e.id)
      throw new Error("collision comparing to self");
    return (
      // 1 left
      t.x < e.x + e.l + this.getBladeWidth(i) && // 2 right
      t.x + t.l + this.getBladeWidth(i) > e.x && // 3 bottom
      t.y < e.y + e.w + this.getBladeWidth(i) && // 4 top
      t.y + t.w + this.getBladeWidth(i) > e.y
    );
  }
}
function Wg(n, t) {
  return t.split(".").reduce((e, i) => e[i], n);
}
function ZS(n = "issues", t, e, i = null) {
  var s;
  if (!t || !((s = t == null ? void 0 : t[n]) != null && s.length)) return !1;
  if (t[n].map((o) => o.field).flat().includes(e))
    return i ? t[n].map((a) => a.subField).flat().includes(i) : !0;
}
function QS(n) {
  if (!ga(n)) return !1;
  const t = Object.getOwnPropertyDescriptor(n, "value");
  return (t == null ? void 0 : t.configurable) === !1;
}
function Je(n, t) {
  var l;
  if (!(n != null && n[0]) || !this) return !1;
  const e = (h) => ga(h) ? QS(h) ? "shallowRef" : "ref" : bp(h) ? "reactive" : !E2(h) && typeof h == "object" ? "raw" : "ref";
  let i, r, s;
  if ("gs" in this && typeof ((l = this.gs) == null ? void 0 : l[n[0]]) < "u")
    i = this.gs, r = wo(this.gs, n), s = n[n.length - 1];
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    i = this, r = wo(this, n), s = n[n.length - 1];
  else
    return !1;
  if (ga(r))
    return r.value = t, !0;
  const o = e(r || t);
  let a = t;
  switch (o) {
    case "shallowRef":
      a = lo(t);
      break;
    case "raw":
      typeof t == "object" && t !== null && t.constructor !== Object && t.constructor !== Array ? a = gl(t) : Array.isArray(t) ? a = gl(t.map((h) => typeof h == "object" && h !== null && h.constructor !== Object ? h : JSON.parse(JSON.stringify(h)))) : a = typeof t == "object" ? gl(JSON.parse(JSON.stringify(t))) : gl(t);
      break;
    case "ref":
      ga(t) ? a = t : a = _e(t);
      break;
    case "reactive":
      a = bp(t) ? t : es(t);
      break;
  }
  if (n.length > 1) {
    const h = n.slice(0, -1), u = wo(i, h);
    if (ga(u))
      return kg(u.value, s, a), !0;
  }
  return kg(i, n, a), !0;
}
function Ye(n) {
  var e;
  if (!(n != null && n[0]) || !this) return null;
  let t;
  if ("gs" in this && typeof ((e = this == null ? void 0 : this.gs) == null ? void 0 : e[n[0]]) < "u")
    t = wo(this.gs, n);
  else if (typeof (this == null ? void 0 : this[n[0]]) < "u")
    t = wo(this, n);
  else
    return console.warn("getData path not found", n), null;
  return ga(t) || t && typeof t == "object" && "value" in t ? t.value : t;
}
function nA(n) {
  var t;
  if (!(n != null && n[0])) return null;
  if ("optionsStore" in this && typeof ((t = this == null ? void 0 : this.optionsStore) == null ? void 0 : t[n[0]]) < "u")
    return wo(this.optionsStore, n);
  if (typeof (this == null ? void 0 : this[n[0]]) < "u") return wo(this, n);
}
function vc(n) {
  n.queue = 0, n.stockCount = 0, n.shapeCount = 0, n.resultCount = 0, n.complete = !1;
}
function t6(n, t) {
  return n != null && n.length ? n.find((e) => e.id === t) : null;
}
function e6(n, t, e = "") {
  if (!(n != null && n.length) || !t) return [];
  const i = n.filter((r) => {
    var s, o, a;
    if (e) {
      if (e === "ptx") return (((a = r == null ? void 0 : r.stock) == null ? void 0 : a.id) ?? (r == null ? void 0 : r.stockId)) === t.id;
    } else return (((s = r == null ? void 0 : r.stock) == null ? void 0 : s.id) ?? (r == null ? void 0 : r.stockId)) === t.id && !((o = r == null ? void 0 : r.guillotineData) != null && o.ptxDummyCut);
  });
  return i.sort((r, s) => {
    var o, a;
    return ((o = r == null ? void 0 : r.guillotineData) == null ? void 0 : o.order) - ((a = s == null ? void 0 : s.guillotineData) == null ? void 0 : a.order);
  }), i;
}
function n6(n) {
  return n != null && n.length ? n.filter((t) => t.used === !0) : [];
}
function i6(n = !1) {
  let t = Ye.call(this, ["inputStock"]);
  if (!(t != null && t.length)) return [{ message: "No stock input" }];
  const e = Ye.call(this, ["stockList"]);
  e && (e.length = 0);
  const i = [];
  n && (t = [t[0]]);
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    !(s != null && s.q) && !s.autoAdd && !n || i.push(...this.createStock(s, r));
  }
  return i;
}
function r6() {
  const n = Ye.call(this, ["vis"]);
  if (!n) return;
  const t = Ye.call(this, ["shapeList"]);
  if (!(t != null && t.length)) return !1;
  n.resetPositions(), n.resetShapes();
  const e = Ye.call(this, ["activeShapes"]);
  n.initShapes(e, t);
  const i = Pl.call(this, "PartsBin");
  i && i.clear(!1);
}
function s6() {
  const n = Ye.call(this, ["vis"]);
  if (!n) return;
  const t = Ye.call(this, ["stockList"]);
  if (!(t != null && t.length)) return !1;
  const e = Ye.call(this, ["activeStock"]);
  n.initStock(e);
  const i = Ye.call(this, ["activeCuts"]);
  n.initCuts(i);
  const r = Ye.call(this, ["activeSegments"]);
  n.initSegments(r), n.resetPositions(), typeof this.toggleSegments == "function" && this.toggleSegments(!1), this != null && this.cutMode && (this == null || this.showCut(0));
}
function o6() {
  var t;
  const n = ((t = this == null ? void 0 : this.gs) == null ? void 0 : t.vis) ?? (this == null ? void 0 : this.vis);
  n && (n.clearSelection(), n.resetShapeAxes(), n.resetCutMeasurementAxes(), n.resetPositions());
}
function a6(n) {
  Ye.call(this, ["examineShape"]) && (this.examineShape = null), Je.call(this, ["activeStockId"], n);
}
function Hg() {
  return this != null && this.$parent ? this.$parent : null;
}
function Pl(n, t = 0) {
  var r;
  let e = this;
  for (let s = 0; s < t; s++) {
    if (!Hg.call(e))
      return null;
    e = Hg.call(e);
  }
  const i = (r = e == null ? void 0 : e.$refs) == null ? void 0 : r[n];
  return i || null;
}
function l6(n = void 0) {
  return this.socket = Vu(n, {
    withCredentials: !0,
    //this is required to send passport user data
    autoConnect: !1
  }), this.socket.on("connect", () => {
    Je.call(this, ["connected"], !0);
  }), this.socket.on("maintenance", () => {
    Je.call(this, ["maintenanceMode"], !0), this.socket.disconnect(), this.env === "development" && console.log("SmartCut - maintenance mode flag received from server");
  }), this.socket.on("connect_error", (t) => {
    Je.call(this, ["connected"], !1), console.warn(`SmartCut - socket connect_error: ${t.message}`), typeof alert < "u" && alert("We are having trouble connecting to the server. Please try again later."), this.socket.close();
  }), this.socket.on("message", (t) => console.log(t)), this.socket.on("user", (t) => {
    Je.call(this, ["user"], t);
  }), this.socket.on("queued", () => {
    Je.call(this, ["progress", "queue"], 1);
  }), this.socket.on("jobInProgess", (t) => (alert(`You already have a job in progress, please wait for it to finish

Job ID: ${t}`), !1)), this.socket.on("jobStart", () => Je.call(this, ["progress", "queue"], 2)), this.socket.on("progress", (t) => {
    const e = t.data;
    if (typeof e.shapeCount < "u" && Je.call(this, ["progress", "shapeCount"], e.shapeCount), typeof e.stockCount < "u" && Je.call(this, ["progress", "stockCount"], e.stockCount), !e.stockCount && !e.shapeCount) {
      const i = Ye.call(this, ["progress", "resultCount"]);
      Je.call(this, ["progress", "resultCount"], i + 1);
    }
  }), this.socket.on("upgrade", () => {
    "showUpgradeModal" in this && typeof this.showUpgradeModal == "function" && this.showUpgradeModal(), Je.call(this, ["thinking"], !1);
  }), this.socket.on("error", (t) => {
    var i;
    Je.call(this, ["thinking"], !1);
    const e = Ye.call(this, ["reset"]);
    typeof e == "function" && e(), console.error("SmartCut error:", t), (i = window == null ? void 0 : window.top) == null || i.postMessage(
      {
        type: "scError",
        message: t
      },
      "*"
    ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage(t), typeof this.showModalMessage == "function" && this.showModalMessage({
      heading: "Issue",
      main: t ? `<p>${t}</p>` : "<p>We are having trouble connecting to the server.</p><p>Please try again later and let us know.</p>"
    });
  }), this.socket.on("result", (t) => {
    var l, h, u, d, p, f, g, y, _, b;
    this.socket.disconnect();
    const e = t.result;
    if (Je.call(this, ["metadata"], e.metadata ?? {}), Je.call(this, ["unusableShapes"], e.unusableShapes ?? []), Je.call(this, ["unavailableStock"], e.unavailableStock ?? []), !((l = e.shapeList) != null && l.length) || !((h = e.stockList) != null && h.length)) {
      const v = Ye.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let A = "<p>We did not manage to fit any parts.</p>";
        (u = e == null ? void 0 : e.unusableShapes) != null && u.length ? (A = "<p>No parts were usable.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "Parts unusable",
          main: A,
          buttonText: "Show me",
          buttonCallback: (L) => {
            L.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (A += "<p>Please double check your list.</p>", this.$nextTick(() => {
          this.showModalMessage({
            heading: "Parts unusable",
            main: A
          });
        }));
      }
      return (d = window == null ? void 0 : window.top) == null || d.postMessage(
        {
          type: "scError",
          message: "No parts were added - please double check your list."
        },
        "*"
      ), "showMessage" in this && typeof this.showMessage == "function" && this.showMessage("No parts were added - please double check your list."), Je.call(this, ["thinking"], !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0), !1;
    }
    e.shapeList.find((v) => !v.added) && typeof this.showModalMessage == "function" && this.$nextTick(() => {
      this.showModalMessage({
        heading: "Parts not used",
        main: "<p>We did not use all your parts.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>",
        buttonText: "Show me",
        buttonCallback: (v) => {
          v.showInputPanel(
            "parts",
            "inputs-unusable-parts"
          );
        }
      });
    }), Je.call(this, ["progress", "complete"], !0), Je.call(this, ["jobId"], t == null ? void 0 : t.jobId), typeof this.toggleWidget == "function" && (this.toggleWidget("updateStock", !1), this.toggleWidget("options", !1), this.toggleWidget("offcuts", !1), this.toggleWidget("results", !1), this.toggleWidget("cutlist", !1), this.toggleWidget("export", !1), this.toggleWidget("labels", !1));
    let i;
    e != null && e.saw && (i = new qs(
      e == null ? void 0 : e.saw,
      ((p = e == null ? void 0 : e.saw) == null ? void 0 : p.stockType) ?? ((g = (f = e.stockList) == null ? void 0 : f[0]) == null ? void 0 : g.type)
    ), Je.call(this, ["saw"], i));
    const r = jb({
      saw: i,
      stockList: e.stockList,
      removeScores: !0,
      preventAutoRotation: !0
    });
    Je.call(this, ["stockList"], r);
    const s = Ye.call(this, ["usedStock"]);
    s.length && Je.call(this, ["activeStockId"], s[0].id), Je.call(
      this,
      ["shapeList"],
      qb({
        shapeList: e.shapeList,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.cutList && Je.call(
      this,
      ["cutList"],
      zb({
        cutList: e.cutList,
        stockList: r
      })
    ), e != null && e.segmentList && Je.call(
      this,
      ["segmentList"],
      $b({
        segmentList: e.segmentList,
        stockList: r
      })
    ), e != null && e.offcuts && Je.call(
      this,
      ["offcuts"],
      Wb({
        offcuts: e.offcuts,
        stockList: r,
        preventAutoRotation: !0
      })
    ), e != null && e.metadata && Je.call(this, ["metadata"], e.metadata), (y = e == null ? void 0 : e.evolutionVisData) != null && y.length ? Je.call(this, ["evolutionVisData"], e.evolutionVisData) : typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "evolution", !1), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "workbench", !0), Je.call(this, ["thinking"], !1);
    const o = Pl.call(this, "inputs");
    if (o && (o != null && o.success) && (o.success = !1), Ye.call(this, ["addedShapes"]).length === 0) {
      const v = Ye.call(this, ["progress"]);
      if (vc(v), typeof this.showModalMessage == "function") {
        let A = "<p>We could not fit any parts.</p>";
        (_ = e == null ? void 0 : e.unusableShapes) != null && _.length ? (A += "<p>Some parts were not usable - click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>", this.showModalMessage({
          heading: "No layouts",
          main: A,
          buttonText: "More info",
          buttonCallback: (L) => {
            L.showInputPanel(
              "parts",
              "inputs-unusable-parts"
            );
          }
        })) : (A += "<p>Please double check your list.</p>", this.showModalMessage({
          heading: "No layouts",
          main: A
        }));
      }
      (b = window == null ? void 0 : window.top) == null || b.postMessage(
        {
          type: "scError",
          message: "No parts were added."
        },
        "*"
      ), console.warn("No parts were added."), typeof this.toggleWidget == "function" && this.toggleWidget.call(this, "inputs", !0);
    }
  }), this.socket;
}
function u6(n) {
  return !n || !No(n, !0) ? "" : Object.values(n).filter((t) => t).join("|");
}
function $d(n, t, e = "Options") {
  if (!e && `${t}` in n && typeof n[t] == "object") return !0;
  const i = `${t}${e}`;
  return !!(e && i in n && typeof n[i] == "object");
}
function Ud(n) {
  return `${n}Options`;
}
function c6(n, t, e) {
  const i = Ud(t);
  for (const r in n[i]) {
    const s = Object.keys(n[i][r]);
    for (const o of s)
      e.includes(o) || o in n[i][r] && delete n[i][r][o];
    for (const o of e)
      (r === "all" || !(o in n[i][r])) && (n[i][r][o] = "");
  }
}
function h6(n, t, e = !0) {
  if (!$d(n, t, "Options")) return;
  const i = n[t], r = Object.keys(i);
  for (const s of r)
    Mm(n, t, s, e);
  e && Rm(n, t, "all");
}
function Mm(n, t, e, i = !0) {
  i && Rm(n, t, e), e !== "all" && $d(n, t) && (n[t][e] = !1);
}
function Rm(n, t, e) {
  if (!$d(n, t, "Options")) return;
  const r = n[`${t}Options`][e];
  if (typeof r != "object" || r === null) return;
  Object.keys(r).forEach((o) => r[o] = "");
}
function Dm(n, t, e, i, r, s) {
  var u;
  const o = t + "Options";
  if (!((u = n == null ? void 0 : n[o]) != null && u[e]) || !(i in n[o][e])) return;
  Fl(n, t, e, !1), n[o][e][i] = r;
  const a = n[o][e], l = Object.values(a || {}).filter((d) => d);
  if (!Array.isArray(l)) return;
  const h = wc(n, t, e, s);
  Fl(n, t, e, !!Jn(h));
}
function f6(n, t, e, i, r = [], s) {
  const o = t + "Options";
  if (!n[o] || typeof n[o] != "object") return;
  const a = Object.keys(n[o]);
  if (!a.length) return;
  const l = wc(n, t, "all", s), h = n[o][e], u = Object.values(h || {}).filter((d) => d);
  for (const d of a)
    d !== "all" && (r.includes(d) || (Dm(n, t, d, e, i, s), Array.isArray(u) || Fl(n, t, d, !1), Fl(n, t, d, !!Jn(l))));
}
function Fl(n, t, e, i) {
  var o;
  if (e === "all") return;
  const r = Ud(t), s = u6((o = n == null ? void 0 : n[r]) == null ? void 0 : o[e]);
  i ? n[t][e] = s || !0 : n[t][e] = !1;
}
function wc(n, t, e, i) {
  var l;
  const r = t + "Options";
  if (!((l = n == null ? void 0 : n[r]) != null && l[e])) return !1;
  const s = n[r][e], o = Object.values(s || {}).filter((h) => h);
  if (!Array.isArray(o) || !i || typeof i != "function")
    return !1;
  const a = i(t, o);
  return t === "banding" && p1(e) && Jn(a) ? Tb(n, e, a) / 1e3 : a;
}
function iA(n) {
  n != null && n.type && delete n.type, d6.call(this, n);
}
function d6(n) {
  if (!(n != null && n.banding) || typeof n.banding != "object") return;
  const t = Object.keys(n.banding);
  if (!t.length) return;
  const e = ["labels", "pricing"];
  if (!t.every((i) => e.includes(i)))
    console.warn("SmartCut - legacy banding data provided - please update to use { labels: string[], pricing: Record<string, number> }");
  else return;
  n.banding = {
    labels: Object.keys(n.banding),
    pricing: n.bandingPricing
  };
}
function p6(n) {
  if (n != null && n.enable) return;
  n.enable = {};
  const t = {
    showDiagram: { new: "diagram", map: "equal" },
    enableFocus: { new: "focus", map: "equal" },
    enableMachining: { new: "machining", map: "equal" },
    enableCSVImport: { new: "csvImport", map: "equal" },
    showProgressNumber: { new: "progressNumber", map: "equal" },
    disableBanding: { new: "banding", map: "reverse" },
    disableFinish: { new: "finish", map: "reverse" },
    disableOrientation: { new: "orientation", map: "reverse" },
    disableClick: { new: "click", map: "reverse" },
    disablePartName: { new: "partName", map: "reverse" }
  };
  for (const e of Object.keys(t))
    e in n && (n.enable[t[e].new] = t[e].map === "reverse" ? !n[e] : n[e], delete n[e]);
  console.log(n);
}
function Of(n = 0, t, e = null, i = null, r = null) {
  if (!Ji(e) && !co || i === "stock") return !1;
  let s, o;
  if (Ji(e) ? s = e.orientationLock : co(e) ? s = e.direction : i === "shape" && (s = r), n === 0 || co(e))
    switch (t) {
      case "n":
        o = s === "w" || r === "w";
        break;
      case "l":
      case "y":
        o = s === "w" || r === "w";
        break;
      case "w":
        o = s === "l" || r === "l";
        break;
      default:
        o = r === "w";
    }
  else if (n === 1)
    o = e.w > e.l;
  else if (n === 2)
    switch (t) {
      case "n":
        o = e.w > e.l;
        break;
      case "y":
      case "l":
        o = e.w > e.l;
        break;
      case "w":
        o = e.l >= e.w;
        break;
      default:
        o = !1;
    }
  return o;
}
function Gg(n, t, e = null, i = null, r = null) {
  if (!Ji(e) || i === "shape") return !1;
  let s;
  return n === 0 || n === 1 ? Of(n, t, e, i, r) ? "cc" : !1 : n === 2 ? t === "w" ? e.l < e.w ? "c" : "cc" : !1 : s;
}
function g6(n) {
  n.banding && (n.banding = xc(n.banding, "cc")), n.trim && (n.trim = xc(n.trim, "cc"));
}
function m6(n, t = 0) {
  return t && (t === 1 || t === 2) && (n.preventAutoRotation = !0, t === 2 && n.l < n.w && g6(n)), n;
}
function xc(n, t = "cc", e = {
  x1: "y1",
  x2: "y2",
  y1: "x1",
  y2: "x2"
}, i = {
  a: "d",
  b: "a",
  c: "b",
  d: "c"
}) {
  const r = {
    x1: null,
    x2: null,
    y1: null,
    y2: null
  };
  if (t === "c") {
    for (const [s, o] of Object.entries(e))
      r[o] = n[s];
    for (const [s, o] of Object.entries(i))
      o in n && (r[o] = n[s]);
  } else if (t === "cc") {
    for (const [s, o] of Object.entries(e))
      r[s] = n[o];
    for (const [s, o] of Object.entries(i))
      o in n && (r[s] = n[o]);
  }
  return r;
}
const y6 = {
  name: "StockNavigation",
  props: {
    stockList: {
      type: Array,
      default: () => []
    },
    primaryColor: {
      type: String,
      default: ""
    },
    secondaryColor: {
      type: String,
      default: ""
    },
    activeStockId: {
      type: String,
      default: null
    }
  },
  emits: ["show-stock"],
  methods: {
    showStock(n) {
      this.$emit("show-stock", n);
    }
  }
}, Ia = (n, t) => {
  const e = n.__vccOpts || n;
  for (const [i, r] of t)
    e[i] = r;
  return e;
}, b6 = { id: "mini-stock-nav" }, v6 = ["onMousedown"], w6 = { class: "id" };
function x6(n, t, e, i, r, s) {
  return Qt(), le("div", b6, [
    (Qt(!0), le(Qn, null, Lr(e.stockList, (o, a) => (Qt(), le("button", {
      key: a,
      class: di(["nav-button", { selected: o.id === e.activeStockId }]),
      type: "button",
      style: Dn({
        backgroundColor: o.id === e.activeStockId ? "#" + e.secondaryColor : "#" + e.primaryColor
      }),
      onMousedown: (l) => s.showStock(o.id)
    }, [
      ye("div", w6, hn(a + 1), 1),
      Xg(ye("div", { class: "stack legibility" }, hn(o.stack), 513), [
        [Jg, typeof o.stack == "number" && o.stack > 1]
      ])
    ], 46, v6))), 128))
  ]);
}
const _6 = /* @__PURE__ */ Ia(y6, [["render", x6]]), S6 = {
  name: "Spinner",
  props: {
    size: {
      type: Number,
      default: 100
    },
    showNumber: {
      type: Boolean,
      default: !0
    },
    number: {
      type: Number,
      default: 0
    },
    complete: {
      type: Boolean,
      default: !1
    }
  }
}, k6 = { id: "spinner" }, A6 = ["width", "height"], N6 = {
  key: 2,
  id: "spinner-number",
  class: "stock-number"
};
function C6(n, t, e, i, r, s) {
  return Qt(), le("div", k6, [
    e.complete ? ke("", !0) : (Qt(), le("svg", {
      key: 0,
      class: "loading",
      style: Dn({ width: e.size + "px", height: e.size + "px" }),
      width: e.size,
      height: e.size,
      viewBox: "0 0 300 300"
    }, t[0] || (t[0] = [
      O2('<rect class="square s1" x="0" y="0"></rect><rect class="square s2" x="100" y="0"></rect><rect class="square s3" x="200" y="0"></rect><rect class="square s4" x="0" y="100"></rect><rect class="square s5" x="200" y="100"></rect><rect class="square s6" x="0" y="200"></rect><rect class="square s7" x="100" y="200"></rect>', 7)
    ]), 12, A6)),
    e.complete ? (Qt(), le("svg", {
      key: 1,
      class: "complete",
      style: Dn({ width: e.size + "px", height: e.size + "px" }),
      viewBox: "0 0 448 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, t[1] || (t[1] = [
      ye("path", { d: "m203.3 331.3c-6.2 6.3-16.4 6.3-22.6 0l-64-64c-6.3-6.2-6.3-16.4 0-22.6 6.2-6.3 16.4-6.3 22.6 0l52.7 52.7 116.7-116.7c6.2-6.3 16.4-6.3 22.6 0 6.3 6.2 6.3 16.4 0 22.6zm-203.3-235.3c0-35.35 28.65-64 64-64h320c35.3 0 64 28.65 64 64v320c0 35.3-28.7 64-64 64h-320c-35.35 0-64-28.7-64-64zm32 0v320c0 17.7 14.33 32 32 32h320c17.7 0 32-14.3 32-32v-320c0-17.67-14.3-32-32-32h-320c-17.67 0-32 14.33-32 32z" }, null, -1)
    ]), 4)) : ke("", !0),
    e.showNumber ? (Qt(), le("div", N6, hn(e.number), 1)) : ke("", !0)
  ]);
}
const Vg = /* @__PURE__ */ Ia(S6, [["render", C6]]);
function P6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "decimal" : "text" : n === "float" ? "decimal" : n === "integer" ? "numeric" : "text";
}
function L6(n, t) {
  return n === "unitDependent" ? t === "decimal" ? "number" : "text" : n === "checkbox" ? "checkbox" : n === "float" || n === "integer" ? "number" : "text";
}
function I6(n, t = null, e = "decimal") {
  switch (n) {
    case "float":
    case "integer":
    case "string":
      return n;
    case "unitDependent":
      return e === "decimal" ? "float" : "string";
    case "checkbox":
      return t || "boolean";
    case "select":
      return t || "string";
    default:
      return "string";
  }
}
function E6(n) {
  return !!n;
}
function O6(n, t) {
  return t ? t.split(".").reduce((i, r) => i && i[r] !== "undefined" ? i[r] : void 0, n) : null;
}
function T6(n, t, e, i = !0) {
  const r = t.split(".");
  let s = n;
  for (let o = 0; o < r.length - 1; o++)
    s[r[o]] || (s[r[o]] = {}), s = s[r[o]];
  (i || !jt(s[r[r.length - 1]])) && (s[r[r.length - 1]] = e);
}
function F6(n, t, e, i, r = !0) {
  var o;
  if (!n || !e || !i || !((o = n == null ? void 0 : n[t]) != null && o[e])) return;
  const s = n[t][e].find((a) => a.id === i);
  if (s)
    return r ? s.enabled = !0 : s.enabled = !1, !0;
}
function M6(n, t, e) {
  var i;
  return (i = n == null ? void 0 : n[t]) != null && i[e] ? n[t][e].filter((r) => r.enabled === !0).map((r) => r.id) : [];
}
function R6(n, t, e, i, r = []) {
  const s = M6(n, e, i);
  if (!s.length) return [];
  const o = t.filter((l) => s.includes(l.id) || l.custom === !0), a = o.filter((l) => (l == null ? void 0 : l.fieldMap) && !l.fieldMap.startsWith("customData."));
  if (s.length !== a.length) {
    const l = new Set(a.map((u) => u.id)), h = o.map((u) => u.id).filter((u) => !l.has(u)).map((u) => `'${u}'`);
    console.warn(`Inputs - these fields do not have a field definition - ${h.join()}`);
  }
  return r.length && o.sort((l, h) => {
    const u = r.indexOf(l.id), d = r.indexOf(h.id);
    return u === -1 ? 1 : d === -1 ? -1 : u - d;
  }), o;
}
const D6 = ["id"], B6 = {
  key: 0,
  class: "delete",
  viewBox: "0 0 512 512",
  xmlns: "http://www.w3.org/2000/svg"
}, j6 = /* @__PURE__ */ Rr({
  __name: "OrientationButton",
  props: {
    id: { default: "" },
    orientationModel: { default: 0 },
    rectangleType: { default: null },
    rectangle: { default: () => null },
    shapeOrientation: { default: "" },
    stockGrain: { default: "n" },
    buttonBackground: { default: "#848484" },
    iconColor: { default: "#FFFFFF" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["updateOrientation"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = _e(0), s = _e(!1), o = () => {
      if (!Ji(e.rectangle)) return "";
      let C = "";
      switch (e.orientationModel) {
        case 0:
          C = v.value;
          break;
        case 1:
          e.stockGrain === "y" || e.stockGrain === "n" ? C = e.rectangle.l >= e.rectangle.w ? "l" : "w" : e.rectangle.l >= e.rectangle.w ? C = e.stockGrain : C = C = e.stockGrain === "l" ? "w" : "l";
          break;
        case 2:
          C = e.rectangle.l >= e.rectangle.w ? "l" : "w";
          break;
      }
      return C;
    }, a = () => {
      if (e.disabled || _.value.length <= 1) return;
      let C = null;
      [1, 2].includes(e.orientationModel) ? C = u() : C = h(), r.value = C;
    }, l = (C) => _.value.findIndex((M) => M === C), h = () => {
      let C = 0;
      return C = l(v.value) + 1, C > _.value.length - 1 && (C = 0), C;
    }, u = () => {
      let C = 0;
      if (v.value)
        C = _.value.findIndex((E) => E === "");
      else {
        const E = o();
        C = _.value.findIndex((M) => M === E);
      }
      return C;
    }, d = (C) => {
      (C.key === "Enter" || C.key === " ") && a();
    }, p = (C) => {
      i("updateOrientation", C);
    }, f = () => {
      const C = v.value;
      switch (e.orientationModel) {
        case 0:
          return C ? e.stockGrain === "n" ? C || e.shapeOrientation || "default" : e.stockGrain === "w" ? C === "w" ? "w" : "l" : C === "l" ? "l" : "w" : "default";
        case 1:
          return C ? e.stockGrain === "n" ? C || e.shapeOrientation || "default" : e.stockGrain === "w" ? C === "w" ? "w" : "l" : C === "l" ? "l" : "w" : "default";
        case 2:
          return C ? e.stockGrain === "n" ? C || e.shapeOrientation || "default" : e.stockGrain === "w" ? C === "w" ? "w" : "l" : C === "l" ? "l" : "w" : "default";
        default:
          return "default";
      }
    }, g = () => {
      if (r.value = l(v.value), !Ji(e.rectangle)) return;
      const { orientationModel: C, stockGrain: E } = e;
      if (C === 1) {
        const M = L.value ? o() : v.value;
        y(M);
        return;
      }
      if (C === 2) {
        let M;
        L.value ? M = E !== "n" ? o() : "" : M = v.value, y(M);
      }
    }, y = (C) => {
      r.value = l(C), p(C);
    }, _ = Re(() => {
      if (!e.rectangle) return ["l", "w"];
      if (co(e.rectangle)) return ["l", "w"];
      let C = ["", "l", "w"];
      return e.rectangle.multiEdit && (C = [" ", "", "l", "w"]), b.value && (C = C.filter((E) => E !== "w")), C;
    }), b = Re(() => {
      var C, E, M, q;
      return Ji(e.rectangle) || Uu(e.rectangle) ? e.rectangle.isSquare() : e.rectangleType && ((C = e.rectangle) != null && C.l) && ((E = e.rectangle) != null && E.w) ? ((M = e.rectangle) == null ? void 0 : M.l) === ((q = e.rectangle) == null ? void 0 : q.w) : !1;
    }), v = Re(() => {
      let C = "";
      return co(e.rectangle) ? C = e.rectangle.direction : Ji(e.rectangle) ? C = e.rectangle.orientationLock : Uu(e.rectangle) && (C = e.rectangle.grain), C;
    }), A = Re(() => co(e.rectangle) || !e.rectangle ? {
      l: null,
      w: null
    } : {
      l: e.rectangle.l,
      w: e.rectangle.w
    }), L = Re(() => !A.value.l && !A.value.w), O = Re(() => Of(
      e.orientationModel,
      e.stockGrain,
      e.rectangle,
      e.rectangleType,
      e.shapeOrientation
    )), R = Re(() => {
      var q;
      if (!e.rectangle)
        return e.shapeOrientation ? "noGrain" : "freeRotation";
      if (Uu(e.rectangle) || e.rectangleType === "stock")
        return {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom"
        }[e.rectangle.grain] || "noGrain";
      const C = {
        n: { " ": "delete", l: "leftRight", w: "leftRight", default: "freeRotation" },
        y: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        l: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        w: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        default: { " ": "delete", l: "leftRight", w: "topBottom", default: "freeRotation" }
      }, E = e.stockGrain || "default";
      let M = "default";
      return Ji(e.rectangle) || e.rectangleType === "shape" ? M = f() : co(e.rectangle) && (M = e.rectangle.direction || "default"), ((q = C[E]) == null ? void 0 : q[M]) || C[E].default;
    });
    return Qi(r, (C, E) => {
      s.value && E !== void 0 && p(_.value[C]);
    }, { immediate: !1 }), Qi(A, (C, E) => {
      if (!e.rectangle || e.orientationModel === 0 || !Ji(e.rectangle) || Ji(e.rectangle) && (e.orientationModel === 2 && E.l && E.w && !v.value || e.stockGrain === "n" && !v.value))
        return;
      const M = o();
      v.value !== M && p(M);
    }, { immediate: !1 }), Us(() => {
      g(), document.addEventListener("keydown", d), dr(() => s.value = !0);
    }), _c(() => {
      document.removeEventListener("keydown", d);
    }), (C, E) => (Qt(), le("div", {
      id: C.id,
      class: di(["orientation-button", { rot: O.value, square: b.value, disabled: C.disabled, [R.value]: !0 }]),
      tabindex: "0",
      "aria-label": "Part orientation",
      style: Dn({
        backgroundColor: C.buttonBackground
      }),
      onClick: a
    }, [
      R.value === "delete" ? (Qt(), le("svg", B6, E[0] || (E[0] = [
        ye("path", { d: "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z" }, null, -1)
      ]))) : ke("", !0),
      R.value === "freeRotation" ? (Qt(), le("svg", {
        key: 1,
        class: "arrow",
        style: Dn({
          stroke: C.iconColor ? C.iconColor : "#ffffff"
        }),
        viewBox: "0 0 67 63",
        xmlns: "http://www.w3.org/2000/svg"
      }, E[1] || (E[1] = [
        ye("g", null, [
          ye("path", { d: "m9.296 31.378c0-3.305.67-6.455 1.88-9.322 3.642-8.621 12.179-14.678 22.12-14.678 10.63 0 19.656 6.927 22.806 16.509" }),
          ye("path", { d: "m57.296 31.378c0 13.246-10.754 24-24 24-10.631 0-19.656-6.926-22.806-16.508" }),
          ye("path", { d: "m61.183 5.408-4.622 17.851-18.347-1.838" }),
          ye("path", { d: "m5.408 57.349 4.622-17.851 18.348 1.838" })
        ], -1)
      ]), 4)) : ke("", !0),
      R.value === "leftRight" ? (Qt(), le("svg", {
        key: 2,
        class: "arrow",
        style: Dn({
          stroke: C.iconColor ? C.iconColor : "#ffffff"
        }),
        viewBox: "0 0 72 39",
        xmlns: "http://www.w3.org/2000/svg"
      }, E[2] || (E[2] = [
        ye("g", null, [
          ye("path", { d: "m5.408 19.408h61.095" }),
          ye("g", null, [
            ye("path", { d: "m52.695 5.408 13.808 14-13.808 14" }),
            ye("path", { d: "m17.408 33.408-12-14 12-14" })
          ])
        ], -1)
      ]), 4)) : ke("", !0),
      R.value === "topBottom" ? (Qt(), le("svg", {
        key: 3,
        class: "arrow",
        style: Dn({
          stroke: C.iconColor ? C.iconColor : "#ffffff"
        }),
        viewBox: "0 0 39 72",
        xmlns: "http://www.w3.org/2000/svg"
      }, E[3] || (E[3] = [
        ye("g", null, [
          ye("path", { d: "m19.408 66.503v-61.095" }),
          ye("g", null, [
            ye("path", { d: "m5.408 19.216 14-13.808 14 13.808" }),
            ye("path", { d: "m33.408 54.503-14 12-14-12" })
          ])
        ], -1)
      ]), 4)) : ke("", !0),
      R.value === "grainLeftRight" ? (Qt(), le("svg", {
        key: 4,
        class: "grain",
        style: Dn({
          stroke: C.iconColor ? C.iconColor : "#ffffff"
        }),
        viewBox: "0 0 106 64",
        xmlns: "http://www.w3.org/2000/svg"
      }, E[4] || (E[4] = [
        ye("g", null, [
          ye("path", { d: "m3 3h99.887" }),
          ye("path", { d: "m3.113 32h99.887" }),
          ye("path", { d: "m3.113 61h99.887" })
        ], -1)
      ]), 4)) : ke("", !0),
      R.value === "grainTopBottom" ? (Qt(), le("svg", {
        key: 5,
        class: "grain",
        style: Dn({
          stroke: C.iconColor ? C.iconColor : "#ffffff"
        }),
        viewBox: "0 0 64 106",
        xmlns: "http://www.w3.org/2000/svg"
      }, E[5] || (E[5] = [
        ye("g", null, [
          ye("path", { d: "m61 3v99.887" }),
          ye("path", { d: "m32 3.113v99.887" }),
          ye("path", { d: "m3 3.113v99.887" })
        ], -1)
      ]), 4)) : ke("", !0)
    ], 14, D6));
  }
}), q6 = ["id"], z6 = /* @__PURE__ */ Rr({
  __name: "BandingButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    orientationModel: { default: 0 },
    stockGrain: { default: "n" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = _e({
      x1: !1,
      x2: !1,
      y1: !1,
      y2: !1
    });
    Qi(() => e.inputShape.orientationLock, () => {
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 }), Qi([
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.banding;
      },
      () => e.orientationModel,
      () => e.stockGrain,
      () => {
        var l;
        return (l = e.inputShape) == null ? void 0 : l.orientationLock;
      }
    ], () => {
      var u;
      if (!((u = e.inputShape) != null && u.banding)) return;
      let l = {
        x1: e.inputShape.banding.x1,
        x2: e.inputShape.banding.x2,
        y1: e.inputShape.banding.y1,
        y2: e.inputShape.banding.y2
      };
      const h = Gg(
        e.orientationModel,
        e.stockGrain,
        e.inputShape
      );
      h && (l = xc(l, h, {
        x1: "y2",
        x2: "y1",
        y1: "x1",
        y2: "x2"
      })), r.value = l;
    }, { deep: !0, immediate: !0 });
    const s = Re(() => r.value), o = (l) => {
      (l.key === "Enter" || l.key === " ") && a();
    }, a = () => {
      e.disabled || i("clicked");
    };
    return Us(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.addEventListener("keydown", o);
    }), _c(() => {
      var l;
      (l = document.getElementById(e.id)) == null || l.removeEventListener("keydown", o);
    }), (l, h) => (Qt(), le("div", {
      id: l.id,
      class: di(["banding-button", { open: l.open, disabled: l.disabled }]),
      tabindex: "0",
      onClick: a
    }, [
      ye("div", {
        class: di(["outer", {
          x1: s.value.x1,
          x2: s.value.x2,
          y1: s.value.y1,
          y2: s.value.y2
        }])
      }, h[0] || (h[0] = [
        ye("div", { class: "inner" }, null, -1)
      ]), 2)
    ], 10, q6));
  }
}), $6 = ["for"], U6 = {
  key: 0,
  "aria-hidden": "true"
}, W6 = ["id", "inputmode", "type", "value", "placeholder", "disabled", "readonly", "required", "min", "max", "aria-label", "aria-invalid", "aria-describedby"], H6 = ["id", "disabled", "required", "checked", "aria-label", "aria-invalid", "aria-describedby"], G6 = ["id", "value", "disabled", "required", "aria-label", "aria-invalid", "aria-describedby"], V6 = ["disabled", "selected"], Y6 = {
  key: 0,
  value: " "
}, K6 = ["hidden", "value", "disabled"], X6 = ["for"], J6 = {
  key: 0,
  "aria-hidden": "true"
}, wl = /* @__PURE__ */ Rr({
  __name: "InputField",
  props: {
    type: { default: "string" },
    value: { type: [String, Number, Boolean, null], default: null },
    id: { default: "" },
    focus: { type: Boolean, default: !1 },
    enableLabel: { type: Boolean, default: !0 },
    labelPosition: { default: "first" },
    output: { default: "string" },
    options: { default: () => [] },
    selectFirstOptionDisabled: { type: Boolean, default: !0 },
    placeholder: { default: "" },
    label: { default: "" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    trueValue: { type: [String, Number, Boolean, null], default: !0 },
    falseValue: { type: [String, Number, Boolean, null], default: !1 },
    default: { type: [String, Number, Boolean, null], default: "" },
    units: { default: "decimal" },
    min: { default: null },
    max: { default: null },
    custom: { type: Boolean, default: !1 },
    multiEdit: { type: Boolean, default: !1 },
    allowBlank: { type: Boolean, default: !1 },
    text: { default: () => ({ select: "Select", delete: "Delete" }) },
    issue: { type: Boolean, default: !1 },
    warning: { type: Boolean, default: !1 },
    errorMessage: { default: "" },
    validationRules: { default: () => [] },
    debounceMs: { default: 300 }
  },
  emits: ["update", "default", "error", "input"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = _e(null), s = _e(null), o = _e(""), a = _e(!0), l = Re(() => e.custom ? "custom-" + e.id : e.id), h = Re(() => `${l.value}-error`), u = Re(() => e.label || e.placeholder), d = Re(() => L6(e.type, e.units)), p = Re(() => P6(e.type, e.units)), f = Re(() => I6(e.type, e.output, e.units)), g = Re(() => ["string", "integer", "float", "unitDependent"].includes(e.type)), y = Re(() => ({
      // 'custom-input__field': true,
      issue: e.issue || !!o.value,
      warning: e.warning,
      required: e.required
    })), _ = Re(() => e.options.map((N) => {
      var S, T, x;
      return {
        value: N.value,
        label: ((S = N.label) == null ? void 0 : S.toUpperCase()) ?? ((x = (T = N.value) == null ? void 0 : T.toString()) == null ? void 0 : x.toUpperCase()),
        hidden: N.hidden ?? !1,
        disabled: N.disabled ?? !1
      };
    })), b = (N) => e.label && e.enableLabel && e.labelPosition === N, v = (N) => {
      if ((N === "" || N === null) && e.allowBlank)
        return null;
      const S = A();
      if (S === "integer" || S === "float")
        try {
          const T = String(N);
          if (S === "integer") {
            const x = T.replace(/[^0-9-]/g, ""), X = parseInt(x);
            if (isNaN(X))
              return null;
            N = X;
          } else {
            const x = T.replace(/[^0-9.-]/g, ""), X = parseFloat(x);
            if (isNaN(X))
              return null;
            N = X;
          }
          typeof N == "number" && (typeof e.min == "number" && N < e.min && (N = e.min), typeof e.min == "number" && typeof e.max == "number" && e.min > e.max && console.warn("Min value is greater than max value"), typeof e.max == "number" && N > e.max && (N = e.max));
        } catch (T) {
          return console.error("Error processing numeric value:", T), null;
        }
      return N;
    }, A = () => e.type === "unitDependent" ? e.units === "fraction" ? "string" : "float" : e.type, L = (N) => {
      N.preventDefault();
      const S = N.target, T = v(S.value);
      M(T);
    }, O = (N) => {
      const S = N.target;
      i("input", S.value), e.debounceMs > 0 && (s.value && window.clearTimeout(s.value), s.value = window.setTimeout(() => {
        const T = v(S.value);
        M(T);
      }, e.debounceMs));
    }, R = (N) => {
      const S = N.target, T = v(S.value);
      M(T);
    }, C = (N) => {
      const S = N.target;
      M(S.checked ? e.trueValue : e.falseValue);
    }, E = (N, S) => {
      i(N, S);
    }, M = (N, S = "update") => {
      if (a.value) {
        if (N === null) {
          E(S, N);
          return;
        }
        try {
          if (e.type === "unitDependent") {
            if (e.units === "fraction") {
              const x = (N != null ? String(N) : "").replace(/[^0-9/ ]+/g, "").replace(/\s{2,}/g, " ").trim();
              E(S, x);
              return;
            } else if (e.units === "decimal") {
              const T = N != null ? String(N) : "", x = parseFloat(T);
              E(S, isNaN(x) ? null : x);
              return;
            }
          }
          switch (f.value) {
            case "string": {
              const T = N != null ? String(N) : "";
              E(S, T);
              break;
            }
            case "integer": {
              const T = N != null ? String(N) : "", x = parseInt(T);
              E(S, isNaN(x) ? null : x);
              break;
            }
            case "float": {
              const T = N != null ? String(N) : "", x = parseFloat(T);
              E(S, isNaN(x) ? null : x);
              break;
            }
            case "boolean":
              E(S, E6(N));
              break;
            default:
              E(S, N);
          }
        } catch (T) {
          console.error("Error updating value:", T), i("error", "Invalid value");
        }
      }
    }, q = () => {
      if (!jt(e.value) && jt(e.default)) {
        const N = v(e.default);
        M(N, "default");
      }
    };
    return Qi(() => e.options, () => {
      e.value && (e.options.find((N) => N.value === e.value) || M(""));
    }, { deep: !1 }), Us(() => {
      r.value && e.focus && dr(() => {
        var N;
        try {
          (N = r.value) == null || N.focus();
        } catch (S) {
          console.warn("Unable to focus input:", S);
        }
      }), a.value = !0;
    }), _c(() => {
      s.value && window.clearTimeout(s.value), a.value = !1;
    }), q(), (N, S) => {
      var T, x, X, V;
      return Qt(), le(Qn, null, [
        b("first") ? (Qt(), le("label", {
          key: 0,
          for: l.value
        }, [
          va(hn(N.label) + " ", 1),
          N.required ? (Qt(), le("span", U6, "*")) : ke("", !0)
        ], 8, $6)) : ke("", !0),
        g.value ? (Qt(), le("input", {
          key: 1,
          id: l.value,
          ref_key: "inputRef",
          ref: r,
          inputmode: p.value,
          type: d.value,
          value: N.value,
          placeholder: N.placeholder,
          disabled: N.disabled,
          readonly: N.readonly,
          required: N.required,
          class: di(y.value),
          min: N.min,
          max: N.max,
          "aria-label": u.value,
          "aria-invalid": !!N.issue,
          "aria-describedby": h.value,
          onChange: L,
          onInput: O
        }, null, 42, W6)) : N.type === "checkbox" ? (Qt(), le("input", {
          key: 2,
          id: l.value,
          ref_key: "inputRef",
          ref: r,
          type: "checkbox",
          disabled: N.readonly || N.disabled,
          required: N.required,
          checked: N.value === N.trueValue,
          "aria-label": u.value,
          "aria-invalid": !!N.issue,
          "aria-describedby": h.value,
          class: di(y.value),
          onChange: C
        }, null, 42, H6)) : N.type === "select" ? (Qt(), le("select", {
          key: 3,
          id: l.value,
          ref_key: "inputRef",
          ref: r,
          value: N.value,
          disabled: N.readonly || N.disabled,
          required: N.required,
          "aria-label": u.value,
          "aria-invalid": !!N.issue,
          "aria-describedby": h.value,
          class: di(y.value),
          onChange: R
        }, [
          ye("option", {
            value: "",
            disabled: N.selectFirstOptionDisabled,
            selected: !N.value
          }, hn(((x = (T = N.text) == null ? void 0 : T.select) == null ? void 0 : x.toUpperCase()) ?? "SELECT"), 9, V6),
          N.multiEdit ? (Qt(), le("option", Y6, hn(((V = (X = N.text) == null ? void 0 : X.delete) == null ? void 0 : V.toUpperCase()) ?? "DELETE"), 1)) : ke("", !0),
          (Qt(!0), le(Qn, null, Lr(_.value, (D) => (Qt(), le("option", {
            key: D.value,
            hidden: D.hidden,
            value: D.value,
            disabled: D.disabled
          }, hn(D.label), 9, K6))), 128))
        ], 42, G6)) : ke("", !0),
        b("last") ? (Qt(), le("label", {
          key: 4,
          for: l.value
        }, [
          va(hn(N.label) + " ", 1),
          N.required ? (Qt(), le("span", J6, "*")) : ke("", !0)
        ], 8, X6)) : ke("", !0)
      ], 64);
    };
  }
}), Z6 = {
  key: 0,
  class: "inputs"
}, Q6 = { class: "label" }, tk = { class: "label" }, ek = { class: "label" }, nk = ["onClick"], ik = { class: "price" }, rk = ["aria-label"], Yg = /* @__PURE__ */ Rr({
  __name: "ExtrasInputs",
  props: {
    translate: { type: Boolean, default: !0 },
    shape: {},
    shapeIndex: { default: 0 },
    extraType: {},
    extraLabel: {},
    extraKeys: {},
    allOptions: {},
    pricing: { default: () => ({}) },
    labels: {},
    userFriendlyFieldMap: {},
    partColumns: {},
    orientationModel: { default: 0 },
    getPrice: {},
    formatPrice: {},
    getAvailablePricingOptions: {}
  },
  emits: ["update-all", "set"],
  setup(n, { emit: t }) {
    const e = n, i = t, { t: r } = Zg({
      inheritLocale: !0,
      useScope: "global"
    }), s = _e(!1), o = Re(() => e.extraType + "Options"), a = Re(() => {
      var _;
      if (!((_ = e.allOptions) != null && _.length)) return "auto";
      const g = e.allOptions.length;
      return g ? `repeat(${g + 3 - 1}, minmax(20px, max-content)) 1fr` : "auto";
    }), l = (g, y) => {
      i("update-all", e.shape, e.extraType, g, y);
    }, h = (g, y, _) => {
      i("set", e.shape, e.extraType, g, y, _);
    }, u = (g, y, _, b, v) => {
      var R;
      if (!g) return [];
      const A = (R = y == null ? void 0 : y[_]) == null ? void 0 : R[b];
      if (!A)
        return console.error(`ExtrasInputs: cannot find pricing options for ${_} > ${b}`), [];
      const L = Object.values(A);
      if (!L.length)
        return console.error(`ExtrasInputs: cannot find pricing options for ${_} > ${b}`), [];
      const O = L.filter((C) => typeof C == "string");
      return e.getAvailablePricingOptions ? e.getAvailablePricingOptions(g, O, v) : (console.error("ExtrasInputs: cannot find pricing function in parent"), []);
    }, d = (g) => {
      if (!e.pricing || !Object.values(e.pricing).length) return "";
      if (!e.getPrice)
        return console.error("ExtrasInputs: cannot find getExtrasPrice or formatPrice in parent"), "";
      const y = e.getPrice(e.shape, e.extraType, g);
      return y ? e.formatPrice(y) : "";
    }, p = () => {
      const g = [];
      e.extraType in e.shape || g.push({ message: `The extra type '${e.extraType}' does not exist in the shape.` }), o.value in e.shape || g.push({ message: `The options key '${o.value}' does not exist in the shape.` }), g.length && (s.value = !0, console.error("pre-flight issues found in ExtrasInputs: " + g.map((y) => y.message).join(" ")));
    }, f = (g) => Zb(g);
    return Us(() => p()), (g, y) => {
      var b, v, A, L, O, R, C, E;
      const _ = Ml("font-awesome-icon");
      return s.value ? ke("", !0) : (Qt(), le("div", {
        key: 0,
        class: di(["extras group", [g.extraType]]),
        style: Dn({ "grid-column-end": "span " + (g.partColumns + 1) })
      }, [
        g.allOptions.length === 1 && g.allOptions[0].length === 1 ? (Qt(), le("div", Z6, [
          ye("div", Q6, hn(f((v = (b = g.allOptions) == null ? void 0 : b[0]) == null ? void 0 : v[0])), 1),
          (A = g.shape) != null && A[o.value] && "all" in g.shape[o.value] ? (Qt(), Un(wl, {
            key: 0,
            id: `${g.extraType}-all-${g.shapeIndex}`,
            type: "checkbox",
            label: f(Oe(r)("all")),
            "true-value": (O = (L = g.allOptions) == null ? void 0 : L[0]) == null ? void 0 : O[0],
            "false-value": "",
            value: (C = g.shape[o.value].all) == null ? void 0 : C[(R = g.labels) == null ? void 0 : R[0]],
            onUpdate: y[0] || (y[0] = (M) => {
              var q, N;
              h("all", (q = g.labels) == null ? void 0 : q[0], M), l((N = g.labels) == null ? void 0 : N[0], M);
            })
          }, null, 8, ["id", "label", "true-value", "value"])) : ke("", !0),
          (Qt(!0), le(Qn, null, Lr(g.extraKeys, (M) => {
            var q, N, S, T, x, X;
            return Qt(), le(Qn, { key: M }, [
              (q = g.labels) != null && q[0] && ((S = (N = g.shape) == null ? void 0 : N[o.value]) != null && S[M]) && g.labels[0] in g.shape[o.value][M] ? (Qt(), Un(wl, {
                key: 0,
                id: `${g.extraType}-${M}-${g.shapeIndex}`,
                type: "checkbox",
                label: f(Oe(r)((T = g.userFriendlyFieldMap) == null ? void 0 : T[M])),
                "true-value": (X = (x = g.allOptions) == null ? void 0 : x[0]) == null ? void 0 : X[0],
                "false-value": "",
                value: g.shape[o.value][M][g.labels[0]],
                onUpdate: (V) => h(M, g.labels[0], V)
              }, null, 8, ["id", "label", "true-value", "value", "onUpdate"])) : ke("", !0)
            ], 64);
          }), 128))
        ])) : (Qt(), le("div", {
          key: 1,
          class: "grid inputs",
          style: Dn({
            "grid-template-columns": a.value
          })
        }, [
          (E = g.shape) != null && E[o.value] && "all" in g.shape[o.value] ? (Qt(), le(Qn, { key: 0 }, [
            ye("div", tk, hn(f(Oe(r)("all"))), 1),
            (Qt(!0), le(Qn, null, Lr(g.allOptions, (M, q) => {
              var N, S;
              return Qt(), Un(wl, {
                id: `${g.extraType}-all-${g.labels[q]}-${q}-${g.shapeIndex}`,
                key: `${g.extraType}-all-${g.labels[q]}-${q}-${g.shapeIndex}`,
                type: "select",
                disabled: u(g.pricing, g.shape, o.value, "all", q).length === 0,
                options: u(g.pricing, g.shape, o.value, "all", q).map((T) => ({ value: T, label: T })),
                text: { select: "✘" },
                "select-first-option-disabled": !1,
                value: (S = g.shape[o.value].all) == null ? void 0 : S[(N = g.labels) == null ? void 0 : N[q]],
                onUpdate: (T) => {
                  var x, X;
                  h("all", (x = g.labels) == null ? void 0 : x[q], T), l((X = g.labels) == null ? void 0 : X[q], T);
                }
              }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
            }), 128)),
            y[2] || (y[2] = ye("div", null, null, -1)),
            y[3] || (y[3] = ye("div", null, null, -1))
          ], 64)) : ke("", !0),
          (Qt(!0), le(Qn, null, Lr(g.extraKeys, (M) => {
            var q, N;
            return Qt(), le(Qn, { key: M }, [
              (q = g.shape) != null && q[o.value] && M in g.shape[o.value] ? (Qt(), le(Qn, { key: 0 }, [
                ye("div", ek, hn(f(Oe(r)((N = g.userFriendlyFieldMap) == null ? void 0 : N[M]))), 1),
                (Qt(!0), le(Qn, null, Lr(g.allOptions, (S, T) => {
                  var x;
                  return Qt(), Un(wl, {
                    id: `${g.extraType}-${M}-${g.labels[T]}-${T}-${g.shapeIndex}`,
                    key: `${g.extraType}-${M}-${g.labels[T]}-${T}-${g.shapeIndex}`,
                    type: "select",
                    disabled: u(g.pricing, g.shape, o.value, M, T).length === 0,
                    options: u(g.pricing, g.shape, o.value, M, T).map((X) => ({
                      value: X,
                      label: X
                    })),
                    text: { select: "✘" },
                    "select-first-option-disabled": !1,
                    value: g.shape[o.value][M][(x = g.labels) == null ? void 0 : x[T]],
                    onUpdate: (X) => {
                      var V;
                      return h(M, (V = g.labels) == null ? void 0 : V[T], X);
                    }
                  }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
                }), 128))
              ], 64)) : ke("", !0),
              ye("div", {
                class: "delete",
                onClick: () => Oe(Mm)(g.shape, g.extraType, M)
              }, [
                Zn(_, { icon: ["fass", "trash"] })
              ], 8, nk),
              ye("div", ik, hn(d(M) || Oe(r)("N/A")), 1)
            ], 64);
          }), 128))
        ], 4)),
        ye("button", {
          type: "button",
          class: "delete icon-left",
          "aria-label": Oe(r)(`delete ${g.extraLabel}`),
          onClick: y[1] || (y[1] = () => Oe(h6)(g.shape, g.extraType, !0))
        }, [
          Zn(_, { icon: ["fass", "trash"] }),
          va(" " + hn(Oe(r)(`delete ${g.extraLabel}`)), 1)
        ], 8, rk)
      ], 6));
    };
  }
}), sk = ["id", "disabled"], ok = { class: "icon" }, ak = /* @__PURE__ */ Rr({
  __name: "FinishButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: !1 },
    id: { default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["clicked"],
  setup(n, { emit: t }) {
    const e = n, i = t, r = () => {
      e.disabled || i("clicked");
    };
    return (s, o) => {
      var l, h, u, d;
      const a = Ml("font-awesome-icon");
      return Qt(), le("button", {
        id: s.id,
        class: di(["finish-button", {
          "face-a": (h = (l = s.inputShape) == null ? void 0 : l.finish) == null ? void 0 : h.a,
          "face-b": (d = (u = s.inputShape) == null ? void 0 : u.finish) == null ? void 0 : d.b,
          selected: s.open
        }]),
        type: "button",
        tabindex: "0",
        disabled: s.disabled,
        onClick: r
      }, [
        ye("div", ok, [
          Zn(a, { icon: ["fass", "spray-can"] })
        ]),
        o[0] || (o[0] = ye("div", { class: "indicator" }, null, -1))
      ], 10, sk);
    };
  }
}), lk = Rr({
  name: "MachiningButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    },
    id: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["open"],
  computed: {
    hasMachining() {
      return d1(this.inputShape);
    },
    disabledOrReadonly() {
      var n;
      return this.disabled || !!((n = this.inputShape) != null && n.readonly);
    }
  },
  methods: {
    openMachining() {
      this.disabled || this.$emit("open");
    }
  }
}), uk = ["id", "disabled"];
function ck(n, t, e, i, r, s) {
  const o = Ml("font-awesome-icon");
  return Qt(), le("button", {
    id: n.id,
    class: di(["machining-button", { "has-machining": n.hasMachining }]),
    type: "button",
    disabled: n.disabled,
    onClick: t[0] || (t[0] = (...a) => n.openMachining && n.openMachining(...a))
  }, [
    Zn(o, { icon: ["fass", "hammer"] })
  ], 10, uk);
}
const hk = /* @__PURE__ */ Ia(lk, [["render", ck]]), fk = { id: "uploader" }, dk = {
  key: 0,
  class: "debug"
}, pk = {
  key: 1,
  class: "selected-files"
}, gk = ["src"], mk = ["onClick"], yk = /* @__PURE__ */ Rr({
  __name: "ImageUpload",
  props: {
    shapeId: {
      type: String,
      required: !0
    },
    prefix: {
      type: String,
      required: !0
    },
    uniqueId: {
      type: String,
      required: !0
    },
    env: {
      type: String,
      required: !1,
      default: "production"
    },
    maxImages: {
      type: Number,
      required: !1,
      default: 5
    },
    images: {
      type: Array,
      required: !0
    }
  },
  emits: ["update", "remove"],
  setup(n, { emit: t }) {
    const e = po(() => import("./ObjectViewer-CW0Ix_lM.js")), i = _e(null), r = _e(!0), s = _e({
      shapeId: "",
      files: [],
      previewUrls: [],
      metadata: []
    }), o = n, a = t, l = (g) => ["image/jpeg", "image/jpg", "image/png"].includes(g.type), h = () => {
      var g;
      (g = i.value) == null || g.click();
    }, u = (g) => {
      const y = g.target, _ = y.files;
      if (!_) return;
      const b = Array.from(_), v = b.filter((M) => !l(M));
      if (v.length > 0) {
        const M = v.map((q) => q.name).join(", ");
        alert(`Invalid file type(s): ${M}
Only JPG and PNG files are allowed.`), y.value = "";
        return;
      }
      const A = s.value.files || [];
      if (A.length + b.length > o.maxImages) {
        alert(`Maximum ${o.maxImages} images allowed per shape.`), y.value = "";
        return;
      }
      const O = [...A, ...b], R = d(O), C = O.map((M, q) => ({
        originalName: M.name,
        newName: `${o.prefix}-${q + 1}-${o.uniqueId}${p(M.name)}`
      })), E = {
        shapeId: o.shapeId,
        files: O,
        previewUrls: R,
        metadata: C
      };
      s.value = E, a("update", E), y.value = "";
    }, d = (g) => g.map((y) => URL.createObjectURL(y)), p = (g) => g.substring(g.lastIndexOf(".")), f = (g) => {
      URL.revokeObjectURL(s.value.previewUrls[g]);
      const y = [...s.value.files], _ = [...s.value.previewUrls], b = [...s.value.metadata];
      if (y.splice(g, 1), _.splice(g, 1), b.splice(g, 1), y.length === 0)
        s.value = {
          shapeId: o.shapeId,
          files: [],
          previewUrls: [],
          metadata: []
        }, a("remove", o.shapeId);
      else {
        const v = {
          shapeId: o.shapeId,
          files: y,
          previewUrls: _,
          metadata: b
        };
        s.value = v, a("update", v);
      }
    };
    return T2(() => {
      var g;
      (g = s.value) != null && g.previewUrls && s.value.previewUrls.forEach((y) => URL.revokeObjectURL(y));
    }), Us(() => {
      s.value.shapeId = o.shapeId;
      const g = o.images.find((y) => y.shapeId === o.shapeId);
      if (g) {
        const y = d(g.files);
        s.value = {
          ...g,
          previewUrls: y
        };
      }
    }), (g, y) => {
      var b;
      const _ = Ml("font-awesome-icon");
      return Qt(), le("div", fk, [
        n.env === "development" && r.value ? (Qt(), le("div", dk, [
          Zn(Oe(e), {
            data: [s.value],
            paths: ["imageData"]
          }, null, 8, ["data"])
        ])) : ke("", !0),
        ye("input", {
          ref_key: "fileInput",
          ref: i,
          type: "file",
          accept: ".jpg,.jpeg,.png",
          class: "hidden",
          multiple: "",
          onChange: u
        }, null, 544),
        ye("button", {
          type: "button",
          class: "upload-button",
          onClick: h
        }, [
          Zn(_, { icon: ["fass", "files"] })
        ]),
        (b = s.value.files) != null && b.length ? (Qt(), le("div", pk, [
          (Qt(!0), le(Qn, null, Lr(s.value.files, (v, A) => (Qt(), le("div", {
            key: A,
            class: "selected-file"
          }, [
            ye("img", {
              src: s.value.previewUrls[A],
              alt: "Preview"
            }, null, 8, gk),
            ye("button", {
              class: "remove-file",
              type: "button",
              onClick: (L) => f(A)
            }, [
              Zn(_, { icon: ["fass", "trash"] })
            ], 8, mk)
          ]))), 128))
        ])) : ke("", !0)
      ]);
    };
  }
}), bk = /* @__PURE__ */ Ia(yk, [["__scopeId", "data-v-b59be53a"]]), vk = {
  key: 0,
  class: "debug"
}, wk = { key: 2 }, xk = {
  key: 0,
  class: "row table-heading"
}, _k = {
  key: 0,
  class: "cell center"
}, Sk = {
  key: 1,
  class: "cell delete"
}, kk = { class: "cell" }, Ak = ["id", "disabled", "onClick"], Nk = {
  key: 0,
  class: "cell center"
}, Ck = ["onClick"], Pk = {
  key: 1,
  class: "cell"
}, Lk = ["disabled", "aria-label", "onClick"], Ik = { class: "button-wrapper main" }, Ek = ["aria-label"], Ok = ["aria-label", "disabled"], Tk = ["aria-label"], Fk = { id: "part-count" }, Mk = {
  key: 3,
  id: "messages"
}, Rk = {
  key: 0,
  class: "heading"
}, Dk = { class: "content" }, Bk = {
  key: 4,
  id: "progress"
}, jk = {
  id: "diagram",
  class: "diagram production"
}, qk = {
  key: 0,
  id: "stack"
}, zk = !0, Bm = /* @__PURE__ */ Rr({
  __name: "CheckoutCalculator",
  props: {
    debug: {
      type: Boolean,
      default: !1
    },
    units: {
      type: String,
      default: "decimal"
    },
    stock: {
      type: Array,
      default: () => []
    },
    findExtrasPrice: {
      type: Function,
      required: !0
    },
    formatPrice: {
      type: Function,
      required: !0
    },
    readonly: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["inputs-changed", "calculating", "result", "log", "error"],
  setup(n, { expose: t, emit: e }) {
    const i = po(() => import("./Machining-DPZtOfOQ.js")), r = po(() => import("./ImportCSV-CYhjWvRa.js")), s = po(() => import("./ObjectViewer-CW0Ix_lM.js")), o = n, a = e, { t: l, locale: h } = Zg({
      locale: "en_US",
      useScope: "global"
    }), u = "production", d = window.location.hostname;
    let p = null, f = null;
    const g = _e(!1), y = _e(!1), _ = _e(!0), b = fg("Checkout/currentURL", window.location.href), v = _e(window.innerWidth), A = Aw(), L = _e([]), O = _e(!1), R = _e(!1), C = _e(!1), E = _e(!1), M = _e(0), q = _e(!1), N = _e(!1), S = _e(tv()), T = {
      enable: {
        diagram: !0,
        focus: !0,
        click: !0,
        partName: !0,
        progressNumber: !0,
        orientation: !0,
        banding: !1,
        finish: !1,
        machining: !1,
        csvImport: !1,
        imageUpload: !1
      },
      colors: {
        partA: "#118ab2",
        partB: null,
        partHover: null,
        partSelected: null,
        stock: "#ffd166",
        button: "#118ab2",
        buttonText: "#ffffff",
        text: "#ffffff"
      },
      decimalPlaces: 2,
      stackHeight: 100,
      maxParts: null,
      locale: "en_US",
      orientationModel: 0,
      customFields: [],
      fieldOrder: [],
      units: "decimal",
      minDimension: 0,
      stockSelection: null,
      cutPreference: null,
      bladeWidth: null,
      stockType: null,
      minSpacing: 0,
      stockGrain: null,
      partTrim: 0
    }, x = es(T), X = _e(null), V = es({
      bladeWidth: 1,
      cutPreference: "l",
      cutType: "guillotine",
      stockType: "sheet",
      stackHeight: 0,
      options: {
        stockSelection: "efficiency",
        minSpacing: 0
      }
    }), D = fg(
      "Checkout/inputShapes",
      [],
      {
        serializer: {
          read: (Q) => {
            if (!Q) return [];
            const mt = Q ? JSON.parse(Q) : [];
            return Bb(mt, o.units);
          },
          write: (Q) => JSON.stringify(Q)
        },
        listenToStorageChanges: !1
      }
    ), tt = _e([]), H = lo([]), ct = lo([]), it = lo([]), P = lo([]), z = _e(null), G = _e(null), Y = _e(null), ot = Re(() => ct.value.filter((Q) => Q.added)), xt = Re(() => ct.value.filter((Q) => Q.added && !Q.duplicate)), gt = Re(() => xt.value.filter((Q) => Q.added)), wt = Re(() => H.value.filter((Q) => Q.used && !Q.duplicate)), qt = Re(() => wt.value.filter((Q) => Q.used).map((Q) => (Q.q = wt.value.filter((mt) => mt.parentID === Q.parentID).reduce(
      (mt, dt) => mt + (typeof (dt == null ? void 0 : dt.stack) == "number" && dt.stack > 0 ? dt.stack : 1),
      0
    ), Q))), Dt = Re(() => n6(H.value)), Yt = Re(() => Y.value ? t6(H.value, Y.value) : null), Xt = Re(() => Qb(H.value)), F = Re(() => ct.value.filter((Q) => {
      var mt, dt;
      return Q.added && ((mt = Q == null ? void 0 : Q.stock) == null ? void 0 : mt.id) === ((dt = Yt.value) == null ? void 0 : dt.id);
    })), ht = Re(() => e6(it.value, Yt.value)), $ = Re(() => D.value.reduce((Q, mt) => Q + mt.q, 0)), nt = _e(!1), J = _e(""), st = _e(""), vt = es({
      banding: null,
      finish: null,
      info: null,
      imageUpload: null
    }), St = _e([]), ft = _e([]), Et = _e([]), zt = _e(!1), Tt = es({
      units: "decimal",
      faces: { enabled: !0 },
      holes: { enabled: !1 },
      corners: {
        enabled: !1,
        types: []
      },
      banding: { enabled: !1 },
      hingeHoles: { enabled: !1 },
      shelfHoles: { enabled: !1 }
    }), $t = es({
      labels: [],
      pricing: {},
      options: {},
      keys: mr
    }), ee = es({
      labels: [],
      pricing: {},
      options: {},
      keys: ["a", "b"]
    }), oe = _e({
      queue: 0,
      stockCount: 0,
      shapeCount: 0,
      complete: !1
    });
    let ae = null;
    const we = _e(!1), Jt = _e(!1), Nt = es({
      disableClick: !1,
      enableStretch: !0
    }), Ot = lo(null), re = es({
      parts: {
        sheet: [
          { id: "material", enabled: !1 },
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "t", enabled: !1 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "banding", enabled: !1 },
          { id: "finish", enabled: !1 },
          { id: "machining", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        linear: [
          { id: "l", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "finish", enabled: !1 },
          { id: "imageUpload", enabled: !1 }
        ],
        roll: [
          { id: "l", enabled: !0 },
          { id: "w", enabled: !0 },
          { id: "q", enabled: !0 },
          { id: "name", enabled: !0 },
          { id: "orientationLock", enabled: !0 },
          { id: "imageUpload", enabled: !1 }
        ]
      }
    }), Zt = _e([]), fe = Re(() => {
      var mt;
      return [...[
        {
          id: "material",
          fieldMap: "material",
          label: l("material"),
          w: "minmax(20px, max-content)",
          type: "select",
          output: "string",
          default: (mt = St.value[0]) == null ? void 0 : mt.name,
          options: St.value.map((dt) => ({
            value: dt.name,
            label: dt.name
          }))
        },
        {
          id: "t",
          fieldMap: "t",
          w: "minmax(20px, max-content)",
          type: "select",
          output: o.units === "decimal" ? "float" : "string",
          label: l("thickness")
        },
        {
          id: "l",
          fieldMap: "l",
          type: "unitDependent",
          label: l("length"),
          min: 0
        },
        {
          id: "w",
          fieldMap: "w",
          type: "unitDependent",
          label: l("width"),
          min: 0
        },
        {
          id: "q",
          fieldMap: "q",
          type: "integer",
          default: 1,
          label: l("quantity"),
          min: 0
        },
        {
          id: "name",
          fieldMap: "name",
          type: "string",
          label: l("name")
        },
        {
          id: "orientationLock",
          w: "32px",
          label: l("orientation"),
          fieldMap: "orientationLock"
        },
        {
          id: "banding",
          w: "32px",
          label: l("banding"),
          fieldMap: "bandingOptions"
        },
        {
          id: "finish",
          type: "checkbox",
          w: "32px",
          label: l("finish"),
          fieldMap: "finish"
        },
        {
          id: "machining",
          w: "32px",
          label: l("machining"),
          fieldMap: "machining"
        },
        {
          id: "imageUpload",
          w: "32px",
          label: l("image upload"),
          fieldMap: "imageUpload"
        }
      ], ...Zt.value];
    }), ie = Re(() => R6(
      re,
      fe.value,
      "parts",
      V.stockType,
      x.fieldOrder
    )), de = Re(() => {
      let Q = ie.value.length;
      return D.value.length > 1 && Q++, Q;
    }), We = Re(() => {
      const Q = {
        id: "34px",
        del: "30px",
        info: "30px"
      }, mt = [];
      for (const dt of ie.value)
        dt.id !== "trim" && mt.push(dt.w ?? "minmax(20px, 1fr)");
      return mt.unshift(Q.id), D.value.length > 1 && mt.push(Q.del), mt.join(" ");
    }), Te = Re(() => ({
      fontSize: "11px",
      textAlign: "right",
      width: "100%",
      height: "auto",
      position: "relative",
      display: "flex",
      visibility: "visible",
      opacity: "1",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingRight: "10px",
      marginTop: "10px",
      marginBottom: "2px",
      userSelect: "none",
      alignItems: "center"
    })), _n = Re(() => ({
      width: "auto",
      height: "auto",
      display: "inline-block",
      position: "relative",
      visibility: "visible",
      opacity: "1",
      color: "#4e4e4e"
    })), Fn = (Q, mt) => {
      let dt;
      return function(...Mt) {
        const pe = () => {
          clearTimeout(dt), Q(...Mt);
        };
        clearTimeout(dt), dt = setTimeout(pe, mt);
      };
    }, Qe = (Q, mt) => O6(Q, mt), Ne = (Q, mt, dt, Bt = !0) => {
      T6(Q, mt, dt, Bt);
    }, qe = {
      stockType: (Q) => {
        const mt = ["sheet", "linear", "roll"];
        mt.includes(Q) || console.warn(`${Q} is not a valid stockType, expected ${mt.join("|")}`), V.stockType = Q, Q === "linear" && (V.cutType = null, V.cutPreference = null);
      },
      stockSelection: (Q) => {
        const mt = ["efficiency", "smallest"];
        Q && !mt.includes(Q) ? console.warn(`${Q} is not a valid stockSelection, expected ${mt.join("|")}`) : V.options.stockSelection = Q;
      },
      minSpacing: (Q) => {
        V.options.minSpacing = Q;
      },
      stackHeight: (Q) => {
        V.stackHeight = Q;
      },
      cutPreference: (Q) => {
        const mt = ["efficiency", "length", "width", "beam"];
        if (mt.includes(Q)) {
          const { cutType: dt, cutPreference: Bt } = rf(Q);
          V.cutType = dt, V.cutPreference = Bt;
        } else
          console.warn(`SmartCut - ${Q} is not one of ${mt.join("|")}`);
      },
      bladeWidth: (Q) => {
        Q >= 0 ? V.bladeWidth = Q : console.warn(`SmartCut - you provided an incorrect blade width of: ${Q}`);
      },
      maxParts: (Q) => {
        x.maxParts = Q;
      },
      locale: (Q) => {
        h.value = Q;
      },
      enable: (Q) => {
        const mt = {
          banding: "banding",
          name: "partName",
          finish: "finish",
          orientationLock: "orientation",
          machining: "machining",
          imageUpload: "imageUpload"
        };
        for (const dt in T.enable)
          dt in Q && (x.enable[dt] = Q[dt]);
        for (const dt in mt)
          jn(dt, Rn(Q, [mt[dt]]) ?? T.enable[mt[dt]]);
        N.value = Rn(Q, ["csvImport"]) ?? T.enable.csvImport, Nt.disableClick = Rn(Q, ["click"]) ?? !T.enable.click;
      },
      colors: (Q) => {
        for (const mt in T.colors)
          mt in Q && (x.colors[mt] = Q[mt]);
      },
      customFields: (Q) => {
        if (!Array.isArray(Q) || !(Q != null && Q.length)) return;
        const mt = [];
        Q.forEach((dt, Bt) => {
          mt.push(dt), mt[Bt].custom = !0;
          const Mt = ve(dt.id);
          mt[Bt].id = Mt, mt[Bt].fieldMap = "customData." + Mt, dt.type === "checkbox" && (mt[Bt].w = "32px"), dt.type === "select" && (mt[Bt].output = dt.output ?? "string", mt[Bt].options = dt.options);
        }), Zt.value = mt, D.value.forEach((dt) => {
          dt.customData = Q.reduce((Bt, Mt) => {
            const pe = ve(Mt.id);
            return Bt[pe] = dt.customData[pe] || Mt.default || "", Bt;
          }, {});
        });
      }
    }, nr = (Q) => {
      if (o.debug && a("log", ["checkout init...", Q]), Q != null && Q.options) {
        const mt = Q.options;
        p6(mt), [
          "stockType",
          "cutPreference",
          "bladeWidth"
        ].forEach((Mt) => {
          Mt in mt || a("error", `${Mt} is a required option`);
        });
        const Bt = ["enable", "colors"];
        for (const Mt in mt)
          Bt.includes(Mt) || (x[Mt] = mt[Mt]), Mt in qe && qe[Mt](mt[Mt]);
      }
      Q.colors && "colors" in qe && qe.colors(Q.colors), fs("banding", Q), fs("finish", Q), ki(Q), os(Q), R.value = !0, dr(() => {
        we.value || hs(), qi() || alert("The SmartCut credit seems to have been tampered with - this is against our terms of service. Please contact support.");
      }), window.smartcutCheckout = { init: nr };
    }, Ln = (Q) => {
      if (!tt.value.length) return "n";
      const mt = Q.material, dt = Q.t, Bt = tt.value.filter((Mt) => Mt.material === mt && Mt.t === dt);
      return Bt.length ? Vb(Bt) : "n";
    }, Di = (Q, mt) => {
      console.log("updateShapeOrientation", mt || "N/A"), Q.orientationLock = mt;
    }, jn = (Q, mt = !1) => {
      F6(re, "parts", V.stockType, Q, mt);
    }, ve = (Q) => Q ? Ul(Q).toLowerCase() : null, ki = (Q) => {
      var mt, dt, Bt, Mt, pe;
      if (Rn(x, ["enable", "machining"]) && Q != null && Q.machining) {
        for (const me in Tt)
          Q.machining[me] && (Tt[me] = Q.machining[me]);
        if (["holes", "hingeHoles"].forEach((me) => {
          var Ce, ln;
          (Ce = Q == null ? void 0 : Q.machining) != null && Ce[me] && (Tt[me].enabled = (ln = Q == null ? void 0 : Q.machining) == null ? void 0 : ln[me].enabled);
        }), (Bt = (dt = (mt = Q == null ? void 0 : Q.machining) == null ? void 0 : mt.corners) == null ? void 0 : dt.types) != null && Bt.length && (Tt.corners.enabled = !0, Tt.corners.types = Q.machining.corners.types), Q.banding && ((pe = (Mt = Q == null ? void 0 : Q.options) == null ? void 0 : Mt.enable) != null && pe.banding)) {
          if (!$t) return;
          Tt.banding = {
            enabled: !0
          }, $t.options.length && (Tt.banding.options = $t.options), $t.labels.length && (Tt.banding.labels = $t.labels), No($t.pricing) && (Tt.banding.pricing = $t.pricing);
        }
      }
    }, Bi = (Q = null) => {
      G.value = Q, Q && Q.l && Q.w ? zt.value = !0 : alert("Please enter dimensions first");
    }, ti = () => {
      zt.value = !1, document.exitFullscreen && document.exitFullscreen();
    }, yn = (Q = []) => {
      if (ft.value = [], Et.value = [], jn("t", !1), !!Q.length) {
        for (const mt of Q)
          if (mt != null && mt.t)
            if (typeof mt.t == "string" && mt.t.includes(",")) {
              const dt = gi(mt.t, !0);
              dt.length === 2 ? (ir(dt), jn("t", !0), mt.t = ft.value[0]) : a("error", "bonded thickness found which does not have 2 options");
            } else ft.value.includes(mt.t) || ft.value.push(mt.t);
        ft.value.length > 1 && jn("t", !0);
      }
    }, bn = (Q) => ui(Q).thicknesses.map((dt) => ({
      label: dt == null ? void 0 : dt.toString(),
      value: dt
    })), ui = (Q) => {
      var Mt;
      if (!Q) return { thicknesses: [], bondedThicknesses: [] };
      if (!((Mt = St.value) != null && Mt.length))
        return {
          thicknesses: ft.value,
          bondedThicknesses: []
        };
      if (!Q.material) return { thicknesses: [], bondedThicknesses: [] };
      const mt = St.value.find((pe) => pe.name === Q.material);
      if (!mt) return { thicknesses: [], bondedThicknesses: [] };
      const dt = [...mt.thicknesses], Bt = [];
      for (let pe = 0; pe < dt.length; pe++) {
        const me = dt[pe], Ce = gi(me), ln = [];
        if (Ce.length) {
          for (const Be of Ce)
            dt[pe] = te(Be), ln.push(pe);
          pe++;
        }
        ln.length && Bt.push(ln);
      }
      return {
        thicknesses: dt,
        bondedThicknesses: Bt
      };
    }, os = (Q) => {
      var mt;
      if ((mt = Q == null ? void 0 : Q.stock) != null && mt.some((dt) => dt == null ? void 0 : dt.material)) {
        St.value = [], ft.value = [], Et.value = [];
        const dt = /* @__PURE__ */ new Map();
        Q.stock.forEach((Bt) => {
          var pe;
          if (!Bt.material) return;
          const Mt = Bt.material.toUpperCase();
          if (dt.has(Mt) || dt.set(Mt, /* @__PURE__ */ new Set()), Bt.t != null) {
            const me = Number(Bt.t);
            isNaN(me) || (pe = dt.get(Mt)) == null || pe.add(me);
          }
        }), St.value = Array.from(dt.entries()).map(([Bt, Mt]) => ({
          name: Bt,
          thicknesses: Array.from(Mt).sort((me, Ce) => me - Ce)
        })), St.value.length > 1 && jn("material", !0);
      } else
        yn(Q.stock);
    }, ir = (Q, mt = null) => {
      if (!Array.isArray(Q)) {
        a("error", "addBondedThicknesses expects an array");
        return;
      }
      const dt = [];
      for (let Bt = 0; Bt < Q.length; Bt++) {
        let Mt = Q[Bt];
        o.units === "decimal" && (Mt = parseFloat(Mt)), ft.value.push(Mt), mt && mt.thicknesses.push(Mt), dt.push(ft.value.length - 1);
      }
      Et.value.push(dt);
    }, gi = (Q, mt = !1) => {
      if (typeof Q == "string" && Q.includes(",")) {
        const dt = Q.split(",");
        return mt ? dt.map((Bt) => te(Bt)) : dt;
      }
      return [];
    }, Ai = () => {
      Jt.value ? ji() : Ni();
    }, Ni = () => {
      document.getElementById("smartcut-checkout").requestFullscreen(), Jt.value = !0;
    }, ji = () => {
      document.exitFullscreen && document.exitFullscreen(), Jt.value = !1;
    };
    p = Fn(() => {
      v.value = window.innerWidth;
    }, 30);
    const qi = () => {
      var Bt, Mt;
      if ((Mt = (Bt = Ot.value) == null ? void 0 : Bt.api) != null && Mt.whiteLabel) return !0;
      let Q = !0;
      const mt = document.querySelector("#smartcut-app #credit"), dt = document.querySelector("#smartcut-app #credit a");
      return [mt, dt].forEach((pe, me) => {
        if (!pe) return Q = !1;
        const Ce = window.getComputedStyle(pe);
        if (Ce.display === "none" || Ce.display === "hidden" || Ce.opacity === "0" || Ce.color === "transparent" || Ce.position !== "relative" || me === 1 && Ce.color !== "#4e4e4e" && Ce.color !== "rgb(78, 78, 78)")
          return Q = !1;
      }), _.value = Q, Q;
    }, xr = (Q, mt, dt, Bt, Mt) => {
      Dm(
        Q,
        mt,
        dt,
        Bt,
        Mt,
        o.findExtrasPrice
      );
    }, Br = (Q, mt, dt, Bt) => {
      f6(
        Q,
        mt,
        dt,
        Bt,
        mt === "banding" ? zl : [],
        o.findExtrasPrice
      );
    }, rr = (Q, mt) => {
      const dt = mt === "banding" ? $t == null ? void 0 : $t.labels : ee == null ? void 0 : ee.labels;
      c6(Q, mt, dt);
      const Bt = Ud(mt);
      if (Q != null && Q[Bt])
        for (const Mt in Q[Bt]) {
          const pe = wc(Q, mt, Mt, o.findExtrasPrice);
          Fl(Q, mt, Mt, !!pe);
        }
    }, jr = (Q) => {
      const mt = Object.keys(Q);
      return Math.max(...mt.map((Bt) => Bt.split("|").length));
    }, qr = (Q) => {
      const mt = [], dt = Object.keys(Q), Bt = jr(Q);
      for (let Mt = Bt; Mt--; ) mt.push(/* @__PURE__ */ new Set());
      for (const Mt of dt)
        Mt.split("|").forEach((me, Ce) => mt[Ce].add(me));
      for (let Mt = 0; Mt < Bt; Mt++)
        mt[Mt] = Array.from(mt[Mt]);
      return mt;
    }, zr = (Q, mt = [], dt) => {
      if (!Q) return [];
      if (dt > 0 && !mt[dt - 1]) return [];
      const Bt = /* @__PURE__ */ new Set();
      for (const Mt of Object.keys(Q)) {
        const pe = Mt.split("|");
        if (pe.length > dt) {
          let me = !0;
          for (let Ce = 0; Ce < dt; Ce++)
            if (mt[Ce] && pe[Ce] !== mt[Ce]) {
              me = !1;
              break;
            }
          me && Bt.add(pe[dt]);
        }
      }
      return Array.from(Bt);
    }, as = (Q, mt, dt) => wc(
      Q,
      mt,
      dt,
      o.findExtrasPrice
    ), Eo = (Q = "issues", mt, dt) => ZS(Q, mt, dt), ls = (Q) => {
      const mt = L.value.findIndex((dt) => dt.shapeId === Q.shapeId);
      mt !== -1 ? L.value[mt] = Q : L.value.push(Q), window.smartcutImages = L.value;
    }, Oo = (Q) => {
      L.value = L.value.filter((mt) => mt.shapeId !== Q), window.smartcutImages = L.value;
    }, us = (Q = 1) => {
      for (let mt = Q; mt--; ) {
        let dt;
        if (D.value.length > 0) {
          const Bt = D.value[D.value.length - 1];
          dt = $r({
            material: Bt.material,
            t: Bt.t
          });
        } else
          dt = $r();
        D.value.push(dt);
      }
    }, Hs = (Q) => {
      var dt;
      if (o.readonly || D.value.length === 1) return;
      const mt = D.value[Q].listId;
      D.value.splice(Q, 1), ((dt = G.value) == null ? void 0 : dt.listId) === mt && (G.value = null), vc(oe);
    }, $r = ({
      l: Q = null,
      w: mt = V.stockType === "linear" ? ((Li) => (Li = tt.value[0]) == null ? void 0 : Li.w)() : null,
      t: dt = ft.value.length ? ft.value[0] : null,
      q: Bt = 1,
      material: Mt = ((Fa) => (Fa = St.value) == null ? void 0 : Fa.length)() === 1 ? St.value[0].name : "",
      name: pe = null,
      orientationLock: me = null,
      bandingOptions: Ce = null,
      finishOptions: ln = null,
      banding: Be = null,
      finish: Ie = null,
      customData: $e = null,
      readonly: Kt = !1
    } = {}) => {
      var Ys, Wr;
      const $i = {
        id: (D.value.length + 1).toString(),
        units: o.units,
        l: Q,
        w: mt,
        t: dt,
        q: Bt,
        material: Mt,
        name: pe,
        orientationLock: me,
        banding: Be,
        bandingOptions: Ce,
        finish: Ie,
        finishOptions: ln,
        customData: $e,
        readonly: Kt
      }, ds = new vd($i);
      return (Ys = $t == null ? void 0 : $t.labels) != null && Ys.length && rr(ds, "banding"), (Wr = ee == null ? void 0 : ee.labels) != null && Wr.length && rr(ds, "finish"), ds;
    }, To = ({
      name: Q = "",
      l: mt = null,
      w: dt = null,
      t: Bt = null,
      material: Mt = "",
      q: pe = 1,
      trim: me = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      grain: Ce = "",
      cost: ln = 0,
      allowExactFitShapes: Be = !1,
      notes: Ie = ""
    }) => new m1({
      id: (tt.value.length + 1).toString(),
      name: Q,
      units: o.units,
      l: mt,
      w: dt,
      t: Bt,
      material: Mt,
      q: pe,
      autoAdd: !0,
      trim: me,
      grain: Ce,
      cost: ln,
      allowExactFitShapes: Be,
      notes: Ie
    }), Ea = (Q, mt) => {
      const dt = te(Q.l), Bt = te(Q.w), Mt = Q.t ? te(Q.t) : null, pe = new qs(V), me = new is({
        id: (mt + 1).toString() + ".0",
        name: Q != null && Q.name ? Q.name : `${dt}x${Bt}`,
        l: dt,
        w: Bt,
        t: Mt,
        saw: pe,
        material: Q.material,
        grain: Q.grain,
        autoAdd: !0,
        cost: Q == null ? void 0 : Q.cost,
        trim: Q.trim,
        allowExactFitShapes: Q.allowExactFitShapes,
        type: V.stockType,
        notes: Q == null ? void 0 : Q.notes
      });
      return H.value.push(me), me.issues;
    }, cs = () => {
      var mt, dt;
      const Q = [];
      for (let Bt = 0; Bt < D.value.length; Bt++) {
        const Mt = D.value[Bt];
        if (te(Mt.l) < te(x.minDimension) && Mt.issues.push({
          message: l("Part") + ` ${Bt + 1}: ` + l("Minimum dimension is") + ` ${x.minDimension}`,
          field: ["l"],
          index: Bt
        }), te(Mt.w) < te(x.minDimension) && Mt.issues.push({
          message: l("Part") + ` ${Bt + 1}: ` + l("Minimum dimension is") + ` ${x.minDimension}`,
          field: ["w"],
          index: Bt
        }), (mt = Mt == null ? void 0 : Mt.issues) != null && mt.length && Q.push(...Mt.issues.map((Ce) => (Ce.message = l("Part") + ` ${Bt + 1}: ${Ce.message}`, Ce))), !Mt.l || !Mt.w || !Mt.q) continue;
        Mt.applyPartTrim(
          x.partTrim,
          V.stockType
        );
        const pe = {
          id: (Bt + 1).toString() + ".0",
          l: te(Mt == null ? void 0 : Mt.l),
          w: te(Mt == null ? void 0 : Mt.w),
          t: Mt != null && Mt.t ? te(Mt.t) : null,
          material: Mt != null && Mt.material ? Mt.material : null,
          q: typeof Mt.q != "number" ? parseInt(Mt.q) : Mt.q,
          name: Mt.name,
          orientationLock: Mt.orientationLock,
          banding: Mt.banding,
          finish: Mt.finish,
          machining: Mt.machining,
          customData: Mt.customData,
          trim: Mt.trim,
          units: o.units
        }, me = new rs(m6(pe, x.orientationModel));
        me.trimDimensions(), ct.value.push(me), (dt = me == null ? void 0 : me.issues) != null && dt.length && Q.push(...me.issues);
      }
      return pn(), Q;
    }, Oa = (Q) => {
      a6.call({ activeStockId: Y }, Q);
    }, pn = () => {
      ft.value.length && ct.value.forEach((Q) => {
        if (!Q.t) return;
        const mt = ft.value.findIndex(
          (Mt) => te(Mt) === Q.t
        ), dt = Et.value.find((Mt) => Mt.includes(mt));
        if (!dt) return;
        const Bt = Math.min(
          ...dt.map((Mt) => ft.value[Mt])
        );
        Q.t > Bt && (Q.q = Q.q * (Q.t / Bt), Q.t = Bt);
      });
    }, Fo = () => {
      s6.call({
        vis: ae,
        stockList: H,
        activeStock: Yt,
        activeCuts: ht
      }), r6.call({
        vis: ae,
        shapeList: ct,
        activeShapes: F
      }, xt.value.length);
    }, Gs = () => {
      vc(oe), H.value = [], ct.value = [], it.value = [], M.value = 0;
    }, Mo = () => {
      D.value.length = 0, dr(() => us(1));
    }, Vs = () => {
      var Bt, Mt, pe;
      if (Pi(), x.maxParts && $.value > x.maxParts) {
        zi(l("The maximum number of parts is") + " " + x.maxParts);
        return;
      }
      if (a("calculating"), C.value) return !1;
      C.value = !0, E.value = !1;
      const Q = [];
      let mt = 0;
      for (const me of D.value)
        Q.push(...me.validate(
          tt.value,
          mt,
          V.stockType,
          null,
          !1
        )), mt++;
      if (Q.length) {
        console.warn(Q), zi({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.map( i => i.message ).slice( 0, 5 )
        }), C.value = !1;
        return;
      }
      if (Gs(), Q.push(...i6.call({
        inputStock: tt,
        stockList: H,
        createStock: Ea
      }, !1)), Q.length) {
        zi({
          heading: `Stock issue${Q.length > 1 ? "s" : ""}`,
          main: `${Q.length} issue${Q.length > 1 ? "s" : ""} found with stock inputs`,
          list: Q.map((me) => me.message)
        }), C.value = !1;
        return;
      }
      if (Q.push(...cs()), Q.length) {
        zi({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.slice( 0, 5 )
        }), C.value = !1;
        return;
      }
      if (X.value = new qs(
        V,
        (V == null ? void 0 : V.stockType) ?? ((Bt = H.value) == null ? void 0 : Bt[0].type)
      ), X.value.issues.length) {
        zi({
          heading: `Saw issue${X.value.issues.length > 1 ? "s" : ""}`,
          main: `${X.value.issues.length} issue${X.value.issues.length > 1 ? "s" : ""} found with saw inputs`
          // list: saw.value.issues.slice( 0, 5 )
        }), C.value = !1;
        return;
      }
      if (!((Mt = H.value) != null && Mt.length)) {
        zi({
          heading: "No stock",
          main: "No stock items were found",
          list: []
        }), C.value = !1;
        return;
      }
      if (!((pe = ct.value) != null && pe.length)) {
        zi({
          heading: "No parts",
          main: "No parts in list",
          list: []
        }), C.value = !1;
        return;
      }
      o.debug && console.log(
        "SmartCut - calculating",
        "stock",
        H.value.map((me) => me.dimensions()),
        "parts",
        ct.value.map((me) => me.dimensions())
      ), f.connect();
      const dt = {
        inputs: {
          parts: D.value,
          stock: tt.value,
          saw: X.value
        },
        saw: X.value,
        shapeList: ct.value,
        stockList: H.value,
        enableEvo: q.value,
        domain: d
      };
      f.compress(!0).emit("calculate", dt);
    }, zi = (Q = {
      main: null,
      heading: null,
      list: []
    }) => {
      var mt;
      typeof Q == "object" ? (st.value = l(Q == null ? void 0 : Q.main), J.value = l(Q.heading), Q != null && Q.list && Array.isArray(Q.list) && ((mt = Q.list) != null && mt.length) && Q.list.forEach((dt) => {
        dt && (st.value += `

${l(dt)}`);
      })) : st.value = l(Q), nt.value = !0;
    }, Pi = () => {
      nt.value = !1, st.value = "", J.value = "";
    }, hs = () => {
      const Q = {
        elementID: "#diagram",
        env: u,
        main: !0,
        units: o.units,
        decimalPlaces: x.decimalPlaces,
        saw: V,
        app: !1,
        embed: !0,
        colors: x.colors,
        options: Nt,
        vueComponent: {
          env: u,
          stockList: H,
          shapeList: ct,
          activeStock: Yt,
          activeShapes: F,
          activeCuts: ht
        }
      };
      ae = new JS(Q), ae.initStock(Yt.value), ae.initShapes(F.value, ct.value), ae.initCuts(ht.value), we.value = !0;
    }, Gn = async (Q = !1) => {
      if (!ae) return !1;
      await ae.updateSize(Q), o6.call({ vis: ae });
    }, fs = (Q, mt) => {
      var Ie;
      if (jn(Q, !1), !Q || !mt || !(mt != null && mt[Q]) || !Rn(x, ["enable", Q])) return;
      const dt = [Q, "pricing"];
      if (!ac(mt, dt)) {
        a("error", `${dt.join(".")} not found in sent data`);
        return;
      }
      const Bt = Rn(mt, dt);
      if (typeof Bt != "object") {
        a("error", `${dt.join(".")} data must be an object`);
        return;
      }
      if (!No(Bt)) {
        a("error", `if provided, ${dt.join(".")} data must contain some values`);
        return;
      }
      const Mt = Object.keys(Bt), pe = Object.values(Bt);
      if (!Mt.length) {
        a("error", `no ${dt.join(".")} pricing found`);
        return;
      }
      const me = /,/;
      for (const $e of Mt)
        if (me.test($e)) {
          a("error", `${dt} keys must not contain commas and should only be separated by a pipe (|)`);
          return;
        }
      if (pe.some(($e) => isNaN($e))) {
        a("error", `${dt} values must be a number`);
        return;
      }
      const Ce = jr(Bt), ln = [Q, "labels"];
      let Be = [];
      if (ac(mt, ln))
        Be = Rn(mt, ln);
      else {
        a("error", `${ln.join(".")} not found`);
        return;
      }
      if (!Be) {
        a("error", `${ln.join(".")} data not provided`);
        return;
      }
      if (!Array.isArray(Be)) {
        a("error", `${ln.join(".")} data must be an array`);
        return;
      }
      if (!(Be != null && Be.length)) {
        a("error", `if provided, ${ln.join(".")} data must contain values`);
        return;
      }
      if (Be.length !== Ce) {
        a("error", `${ln.join(".")} length (${Be.length}) must match the number of levels in ${dt.join(".")} (${Ce})`);
        return;
      }
      switch (Q) {
        case "banding":
          $t.labels = Be, $t.pricing = Bt, $t.options = qr(Bt);
          break;
        case "finish":
          ee.labels = Be, ee.pricing = Bt, ee.options = qr(Bt);
          break;
      }
      if (jn(Q, !0), !!((Ie = D.value) != null && Ie.length))
        for (const $e of D.value)
          rr($e, Q);
    }, Ur = (Q, mt) => {
      if (!mt) return;
      Q !== "info" && Object.keys(vt).forEach((Bt) => {
        Bt !== Q && Bt !== "info" && (vt[Bt] = null);
      });
      const dt = D.value.indexOf(mt);
      vt[Q] === dt ? (G.value = null, vt[Q] = null) : (G.value = mt, vt[Q] = dt);
    }, Ro = (Q) => {
      a("log", ["SmartCut - load event received"]), Do(Q.detail);
    }, Do = (Q) => {
      var dt, Bt, Mt;
      if (a("log", ["SmartCut - loading parts..."]), !Q || !((Bt = (dt = Q == null ? void 0 : Q.inputs) == null ? void 0 : dt.parts) != null && Bt.length)) return;
      D.value = [];
      let mt = 0;
      for (const pe of Q.inputs.parts) {
        const me = $r(pe);
        console.log(`inputShape ${mt}`, pe.orientationLock || "N/A", me.orientationLock || "N/A"), me ? (D.value.push(me), (Mt = me.issues) != null && Mt.length && a("log", [`SmartCut - issues found while importing part at index ${mt}`, me.issues])) : a("log", [`SmartCut - error loading part at index ${mt}`, pe]), mt++;
      }
      a("log", [`SmartCut - loaded ${D.value.length} parts`]);
    }, Ta = (Q) => {
      D.value.length = 0, dr(() => {
        var mt, dt;
        for (const Bt of Q)
          Bt.t = ((dt = (mt = tt.value) == null ? void 0 : mt[0]) == null ? void 0 : dt.t) ?? null, D.value.push($r(Bt));
      });
    };
    Qi(() => o.stock, (Q) => {
      if (Gs(), Array.isArray(Q) || console.warn("SmartCut - stock must be passed as an array"), !!(Q != null && Q.length)) {
        tt.value = [], St.value.length || yn(Q);
        for (const mt of Q) {
          mt.type = V.stockType;
          const dt = To(mt);
          tt.value.push(dt);
        }
        tt.value.length && (D.value.length ? dr(() => {
          D.value.forEach((mt) => {
            if (mt.material) {
              const dt = St.value.find((Bt) => Bt.name === mt.material);
              dt && (dt.thicknesses.includes(te(mt.t)) || (mt.t = dt.thicknesses[0]), mt.t == null && (mt.t = dt.thicknesses[0]));
            } else
              mt.t = tt.value[0].t;
          });
        }) : dr(() => us(1)));
      }
    }, { immediate: !0 }), Qi(D, (Q) => {
      a("inputs-changed"), Q.forEach((mt) => {
        var Bt;
        V.stockType === "linear" && (mt.w = (Bt = tt.value[0]) == null ? void 0 : Bt.w);
        const dt = St.value.find((Mt) => Mt.name === mt.material);
        dt && (dt.thicknesses.includes(te(mt.t)) || (mt.t = dt.thicknesses[0]));
      });
    }, { deep: !0 }), Qi(M, (Q) => {
      if (!Q) return;
      we.value && Gn(), z.value || a("error", "SmartCut - no metadata received from server"), pn();
      const mt = {
        jobId: M.value,
        metadata: z.value,
        parts: gt.value.map((dt) => {
          var Bt, Mt, pe;
          return {
            l: dt.l,
            w: dt.w,
            t: dt == null ? void 0 : dt.t,
            material: dt.material,
            orientationLock: dt.orientationLock,
            q: (Mt = (Bt = z.value) == null ? void 0 : Bt.addedPartTally) == null ? void 0 : Mt[dt.parentID],
            name: dt.name,
            banding: dt.banding,
            finish: dt.finish,
            customData: dt.customData,
            stockId: ((pe = dt == null ? void 0 : dt.stock) == null ? void 0 : pe.id) || (dt == null ? void 0 : dt.stockId)
          };
        }),
        stock: qt.value.map((dt) => {
          var Bt, Mt;
          return {
            id: dt.id,
            name: dt == null ? void 0 : dt.name,
            l: dt.l,
            w: dt.w,
            t: dt == null ? void 0 : dt.t,
            material: dt.material,
            q: (Mt = (Bt = z.value) == null ? void 0 : Bt.usedStockTally) == null ? void 0 : Mt[dt.parentID],
            trim: dt == null ? void 0 : dt.trim,
            cost: dt == null ? void 0 : dt.cost,
            analysis: dt == null ? void 0 : dt.analysis,
            type: dt == null ? void 0 : dt.type
          };
        }),
        offcuts: P.value.map((dt) => ({
          l: dt.l,
          w: dt.w,
          t: (dt == null ? void 0 : dt.t) ?? null,
          q: dt.q,
          stockId: dt.stockId
        })),
        inputs: {
          parts: D.value.map((dt) => {
            const Bt = { ...dt };
            return delete Bt.listId, Bt;
          })
        }
      };
      if (z.value.unplacedParts.length) {
        const dt = z.value.unplacedParts.map((Bt) => Bt.id).join();
        zi(l("The following parts did not fit") + ": " + dt);
      }
      a("result", mt);
    }), Qi(v, () => {
      we.value && Gn();
    }), Qi(Y, () => {
      we.value && dr(() => Fo());
    });
    const Bo = () => {
      f && (f.disconnect(), f = null);
    };
    return Us(() => {
      if (O.value) return;
      const Q = new URL(window.location.href), mt = Q.searchParams.toString(), dt = Q.origin + Q.pathname + (mt ? `?${mt}` : "");
      b.value !== dt && (D.value.length = 0, us(1)), b.value = dt, h.value = x.locale;
      const Bt = {
        socket: null,
        connected: g,
        maintenanceMode: y,
        jobId: M,
        progress: oe,
        thinking: C,
        user: Ot,
        saw: X,
        stockList: H,
        shapeList: ct,
        cutList: it,
        offcuts: P,
        metadata: z,
        usedStock: Dt,
        addedShapes: ot,
        activeStockId: Y
      };
      f = l6.call(Bt, "https://api.cutlistevo.com/"), f.connect(), f.emit("getUserFromDomain"), window.addEventListener("resize", p, { passive: !0 }), window.addEventListener("smartcut/load", Ro), O.value = !0, o.debug && a("log", [
        "SmartCut - ready...",
        "fields:",
        ie.value.map((Mt) => Mt.id)
      ]), typeof window < "u" && (window.smartcutCheckout = { init: nr });
    }), _c(() => {
      window.removeEventListener("resize", p), window.removeEventListener("smartcut/load", Ro), Bo(), delete window.smartcutCheckout;
    }), t({
      init: nr,
      getAvailablePricingOptions: zr,
      getExtrasPrice: as,
      formatPrice: o.formatPrice,
      findExtrasPrice: o.findExtrasPrice,
      inputShapes: D,
      initExtrasOptions: rr,
      createShapeInput: $r
    }), (Q, mt) => {
      var Bt, Mt, pe, me, Ce, ln, Be;
      const dt = Ml("font-awesome-icon");
      return Qt(), le(Qn, null, [
        Oe(u) === "development" && zk ? (Qt(), le("div", vk, [
          mt[5] || (mt[5] = ye("div", null, "Developer information", -1)),
          Zn(Oe(s), {
            data: [x.enable],
            paths: ["options.enable"]
          }, null, 8, ["data"])
        ])) : ke("", !0),
        zt.value && ((Bt = G.value) != null && Bt.machining) ? (Qt(), Un(Oe(i), {
          key: 1,
          shape: G.value,
          "onUpdate:shape": mt[0] || (mt[0] = (Ie) => G.value = Ie),
          translate: !0,
          options: Tt,
          env: Oe(u),
          "find-extras-price": n.findExtrasPrice,
          "get-extras-price": as,
          "get-available-pricing-options": zr,
          "format-price": n.formatPrice,
          onClose: ti
        }, null, 8, ["shape", "options", "env", "find-extras-price", "format-price"])) : ke("", !0),
        R.value ? ke("", !0) : (Qt(), le("div", wk, [
          Zn(Vg, {
            size: 50,
            "show-number": !1
          })
        ])),
        R.value ? (Qt(), le("div", {
          key: 3,
          id: "smartcut-checkout",
          class: di({ fullscreen: Jt.value })
        }, [
          S.value && !n.readonly ? (Qt(), le("div", {
            key: 0,
            id: "smartcut-full-screen",
            class: "icon-left",
            onClick: mt[1] || (mt[1] = (Ie) => Ai())
          }, [
            Zn(dt, { icon: ["fasr", "expand"] }),
            va(" " + hn(Oe(l)("full screen")), 1)
          ])) : ke("", !0),
          (pe = (Mt = Ot.value) == null ? void 0 : Mt.api) != null && pe.whiteLabel ? ke("", !0) : (Qt(), le("div", {
            key: 1,
            id: "credit",
            style: Dn(Te.value)
          }, [
            ye("a", {
              title: "SmartCut | Cut list optimization software",
              style: Dn(_n.value),
              target: "_blank",
              href: "https://smartcut.dev/"
            }, hn(Oe(l)("Powered by SmartCut")), 5)
          ], 4)),
          ye("div", {
            id: "part-input",
            class: "inputs no-margin-top grid-table",
            style: Dn({ "grid-template-columns": We.value })
          }, [
            Oe(D).length ? (Qt(), le("div", xk, [
              mt[6] || (mt[6] = ye("div", { class: "cell id" }, null, -1)),
              (Qt(!0), le(Qn, null, Lr(ie.value, (Ie) => (Qt(), le("div", {
                key: Ie.id,
                class: di(["cell", { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Ie.id) || Ie.type === "checkbox" }])
              }, hn(Ie.label), 3))), 128)),
              Oe(u) === "development" ? (Qt(), le("div", _k, " Info ")) : ke("", !0),
              Oe(D).length > 1 ? (Qt(), le("div", Sk)) : ke("", !0)
            ])) : ke("", !0),
            (Qt(!0), le(Qn, null, Lr(Oe(D), (Ie, $e) => (Qt(), le("div", {
              key: $e,
              class: "row inputs"
            }, [
              ye("div", kk, [
                ye("div", {
                  class: "id",
                  style: Dn({
                    background: x.colors.partA,
                    color: x.colors.text
                  })
                }, hn($e + 1), 5)
              ]),
              (Qt(!0), le(Qn, null, Lr(ie.value, (Kt) => (Qt(), le("div", {
                key: Kt.fieldMap,
                class: di(["cell", [`${Kt.id}`, { center: ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Kt.id) || Kt.type === "checkbox" }]])
              }, [
                ["orientationLock", "banding", "finish", "machining", "imageUpload"].includes(Kt.id) ? Kt.id === "orientationLock" ? (Qt(), Un(j6, {
                  key: 1,
                  id: "orientation-" + $e,
                  rectangle: Ie,
                  disabled: n.readonly,
                  "stock-grain": Ln(Ie),
                  "button-background": x.colors.button,
                  "icon-color": x.colors.buttonText,
                  "orientation-model": x.orientationModel,
                  onUpdateOrientation: (Li) => Di(Ie, Li)
                }, null, 8, ["id", "rectangle", "disabled", "stock-grain", "button-background", "icon-color", "orientation-model", "onUpdateOrientation"])) : Kt.id === "banding" ? (Qt(), Un(z6, {
                  key: 2,
                  id: "banding-" + $e,
                  "input-shape": Ie,
                  disabled: n.readonly,
                  "stock-grain": Ln(Ie),
                  open: vt.banding === $e,
                  "orientation-model": x.orientationModel,
                  onClicked: (Li) => Ur("banding", Ie)
                }, null, 8, ["id", "input-shape", "disabled", "stock-grain", "open", "orientation-model", "onClicked"])) : Kt.id === "finish" ? (Qt(), Un(ak, {
                  key: 3,
                  id: "finish-" + $e,
                  "input-shape": Ie,
                  disabled: n.readonly,
                  open: vt.finish === $e,
                  onClicked: (Li) => Ur("finish", Ie)
                }, null, 8, ["id", "input-shape", "disabled", "open", "onClicked"])) : Kt.fieldMap === "machining" && S.value ? (Qt(), Un(hk, {
                  key: 4,
                  id: "machining-" + $e,
                  disabled: n.readonly,
                  "input-shape": Ie,
                  onOpen: (Li) => Bi(Ie)
                }, null, 8, ["id", "disabled", "input-shape", "onOpen"])) : Kt.fieldMap === "imageUpload" ? (Qt(), le("button", {
                  key: 5,
                  id: "image-upload-" + $e,
                  type: "button",
                  disabled: n.readonly,
                  class: di({ selected: vt.info === $e }),
                  onClick: (Li) => Ur("imageUpload", Ie)
                }, [
                  Zn(dt, { icon: ["fass", "image"] })
                ], 10, Ak)) : ke("", !0) : (Qt(), Un(wl, {
                  key: 0,
                  id: Kt.id + "-" + $e,
                  focus: !n.readonly && x.enable.focus && $e === Oe(D).length - 1 && Kt.id === "l",
                  warning: Eo("warnings", Ie, Kt.fieldMap),
                  issue: Eo("issues", Ie, Kt.fieldMap),
                  type: Kt.type,
                  output: Kt.output,
                  label: Kt.label,
                  units: n.units,
                  readonly: n.readonly,
                  placeholder: Kt == null ? void 0 : Kt.placeholder,
                  options: Kt.id === "t" ? bn(Ie) : Kt == null ? void 0 : Kt.options,
                  "true-value": Kt == null ? void 0 : Kt.trueValue,
                  "false-value": Kt == null ? void 0 : Kt.falseValue,
                  default: Kt == null ? void 0 : Kt.default,
                  min: typeof (Kt == null ? void 0 : Kt.min) == "number" ? Kt.min : null,
                  max: typeof (Kt == null ? void 0 : Kt.max) == "number" ? Kt.max : null,
                  custom: Kt == null ? void 0 : Kt.custom,
                  value: Qe(Ie, Kt == null ? void 0 : Kt.fieldMap),
                  text: {
                    delete: Oe(l)("delete"),
                    select: Oe(l)("select")
                  },
                  onUpdate: (Li) => {
                    Kt.fieldMap && Ne(Ie, Kt.fieldMap, Li);
                  }
                }, null, 8, ["id", "focus", "warning", "issue", "type", "output", "label", "units", "readonly", "placeholder", "options", "true-value", "false-value", "default", "min", "max", "custom", "value", "text", "onUpdate"]))
              ], 2))), 128)),
              Oe(u) === "development" ? (Qt(), le("div", Nk, [
                ye("button", {
                  type: "button",
                  class: di({ selected: vt.info === $e }),
                  onClick: (Kt) => Ur("info", Ie)
                }, " i ", 10, Ck)
              ])) : ke("", !0),
              Oe(D).length > 1 ? (Qt(), le("div", Pk, [
                ye("button", {
                  type: "button",
                  disabled: n.readonly,
                  class: "delete",
                  "aria-label": Oe(l)("remove part"),
                  onClick: (Kt) => Hs($e)
                }, [
                  Zn(dt, { icon: ["fass", "trash"] })
                ], 8, Lk)
              ])) : ke("", !0),
              vt.banding === $e && $t.options.length > 0 ? (Qt(), Un(Yg, {
                key: 2,
                env: Oe(u),
                shape: Ie,
                "shape-index": $e,
                "extra-type": "banding",
                "extra-label": "banding",
                "extra-keys": $t.keys,
                "all-options": $t.options,
                pricing: $t.pricing,
                labels: $t.labels,
                "user-friendly-field-map": Oe(of),
                "part-columns": de.value,
                "get-price": as,
                "format-price": n.formatPrice,
                "orientation-model": x.orientationModel,
                "get-available-pricing-options": zr,
                onUpdateAll: Br,
                onSet: xr
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : ke("", !0),
              vt.finish === $e && ee.options.length > 0 ? (Qt(), Un(Yg, {
                key: 3,
                env: Oe(u),
                shape: Ie,
                "shape-index": $e,
                "extra-type": "finish",
                "extra-label": "finish",
                "extra-keys": ee.keys,
                "all-options": ee.options,
                pricing: ee.pricing,
                labels: ee.labels,
                "user-friendly-field-map": Oe(of),
                "part-columns": de.value,
                "get-price": as,
                "format-price": n.formatPrice,
                "orientation-model": x.orientationModel,
                "get-available-pricing-options": zr,
                onUpdateAll: Br,
                onSet: xr
              }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : ke("", !0),
              vt.info === $e ? (Qt(), le("div", {
                key: 4,
                id: "shape-info",
                style: Dn({ "grid-column-end": "span " + (de.value + 1) })
              }, " Orientation lock " + hn(Ie.orientationLock.toUpperCase() || "N/A"), 5)) : ke("", !0),
              vt.imageUpload === $e ? (Qt(), Un(bk, {
                key: 5,
                prefix: ($e + 1).toString(),
                "unique-id": Oe(A),
                "shape-id": Ie.listId,
                env: Oe(u),
                style: Dn({ "grid-column-end": "span " + (de.value + 1) }),
                images: L.value,
                onUpdate: ls,
                onRemove: Oo
              }, null, 8, ["prefix", "unique-id", "shape-id", "env", "style", "images"])) : ke("", !0)
            ]))), 128))
          ], 4),
          ye("div", Ik, [
            n.readonly ? ke("", !0) : (Qt(), le("button", {
              key: 0,
              type: "button",
              "aria-label": Oe(l)("add part"),
              style: Dn({ background: x.colors.button, color: x.colors.buttonText }),
              class: "add c-btn icon-left",
              onClick: mt[2] || (mt[2] = (Ie) => us(1))
            }, [
              Zn(dt, { icon: ["fasr", "plus-large"] }),
              va(" " + hn(Oe(l)("add part")), 1)
            ], 12, Ek)),
            ye("button", {
              id: "calculate-button",
              type: "button",
              class: "c-btn calculate icon-left",
              "aria-label": Oe(l)("calculate"),
              style: Dn({
                background: x.colors.button,
                color: x.colors.buttonText
              }),
              disabled: !((me = tt.value) != null && me.length) || C.value,
              onClick: mt[3] || (mt[3] = (Ie) => Vs())
            }, [
              Zn(dt, { icon: ["fass", "calculator"] }),
              va(hn(Oe(l)("calculate")), 1)
            ], 12, Ok),
            n.readonly ? ke("", !0) : (Qt(), le("button", {
              key: 1,
              type: "button",
              class: "c-btn clear",
              "aria-label": Oe(l)("clear"),
              onClick: mt[4] || (mt[4] = (Ie) => Mo())
            }, [
              Zn(dt, { icon: ["fass", "trash"] })
            ], 8, Tk)),
            ye("div", Fk, hn($.value) + hn(x != null && x.maxParts ? "/" + x.maxParts : ""), 1)
          ]),
          N.value && !n.readonly ? (Qt(), Un(Oe(r), {
            key: 2,
            ref: "import",
            units: n.units,
            "custom-fields": Zt.value,
            "banding-options": $t.options,
            "banding-labels": $t.labels,
            "finish-options": ee.options,
            "finish-labels": ee.labels,
            options: {
              locale: x.locale
            },
            onImport: Ta
          }, null, 8, ["units", "custom-fields", "banding-options", "banding-labels", "finish-options", "finish-labels", "options"])) : ke("", !0),
          nt.value ? (Qt(), le("div", Mk, [
            J.value ? (Qt(), le("div", Rk, hn(J.value), 1)) : ke("", !0),
            ye("pre", Dk, hn(st.value), 1)
          ])) : ke("", !0),
          (x.enable.diagram ? C.value && !oe.value.complete : C.value || oe.value.complete) ? (Qt(), le("div", Bk, [
            Zn(Vg, {
              size: 50,
              number: oe.value.shapeCount,
              complete: oe.value.complete,
              "show-number": x.enable.progressNumber
            }, null, 8, ["number", "complete", "show-number"])
          ])) : ke("", !0),
          Xg(ye("div", jk, [
            ((Ce = Yt.value) == null ? void 0 : Ce.type) !== "roll" ? (Qt(), le("div", qk, hn((ln = Yt.value) != null && ln.stack ? (Be = Yt.value) == null ? void 0 : Be.stack : 1), 1)) : ke("", !0)
          ], 512), [
            [Jg, x.enable.diagram && M.value > 0]
          ]),
          x.enable.diagram && we.value && Dt.value.length > 1 && M.value > 0 && oe.value.complete ? (Qt(), Un(_6, {
            key: 5,
            ref: "stockNavigation",
            "active-stock-id": Y.value,
            "stock-list": Xt.value,
            "stock-count": H.value.length,
            "viewport-width": v.value,
            onShowStock: Oa
          }, null, 8, ["active-stock-id", "stock-list", "stock-count", "viewport-width"])) : ke("", !0)
        ], 2)) : ke("", !0)
      ], 64);
    };
  }
});
function Kg(n) {
  const t = n;
  t.__i18n = t.__i18n || [], t.__i18n.push({
    locale: "",
    resource: {
      en_US: {
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Length" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Width" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Thickness" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "T" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Name" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantity" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Material" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machining" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grain" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Add part" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Remove part" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calculate" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Full screen" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Banding" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete banding" } },
        finish: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Finish" } },
        "image upload": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Image upload" } },
        "delete finish": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete finish" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Select" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Delete" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Clear" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "W2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "All" } },
        a: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        b: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "B" } },
        c: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        d: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "D" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Drop CSV file here" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Powered by SmartCut" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part issue" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Issue with part inputs" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts in list" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No quantity of parts found" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No parts were added - please double check your list." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The following parts did not fit" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "The maximum number of parts is" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No valid parts found" } },
        Hardware: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware" } },
        "Hardware total": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Hardware total" } },
        Panels: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Panels" } },
        pdf: {
          orderSummary: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Order summary" } },
          stockRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Stock requirements" } },
          rollRequirements: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Roll requirements" } },
          totals: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Totals" } },
          item: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Item" } },
          totalParts: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total parts" } },
          partArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part area" } },
          images: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Images" } },
          totalStockRequired: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total stock required" } },
          totalBandingLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total banding length" } },
          totalFinishArea: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total finish area" } },
          totalRollLength: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Total roll length" } },
          partIndex: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Part index" } },
          fileName: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "File name" } },
          link: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Link" } }
        }
      },
      ca: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Llarg" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ample" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gruix" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantitat" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Q" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanitzat" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Gir" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Afegeix" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantell" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina cantell" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Neteja" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Peça" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les peces següents no encaixaven" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número màxim de peces és" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No s'han trobat peces vàlides" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desenvolupat per SmartCut" } }
      },
      es_ES: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largo" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ancho" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Grueso" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "G" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nombre" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Cantidad" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "C" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Mecanizado" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Giro" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Añade" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Calcula" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pantalla completa" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Canto" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina canto" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Elimina" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Borra" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "A1" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Todos" } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pieza" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tema" } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Las siguientes piezas no encajaban" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "El número máximo de piezas es" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "No se encontraron piezas válidas" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Carga el archivo CSV aquí" } },
        "Powered by SmartCut": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Desarrollado por SmartCut" } }
      },
      fr_FR: {
        length: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Longueur" } },
        l: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L" } },
        width: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Largeur" } },
        w: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la" } },
        thickness: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Epaisseur" } },
        t: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "ep" } },
        name: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Nom" } },
        quantity: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Quantité" } },
        q: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Qt" } },
        material: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Matèriel" } },
        machining: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Machinage" } },
        grain: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sens de fil" } },
        orientation: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Orientation" } },
        "add part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Ajouter pièce" } },
        "remove part": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer pièce" } },
        calculate: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Optimiser" } },
        "full screen": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Plein écran" } },
        banding: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Chants" } },
        "delete banding": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer chants" } },
        select: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Sélectionner" } },
        delete: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Supprimer" } },
        clear: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Effacer" } },
        l1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L1" } },
        l2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "L2" } },
        w1: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la1" } },
        w2: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "la2" } },
        all: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Tous" } },
        "N/A": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "N/A" } },
        "Powered by SmartCut": { t: 0, b: { static: "", t: 2, i: [] } },
        Part: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce" } },
        "Drop CSV file here": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Télécharger CSV" } },
        Issue: { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur" } },
        "Part issue": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Pièce erreur" } },
        "Issue with part inputs": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Erreur avec l'importation de pièces" } },
        "No parts": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce" } },
        "No parts in list": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce dans la liste" } },
        "No quantity of parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune quantité trouvé pour certaines pièces" } },
        "No parts were added - please double check your list.": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce n'a été ajoutée - veuillez vérifier votre liste." } },
        "The following parts did not fit": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Les pièces suivantes ne s'adaptent pas" } },
        "The maximum number of parts is": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Le nombre maximum de pièces est" } },
        "No valid parts found": { t: 0, b: { t: 2, i: [{ t: 3 }], s: "Aucune pièce valide trouvée" } }
      }
    }
  });
}
typeof Kg == "function" && Kg(Bm);
const $k = /* @__PURE__ */ Ia(Bm, [["__scopeId", "data-v-d4a3b7df"]]), jm = ["banding", "finish", "cutLength", "perPart", "partArea", "offcutArea", "rollLength", "surcharge", "machining", "stock", "custom"], Uk = (n) => jm.includes(n);
function Wk(n, t) {
  const e = (u) => {
    var d;
    (d = t.log) == null || d.call(t, u);
  }, i = (u) => {
    var d;
    return (d = t.error) == null || d.call(t, u), { success: !1, error: u };
  }, r = () => {
    for (const u of jm) s(u, 0);
  }, s = (u, d) => {
    const { inputs: p, elements: f, setInputValue: g, formatPrice: y } = t;
    if (isNaN(d)) throw new Error("Price must be a number");
    if (!Uk(u)) return;
    const b = {
      custom: {
        visible: null,
        hidden: "smartcut-custom-price"
      },
      perPart: {
        hidden: "smartcut-per-part-price",
        visible: "per_part_price"
      },
      partArea: {
        hidden: null,
        visible: "part_area_price"
      },
      offcutArea: {
        hidden: null,
        visible: "offcut_area_price"
      },
      rollLength: {
        hidden: null,
        visible: "roll_length_price"
      },
      banding: {
        hidden: "smartcut-banding-price",
        visible: "banding_total_price"
      },
      finish: {
        hidden: "smartcut-finish-price",
        visible: "finish_total_price"
      },
      machining: {
        hidden: "smartcut-machining-price",
        visible: "machining_total_price"
      },
      surcharge: {
        hidden: "smartcut-cut-to-size-surcharge",
        visible: "surcharge_price"
      },
      cutLength: {
        hidden: "smartcut-cut-length-price",
        visible: "cut_length_price"
      },
      stock: {
        hidden: null,
        visible: "stock_total_price"
      }
    }[u];
    b != null && b.hidden && p[b.hidden] && g(b.hidden, d), b != null && b.visible && f[b.visible] && (f[b.visible].innerText = y(d));
  }, o = (u) => {
    var O;
    const { product: d, selectedVariation: p, isQuantityPricing: f, enableAddToCart: g, setCartQuantity: y } = t, _ = parseFloat((d == null ? void 0 : d.price) || ((O = p.value) == null ? void 0 : O.display_price) || "0"), b = n.unit_system === "imperial" ? "feet" : "meters", A = {
      full_stock: (R) => (e(["calculating cost by full sheet"]), f() ? (y(R.metadata.totalUsedStock), 0) : R.metadata.totalStockCost),
      part_area: (R) => {
        e([`calculating cost by part area in square ${b}`]);
        const C = n.unit_system === "imperial" ? 144 : 1e6, E = R.metadata.totalPartArea / C, M = E * _;
        s("partArea", M), e([`part area in square ${b} is ${E} with price ${M}`]);
        let q = E;
        if (n != null && n.enable_offcut_pricing && (R != null && R.offcuts)) {
          const S = R == null ? void 0 : R.offcuts.reduce((x, X) => {
            const V = X.l >= X.w ? X.l : X.w, D = X.l >= X.w ? X.w : X.l;
            return V < n.offcut_min_length || D < n.offcut_min_width ? x + V * D : x;
          }, 0), T = S / C * _;
          s("offcutArea", T), e([`calculated sellable offcut area as ${S}, with price ${T}`]), q += S / C;
        }
        const N = q * _;
        if (e([`calculated total price as ${N}, `]), f())
          e([`setting cart quantity to ${q}`]), y(q, 2);
        else
          return N;
        return 0;
      },
      cut_length: (R) => {
        e([`calculating cost by cut length in  ${b}`]);
        const C = n.unit_system === "imperial" ? 12 : 1e3, E = R.metadata.totalCutLength / C;
        return y(E, 2), 0;
      },
      full_stock_plus_cut_length: (R) => {
        e(["calculating cost by full sheet plus cut length"]);
        let C = 0;
        f() ? y(R.metadata.totalUsedStock) : C = R.metadata.totalStockCost;
        const E = n.unit_system === "imperial" ? 12 : 1e3, q = R.metadata.totalCutLength / E * n.cut_length_price;
        return s("cutLength", q), C + q;
      },
      full_stock_plus_num_parts: (R) => {
        e(["calculating cost by full sheet plus number of parts"]);
        let C = 0;
        if (f())
          y(R.metadata.totalUsedStock);
        else {
          const M = R.metadata.totalStockCost;
          s("stock", M), C = M;
        }
        const E = R.metadata.totalPartsProduced * n.per_part_price;
        return s("perPart", E), C + E;
      },
      roll_length: (R) => {
        e([`calculating cost by roll length in ${b}`]);
        const C = n.unit_system === "imperial" ? 12 : 1e3, E = R.stock.reduce((M, q) => M + q.analysis.rollLength / C * te(q.cost), 0);
        return s("rollLength", E), E;
      }
    }[n.pricing_strategy], L = A(u);
    return g(), L;
  }, a = (u, d) => {
    const {
      isExtraEnabled: p,
      isMachiningEnabled: f,
      isSurchargeEnabled: g,
      inputType: y,
      getTotalBandingPrice: _,
      getTotalFinishPrice: b,
      getTotalMachiningPrice: v,
      getInputValue: A
    } = t;
    let L = d;
    if (p("banding") && u.metadata.bandingLengthByType) {
      const O = _(u.metadata.bandingLengthByType);
      s("banding", O), L += O;
    }
    if (p("finish") && u.metadata.finishAreaByType) {
      const O = b(u.metadata.finishAreaByType);
      s("finish", O), L += O;
    }
    if (y.value === "formula") {
      const O = parseFloat(A("smartcut-hardware-price"));
      isNaN(O) || (L += O);
    }
    if (f()) {
      const O = v(u);
      s("machining", O), L += O;
    }
    if (g() && n.surcharge) {
      const O = n.surcharge_type === "per_sheet" ? parseFloat(n.surcharge.toString()) * u.metadata.totalUsedStock : parseFloat(n.surcharge.toString());
      s("surcharge", O), e(["added surcharge", O]), L += O;
    }
    return L;
  }, l = (u) => {
    const { getInputValue: d, setInputValue: p } = t, f = {
      "smartcut-job-id": u.jobId,
      "smartcut-dimensions": u.parts.map((g) => `${g.l}x${g.w} [${g.q}]`).join(", "),
      "smartcut-total-cut-length": u.metadata.totalCutLength,
      "smartcut-part-area": u.metadata.totalPartArea,
      "smartcut-total-cuts": u.metadata.totalCuts,
      "smartcut-total-parts": u.metadata.totalPartsProduced,
      "smartcut-machining": u.metadata.hasMachining
    };
    if (Object.entries(f).forEach(([g, y]) => {
      p(g, y);
    }), d("smartcut-stock-summary") !== void 0) {
      const g = u.stock.map((y) => `${y.l}x${y.w}${y.t ? "x" + y.t : ""} [${y.q}]`).join(", ");
      p("smartcut-stock-summary", g);
    }
  };
  return {
    calculatePrice: async (u) => {
      const { isQuantityPricing: d, selectedVariation: p, setVariationPrice: f, setCartQuantity: g } = t;
      if (!(u != null && u.jobId))
        return i("No job ID provided");
      d() || g(1);
      let y = o(u);
      if (!d()) {
        if (!u.metadata.totalStockCost)
          return i("Total stock cost not returned for a multiple size product");
        e([`total cost is ${y}`]), s("custom", y);
      }
      return y = a(u, y), p.value && f(y), l(u), { success: !0, totalPrice: y };
    },
    resetPricing: r
  };
}
function qu(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var qm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, r, s) {
      function o(h, u) {
        if (!r[h]) {
          if (!i[h]) {
            var d = typeof qu == "function" && qu;
            if (!u && d) return d(h, !0);
            if (a) return a(h, !0);
            var p = new Error("Cannot find module '" + h + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var f = r[h] = { exports: {} };
          i[h][0].call(f.exports, function(g) {
            var y = i[h][1][g];
            return o(y || g);
          }, f, f.exports, e, i, r, s);
        }
        return r[h].exports;
      }
      for (var a = typeof qu == "function" && qu, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ 1: [function(e, i, r) {
      var s = e("./utils"), o = e("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(l) {
        for (var h, u, d, p, f, g, y, _ = [], b = 0, v = l.length, A = v, L = s.getTypeOf(l) !== "string"; b < l.length; ) A = v - b, d = L ? (h = l[b++], u = b < v ? l[b++] : 0, b < v ? l[b++] : 0) : (h = l.charCodeAt(b++), u = b < v ? l.charCodeAt(b++) : 0, b < v ? l.charCodeAt(b++) : 0), p = h >> 2, f = (3 & h) << 4 | u >> 4, g = 1 < A ? (15 & u) << 2 | d >> 6 : 64, y = 2 < A ? 63 & d : 64, _.push(a.charAt(p) + a.charAt(f) + a.charAt(g) + a.charAt(y));
        return _.join("");
      }, r.decode = function(l) {
        var h, u, d, p, f, g, y = 0, _ = 0, b = "data:";
        if (l.substr(0, b.length) === b) throw new Error("Invalid base64 input, it looks like a data url.");
        var v, A = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && A--, l.charAt(l.length - 2) === a.charAt(64) && A--, A % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (v = o.uint8array ? new Uint8Array(0 | A) : new Array(0 | A); y < l.length; ) h = a.indexOf(l.charAt(y++)) << 2 | (p = a.indexOf(l.charAt(y++))) >> 4, u = (15 & p) << 4 | (f = a.indexOf(l.charAt(y++))) >> 2, d = (3 & f) << 6 | (g = a.indexOf(l.charAt(y++))), v[_++] = h, f !== 64 && (v[_++] = u), g !== 64 && (v[_++] = d);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, r) {
      var s = e("./external"), o = e("./stream/DataWorker"), a = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function h(u, d, p, f, g) {
        this.compressedSize = u, this.uncompressedSize = d, this.crc32 = p, this.compression = f, this.compressedContent = g;
      }
      h.prototype = { getContentWorker: function() {
        var u = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, h.createWorkerFrom = function(u, d, p) {
        return u.pipe(new a()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, i.exports = h;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, r) {
      var s = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, r) {
      var s = e("./utils"), o = function() {
        for (var a, l = [], h = 0; h < 256; h++) {
          a = h;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[h] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? function(h, u, d, p) {
          var f = o, g = p + d;
          h ^= -1;
          for (var y = p; y < g; y++) h = h >>> 8 ^ f[255 & (h ^ u[y])];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : function(h, u, d, p) {
          var f = o, g = p + d;
          h ^= -1;
          for (var y = p; y < g; y++) h = h >>> 8 ^ f[255 & (h ^ u.charCodeAt(y))];
          return -1 ^ h;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, r) {
      r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, i, r) {
      var s = null;
      s = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), a = e("./utils"), l = e("./stream/GenericWorker"), h = s ? "uint8array" : "array";
      function u(d, p) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = p, this.meta = {};
      }
      r.magic = "\b\0", a.inherits(u, l), u.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(h, d.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(p) {
          d.push({ data: p, meta: d.meta });
        };
      }, r.compressWorker = function(d) {
        return new u("Deflate", d);
      }, r.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, r) {
      function s(f, g) {
        var y, _ = "";
        for (y = 0; y < g; y++) _ += String.fromCharCode(255 & f), f >>>= 8;
        return _;
      }
      function o(f, g, y, _, b, v) {
        var A, L, O = f.file, R = f.compression, C = v !== h.utf8encode, E = a.transformTo("string", v(O.name)), M = a.transformTo("string", h.utf8encode(O.name)), q = O.comment, N = a.transformTo("string", v(q)), S = a.transformTo("string", h.utf8encode(q)), T = M.length !== O.name.length, x = S.length !== q.length, X = "", V = "", D = "", tt = O.dir, H = O.date, ct = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !y || (ct.crc32 = f.crc32, ct.compressedSize = f.compressedSize, ct.uncompressedSize = f.uncompressedSize);
        var it = 0;
        g && (it |= 8), C || !T && !x || (it |= 2048);
        var P = 0, z = 0;
        tt && (P |= 16), b === "UNIX" ? (z = 798, P |= function(Y, ot) {
          var xt = Y;
          return Y || (xt = ot ? 16893 : 33204), (65535 & xt) << 16;
        }(O.unixPermissions, tt)) : (z = 20, P |= function(Y) {
          return 63 & (Y || 0);
        }(O.dosPermissions)), A = H.getUTCHours(), A <<= 6, A |= H.getUTCMinutes(), A <<= 5, A |= H.getUTCSeconds() / 2, L = H.getUTCFullYear() - 1980, L <<= 4, L |= H.getUTCMonth() + 1, L <<= 5, L |= H.getUTCDate(), T && (V = s(1, 1) + s(u(E), 4) + M, X += "up" + s(V.length, 2) + V), x && (D = s(1, 1) + s(u(N), 4) + S, X += "uc" + s(D.length, 2) + D);
        var G = "";
        return G += `
\0`, G += s(it, 2), G += R.magic, G += s(A, 2), G += s(L, 2), G += s(ct.crc32, 4), G += s(ct.compressedSize, 4), G += s(ct.uncompressedSize, 4), G += s(E.length, 2), G += s(X.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + G + E + X, dirRecord: d.CENTRAL_FILE_HEADER + s(z, 2) + G + s(N.length, 2) + "\0\0\0\0" + s(P, 4) + s(_, 4) + E + X + N };
      }
      var a = e("../utils"), l = e("../stream/GenericWorker"), h = e("../utf8"), u = e("../crc32"), d = e("../signature");
      function p(f, g, y, _) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = y, this.encodeFileName = _, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(p, l), p.prototype.push = function(f) {
        var g = f.meta.percent || 0, y = this.entriesCount, _ = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, l.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: y ? (g + 100 * (y - _ - 1)) / y : 100 } }));
      }, p.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var g = this.streamFiles && !f.file.dir;
        if (g) {
          var y = o(f, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: y.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var g = this.streamFiles && !f.file.dir, y = o(f, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(y.dirRecord), g) this.push({ data: function(_) {
          return d.DATA_DESCRIPTOR + s(_.crc32, 4) + s(_.compressedSize, 4) + s(_.uncompressedSize, 4);
        }(f), meta: { percent: 100 } });
        else for (this.push({ data: y.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var f = this.bytesWritten, g = 0; g < this.dirRecords.length; g++) this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var y = this.bytesWritten - f, _ = function(b, v, A, L, O) {
          var R = a.transformTo("string", O(L));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(b, 2) + s(b, 2) + s(v, 4) + s(A, 4) + s(R.length, 2) + R;
        }(this.dirRecords.length, y, f, this.zipComment, this.encodeFileName);
        this.push({ data: _, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var g = this;
        return f.on("data", function(y) {
          g.processChunk(y);
        }), f.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), f.on("error", function(y) {
          g.error(y);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(f) {
        var g = this._sources;
        if (!l.prototype.error.call(this, f)) return !1;
        for (var y = 0; y < g.length; y++) try {
          g[y].error(f);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var f = this._sources, g = 0; g < f.length; g++) f[g].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, r) {
      var s = e("../compressions"), o = e("./ZipFileWorker");
      r.generateWorker = function(a, l, h) {
        var u = new o(l.streamFiles, h, l.platform, l.encodeFileName), d = 0;
        try {
          a.forEach(function(p, f) {
            d++;
            var g = function(v, A) {
              var L = v || A, O = s[L];
              if (!O) throw new Error(L + " is not a valid compression method !");
              return O;
            }(f.options.compression, l.compression), y = f.options.compressionOptions || l.compressionOptions || {}, _ = f.dir, b = f.date;
            f._compressWorker(g, y).withStreamInfo("file", { name: p, dir: _, date: b, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(u);
          }), u.entriesCount = d;
        } catch (p) {
          u.error(p);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, r) {
      function s() {
        if (!(this instanceof s)) return new s();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this) typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (s.prototype = e("./object")).loadAsync = e("./load"), s.support = e("./support"), s.defaults = e("./defaults"), s.version = "3.10.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = e("./external"), i.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, r) {
      var s = e("./utils"), o = e("./external"), a = e("./utf8"), l = e("./zipEntries"), h = e("./stream/Crc32Probe"), u = e("./nodejsUtils");
      function d(p) {
        return new o.Promise(function(f, g) {
          var y = p.decompressed.getContentWorker().pipe(new h());
          y.on("error", function(_) {
            g(_);
          }).on("end", function() {
            y.streamInfo.crc32 !== p.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      i.exports = function(p, f) {
        var g = this;
        return f = s.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), u.isNode && u.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", p, !0, f.optimizedBinaryString, f.base64).then(function(y) {
          var _ = new l(f);
          return _.load(y), _;
        }).then(function(y) {
          var _ = [o.Promise.resolve(y)], b = y.files;
          if (f.checkCRC32) for (var v = 0; v < b.length; v++) _.push(d(b[v]));
          return o.Promise.all(_);
        }).then(function(y) {
          for (var _ = y.shift(), b = _.files, v = 0; v < b.length; v++) {
            var A = b[v], L = A.fileNameStr, O = s.resolve(A.fileNameStr);
            g.file(O, A.decompressed, { binary: !0, optimizedBinaryString: !0, date: A.date, dir: A.dir, comment: A.fileCommentStr.length ? A.fileCommentStr : null, unixPermissions: A.unixPermissions, dosPermissions: A.dosPermissions, createFolders: f.createFolders }), A.dir || (g.file(O).unsafeOriginalName = L);
          }
          return _.zipComment.length && (g.comment = _.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, r) {
      var s = e("../utils"), o = e("../stream/GenericWorker");
      function a(l, h) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(h);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var h = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          h.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          h.isPaused ? this.generatedError = u : h.error(u);
        }).on("end", function() {
          h.isPaused ? h._upstreamEnded = !0 : h.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, r) {
      var s = e("readable-stream").Readable;
      function o(a, l, h) {
        s.call(this, l), this._helper = a;
        var u = this;
        a.on("data", function(d, p) {
          u.push(d) || u._helper.pause(), h && h(p);
        }).on("error", function(d) {
          u.emit("error", d);
        }).on("end", function() {
          u.push(null);
        });
      }
      e("../utils").inherits(o, s), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, r) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(s, o);
        if (typeof s == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(s, o);
      }, allocBuffer: function(s) {
        if (Buffer.alloc) return Buffer.alloc(s);
        var o = new Buffer(s);
        return o.fill(0), o;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(e, i, r) {
      function s(O, R, C) {
        var E, M = a.getTypeOf(R), q = a.extend(C || {}, u);
        q.date = q.date || /* @__PURE__ */ new Date(), q.compression !== null && (q.compression = q.compression.toUpperCase()), typeof q.unixPermissions == "string" && (q.unixPermissions = parseInt(q.unixPermissions, 8)), q.unixPermissions && 16384 & q.unixPermissions && (q.dir = !0), q.dosPermissions && 16 & q.dosPermissions && (q.dir = !0), q.dir && (O = b(O)), q.createFolders && (E = _(O)) && v.call(this, E, !0);
        var N = M === "string" && q.binary === !1 && q.base64 === !1;
        C && C.binary !== void 0 || (q.binary = !N), (R instanceof d && R.uncompressedSize === 0 || q.dir || !R || R.length === 0) && (q.base64 = !1, q.binary = !0, R = "", q.compression = "STORE", M = "string");
        var S = null;
        S = R instanceof d || R instanceof l ? R : g.isNode && g.isStream(R) ? new y(O, R) : a.prepareContent(O, R, q.binary, q.optimizedBinaryString, q.base64);
        var T = new p(O, S, q);
        this.files[O] = T;
      }
      var o = e("./utf8"), a = e("./utils"), l = e("./stream/GenericWorker"), h = e("./stream/StreamHelper"), u = e("./defaults"), d = e("./compressedObject"), p = e("./zipObject"), f = e("./generate"), g = e("./nodejsUtils"), y = e("./nodejs/NodejsStreamInputAdapter"), _ = function(O) {
        O.slice(-1) === "/" && (O = O.substring(0, O.length - 1));
        var R = O.lastIndexOf("/");
        return 0 < R ? O.substring(0, R) : "";
      }, b = function(O) {
        return O.slice(-1) !== "/" && (O += "/"), O;
      }, v = function(O, R) {
        return R = R !== void 0 ? R : u.createFolders, O = b(O), this.files[O] || s.call(this, O, null, { dir: !0, createFolders: R }), this.files[O];
      };
      function A(O) {
        return Object.prototype.toString.call(O) === "[object RegExp]";
      }
      var L = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(O) {
        var R, C, E;
        for (R in this.files) E = this.files[R], (C = R.slice(this.root.length, R.length)) && R.slice(0, this.root.length) === this.root && O(C, E);
      }, filter: function(O) {
        var R = [];
        return this.forEach(function(C, E) {
          O(C, E) && R.push(E);
        }), R;
      }, file: function(O, R, C) {
        if (arguments.length !== 1) return O = this.root + O, s.call(this, O, R, C), this;
        if (A(O)) {
          var E = O;
          return this.filter(function(q, N) {
            return !N.dir && E.test(q);
          });
        }
        var M = this.files[this.root + O];
        return M && !M.dir ? M : null;
      }, folder: function(O) {
        if (!O) return this;
        if (A(O)) return this.filter(function(M, q) {
          return q.dir && O.test(M);
        });
        var R = this.root + O, C = v.call(this, R), E = this.clone();
        return E.root = C.name, E;
      }, remove: function(O) {
        O = this.root + O;
        var R = this.files[O];
        if (R || (O.slice(-1) !== "/" && (O += "/"), R = this.files[O]), R && !R.dir) delete this.files[O];
        else for (var C = this.filter(function(M, q) {
          return q.name.slice(0, O.length) === O;
        }), E = 0; E < C.length; E++) delete this.files[C[E].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(O) {
        var R, C = {};
        try {
          if ((C = a.extend(O || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = C.type.toLowerCase(), C.compression = C.compression.toUpperCase(), C.type === "binarystring" && (C.type = "string"), !C.type) throw new Error("No output type specified.");
          a.checkSupport(C.type), C.platform !== "darwin" && C.platform !== "freebsd" && C.platform !== "linux" && C.platform !== "sunos" || (C.platform = "UNIX"), C.platform === "win32" && (C.platform = "DOS");
          var E = C.comment || this.comment || "";
          R = f.generateWorker(this, C, E);
        } catch (M) {
          (R = new l("error")).error(M);
        }
        return new h(R, C.type || "string", C.mimeType);
      }, generateAsync: function(O, R) {
        return this.generateInternalStream(O).accumulate(R);
      }, generateNodeStream: function(O, R) {
        return (O = O || {}).type || (O.type = "nodebuffer"), this.generateInternalStream(O).toNodejsStream(R);
      } };
      i.exports = L;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, r) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
        for (var l = 0; l < this.data.length; l++) a[l] = 255 & a[l];
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === l && this.data[p + 1] === h && this.data[p + 2] === u && this.data[p + 3] === d) return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), h = a.charCodeAt(1), u = a.charCodeAt(2), d = a.charCodeAt(3), p = this.readData(4);
        return l === p[0] && h === p[1] && u === p[2] && d === p[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, r) {
      var s = e("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, h = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--) h = (h << 8) + this.byteAt(l);
        return this.index += a, h;
      }, readString: function(a) {
        return s.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, r) {
      var s = e("./Uint8ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, r) {
      var s = e("./DataReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, r) {
      var s = e("./ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      e("../utils").inherits(o, s), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, r) {
      var s = e("../utils"), o = e("../support"), a = e("./ArrayReader"), l = e("./StringReader"), h = e("./NodeBufferReader"), u = e("./Uint8ArrayReader");
      i.exports = function(d) {
        var p = s.getTypeOf(d);
        return s.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new h(d) : o.uint8array ? new u(s.transformTo("uint8array", d)) : new a(s.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, r) {
      var s = e("./GenericWorker"), o = e("../crc32");
      function a() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(a, s), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var h = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = h + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, r) {
      var s = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var h = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          h.dataIsReady = !0, h.data = u, h.max = u && u.length || 0, h.type = s.getTypeOf(u), h.isPaused || h._tickAndRepeat();
        }, function(u) {
          h.error(u);
        });
      }
      s.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, h = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, h);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, h);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, h);
        }
        return this.index = h, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, r) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o]) for (var l = 0; l < this._listeners[o].length; l++) this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = s;
    }, {}], 29: [function(e, i, r) {
      var s = e("../utils"), o = e("./ConvertWorker"), a = e("./GenericWorker"), l = e("../base64"), h = e("../support"), u = e("../external"), d = null;
      if (h.nodestream) try {
        d = e("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(g, y) {
        return new u.Promise(function(_, b) {
          var v = [], A = g._internalType, L = g._outputType, O = g._mimeType;
          g.on("data", function(R, C) {
            v.push(R), y && y(C);
          }).on("error", function(R) {
            v = [], b(R);
          }).on("end", function() {
            try {
              var R = function(C, E, M) {
                switch (C) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", E), M);
                  case "base64":
                    return l.encode(E);
                  default:
                    return s.transformTo(C, E);
                }
              }(L, function(C, E) {
                var M, q = 0, N = null, S = 0;
                for (M = 0; M < E.length; M++) S += E[M].length;
                switch (C) {
                  case "string":
                    return E.join("");
                  case "array":
                    return Array.prototype.concat.apply([], E);
                  case "uint8array":
                    for (N = new Uint8Array(S), M = 0; M < E.length; M++) N.set(E[M], q), q += E[M].length;
                    return N;
                  case "nodebuffer":
                    return Buffer.concat(E);
                  default:
                    throw new Error("concat : unsupported type '" + C + "'");
                }
              }(A, v), O);
              _(R);
            } catch (C) {
              b(C);
            }
            v = [];
          }).resume();
        });
      }
      function f(g, y, _) {
        var b = y;
        switch (y) {
          case "blob":
          case "arraybuffer":
            b = "uint8array";
            break;
          case "base64":
            b = "string";
        }
        try {
          this._internalType = b, this._outputType = y, this._mimeType = _, s.checkSupport(b), this._worker = g.pipe(new o(b)), g.lock();
        } catch (v) {
          this._worker = new a("error"), this._worker.error(v);
        }
      }
      f.prototype = { accumulate: function(g) {
        return p(this, g);
      }, on: function(g, y) {
        var _ = this;
        return g === "data" ? this._worker.on(g, function(b) {
          y.call(_, b.data, b.meta);
        }) : this._worker.on(g, function() {
          s.delay(y, arguments, _);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, i.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, r) {
      if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") r.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          r.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(s), r.blob = o.getBlob("application/zip").size === 0;
          } catch {
            r.blob = !1;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch {
        r.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, r) {
      for (var s = e("./utils"), o = e("./support"), a = e("./nodejsUtils"), l = e("./stream/GenericWorker"), h = new Array(256), u = 0; u < 256; u++) h[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      h[254] = h[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      r.utf8encode = function(f) {
        return o.nodebuffer ? a.newBufferFrom(f, "utf-8") : function(g) {
          var y, _, b, v, A, L = g.length, O = 0;
          for (v = 0; v < L; v++) (64512 & (_ = g.charCodeAt(v))) == 55296 && v + 1 < L && (64512 & (b = g.charCodeAt(v + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (b - 56320), v++), O += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (y = o.uint8array ? new Uint8Array(O) : new Array(O), v = A = 0; A < O; v++) (64512 & (_ = g.charCodeAt(v))) == 55296 && v + 1 < L && (64512 & (b = g.charCodeAt(v + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (b - 56320), v++), _ < 128 ? y[A++] = _ : (_ < 2048 ? y[A++] = 192 | _ >>> 6 : (_ < 65536 ? y[A++] = 224 | _ >>> 12 : (y[A++] = 240 | _ >>> 18, y[A++] = 128 | _ >>> 12 & 63), y[A++] = 128 | _ >>> 6 & 63), y[A++] = 128 | 63 & _);
          return y;
        }(f);
      }, r.utf8decode = function(f) {
        return o.nodebuffer ? s.transformTo("nodebuffer", f).toString("utf-8") : function(g) {
          var y, _, b, v, A = g.length, L = new Array(2 * A);
          for (y = _ = 0; y < A; ) if ((b = g[y++]) < 128) L[_++] = b;
          else if (4 < (v = h[b])) L[_++] = 65533, y += v - 1;
          else {
            for (b &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && y < A; ) b = b << 6 | 63 & g[y++], v--;
            1 < v ? L[_++] = 65533 : b < 65536 ? L[_++] = b : (b -= 65536, L[_++] = 55296 | b >> 10 & 1023, L[_++] = 56320 | 1023 & b);
          }
          return L.length !== _ && (L.subarray ? L = L.subarray(0, _) : L.length = _), s.applyFromCharCode(L);
        }(f = s.transformTo(o.uint8array ? "uint8array" : "array", f));
      }, s.inherits(d, l), d.prototype.processChunk = function(f) {
        var g = s.transformTo(o.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var y = g;
            (g = new Uint8Array(y.length + this.leftOver.length)).set(this.leftOver, 0), g.set(y, this.leftOver.length);
          } else g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var _ = function(v, A) {
          var L;
          for ((A = A || v.length) > v.length && (A = v.length), L = A - 1; 0 <= L && (192 & v[L]) == 128; ) L--;
          return L < 0 || L === 0 ? A : L + h[v[L]] > A ? L : A;
        }(g), b = g;
        _ !== g.length && (o.uint8array ? (b = g.subarray(0, _), this.leftOver = g.subarray(_, g.length)) : (b = g.slice(0, _), this.leftOver = g.slice(_, g.length))), this.push({ data: r.utf8decode(b), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, r.Utf8DecodeWorker = d, s.inherits(p, l), p.prototype.processChunk = function(f) {
        this.push({ data: r.utf8encode(f.data), meta: f.meta });
      }, r.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, r) {
      var s = e("./support"), o = e("./base64"), a = e("./nodejsUtils"), l = e("./external");
      function h(y) {
        return y;
      }
      function u(y, _) {
        for (var b = 0; b < y.length; ++b) _[b] = 255 & y.charCodeAt(b);
        return _;
      }
      e("setimmediate"), r.newBlob = function(y, _) {
        r.checkSupport("blob");
        try {
          return new Blob([y], { type: _ });
        } catch {
          try {
            var b = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return b.append(y), b.getBlob(_);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(y, _, b) {
        var v = [], A = 0, L = y.length;
        if (L <= b) return String.fromCharCode.apply(null, y);
        for (; A < L; ) _ === "array" || _ === "nodebuffer" ? v.push(String.fromCharCode.apply(null, y.slice(A, Math.min(A + b, L)))) : v.push(String.fromCharCode.apply(null, y.subarray(A, Math.min(A + b, L)))), A += b;
        return v.join("");
      }, stringifyByChar: function(y) {
        for (var _ = "", b = 0; b < y.length; b++) _ += String.fromCharCode(y[b]);
        return _;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(y) {
        var _ = 65536, b = r.getTypeOf(y), v = !0;
        if (b === "uint8array" ? v = d.applyCanBeUsed.uint8array : b === "nodebuffer" && (v = d.applyCanBeUsed.nodebuffer), v) for (; 1 < _; ) try {
          return d.stringifyByChunk(y, b, _);
        } catch {
          _ = Math.floor(_ / 2);
        }
        return d.stringifyByChar(y);
      }
      function f(y, _) {
        for (var b = 0; b < y.length; b++) _[b] = y[b];
        return _;
      }
      r.applyFromCharCode = p;
      var g = {};
      g.string = { string: h, array: function(y) {
        return u(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return g.string.uint8array(y).buffer;
      }, uint8array: function(y) {
        return u(y, new Uint8Array(y.length));
      }, nodebuffer: function(y) {
        return u(y, a.allocBuffer(y.length));
      } }, g.array = { string: p, array: h, arraybuffer: function(y) {
        return new Uint8Array(y).buffer;
      }, uint8array: function(y) {
        return new Uint8Array(y);
      }, nodebuffer: function(y) {
        return a.newBufferFrom(y);
      } }, g.arraybuffer = { string: function(y) {
        return p(new Uint8Array(y));
      }, array: function(y) {
        return f(new Uint8Array(y), new Array(y.byteLength));
      }, arraybuffer: h, uint8array: function(y) {
        return new Uint8Array(y);
      }, nodebuffer: function(y) {
        return a.newBufferFrom(new Uint8Array(y));
      } }, g.uint8array = { string: p, array: function(y) {
        return f(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return y.buffer;
      }, uint8array: h, nodebuffer: function(y) {
        return a.newBufferFrom(y);
      } }, g.nodebuffer = { string: p, array: function(y) {
        return f(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return g.nodebuffer.uint8array(y).buffer;
      }, uint8array: function(y) {
        return f(y, new Uint8Array(y.length));
      }, nodebuffer: h }, r.transformTo = function(y, _) {
        if (_ = _ || "", !y) return _;
        r.checkSupport(y);
        var b = r.getTypeOf(_);
        return g[b][y](_);
      }, r.resolve = function(y) {
        for (var _ = y.split("/"), b = [], v = 0; v < _.length; v++) {
          var A = _[v];
          A === "." || A === "" && v !== 0 && v !== _.length - 1 || (A === ".." ? b.pop() : b.push(A));
        }
        return b.join("/");
      }, r.getTypeOf = function(y) {
        return typeof y == "string" ? "string" : Object.prototype.toString.call(y) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(y) ? "nodebuffer" : s.uint8array && y instanceof Uint8Array ? "uint8array" : s.arraybuffer && y instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, r.checkSupport = function(y) {
        if (!s[y.toLowerCase()]) throw new Error(y + " is not supported by this platform");
      }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(y) {
        var _, b, v = "";
        for (b = 0; b < (y || "").length; b++) v += "\\x" + ((_ = y.charCodeAt(b)) < 16 ? "0" : "") + _.toString(16).toUpperCase();
        return v;
      }, r.delay = function(y, _, b) {
        setImmediate(function() {
          y.apply(b || null, _ || []);
        });
      }, r.inherits = function(y, _) {
        function b() {
        }
        b.prototype = _.prototype, y.prototype = new b();
      }, r.extend = function() {
        var y, _, b = {};
        for (y = 0; y < arguments.length; y++) for (_ in arguments[y]) Object.prototype.hasOwnProperty.call(arguments[y], _) && b[_] === void 0 && (b[_] = arguments[y][_]);
        return b;
      }, r.prepareContent = function(y, _, b, v, A) {
        return l.Promise.resolve(_).then(function(L) {
          return s.blob && (L instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(L)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(O, R) {
            var C = new FileReader();
            C.onload = function(E) {
              O(E.target.result);
            }, C.onerror = function(E) {
              R(E.target.error);
            }, C.readAsArrayBuffer(L);
          }) : L;
        }).then(function(L) {
          var O = r.getTypeOf(L);
          return O ? (O === "arraybuffer" ? L = r.transformTo("uint8array", L) : O === "string" && (A ? L = o.decode(L) : b && v !== !0 && (L = function(R) {
            return u(R, s.uint8array ? new Uint8Array(R.length) : new Array(R.length));
          }(L))), L) : l.Promise.reject(new Error("Can't read the data of '" + y + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./signature"), l = e("./zipEntry"), h = e("./support");
      function u(d) {
        this.files = [], this.loadOptions = d;
      }
      u.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(d) + ")");
        }
      }, isSignature: function(d, p) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var g = this.reader.readString(4) === p;
        return this.reader.setIndex(f), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), p = h.uint8array ? "uint8array" : "array", f = o.transformTo(p, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, p, f, g = this.zip64EndOfCentralSize - 44; 0 < g; ) d = this.reader.readInt(2), p = this.reader.readInt(4), f = this.reader.readData(p), this.zip64ExtensibleData[d] = { id: d, length: p, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, p;
        for (d = 0; d < this.files.length; d++) p = this.files[d], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); ) (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (d < 0) throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var p = d;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var g = p - f;
        if (0 < g) this.isSignature(p, a.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0) throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = s(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, r) {
      var s = e("./reader/readerFor"), o = e("./utils"), a = e("./compressedObject"), l = e("./crc32"), h = e("./utf8"), u = e("./compressions"), d = e("./support");
      function p(f, g) {
        this.options = f, this.loadOptions = g;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var g, y;
        if (f.skip(22), this.fileNameLength = f.readInt(2), y = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(y), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(_) {
          for (var b in u) if (Object.prototype.hasOwnProperty.call(u, b) && u[b].magic === _) return u[b];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, g, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var g = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        f.skip(g), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = s(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var g, y, _, b = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < b; ) g = f.readInt(2), y = f.readInt(2), _ = f.readData(y), this.extraFields[g] = { id: g, length: y, value: _ };
        f.setIndex(b);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = h.utf8decode(this.fileName), this.fileCommentStr = h.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null) this.fileNameStr = g;
          else {
            var y = o.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(y);
          }
          var _ = this.findExtraFieldUnicodeComment();
          if (_ !== null) this.fileCommentStr = _;
          else {
            var b = o.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(b);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var g = s(f.value);
          return g.readInt(1) !== 1 || l(this.fileName) !== g.readInt(4) ? null : h.utf8decode(g.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var g = s(f.value);
          return g.readInt(1) !== 1 || l(this.fileComment) !== g.readInt(4) ? null : h.utf8decode(g.readData(f.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, r) {
      function s(g, y, _) {
        this.name = g, this.dir = _.dir, this.date = _.date, this.comment = _.comment, this.unixPermissions = _.unixPermissions, this.dosPermissions = _.dosPermissions, this._data = y, this._dataBinary = _.binary, this.options = { compression: _.compression, compressionOptions: _.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), a = e("./stream/DataWorker"), l = e("./utf8"), h = e("./compressedObject"), u = e("./stream/GenericWorker");
      s.prototype = { internalStream: function(g) {
        var y = null, _ = "string";
        try {
          if (!g) throw new Error("No output type specified.");
          var b = (_ = g.toLowerCase()) === "string" || _ === "text";
          _ !== "binarystring" && _ !== "text" || (_ = "string"), y = this._decompressWorker();
          var v = !this._dataBinary;
          v && !b && (y = y.pipe(new l.Utf8EncodeWorker())), !v && b && (y = y.pipe(new l.Utf8DecodeWorker()));
        } catch (A) {
          (y = new u("error")).error(A);
        }
        return new o(y, _, "");
      }, async: function(g, y) {
        return this.internalStream(g).accumulate(y);
      }, nodeStream: function(g, y) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(y);
      }, _compressWorker: function(g, y) {
        if (this._data instanceof h && this._data.compression.magic === g.magic) return this._data.getCompressedWorker();
        var _ = this._decompressWorker();
        return this._dataBinary || (_ = _.pipe(new l.Utf8EncodeWorker())), h.createWorkerFrom(_, g, y);
      }, _decompressWorker: function() {
        return this._data instanceof h ? this._data.getContentWorker() : this._data instanceof u ? this._data : new a(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++) s.prototype[d[f]] = p;
      i.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, r) {
      (function(s) {
        var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
        if (l) {
          var h = 0, u = new l(g), d = s.document.createTextNode("");
          u.observe(d, { characterData: !0 }), o = function() {
            d.data = h = ++h % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0) o = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
          var y = s.document.createElement("script");
          y.onreadystatechange = function() {
            g(), y.onreadystatechange = null, y.parentNode.removeChild(y), y = null;
          }, s.document.documentElement.appendChild(y);
        } : function() {
          setTimeout(g, 0);
        };
        else {
          var p = new s.MessageChannel();
          p.port1.onmessage = g, o = function() {
            p.port2.postMessage(0);
          };
        }
        var f = [];
        function g() {
          var y, _;
          a = !0;
          for (var b = f.length; b; ) {
            for (_ = f, f = [], y = -1; ++y < b; ) _[y]();
            b = f.length;
          }
          a = !1;
        }
        i.exports = function(y) {
          f.push(y) !== 1 || a || o();
        };
      }).call(this, typeof uo < "u" ? uo : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, r) {
      var s = e("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], h = ["FULFILLED"], u = ["PENDING"];
      function d(b) {
        if (typeof b != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, b !== o && y(this, b);
      }
      function p(b, v, A) {
        this.promise = b, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof A == "function" && (this.onRejected = A, this.callRejected = this.otherCallRejected);
      }
      function f(b, v, A) {
        s(function() {
          var L;
          try {
            L = v(A);
          } catch (O) {
            return a.reject(b, O);
          }
          L === b ? a.reject(b, new TypeError("Cannot resolve promise with itself")) : a.resolve(b, L);
        });
      }
      function g(b) {
        var v = b && b.then;
        if (b && (typeof b == "object" || typeof b == "function") && typeof v == "function") return function() {
          v.apply(b, arguments);
        };
      }
      function y(b, v) {
        var A = !1;
        function L(C) {
          A || (A = !0, a.reject(b, C));
        }
        function O(C) {
          A || (A = !0, a.resolve(b, C));
        }
        var R = _(function() {
          v(O, L);
        });
        R.status === "error" && L(R.value);
      }
      function _(b, v) {
        var A = {};
        try {
          A.value = b(v), A.status = "success";
        } catch (L) {
          A.status = "error", A.value = L;
        }
        return A;
      }
      (i.exports = d).prototype.finally = function(b) {
        if (typeof b != "function") return this;
        var v = this.constructor;
        return this.then(function(A) {
          return v.resolve(b()).then(function() {
            return A;
          });
        }, function(A) {
          return v.resolve(b()).then(function() {
            throw A;
          });
        });
      }, d.prototype.catch = function(b) {
        return this.then(null, b);
      }, d.prototype.then = function(b, v) {
        if (typeof b != "function" && this.state === h || typeof v != "function" && this.state === l) return this;
        var A = new this.constructor(o);
        return this.state !== u ? f(A, this.state === h ? b : v, this.outcome) : this.queue.push(new p(A, b, v)), A;
      }, p.prototype.callFulfilled = function(b) {
        a.resolve(this.promise, b);
      }, p.prototype.otherCallFulfilled = function(b) {
        f(this.promise, this.onFulfilled, b);
      }, p.prototype.callRejected = function(b) {
        a.reject(this.promise, b);
      }, p.prototype.otherCallRejected = function(b) {
        f(this.promise, this.onRejected, b);
      }, a.resolve = function(b, v) {
        var A = _(g, v);
        if (A.status === "error") return a.reject(b, A.value);
        var L = A.value;
        if (L) y(b, L);
        else {
          b.state = h, b.outcome = v;
          for (var O = -1, R = b.queue.length; ++O < R; ) b.queue[O].callFulfilled(v);
        }
        return b;
      }, a.reject = function(b, v) {
        b.state = l, b.outcome = v;
        for (var A = -1, L = b.queue.length; ++A < L; ) b.queue[A].callRejected(v);
        return b;
      }, d.resolve = function(b) {
        return b instanceof this ? b : a.resolve(new this(o), b);
      }, d.reject = function(b) {
        var v = new this(o);
        return a.reject(v, b);
      }, d.all = function(b) {
        var v = this;
        if (Object.prototype.toString.call(b) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var A = b.length, L = !1;
        if (!A) return this.resolve([]);
        for (var O = new Array(A), R = 0, C = -1, E = new this(o); ++C < A; ) M(b[C], C);
        return E;
        function M(q, N) {
          v.resolve(q).then(function(S) {
            O[N] = S, ++R !== A || L || (L = !0, a.resolve(E, O));
          }, function(S) {
            L || (L = !0, a.reject(E, S));
          });
        }
      }, d.race = function(b) {
        var v = this;
        if (Object.prototype.toString.call(b) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var A = b.length, L = !1;
        if (!A) return this.resolve([]);
        for (var O = -1, R = new this(o); ++O < A; ) C = b[O], v.resolve(C).then(function(E) {
          L || (L = !0, a.resolve(R, E));
        }, function(E) {
          L || (L = !0, a.reject(R, E));
        });
        var C;
        return R;
      };
    }, { immediate: 36 }], 38: [function(e, i, r) {
      var s = {};
      (0, e("./lib/utils/common").assign)(s, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, r) {
      var s = e("./zlib/deflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/messages"), h = e("./zlib/zstream"), u = Object.prototype.toString, d = 0, p = -1, f = 0, g = 8;
      function y(b) {
        if (!(this instanceof y)) return new y(b);
        this.options = o.assign({ level: p, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, b || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var A = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (A !== d) throw new Error(l[A]);
        if (v.header && s.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var L;
          if (L = typeof v.dictionary == "string" ? a.string2buf(v.dictionary) : u.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (A = s.deflateSetDictionary(this.strm, L)) !== d) throw new Error(l[A]);
          this._dict_set = !0;
        }
      }
      function _(b, v) {
        var A = new y(v);
        if (A.push(b, !0), A.err) throw A.msg || l[A.err];
        return A.result;
      }
      y.prototype.push = function(b, v) {
        var A, L, O = this.strm, R = this.options.chunkSize;
        if (this.ended) return !1;
        L = v === ~~v ? v : v === !0 ? 4 : 0, typeof b == "string" ? O.input = a.string2buf(b) : u.call(b) === "[object ArrayBuffer]" ? O.input = new Uint8Array(b) : O.input = b, O.next_in = 0, O.avail_in = O.input.length;
        do {
          if (O.avail_out === 0 && (O.output = new o.Buf8(R), O.next_out = 0, O.avail_out = R), (A = s.deflate(O, L)) !== 1 && A !== d) return this.onEnd(A), !(this.ended = !0);
          O.avail_out !== 0 && (O.avail_in !== 0 || L !== 4 && L !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(O.output, O.next_out))) : this.onData(o.shrinkBuf(O.output, O.next_out)));
        } while ((0 < O.avail_in || O.avail_out === 0) && A !== 1);
        return L === 4 ? (A = s.deflateEnd(this.strm), this.onEnd(A), this.ended = !0, A === d) : L !== 2 || (this.onEnd(d), !(O.avail_out = 0));
      }, y.prototype.onData = function(b) {
        this.chunks.push(b);
      }, y.prototype.onEnd = function(b) {
        b === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, r.Deflate = y, r.deflate = _, r.deflateRaw = function(b, v) {
        return (v = v || {}).raw = !0, _(b, v);
      }, r.gzip = function(b, v) {
        return (v = v || {}).gzip = !0, _(b, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, r) {
      var s = e("./zlib/inflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/constants"), h = e("./zlib/messages"), u = e("./zlib/zstream"), d = e("./zlib/gzheader"), p = Object.prototype.toString;
      function f(y) {
        if (!(this instanceof f)) return new f(y);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, y || {});
        var _ = this.options;
        _.raw && 0 <= _.windowBits && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), !(0 <= _.windowBits && _.windowBits < 16) || y && y.windowBits || (_.windowBits += 32), 15 < _.windowBits && _.windowBits < 48 && !(15 & _.windowBits) && (_.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var b = s.inflateInit2(this.strm, _.windowBits);
        if (b !== l.Z_OK) throw new Error(h[b]);
        this.header = new d(), s.inflateGetHeader(this.strm, this.header);
      }
      function g(y, _) {
        var b = new f(_);
        if (b.push(y, !0), b.err) throw b.msg || h[b.err];
        return b.result;
      }
      f.prototype.push = function(y, _) {
        var b, v, A, L, O, R, C = this.strm, E = this.options.chunkSize, M = this.options.dictionary, q = !1;
        if (this.ended) return !1;
        v = _ === ~~_ ? _ : _ === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof y == "string" ? C.input = a.binstring2buf(y) : p.call(y) === "[object ArrayBuffer]" ? C.input = new Uint8Array(y) : C.input = y, C.next_in = 0, C.avail_in = C.input.length;
        do {
          if (C.avail_out === 0 && (C.output = new o.Buf8(E), C.next_out = 0, C.avail_out = E), (b = s.inflate(C, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && M && (R = typeof M == "string" ? a.string2buf(M) : p.call(M) === "[object ArrayBuffer]" ? new Uint8Array(M) : M, b = s.inflateSetDictionary(this.strm, R)), b === l.Z_BUF_ERROR && q === !0 && (b = l.Z_OK, q = !1), b !== l.Z_STREAM_END && b !== l.Z_OK) return this.onEnd(b), !(this.ended = !0);
          C.next_out && (C.avail_out !== 0 && b !== l.Z_STREAM_END && (C.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (A = a.utf8border(C.output, C.next_out), L = C.next_out - A, O = a.buf2string(C.output, A), C.next_out = L, C.avail_out = E - L, L && o.arraySet(C.output, C.output, A, L, 0), this.onData(O)) : this.onData(o.shrinkBuf(C.output, C.next_out)))), C.avail_in === 0 && C.avail_out === 0 && (q = !0);
        } while ((0 < C.avail_in || C.avail_out === 0) && b !== l.Z_STREAM_END);
        return b === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (b = s.inflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(C.avail_out = 0));
      }, f.prototype.onData = function(y) {
        this.chunks.push(y);
      }, f.prototype.onEnd = function(y) {
        y === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, r.Inflate = f, r.inflate = g, r.inflateRaw = function(y, _) {
        return (_ = _ || {}).raw = !0, g(y, _);
      }, r.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      r.assign = function(l) {
        for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
          var u = h.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var d in u) u.hasOwnProperty(d) && (l[d] = u[d]);
          }
        }
        return l;
      }, r.shrinkBuf = function(l, h) {
        return l.length === h ? l : l.subarray ? l.subarray(0, h) : (l.length = h, l);
      };
      var o = { arraySet: function(l, h, u, d, p) {
        if (h.subarray && l.subarray) l.set(h.subarray(u, u + d), p);
        else for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        var h, u, d, p, f, g;
        for (h = d = 0, u = l.length; h < u; h++) d += l[h].length;
        for (g = new Uint8Array(d), h = p = 0, u = l.length; h < u; h++) f = l[h], g.set(f, p), p += f.length;
        return g;
      } }, a = { arraySet: function(l, h, u, d, p) {
        for (var f = 0; f < d; f++) l[p + f] = h[u + f];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      r.setTyped = function(l) {
        l ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, a));
      }, r.setTyped(s);
    }, {}], 42: [function(e, i, r) {
      var s = e("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), h = 0; h < 256; h++) l[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      function u(d, p) {
        if (p < 65537 && (d.subarray && a || !d.subarray && o)) return String.fromCharCode.apply(null, s.shrinkBuf(d, p));
        for (var f = "", g = 0; g < p; g++) f += String.fromCharCode(d[g]);
        return f;
      }
      l[254] = l[254] = 1, r.string2buf = function(d) {
        var p, f, g, y, _, b = d.length, v = 0;
        for (y = 0; y < b; y++) (64512 & (f = d.charCodeAt(y))) == 55296 && y + 1 < b && (64512 & (g = d.charCodeAt(y + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), y++), v += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (p = new s.Buf8(v), y = _ = 0; _ < v; y++) (64512 & (f = d.charCodeAt(y))) == 55296 && y + 1 < b && (64512 & (g = d.charCodeAt(y + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (g - 56320), y++), f < 128 ? p[_++] = f : (f < 2048 ? p[_++] = 192 | f >>> 6 : (f < 65536 ? p[_++] = 224 | f >>> 12 : (p[_++] = 240 | f >>> 18, p[_++] = 128 | f >>> 12 & 63), p[_++] = 128 | f >>> 6 & 63), p[_++] = 128 | 63 & f);
        return p;
      }, r.buf2binstring = function(d) {
        return u(d, d.length);
      }, r.binstring2buf = function(d) {
        for (var p = new s.Buf8(d.length), f = 0, g = p.length; f < g; f++) p[f] = d.charCodeAt(f);
        return p;
      }, r.buf2string = function(d, p) {
        var f, g, y, _, b = p || d.length, v = new Array(2 * b);
        for (f = g = 0; f < b; ) if ((y = d[f++]) < 128) v[g++] = y;
        else if (4 < (_ = l[y])) v[g++] = 65533, f += _ - 1;
        else {
          for (y &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && f < b; ) y = y << 6 | 63 & d[f++], _--;
          1 < _ ? v[g++] = 65533 : y < 65536 ? v[g++] = y : (y -= 65536, v[g++] = 55296 | y >> 10 & 1023, v[g++] = 56320 | 1023 & y);
        }
        return u(v, g);
      }, r.utf8border = function(d, p) {
        var f;
        for ((p = p || d.length) > d.length && (p = d.length), f = p - 1; 0 <= f && (192 & d[f]) == 128; ) f--;
        return f < 0 || f === 0 ? p : f + l[d[f]] > p ? f : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, r) {
      i.exports = function(s, o, a, l) {
        for (var h = 65535 & s | 0, u = s >>> 16 & 65535 | 0, d = 0; a !== 0; ) {
          for (a -= d = 2e3 < a ? 2e3 : a; u = u + (h = h + o[l++] | 0) | 0, --d; ) ;
          h %= 65521, u %= 65521;
        }
        return h | u << 16 | 0;
      };
    }, {}], 44: [function(e, i, r) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, r) {
      var s = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var h = 0; h < 8; h++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, h) {
        var u = s, d = h + l;
        o ^= -1;
        for (var p = h; p < d; p++) o = o >>> 8 ^ u[255 & (o ^ a[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, r) {
      var s, o = e("../utils/common"), a = e("./trees"), l = e("./adler32"), h = e("./crc32"), u = e("./messages"), d = 0, p = 4, f = 0, g = -2, y = -1, _ = 4, b = 2, v = 8, A = 9, L = 286, O = 30, R = 19, C = 2 * L + 1, E = 15, M = 3, q = 258, N = q + M + 1, S = 42, T = 113, x = 1, X = 2, V = 3, D = 4;
      function tt(F, ht) {
        return F.msg = u[ht], ht;
      }
      function H(F) {
        return (F << 1) - (4 < F ? 9 : 0);
      }
      function ct(F) {
        for (var ht = F.length; 0 <= --ht; ) F[ht] = 0;
      }
      function it(F) {
        var ht = F.state, $ = ht.pending;
        $ > F.avail_out && ($ = F.avail_out), $ !== 0 && (o.arraySet(F.output, ht.pending_buf, ht.pending_out, $, F.next_out), F.next_out += $, ht.pending_out += $, F.total_out += $, F.avail_out -= $, ht.pending -= $, ht.pending === 0 && (ht.pending_out = 0));
      }
      function P(F, ht) {
        a._tr_flush_block(F, 0 <= F.block_start ? F.block_start : -1, F.strstart - F.block_start, ht), F.block_start = F.strstart, it(F.strm);
      }
      function z(F, ht) {
        F.pending_buf[F.pending++] = ht;
      }
      function G(F, ht) {
        F.pending_buf[F.pending++] = ht >>> 8 & 255, F.pending_buf[F.pending++] = 255 & ht;
      }
      function Y(F, ht) {
        var $, nt, J = F.max_chain_length, st = F.strstart, vt = F.prev_length, St = F.nice_match, ft = F.strstart > F.w_size - N ? F.strstart - (F.w_size - N) : 0, Et = F.window, zt = F.w_mask, Tt = F.prev, $t = F.strstart + q, ee = Et[st + vt - 1], oe = Et[st + vt];
        F.prev_length >= F.good_match && (J >>= 2), St > F.lookahead && (St = F.lookahead);
        do
          if (Et[($ = ht) + vt] === oe && Et[$ + vt - 1] === ee && Et[$] === Et[st] && Et[++$] === Et[st + 1]) {
            st += 2, $++;
            do
              ;
            while (Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && Et[++st] === Et[++$] && st < $t);
            if (nt = q - ($t - st), st = $t - q, vt < nt) {
              if (F.match_start = ht, St <= (vt = nt)) break;
              ee = Et[st + vt - 1], oe = Et[st + vt];
            }
          }
        while ((ht = Tt[ht & zt]) > ft && --J != 0);
        return vt <= F.lookahead ? vt : F.lookahead;
      }
      function ot(F) {
        var ht, $, nt, J, st, vt, St, ft, Et, zt, Tt = F.w_size;
        do {
          if (J = F.window_size - F.lookahead - F.strstart, F.strstart >= Tt + (Tt - N)) {
            for (o.arraySet(F.window, F.window, Tt, Tt, 0), F.match_start -= Tt, F.strstart -= Tt, F.block_start -= Tt, ht = $ = F.hash_size; nt = F.head[--ht], F.head[ht] = Tt <= nt ? nt - Tt : 0, --$; ) ;
            for (ht = $ = Tt; nt = F.prev[--ht], F.prev[ht] = Tt <= nt ? nt - Tt : 0, --$; ) ;
            J += Tt;
          }
          if (F.strm.avail_in === 0) break;
          if (vt = F.strm, St = F.window, ft = F.strstart + F.lookahead, Et = J, zt = void 0, zt = vt.avail_in, Et < zt && (zt = Et), $ = zt === 0 ? 0 : (vt.avail_in -= zt, o.arraySet(St, vt.input, vt.next_in, zt, ft), vt.state.wrap === 1 ? vt.adler = l(vt.adler, St, zt, ft) : vt.state.wrap === 2 && (vt.adler = h(vt.adler, St, zt, ft)), vt.next_in += zt, vt.total_in += zt, zt), F.lookahead += $, F.lookahead + F.insert >= M) for (st = F.strstart - F.insert, F.ins_h = F.window[st], F.ins_h = (F.ins_h << F.hash_shift ^ F.window[st + 1]) & F.hash_mask; F.insert && (F.ins_h = (F.ins_h << F.hash_shift ^ F.window[st + M - 1]) & F.hash_mask, F.prev[st & F.w_mask] = F.head[F.ins_h], F.head[F.ins_h] = st, st++, F.insert--, !(F.lookahead + F.insert < M)); ) ;
        } while (F.lookahead < N && F.strm.avail_in !== 0);
      }
      function xt(F, ht) {
        for (var $, nt; ; ) {
          if (F.lookahead < N) {
            if (ot(F), F.lookahead < N && ht === d) return x;
            if (F.lookahead === 0) break;
          }
          if ($ = 0, F.lookahead >= M && (F.ins_h = (F.ins_h << F.hash_shift ^ F.window[F.strstart + M - 1]) & F.hash_mask, $ = F.prev[F.strstart & F.w_mask] = F.head[F.ins_h], F.head[F.ins_h] = F.strstart), $ !== 0 && F.strstart - $ <= F.w_size - N && (F.match_length = Y(F, $)), F.match_length >= M) if (nt = a._tr_tally(F, F.strstart - F.match_start, F.match_length - M), F.lookahead -= F.match_length, F.match_length <= F.max_lazy_match && F.lookahead >= M) {
            for (F.match_length--; F.strstart++, F.ins_h = (F.ins_h << F.hash_shift ^ F.window[F.strstart + M - 1]) & F.hash_mask, $ = F.prev[F.strstart & F.w_mask] = F.head[F.ins_h], F.head[F.ins_h] = F.strstart, --F.match_length != 0; ) ;
            F.strstart++;
          } else F.strstart += F.match_length, F.match_length = 0, F.ins_h = F.window[F.strstart], F.ins_h = (F.ins_h << F.hash_shift ^ F.window[F.strstart + 1]) & F.hash_mask;
          else nt = a._tr_tally(F, 0, F.window[F.strstart]), F.lookahead--, F.strstart++;
          if (nt && (P(F, !1), F.strm.avail_out === 0)) return x;
        }
        return F.insert = F.strstart < M - 1 ? F.strstart : M - 1, ht === p ? (P(F, !0), F.strm.avail_out === 0 ? V : D) : F.last_lit && (P(F, !1), F.strm.avail_out === 0) ? x : X;
      }
      function gt(F, ht) {
        for (var $, nt, J; ; ) {
          if (F.lookahead < N) {
            if (ot(F), F.lookahead < N && ht === d) return x;
            if (F.lookahead === 0) break;
          }
          if ($ = 0, F.lookahead >= M && (F.ins_h = (F.ins_h << F.hash_shift ^ F.window[F.strstart + M - 1]) & F.hash_mask, $ = F.prev[F.strstart & F.w_mask] = F.head[F.ins_h], F.head[F.ins_h] = F.strstart), F.prev_length = F.match_length, F.prev_match = F.match_start, F.match_length = M - 1, $ !== 0 && F.prev_length < F.max_lazy_match && F.strstart - $ <= F.w_size - N && (F.match_length = Y(F, $), F.match_length <= 5 && (F.strategy === 1 || F.match_length === M && 4096 < F.strstart - F.match_start) && (F.match_length = M - 1)), F.prev_length >= M && F.match_length <= F.prev_length) {
            for (J = F.strstart + F.lookahead - M, nt = a._tr_tally(F, F.strstart - 1 - F.prev_match, F.prev_length - M), F.lookahead -= F.prev_length - 1, F.prev_length -= 2; ++F.strstart <= J && (F.ins_h = (F.ins_h << F.hash_shift ^ F.window[F.strstart + M - 1]) & F.hash_mask, $ = F.prev[F.strstart & F.w_mask] = F.head[F.ins_h], F.head[F.ins_h] = F.strstart), --F.prev_length != 0; ) ;
            if (F.match_available = 0, F.match_length = M - 1, F.strstart++, nt && (P(F, !1), F.strm.avail_out === 0)) return x;
          } else if (F.match_available) {
            if ((nt = a._tr_tally(F, 0, F.window[F.strstart - 1])) && P(F, !1), F.strstart++, F.lookahead--, F.strm.avail_out === 0) return x;
          } else F.match_available = 1, F.strstart++, F.lookahead--;
        }
        return F.match_available && (nt = a._tr_tally(F, 0, F.window[F.strstart - 1]), F.match_available = 0), F.insert = F.strstart < M - 1 ? F.strstart : M - 1, ht === p ? (P(F, !0), F.strm.avail_out === 0 ? V : D) : F.last_lit && (P(F, !1), F.strm.avail_out === 0) ? x : X;
      }
      function wt(F, ht, $, nt, J) {
        this.good_length = F, this.max_lazy = ht, this.nice_length = $, this.max_chain = nt, this.func = J;
      }
      function qt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * C), this.dyn_dtree = new o.Buf16(2 * (2 * O + 1)), this.bl_tree = new o.Buf16(2 * (2 * R + 1)), ct(this.dyn_ltree), ct(this.dyn_dtree), ct(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(E + 1), this.heap = new o.Buf16(2 * L + 1), ct(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * L + 1), ct(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Dt(F) {
        var ht;
        return F && F.state ? (F.total_in = F.total_out = 0, F.data_type = b, (ht = F.state).pending = 0, ht.pending_out = 0, ht.wrap < 0 && (ht.wrap = -ht.wrap), ht.status = ht.wrap ? S : T, F.adler = ht.wrap === 2 ? 0 : 1, ht.last_flush = d, a._tr_init(ht), f) : tt(F, g);
      }
      function Yt(F) {
        var ht = Dt(F);
        return ht === f && function($) {
          $.window_size = 2 * $.w_size, ct($.head), $.max_lazy_match = s[$.level].max_lazy, $.good_match = s[$.level].good_length, $.nice_match = s[$.level].nice_length, $.max_chain_length = s[$.level].max_chain, $.strstart = 0, $.block_start = 0, $.lookahead = 0, $.insert = 0, $.match_length = $.prev_length = M - 1, $.match_available = 0, $.ins_h = 0;
        }(F.state), ht;
      }
      function Xt(F, ht, $, nt, J, st) {
        if (!F) return g;
        var vt = 1;
        if (ht === y && (ht = 6), nt < 0 ? (vt = 0, nt = -nt) : 15 < nt && (vt = 2, nt -= 16), J < 1 || A < J || $ !== v || nt < 8 || 15 < nt || ht < 0 || 9 < ht || st < 0 || _ < st) return tt(F, g);
        nt === 8 && (nt = 9);
        var St = new qt();
        return (F.state = St).strm = F, St.wrap = vt, St.gzhead = null, St.w_bits = nt, St.w_size = 1 << St.w_bits, St.w_mask = St.w_size - 1, St.hash_bits = J + 7, St.hash_size = 1 << St.hash_bits, St.hash_mask = St.hash_size - 1, St.hash_shift = ~~((St.hash_bits + M - 1) / M), St.window = new o.Buf8(2 * St.w_size), St.head = new o.Buf16(St.hash_size), St.prev = new o.Buf16(St.w_size), St.lit_bufsize = 1 << J + 6, St.pending_buf_size = 4 * St.lit_bufsize, St.pending_buf = new o.Buf8(St.pending_buf_size), St.d_buf = 1 * St.lit_bufsize, St.l_buf = 3 * St.lit_bufsize, St.level = ht, St.strategy = st, St.method = $, Yt(F);
      }
      s = [new wt(0, 0, 0, 0, function(F, ht) {
        var $ = 65535;
        for ($ > F.pending_buf_size - 5 && ($ = F.pending_buf_size - 5); ; ) {
          if (F.lookahead <= 1) {
            if (ot(F), F.lookahead === 0 && ht === d) return x;
            if (F.lookahead === 0) break;
          }
          F.strstart += F.lookahead, F.lookahead = 0;
          var nt = F.block_start + $;
          if ((F.strstart === 0 || F.strstart >= nt) && (F.lookahead = F.strstart - nt, F.strstart = nt, P(F, !1), F.strm.avail_out === 0) || F.strstart - F.block_start >= F.w_size - N && (P(F, !1), F.strm.avail_out === 0)) return x;
        }
        return F.insert = 0, ht === p ? (P(F, !0), F.strm.avail_out === 0 ? V : D) : (F.strstart > F.block_start && (P(F, !1), F.strm.avail_out), x);
      }), new wt(4, 4, 8, 4, xt), new wt(4, 5, 16, 8, xt), new wt(4, 6, 32, 32, xt), new wt(4, 4, 16, 16, gt), new wt(8, 16, 32, 32, gt), new wt(8, 16, 128, 128, gt), new wt(8, 32, 128, 256, gt), new wt(32, 128, 258, 1024, gt), new wt(32, 258, 258, 4096, gt)], r.deflateInit = function(F, ht) {
        return Xt(F, ht, v, 15, 8, 0);
      }, r.deflateInit2 = Xt, r.deflateReset = Yt, r.deflateResetKeep = Dt, r.deflateSetHeader = function(F, ht) {
        return F && F.state ? F.state.wrap !== 2 ? g : (F.state.gzhead = ht, f) : g;
      }, r.deflate = function(F, ht) {
        var $, nt, J, st;
        if (!F || !F.state || 5 < ht || ht < 0) return F ? tt(F, g) : g;
        if (nt = F.state, !F.output || !F.input && F.avail_in !== 0 || nt.status === 666 && ht !== p) return tt(F, F.avail_out === 0 ? -5 : g);
        if (nt.strm = F, $ = nt.last_flush, nt.last_flush = ht, nt.status === S) if (nt.wrap === 2) F.adler = 0, z(nt, 31), z(nt, 139), z(nt, 8), nt.gzhead ? (z(nt, (nt.gzhead.text ? 1 : 0) + (nt.gzhead.hcrc ? 2 : 0) + (nt.gzhead.extra ? 4 : 0) + (nt.gzhead.name ? 8 : 0) + (nt.gzhead.comment ? 16 : 0)), z(nt, 255 & nt.gzhead.time), z(nt, nt.gzhead.time >> 8 & 255), z(nt, nt.gzhead.time >> 16 & 255), z(nt, nt.gzhead.time >> 24 & 255), z(nt, nt.level === 9 ? 2 : 2 <= nt.strategy || nt.level < 2 ? 4 : 0), z(nt, 255 & nt.gzhead.os), nt.gzhead.extra && nt.gzhead.extra.length && (z(nt, 255 & nt.gzhead.extra.length), z(nt, nt.gzhead.extra.length >> 8 & 255)), nt.gzhead.hcrc && (F.adler = h(F.adler, nt.pending_buf, nt.pending, 0)), nt.gzindex = 0, nt.status = 69) : (z(nt, 0), z(nt, 0), z(nt, 0), z(nt, 0), z(nt, 0), z(nt, nt.level === 9 ? 2 : 2 <= nt.strategy || nt.level < 2 ? 4 : 0), z(nt, 3), nt.status = T);
        else {
          var vt = v + (nt.w_bits - 8 << 4) << 8;
          vt |= (2 <= nt.strategy || nt.level < 2 ? 0 : nt.level < 6 ? 1 : nt.level === 6 ? 2 : 3) << 6, nt.strstart !== 0 && (vt |= 32), vt += 31 - vt % 31, nt.status = T, G(nt, vt), nt.strstart !== 0 && (G(nt, F.adler >>> 16), G(nt, 65535 & F.adler)), F.adler = 1;
        }
        if (nt.status === 69) if (nt.gzhead.extra) {
          for (J = nt.pending; nt.gzindex < (65535 & nt.gzhead.extra.length) && (nt.pending !== nt.pending_buf_size || (nt.gzhead.hcrc && nt.pending > J && (F.adler = h(F.adler, nt.pending_buf, nt.pending - J, J)), it(F), J = nt.pending, nt.pending !== nt.pending_buf_size)); ) z(nt, 255 & nt.gzhead.extra[nt.gzindex]), nt.gzindex++;
          nt.gzhead.hcrc && nt.pending > J && (F.adler = h(F.adler, nt.pending_buf, nt.pending - J, J)), nt.gzindex === nt.gzhead.extra.length && (nt.gzindex = 0, nt.status = 73);
        } else nt.status = 73;
        if (nt.status === 73) if (nt.gzhead.name) {
          J = nt.pending;
          do {
            if (nt.pending === nt.pending_buf_size && (nt.gzhead.hcrc && nt.pending > J && (F.adler = h(F.adler, nt.pending_buf, nt.pending - J, J)), it(F), J = nt.pending, nt.pending === nt.pending_buf_size)) {
              st = 1;
              break;
            }
            st = nt.gzindex < nt.gzhead.name.length ? 255 & nt.gzhead.name.charCodeAt(nt.gzindex++) : 0, z(nt, st);
          } while (st !== 0);
          nt.gzhead.hcrc && nt.pending > J && (F.adler = h(F.adler, nt.pending_buf, nt.pending - J, J)), st === 0 && (nt.gzindex = 0, nt.status = 91);
        } else nt.status = 91;
        if (nt.status === 91) if (nt.gzhead.comment) {
          J = nt.pending;
          do {
            if (nt.pending === nt.pending_buf_size && (nt.gzhead.hcrc && nt.pending > J && (F.adler = h(F.adler, nt.pending_buf, nt.pending - J, J)), it(F), J = nt.pending, nt.pending === nt.pending_buf_size)) {
              st = 1;
              break;
            }
            st = nt.gzindex < nt.gzhead.comment.length ? 255 & nt.gzhead.comment.charCodeAt(nt.gzindex++) : 0, z(nt, st);
          } while (st !== 0);
          nt.gzhead.hcrc && nt.pending > J && (F.adler = h(F.adler, nt.pending_buf, nt.pending - J, J)), st === 0 && (nt.status = 103);
        } else nt.status = 103;
        if (nt.status === 103 && (nt.gzhead.hcrc ? (nt.pending + 2 > nt.pending_buf_size && it(F), nt.pending + 2 <= nt.pending_buf_size && (z(nt, 255 & F.adler), z(nt, F.adler >> 8 & 255), F.adler = 0, nt.status = T)) : nt.status = T), nt.pending !== 0) {
          if (it(F), F.avail_out === 0) return nt.last_flush = -1, f;
        } else if (F.avail_in === 0 && H(ht) <= H($) && ht !== p) return tt(F, -5);
        if (nt.status === 666 && F.avail_in !== 0) return tt(F, -5);
        if (F.avail_in !== 0 || nt.lookahead !== 0 || ht !== d && nt.status !== 666) {
          var St = nt.strategy === 2 ? function(ft, Et) {
            for (var zt; ; ) {
              if (ft.lookahead === 0 && (ot(ft), ft.lookahead === 0)) {
                if (Et === d) return x;
                break;
              }
              if (ft.match_length = 0, zt = a._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++, zt && (P(ft, !1), ft.strm.avail_out === 0)) return x;
            }
            return ft.insert = 0, Et === p ? (P(ft, !0), ft.strm.avail_out === 0 ? V : D) : ft.last_lit && (P(ft, !1), ft.strm.avail_out === 0) ? x : X;
          }(nt, ht) : nt.strategy === 3 ? function(ft, Et) {
            for (var zt, Tt, $t, ee, oe = ft.window; ; ) {
              if (ft.lookahead <= q) {
                if (ot(ft), ft.lookahead <= q && Et === d) return x;
                if (ft.lookahead === 0) break;
              }
              if (ft.match_length = 0, ft.lookahead >= M && 0 < ft.strstart && (Tt = oe[$t = ft.strstart - 1]) === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t]) {
                ee = ft.strstart + q;
                do
                  ;
                while (Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && Tt === oe[++$t] && $t < ee);
                ft.match_length = q - (ee - $t), ft.match_length > ft.lookahead && (ft.match_length = ft.lookahead);
              }
              if (ft.match_length >= M ? (zt = a._tr_tally(ft, 1, ft.match_length - M), ft.lookahead -= ft.match_length, ft.strstart += ft.match_length, ft.match_length = 0) : (zt = a._tr_tally(ft, 0, ft.window[ft.strstart]), ft.lookahead--, ft.strstart++), zt && (P(ft, !1), ft.strm.avail_out === 0)) return x;
            }
            return ft.insert = 0, Et === p ? (P(ft, !0), ft.strm.avail_out === 0 ? V : D) : ft.last_lit && (P(ft, !1), ft.strm.avail_out === 0) ? x : X;
          }(nt, ht) : s[nt.level].func(nt, ht);
          if (St !== V && St !== D || (nt.status = 666), St === x || St === V) return F.avail_out === 0 && (nt.last_flush = -1), f;
          if (St === X && (ht === 1 ? a._tr_align(nt) : ht !== 5 && (a._tr_stored_block(nt, 0, 0, !1), ht === 3 && (ct(nt.head), nt.lookahead === 0 && (nt.strstart = 0, nt.block_start = 0, nt.insert = 0))), it(F), F.avail_out === 0)) return nt.last_flush = -1, f;
        }
        return ht !== p ? f : nt.wrap <= 0 ? 1 : (nt.wrap === 2 ? (z(nt, 255 & F.adler), z(nt, F.adler >> 8 & 255), z(nt, F.adler >> 16 & 255), z(nt, F.adler >> 24 & 255), z(nt, 255 & F.total_in), z(nt, F.total_in >> 8 & 255), z(nt, F.total_in >> 16 & 255), z(nt, F.total_in >> 24 & 255)) : (G(nt, F.adler >>> 16), G(nt, 65535 & F.adler)), it(F), 0 < nt.wrap && (nt.wrap = -nt.wrap), nt.pending !== 0 ? f : 1);
      }, r.deflateEnd = function(F) {
        var ht;
        return F && F.state ? (ht = F.state.status) !== S && ht !== 69 && ht !== 73 && ht !== 91 && ht !== 103 && ht !== T && ht !== 666 ? tt(F, g) : (F.state = null, ht === T ? tt(F, -3) : f) : g;
      }, r.deflateSetDictionary = function(F, ht) {
        var $, nt, J, st, vt, St, ft, Et, zt = ht.length;
        if (!F || !F.state || (st = ($ = F.state).wrap) === 2 || st === 1 && $.status !== S || $.lookahead) return g;
        for (st === 1 && (F.adler = l(F.adler, ht, zt, 0)), $.wrap = 0, zt >= $.w_size && (st === 0 && (ct($.head), $.strstart = 0, $.block_start = 0, $.insert = 0), Et = new o.Buf8($.w_size), o.arraySet(Et, ht, zt - $.w_size, $.w_size, 0), ht = Et, zt = $.w_size), vt = F.avail_in, St = F.next_in, ft = F.input, F.avail_in = zt, F.next_in = 0, F.input = ht, ot($); $.lookahead >= M; ) {
          for (nt = $.strstart, J = $.lookahead - (M - 1); $.ins_h = ($.ins_h << $.hash_shift ^ $.window[nt + M - 1]) & $.hash_mask, $.prev[nt & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = nt, nt++, --J; ) ;
          $.strstart = nt, $.lookahead = M - 1, ot($);
        }
        return $.strstart += $.lookahead, $.block_start = $.strstart, $.insert = $.lookahead, $.lookahead = 0, $.match_length = $.prev_length = M - 1, $.match_available = 0, F.next_in = St, F.input = ft, F.avail_in = vt, $.wrap = st, f;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, r) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, r) {
      i.exports = function(s, o) {
        var a, l, h, u, d, p, f, g, y, _, b, v, A, L, O, R, C, E, M, q, N, S, T, x, X;
        a = s.state, l = s.next_in, x = s.input, h = l + (s.avail_in - 5), u = s.next_out, X = s.output, d = u - (o - s.avail_out), p = u + (s.avail_out - 257), f = a.dmax, g = a.wsize, y = a.whave, _ = a.wnext, b = a.window, v = a.hold, A = a.bits, L = a.lencode, O = a.distcode, R = (1 << a.lenbits) - 1, C = (1 << a.distbits) - 1;
        t: do {
          A < 15 && (v += x[l++] << A, A += 8, v += x[l++] << A, A += 8), E = L[v & R];
          e: for (; ; ) {
            if (v >>>= M = E >>> 24, A -= M, (M = E >>> 16 & 255) === 0) X[u++] = 65535 & E;
            else {
              if (!(16 & M)) {
                if (!(64 & M)) {
                  E = L[(65535 & E) + (v & (1 << M) - 1)];
                  continue e;
                }
                if (32 & M) {
                  a.mode = 12;
                  break t;
                }
                s.msg = "invalid literal/length code", a.mode = 30;
                break t;
              }
              q = 65535 & E, (M &= 15) && (A < M && (v += x[l++] << A, A += 8), q += v & (1 << M) - 1, v >>>= M, A -= M), A < 15 && (v += x[l++] << A, A += 8, v += x[l++] << A, A += 8), E = O[v & C];
              n: for (; ; ) {
                if (v >>>= M = E >>> 24, A -= M, !(16 & (M = E >>> 16 & 255))) {
                  if (!(64 & M)) {
                    E = O[(65535 & E) + (v & (1 << M) - 1)];
                    continue n;
                  }
                  s.msg = "invalid distance code", a.mode = 30;
                  break t;
                }
                if (N = 65535 & E, A < (M &= 15) && (v += x[l++] << A, (A += 8) < M && (v += x[l++] << A, A += 8)), f < (N += v & (1 << M) - 1)) {
                  s.msg = "invalid distance too far back", a.mode = 30;
                  break t;
                }
                if (v >>>= M, A -= M, (M = u - d) < N) {
                  if (y < (M = N - M) && a.sane) {
                    s.msg = "invalid distance too far back", a.mode = 30;
                    break t;
                  }
                  if (T = b, (S = 0) === _) {
                    if (S += g - M, M < q) {
                      for (q -= M; X[u++] = b[S++], --M; ) ;
                      S = u - N, T = X;
                    }
                  } else if (_ < M) {
                    if (S += g + _ - M, (M -= _) < q) {
                      for (q -= M; X[u++] = b[S++], --M; ) ;
                      if (S = 0, _ < q) {
                        for (q -= M = _; X[u++] = b[S++], --M; ) ;
                        S = u - N, T = X;
                      }
                    }
                  } else if (S += _ - M, M < q) {
                    for (q -= M; X[u++] = b[S++], --M; ) ;
                    S = u - N, T = X;
                  }
                  for (; 2 < q; ) X[u++] = T[S++], X[u++] = T[S++], X[u++] = T[S++], q -= 3;
                  q && (X[u++] = T[S++], 1 < q && (X[u++] = T[S++]));
                } else {
                  for (S = u - N; X[u++] = X[S++], X[u++] = X[S++], X[u++] = X[S++], 2 < (q -= 3); ) ;
                  q && (X[u++] = X[S++], 1 < q && (X[u++] = X[S++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < h && u < p);
        l -= q = A >> 3, v &= (1 << (A -= q << 3)) - 1, s.next_in = l, s.next_out = u, s.avail_in = l < h ? h - l + 5 : 5 - (l - h), s.avail_out = u < p ? p - u + 257 : 257 - (u - p), a.hold = v, a.bits = A;
      };
    }, {}], 49: [function(e, i, r) {
      var s = e("../utils/common"), o = e("./adler32"), a = e("./crc32"), l = e("./inffast"), h = e("./inftrees"), u = 1, d = 2, p = 0, f = -2, g = 1, y = 852, _ = 592;
      function b(S) {
        return (S >>> 24 & 255) + (S >>> 8 & 65280) + ((65280 & S) << 8) + ((255 & S) << 24);
      }
      function v() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function A(S) {
        var T;
        return S && S.state ? (T = S.state, S.total_in = S.total_out = T.total = 0, S.msg = "", T.wrap && (S.adler = 1 & T.wrap), T.mode = g, T.last = 0, T.havedict = 0, T.dmax = 32768, T.head = null, T.hold = 0, T.bits = 0, T.lencode = T.lendyn = new s.Buf32(y), T.distcode = T.distdyn = new s.Buf32(_), T.sane = 1, T.back = -1, p) : f;
      }
      function L(S) {
        var T;
        return S && S.state ? ((T = S.state).wsize = 0, T.whave = 0, T.wnext = 0, A(S)) : f;
      }
      function O(S, T) {
        var x, X;
        return S && S.state ? (X = S.state, T < 0 ? (x = 0, T = -T) : (x = 1 + (T >> 4), T < 48 && (T &= 15)), T && (T < 8 || 15 < T) ? f : (X.window !== null && X.wbits !== T && (X.window = null), X.wrap = x, X.wbits = T, L(S))) : f;
      }
      function R(S, T) {
        var x, X;
        return S ? (X = new v(), (S.state = X).window = null, (x = O(S, T)) !== p && (S.state = null), x) : f;
      }
      var C, E, M = !0;
      function q(S) {
        if (M) {
          var T;
          for (C = new s.Buf32(512), E = new s.Buf32(32), T = 0; T < 144; ) S.lens[T++] = 8;
          for (; T < 256; ) S.lens[T++] = 9;
          for (; T < 280; ) S.lens[T++] = 7;
          for (; T < 288; ) S.lens[T++] = 8;
          for (h(u, S.lens, 0, 288, C, 0, S.work, { bits: 9 }), T = 0; T < 32; ) S.lens[T++] = 5;
          h(d, S.lens, 0, 32, E, 0, S.work, { bits: 5 }), M = !1;
        }
        S.lencode = C, S.lenbits = 9, S.distcode = E, S.distbits = 5;
      }
      function N(S, T, x, X) {
        var V, D = S.state;
        return D.window === null && (D.wsize = 1 << D.wbits, D.wnext = 0, D.whave = 0, D.window = new s.Buf8(D.wsize)), X >= D.wsize ? (s.arraySet(D.window, T, x - D.wsize, D.wsize, 0), D.wnext = 0, D.whave = D.wsize) : (X < (V = D.wsize - D.wnext) && (V = X), s.arraySet(D.window, T, x - X, V, D.wnext), (X -= V) ? (s.arraySet(D.window, T, x - X, X, 0), D.wnext = X, D.whave = D.wsize) : (D.wnext += V, D.wnext === D.wsize && (D.wnext = 0), D.whave < D.wsize && (D.whave += V))), 0;
      }
      r.inflateReset = L, r.inflateReset2 = O, r.inflateResetKeep = A, r.inflateInit = function(S) {
        return R(S, 15);
      }, r.inflateInit2 = R, r.inflate = function(S, T) {
        var x, X, V, D, tt, H, ct, it, P, z, G, Y, ot, xt, gt, wt, qt, Dt, Yt, Xt, F, ht, $, nt, J = 0, st = new s.Buf8(4), vt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!S || !S.state || !S.output || !S.input && S.avail_in !== 0) return f;
        (x = S.state).mode === 12 && (x.mode = 13), tt = S.next_out, V = S.output, ct = S.avail_out, D = S.next_in, X = S.input, H = S.avail_in, it = x.hold, P = x.bits, z = H, G = ct, ht = p;
        t: for (; ; ) switch (x.mode) {
          case g:
            if (x.wrap === 0) {
              x.mode = 13;
              break;
            }
            for (; P < 16; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            if (2 & x.wrap && it === 35615) {
              st[x.check = 0] = 255 & it, st[1] = it >>> 8 & 255, x.check = a(x.check, st, 2, 0), P = it = 0, x.mode = 2;
              break;
            }
            if (x.flags = 0, x.head && (x.head.done = !1), !(1 & x.wrap) || (((255 & it) << 8) + (it >> 8)) % 31) {
              S.msg = "incorrect header check", x.mode = 30;
              break;
            }
            if ((15 & it) != 8) {
              S.msg = "unknown compression method", x.mode = 30;
              break;
            }
            if (P -= 4, F = 8 + (15 & (it >>>= 4)), x.wbits === 0) x.wbits = F;
            else if (F > x.wbits) {
              S.msg = "invalid window size", x.mode = 30;
              break;
            }
            x.dmax = 1 << F, S.adler = x.check = 1, x.mode = 512 & it ? 10 : 12, P = it = 0;
            break;
          case 2:
            for (; P < 16; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            if (x.flags = it, (255 & x.flags) != 8) {
              S.msg = "unknown compression method", x.mode = 30;
              break;
            }
            if (57344 & x.flags) {
              S.msg = "unknown header flags set", x.mode = 30;
              break;
            }
            x.head && (x.head.text = it >> 8 & 1), 512 & x.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, x.check = a(x.check, st, 2, 0)), P = it = 0, x.mode = 3;
          case 3:
            for (; P < 32; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            x.head && (x.head.time = it), 512 & x.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, st[2] = it >>> 16 & 255, st[3] = it >>> 24 & 255, x.check = a(x.check, st, 4, 0)), P = it = 0, x.mode = 4;
          case 4:
            for (; P < 16; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            x.head && (x.head.xflags = 255 & it, x.head.os = it >> 8), 512 & x.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, x.check = a(x.check, st, 2, 0)), P = it = 0, x.mode = 5;
          case 5:
            if (1024 & x.flags) {
              for (; P < 16; ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              x.length = it, x.head && (x.head.extra_len = it), 512 & x.flags && (st[0] = 255 & it, st[1] = it >>> 8 & 255, x.check = a(x.check, st, 2, 0)), P = it = 0;
            } else x.head && (x.head.extra = null);
            x.mode = 6;
          case 6:
            if (1024 & x.flags && (H < (Y = x.length) && (Y = H), Y && (x.head && (F = x.head.extra_len - x.length, x.head.extra || (x.head.extra = new Array(x.head.extra_len)), s.arraySet(x.head.extra, X, D, Y, F)), 512 & x.flags && (x.check = a(x.check, X, Y, D)), H -= Y, D += Y, x.length -= Y), x.length)) break t;
            x.length = 0, x.mode = 7;
          case 7:
            if (2048 & x.flags) {
              if (H === 0) break t;
              for (Y = 0; F = X[D + Y++], x.head && F && x.length < 65536 && (x.head.name += String.fromCharCode(F)), F && Y < H; ) ;
              if (512 & x.flags && (x.check = a(x.check, X, Y, D)), H -= Y, D += Y, F) break t;
            } else x.head && (x.head.name = null);
            x.length = 0, x.mode = 8;
          case 8:
            if (4096 & x.flags) {
              if (H === 0) break t;
              for (Y = 0; F = X[D + Y++], x.head && F && x.length < 65536 && (x.head.comment += String.fromCharCode(F)), F && Y < H; ) ;
              if (512 & x.flags && (x.check = a(x.check, X, Y, D)), H -= Y, D += Y, F) break t;
            } else x.head && (x.head.comment = null);
            x.mode = 9;
          case 9:
            if (512 & x.flags) {
              for (; P < 16; ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              if (it !== (65535 & x.check)) {
                S.msg = "header crc mismatch", x.mode = 30;
                break;
              }
              P = it = 0;
            }
            x.head && (x.head.hcrc = x.flags >> 9 & 1, x.head.done = !0), S.adler = x.check = 0, x.mode = 12;
            break;
          case 10:
            for (; P < 32; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            S.adler = x.check = b(it), P = it = 0, x.mode = 11;
          case 11:
            if (x.havedict === 0) return S.next_out = tt, S.avail_out = ct, S.next_in = D, S.avail_in = H, x.hold = it, x.bits = P, 2;
            S.adler = x.check = 1, x.mode = 12;
          case 12:
            if (T === 5 || T === 6) break t;
          case 13:
            if (x.last) {
              it >>>= 7 & P, P -= 7 & P, x.mode = 27;
              break;
            }
            for (; P < 3; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            switch (x.last = 1 & it, P -= 1, 3 & (it >>>= 1)) {
              case 0:
                x.mode = 14;
                break;
              case 1:
                if (q(x), x.mode = 20, T !== 6) break;
                it >>>= 2, P -= 2;
                break t;
              case 2:
                x.mode = 17;
                break;
              case 3:
                S.msg = "invalid block type", x.mode = 30;
            }
            it >>>= 2, P -= 2;
            break;
          case 14:
            for (it >>>= 7 & P, P -= 7 & P; P < 32; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            if ((65535 & it) != (it >>> 16 ^ 65535)) {
              S.msg = "invalid stored block lengths", x.mode = 30;
              break;
            }
            if (x.length = 65535 & it, P = it = 0, x.mode = 15, T === 6) break t;
          case 15:
            x.mode = 16;
          case 16:
            if (Y = x.length) {
              if (H < Y && (Y = H), ct < Y && (Y = ct), Y === 0) break t;
              s.arraySet(V, X, D, Y, tt), H -= Y, D += Y, ct -= Y, tt += Y, x.length -= Y;
              break;
            }
            x.mode = 12;
            break;
          case 17:
            for (; P < 14; ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            if (x.nlen = 257 + (31 & it), it >>>= 5, P -= 5, x.ndist = 1 + (31 & it), it >>>= 5, P -= 5, x.ncode = 4 + (15 & it), it >>>= 4, P -= 4, 286 < x.nlen || 30 < x.ndist) {
              S.msg = "too many length or distance symbols", x.mode = 30;
              break;
            }
            x.have = 0, x.mode = 18;
          case 18:
            for (; x.have < x.ncode; ) {
              for (; P < 3; ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              x.lens[vt[x.have++]] = 7 & it, it >>>= 3, P -= 3;
            }
            for (; x.have < 19; ) x.lens[vt[x.have++]] = 0;
            if (x.lencode = x.lendyn, x.lenbits = 7, $ = { bits: x.lenbits }, ht = h(0, x.lens, 0, 19, x.lencode, 0, x.work, $), x.lenbits = $.bits, ht) {
              S.msg = "invalid code lengths set", x.mode = 30;
              break;
            }
            x.have = 0, x.mode = 19;
          case 19:
            for (; x.have < x.nlen + x.ndist; ) {
              for (; wt = (J = x.lencode[it & (1 << x.lenbits) - 1]) >>> 16 & 255, qt = 65535 & J, !((gt = J >>> 24) <= P); ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              if (qt < 16) it >>>= gt, P -= gt, x.lens[x.have++] = qt;
              else {
                if (qt === 16) {
                  for (nt = gt + 2; P < nt; ) {
                    if (H === 0) break t;
                    H--, it += X[D++] << P, P += 8;
                  }
                  if (it >>>= gt, P -= gt, x.have === 0) {
                    S.msg = "invalid bit length repeat", x.mode = 30;
                    break;
                  }
                  F = x.lens[x.have - 1], Y = 3 + (3 & it), it >>>= 2, P -= 2;
                } else if (qt === 17) {
                  for (nt = gt + 3; P < nt; ) {
                    if (H === 0) break t;
                    H--, it += X[D++] << P, P += 8;
                  }
                  P -= gt, F = 0, Y = 3 + (7 & (it >>>= gt)), it >>>= 3, P -= 3;
                } else {
                  for (nt = gt + 7; P < nt; ) {
                    if (H === 0) break t;
                    H--, it += X[D++] << P, P += 8;
                  }
                  P -= gt, F = 0, Y = 11 + (127 & (it >>>= gt)), it >>>= 7, P -= 7;
                }
                if (x.have + Y > x.nlen + x.ndist) {
                  S.msg = "invalid bit length repeat", x.mode = 30;
                  break;
                }
                for (; Y--; ) x.lens[x.have++] = F;
              }
            }
            if (x.mode === 30) break;
            if (x.lens[256] === 0) {
              S.msg = "invalid code -- missing end-of-block", x.mode = 30;
              break;
            }
            if (x.lenbits = 9, $ = { bits: x.lenbits }, ht = h(u, x.lens, 0, x.nlen, x.lencode, 0, x.work, $), x.lenbits = $.bits, ht) {
              S.msg = "invalid literal/lengths set", x.mode = 30;
              break;
            }
            if (x.distbits = 6, x.distcode = x.distdyn, $ = { bits: x.distbits }, ht = h(d, x.lens, x.nlen, x.ndist, x.distcode, 0, x.work, $), x.distbits = $.bits, ht) {
              S.msg = "invalid distances set", x.mode = 30;
              break;
            }
            if (x.mode = 20, T === 6) break t;
          case 20:
            x.mode = 21;
          case 21:
            if (6 <= H && 258 <= ct) {
              S.next_out = tt, S.avail_out = ct, S.next_in = D, S.avail_in = H, x.hold = it, x.bits = P, l(S, G), tt = S.next_out, V = S.output, ct = S.avail_out, D = S.next_in, X = S.input, H = S.avail_in, it = x.hold, P = x.bits, x.mode === 12 && (x.back = -1);
              break;
            }
            for (x.back = 0; wt = (J = x.lencode[it & (1 << x.lenbits) - 1]) >>> 16 & 255, qt = 65535 & J, !((gt = J >>> 24) <= P); ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            if (wt && !(240 & wt)) {
              for (Dt = gt, Yt = wt, Xt = qt; wt = (J = x.lencode[Xt + ((it & (1 << Dt + Yt) - 1) >> Dt)]) >>> 16 & 255, qt = 65535 & J, !(Dt + (gt = J >>> 24) <= P); ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              it >>>= Dt, P -= Dt, x.back += Dt;
            }
            if (it >>>= gt, P -= gt, x.back += gt, x.length = qt, wt === 0) {
              x.mode = 26;
              break;
            }
            if (32 & wt) {
              x.back = -1, x.mode = 12;
              break;
            }
            if (64 & wt) {
              S.msg = "invalid literal/length code", x.mode = 30;
              break;
            }
            x.extra = 15 & wt, x.mode = 22;
          case 22:
            if (x.extra) {
              for (nt = x.extra; P < nt; ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              x.length += it & (1 << x.extra) - 1, it >>>= x.extra, P -= x.extra, x.back += x.extra;
            }
            x.was = x.length, x.mode = 23;
          case 23:
            for (; wt = (J = x.distcode[it & (1 << x.distbits) - 1]) >>> 16 & 255, qt = 65535 & J, !((gt = J >>> 24) <= P); ) {
              if (H === 0) break t;
              H--, it += X[D++] << P, P += 8;
            }
            if (!(240 & wt)) {
              for (Dt = gt, Yt = wt, Xt = qt; wt = (J = x.distcode[Xt + ((it & (1 << Dt + Yt) - 1) >> Dt)]) >>> 16 & 255, qt = 65535 & J, !(Dt + (gt = J >>> 24) <= P); ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              it >>>= Dt, P -= Dt, x.back += Dt;
            }
            if (it >>>= gt, P -= gt, x.back += gt, 64 & wt) {
              S.msg = "invalid distance code", x.mode = 30;
              break;
            }
            x.offset = qt, x.extra = 15 & wt, x.mode = 24;
          case 24:
            if (x.extra) {
              for (nt = x.extra; P < nt; ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              x.offset += it & (1 << x.extra) - 1, it >>>= x.extra, P -= x.extra, x.back += x.extra;
            }
            if (x.offset > x.dmax) {
              S.msg = "invalid distance too far back", x.mode = 30;
              break;
            }
            x.mode = 25;
          case 25:
            if (ct === 0) break t;
            if (Y = G - ct, x.offset > Y) {
              if ((Y = x.offset - Y) > x.whave && x.sane) {
                S.msg = "invalid distance too far back", x.mode = 30;
                break;
              }
              ot = Y > x.wnext ? (Y -= x.wnext, x.wsize - Y) : x.wnext - Y, Y > x.length && (Y = x.length), xt = x.window;
            } else xt = V, ot = tt - x.offset, Y = x.length;
            for (ct < Y && (Y = ct), ct -= Y, x.length -= Y; V[tt++] = xt[ot++], --Y; ) ;
            x.length === 0 && (x.mode = 21);
            break;
          case 26:
            if (ct === 0) break t;
            V[tt++] = x.length, ct--, x.mode = 21;
            break;
          case 27:
            if (x.wrap) {
              for (; P < 32; ) {
                if (H === 0) break t;
                H--, it |= X[D++] << P, P += 8;
              }
              if (G -= ct, S.total_out += G, x.total += G, G && (S.adler = x.check = x.flags ? a(x.check, V, G, tt - G) : o(x.check, V, G, tt - G)), G = ct, (x.flags ? it : b(it)) !== x.check) {
                S.msg = "incorrect data check", x.mode = 30;
                break;
              }
              P = it = 0;
            }
            x.mode = 28;
          case 28:
            if (x.wrap && x.flags) {
              for (; P < 32; ) {
                if (H === 0) break t;
                H--, it += X[D++] << P, P += 8;
              }
              if (it !== (4294967295 & x.total)) {
                S.msg = "incorrect length check", x.mode = 30;
                break;
              }
              P = it = 0;
            }
            x.mode = 29;
          case 29:
            ht = 1;
            break t;
          case 30:
            ht = -3;
            break t;
          case 31:
            return -4;
          case 32:
          default:
            return f;
        }
        return S.next_out = tt, S.avail_out = ct, S.next_in = D, S.avail_in = H, x.hold = it, x.bits = P, (x.wsize || G !== S.avail_out && x.mode < 30 && (x.mode < 27 || T !== 4)) && N(S, S.output, S.next_out, G - S.avail_out) ? (x.mode = 31, -4) : (z -= S.avail_in, G -= S.avail_out, S.total_in += z, S.total_out += G, x.total += G, x.wrap && G && (S.adler = x.check = x.flags ? a(x.check, V, G, S.next_out - G) : o(x.check, V, G, S.next_out - G)), S.data_type = x.bits + (x.last ? 64 : 0) + (x.mode === 12 ? 128 : 0) + (x.mode === 20 || x.mode === 15 ? 256 : 0), (z == 0 && G === 0 || T === 4) && ht === p && (ht = -5), ht);
      }, r.inflateEnd = function(S) {
        if (!S || !S.state) return f;
        var T = S.state;
        return T.window && (T.window = null), S.state = null, p;
      }, r.inflateGetHeader = function(S, T) {
        var x;
        return S && S.state && 2 & (x = S.state).wrap ? ((x.head = T).done = !1, p) : f;
      }, r.inflateSetDictionary = function(S, T) {
        var x, X = T.length;
        return S && S.state ? (x = S.state).wrap !== 0 && x.mode !== 11 ? f : x.mode === 11 && o(1, T, X, 0) !== x.check ? -3 : N(S, T, X, X) ? (x.mode = 31, -4) : (x.havedict = 1, p) : f;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, r) {
      var s = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(u, d, p, f, g, y, _, b) {
        var v, A, L, O, R, C, E, M, q, N = b.bits, S = 0, T = 0, x = 0, X = 0, V = 0, D = 0, tt = 0, H = 0, ct = 0, it = 0, P = null, z = 0, G = new s.Buf16(16), Y = new s.Buf16(16), ot = null, xt = 0;
        for (S = 0; S <= 15; S++) G[S] = 0;
        for (T = 0; T < f; T++) G[d[p + T]]++;
        for (V = N, X = 15; 1 <= X && G[X] === 0; X--) ;
        if (X < V && (V = X), X === 0) return g[y++] = 20971520, g[y++] = 20971520, b.bits = 1, 0;
        for (x = 1; x < X && G[x] === 0; x++) ;
        for (V < x && (V = x), S = H = 1; S <= 15; S++) if (H <<= 1, (H -= G[S]) < 0) return -1;
        if (0 < H && (u === 0 || X !== 1)) return -1;
        for (Y[1] = 0, S = 1; S < 15; S++) Y[S + 1] = Y[S] + G[S];
        for (T = 0; T < f; T++) d[p + T] !== 0 && (_[Y[d[p + T]]++] = T);
        if (C = u === 0 ? (P = ot = _, 19) : u === 1 ? (P = o, z -= 257, ot = a, xt -= 257, 256) : (P = l, ot = h, -1), S = x, R = y, tt = T = it = 0, L = -1, O = (ct = 1 << (D = V)) - 1, u === 1 && 852 < ct || u === 2 && 592 < ct) return 1;
        for (; ; ) {
          for (E = S - tt, q = _[T] < C ? (M = 0, _[T]) : _[T] > C ? (M = ot[xt + _[T]], P[z + _[T]]) : (M = 96, 0), v = 1 << S - tt, x = A = 1 << D; g[R + (it >> tt) + (A -= v)] = E << 24 | M << 16 | q | 0, A !== 0; ) ;
          for (v = 1 << S - 1; it & v; ) v >>= 1;
          if (v !== 0 ? (it &= v - 1, it += v) : it = 0, T++, --G[S] == 0) {
            if (S === X) break;
            S = d[p + _[T]];
          }
          if (V < S && (it & O) !== L) {
            for (tt === 0 && (tt = V), R += x, H = 1 << (D = S - tt); D + tt < X && !((H -= G[D + tt]) <= 0); ) D++, H <<= 1;
            if (ct += 1 << D, u === 1 && 852 < ct || u === 2 && 592 < ct) return 1;
            g[L = it & O] = V << 24 | D << 16 | R - y | 0;
          }
        }
        return it !== 0 && (g[R + it] = S - tt << 24 | 64 << 16 | 0), b.bits = V, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, r) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, r) {
      var s = e("../utils/common"), o = 0, a = 1;
      function l(J) {
        for (var st = J.length; 0 <= --st; ) J[st] = 0;
      }
      var h = 0, u = 29, d = 256, p = d + 1 + u, f = 30, g = 19, y = 2 * p + 1, _ = 15, b = 16, v = 7, A = 256, L = 16, O = 17, R = 18, C = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], E = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], M = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], q = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], N = new Array(2 * (p + 2));
      l(N);
      var S = new Array(2 * f);
      l(S);
      var T = new Array(512);
      l(T);
      var x = new Array(256);
      l(x);
      var X = new Array(u);
      l(X);
      var V, D, tt, H = new Array(f);
      function ct(J, st, vt, St, ft) {
        this.static_tree = J, this.extra_bits = st, this.extra_base = vt, this.elems = St, this.max_length = ft, this.has_stree = J && J.length;
      }
      function it(J, st) {
        this.dyn_tree = J, this.max_code = 0, this.stat_desc = st;
      }
      function P(J) {
        return J < 256 ? T[J] : T[256 + (J >>> 7)];
      }
      function z(J, st) {
        J.pending_buf[J.pending++] = 255 & st, J.pending_buf[J.pending++] = st >>> 8 & 255;
      }
      function G(J, st, vt) {
        J.bi_valid > b - vt ? (J.bi_buf |= st << J.bi_valid & 65535, z(J, J.bi_buf), J.bi_buf = st >> b - J.bi_valid, J.bi_valid += vt - b) : (J.bi_buf |= st << J.bi_valid & 65535, J.bi_valid += vt);
      }
      function Y(J, st, vt) {
        G(J, vt[2 * st], vt[2 * st + 1]);
      }
      function ot(J, st) {
        for (var vt = 0; vt |= 1 & J, J >>>= 1, vt <<= 1, 0 < --st; ) ;
        return vt >>> 1;
      }
      function xt(J, st, vt) {
        var St, ft, Et = new Array(_ + 1), zt = 0;
        for (St = 1; St <= _; St++) Et[St] = zt = zt + vt[St - 1] << 1;
        for (ft = 0; ft <= st; ft++) {
          var Tt = J[2 * ft + 1];
          Tt !== 0 && (J[2 * ft] = ot(Et[Tt]++, Tt));
        }
      }
      function gt(J) {
        var st;
        for (st = 0; st < p; st++) J.dyn_ltree[2 * st] = 0;
        for (st = 0; st < f; st++) J.dyn_dtree[2 * st] = 0;
        for (st = 0; st < g; st++) J.bl_tree[2 * st] = 0;
        J.dyn_ltree[2 * A] = 1, J.opt_len = J.static_len = 0, J.last_lit = J.matches = 0;
      }
      function wt(J) {
        8 < J.bi_valid ? z(J, J.bi_buf) : 0 < J.bi_valid && (J.pending_buf[J.pending++] = J.bi_buf), J.bi_buf = 0, J.bi_valid = 0;
      }
      function qt(J, st, vt, St) {
        var ft = 2 * st, Et = 2 * vt;
        return J[ft] < J[Et] || J[ft] === J[Et] && St[st] <= St[vt];
      }
      function Dt(J, st, vt) {
        for (var St = J.heap[vt], ft = vt << 1; ft <= J.heap_len && (ft < J.heap_len && qt(st, J.heap[ft + 1], J.heap[ft], J.depth) && ft++, !qt(st, St, J.heap[ft], J.depth)); ) J.heap[vt] = J.heap[ft], vt = ft, ft <<= 1;
        J.heap[vt] = St;
      }
      function Yt(J, st, vt) {
        var St, ft, Et, zt, Tt = 0;
        if (J.last_lit !== 0) for (; St = J.pending_buf[J.d_buf + 2 * Tt] << 8 | J.pending_buf[J.d_buf + 2 * Tt + 1], ft = J.pending_buf[J.l_buf + Tt], Tt++, St === 0 ? Y(J, ft, st) : (Y(J, (Et = x[ft]) + d + 1, st), (zt = C[Et]) !== 0 && G(J, ft -= X[Et], zt), Y(J, Et = P(--St), vt), (zt = E[Et]) !== 0 && G(J, St -= H[Et], zt)), Tt < J.last_lit; ) ;
        Y(J, A, st);
      }
      function Xt(J, st) {
        var vt, St, ft, Et = st.dyn_tree, zt = st.stat_desc.static_tree, Tt = st.stat_desc.has_stree, $t = st.stat_desc.elems, ee = -1;
        for (J.heap_len = 0, J.heap_max = y, vt = 0; vt < $t; vt++) Et[2 * vt] !== 0 ? (J.heap[++J.heap_len] = ee = vt, J.depth[vt] = 0) : Et[2 * vt + 1] = 0;
        for (; J.heap_len < 2; ) Et[2 * (ft = J.heap[++J.heap_len] = ee < 2 ? ++ee : 0)] = 1, J.depth[ft] = 0, J.opt_len--, Tt && (J.static_len -= zt[2 * ft + 1]);
        for (st.max_code = ee, vt = J.heap_len >> 1; 1 <= vt; vt--) Dt(J, Et, vt);
        for (ft = $t; vt = J.heap[1], J.heap[1] = J.heap[J.heap_len--], Dt(J, Et, 1), St = J.heap[1], J.heap[--J.heap_max] = vt, J.heap[--J.heap_max] = St, Et[2 * ft] = Et[2 * vt] + Et[2 * St], J.depth[ft] = (J.depth[vt] >= J.depth[St] ? J.depth[vt] : J.depth[St]) + 1, Et[2 * vt + 1] = Et[2 * St + 1] = ft, J.heap[1] = ft++, Dt(J, Et, 1), 2 <= J.heap_len; ) ;
        J.heap[--J.heap_max] = J.heap[1], function(oe, ae) {
          var we, Jt, Nt, Ot, re, Zt, fe = ae.dyn_tree, ie = ae.max_code, de = ae.stat_desc.static_tree, We = ae.stat_desc.has_stree, Te = ae.stat_desc.extra_bits, _n = ae.stat_desc.extra_base, Fn = ae.stat_desc.max_length, Qe = 0;
          for (Ot = 0; Ot <= _; Ot++) oe.bl_count[Ot] = 0;
          for (fe[2 * oe.heap[oe.heap_max] + 1] = 0, we = oe.heap_max + 1; we < y; we++) Fn < (Ot = fe[2 * fe[2 * (Jt = oe.heap[we]) + 1] + 1] + 1) && (Ot = Fn, Qe++), fe[2 * Jt + 1] = Ot, ie < Jt || (oe.bl_count[Ot]++, re = 0, _n <= Jt && (re = Te[Jt - _n]), Zt = fe[2 * Jt], oe.opt_len += Zt * (Ot + re), We && (oe.static_len += Zt * (de[2 * Jt + 1] + re)));
          if (Qe !== 0) {
            do {
              for (Ot = Fn - 1; oe.bl_count[Ot] === 0; ) Ot--;
              oe.bl_count[Ot]--, oe.bl_count[Ot + 1] += 2, oe.bl_count[Fn]--, Qe -= 2;
            } while (0 < Qe);
            for (Ot = Fn; Ot !== 0; Ot--) for (Jt = oe.bl_count[Ot]; Jt !== 0; ) ie < (Nt = oe.heap[--we]) || (fe[2 * Nt + 1] !== Ot && (oe.opt_len += (Ot - fe[2 * Nt + 1]) * fe[2 * Nt], fe[2 * Nt + 1] = Ot), Jt--);
          }
        }(J, st), xt(Et, ee, J.bl_count);
      }
      function F(J, st, vt) {
        var St, ft, Et = -1, zt = st[1], Tt = 0, $t = 7, ee = 4;
        for (zt === 0 && ($t = 138, ee = 3), st[2 * (vt + 1) + 1] = 65535, St = 0; St <= vt; St++) ft = zt, zt = st[2 * (St + 1) + 1], ++Tt < $t && ft === zt || (Tt < ee ? J.bl_tree[2 * ft] += Tt : ft !== 0 ? (ft !== Et && J.bl_tree[2 * ft]++, J.bl_tree[2 * L]++) : Tt <= 10 ? J.bl_tree[2 * O]++ : J.bl_tree[2 * R]++, Et = ft, ee = (Tt = 0) === zt ? ($t = 138, 3) : ft === zt ? ($t = 6, 3) : ($t = 7, 4));
      }
      function ht(J, st, vt) {
        var St, ft, Et = -1, zt = st[1], Tt = 0, $t = 7, ee = 4;
        for (zt === 0 && ($t = 138, ee = 3), St = 0; St <= vt; St++) if (ft = zt, zt = st[2 * (St + 1) + 1], !(++Tt < $t && ft === zt)) {
          if (Tt < ee) for (; Y(J, ft, J.bl_tree), --Tt != 0; ) ;
          else ft !== 0 ? (ft !== Et && (Y(J, ft, J.bl_tree), Tt--), Y(J, L, J.bl_tree), G(J, Tt - 3, 2)) : Tt <= 10 ? (Y(J, O, J.bl_tree), G(J, Tt - 3, 3)) : (Y(J, R, J.bl_tree), G(J, Tt - 11, 7));
          Et = ft, ee = (Tt = 0) === zt ? ($t = 138, 3) : ft === zt ? ($t = 6, 3) : ($t = 7, 4);
        }
      }
      l(H);
      var $ = !1;
      function nt(J, st, vt, St) {
        G(J, (h << 1) + (St ? 1 : 0), 3), function(ft, Et, zt, Tt) {
          wt(ft), z(ft, zt), z(ft, ~zt), s.arraySet(ft.pending_buf, ft.window, Et, zt, ft.pending), ft.pending += zt;
        }(J, st, vt);
      }
      r._tr_init = function(J) {
        $ || (function() {
          var st, vt, St, ft, Et, zt = new Array(_ + 1);
          for (ft = St = 0; ft < u - 1; ft++) for (X[ft] = St, st = 0; st < 1 << C[ft]; st++) x[St++] = ft;
          for (x[St - 1] = ft, ft = Et = 0; ft < 16; ft++) for (H[ft] = Et, st = 0; st < 1 << E[ft]; st++) T[Et++] = ft;
          for (Et >>= 7; ft < f; ft++) for (H[ft] = Et << 7, st = 0; st < 1 << E[ft] - 7; st++) T[256 + Et++] = ft;
          for (vt = 0; vt <= _; vt++) zt[vt] = 0;
          for (st = 0; st <= 143; ) N[2 * st + 1] = 8, st++, zt[8]++;
          for (; st <= 255; ) N[2 * st + 1] = 9, st++, zt[9]++;
          for (; st <= 279; ) N[2 * st + 1] = 7, st++, zt[7]++;
          for (; st <= 287; ) N[2 * st + 1] = 8, st++, zt[8]++;
          for (xt(N, p + 1, zt), st = 0; st < f; st++) S[2 * st + 1] = 5, S[2 * st] = ot(st, 5);
          V = new ct(N, C, d + 1, p, _), D = new ct(S, E, 0, f, _), tt = new ct(new Array(0), M, 0, g, v);
        }(), $ = !0), J.l_desc = new it(J.dyn_ltree, V), J.d_desc = new it(J.dyn_dtree, D), J.bl_desc = new it(J.bl_tree, tt), J.bi_buf = 0, J.bi_valid = 0, gt(J);
      }, r._tr_stored_block = nt, r._tr_flush_block = function(J, st, vt, St) {
        var ft, Et, zt = 0;
        0 < J.level ? (J.strm.data_type === 2 && (J.strm.data_type = function(Tt) {
          var $t, ee = 4093624447;
          for ($t = 0; $t <= 31; $t++, ee >>>= 1) if (1 & ee && Tt.dyn_ltree[2 * $t] !== 0) return o;
          if (Tt.dyn_ltree[18] !== 0 || Tt.dyn_ltree[20] !== 0 || Tt.dyn_ltree[26] !== 0) return a;
          for ($t = 32; $t < d; $t++) if (Tt.dyn_ltree[2 * $t] !== 0) return a;
          return o;
        }(J)), Xt(J, J.l_desc), Xt(J, J.d_desc), zt = function(Tt) {
          var $t;
          for (F(Tt, Tt.dyn_ltree, Tt.l_desc.max_code), F(Tt, Tt.dyn_dtree, Tt.d_desc.max_code), Xt(Tt, Tt.bl_desc), $t = g - 1; 3 <= $t && Tt.bl_tree[2 * q[$t] + 1] === 0; $t--) ;
          return Tt.opt_len += 3 * ($t + 1) + 5 + 5 + 4, $t;
        }(J), ft = J.opt_len + 3 + 7 >>> 3, (Et = J.static_len + 3 + 7 >>> 3) <= ft && (ft = Et)) : ft = Et = vt + 5, vt + 4 <= ft && st !== -1 ? nt(J, st, vt, St) : J.strategy === 4 || Et === ft ? (G(J, 2 + (St ? 1 : 0), 3), Yt(J, N, S)) : (G(J, 4 + (St ? 1 : 0), 3), function(Tt, $t, ee, oe) {
          var ae;
          for (G(Tt, $t - 257, 5), G(Tt, ee - 1, 5), G(Tt, oe - 4, 4), ae = 0; ae < oe; ae++) G(Tt, Tt.bl_tree[2 * q[ae] + 1], 3);
          ht(Tt, Tt.dyn_ltree, $t - 1), ht(Tt, Tt.dyn_dtree, ee - 1);
        }(J, J.l_desc.max_code + 1, J.d_desc.max_code + 1, zt + 1), Yt(J, J.dyn_ltree, J.dyn_dtree)), gt(J), St && wt(J);
      }, r._tr_tally = function(J, st, vt) {
        return J.pending_buf[J.d_buf + 2 * J.last_lit] = st >>> 8 & 255, J.pending_buf[J.d_buf + 2 * J.last_lit + 1] = 255 & st, J.pending_buf[J.l_buf + J.last_lit] = 255 & vt, J.last_lit++, st === 0 ? J.dyn_ltree[2 * vt]++ : (J.matches++, st--, J.dyn_ltree[2 * (x[vt] + d + 1)]++, J.dyn_dtree[2 * P(st)]++), J.last_lit === J.lit_bufsize - 1;
      }, r._tr_align = function(J) {
        G(J, 2, 3), Y(J, A, N), function(st) {
          st.bi_valid === 16 ? (z(st, st.bi_buf), st.bi_buf = 0, st.bi_valid = 0) : 8 <= st.bi_valid && (st.pending_buf[st.pending++] = 255 & st.bi_buf, st.bi_buf >>= 8, st.bi_valid -= 8);
        }(J);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, r) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, r) {
      (function(s) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, h, u, d, p = 1, f = {}, g = !1, y = o.document, _ = Object.getPrototypeOf && Object.getPrototypeOf(o);
            _ = _ && _.setTimeout ? _ : o, l = {}.toString.call(o.process) === "[object process]" ? function(L) {
              process.nextTick(function() {
                v(L);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var L = !0, O = o.onmessage;
                return o.onmessage = function() {
                  L = !1;
                }, o.postMessage("", "*"), o.onmessage = O, L;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", A, !1) : o.attachEvent("onmessage", A), function(L) {
              o.postMessage(d + L, "*");
            }) : o.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(L) {
              v(L.data);
            }, function(L) {
              u.port2.postMessage(L);
            }) : y && "onreadystatechange" in y.createElement("script") ? (h = y.documentElement, function(L) {
              var O = y.createElement("script");
              O.onreadystatechange = function() {
                v(L), O.onreadystatechange = null, h.removeChild(O), O = null;
              }, h.appendChild(O);
            }) : function(L) {
              setTimeout(v, 0, L);
            }, _.setImmediate = function(L) {
              typeof L != "function" && (L = new Function("" + L));
              for (var O = new Array(arguments.length - 1), R = 0; R < O.length; R++) O[R] = arguments[R + 1];
              var C = { callback: L, args: O };
              return f[p] = C, l(p), p++;
            }, _.clearImmediate = b;
          }
          function b(L) {
            delete f[L];
          }
          function v(L) {
            if (g) setTimeout(v, 0, L);
            else {
              var O = f[L];
              if (O) {
                g = !0;
                try {
                  (function(R) {
                    var C = R.callback, E = R.args;
                    switch (E.length) {
                      case 0:
                        C();
                        break;
                      case 1:
                        C(E[0]);
                        break;
                      case 2:
                        C(E[0], E[1]);
                        break;
                      case 3:
                        C(E[0], E[1], E[2]);
                        break;
                      default:
                        C.apply(a, E);
                    }
                  })(O);
                } finally {
                  b(L), g = !1;
                }
              }
            }
          }
          function A(L) {
            L.source === o && typeof L.data == "string" && L.data.indexOf(d) === 0 && v(+L.data.slice(d.length));
          }
        })(typeof self > "u" ? s === void 0 ? this : s : self);
      }).call(this, typeof uo < "u" ? uo : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(qm);
var Hk = qm.exports;
const Gk = /* @__PURE__ */ Tc(Hk), Vk = {
  key: 0,
  class: "debug"
}, Yk = !0, Kk = /* @__PURE__ */ Rr({
  __name: "WordPress",
  setup(n) {
    const t = po(() => import("./FormulaPricing--BfBx95c.js")), e = po(() => import("./ObjectViewer-CW0Ix_lM.js")), i = "production", r = {}, s = {};
    let o, a, l;
    const h = {
      banding: null,
      finish: null
    };
    let u = null, d = [], p = null, f = {};
    const g = _e(!1), y = _e("manual"), _ = _e(""), b = _e([]), v = _e(null), A = _e(!0), L = _e(null), O = _e(!1), R = _e(null), C = Re(() => window.smartcutConfig.settings.units ?? "decimal");
    F2("calculator", () => R.value);
    const E = (Nt) => {
      g.value && console.log("SmartCut -", ...Nt);
    }, M = (Nt) => {
      console.error(`SmartCut - ${Nt}`);
    }, q = (Nt = !0) => {
      O.value = !0, ["checkout", "intro_text", "offcuts", "banding_key"].forEach((re) => ht(re, "block")), zt() && ht("pricing_table", "table"), Nt ? S(!0) : T(), X();
    }, N = (Nt = !0, Ot = !0) => {
      O.value = !1, ["checkout", "intro_text", "offcuts", "banding_key", "pricing_table"].forEach((Zt) => ht(Zt, "none")), Ot === !0 ? x() : Ot === !1 && X(), S ? S() : Nt === !1 && T();
    }, S = (Nt = !1) => {
      ht("quantity", "inline-block"), r.quantity.readOnly = Nt;
    }, T = () => {
      O.value !== !1 && (V(1), ht("quantity", "none"), r.quantity.readOnly = !0);
    }, x = () => {
      if (!r.cart_button) {
        M("Cart button not found");
        return;
      }
      r.cart_button.disabled = !1;
    }, X = () => {
      if (O.value !== !1) {
        if (!r.cart_button) {
          M("Cart button not found");
          return;
        }
        r.cart_button.disabled = !0;
      }
    }, V = (Nt, Ot = 0) => {
      if (E(["setting cart quantity", Nt]), !r.quantity) {
        M("Quantity field not found when trying to set");
        return;
      }
      r.quantity.value = Nt.toFixed(Ot), console.assert(r.quantity.value === Nt.toFixed(Ot), "Quantity field value not set correctly");
    }, D = (Nt) => {
      E(["setting variation price", Nt]);
      const Ot = document.querySelector(".woocommerce-variation-price .smartcut-price-selector");
      Ot && (Ot.innerText = ot(Nt)), v.value.display_price = Nt;
    }, tt = () => {
      if (!(window != null && window.smartcutConfig)) {
        M("SmartCut config not found");
        return;
      }
      const Nt = window.smartcutConfig;
      l = Nt.settings;
      const Ot = qt(Rn(window, ["smartcutConfig", "banding_data"])), re = qt(Rn(window, ["smartcutConfig", "finish_data"])), Zt = {
        debug: l.debug,
        units: l.units,
        locale: Nt.locale,
        decimalPlaces: 2,
        //saw
        stockType: l.stock_type,
        bladeWidth: l.blade_width,
        cutPreference: l.cut_preference,
        stackHeight: l.stack_height,
        stockSelection: l.stock_selection,
        stockGrain: l.stock_grain,
        minSpacing: l.min_spacing,
        maxParts: l.max_parts ?? null,
        orientationModel: l.orientation_model,
        minDimension: l.min_dimension,
        partTrim: l.part_trim,
        enable: {
          banding: l.enable_banding,
          finish: l.enable_finish,
          orientation: l.enable_orientation,
          diagram: !l.hide_diagram,
          machining: l.enable_machining,
          csvImport: l.enable_import,
          partName: l.enable_part_name,
          imageUpload: l.enable_image_upload,
          focus: !0,
          click: !0,
          progressNumber: l.pricing_strategy !== "part_area"
        },
        colors: {
          partA: (l == null ? void 0 : l.part_a_color) ?? "#1d9bc4",
          partB: (l == null ? void 0 : l.part_b_color) ?? "#065d7a",
          partHover: (l == null ? void 0 : l.part_hover_color) ?? "#f8b029",
          partSelected: (l == null ? void 0 : l.part_selected_color) ?? "#5bc85b",
          stock: (l == null ? void 0 : l.stock_color) ?? "#ffd166",
          button: (l == null ? void 0 : l.button_color) ?? "#118ab2",
          buttonText: (l == null ? void 0 : l.button_text_color) ?? "#ffffff",
          text: (l == null ? void 0 : l.text_color) ?? "#ffffff"
        }
      };
      g.value = Zt.debug;
      const fe = {
        units: "decimal",
        faces: {
          enabled: l.machining_sides
        },
        holes: {
          enabled: l.machining_holes,
          defaultDiameter: l.machining_holes_default_diameter,
          diameters: l.machining_holes_diameters.split(",").map((Te) => Te.trim()).filter(Boolean),
          minDiameter: l.machining_holes_min_diameter,
          maxDiameter: l.machining_holes_max_diameter,
          enableDepth: l.machining_holes_depth,
          depths: l.machining_holes_depths.split(",").map((Te) => Te.trim()).filter(Boolean),
          defaultDepth: l.machining_holes_default_depth,
          minDepth: l.machining_holes_min_depth,
          maxDepth: l.machining_holes_max_depth
        },
        hingeHoles: {
          enabled: l.machining_hinge_holes,
          minimumHoleDistance: l.machining_hinge_holes_minimum_hole_distance,
          defaultDistanceFromEdge: l.machining_hinge_holes_default_distance_from_edge,
          defaultOuterSpacing: l.machining_hinge_holes_default_outer_spacing,
          defaultHingeLength: l.machining_hinge_holes_default_hinge_length
        },
        corners: {
          enabled: l.machining_radius_corners || l.machining_bevel_corners,
          types: [
            l.machining_radius_corners ? "radius" : null,
            l.machining_bevel_corners ? "bevel" : null
          ].filter(Boolean),
          minValue: l.machining_corners_min_value,
          maxValue: l.machining_corners_max_value,
          enableBanding: l.machining_corners_enable_banding
        }
      };
      A.value = vt(), A.value ? S(!0) : T(), u.type === "variable" ? N(!1, !1) : q(A.value);
      const ie = {
        type: u.type,
        stock: b.value,
        variations: d ?? null,
        options: Zt,
        banding: Ot,
        finish: re,
        machining: fe
      };
      ie.type === "variable" && (E(["setting variable product form listeners"]), jQuery(function(Te) {
        Te(".variations_form").on("reset_data", () => N(!1, !1)).on("found_variation", (_n, Fn) => oe(_n, Fn));
      }));
      const de = {
        product: u,
        selectedVariation: v,
        inputs: s,
        elements: r,
        inputType: y,
        formatPrice: ot,
        setInputValue: $,
        setCartQuantity: V,
        setVariationPrice: D,
        isExtraEnabled: St,
        isQuantityPricing: vt,
        isMachiningEnabled: ft,
        isSurchargeEnabled: Et,
        getTotalBandingPrice: Xt,
        getTotalFinishPrice: Yt,
        getTotalMachiningPrice: F,
        getInputValue: nt,
        enableAddToCart: x,
        log: E,
        error: M
      }, We = Wk({
        pricing_strategy: l.pricing_strategy,
        units: l.units,
        unit_system: l.unit_system,
        cut_length_price: l.cut_length_price,
        per_part_price: l.per_part_price,
        surcharge: l.surcharge,
        surcharge_type: l.surcharge_type,
        enable_offcut_pricing: l.enable_offcut_pricing,
        offcut_min_length: l.offcut_min_length,
        offcut_min_width: l.offcut_min_width
      }, de);
      o = We.calculatePrice, a = We.resetPricing, dr(() => {
        R.value && R.value.init(ie);
      });
    }, H = (Nt) => {
      const Ot = (Nt == null ? void 0 : Nt.multiple_sizes) === !0;
      u = {
        type: Nt == null ? void 0 : Nt.product_type,
        multiple_sizes: Ot,
        size: Nt != null && Nt.size ? Nt.size.split(" | ") : [],
        l: !Ot && (Nt != null && Nt.l) ? parseFloat(Nt.l) : null,
        w: !Ot && (Nt != null && Nt.w) ? parseFloat(Nt.w) : null,
        t: (Nt == null ? void 0 : Nt.t) ?? null,
        price: Nt != null && Nt.price ? parseFloat(Nt.price) : null,
        stock_name: (Nt == null ? void 0 : Nt.stock_sku) || Nt.stock_name
      }, u.multiple_sizes || (u.l || M("product 'length' attribute not available"), u.w || M("product 'width' attribute not available"));
    }, ct = (Nt) => {
      y.value = Rn(window, ["smartcutConfig", "settings", "enable_formula"]) === !0 ? "formula" : "manual", _.value = Rn(window, ["smartcutConfig", "settings", "formula_url"]), E([`Input type: ${y.value}`]), E([`Input type: ${y.value}`]), f = {
        thousands_separator: Nt == null ? void 0 : Nt.thousands_separator,
        decimal_separator: Nt == null ? void 0 : Nt.decimal_separator,
        number_of_decimals: Nt == null ? void 0 : Nt.number_of_decimals,
        currency_symbol: Nt == null ? void 0 : Nt.currency_symbol,
        currency_position: Nt == null ? void 0 : Nt.currency_position
      };
    }, it = () => {
      const Nt = {
        checkout: "#smartcut-app",
        intro_text: "#smartcut-intro-text",
        pricing_table: "#smartcut-pricing-table",
        offcuts: "#include_offcuts_field",
        banding_key: "#smartcut-banding-key",
        finish_key: "#smartcut-finish-key",
        banding_total_price: "#smartcut-banding-total bdi .smartcut-price-selector",
        finish_total_price: "#smartcut-finish-total bdi .smartcut-price-selector",
        cut_length_price: "#smartcut-cut-length-total bdi .smartcut-price-selector",
        per_part_price: "#smartcut-per-part-total bdi .smartcut-price-selector",
        part_area_price: "#smartcut-area-total bdi .smartcut-price-selector",
        offcut_area_price: "#smartcut-offcut-area-total bdi .smartcut-price-selector",
        roll_length_price: "#smartcut-roll-length-total bdi .smartcut-price-selector",
        surcharge_price: "#smartcut-surcharge-total bdi .smartcut-price-selector",
        machining_total_price: "#smartcut-machining-total bdi .smartcut-price-selector",
        stock_total_price: "#smartcut-stock-total bdi .smartcut-price-selector",
        quantity: ".smartcut-stock-quantity",
        //this is the add to cart quantity element(s)
        cart_button: ".single_add_to_cart_button"
      };
      for (const [Ot, re] of Object.entries(Nt))
        r[Ot] = document.querySelector(re);
      if (!r.checkout)
        return M("checkout iframe not found");
      if (!r.quantity)
        return M("quantity field not found");
      if (!r.cart_button)
        return M("cart button not found");
      r.quantity.readOnly = !0, X();
    }, P = () => ({
      x1: l.stock_trim_x1 ?? 0,
      x2: l.stock_trim_x2 ?? 0,
      y1: l.stock_type === "linear" ? 0 : l.stock_trim_y1 ?? 0,
      y2: l.stock_type === "linear" ? 0 : l.stock_trim_y2 ?? 0
    }), z = (Nt = null, Ot = null, re = null, Zt = null, fe = null) => {
      let ie;
      if (fe && typeof fe == "object") {
        ie = [];
        for (const [We, Te] of Object.entries(fe))
          We !== "attribute_size" && We !== "attribute_thickness" && ie.push(`${We.replace("attribute_", "")}: ${Te}`);
        ie = ie.join(" - ");
      }
      return {
        name: u.stock_name,
        type: l.stock_type,
        l: Nt,
        w: Ot,
        t: re,
        grain: l.stock_grain,
        cost: parseFloat((Zt == null ? void 0 : Zt.toString()) || "0"),
        trim: P(),
        allowExactFitShapes: !0,
        notes: ie
      };
    }, G = () => {
      u != null && u.stock_name || M("product name not specified"), b.value = [], u.multiple_sizes ? u.size.forEach((Nt) => {
        const [Ot, re] = Nt.split("x"), Zt = z(
          parseFloat(Ot),
          parseFloat(re),
          u == null ? void 0 : u.t,
          u.price
        );
        b.value.push(Zt);
      }) : b.value.push(z(
        u.l,
        u.w,
        u == null ? void 0 : u.t,
        u == null ? void 0 : u.price
      ));
    }, Y = (Nt, Ot) => {
      const re = Nt.split(".");
      return re[0] = re[0].replace(/\B(?=(\d{3})+(?!\d))/g, Ot), re.join(".");
    }, ot = (Nt = 0, Ot = "") => {
      if (!Nt)
        return Ot ? gt("0.00") : "0.00";
      typeof Nt == "string" && (Nt = parseFloat(Nt));
      const re = Nt.toFixed(f.number_of_decimals).replace(".", f.decimal_separator), Zt = Y(re, f.thousands_separator);
      return Ot ? gt(Zt) : Zt;
    }, xt = (Nt) => {
      if (Nt == null) return "";
      typeof Nt == "string" && (Nt = parseFloat(Nt));
      const re = Nt % 1 !== 0 ? f.number_of_decimals : 0, Zt = Nt.toFixed(re).replace(".", f.decimal_separator);
      return Y(Zt, f.thousands_separator);
    }, gt = (Nt) => {
      switch (f.currency_position) {
        case "left":
          return `${f.currency_symbol}${Nt}`;
        case "right":
          return `${Nt}${f.currency_symbol}`;
        default:
          return `${f.currency_symbol}${Nt}`;
      }
    }, wt = (Nt) => {
      const Ot = (re) => b1(Ul(re), 100).replace("|", "_");
      return Array.isArray(Nt) ? Nt.map(Ot).join(",") : Ot(Nt);
    }, qt = (Nt) => {
      if (!Nt) return null;
      const Ot = {
        labels: [],
        pricing: {}
      }, re = Object.values(Nt);
      for (const Zt of re)
        Zt != null && Zt.variations ? (Ot.labels.push(...Object.keys(Zt.options)), Object.values(Zt.variations).forEach((fe) => {
          const { options: ie } = fe, de = Object.values(ie).map((We) => wt(We)).join("|");
          Ot.pricing[de] = parseInt(fe.price);
        })) : Zt != null && Zt.options && Object.keys(Zt.options).forEach((fe) => {
          Ot.pricing[wt(fe)] = parseInt(Zt.price);
        });
      return Ot.labels.length || Ot.labels.push("type"), Ot;
    }, Dt = (Nt, Ot) => {
      if (!Ot.length || !ac(h, [Nt])) return null;
      const re = Rn(h, [Nt]);
      if (!No(re)) return null;
      const fe = Object.values(re).map((ie) => ie != null && ie.variations ? Object.values(ie.variations).map((de) => (de.type = "variable", de)) : (ie.type = "simple", ie)).flat().find((ie) => {
        let de;
        return ie.type === "simple" ? de = Object.keys(ie.options) : de = Object.values(ie.options), de ? de.every((We, Te) => wt(We) === wt(Ot[Te])) : !1;
      });
      return fe != null && fe.price ? parseFloat(fe.price) : null;
    }, Yt = (Nt) => {
      let Ot = 0;
      if (typeof Nt == "object") {
        for (let [re, Zt] of Object.entries(Nt)) {
          typeof Zt == "string" && (Zt = parseFloat(Zt));
          const fe = re.split("|"), ie = Dt("finish", fe);
          if (ie === null) continue;
          const We = Number(Zt) / 1e6 * parseFloat(ie.toString());
          Ot += We;
        }
        if ("min_finish_charge" in l) {
          const re = parseFloat(l == null ? void 0 : l.min_finish_charge);
          if (re > 0 && Ot > 0 && Ot < re)
            return re;
        }
      }
      return Ot;
    }, Xt = (Nt) => {
      let Ot = 0;
      if (typeof Nt == "object") {
        for (let [re, Zt] of Object.entries(Nt)) {
          typeof Zt == "string" && (Zt = parseFloat(Zt));
          const fe = re.split("|"), ie = Dt("banding", fe);
          if (ie === null) continue;
          const de = Zt / (l.unit_system === "imperial" ? 12 : 1e3) * parseFloat(ie.toString());
          Ot += de;
        }
        if ("min_banding_charge" in l) {
          const re = parseFloat(l == null ? void 0 : l.min_banding_charge);
          if (re > 0 && Ot > 0 && Ot < re)
            return re;
        }
      }
      return Ot;
    }, F = (Nt) => (p.holes ?? 0) * (Nt.metadata.numHoles ?? 0) + (p.corners ?? 0) * (Nt.metadata.numCorners ?? 0), ht = (Nt, Ot) => {
      var re;
      Nt in r && ((re = r[Nt]) != null && re.style) && (r[Nt].style.display = Ot);
    }, $ = (Nt, Ot) => {
      J(Nt) ? s[Nt].value = Ot : M(`Attempting to set input but key '${Nt}' does not exist`);
    }, nt = (Nt) => {
      if (J(Nt))
        return s[Nt].value;
      M(`Attempting to get input but key '${Nt}' does not exist`);
    }, J = (Nt) => Nt in s && s[Nt] instanceof HTMLInputElement, st = () => {
      V(1), X(), $("smartcut-cut-to-size-surcharge", 0), a();
      for (const Nt in s)
        Nt !== "smartcut-hardware-price" && $(Nt, null);
    }, vt = () => {
      var Nt;
      if (((Nt = window.smartcutConfig) == null ? void 0 : Nt.product_type) === "variable")
        return !1;
      switch (l.pricing_strategy) {
        case "full_stock":
        case "part_area":
        case "full_stock_plus_cut_length":
        case "full_stock_plus_num_parts":
          return !0;
        case "roll_length":
        case "cut_length":
          return !1;
        default:
          return !1;
      }
    }, St = (Nt) => {
      if (ac(l, ["enable", Nt]) && Rn(l, ["enable", Nt]) === !1)
        return !1;
      const Ot = Rn(h, [Nt]);
      return !!(Ot && Object.values(Ot).length);
    }, ft = () => l.enable_machining === !0, Et = () => !((l == null ? void 0 : l.surcharge_type) === "none" || !(l != null && l.surcharge) || l.surcharge === "0.00"), zt = () => !!(l.pricing_strategy === "full_stock_plus_cut_length" || l.pricing_strategy === "full_stock_plus_num_parts" || l.pricing_strategy === "part_area" || l.pricing_strategy === "roll_length" || Et() || St("banding") || St("finish") || ft()), Tt = (Nt) => {
      var re;
      let Ot = (re = Nt == null ? void 0 : Nt.attributes) == null ? void 0 : re.attribute_size;
      return Ot || (Ot = u == null ? void 0 : u.size), Ot;
    }, $t = (Nt) => /\d+x\d+/.test(Nt), ee = () => {
      window.smartcutConfig.input_fields.forEach((Nt) => {
        const Ot = Nt.replaceAll("_", "-");
        s[Ot] = document.getElementById(Ot);
      });
    }, oe = (Nt, Ot) => {
      st(), v.value = Ot, E(["variation selected", Ot.attributes]), b.value = [];
      const re = Rn(Ot, ["attributes", "attribute_thickness"]);
      if (u.selected_thickness = re, u.multiple_sizes) {
        const Zt = Tt(Ot);
        if (E([`variation found with size: ${Zt} & thickness: ${re}`]), !Zt)
          return N(!1), M("The size of this multiple size product could not be found");
        if (Array.isArray(Zt) ? q(A.value) : $t(Zt) ? N(!0, !0) : q(A.value), d != null && d.length && re) {
          let fe;
          Array.isArray(Zt) ? fe = Zt.map((ie) => ({
            size: ie,
            l: ie.split("x")[0],
            w: ie.split("x")[1],
            t: re,
            price: Ot.display_price
          })) : fe = d.filter((ie) => {
            var de, We;
            return /\d+x\d+/.test((de = ie == null ? void 0 : ie.attributes) == null ? void 0 : de.size) ? re === ((We = ie == null ? void 0 : ie.attributes) == null ? void 0 : We.thickness) : !1;
          }).map((ie) => {
            var de, We, Te, _n;
            return E([
              `size attribute: '${(de = ie == null ? void 0 : ie.attributes) == null ? void 0 : de.size}'`,
              `price for 'thickness ${re}, size: ${Zt}' is ${Ot.display_price}`
            ]), {
              size: (We = ie == null ? void 0 : ie.attributes) == null ? void 0 : We.size,
              l: (Te = ie == null ? void 0 : ie.attributes) == null ? void 0 : Te.size.split("x")[0],
              w: (_n = ie == null ? void 0 : ie.attributes) == null ? void 0 : _n.size.split("x")[1],
              t: u.selected_thickness,
              price: Ot.display_price
            };
          }), O.value === !0 && fe.forEach((ie) => {
            const de = z(
              ie.l,
              ie.w,
              ie.t,
              ie.price,
              Ot == null ? void 0 : Ot.attributes
            );
            b.value.push(de);
          });
        }
      } else {
        const Zt = d.find((fe) => fe.attributes.thickness === re);
        if (!Zt) return M(`variation not found for thickness ${re}`);
        b.value.push(z(
          u.l,
          u.w,
          re,
          Zt.price,
          Ot == null ? void 0 : Ot.attributes
        )), q(A.value);
      }
    }, ae = async (Nt) => {
      st(), E(["result event received", Nt]);
      const Ot = await o(Nt);
      if (!Ot.success) {
        console.error(Ot.error);
        return;
      }
      await we(Nt);
    }, we = async (Nt) => {
      const re = nw(Nt, L.value, xt).split(",")[1], Zt = new Gk();
      Zt.file("order-summary.pdf", re);
      const fe = await Zt.generateAsync({ type: "blob" }), ie = new File([fe], "order-summary.zip", { type: "application/zip" });
      if (!J("smartcut-order-summary")) return;
      const de = s["smartcut-order-summary"].closest("form");
      if (!de) return;
      const We = new DataTransfer();
      We.items.add(ie);
      const Te = de.querySelector('[name="smartcut_order_summary"]');
      Te instanceof HTMLInputElement && (Te.files = We.files);
    }, Jt = (Nt, Ot) => {
      X(), L.value = gl(Nt), $("smartcut-hardware-price", Ot);
    };
    return Us(() => {
      console.log("💥 Powered by https://smartcut.dev", window.smartcutConfig.version), E(["Launching WordPress checkout..."]), h.banding = Rn(window, ["smartcutConfig", "banding_data"]), h.finish = Rn(window, ["smartcutConfig", "finish_data"]), p = Rn(window, ["smartcutConfig", "machining_pricing"]), d = Rn(window, ["smartcutConfig", "variations"]), it(), ee(), H(window.smartcutConfig), ct(window.smartcutConfig), tt(), G(), [
        "div.quantity > input.plus",
        "div.quantity > input.minus",
        "div.quantity .qty-plus",
        "div.quantity .qty-minus"
      ].forEach((re) => {
        const Zt = document.querySelector(re);
        Zt && (Zt.style.display = "none");
      });
      const Ot = new CustomEvent("smartcut/ready");
      window.dispatchEvent(Ot), E(["Wordpress checkout ready"]);
    }), (Nt, Ot) => (Qt(), le(Qn, null, [
      Oe(i) === "development" && Yk ? (Qt(), le("div", Vk, [
        Ot[0] || (Ot[0] = ye("div", null, "WP - developer information", -1)),
        Zn(Oe(e), {
          data: [Oe(u)],
          paths: ["product"]
        }, null, 8, ["data"])
      ])) : ke("", !0),
      y.value === "formula" && _.value ? (Qt(), Un(Oe(t), {
        key: 1,
        ref: "formulapricing",
        units: C.value,
        "format-price": ot,
        url: _.value,
        debug: g.value,
        onHardwareResult: Jt,
        onPanelResult: X
      }, null, 8, ["units", "url", "debug"])) : ke("", !0),
      y.value === "manual" || y.value === "formula" && _.value ? (Qt(), Un($k, {
        key: 2,
        ref_key: "calculator",
        ref: R,
        readonly: y.value === "formula",
        debug: g.value,
        stock: b.value,
        "find-extras-price": Dt,
        "format-price": ot,
        units: C.value,
        onLog: E,
        onError: M,
        onResult: ae,
        onInputsChanged: X
      }, null, 8, ["readonly", "debug", "stock", "units"])) : ke("", !0)
    ], 64));
  }
}), Xk = {
  key: 1,
  class: "error-message"
}, Jk = /* @__PURE__ */ Rr({
  __name: "Launch",
  props: {
    type: { default: "" }
  },
  setup(n, { expose: t }) {
    const e = po(() => import("./Vanilla-C-2oLcyI.js").catch((o) => {
      throw console.error("Failed to load Vanilla component:", o), new Error("Failed to load Vanilla component");
    })), i = {
      wordpress: Kk,
      vanilla: e
    }, r = n, s = Re(() => {
      if (!r.type) return null;
      const o = r.type.toLowerCase();
      return i[o] || null;
    });
    return t({
      componentType: Re(() => r.type)
    }), (o, a) => s.value ? (Qt(), Un(M2(s.value), {
      key: 0,
      ref: "checkout"
    }, null, 512)) : (Qt(), le("div", Xk, " Invalid component type: " + hn(r.type), 1));
  }
}), Zk = /* @__PURE__ */ Ia(Jk, [["__scopeId", "data-v-7957d240"]]), rA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: Zk }, Symbol.toStringTag, { value: "Module" }));
export {
  $k as C,
  rA as L,
  wl as _,
  Ia as a,
  uo as b,
  ac as c,
  nn as d,
  Tc as e,
  De as f,
  Rn as g,
  te as h,
  mr as i,
  d1 as j,
  nA as k,
  h1 as l,
  iA as m,
  Yg as n,
  f6 as o,
  Ky as p,
  Mm as r,
  Dm as s,
  of as u,
  jt as v
};
