var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var _a;
import { i as i18n, u as unref, o as onMounted, n as nextTick$1, r as ref, a as readonly, w as watch, g as getCurrentScope, b as onScopeDispose, c as getCurrentInstance, s as shallowRef, d as isRef, e as isReactive, f as reactive, m as markRaw, h as isProxy, j as openBlock, k as createElementBlock, F as Fragment, l as renderList, p as normalizeClass, q as normalizeStyle, t as createBaseVNode, v as toDisplayString, x as withDirectives, y as vShow, z as createStaticVNode, A as createCommentVNode, B as defineComponent, C as computed, D as onUnmounted, E as useI18n, G as resolveComponent, H as createBlock, I as createVNode, J as createTextVNode, K as defineAsyncComponent, L as provide, M as resolveDynamicComponent } from "./main-BuWv0poc.js";
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
const TOLERANCE = 1e-10;
const DECIMAL_PLACES = 10;
const MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER;
const UINT32_MAX = 4294967295;
const isNumber = (value2) => typeof value2 === "number" && Number.isFinite(value2);
const isValidArray = (arr) => Array.isArray(arr) && arr.length > 0;
function compare(a2, b2, tolerance = TOLERANCE) {
  if (a2 === b2) return 0;
  if (Number.isInteger(a2) && Number.isInteger(b2)) {
    return a2 > b2 ? 1 : -1;
  }
  const diff = a2 - b2;
  return Math.abs(diff) < tolerance ? 0 : diff;
}
const mathOps = {
  greaterThan: (a2, b2, tolerance = TOLERANCE) => {
    if (!isNumber(a2) || !isNumber(b2)) return false;
    return compare(a2, b2, tolerance) > 0;
  },
  greaterThanOrEqualTo: (a2, b2, tolerance = TOLERANCE) => {
    if (!isNumber(a2) || !isNumber(b2)) return false;
    return compare(a2, b2, tolerance) >= 0;
  },
  lessThan: (a2, b2, tolerance = TOLERANCE) => {
    if (!isNumber(a2) || !isNumber(b2)) return false;
    return compare(a2, b2, tolerance) < 0;
  },
  lessThanOrEqualTo: (a2, b2, tolerance = TOLERANCE) => {
    if (!isNumber(a2) || !isNumber(b2)) return false;
    return compare(a2, b2, tolerance) <= 0;
  },
  equalTo: (a2, b2, tolerance = TOLERANCE) => {
    if (!isNumber(a2) || !isNumber(b2)) return false;
    return compare(a2, b2, tolerance) === 0;
  }
};
function round(number2) {
  if (!isNumber(number2)) return false;
  if (Number.isInteger(number2)) return number2;
  return Number(number2.toFixed(DECIMAL_PLACES));
}
function getRandom(length) {
  if (!isNumber(length) || length < 0 || length > MAX_SAFE_INTEGER$3) {
    throw new Error("Invalid length parameter");
  }
  return Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / (UINT32_MAX + 1) * length);
}
function getRandomSample(array2, size) {
  if (!isValidArray(array2)) {
    throw new Error("Invalid array parameter");
  }
  if (!isNumber(size) || size < 0 || size > array2.length) {
    throw new Error("Invalid size parameter");
  }
  const shuffled = array2.slice();
  const min2 = array2.length - size;
  for (let i2 = array2.length - 1; i2 >= min2; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    [shuffled[i2], shuffled[j2]] = [shuffled[j2], shuffled[i2]];
  }
  return shuffled.slice(min2);
}
class Statistics {
  static calculateMean(numbers) {
    if (!isValidArray(numbers)) {
      throw new Error("Invalid input array");
    }
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }
  static calculateStandardDeviation(numbers, mean = null) {
    if (!isValidArray(numbers)) {
      throw new Error("Invalid input array");
    }
    const calculatedMean = mean ?? this.calculateMean(numbers);
    const variance = numbers.reduce((sum, num) => {
      const diff = num - calculatedMean;
      return sum + diff * diff;
    }, 0) / numbers.length;
    return Math.sqrt(variance);
  }
  static calculateCoefficientOfVariation(numbers) {
    if (!isValidArray(numbers)) {
      throw new Error("Invalid input array");
    }
    const mean = this.calculateMean(numbers);
    if (mean === 0) {
      throw new Error("Mean is zero, coefficient of variation undefined");
    }
    const sd = this.calculateStandardDeviation(numbers, mean);
    return sd / mean;
  }
}
const maths = {
  ...mathOps,
  isNumber,
  round,
  getRandom,
  getRandomSample,
  calculateStandardDeviation: Statistics.calculateStandardDeviation.bind(Statistics),
  calculateCoefficientOfVariation: Statistics.calculateCoefficientOfVariation.bind(Statistics)
};
const sort = {
  //sort by width then length - use .sort(sortHeightDescWidthDesc)
  WDLD(a2, b2) {
    if (a2.w < b2.w) return 1;
    if (a2.w > b2.w) return -1;
    if (a2.l === b2.l) return 0;
    if (a2.l < b2.l) return 1;
    if (a2.l > b2.l) return -1;
  },
  WALA(a2, b2) {
    if (a2.w > b2.w) return 1;
    if (a2.w < b2.w) return -1;
    if (a2.l === b2.l) return 0;
    if (a2.l > b2.l) return 1;
    if (a2.l < b2.l) return -1;
  },
  //sort by length d then width d
  LDWD(a2, b2) {
    if (a2.l < b2.l) return 1;
    if (a2.l > b2.l) return -1;
    if (a2.w === b2.w) return 0;
    if (a2.w < b2.w) return 1;
    if (a2.w > b2.w) return -1;
  },
  LAWA(a2, b2) {
    if (a2.l > b2.l) return 1;
    if (a2.l < b2.l) return -1;
    if (a2.w === b2.w) return 0;
    if (a2.w > b2.w) return 1;
    if (a2.w < b2.w) return -1;
  },
  //sort by width d
  WD(a2, b2) {
    if (a2.w < b2.w) return 1;
    if (a2.w > b2.w) return -1;
    if (a2.w === b2.w) return 0;
  },
  LD(a2, b2) {
    if (a2.l < b2.l) return 1;
    if (a2.l > b2.l) return -1;
    if (a2.l === b2.l) return 0;
  },
  LDIDA(a2, b2) {
    if (a2.l < b2.l) return 1;
    if (a2.l > b2.l) return -1;
    const aID = a2.id.toString().split(".");
    const bID = b2.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    } else {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
  },
  WDIDA(a2, b2) {
    if (a2.w < b2.w) return 1;
    if (a2.w > b2.w) return -1;
    const aID = a2.id.toString().split(".");
    const bID = b2.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    } else {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
  },
  //sort by proportion
  /* sortProportion: function(a, b) {
  
  		if (a.proportion < b.proportion) return 1;
  		if (a.proportion > b.proportion) return -1;
  
  		if (a.proportion === b.proportion) return a.index - b.index;
  
  	} */
  //area descending
  AD(a2, b2) {
    const aArea = a2.getArea();
    const bArea = b2.getArea();
    if (aArea < bArea) return 1;
    if (aArea > bArea) return -1;
    if (aArea === bArea) return 0;
  },
  AA(a2, b2) {
    const aArea = a2.getArea();
    const bArea = b2.getArea();
    if (aArea < bArea) return -1;
    if (aArea > bArea) return 1;
    if (aArea === bArea) return 0;
  },
  AAID(a2, b2) {
    const aArea = a2.getArea();
    const bArea = b2.getArea();
    if (aArea < bArea) return -1;
    if (aArea > bArea) return 1;
    if (aArea === bArea) {
      const aID = a2.id.toString().split(".");
      const bID = b2.id.toString().split(".");
      if (aID[0] !== bID[0]) {
        return parseInt(aID[0]) - parseInt(bID[0]);
      }
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    return 0;
  },
  ADID(a2, b2) {
    const aArea = a2.getArea();
    const bArea = b2.getArea();
    if (aArea < bArea) return 1;
    if (aArea > bArea) return -1;
    if (aArea === bArea) return 0;
    if (aArea === bArea) {
      const aID = a2.id.toString().split(".");
      const bID = b2.id.toString().split(".");
      if (aID[0] !== bID[0]) {
        return parseInt(aID[0]) - parseInt(bID[0]);
      }
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    return 0;
  },
  //by id ascending
  ID(a2, b2) {
    if (!a2.id || !b2.id) return 0;
    const aID = a2.id.toString().split(".");
    const bID = b2.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    return parseInt(aID[1]) - parseInt(bID[1]);
  },
  IDDesc(a2, b2) {
    const aID = a2.id.toString().split(".");
    const bID = b2.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(bID[0]) - parseInt(aID[0]);
    }
    return parseInt(bID[1]) - parseInt(aID[1]);
  },
  StockID(a2, b2) {
    const aID = a2.stock.id.toString().split(".");
    const bID = b2.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    return parseInt(aID[1]) - parseInt(bID[1]);
  },
  StockIDAD(a2, b2) {
    const aID = a2.stock.id.toString().split(".");
    const bID = b2.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    } else if (aID[1] !== bID[1]) {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    const aArea = a2.getArea();
    const bArea = b2.getArea();
    if (aArea < bArea) return 1;
    if (aArea > bArea) return -1;
  },
  parentID(a2, b2) {
    return a2.parentID - b2.parentID;
  },
  YX(a2, b2) {
    if (a2.y < b2.y) return -1;
    if (a2.y > b2.y) return 1;
    if (a2.y === b2.y) return 0;
    if (a2.x < b2.x) return -1;
    if (a2.x > b2.x) return 1;
  },
  XY(a2, b2) {
    if (a2.x < b2.x) return -1;
    if (a2.x > b2.x) return 1;
    if (a2.x === b2.x) return 0;
    if (a2.y < b2.y) return -1;
    if (a2.y > b2.y) return 1;
  },
  subset(a2, b2) {
    if (a2.totalLength < b2.totalLength) return 1;
    if (a2.totalLength > b2.totalLength) return -1;
    if (a2.area === b2.area) return 0;
    if (a2.area < b2.area) return 1;
    if (a2.area > b2.area) return -1;
  },
  placementOrder(a2, b2) {
    return (a2 == null ? void 0 : a2.placementOrder) - (b2 == null ? void 0 : b2.placementOrder);
  },
  typePlacementOrder(a2, b2) {
    if (a2.offcut && !b2.offcut) return 1;
    else if (!a2.offcut && b2.offcut) return 0;
    if (a2.offcut === b2.offcut) return a2.placementOrder - b2.placementOrder;
  },
  stockIDTypePlacementOrder(a2, b2) {
    const aID = a2.stock.id.toString().split(".");
    const bID = b2.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    if (aID[1] !== bID[1]) {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    if (a2.offcut && !b2.offcut) return 1;
    else if (!a2.offcut && b2.offcut) return 0;
    if (a2.offcut === b2.offcut) return a2.placementOrder - b2.placementOrder;
  },
  offcutPlacementOrder(a2, b2) {
    var _a3, _b2;
    if (!((_a3 = a2 == null ? void 0 : a2.stock) == null ? void 0 : _a3.id) || !((_b2 = b2 == null ? void 0 : b2.stock) == null ? void 0 : _b2.id)) return 0;
    const aID = a2.stock.id.toString().split(".");
    const bID = b2.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    if (aID[1] !== bID[1]) {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    return (a2 == null ? void 0 : a2.placementOrder) - (b2 == null ? void 0 : b2.placementOrder);
  },
  groupPlacementOrder(a2, b2) {
    if (a2.placementOrder > b2.placementOrder) return 1;
    if (a2.placementOrder < b2.placementOrder) return -1;
    if (a2.groupPlacementOrder === b2.groupPlacementOrder) return 0;
    if (a2.groupPlacementOrder > b2.groupPlacementOrder) return 1;
    if (a2.groupPlacementOrder < b2.groupPlacementOrder) return -1;
  },
  swapFirstTwo(array2) {
    const second = array2[1];
    array2[1] = array2[0];
    array2[0] = second;
  },
  //Fisher-Yates shuffle
  shuffle(array2) {
    for (let i2 = array2.length - 1; i2 > 0; i2--) {
      const j2 = Math.floor(Math.random() * (i2 + 1));
      [array2[i2], array2[j2]] = [array2[j2], array2[i2]];
    }
  },
  /**
      * generator function which accepts a dimension to cater for shape rotation lock
      */
  fillThenArea(dimension) {
    return function(a2, b2) {
      if (a2.getLongSide(dimension) > b2.getLongSide(dimension)) return -1;
      else if (a2.getLongSide(dimension) < b2.getLongSide(dimension))
        return 1;
      if (a2.getArea() > b2.getArea()) return -1;
      if (a2.getArea() < b2.getArea()) return 1;
      return 0;
    };
  },
  aspect(a2, b2) {
    const aAspect = a2.getAspect();
    const bAspect = b2.getAspect();
    if (aAspect > bAspect) return -1;
    if (aAspect < bAspect) return 1;
    return 0;
  }
};
function getAxisFromDimension(dimension) {
  if (dimension === "l") return "x";
  if (dimension === "w") return "y";
}
function getReverseDimension(dimension) {
  if (!dimension) return null;
  return dimension === "l" ? "w" : "l";
}
function getReverseAxis(axis2) {
  if (!axis2) return null;
  return axis2 === "x" ? "y" : "x";
}
class Line {
  constructor(data) {
    __publicField(this, "x1");
    __publicField(this, "x2");
    __publicField(this, "y1");
    __publicField(this, "y2");
    __publicField(this, "dimension");
    __publicField(this, "direction");
    __publicField(this, "shapeCollisions");
    __publicField(this, "origin");
    __publicField(this, "type");
    this.x1 = data.x1;
    this.x2 = data.x2;
    this.y1 = data.y1;
    this.y2 = data.y2;
    this.dimension = getLineDimension(this);
    this.direction = getLineDirection(this);
    this.type = (data == null ? void 0 : data.type) ? data.type : null;
    this.origin = (data == null ? void 0 : data.origin) ? data.origin : null;
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
}
function createLine(x1, y1, x2, y2, origin = null, type3 = null) {
  return new Line({ x1, y1, x2, y2, origin, type: type3 });
}
function getLineDimension(line) {
  if (typeof line === "undefined") return null;
  if (!maths.isNumber(line.x1) || !maths.isNumber(line.x2) || !maths.isNumber(line.y1) || !maths.isNumber(line.y2)) {
    return null;
  }
  if (line.x1 === line.x2 && line.y1 !== line.y2) return "w";
  else if (line.y1 === line.y2 && line.x1 !== line.x2) return "l";
  else return null;
}
function getLineDirection(line) {
  if (typeof line === "undefined") return null;
  if (!maths.isNumber(line.x1) || !maths.isNumber(line.x2) || !maths.isNumber(line.y1) || !maths.isNumber(line.y2)) {
    return null;
  }
  if (line.x1 < line.x2) return "lr";
  else if (line.x1 > line.x2) return "rl";
  else if (line.y1 < line.y2) return "bt";
  else if (line.y1 > line.y2) return "tb";
  else return null;
}
function rayCastRectangle(rectangle, container) {
  const points = rectangle.getCorners();
  const lines = {};
  if (points.bottomLeft.x > 0 && points.bottomLeft.y > 0) {
    lines.bottomLeftDown = createLine(
      points.bottomLeft.x,
      points.bottomLeft.y,
      points.bottomLeft.x,
      0,
      "bottomLeft",
      "bottomLeftDown"
    );
    lines.bottomLeftLeft = createLine(
      points.bottomLeft.x,
      points.bottomLeft.y,
      0,
      points.bottomLeft.y,
      "bottomLeft",
      "bottomLeftLeft"
    );
  }
  if (points.topLeft.x > 0 && points.topLeft.y < container.w) {
    lines.topLeftLeft = createLine(
      points.topLeft.x,
      points.topLeft.y,
      0,
      points.topLeft.y,
      "topLeft",
      "topLeftLeft"
    );
    lines.topLeftTop = createLine(
      points.topLeft.x,
      points.topLeft.y,
      points.topLeft.x,
      container.w,
      "topLeft",
      "topLeftTop"
    );
  }
  if (points.topRight.y < container.w && points.topRight.x < container.l) {
    lines.topRightTop = createLine(
      points.topRight.x,
      points.topRight.y,
      points.topRight.x,
      container.w,
      "topRight",
      "topRightTop"
    );
    lines.topRightRight = createLine(
      points.topRight.x,
      points.topRight.y,
      container.l,
      points.topRight.y,
      "topRight",
      "topRightRight"
    );
  }
  if (points.bottomRight.x < container.l && points.bottomRight.y > 0) {
    lines.bottomRightRight = createLine(
      points.bottomRight.x,
      points.bottomRight.y,
      container.l,
      points.bottomRight.y,
      "bottomRight",
      "bottomRightRight"
    );
    lines.bottomRightDown = createLine(
      points.bottomRight.x,
      points.bottomRight.y,
      points.bottomRight.x,
      0,
      "bottomRight",
      "bottomRightDown"
    );
  }
  return lines;
}
var __defProp2 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value2) => __defProp2(target, "name", { value: value2, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var require_util = __commonJS({
  "(disabled):util"() {
  }
});
var utils_exports = {};
__export(utils_exports, {
  addChainableMethod: () => addChainableMethod,
  addLengthGuard: () => addLengthGuard,
  addMethod: () => addMethod,
  addProperty: () => addProperty,
  checkError: () => check_error_exports,
  compareByInspect: () => compareByInspect,
  eql: () => deep_eql_default,
  expectTypes: () => expectTypes,
  flag: () => flag,
  getActual: () => getActual,
  getMessage: () => getMessage2,
  getName: () => getName,
  getOperator: () => getOperator,
  getOwnEnumerableProperties: () => getOwnEnumerableProperties,
  getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
  getPathInfo: () => getPathInfo,
  hasProperty: () => hasProperty,
  inspect: () => inspect2,
  isNaN: () => isNaN2,
  isNumeric: () => isNumeric,
  isProxyEnabled: () => isProxyEnabled,
  isRegExp: () => isRegExp2,
  objDisplay: () => objDisplay,
  overwriteChainableMethod: () => overwriteChainableMethod,
  overwriteMethod: () => overwriteMethod,
  overwriteProperty: () => overwriteProperty,
  proxify: () => proxify,
  test: () => test$1,
  transferFlags: () => transferFlags,
  type: () => type
});
var check_error_exports = {};
__export(check_error_exports, {
  compatibleConstructor: () => compatibleConstructor,
  compatibleInstance: () => compatibleInstance,
  compatibleMessage: () => compatibleMessage,
  getConstructorName: () => getConstructorName,
  getMessage: () => getMessage
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  if (isErrorInstance(errorLike)) {
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if ((typeof errorLike === "object" || typeof errorLike === "function") && errorLike.prototype) {
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }
  return false;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  const comparisonString = typeof thrown === "string" ? thrown : thrown.message;
  if (isRegExp(errMatcher)) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === "string") {
    return comparisonString.indexOf(errMatcher) !== -1;
  }
  return false;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName(errorLike) {
  let constructorName = errorLike;
  if (isErrorInstance(errorLike)) {
    constructorName = errorLike.constructor.name;
  } else if (typeof errorLike === "function") {
    constructorName = errorLike.name;
    if (constructorName === "") {
      const newConstructorName = new errorLike().name;
      constructorName = newConstructorName || constructorName;
    }
  }
  return constructorName;
}
__name(getConstructorName, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === "string") {
    msg = errorLike;
  }
  return msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value2) {
  var flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value2;
  } else {
    return flags[key];
  }
}
__name(flag, "flag");
function test$1(obj, args) {
  var negate = flag(obj, "negate"), expr = args[0];
  return negate ? !expr : expr;
}
__name(test$1, "test");
function type(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  const stringTag2 = obj[Symbol.toStringTag];
  if (typeof stringTag2 === "string") {
    return stringTag2;
  }
  const type3 = Object.prototype.toString.call(obj).slice(8, -1);
  return type3;
}
__name(type, "type");
var canElideFrames = "captureStackTrace" in Error;
var AssertionError = (_a = class extends Error {
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message);
    __publicField(this, "message");
    this.message = message;
    if (canElideFrames) {
      Error.captureStackTrace(this, ssf || _a);
    }
    for (const key in props) {
      if (!(key in this)) {
        this[key] = props[key];
      }
    }
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return false;
  }
  toJSON(stack) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: false,
      stack: stack !== false ? this.stack : void 0
    };
  }
}, __name(_a, "AssertionError"), _a);
function expectTypes(obj, types) {
  var flagMsg = flag(obj, "message");
  var ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  obj = flag(obj, "object");
  types = types.map(function(t2) {
    return t2.toLowerCase();
  });
  types.sort();
  var str = types.map(function(t2, index) {
    var art = ~["a", "e", "i", "o", "u"].indexOf(t2.charAt(0)) ? "an" : "a";
    var or = types.length > 1 && index === types.length - 1 ? "or " : "";
    return or + art + " " + t2;
  }).join(", ");
  var objType = type(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  })) {
    throw new AssertionError(
      flagMsg + "object tested must be " + str + ", but " + objType + " given",
      void 0,
      ssfi
    );
  }
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles$1 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "…";
function colorise(value2, styleType) {
  const color2 = ansiColors[styles$1[styleType]] || ansiColors[styleType] || "";
  if (!color2) {
    return String(value2);
  }
  return `\x1B[${color2[0]}m${String(value2)}\x1B[${color2[1]}m`;
}
__name(colorise, "colorise");
function normaliseOptions({
  showHidden = false,
  depth = 2,
  colors = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = Infinity,
  breakLength = Infinity,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate2 = Infinity,
  stylize = String
} = {}, inspect3) {
  const options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate2),
    seen,
    inspect: inspect3,
    stylize
  };
  if (options.colors) {
    options.stylize = colorise;
  }
  return options;
}
__name(normaliseOptions, "normaliseOptions");
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate, "isHighSurrogate");
function truncate(string2, length, tail = truncator) {
  string2 = String(string2);
  const tailLength = tail.length;
  const stringLength = string2.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    if (end > 0 && isHighSurrogate(string2[end - 1])) {
      end = end - 1;
    }
    return `${string2.slice(0, end)}${tail}`;
  }
  return string2;
}
__name(truncate, "truncate");
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  const size = list.length;
  if (size === 0)
    return "";
  const originalLength = options.truncate;
  let output = "";
  let peek = "";
  let truncated = "";
  for (let i2 = 0; i2 < size; i2 += 1) {
    const last = i2 + 1 === list.length;
    const secondToLast = i2 + 2 === list.length;
    truncated = `${truncator}(${list.length - i2})`;
    const value2 = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    const string2 = peek || inspectItem(value2, options) + (last ? "" : separator);
    const nextLength = output.length + string2.length;
    const truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string2;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList, "inspectList");
function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey, "quoteComplexKey");
function inspectProperty([key, value2], options) {
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = `[${options.inspect(key, options)}]`;
  }
  options.truncate -= key.length;
  value2 = options.inspect(value2, options);
  return `${key}: ${value2}`;
}
__name(inspectProperty, "inspectProperty");
function inspectArray(array2, options) {
  const nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  const listContents = inspectList(array2, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty);
  }
  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray, "inspectArray");
var getArrayName = /* @__PURE__ */ __name((array2) => {
  if (typeof Buffer === "function" && array2 instanceof Buffer) {
    return "Buffer";
  }
  if (array2[Symbol.toStringTag]) {
    return array2[Symbol.toStringTag];
  }
  return array2.constructor.name;
}, "getArrayName");
function inspectTypedArray(array2, options) {
  const name = getArrayName(array2);
  options.truncate -= name.length + 4;
  const nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array2.length; i2++) {
    const string2 = `${options.stylize(truncate(array2[i2], options.truncate), "number")}${i2 === array2.length - 1 ? "" : ", "}`;
    options.truncate -= string2.length;
    if (array2[i2] !== array2.length && options.truncate <= 3) {
      output += `${truncator}(${array2.length - array2[i2] + 1})`;
      break;
    }
    output += string2;
  }
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty);
  }
  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray, "inspectTypedArray");
function inspectDate(dateObject, options) {
  const stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  const split = stringRepresentation.split("T");
  const date2 = split[0];
  return options.stylize(`${date2}T${truncate(split[1], options.truncate - date2.length - 1)}`, "date");
}
__name(inspectDate, "inspectDate");
function inspectFunction(func, options) {
  const functionType = func[Symbol.toStringTag] || "Function";
  const name = func.name;
  if (!name) {
    return options.stylize(`[${functionType}]`, "special");
  }
  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
}
__name(inspectFunction, "inspectFunction");
function inspectMapEntry([key, value2], options) {
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value2 = options.inspect(value2, options);
  return `${key} => ${value2}`;
}
__name(inspectMapEntry, "inspectMapEntry");
function mapToEntries(map2) {
  const entries = [];
  map2.forEach((value2, key) => {
    entries.push([key, value2]);
  });
  return entries;
}
__name(mapToEntries, "mapToEntries");
function inspectMap(map2, options) {
  const size = map2.size - 1;
  if (size <= 0) {
    return "Map{}";
  }
  options.truncate -= 7;
  return `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`;
}
__name(inspectMap, "inspectMap");
var isNaN$1 = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber(number2, options) {
  if (isNaN$1(number2)) {
    return options.stylize("NaN", "number");
  }
  if (number2 === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number2 === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number2 === 0) {
    return options.stylize(1 / number2 === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate(String(number2), options.truncate), "number");
}
__name(inspectNumber, "inspectNumber");
function inspectBigInt(number2, options) {
  let nums = truncate(number2.toString(), options.truncate - 1);
  if (nums !== truncator)
    nums += "n";
  return options.stylize(nums, "bigint");
}
__name(inspectBigInt, "inspectBigInt");
function inspectRegExp(value2, options) {
  const flags = value2.toString().split("/")[2];
  const sourceLength = options.truncate - (2 + flags.length);
  const source = value2.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp, "inspectRegExp");
function arrayFromSet(set22) {
  const values = [];
  set22.forEach((value2) => {
    values.push(value2);
  });
  return values;
}
__name(arrayFromSet, "arrayFromSet");
function inspectSet(set22, options) {
  if (set22.size === 0)
    return "Set{}";
  options.truncate -= 7;
  return `Set{ ${inspectList(arrayFromSet(set22), options)} }`;
}
__name(inspectSet, "inspectSet");
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex$1 = 16;
var unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex$1)}`.slice(-unicodeLength)}`;
}
__name(escape, "escape");
function inspectString(string2, options) {
  if (stringEscapeChars.test(string2)) {
    string2 = string2.replace(stringEscapeChars, escape);
  }
  return options.stylize(`'${truncate(string2, options.truncate - 2)}'`, "string");
}
__name(inspectString, "inspectString");
function inspectSymbol(value2) {
  if ("description" in Symbol.prototype) {
    return value2.description ? `Symbol(${value2.description})` : "Symbol()";
  }
  return value2.toString();
}
__name(inspectSymbol, "inspectSymbol");
var getPromiseValue = /* @__PURE__ */ __name(() => "Promise{…}", "getPromiseValue");
try {
  const { getPromiseDetails, kPending, kRejected } = process.binding("util");
  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
    getPromiseValue = /* @__PURE__ */ __name((value2, options) => {
      const [state, innerValue] = getPromiseDetails(value2);
      if (state === kPending) {
        return "Promise{<pending>}";
      }
      return `Promise${state === kRejected ? "!" : ""}{${options.inspect(innerValue, options)}}`;
    }, "getPromiseValue");
  }
} catch (notNode) {
}
var promise_default = getPromiseValue;
function inspectObject(object2, options) {
  const properties = Object.getOwnPropertyNames(object2);
  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object2)) {
    return "[Circular]";
  }
  options.seen.push(object2);
  const propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options, inspectProperty);
  const symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject, "inspectObject");
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value2, options) {
  let name = "";
  if (toStringTag && toStringTag in value2) {
    name = value2[toStringTag];
  }
  name = name || value2.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return `${name}${inspectObject(value2, options)}`;
}
__name(inspectClass, "inspectClass");
function inspectArguments(args, options) {
  if (args.length === 0)
    return "Arguments[]";
  options.truncate -= 13;
  return `Arguments[ ${inspectList(args, options)} ]`;
}
__name(inspectArguments, "inspectArguments");
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject2(error, options) {
  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
  const name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? `: ${message}` : "";
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return "[Circular]";
  }
  options.seen.push(error);
  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject2, "inspectObject");
function inspectAttribute([key, value2], options) {
  options.truncate -= 3;
  if (!value2) {
    return `${options.stylize(String(key), "yellow")}`;
  }
  return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value2}"`, "string")}`;
}
__name(inspectAttribute, "inspectAttribute");
function inspectHTMLCollection(collection, options) {
  return inspectList(collection, options, inspectHTML, "\n");
}
__name(inspectHTMLCollection, "inspectHTMLCollection");
function inspectHTML(element, options) {
  const properties = element.getAttributeNames();
  const name = element.tagName.toLowerCase();
  const head = options.stylize(`<${name}`, "special");
  const headClose = options.stylize(`>`, "special");
  const tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
  }
  options.truncate -= propertyContents.length;
  const truncate2 = options.truncate;
  let children2 = inspectHTMLCollection(element.children, options);
  if (children2 && children2.length > truncate2) {
    children2 = `${truncator}(${element.children.length})`;
  }
  return `${head}${propertyContents}${headClose}${children2}${tail}`;
}
__name(inspectHTML, "inspectHTML");
var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = false;
try {
  const nodeUtil2 = require_util();
  nodeInspect = nodeUtil2.inspect ? nodeUtil2.inspect.custom : false;
} catch (noNodeInspect) {
  nodeInspect = false;
}
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: (value2, options) => options.stylize("undefined", "undefined"),
  null: (value2, options) => options.stylize("null", "null"),
  boolean: (value2, options) => options.stylize(String(value2), "boolean"),
  Boolean: (value2, options) => options.stylize(String(value2), "boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value2, options) => options.stylize("WeakSet{…}", "special"),
  WeakMap: (value2, options) => options.stylize("WeakMap{…}", "special"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject2,
  HTMLCollection: inspectHTMLCollection,
  NodeList: inspectHTMLCollection
};
var inspectCustom = /* @__PURE__ */ __name((value2, options, type3) => {
  if (chaiInspect in value2 && typeof value2[chaiInspect] === "function") {
    return value2[chaiInspect](options);
  }
  if (nodeInspect && nodeInspect in value2 && typeof value2[nodeInspect] === "function") {
    return value2[nodeInspect](options.depth, options);
  }
  if ("inspect" in value2 && typeof value2.inspect === "function") {
    return value2.inspect(options.depth, options);
  }
  if ("constructor" in value2 && constructorMap.has(value2.constructor)) {
    return constructorMap.get(value2.constructor)(value2, options);
  }
  if (stringTagMap[type3]) {
    return stringTagMap[type3](value2, options);
  }
  return "";
}, "inspectCustom");
var toString$3 = Object.prototype.toString;
function inspect(value2, opts = {}) {
  const options = normaliseOptions(opts, inspect);
  const { customInspect } = options;
  let type3 = value2 === null ? "null" : typeof value2;
  if (type3 === "object") {
    type3 = toString$3.call(value2).slice(8, -1);
  }
  if (type3 in baseTypesMap) {
    return baseTypesMap[type3](value2, options);
  }
  if (customInspect && value2) {
    const output = inspectCustom(value2, options, type3);
    if (output) {
      if (typeof output === "string")
        return output;
      return inspect(output, options);
    }
  }
  const proto = value2 ? Object.getPrototypeOf(value2) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject(value2, options);
  }
  if (value2 && typeof HTMLElement === "function" && value2 instanceof HTMLElement) {
    return inspectHTML(value2, options);
  }
  if ("constructor" in value2) {
    if (value2.constructor !== Object) {
      return inspectClass(value2, options);
    }
    return inspectObject(value2, options);
  }
  if (value2 === Object(value2)) {
    return inspectObject(value2, options);
  }
  return options.stylize(String(value2), type3);
}
__name(inspect, "inspect");
var config$1 = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: false,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: true,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: true,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function inspect2(obj, showHidden, depth, colors) {
  var options = {
    colors,
    depth: typeof depth === "undefined" ? 2 : depth,
    showHidden,
    truncate: config$1.truncateThreshold ? config$1.truncateThreshold : Infinity
  };
  return inspect(obj, options);
}
__name(inspect2, "inspect");
function objDisplay(obj) {
  var str = inspect2(obj), type3 = Object.prototype.toString.call(obj);
  if (config$1.truncateThreshold && str.length >= config$1.truncateThreshold) {
    if (type3 === "[object Function]") {
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    } else if (type3 === "[object Array]") {
      return "[ Array(" + obj.length + ") ]";
    } else if (type3 === "[object Object]") {
      var keys = Object.keys(obj), kstr = keys.length > 2 ? keys.splice(0, 2).join(", ") + ", ..." : keys.join(", ");
      return "{ Object (" + kstr + ") }";
    } else {
      return str;
    }
  } else {
    return str;
  }
}
__name(objDisplay, "objDisplay");
function getMessage2(obj, args) {
  var negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, "message");
  if (typeof msg === "function")
    msg = msg();
  msg = msg || "";
  msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object2, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  if (!object2.__flags) {
    object2.__flags = /* @__PURE__ */ Object.create(null);
  }
  includeAll = arguments.length === 3 ? includeAll : true;
  for (var flag3 in flags) {
    if (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") {
      object2.__flags[flag3] = flags[flag3];
    }
  }
}
__name(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  const stringTag2 = obj[Symbol.toStringTag];
  if (typeof stringTag2 === "string") {
    return stringTag2;
  }
  const sliceStart = 8;
  const sliceEnd = -1;
  return Object.prototype.toString.call(obj).slice(sliceStart, sliceEnd);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: /* @__PURE__ */ __name(function get(key) {
    return key[this._key];
  }, "get"),
  set: /* @__PURE__ */ __name(function set(key, value2) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value2,
        configurable: true
      });
    }
  }, "set")
};
var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result === "boolean") {
      return result;
    }
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  if (simpleResult !== null) {
    return simpleResult;
  }
  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  if (leftHandOperand === rightHandOperand) {
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  }
  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand) {
    return true;
  }
  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return false;
  }
  return null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator;
  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  }
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    }
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      return simpleResult;
    }
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  }
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  try {
    if (leftHandOperand.size !== rightHandOperand.size) {
      return false;
    }
    if (leftHandOperand.size === 0) {
      return true;
    }
  } catch (sizeError) {
    return false;
  }
  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value2) {
    leftHandItems.push([key, value2]);
  }, "gatherEntries"));
  rightHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value2) {
    rightHandItems.push([key, value2]);
  }, "gatherEntries"));
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length) {
    return false;
  }
  if (length === 0) {
    return true;
  }
  var index = -1;
  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }
  return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];
  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys = [];
  for (var key in target) {
    keys.push(key);
  }
  return keys;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  var keys = [];
  var allKeys = Object.getOwnPropertySymbols(target);
  for (var i2 = 0; i2 < allKeys.length; i2 += 1) {
    var key = allKeys[i2];
    if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
      keys.push(key);
    }
  }
  return keys;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;
  if (length === 0) {
    return true;
  }
  for (var i2 = 0; i2 < length; i2 += 1) {
    if (deepEqual(leftHandOperand[keys[i2]], rightHandOperand[keys[i2]], options) === false) {
      return false;
    }
  }
  return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);
  var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
  var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  leftHandKeys = leftHandKeys.concat(leftHandSymbols);
  rightHandKeys = rightHandKeys.concat(rightHandSymbols);
  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
      return false;
    }
    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }
  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);
  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }
  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }
  return false;
}
__name(objectEqual, "objectEqual");
function isPrimitive(value2) {
  return value2 === null || typeof value2 !== "object";
}
__name(isPrimitive, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(/* @__PURE__ */ __name(function mapSymbol(entry) {
    if (typeof entry === "symbol") {
      return entry.toString();
    }
    return entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
  if (typeof obj === "undefined" || obj === null) {
    return false;
  }
  return name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path2) {
  const str = path2.replace(/([^\\])\[/g, "$1.[");
  const parts2 = str.match(/(\\\.|[^.]+?)+/g);
  return parts2.map((value2) => {
    if (value2 === "constructor" || value2 === "__proto__" || value2 === "prototype") {
      return {};
    }
    const regexp = /^\[(\d+)\]$/;
    const mArr = regexp.exec(value2);
    let parsed = null;
    if (mArr) {
      parsed = { i: parseFloat(mArr[1]) };
    } else {
      parsed = { p: value2.replace(/\\([.[\]])/g, "$1") };
    }
    return parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj;
  let res = null;
  pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
  for (let i2 = 0; i2 < pathDepth; i2++) {
    const part = parsed[i2];
    if (temporaryValue) {
      if (typeof part.p === "undefined") {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }
      if (i2 === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path2) {
  const parsed = parsePath(path2);
  const last = parsed[parsed.length - 1];
  const info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
__name(getPathInfo, "getPathInfo");
function Assertion(obj, msg, ssfi, lockSsfi) {
  flag(this, "ssfi", ssfi || Assertion);
  flag(this, "lockSsfi", lockSsfi);
  flag(this, "object", obj);
  flag(this, "message", msg);
  flag(this, "eql", config$1.deepEqual || deep_eql_default);
  return proxify(this);
}
__name(Assertion, "Assertion");
Object.defineProperty(Assertion, "includeStack", {
  get: function() {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
    return config$1.includeStack;
  },
  set: function(value2) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
    config$1.includeStack = value2;
  }
});
Object.defineProperty(Assertion, "showDiff", {
  get: function() {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
    return config$1.showDiff;
  },
  set: function(value2) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
    config$1.showDiff = value2;
  }
});
Assertion.addProperty = function(name, fn) {
  addProperty(this.prototype, name, fn);
};
Assertion.addMethod = function(name, fn) {
  addMethod(this.prototype, name, fn);
};
Assertion.addChainableMethod = function(name, fn, chainingBehavior) {
  addChainableMethod(this.prototype, name, fn, chainingBehavior);
};
Assertion.overwriteProperty = function(name, fn) {
  overwriteProperty(this.prototype, name, fn);
};
Assertion.overwriteMethod = function(name, fn) {
  overwriteMethod(this.prototype, name, fn);
};
Assertion.overwriteChainableMethod = function(name, fn, chainingBehavior) {
  overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
};
Assertion.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
  var ok = test$1(this, arguments);
  if (false !== showDiff)
    showDiff = true;
  if (void 0 === expected && void 0 === _actual)
    showDiff = false;
  if (true !== config$1.showDiff)
    showDiff = false;
  if (!ok) {
    msg = getMessage2(this, arguments);
    var actual = getActual(this, arguments);
    var assertionErrorObjectProperties = {
      actual,
      expected,
      showDiff
    };
    var operator = getOperator(this, arguments);
    if (operator) {
      assertionErrorObjectProperties.operator = operator;
    }
    throw new AssertionError(
      msg,
      assertionErrorObjectProperties,
      config$1.includeStack ? this.assert : flag(this, "ssfi")
    );
  }
};
Object.defineProperty(
  Assertion.prototype,
  "_obj",
  {
    get: function() {
      return flag(this, "object");
    },
    set: function(val) {
      flag(this, "object", val);
    }
  }
);
function isProxyEnabled() {
  return config$1.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function() {
  } : getter;
  Object.defineProperty(
    ctx,
    name,
    {
      get: /* @__PURE__ */ __name(function propertyGetter() {
        if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
          flag(this, "ssfi", propertyGetter);
        }
        var result = getter.call(this);
        if (result !== void 0)
          return result;
        var newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "propertyGetter"),
      configurable: true
    }
  );
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable)
    return fn;
  Object.defineProperty(fn, "length", {
    get: function() {
      if (isChainable) {
        throw Error("Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }
      throw Error("Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object2) {
  var result = Object.getOwnPropertyNames(object2);
  function addProperty2(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }
  __name(addProperty2, "addProperty");
  var proto = Object.getPrototypeOf(object2);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty2);
    proto = Object.getPrototypeOf(proto);
  }
  return result;
}
__name(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled())
    return obj;
  return new Proxy(obj, {
    get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
      if (typeof property === "string" && config$1.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName) {
          throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        }
        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function(prop) {
          if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(
              property,
              prop,
              suggestionDistance
            );
            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });
        if (suggestion !== null) {
          throw Error("Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error("Invalid Chai property: " + property);
        }
      }
      if (builtins.indexOf(property) === -1 && !flag(target, "lockSsfi")) {
        flag(target, "ssfi", proxyGetter);
      }
      return Reflect.get(target, property);
    }, "proxyGetter")
  });
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }
  var memo = [];
  for (var i2 = 0; i2 <= strA.length; i2++) {
    memo[i2] = Array(strB.length + 1).fill(0);
    memo[i2][0] = i2;
  }
  for (var j2 = 0; j2 < strB.length; j2++) {
    memo[0][j2] = j2;
  }
  for (var i2 = 1; i2 <= strA.length; i2++) {
    var ch = strA.charCodeAt(i2 - 1);
    for (var j2 = 1; j2 <= strB.length; j2++) {
      if (Math.abs(i2 - j2) >= cap) {
        memo[i2][j2] = cap;
        continue;
      }
      memo[i2][j2] = Math.min(
        memo[i2 - 1][j2] + 1,
        memo[i2][j2 - 1] + 1,
        memo[i2 - 1][j2 - 1] + (ch === strB.charCodeAt(j2 - 1) ? 0 : 1)
      );
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
  var methodWrapper = /* @__PURE__ */ __name(function() {
    if (!flag(this, "lockSsfi")) {
      flag(this, "ssfi", methodWrapper);
    }
    var result = method.apply(this, arguments);
    if (result !== void 0)
      return result;
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {
  }, "_super");
  if (_get && "function" === typeof _get.get)
    _super = _get.get;
  Object.defineProperty(
    ctx,
    name,
    {
      get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
        if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
          flag(this, "ssfi", overwritingPropertyGetter);
        }
        var origLockSsfi = flag(this, "lockSsfi");
        flag(this, "lockSsfi", true);
        var result = getter(_super).call(this);
        flag(this, "lockSsfi", origLockSsfi);
        if (result !== void 0) {
          return result;
        }
        var newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "overwritingPropertyGetter"),
      configurable: true
    }
  );
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
  var _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
    throw new Error(name + " is not a function");
  }, "_super");
  if (_method && "function" === typeof _method)
    _super = _method;
  var overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
    if (!flag(this, "lockSsfi")) {
      flag(this, "ssfi", overwritingMethodWrapper);
    }
    var origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", true);
    var result = method(_super).apply(this, arguments);
    flag(this, "lockSsfi", origLockSsfi);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf === "function";
var testFn = /* @__PURE__ */ __name(function() {
}, "testFn");
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  if (typeof propDesc !== "object")
    return true;
  return !propDesc.configurable;
});
var call = Function.prototype.call;
var apply$1 = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== "function") {
    chainingBehavior = /* @__PURE__ */ __name(function() {
    }, "chainingBehavior");
  }
  var chainableBehavior = {
    method,
    chainingBehavior
  };
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(
    ctx,
    name,
    {
      get: /* @__PURE__ */ __name(function chainableMethodGetter() {
        chainableBehavior.chainingBehavior.call(this);
        var chainableMethodWrapper = /* @__PURE__ */ __name(function() {
          if (!flag(this, "lockSsfi")) {
            flag(this, "ssfi", chainableMethodWrapper);
          }
          var result = chainableBehavior.method.apply(this, arguments);
          if (result !== void 0) {
            return result;
          }
          var newAssertion = new Assertion();
          transferFlags(this, newAssertion);
          return newAssertion;
        }, "chainableMethodWrapper");
        addLengthGuard(chainableMethodWrapper, name, true);
        if (canSetPrototype) {
          var prototype = Object.create(this);
          prototype.call = call;
          prototype.apply = apply$1;
          Object.setPrototypeOf(chainableMethodWrapper, prototype);
        } else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function(asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }
            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }
        transferFlags(this, chainableMethodWrapper);
        return proxify(chainableMethodWrapper);
      }, "chainableMethodGetter"),
      configurable: true
    }
  );
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodGetter");
  var _method = chainableBehavior.method;
  chainableBehavior.method = /* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a2, b2) {
  return inspect2(a2) < inspect2(b2) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== "function")
    return [];
  return Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
function _isNaN(value2) {
  return value2 !== value2;
}
__name(_isNaN, "_isNaN");
var isNaN2 = Number.isNaN || _isNaN;
function isObjectType(obj) {
  var objectType = type(obj);
  var objectTypes = ["Array", "Object", "Function"];
  return objectTypes.indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
  var operator = flag(obj, "operator");
  var negate = flag(obj, "negate");
  var expected = args[3];
  var msg = negate ? args[2] : args[1];
  if (operator) {
    return operator;
  }
  if (typeof msg === "function")
    msg = msg();
  msg = msg || "";
  if (!msg) {
    return void 0;
  }
  if (/\shave\s/.test(msg)) {
    return void 0;
  }
  var isObject2 = isObjectType(expected);
  if (/\snot\s/.test(msg)) {
    return isObject2 ? "notDeepStrictEqual" : "notStrictEqual";
  }
  return isObject2 ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
function getName(fn) {
  return fn.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isNumeric(obj) {
  return ["Number", "BigInt"].includes(type(obj));
}
__name(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", true);
  flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", true);
  flag2(this, "any", false);
});
var functionTypes = {
  "function": ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  "asyncfunction": ["asyncfunction", "asyncgeneratorfunction"],
  "generatorfunction": ["generatorfunction", "asyncgeneratorfunction"],
  "asyncgeneratorfunction": ["asyncgeneratorfunction"]
};
function an(type3, msg) {
  if (msg)
    flag2(this, "message", msg);
  type3 = type3.toLowerCase();
  var obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type3.charAt(0)) ? "an " : "a ";
  const detectedType = type(obj).toLowerCase();
  if (functionTypes["function"].includes(type3)) {
    this.assert(
      functionTypes[type3].includes(detectedType),
      "expected #{this} to be " + article + type3,
      "expected #{this} not to be " + article + type3
    );
  } else {
    this.assert(
      type3 === detectedType,
      "expected #{this} to be " + article + type3,
      "expected #{this} not to be " + article + type3
    );
  }
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a2, b2) {
  return isNaN2(a2) && isNaN2(b2) || a2 === b2;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var included = false;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep) {
        throw new AssertionError(
          flagMsg + "unable to use .deep.include with WeakSet",
          void 0,
          ssfi
        );
      }
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      if (isDeep) {
        obj.forEach(function(item) {
          included = included || isEql(item, val);
        });
      } else {
        included = obj.has(val);
      }
      break;
    case "array":
      if (isDeep) {
        included = obj.some(function(item) {
          return isEql(item, val);
        });
      } else {
        included = obj.indexOf(val) !== -1;
      }
      break;
    default:
      if (val !== Object(val)) {
        throw new AssertionError(
          flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(),
          void 0,
          ssfi
        );
      }
      var props = Object.keys(val), firstErr = null, numErrs = 0;
      props.forEach(function(prop) {
        var propAssertion = new Assertion(obj);
        transferFlags(this, propAssertion, true);
        flag2(propAssertion, "lockSsfi", true);
        if (!negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err2) {
          if (!check_error_exports.compatibleConstructor(err2, AssertionError)) {
            throw err2;
          }
          if (firstErr === null)
            firstErr = err2;
          numErrs++;
        }
      }, this);
      if (negate && props.length > 1 && numErrs === props.length) {
        throw firstErr;
      }
      return;
  }
  this.assert(
    included,
    "expected #{this} to " + descriptor + "include " + inspect2(val),
    "expected #{this} to not " + descriptor + "include " + inspect2(val)
  );
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(
    flag2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
Assertion.addProperty("true", function() {
  this.assert(
    true === flag2(this, "object"),
    "expected #{this} to be true",
    "expected #{this} to be false",
    flag2(this, "negate") ? false : true
  );
});
Assertion.addProperty("numeric", function() {
  const object2 = flag2(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(type(object2)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    flag2(this, "negate") ? false : true
  );
});
Assertion.addProperty("callable", function() {
  const val = flag2(this, "object");
  const ssfi = flag2(this, "ssfi");
  const message = flag2(this, "message");
  const msg = message ? `${message}: ` : "";
  const negate = flag2(this, "negate");
  const assertionMessage = negate ? `${msg}expected ${inspect2(val)} not to be a callable function` : `${msg}expected ${inspect2(val)} to be a callable function`;
  const isCallable = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(type(val));
  if (isCallable && negate || !isCallable && !negate) {
    throw new AssertionError(
      assertionMessage,
      void 0,
      ssfi
    );
  }
});
Assertion.addProperty("false", function() {
  this.assert(
    false === flag2(this, "object"),
    "expected #{this} to be false",
    "expected #{this} to be true",
    flag2(this, "negate") ? true : false
  );
});
Assertion.addProperty("null", function() {
  this.assert(
    null === flag2(this, "object"),
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
Assertion.addProperty("undefined", function() {
  this.assert(
    void 0 === flag2(this, "object"),
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
Assertion.addProperty("NaN", function() {
  this.assert(
    isNaN2(flag2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function assertExist() {
  var val = flag2(this, "object");
  this.assert(
    val !== null && val !== void 0,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  var val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  switch (type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(
        flagMsg + ".empty was passed a weak collection",
        void 0,
        ssfi
      );
    case "function":
      var msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    default:
      if (val !== Object(val)) {
        throw new AssertionError(
          flagMsg + ".empty was passed non-string primitive " + inspect2(val),
          void 0,
          ssfi
        );
      }
      itemsCount = Object.keys(val).length;
  }
  this.assert(
    0 === itemsCount,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function checkArguments() {
  var obj = flag2(this, "object"), type3 = type(obj);
  this.assert(
    "Arguments" === type3,
    "expected #{this} to be arguments but got " + type3,
    "expected #{this} to not be arguments"
  );
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    var prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", true);
    this.eql(val);
    flag2(this, "lockSsfi", prevLockSsfi);
  } else {
    this.assert(
      val === obj,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      val,
      this._obj,
      true
    );
  }
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  if (msg)
    flag2(this, "message", msg);
  var eql = flag2(this, "eql");
  this.assert(
    eql(obj, flag2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    obj,
    this._obj,
    true
  );
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase();
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    throw new AssertionError(msgPrefix + "the argument to above must be a date", void 0, ssfi);
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    throw new AssertionError(msgPrefix + "the argument to above must be a number", void 0, ssfi);
  } else if (!doLength && (objType !== "date" && !isNumeric(obj))) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    throw new AssertionError(msgPrefix + "expected " + printObj + " to be a number or a date", void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount > n2,
      "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj > n2,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n2
    );
  }
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to least must be a date";
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to least must be a number";
  } else if (!doLength && (objType !== "date" && !isNumeric(obj))) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount >= n2,
      "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj >= n2,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n2
    );
  }
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to below must be a date";
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to below must be a number";
  } else if (!doLength && (objType !== "date" && !isNumeric(obj))) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount < n2,
      "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " below #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj < n2,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n2
    );
  }
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n2).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to most must be a date";
  } else if (!isNumeric(n2) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the argument to most must be a number";
  } else if (!doLength && (objType !== "date" && !isNumeric(obj))) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount <= n2,
      "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " above #{exp}",
      n2,
      itemsCount
    );
  } else {
    this.assert(
      obj <= n2,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n2
    );
  }
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && (startType !== "date" || finishType !== "date"))) {
    errorMessage = msgPrefix + "the arguments to within must be dates";
  } else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj))) {
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  } else if (!doLength && (objType !== "date" && !isNumeric(obj))) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount >= start && itemsCount <= finish,
      "expected #{this} to have a " + descriptor + " within " + range,
      "expected #{this} to not have a " + descriptor + " within " + range
    );
  } else {
    this.assert(
      obj >= start && obj <= finish,
      "expected #{this} to be within " + range,
      "expected #{this} to not be within " + range
    );
  }
});
function assertInstanceOf(constructor, msg) {
  if (msg)
    flag2(this, "message", msg);
  var target = flag2(this, "object");
  var ssfi = flag2(this, "ssfi");
  var flagMsg = flag2(this, "message");
  try {
    var isInstanceOf = target instanceof constructor;
  } catch (err2) {
    if (err2 instanceof TypeError) {
      flagMsg = flagMsg ? flagMsg + ": " : "";
      throw new AssertionError(
        flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.",
        void 0,
        ssfi
      );
    }
    throw err2;
  }
  var name = getName(constructor);
  if (name == null) {
    name = "an unnamed constructor";
  }
  this.assert(
    isInstanceOf,
    "expected #{this} to be an instance of " + name,
    "expected #{this} to not be an instance of " + name
  );
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  if (msg)
    flag2(this, "message", msg);
  var isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  if (isNested) {
    if (nameType !== "string") {
      throw new AssertionError(
        flagMsg + "the argument to property must be a string when using nested syntax",
        void 0,
        ssfi
      );
    }
  } else {
    if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") {
      throw new AssertionError(
        flagMsg + "the argument to property must be a string, number, or symbol",
        void 0,
        ssfi
      );
    }
  }
  if (isNested && isOwn) {
    throw new AssertionError(
      flagMsg + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      ssfi
    );
  }
  if (obj === null || obj === void 0) {
    throw new AssertionError(
      flagMsg + "Target cannot be null or undefined.",
      void 0,
      ssfi
    );
  }
  var isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value2 = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  var descriptor = "";
  if (isDeep)
    descriptor += "deep ";
  if (isOwn)
    descriptor += "own ";
  if (isNested)
    descriptor += "nested ";
  descriptor += "property ";
  var hasProperty2;
  if (isOwn)
    hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name);
  else if (isNested)
    hasProperty2 = pathInfo.exists;
  else
    hasProperty2 = hasProperty(obj, name);
  if (!negate || arguments.length === 1) {
    this.assert(
      hasProperty2,
      "expected #{this} to have " + descriptor + inspect2(name),
      "expected #{this} to not have " + descriptor + inspect2(name)
    );
  }
  if (arguments.length > 1) {
    this.assert(
      hasProperty2 && isEql(val, value2),
      "expected #{this} to have " + descriptor + inspect2(name) + " of #{exp}, but got #{act}",
      "expected #{this} to not have " + descriptor + inspect2(name) + " of #{act}",
      val,
      value2
    );
  }
  flag2(this, "object", value2);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(name, value2, msg) {
  flag2(this, "own", true);
  assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  if (typeof descriptor === "string") {
    msg = descriptor;
    descriptor = null;
  }
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
  var eql = flag2(this, "eql");
  if (actualDescriptor && descriptor) {
    this.assert(
      eql(descriptor, actualDescriptor),
      "expected the own property descriptor for " + inspect2(name) + " on #{this} to match " + inspect2(descriptor) + ", got " + inspect2(actualDescriptor),
      "expected the own property descriptor for " + inspect2(name) + " on #{this} to not match " + inspect2(descriptor),
      descriptor,
      actualDescriptor,
      true
    );
  } else {
    this.assert(
      actualDescriptor,
      "expected #{this} to have an own property descriptor for " + inspect2(name),
      "expected #{this} to not have an own property descriptor for " + inspect2(name)
    );
  }
  flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size";
      itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
      itemsCount = obj.length;
  }
  this.assert(
    itemsCount == n2,
    "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + descriptor + " of #{act}",
    n2,
    itemsCount
  );
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(
    re2.exec(obj),
    "expected #{this} to match " + re2,
    "expected #{this} not to match " + re2
  );
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("string");
  this.assert(
    ~obj.indexOf(str),
    "expected #{this} to contain " + inspect2(str),
    "expected #{this} to not contain " + inspect2(str)
  );
});
function assertKeys(keys) {
  var obj = flag2(this, "object"), objType = type(obj), keysType = type(keys), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set") {
    deepStr = isDeep ? "deeply " : "";
    actual = [];
    obj.forEach(function(val, key) {
      actual.push(key);
    });
    if (keysType !== "Array") {
      keys = Array.prototype.slice.call(arguments);
    }
  } else {
    actual = getOwnEnumerableProperties(obj);
    switch (keysType) {
      case "Array":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        break;
      case "Object":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }
    keys = keys.map(function(val) {
      return typeof val === "symbol" ? val : String(val);
    });
  }
  if (!keys.length) {
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  }
  var len = keys.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all) {
    all = true;
  }
  if (any) {
    ok = expected.some(function(expectedKey) {
      return actual.some(function(actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
  }
  if (all) {
    ok = expected.every(function(expectedKey) {
      return actual.some(function(actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
    if (!flag2(this, "contains")) {
      ok = ok && keys.length == actual.length;
    }
  }
  if (len > 1) {
    keys = keys.map(function(key) {
      return inspect2(key);
    });
    var last = keys.pop();
    if (all) {
      str = keys.join(", ") + ", and " + last;
    }
    if (any) {
      str = keys.join(", ") + ", or " + last;
    }
  } else {
    str = inspect2(keys[0]);
  }
  str = (len > 1 ? "keys " : "key ") + str;
  str = (flag2(this, "contains") ? "contain " : "have ") + str;
  this.assert(
    ok,
    "expected #{this} to " + deepStr + str,
    "expected #{this} to not " + deepStr + str,
    expected.slice(0).sort(compareByInspect),
    actual.sort(compareByInspect),
    true
  );
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
  new Assertion(obj, flagMsg, ssfi, true).is.a("function");
  if (isRegExp2(errorLike) || typeof errorLike === "string") {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  let caughtErr;
  let errorWasThrown = false;
  try {
    obj();
  } catch (err2) {
    errorWasThrown = true;
    caughtErr = err2;
  }
  var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
  var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
  var errorLikeFail = false;
  var errMsgMatcherFail = false;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    var errorLikeString = "an error";
    if (errorLike instanceof Error) {
      errorLikeString = "#{exp}";
    } else if (errorLike) {
      errorLikeString = check_error_exports.getConstructorName(errorLike);
    }
    let actual = caughtErr;
    if (caughtErr instanceof Error) {
      actual = caughtErr.toString();
    } else if (typeof caughtErr === "string") {
      actual = caughtErr;
    } else if (caughtErr && (typeof caughtErr === "object" || typeof caughtErr === "function")) {
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch (_err) {
      }
    }
    this.assert(
      errorWasThrown,
      "expected #{this} to throw " + errorLikeString,
      "expected #{this} to not throw an error but #{act} was thrown",
      errorLike && errorLike.toString(),
      actual
    );
  }
  if (errorLike && caughtErr) {
    if (errorLike instanceof Error) {
      var isCompatibleInstance = check_error_exports.compatibleInstance(caughtErr, errorLike);
      if (isCompatibleInstance === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(
            negate,
            "expected #{this} to throw #{exp} but #{act} was thrown",
            "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
            errorLike.toString(),
            caughtErr.toString()
          );
        }
      }
    }
    var isCompatibleConstructor = check_error_exports.compatibleConstructor(caughtErr, errorLike);
    if (isCompatibleConstructor === negate) {
      if (everyArgIsDefined && negate) {
        errorLikeFail = true;
      } else {
        this.assert(
          negate,
          "expected #{this} to throw #{exp} but #{act} was thrown",
          "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
          errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
          caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
        );
      }
    }
  }
  if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    var placeholder = "including";
    if (isRegExp2(errMsgMatcher)) {
      placeholder = "matching";
    }
    var isCompatibleMessage = check_error_exports.compatibleMessage(caughtErr, errMsgMatcher);
    if (isCompatibleMessage === negate) {
      if (everyArgIsDefined && negate) {
        errMsgMatcherFail = true;
      } else {
        this.assert(
          negate,
          "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
          "expected #{this} to throw error not " + placeholder + " #{exp}",
          errMsgMatcher,
          check_error_exports.getMessage(caughtErr)
        );
      }
    }
  }
  if (errorLikeFail && errMsgMatcherFail) {
    this.assert(
      negate,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
      errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
      caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
    );
  }
  flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), itself = flag2(this, "itself"), context = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
  this.assert(
    "function" === typeof context,
    "expected #{this} to respond to " + inspect2(method),
    "expected #{this} to not respond to " + inspect2(method)
  );
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", true);
});
function satisfy(matcher2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  var result = matcher2(obj);
  this.assert(
    result,
    "expected #{this} to satisfy " + objDisplay(matcher2),
    "expected #{this} to not satisfy" + objDisplay(matcher2),
    flag2(this, "negate") ? false : true,
    result
  );
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.numeric;
  let message = "A `delta` value is required for `closeTo`";
  if (delta == void 0)
    throw new AssertionError(flagMsg ? `${flagMsg}: ${message}` : message, void 0, ssfi);
  new Assertion(delta, flagMsg, ssfi, true).is.numeric;
  message = "A `expected` value is required for `closeTo`";
  if (expected == void 0)
    throw new AssertionError(flagMsg ? `${flagMsg}: ${message}` : message, void 0, ssfi);
  new Assertion(expected, flagMsg, ssfi, true).is.numeric;
  const abs2 = /* @__PURE__ */ __name((x2) => x2 < 0n ? -x2 : x2, "abs");
  this.assert(
    abs2(obj - expected) <= delta,
    "expected #{this} to be close to " + expected + " +/- " + delta,
    "expected #{this} not to be close to " + expected + " +/- " + delta
  );
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  let superset = Array.from(_superset);
  let subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length)
      return false;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered)
      return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      var matchIdx = superset.indexOf(elem);
      if (matchIdx === -1)
        return false;
      if (!contains)
        superset.splice(matchIdx, 1);
      return true;
    }
    return superset.some(function(elem2, matchIdx2) {
      if (!cmp(elem, elem2))
        return false;
      if (!contains)
        superset.splice(matchIdx2, 1);
      return true;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
  new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
  var contains = flag2(this, "contains");
  var ordered = flag2(this, "ordered");
  var subject, failMsg, failNegateMsg;
  if (contains) {
    subject = ordered ? "an ordered superset" : "a superset";
    failMsg = "expected #{this} to be " + subject + " of #{exp}";
    failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
  } else {
    subject = ordered ? "ordered members" : "members";
    failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
    failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
  }
  var cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(
    isSubsetOf(subset, obj, cmp, contains, ordered),
    failMsg,
    failNegateMsg,
    subset,
    obj,
    true
  );
});
Assertion.addProperty("iterable", function(msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(
    obj != void 0 && obj[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    obj
  );
});
function oneOf(list, msg) {
  if (msg)
    flag2(this, "message", msg);
  var expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
  if (contains) {
    this.assert(
      list.some(function(possibility) {
        return expected.indexOf(possibility) > -1;
      }),
      "expected #{this} to contain one of #{exp}",
      "expected #{this} to not contain one of #{exp}",
      list,
      expected
    );
  } else {
    if (isDeep) {
      this.assert(
        list.some(function(possibility) {
          return eql(expected, possibility);
        }),
        "expected #{this} to deeply equal one of #{exp}",
        "expected #{this} to deeply equal one of #{exp}",
        list,
        expected
      );
    } else {
      this.assert(
        list.indexOf(expected) > -1,
        "expected #{this} to be one of #{exp}",
        "expected #{this} to not be one of #{exp}",
        list,
        expected
      );
    }
  }
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  if (msg)
    flag2(this, "message", msg);
  var fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "change");
  flag2(this, "realDelta", final !== initial);
  this.assert(
    initial !== final,
    "expected " + msgObj + " to change",
    "expected " + msgObj + " to not change"
  );
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  if (msg)
    flag2(this, "message", msg);
  var fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  new Assertion(initial, flagMsg, ssfi, true).is.a("number");
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "increase");
  flag2(this, "realDelta", final - initial);
  this.assert(
    final - initial > 0,
    "expected " + msgObj + " to increase",
    "expected " + msgObj + " to not increase"
  );
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  if (msg)
    flag2(this, "message", msg);
  var fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial = subject[prop];
  }
  new Assertion(initial, flagMsg, ssfi, true).is.a("number");
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "decrease");
  flag2(this, "realDelta", initial - final);
  this.assert(
    final - initial < 0,
    "expected " + msgObj + " to decrease",
    "expected " + msgObj + " to not decrease"
  );
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  if (msg)
    flag2(this, "message", msg);
  var msgObj = flag2(this, "deltaMsgObj");
  var initial = flag2(this, "initialDeltaValue");
  var final = flag2(this, "finalDeltaValue");
  var behavior = flag2(this, "deltaBehavior");
  var realDelta = flag2(this, "realDelta");
  var expression;
  if (behavior === "change") {
    expression = Math.abs(final - initial) === Math.abs(delta);
  } else {
    expression = realDelta === Math.abs(delta);
  }
  this.assert(
    expression,
    "expected " + msgObj + " to " + behavior + " by " + delta,
    "expected " + msgObj + " to not " + behavior + " by " + delta
  );
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  var obj = flag2(this, "object");
  var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(
    isExtensible,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
Assertion.addProperty("sealed", function() {
  var obj = flag2(this, "object");
  var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
  this.assert(
    isSealed,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
Assertion.addProperty("frozen", function() {
  var obj = flag2(this, "object");
  var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
  this.assert(
    isFrozen,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
Assertion.addProperty("finite", function(msg) {
  var obj = flag2(this, "object");
  this.assert(
    typeof obj === "number" && isFinite(obj),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "expect.fail()";
  throw new AssertionError(message, {
    actual,
    expected,
    operator
  }, expect.fail);
};
var should_exports = {};
__export(should_exports, {
  Should: () => Should,
  should: () => should
});
function loadShould() {
  function shouldGetter() {
    if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) {
      return new Assertion(this.valueOf(), null, shouldGetter);
    }
    return new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value2) {
    Object.defineProperty(this, "should", {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  }
  __name(shouldSetter, "shouldSetter");
  Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: true
  });
  var should2 = {};
  should2.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = void 0;
    }
    message = message || "should.fail()";
    throw new AssertionError(message, {
      actual,
      expected,
      operator
    }, should2.fail);
  };
  should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  };
  should2.Throw = function(fn, errt, errs, msg) {
    new Assertion(fn, msg).to.Throw(errt, errs);
  };
  should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  };
  should2.not = {};
  should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  };
  should2.not.Throw = function(fn, errt, errs, msg) {
    new Assertion(fn, msg).to.not.Throw(errt, errs);
  };
  should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  };
  should2["throw"] = should2["Throw"];
  should2.not["throw"] = should2.not["Throw"];
  return should2;
}
__name(loadShould, "loadShould");
var should = loadShould;
var Should = loadShould;
function assert(express, errmsg) {
  var test2 = new Assertion(null, null, assert, true);
  test2.assert(
    express,
    errmsg,
    "[ negation message unavailable ]"
  );
}
__name(assert, "assert");
assert.fail = function(actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "assert.fail()";
  throw new AssertionError(message, {
    actual,
    expected,
    operator
  }, assert.fail);
};
assert.isOk = function(val, msg) {
  new Assertion(val, msg, assert.isOk, true).is.ok;
};
assert.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
};
assert.equal = function(act, exp, msg) {
  var test2 = new Assertion(act, msg, assert.equal, true);
  test2.assert(
    exp == flag(test2, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    exp,
    act,
    true
  );
};
assert.notEqual = function(act, exp, msg) {
  var test2 = new Assertion(act, msg, assert.notEqual, true);
  test2.assert(
    exp != flag(test2, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    exp,
    act,
    true
  );
};
assert.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
};
assert.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
};
assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
};
assert.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
};
assert.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
};
assert.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
};
assert.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
};
assert.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
};
assert.isTrue = function(val, msg) {
  new Assertion(val, msg, assert.isTrue, true).is["true"];
};
assert.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
};
assert.isFalse = function(val, msg) {
  new Assertion(val, msg, assert.isFalse, true).is["false"];
};
assert.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
};
assert.isNull = function(val, msg) {
  new Assertion(val, msg, assert.isNull, true).to.equal(null);
};
assert.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
};
assert.isNaN = function(val, msg) {
  new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
};
assert.isNotNaN = function(value2, message) {
  new Assertion(value2, message, assert.isNotNaN, true).not.to.be.NaN;
};
assert.exists = function(val, msg) {
  new Assertion(val, msg, assert.exists, true).to.exist;
};
assert.notExists = function(val, msg) {
  new Assertion(val, msg, assert.notExists, true).to.not.exist;
};
assert.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
};
assert.isDefined = function(val, msg) {
  new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
};
assert.isCallable = function(value2, message) {
  new Assertion(value2, message, assert.isCallable, true).is.callable;
};
assert.isNotCallable = function(value2, message) {
  new Assertion(value2, message, assert.isNotCallable, true).is.not.callable;
};
assert.isObject = function(val, msg) {
  new Assertion(val, msg, assert.isObject, true).to.be.a("object");
};
assert.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
};
assert.isArray = function(val, msg) {
  new Assertion(val, msg, assert.isArray, true).to.be.an("array");
};
assert.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
};
assert.isString = function(val, msg) {
  new Assertion(val, msg, assert.isString, true).to.be.a("string");
};
assert.isNotString = function(val, msg) {
  new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
};
assert.isNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
};
assert.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
};
assert.isNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNumeric, true).is.numeric;
};
assert.isNotNumeric = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumeric, true).is.not.numeric;
};
assert.isFinite = function(val, msg) {
  new Assertion(val, msg, assert.isFinite, true).to.be.finite;
};
assert.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
};
assert.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
};
assert.typeOf = function(val, type3, msg) {
  new Assertion(val, msg, assert.typeOf, true).to.be.a(type3);
};
assert.notTypeOf = function(value2, type3, message) {
  new Assertion(value2, message, assert.notTypeOf, true).to.not.be.a(type3);
};
assert.instanceOf = function(val, type3, msg) {
  new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type3);
};
assert.notInstanceOf = function(val, type3, msg) {
  new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type3);
};
assert.include = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.include, true).include(inc);
};
assert.notInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
};
assert.deepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
};
assert.notDeepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
};
assert.nestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
};
assert.notNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
};
assert.deepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
};
assert.notDeepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
};
assert.ownInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
};
assert.notOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
};
assert.deepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
};
assert.notDeepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
};
assert.match = function(exp, re2, msg) {
  new Assertion(exp, msg, assert.match, true).to.match(re2);
};
assert.notMatch = function(exp, re2, msg) {
  new Assertion(exp, msg, assert.notMatch, true).to.not.match(re2);
};
assert.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.property, true).to.have.property(prop);
};
assert.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
};
assert.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
};
assert.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
};
assert.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
};
assert.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
};
assert.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
};
assert.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
};
assert.ownPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value2);
};
assert.notOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value2);
};
assert.deepOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value2);
};
assert.notDeepOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value2);
};
assert.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
};
assert.notNestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
};
assert.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
};
assert.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
};
assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
};
assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
};
assert.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
};
assert.hasAnyKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
};
assert.hasAllKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
};
assert.containsAllKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
};
assert.doesNotHaveAnyKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
};
assert.doesNotHaveAllKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
};
assert.hasAnyDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
};
assert.hasAllDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
};
assert.containsAllDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
};
assert.doesNotHaveAnyDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
};
assert.doesNotHaveAllDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
};
assert.throws = function(fn, errorLike, errMsgMatcher, msg) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
  return flag(assertErr, "object");
};
assert.doesNotThrow = function(fn, errorLike, errMsgMatcher, message) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  new Assertion(fn, message, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
};
assert.operator = function(val, operator, val2, msg) {
  var ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      msg = msg ? msg + ": " : msg;
      throw new AssertionError(
        msg + 'Invalid operator "' + operator + '"',
        void 0,
        assert.operator
      );
  }
  var test2 = new Assertion(ok, msg, assert.operator, true);
  test2.assert(
    true === flag(test2, "object"),
    "expected " + inspect2(val) + " to be " + operator + " " + inspect2(val2),
    "expected " + inspect2(val) + " to not be " + operator + " " + inspect2(val2)
  );
};
assert.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
};
assert.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
};
assert.sameMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set22);
};
assert.notSameMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set22);
};
assert.sameDeepMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set22);
};
assert.notSameDeepMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set22);
};
assert.sameOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set22);
};
assert.notSameOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set22);
};
assert.sameDeepOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set22);
};
assert.notSameDeepOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set22);
};
assert.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
};
assert.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
};
assert.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
};
assert.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
};
assert.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
};
assert.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
};
assert.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
};
assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
};
assert.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
};
assert.isIterable = function(obj, msg) {
  if (obj == void 0 || !obj[Symbol.iterator]) {
    msg = msg ? `${msg} expected ${inspect2(obj)} to be an iterable` : `expected ${inspect2(obj)} to be an iterable`;
    throw new AssertionError(
      msg,
      void 0,
      assert.isIterable
    );
  }
};
assert.changes = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
};
assert.changesBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
};
assert.doesNotChange = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
};
assert.changesButNotBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert.increases = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
};
assert.increasesBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert.doesNotIncrease = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
};
assert.increasesButNotBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert.decreases = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
};
assert.decreasesBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert.doesNotDecrease = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
};
assert.doesNotDecreaseBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert.decreasesButNotBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert.ifError = function(val) {
  if (val) {
    throw val;
  }
};
assert.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
};
assert.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
};
assert.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
};
assert.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
};
assert.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
};
assert.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
};
assert.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
};
assert.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
};
(/* @__PURE__ */ __name(function alias(name, as) {
  assert[as] = assert[name];
  return alias;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var used = [];
function use(fn) {
  const exports2 = {
    AssertionError,
    util: utils_exports,
    config: config$1,
    expect,
    assert,
    Assertion,
    ...should_exports
  };
  if (!~used.indexOf(fn)) {
    fn(exports2, utils_exports);
    used.push(fn);
  }
  return exports2;
}
__name(use, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var browser$1 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type3 = (match[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w2;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
function setup$1(env) {
  createDebug2.debug = createDebug2;
  createDebug2.default = createDebug2;
  createDebug2.coerce = coerce;
  createDebug2.disable = disable;
  createDebug2.enable = enable;
  createDebug2.enabled = enabled;
  createDebug2.humanize = requireMs$1();
  createDebug2.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug2[key] = env[key];
  });
  createDebug2.names = [];
  createDebug2.skips = [];
  createDebug2.formatters = {};
  function selectColor(namespace2) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace2.length; i2++) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
  }
  createDebug2.selectColor = selectColor;
  function createDebug2(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug2.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug2.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug2.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.useColors = createDebug2.useColors();
    debug2.color = createDebug2.selectColor(namespace2);
    debug2.extend = extend2;
    debug2.destroy = createDebug2.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug2.namespaces) {
          namespacesCache = createDebug2.namespaces;
          enabledCache = createDebug2.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v2) => {
        enableOverride = v2;
      }
    });
    if (typeof createDebug2.init === "function") {
      createDebug2.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace2, delimiter) {
    const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces2) {
    createDebug2.save(namespaces2);
    createDebug2.namespaces = namespaces2;
    createDebug2.names = [];
    createDebug2.skips = [];
    let i2;
    const split = (typeof namespaces2 === "string" ? namespaces2 : "").split(/[\s,]+/);
    const len = split.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces2 = split[i2].replace(/\*/g, ".*?");
      if (namespaces2[0] === "-") {
        createDebug2.skips.push(new RegExp("^" + namespaces2.slice(1) + "$"));
      } else {
        createDebug2.names.push(new RegExp("^" + namespaces2 + "$"));
      }
    }
  }
  function disable() {
    const namespaces2 = [
      ...createDebug2.names.map(toNamespace),
      ...createDebug2.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug2.enable("");
    return namespaces2;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug2.skips.length; i2 < len; i2++) {
      if (createDebug2.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug2.names.length; i2 < len; i2++) {
      if (createDebug2.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug2.enable(createDebug2.load());
  return createDebug2;
}
var common$1 = setup$1;
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m2;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces2) {
    try {
      if (namespaces2) {
        exports2.storage.setItem("debug", namespaces2);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = void 0;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = common$1(exports2);
  const { formatters } = module2.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser$1, browser$1.exports);
var browserExports$1 = browser$1.exports;
const createDebug$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
const config = {
  cacheResults: true,
  successMetric: "efficiency",
  calculateCuts: true,
  stack: true,
  findDuplicatePatterns: true,
  //dev specific
  captureProfile: false,
  runTests: false,
  throwErrorsOnFailedTests: false,
  // recordPlacementPositions: isDevOrTest ? true : false,
  sample: {
    enable: true,
    groupSize: 6,
    efficiency: 4,
    guillotine: 2
  },
  priority: {
    enable: true,
    variationThreshold: 0.3
  },
  secondRun: {
    enabled: false,
    efficiencyCutoff: 0.5,
    stack: false
  },
  efficiency: {
    tidy: false,
    //[] issue with picking winner when tidy is enabled
    rayCasting: true
  },
  groups: {
    shapeAreaCutOff: 0.7,
    tolerance: 0.04,
    guillotine: {
      strips: true,
      segments: true,
      runWithout: false
    },
    efficiency: {
      firstShapes: true,
      position: true,
      limit: 100
    }
  },
  guillotine: {
    viableShapeArea: 0.5,
    secondPass: true,
    strips: {
      rearrange: true,
      efficiencyThreshold: 0.7
    },
    stripShapes: {
      allocation: true,
      iterations: 6,
      numPriorityShapes: 1
    }
  },
  subset: {
    shuffles: 80,
    //this is the default - can be overwritten (for example when creating groups)
    guillotine: {
      shuffles: 80
    },
    efficiency: {
      limit: 0.5
    }
  },
  evo: {
    disable: false,
    stockLimit: 40
  }
};
config$1.showDiff = true;
const debug = createDebug$1("tests");
createDebug$1("timers");
function isDev() {
  if (typeof process !== "undefined" && (process == null ? void 0 : process.env)) {
    return false;
  }
  return false;
}
function test(tests, issueMessage = null) {
  if (!(tests == null ? void 0 : tests.length)) return;
  if (isDev() && config.runTests) {
    for (const test2 of tests) {
      try {
        test2();
      } catch (e) {
        if (issueMessage) {
          debug(issueMessage, e.message);
        } else {
          debug(e.message);
        }
      }
    }
  }
}
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type3 = (match[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w2;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env) {
  createDebug2.debug = createDebug2;
  createDebug2.default = createDebug2;
  createDebug2.coerce = coerce;
  createDebug2.disable = disable;
  createDebug2.enable = enable;
  createDebug2.enabled = enabled;
  createDebug2.humanize = requireMs();
  createDebug2.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug2[key] = env[key];
  });
  createDebug2.names = [];
  createDebug2.skips = [];
  createDebug2.formatters = {};
  function selectColor(namespace2) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace2.length; i2++) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
  }
  createDebug2.selectColor = selectColor;
  function createDebug2(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug2.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug2.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug2.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.useColors = createDebug2.useColors();
    debug2.color = createDebug2.selectColor(namespace2);
    debug2.extend = extend2;
    debug2.destroy = createDebug2.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug2.namespaces) {
          namespacesCache = createDebug2.namespaces;
          enabledCache = createDebug2.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v2) => {
        enableOverride = v2;
      }
    });
    if (typeof createDebug2.init === "function") {
      createDebug2.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace2, delimiter) {
    const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces2) {
    createDebug2.save(namespaces2);
    createDebug2.namespaces = namespaces2;
    createDebug2.names = [];
    createDebug2.skips = [];
    let i2;
    const split = (typeof namespaces2 === "string" ? namespaces2 : "").split(/[\s,]+/);
    const len = split.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces2 = split[i2].replace(/\*/g, ".*?");
      if (namespaces2[0] === "-") {
        createDebug2.skips.push(new RegExp("^" + namespaces2.slice(1) + "$"));
      } else {
        createDebug2.names.push(new RegExp("^" + namespaces2 + "$"));
      }
    }
  }
  function disable() {
    const namespaces2 = [
      ...createDebug2.names.map(toNamespace),
      ...createDebug2.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug2.enable("");
    return namespaces2;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug2.skips.length; i2 < len; i2++) {
      if (createDebug2.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug2.names.length; i2 < len; i2++) {
      if (createDebug2.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug2.enable(createDebug2.load());
  return createDebug2;
}
var common = setup;
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m2;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces2) {
    try {
      if (namespaces2) {
        exports2.storage.setItem("debug", namespaces2);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = void 0;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = common(exports2);
  const { formatters } = module2.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const createDebug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
createDebug.colors = [
  2,
  3,
  4,
  5,
  7,
  9,
  10,
  11,
  14,
  159
];
createDebug("logs");
createDebug("cuts");
createDebug("guillotine");
createDebug("results");
createDebug("scoring");
createDebug("calculations");
createDebug("subset");
createDebug("secondRun");
createDebug("stack");
const errorDebug = createDebug("errors");
createDebug("allStock");
errorDebug.color = 1;
function getCutLength(cut) {
  if (cut == null ? void 0 : cut.dimension) {
    switch (cut.dimension) {
      case "l":
        return cut.x2 - cut.x1;
      case "w":
        return cut.y2 - cut.y1;
    }
  }
  switch (cut.type) {
    case "top":
    case "bottom":
      return cut.x2 - cut.x1;
    case "left":
    case "right":
      return cut.y2 - cut.y1;
  }
  return 0;
}
class Cut extends Line {
  //used to mark for removal
  constructor(data) {
    var _a3, _b2, _c, _d;
    if (data.x2 < data.x1) [data.x1, data.x2] = [data.x2, data.x1];
    if (data.y2 < data.y1) [data.y1, data.y2] = [data.y2, data.y1];
    super(data);
    __publicField(this, "stock");
    __publicField(this, "stockId");
    __publicField(this, "guillotine");
    __publicField(this, "guillotineData");
    __publicField(this, "isTrim");
    __publicField(this, "distances");
    __publicField(this, "beamTrimX1");
    __publicField(this, "beamTrimY1");
    __publicField(this, "type", null);
    __publicField(this, "remove");
    if (valueSet(data == null ? void 0 : data.stock)) {
      if (((_b2 = (_a3 = data.stock) == null ? void 0 : _a3.constructor) == null ? void 0 : _b2.name) === "Stock")
        this.stock = data.stock;
      else this.stock = new Stock(data.stock);
      this.stockId = this.stock.id;
    }
    this.stockId = (_c = data == null ? void 0 : data.stock) == null ? void 0 : _c.id;
    this.type = data.type ?? null;
    this.guillotine = data.guillotine;
    this.guillotineData = valueSet(data.guillotineData) ? data.guillotineData : {};
    this.guillotineData.ptxDummyCut = (data == null ? void 0 : data.ptxDummyCut) || ((_d = data == null ? void 0 : data.guillotineData) == null ? void 0 : _d.ptxDummyCut) || false;
    this.isTrim = valueSet(data.isTrim) ? data.isTrim : false;
    this.distances = valueSet(data.distances) ? data.distances : {};
    this.beamTrimX1 = data.beamTrimX1;
    this.beamTrimY1 = data.beamTrimY1;
  }
  //compress for saving / transfer
  compress() {
    var _a3;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((_a3 = this == null ? void 0 : this.stock) == null ? void 0 : _a3.id);
    delete this.shapeCollisions;
    delete this.stock;
  }
  clone() {
    const data = structuredClone(this);
    return new Cut(data);
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
  trim() {
    if (this.dimension === "l") {
      this.x1 = this.x1 < 0 ? 0 : this.x1;
      this.x2 = this.x2 > this.stock.l ? this.stock.l : this.x2;
    } else if (this.dimension === "w") {
      this.y1 = this.y1 < 0 ? 0 : this.y1;
      this.y2 = this.y2 > this.stock.w ? this.stock.w : this.y2;
    }
  }
  lookupDirectionByType(type3) {
    const directionLookup = {
      top: "l",
      bottom: "l",
      left: "w",
      right: "w"
    };
    const result = directionLookup[type3];
    if (result) return result;
    throw new Error("no direction found in lookupDirectionByType");
  }
  isInsideStock() {
    switch (this.type) {
      case "bottom":
        return maths.greaterThan(
          this.y1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "left":
        return maths.greaterThan(
          this.x1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "top":
        return maths.lessThan(
          this.y1 - this.stock.getBladeWidth() / 2,
          this.stock.w
        );
      case "right":
        return maths.lessThan(
          this.x1 - this.stock.getBladeWidth() / 2,
          this.stock.l
        );
      default:
        return true;
    }
  }
  /**
      * the cuts are visualised differently from their exact dimensions
      * @param {string} coord
      */
  getVisCoords(coord) {
    return this[coord];
  }
  getLength() {
    return getCutLength(this);
  }
  getArea() {
    if (!this.stock) return 0;
    const cutLength = this.getLength();
    if (cutLength) return cutLength * this.stock.getBladeWidth();
    return 0;
  }
}
const raycastPointToShapePositionMap = {
  "tb": {
    "bottomLeft": {
      "top": "topRight",
      "topLeft": "topLeft"
    },
    "bottomRight": {
      "top": "topLeft",
      "topRight": "topRight"
    }
  },
  "bt": {
    "topLeft": {
      "bottom": "bottomRight",
      "bottomLeft": "bottomLeft"
    },
    "topRight": {
      "bottom": "bottomLeft",
      "bottomRight": "bottomRight"
    }
  },
  "lr": {
    "topRight": {
      "left": "bottomLeft",
      "topLeft": "topLeft"
    },
    "bottomRight": {
      "left": "topLeft",
      "bottomLeft": "bottomLeft"
    }
  },
  "rl": {
    "topLeft": {
      "right": "bottomRight",
      "topRight": "topRight"
    },
    "bottomLeft": {
      "right": "topRight",
      "bottomRight": "bottomRight"
    }
  }
};
const guillotinePointToShapePositionMap = {
  "topLeft": {
    "top": ["topRight"],
    "default": ["topRight"]
  },
  "bottomRight": {
    "right": ["topRight"],
    "default": ["topRight"]
  }
};
const efficiencyPointToShapePositionMap = {
  "topRight": {
    "top": ["topLeft"],
    "right": ["bottomRight"],
    "default": ["topLeft", "bottomRight"]
  },
  "topLeft": {
    "top": ["topRight"],
    "left": ["bottomLeft"],
    "default": ["topRight", "bottomLeft"]
  },
  "bottomRight": {
    "bottom": ["bottomLeft"],
    "right": ["topRight"],
    "default": ["bottomLeft", "topRight"]
  },
  "bottomLeft": {
    "bottom": ["bottomRight"],
    "left": ["topLeft"],
    "default": ["bottomRight", "topLeft"]
  }
};
class Point {
  constructor(x2, y2, z2 = null) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "z");
    __publicField(this, "a");
    //shape id
    __publicField(this, "b");
    //shape id
    __publicField(this, "direction");
    //direction of the raay
    __publicField(this, "type");
    //[] need to type
    __publicField(this, "corner");
    //originating corner of this point
    __publicField(this, "grid");
    //if a grid point, which grid position
    __publicField(this, "stockID");
    __publicField(this, "raycast");
    __publicField(this, "collision");
    __publicField(this, "tooClose");
    __publicField(this, "adjustedForMinSpacing");
    this.x = parseFloat(x2);
    this.y = parseFloat(y2);
    this.z = parseFloat(z2) || 0;
    this.validate();
  }
  /**
   * clone with the ability to change the coordinates
   * NOTE: looks odd for performance reasons
   */
  clone(x2 = null, y2 = null) {
    const point = new Point(x2 ?? this.x, y2 ?? this.y);
    for (const key in this) {
      if (key !== "x" && key !== "y") {
        point[key] = this[key];
      }
    }
    return point;
  }
  validate() {
    if (isNaN(this.x) || isNaN(this.y))
      throw new Error("invalid point coordinates");
  }
  coords() {
    return {
      x: this.x,
      y: this.y
    };
  }
  collidesWith(shape) {
    return this.x >= shape.x && this.x <= shape.x + shape.l && this.y >= shape.y && this.y <= shape.y + shape.w;
  }
  isIdenticalTo(point) {
    return this.x === point.x && this.y === point.y;
  }
  /**
   * given a point from a shape corner or a ray, get the available positions for this shape
   * @returns the position of the shape relative to the point e.g. bottomRight means the shape is placed to the bottom right of the point
   * @remarks does not cater for diagonals
   */
  //[x] needs to cater for raycast coords, which don't originate from a shape corner
  //[x] cater for raycast corners and grid
  getAvailableShapePositions(container) {
    const availableShapePositions = /* @__PURE__ */ new Set();
    if (this.raycast) {
      const directionMap = raycastPointToShapePositionMap[this.direction];
      if (directionMap && directionMap[this.corner] && directionMap[this.corner][this.grid]) {
        availableShapePositions.add(directionMap[this.corner][this.grid]);
      }
      return availableShapePositions;
    }
    if ((container == null ? void 0 : container.cutType) !== "efficiency") {
      if (guillotinePointToShapePositionMap[this.corner]) {
        if (!this.grid) {
          guillotinePointToShapePositionMap[this.corner].default.forEach((pos) => availableShapePositions.add(pos));
        } else if (guillotinePointToShapePositionMap[this.corner][this.grid]) {
          guillotinePointToShapePositionMap[this.corner][this.grid].forEach((pos) => availableShapePositions.add(pos));
        }
      }
      return availableShapePositions;
    }
    if (efficiencyPointToShapePositionMap[this.corner]) {
      if (!this.grid) {
        efficiencyPointToShapePositionMap[this.corner].default.forEach((pos) => availableShapePositions.add(pos));
      } else if (efficiencyPointToShapePositionMap[this.corner][this.grid]) {
        efficiencyPointToShapePositionMap[this.corner][this.grid].forEach((pos) => availableShapePositions.add(pos));
      }
    }
    return availableShapePositions;
  }
}
class PointCollection {
  constructor(points = []) {
    __publicField(this, "points", /* @__PURE__ */ new Map());
    points.forEach((p2) => this.addPoint(p2));
  }
  addPoint(p2, type3 = null) {
    if (this.contains(p2)) {
      const existingPoint = this.getPoint(p2);
      if (existingPoint.type === "group" && !type3) {
        existingPoint.type = void 0;
      }
      return;
    }
    p2.validate();
    if (type3) p2.type = type3;
    this.points.set(this.createKey(p2), p2);
  }
  addPoints(points, type3 = null) {
    for (const p2 of points) {
      if (!p2) return;
      p2.validate();
      this.addPoint(p2, type3);
    }
  }
  createKey(p2) {
    return `${p2.x},${p2.y}`;
  }
  getPoint(p2) {
    return this.points.get(this.createKey(p2));
  }
  deletePoint(p2) {
    p2.validate();
    this.points.delete(this.createKey(p2));
  }
  deletePoints(points) {
    for (const p2 of points) {
      p2.validate();
      this.deletePoint(p2);
    }
  }
  clear() {
    this.points.clear();
  }
  toArray() {
    return Array.from(this.points.values());
  }
  contains(p2) {
    return this.points.has(this.createKey(p2));
  }
}
function getGridPoint(gridPostion, centre, spacing, corner, direction) {
  const gridPoint = gridPointCalculations[gridPostion](centre, spacing);
  if (corner) gridPoint.corner = corner;
  if (direction) gridPoint.direction = direction;
  return gridPoint;
}
const gridPointCalculations = {
  bottom: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x, p2.y - spacing);
    gridPoint.grid = "bottom";
    return gridPoint;
  },
  bottomLeft: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x - spacing, p2.y - spacing);
    gridPoint.grid = "bottomLeft";
    return gridPoint;
  },
  bottomRight: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x + spacing, p2.y - spacing);
    gridPoint.grid = "bottomRight";
    return gridPoint;
  },
  left: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x - spacing, p2.y);
    gridPoint.grid = "left";
    return gridPoint;
  },
  centre: (p2) => {
    const gridPoint = p2.clone(p2.x, p2.y);
    gridPoint.grid = "centre";
    return gridPoint;
  },
  right: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x + spacing, p2.y);
    gridPoint.grid = "right";
    return gridPoint;
  },
  top: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x, p2.y + spacing);
    gridPoint.grid = "top";
    return gridPoint;
  },
  topLeft: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x - spacing, p2.y + spacing);
    gridPoint.grid = "topLeft";
    return gridPoint;
  },
  topRight: (p2, spacing) => {
    const gridPoint = p2.clone(p2.x + spacing, p2.y + spacing);
    gridPoint.grid = "topRight";
    return gridPoint;
  }
};
function createGrid(placedShapes, container, cornerCollection) {
  var _a3, _b2, _c, _d, _e, _f;
  const gridCollection = new PointCollection();
  const sortedCorners = cornerCollection.toArray().sort(pointsSort);
  const bladeWidth = container.getBladeWidth();
  sortedCorners.forEach((cornerPoint) => {
    const corner = cornerPoint.corner;
    const cornerType = cornerPoint.type;
    if (!bladeWidth) {
      gridCollection.addPoint(cornerPoint);
    } else {
      switch (corner) {
        case "topRight":
          gridCollection.addPoint(
            getGridPoint("top", cornerPoint, bladeWidth, corner),
            cornerType
          );
          gridCollection.addPoint(
            getGridPoint("right", cornerPoint, bladeWidth, corner),
            cornerType
          );
          break;
        case "topLeft":
          gridCollection.addPoint(
            getGridPoint("top", cornerPoint, bladeWidth, corner),
            cornerType
          );
          gridCollection.addPoint(
            getGridPoint("left", cornerPoint, bladeWidth, corner),
            cornerType
          );
          break;
        case "bottomRight":
          gridCollection.addPoint(
            getGridPoint("bottom", cornerPoint, bladeWidth, corner),
            cornerType
          );
          gridCollection.addPoint(
            getGridPoint("right", cornerPoint, bladeWidth, corner),
            cornerType
          );
          break;
        case "bottomLeft":
          gridCollection.addPoint(
            getGridPoint("bottom", cornerPoint, bladeWidth, corner),
            cornerType
          );
          gridCollection.addPoint(
            getGridPoint("left", cornerPoint, bladeWidth, corner),
            cornerType
          );
          break;
      }
    }
    const gridCollectionArray = gridCollection.toArray();
    if (bladeWidth) {
      for (let i2 = gridCollectionArray.length; i2--; ) {
        const gridPoint = gridCollectionArray[i2];
        if (cornerCollection.contains(gridPoint)) {
          gridCollection.deletePoint(gridPoint);
        }
      }
    } else {
      for (let i2 = gridCollectionArray.length; i2--; ) {
        const gridPoint = gridCollectionArray[i2];
        for (let j2 = placedShapes.length; j2--; ) {
          const placedShape = placedShapes[j2];
          if (gridPoint.x === placedShape.x && gridPoint.y === placedShape.y) {
            gridCollection.deletePoint(gridPoint);
            break;
          }
        }
      }
    }
  });
  if (bladeWidth) {
    const pointsToRemove = /* @__PURE__ */ new Set();
    let minX, minY, maxX, maxY;
    if (((_a3 = container == null ? void 0 : container.constructor) == null ? void 0 : _a3.name) === "Stock" && (container == null ? void 0 : container.trimmed) || ((_b2 = container == null ? void 0 : container.constructor) == null ? void 0 : _b2.name) === "Segment") {
      minX = container.x;
      minY = container.y;
      maxX = container.x + container.l;
      maxY = container.y + container.w;
    } else {
      minX = container.x + ((_c = container == null ? void 0 : container.trim) == null ? void 0 : _c.x1);
      minY = container.y + ((_d = container == null ? void 0 : container.trim) == null ? void 0 : _d.y1);
      maxX = container.x + container.l - ((_e = container == null ? void 0 : container.trim) == null ? void 0 : _e.x2);
      maxY = container.y + container.w - ((_f = container == null ? void 0 : container.trim) == null ? void 0 : _f.y2);
    }
    let gridArray = gridCollection.toArray();
    for (let i2 = gridArray.length; i2--; ) {
      const point = gridArray[i2];
      if (maths.lessThan(point.x, minX) || maths.lessThan(point.y, minY) || maths.greaterThan(point.x, maxX) || maths.greaterThan(point.y, maxY)) {
        gridArray.splice(i2, 1);
      }
    }
    gridCollection.clear();
    gridCollection.addPoints(gridArray);
    pointsToRemove.clear();
    gridArray = gridCollection.toArray();
    for (let i2 = gridArray.length; i2--; ) {
      const point = gridArray[i2];
      for (let j2 = placedShapes.length; j2--; ) {
        const placedShape = placedShapes[j2];
        if (point.collidesWith(placedShape)) {
          gridCollection.deletePoint(point);
          break;
        }
      }
    }
  }
  return gridCollection;
}
function convertRaycastCollisionPointToShapePositions(shape, point, container) {
  let points = [];
  const minSpacing = shape.getMinSpacing(container);
  const corner = point.corner;
  const direction = point.direction;
  if (point.type === "shape") {
    switch (corner) {
      case "topLeft":
        if (direction === "rl") {
          points.push(getGridPoint("right", point, minSpacing, corner, direction));
          points.push(getGridPoint("topRight", point, minSpacing, corner, direction));
        }
        if (direction === "bt") {
          points.push(getGridPoint("bottom", point, minSpacing, corner, direction));
          points.push(getGridPoint("bottomLeft", point, minSpacing, corner, direction));
        }
        break;
      case "topRight":
        if (direction === "lr") {
          points.push(getGridPoint("left", point, minSpacing, corner, direction));
          points.push(getGridPoint("topLeft", point, minSpacing, corner, direction));
        }
        if (direction === "bt") {
          points.push(getGridPoint("bottom", point, minSpacing, corner, direction));
          points.push(getGridPoint("bottomRight", point, minSpacing, corner, direction));
        }
        break;
      case "bottomRight":
        if (direction === "lr") {
          points.push(getGridPoint("left", point, minSpacing, corner, direction));
          points.push(getGridPoint("bottomLeft", point, minSpacing, corner, direction));
        }
        if (direction === "tb") {
          points.push(getGridPoint("top", point, minSpacing, corner, direction));
          points.push(getGridPoint("topRight", point, minSpacing, corner, direction));
        }
        break;
      case "bottomLeft":
        if (direction === "rl") {
          points.push(getGridPoint("right", point, minSpacing, corner, direction));
          points.push(getGridPoint("bottomRight", point, minSpacing, corner, direction));
        }
        if (direction === "tb") {
          points.push(getGridPoint("top", point, minSpacing, corner, direction));
          points.push(getGridPoint("topLeft", point, minSpacing, corner, direction));
        }
        break;
    }
  } else if (point.type === "edge") {
    switch (direction) {
      case "rl":
      case "lr":
        points.push(getGridPoint("top", point, 0));
        points.push(getGridPoint("centre", point, 0));
        points.push(getGridPoint("bottom", point, 0));
        break;
      case "tb":
      case "bt":
        points.push(getGridPoint("left", point, 0));
        points.push(getGridPoint("right", point, 0));
        points.push(getGridPoint("centre", point, 0));
        break;
    }
  }
  points = points.filter((c2) => c2.x >= 0 && c2.y >= 0);
  if (!points.length) return null;
  const shapePositions = new PointCollection();
  for (const p2 of points) {
    p2.raycast = true;
    shapePositions.addPoints(convertPointToShapePositions(shape, p2, container).toArray());
  }
  removeOutOfBoundsPoints(shape, container, shapePositions);
  return shapePositions;
}
function getCorners(shapes, container) {
  const cornerCollection = new PointCollection();
  shapes.sort(pointsSort);
  shapes.forEach((s2) => {
    if (isGroup(s2)) {
      cornerCollection.addPoints(s2.getCoords(container));
      s2.shapes.forEach((gs) => {
        const points = gs.getCoords(container);
        cornerCollection.addPoints(points, "group");
      });
    } else {
      cornerCollection.addPoints(s2.getCoords(container));
    }
  });
  cornerCollection.points.forEach((p2) => {
    p2.stockID = container.getStock().id;
  });
  return cornerCollection;
}
function getPlacementPositions(addedShapes = [], placedShapes, container) {
  const cornerCollection = getCorners(
    addedShapes === null ? placedShapes : addedShapes,
    container
  );
  const gridCollection = createGrid(
    placedShapes,
    container,
    cornerCollection
  );
  return gridCollection;
}
function pointsSort(a2, b2) {
  if (a2.y === b2.y) return b2.x - a2.x;
  return b2.y - a2.y;
}
function addDataToPoint(point, shapeA, shapeB, direction, type3, corner) {
  point.a = shapeA.id;
  point.b = shapeB ? shapeB.id : null;
  point.direction = direction;
  point.raycast = true;
  point.type = type3;
  point.corner = corner;
}
function getRayCastCoordinates(container, placedShapes) {
  if (container.saw.cutType !== "efficiency" || placedShapes.length <= 1) return null;
  let pointCollection = new PointCollection();
  const shapeRays = precomputeShapeRays(placedShapes, container);
  for (const placedShape of placedShapes) {
    for (const shapeRay of shapeRays) {
      if (shapeRay.shape.id === placedShape.id) continue;
      const rays = Object.values(shapeRay.rays);
      for (const ray of rays) {
        processRayCollision(
          ray,
          shapeRay.shape,
          placedShape,
          pointCollection
        );
      }
    }
  }
  const saw = container.saw;
  const requiredFromDirection = saw.efficiencyOptions.primaryCompression === "x" ? "lr" : "tb";
  const edgeRaycastShape = placedShapes.reduce((a2, b2) => {
    return (requiredFromDirection === "tb" ? a2.x + a2.l > b2.x + b2.l : a2.y + a2.w > b2.y + b2.w) ? a2 : b2;
  });
  shapeRays.filter(({ shape }) => shape.id === edgeRaycastShape.id).forEach(({ shape, rays }) => {
    const raycastLines = Object.values(rays);
    for (const ray of raycastLines) {
      const p2 = new Point(ray.x2, ray.y2);
      if (requiredFromDirection === ray.direction) {
        addDataToPoint(p2, shape, null, ray.direction, "edge");
        pointCollection.addPoint(p2);
      }
    }
  });
  pointCollection = filterClosestPoints(pointCollection);
  return pointCollection;
}
function precomputeShapeRays(placedShapes, container) {
  return placedShapes.map((shape) => {
    const rays = rayCastRectangle(shape, container);
    return {
      shape,
      rays
    };
  });
}
function processRayCollision(ray, shapeA, shapeB, collection) {
  switch (ray.direction) {
    case "rl":
      checkAndAddCollisionPoint(
        ray,
        shapeA,
        shapeB,
        collection,
        shapeB.x + shapeB.l
      );
      break;
    case "lr":
      checkAndAddCollisionPoint(
        ray,
        shapeA,
        shapeB,
        collection,
        shapeB.x
      );
      break;
    case "tb":
      checkAndAddCollisionPoint(
        ray,
        shapeA,
        shapeB,
        collection,
        shapeB.y + shapeB.w
      );
      break;
    case "bt":
      checkAndAddCollisionPoint(
        ray,
        shapeA,
        shapeB,
        collection,
        shapeB.y
      );
      break;
  }
}
function checkAndAddCollisionPoint(ray, shapeA, shapeB, collection, collisionCoordinate) {
  const isVerticalRay = ray.dimension === "w";
  const rayPrimaryAxis = isVerticalRay ? "y" : "x";
  const raySecondaryAxis = isVerticalRay ? "x" : "y";
  const secondaryDimension = isVerticalRay ? "l" : "w";
  if (ray[`${raySecondaryAxis}1`] >= shapeB[raySecondaryAxis] && ray[`${raySecondaryAxis}1`] <= shapeB[raySecondaryAxis] + shapeB[secondaryDimension]) {
    const collisionFromLeft = ray.direction === "lr" && ray[`${rayPrimaryAxis}1`] <= collisionCoordinate && ray[`${rayPrimaryAxis}2`] >= collisionCoordinate;
    const collisionFromRight = ray.direction === "rl" && ray[`${rayPrimaryAxis}1`] >= collisionCoordinate && ray[`${rayPrimaryAxis}2`] <= collisionCoordinate;
    const collisionFromBottom = ray.direction === "bt" && ray[`${rayPrimaryAxis}1`] <= collisionCoordinate && ray[`${rayPrimaryAxis}2`] >= collisionCoordinate;
    const collisionFromTop = ray.direction === "tb" && ray[`${rayPrimaryAxis}1`] >= collisionCoordinate && ray[`${rayPrimaryAxis}2`] <= collisionCoordinate;
    const collision = collisionFromLeft || collisionFromRight || collisionFromBottom || collisionFromTop;
    if (collision) {
      const pointCoordX = isVerticalRay ? ray[`${raySecondaryAxis}1`] : collisionCoordinate;
      const pointCoordY = isVerticalRay ? collisionCoordinate : ray[`${raySecondaryAxis}1`];
      const point = new Point(pointCoordX, pointCoordY);
      const corner = ray.origin;
      addDataToPoint(point, shapeA, shapeB, ray.direction, "shape", corner);
      collection.addPoint(point);
    }
  }
}
function filterClosestPoints(collection) {
  const filteredPoints = new PointCollection();
  if (collection.points.size === 0) return filteredPoints;
  const originShapes = new Set(collection.toArray().map((p2) => p2.a));
  originShapes.forEach((shape) => {
    const startingShapePoints = collection.toArray().filter((p2) => p2.a === shape);
    ["right", "left", "top", "bottom"].forEach((direction) => {
      const point = findClosestPointInDirection(
        startingShapePoints,
        direction
      );
      if (point) filteredPoints.addPoint(point);
    });
  });
  return filteredPoints;
}
function findClosestPointInDirection(points, direction) {
  if (points.length === 0) return null;
  return points.reduce((closest, current) => {
    switch (direction) {
      case "left":
        return !closest || current.x < closest.x ? current : closest;
      case "right":
        return !closest || current.x > closest.x ? current : closest;
      case "top":
        return !closest || current.y > closest.y ? current : closest;
      case "bottom":
        return !closest || current.y < closest.y ? current : closest;
      default:
        return null;
    }
  }, null);
}
function convertPointToShapePositions(shape, point, container) {
  const collection = new PointCollection();
  const availableShapePositions = point.getAvailableShapePositions(container);
  for (const position of availableShapePositions) {
    let p2;
    p2 = adjustPointForMimumSpacing(point, shape, container);
    switch (position) {
      case "bottomLeft":
        {
          p2 = p2.clone(p2.x - shape.l, p2.y - shape.w);
          p2.shapePosition = "bottomLeft";
        }
        break;
      case "bottomRight":
        {
          p2 = p2.clone(p2.x, p2.y - shape.w);
          p2.shapePosition = "bottomRight";
        }
        break;
      case "topLeft":
        {
          p2 = p2.clone(p2.x - shape.l, p2.y);
          p2.shapePosition = "topLeft";
        }
        break;
      case "topRight":
        {
          p2 = p2.clone(p2.x, p2.y);
          p2.shapePosition = "topRight";
        }
        break;
    }
    collection.addPoint(p2);
  }
  removeOutOfBoundsPoints(shape, container, collection);
  return collection;
}
function adjustPointForMimumSpacing(point, shape, container) {
  if (container.saw.cutType !== "efficiency") return point;
  const minSpacing = shape.getMinSpacing(container);
  const bladeWidth = container.getBladeWidth();
  if (!minSpacing) return point;
  if (minSpacing === bladeWidth) return point;
  let newPoint;
  if (!point.grid) return point;
  switch (point.grid) {
    case "bottom":
      newPoint = point.clone(point.x, point.y - minSpacing + bladeWidth);
      break;
    case "top":
      newPoint = point.clone(point.x, point.y + minSpacing - bladeWidth);
      break;
    case "left":
      newPoint = point.clone(point.x - minSpacing + bladeWidth, point.y);
      break;
    case "right":
      newPoint = point.clone(point.x + minSpacing - bladeWidth, point.y);
      break;
  }
  if (!newPoint) return point;
  if (newPoint.x < 0) newPoint.x = 0;
  if (newPoint.y < 0) newPoint.y = 0;
  newPoint.adjustedForMinSpacing = true;
  return newPoint;
}
function removeOutOfBoundsPoints(shape, container, collection) {
  var _a3, _b2, _c, _d, _e, _f;
  let minX, minY, maxX, maxY;
  if (((_a3 = container == null ? void 0 : container.constructor) == null ? void 0 : _a3.name) === "Stock" && (container == null ? void 0 : container.trimmed) || ((_b2 = container == null ? void 0 : container.constructor) == null ? void 0 : _b2.name) === "Segment") {
    minX = 0;
    minY = 0;
    maxX = container.x + container.l - shape.l;
    maxY = container.y + container.w - shape.w;
  } else {
    minX = (_c = container == null ? void 0 : container.trim) == null ? void 0 : _c.x1;
    minY = (_d = container == null ? void 0 : container.trim) == null ? void 0 : _d.y1;
    maxX = container.l - ((_e = container == null ? void 0 : container.trim) == null ? void 0 : _e.x2) - shape.l;
    maxY = container.w - ((_f = container == null ? void 0 : container.trim) == null ? void 0 : _f.y2) - shape.w;
  }
  const pointsArray = collection.toArray();
  for (let i2 = pointsArray.length; i2--; ) {
    const p2 = pointsArray[i2];
    if (maths.lessThan(p2.x, minX) || maths.lessThan(p2.y, minY) || maths.greaterThan(p2.x, maxX) || maths.greaterThan(p2.y, maxY) || p2.x < 0 || p2.y < 0)
      collection.deletePoint(p2);
  }
}
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
var MAX_CYCLE_LEN = 2e3;
var P$1 = {
  "s": 1,
  "n": 0,
  "d": 1
};
function assign(n2, s2) {
  if (isNaN(n2 = parseInt(n2, 10))) {
    throw InvalidParameter();
  }
  return n2 * s2;
}
function newFraction(n2, d2) {
  if (d2 === 0) {
    throw DivisionByZero();
  }
  var f2 = Object.create(Fraction.prototype);
  f2["s"] = n2 < 0 ? -1 : 1;
  n2 = n2 < 0 ? -n2 : n2;
  var a2 = gcd(n2, d2);
  f2["n"] = n2 / a2;
  f2["d"] = d2 / a2;
  return f2;
}
function factorize(num) {
  var factors = {};
  var n2 = num;
  var i2 = 2;
  var s2 = 4;
  while (s2 <= n2) {
    while (n2 % i2 === 0) {
      n2 /= i2;
      factors[i2] = (factors[i2] || 0) + 1;
    }
    s2 += 1 + 2 * i2++;
  }
  if (n2 !== num) {
    if (n2 > 1)
      factors[n2] = (factors[n2] || 0) + 1;
  } else {
    factors[num] = (factors[num] || 0) + 1;
  }
  return factors;
}
var parse$1 = function(p1, p2) {
  var n2 = 0, d2 = 1, s2 = 1;
  var v2 = 0, w2 = 0, x2 = 0, y2 = 1, z2 = 1;
  var A2 = 0, B2 = 1;
  var C2 = 1, D2 = 1;
  var N2 = 1e7;
  var M2;
  if (p1 === void 0 || p1 === null) ;
  else if (p2 !== void 0) {
    n2 = p1;
    d2 = p2;
    s2 = n2 * d2;
    if (n2 % 1 !== 0 || d2 % 1 !== 0) {
      throw NonIntegerParameter();
    }
  } else
    switch (typeof p1) {
      case "object": {
        if ("d" in p1 && "n" in p1) {
          n2 = p1["n"];
          d2 = p1["d"];
          if ("s" in p1)
            n2 *= p1["s"];
        } else if (0 in p1) {
          n2 = p1[0];
          if (1 in p1)
            d2 = p1[1];
        } else {
          throw InvalidParameter();
        }
        s2 = n2 * d2;
        break;
      }
      case "number": {
        if (p1 < 0) {
          s2 = p1;
          p1 = -p1;
        }
        if (p1 % 1 === 0) {
          n2 = p1;
        } else if (p1 > 0) {
          if (p1 >= 1) {
            z2 = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
            p1 /= z2;
          }
          while (B2 <= N2 && D2 <= N2) {
            M2 = (A2 + C2) / (B2 + D2);
            if (p1 === M2) {
              if (B2 + D2 <= N2) {
                n2 = A2 + C2;
                d2 = B2 + D2;
              } else if (D2 > B2) {
                n2 = C2;
                d2 = D2;
              } else {
                n2 = A2;
                d2 = B2;
              }
              break;
            } else {
              if (p1 > M2) {
                A2 += C2;
                B2 += D2;
              } else {
                C2 += A2;
                D2 += B2;
              }
              if (B2 > N2) {
                n2 = C2;
                d2 = D2;
              } else {
                n2 = A2;
                d2 = B2;
              }
            }
          }
          n2 *= z2;
        } else if (isNaN(p1) || isNaN(p2)) {
          d2 = n2 = NaN;
        }
        break;
      }
      case "string": {
        B2 = p1.match(/\d+|./g);
        if (B2 === null)
          throw InvalidParameter();
        if (B2[A2] === "-") {
          s2 = -1;
          A2++;
        } else if (B2[A2] === "+") {
          A2++;
        }
        if (B2.length === A2 + 1) {
          w2 = assign(B2[A2++], s2);
        } else if (B2[A2 + 1] === "." || B2[A2] === ".") {
          if (B2[A2] !== ".") {
            v2 = assign(B2[A2++], s2);
          }
          A2++;
          if (A2 + 1 === B2.length || B2[A2 + 1] === "(" && B2[A2 + 3] === ")" || B2[A2 + 1] === "'" && B2[A2 + 3] === "'") {
            w2 = assign(B2[A2], s2);
            y2 = Math.pow(10, B2[A2].length);
            A2++;
          }
          if (B2[A2] === "(" && B2[A2 + 2] === ")" || B2[A2] === "'" && B2[A2 + 2] === "'") {
            x2 = assign(B2[A2 + 1], s2);
            z2 = Math.pow(10, B2[A2 + 1].length) - 1;
            A2 += 3;
          }
        } else if (B2[A2 + 1] === "/" || B2[A2 + 1] === ":") {
          w2 = assign(B2[A2], s2);
          y2 = assign(B2[A2 + 2], 1);
          A2 += 3;
        } else if (B2[A2 + 3] === "/" && B2[A2 + 1] === " ") {
          v2 = assign(B2[A2], s2);
          w2 = assign(B2[A2 + 2], s2);
          y2 = assign(B2[A2 + 4], 1);
          A2 += 5;
        }
        if (B2.length <= A2) {
          d2 = y2 * z2;
          s2 = /* void */
          n2 = x2 + d2 * v2 + z2 * w2;
          break;
        }
      }
      default:
        throw InvalidParameter();
    }
  if (d2 === 0) {
    throw DivisionByZero();
  }
  P$1["s"] = s2 < 0 ? -1 : 1;
  P$1["n"] = Math.abs(n2);
  P$1["d"] = Math.abs(d2);
};
function modpow(b2, e, m2) {
  var r = 1;
  for (; e > 0; b2 = b2 * b2 % m2, e >>= 1) {
    if (e & 1) {
      r = r * b2 % m2;
    }
  }
  return r;
}
function cycleLen(n2, d2) {
  for (; d2 % 2 === 0; d2 /= 2) {
  }
  for (; d2 % 5 === 0; d2 /= 5) {
  }
  if (d2 === 1)
    return 0;
  var rem = 10 % d2;
  var t2 = 1;
  for (; rem !== 1; t2++) {
    rem = rem * 10 % d2;
    if (t2 > MAX_CYCLE_LEN)
      return 0;
  }
  return t2;
}
function cycleStart(n2, d2, len) {
  var rem1 = 1;
  var rem2 = modpow(10, len, d2);
  for (var t2 = 0; t2 < 300; t2++) {
    if (rem1 === rem2)
      return t2;
    rem1 = rem1 * 10 % d2;
    rem2 = rem2 * 10 % d2;
  }
  return 0;
}
function gcd(a2, b2) {
  if (!a2)
    return b2;
  if (!b2)
    return a2;
  while (1) {
    a2 %= b2;
    if (!a2)
      return b2;
    b2 %= a2;
    if (!b2)
      return a2;
  }
}
function Fraction(a2, b2) {
  parse$1(a2, b2);
  if (this instanceof Fraction) {
    a2 = gcd(P$1["d"], P$1["n"]);
    this["s"] = P$1["s"];
    this["n"] = P$1["n"] / a2;
    this["d"] = P$1["d"] / a2;
  } else {
    return newFraction(P$1["s"] * P$1["n"], P$1["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  "s": 1,
  "n": 0,
  "d": 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a2, b2) {
    parse$1(a2, b2);
    return newFraction(
      this["s"] * this["n"] * P$1["d"] + P$1["s"] * this["d"] * P$1["n"],
      this["d"] * P$1["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a2, b2) {
    parse$1(a2, b2);
    return newFraction(
      this["s"] * this["n"] * P$1["d"] - P$1["s"] * this["d"] * P$1["n"],
      this["d"] * P$1["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a2, b2) {
    parse$1(a2, b2);
    return newFraction(
      this["s"] * P$1["s"] * this["n"] * P$1["n"],
      this["d"] * P$1["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a2, b2) {
    parse$1(a2, b2);
    return newFraction(
      this["s"] * P$1["s"] * this["n"] * P$1["d"],
      this["d"] * P$1["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  "mod": function(a2, b2) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    if (a2 === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], 1);
    }
    parse$1(a2, b2);
    if (0 === P$1["n"] && 0 === this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P$1["d"] * this["n"]) % (P$1["n"] * this["d"]),
      P$1["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a2, b2) {
    parse$1(a2, b2);
    return newFraction(gcd(P$1["n"], this["n"]) * gcd(P$1["d"], this["d"]), P$1["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a2, b2) {
    parse$1(a2, b2);
    if (P$1["n"] === 0 && this["n"] === 0) {
      return newFraction(0, 1);
    }
    return newFraction(P$1["n"] * this["n"], gcd(P$1["n"], this["n"]) * gcd(P$1["d"], this["d"]));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  "roundTo": function(a2, b2) {
    parse$1(a2, b2);
    return newFraction(this["s"] * Math.round(this["n"] * P$1["d"] / (this["d"] * P$1["n"])) * P$1["n"], P$1["d"]);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a2, b2) {
    parse$1(a2, b2);
    if (P$1["d"] === 1) {
      if (P$1["s"] < 0) {
        return newFraction(Math.pow(this["s"] * this["d"], P$1["n"]), Math.pow(this["n"], P$1["n"]));
      } else {
        return newFraction(Math.pow(this["s"] * this["n"], P$1["n"]), Math.pow(this["d"], P$1["n"]));
      }
    }
    if (this["s"] < 0) return null;
    var N2 = factorize(this["n"]);
    var D2 = factorize(this["d"]);
    var n2 = 1;
    var d2 = 1;
    for (var k2 in N2) {
      if (k2 === "1") continue;
      if (k2 === "0") {
        n2 = 0;
        break;
      }
      N2[k2] *= P$1["n"];
      if (N2[k2] % P$1["d"] === 0) {
        N2[k2] /= P$1["d"];
      } else return null;
      n2 *= Math.pow(k2, N2[k2]);
    }
    for (var k2 in D2) {
      if (k2 === "1") continue;
      D2[k2] *= P$1["n"];
      if (D2[k2] % P$1["d"] === 0) {
        D2[k2] /= P$1["d"];
      } else return null;
      d2 *= Math.pow(k2, D2[k2]);
    }
    if (P$1["s"] < 0) {
      return newFraction(d2, n2);
    }
    return newFraction(n2, d2);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a2, b2) {
    parse$1(a2, b2);
    return this["s"] * this["n"] * P$1["d"] === P$1["s"] * P$1["n"] * this["d"];
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "compare": function(a2, b2) {
    parse$1(a2, b2);
    var t2 = this["s"] * this["n"] * P$1["d"] - P$1["s"] * P$1["n"] * this["d"];
    return (0 < t2) - (t2 < 0);
  },
  "simplify": function(eps) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return this;
    }
    eps = eps || 1e-3;
    var thisABS = this["abs"]();
    var cont = thisABS["toContinued"]();
    for (var i2 = 1; i2 < cont.length; i2++) {
      var s2 = newFraction(cont[i2 - 1], 1);
      for (var k2 = i2 - 2; k2 >= 0; k2--) {
        s2 = s2["inverse"]()["add"](cont[k2]);
      }
      if (Math.abs(s2["sub"](thisABS).valueOf()) < eps) {
        return s2["mul"](this["s"]);
      }
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a2, b2) {
    parse$1(a2, b2);
    return !(!(P$1["n"] * this["d"]) || this["n"] * P$1["d"] % (P$1["n"] * this["d"]));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return this["s"] * this["n"] / this["d"];
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  "toFraction": function(excludeWhole) {
    var whole, str = "";
    var n2 = this["n"];
    var d2 = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d2 === 1) {
      str += n2;
    } else {
      if (excludeWhole && (whole = Math.floor(n2 / d2)) > 0) {
        str += whole;
        str += " ";
        n2 %= d2;
      }
      str += n2;
      str += "/";
      str += d2;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(excludeWhole) {
    var whole, str = "";
    var n2 = this["n"];
    var d2 = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d2 === 1) {
      str += n2;
    } else {
      if (excludeWhole && (whole = Math.floor(n2 / d2)) > 0) {
        str += whole;
        n2 %= d2;
      }
      str += "\\frac{";
      str += n2;
      str += "}{";
      str += d2;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    var t2;
    var a2 = this["n"];
    var b2 = this["d"];
    var res = [];
    if (isNaN(a2) || isNaN(b2)) {
      return res;
    }
    do {
      res.push(Math.floor(a2 / b2));
      t2 = a2 % b2;
      a2 = b2;
      b2 = t2;
    } while (a2 !== 1);
    return res;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec) {
    var N2 = this["n"];
    var D2 = this["d"];
    if (isNaN(N2) || isNaN(D2)) {
      return "NaN";
    }
    dec = dec || 15;
    var cycLen = cycleLen(N2, D2);
    var cycOff = cycleStart(N2, D2, cycLen);
    var str = this["s"] < 0 ? "-" : "";
    str += N2 / D2 | 0;
    N2 %= D2;
    N2 *= 10;
    if (N2)
      str += ".";
    if (cycLen) {
      for (var i2 = cycOff; i2--; ) {
        str += N2 / D2 | 0;
        N2 %= D2;
        N2 *= 10;
      }
      str += "(";
      for (var i2 = cycLen; i2--; ) {
        str += N2 / D2 | 0;
        N2 %= D2;
        N2 *= 10;
      }
      str += ")";
    } else {
      for (var i2 = dec; N2 && i2--; ) {
        str += N2 / D2 | 0;
        N2 %= D2;
        N2 *= 10;
      }
    }
    return str;
  }
};
function localeParseFloat(s2) {
  if (!s2) return null;
  s2 = s2.toString().trim();
  if (typeof navigator === "undefined" || typeof navigator.language === "undefined")
    return parseFloat(s2);
  const { thousandsSeparator, decimalSeparator } = getSeparators();
  s2 = Array.from(s2, (c2) => c2 === thousandsSeparator ? "" : c2 === decimalSeparator ? "." : c2).join("");
  return parseFloat(s2);
}
function getSeparators() {
  const locale2 = navigator.language;
  const formattedNumber = 123456789e-2.toLocaleString(locale2);
  const withoutDigits = formattedNumber.replace(/\d/g, "");
  const uniqueCharacters = Array.from(new Set(withoutDigits.split("")));
  let thousandsSeparator = "";
  let decimalSeparator = "";
  if (uniqueCharacters.length === 1) {
    decimalSeparator = uniqueCharacters[0];
  } else if (uniqueCharacters.length === 2) {
    const lastCharacter = formattedNumber[formattedNumber.length - 3];
    if (uniqueCharacters.includes(lastCharacter)) {
      decimalSeparator = lastCharacter;
      thousandsSeparator = uniqueCharacters.find((char) => char !== lastCharacter);
    } else {
      decimalSeparator = uniqueCharacters[1];
      thousandsSeparator = uniqueCharacters[0];
    }
  }
  return { thousandsSeparator, decimalSeparator };
}
function detectFraction(inputString) {
  if (!inputString) return false;
  if (typeof inputString === "number") return false;
  inputString = inputString.toString().replace(/[^0-9/ ]/g, "");
  const fractionRegex = /\b\d+\/\d+\b/g;
  return inputString.match(fractionRegex);
}
function cleanNumericInput(input, parseLocale = false) {
  if (!valueSet(input)) return null;
  if (input === 0) return "0";
  let cleanValue = input.toString().trim();
  if (!cleanValue) return null;
  if (detectFraction(input)) {
    cleanValue = cleanValue.replace(/[^0-9/,. -]/g, "").replace(/  +/g, " ");
    return cleanValue;
  } else {
    cleanValue = cleanValue.replace(/[^0-9,. -]/g, "");
    if (cleanValue.startsWith(".")) cleanValue = "0" + cleanValue;
    let parsed;
    if (parseLocale) {
      parsed = localeParseFloat(cleanValue);
    } else {
      parsed = parseFloat(cleanValue);
    }
    if (parsed) return parsed.toString();
    return null;
  }
}
function createFraction(value2) {
  let parsed;
  try {
    parsed = new Fraction(value2);
  } catch {
    console.log(`issue parsing ${value2} to new Fraction()`);
    parsed = 0;
  }
  return parsed;
}
function convertUnit(value2, to = "decimal", decimalPlaces = false, parseLocale = false, fractionRoundTo = 0) {
  if (!valueSet(value2) || !to) return null;
  if (to !== "decimal" && to !== "fraction") {
    console.error("incorrect conversion type specified for convertUnit");
    return null;
  }
  try {
    const stringValue = cleanNumericInput(value2, parseLocale);
    if (!stringValue) return 0;
    let parsed;
    if (to === "fraction") {
      if (detectFraction(stringValue)) {
        parsed = createFraction(stringValue);
      } else {
        const number2 = parseFloat(stringValue);
        if (Number.isInteger(number2)) {
          parsed = createFraction(stringValue);
        } else {
          parsed = createFraction(number2);
        }
      }
    } else parsed = createFraction(stringValue);
    switch (to) {
      case "fraction":
        if (fractionRoundTo > 0) {
          const decimalValue = parsed.valueOf();
          const rounded = Math.round(decimalValue * fractionRoundTo) / fractionRoundTo;
          parsed = createFraction(rounded);
        }
        return parsed.toFraction(true);
      case "decimal":
        if (decimalPlaces === false || typeof decimalPlaces !== "number") {
          return parsed.valueOf();
        } else {
          const value22 = parsed.valueOf();
          if (value22 === 0) {
            return 0;
          }
          return parseFloat(value22.toFixed(decimalPlaces));
        }
      default:
        return 0;
    }
  } catch (e) {
    console.error(e);
    return 0;
  }
}
function isDecimal(num) {
  let parsed = num;
  if (typeof num !== "number") {
    parsed = parseFloat(num);
  }
  return parsed % 1 !== 0;
}
const validation = {
  customData: (val, index = null) => {
    const issues = [];
    if (typeof val !== "object") {
      issues.push({ message: "Custom data must be an object." });
      return issues;
    }
    Object.entries(val).forEach(([key, value2]) => {
      if (valueSet(value2)) {
        if (!["string", "number", "boolean"].includes(typeof value2)) {
          issues.push({
            message: `Custom data ${key} must be a string, number or boolean.`,
            index
          });
        }
      }
    });
    return issues;
  },
  banding: (val, index = null) => {
    const issues = [];
    if (!valueSet(val)) return [];
    if (typeof val !== "object") {
      issues.push({
        message: "Banding must be an object.",
        field: ["banding"],
        index
      });
      return issues;
    }
    Object.entries(val).forEach(([key, value2]) => {
      if (valueSet(value2)) {
        if (value2 !== true && value2 !== false) {
          issues.push({
            message: `Banding ${key} must be a boolean.`,
            field: ["banding"],
            index
          });
        }
      }
    });
  },
  //when trim provided as number
  partTrim(s2, partTrim, index = null) {
    partTrim = convertUnit(partTrim);
    const l2 = convertUnit(s2.l);
    const w2 = convertUnit(s2.w);
    const trimmedL = l2 - partTrim * 2;
    const trimmedW = w2 - partTrim * 2;
    if (trimmedL < 0 || trimmedW < 0) {
      return [
        {
          message: `When applying trim of ${partTrim}, part is ${trimmedL} x ${trimmedW}.`,
          field: ["trim"],
          index
        }
      ];
    }
    return [];
  },
  //when trim provided as object
  trim: (s2, index = null) => {
    const issues = [];
    if (!valueSet(s2.trim)) return issues;
    mainSides.forEach((key) => {
      if (!valueSet(s2.trim[key])) s2.trim[key] = 0;
    });
    if (!isStock(s2) || isStock(s2) && !(s2 == null ? void 0 : s2.trimmed)) {
      const dimensions = ["l", "w"];
      const [l2, w2] = dimensions.map((dim) => convertUnit(s2[dim]));
      const [x1, x2, y1, y2] = mainSides.map((trim) => convertUnit(s2.trim[trim]));
      const variables = { x1, x2, y1, y2 };
      Object.entries(variables).forEach(([key, value2]) => {
        if (isNaN(value2)) {
          issues.push({
            message: `The value of trim ${userFriendlyFieldMap[key]} is not understood.`,
            field: ["trim"],
            index
          });
        }
      });
      if (l2 && w2 && l2 > 0 && w2 > 0) {
        if (x1 + x2 >= s2.l)
          issues.push({
            message: `Trim W1 + W2 = ${x1 + x2}, which is greater than or equal to total length of ${l2}.`,
            field: ["trim"],
            subField: ["x1", "x2"],
            index
          });
        if (y1 + y2 >= s2.w)
          issues.push({
            message: `Trim L1 + L2 = ${y1 + y2}, which is greater than or equal to total width of ${w2}.`,
            field: ["trim"],
            subField: ["y1", "y2"],
            index
          });
      }
    }
    return issues;
  },
  x: (val, index = null) => {
    const issues = [];
    if (!valueSet(val)) {
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push({ message: `X value is not understood, got ${val}`, index });
      return issues;
    }
    if (val < 0) issues.push({ message: `X must be greater than or equal to zero, got ${val}` });
    return issues;
  },
  y: (val, index = null) => {
    const issues = [];
    if (!valueSet(val)) {
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) issues.push({ message: `Y value is not understood, got ${val}`, index });
    if (val < 0) issues.push({ message: `Y must be greater than or equal to zero, got ${val}`, index });
    return issues;
  },
  l: (val, index = null, min2 = 0) => {
    const issues = [];
    if (!valueSet(val)) {
      issues.push({
        message: "Length is required.",
        field: ["l"],
        index
      });
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push({
        message: `Length value is not understood, got ${val}`,
        field: ["l"],
        index
      });
      return issues;
    }
    if (val < min2) issues.push({
      message: `Length must be greater than or equal to ${min2}, got ${val}`,
      field: ["l"],
      index
    });
    return issues;
  },
  w: (val, index = null, min2 = 0) => {
    const issues = [];
    if (!valueSet(val)) {
      issues.push({
        message: "Width is required.",
        field: ["w"],
        index
      });
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push({
        message: `Width value is not understood, got ${val}`,
        field: ["w"],
        index
      });
      return issues;
    }
    if (val < min2) issues.push({
      message: `Width must be greater than or equal to ${min2}, got ${val}`,
      field: ["w"],
      index
    });
    return issues;
  },
  t: (val, index = null) => {
    const issues = [];
    if (!valueSet(val) || val === "") return issues;
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push({
        message: `Thickness value is not understood, got ${val}`,
        field: ["t"],
        index
      });
      return issues;
    }
    if (val && val <= 0) issues.push({
      message: `Thickness must be greater than zero, got ${val}`,
      field: ["t"],
      index
    });
    return issues;
  },
  q: (val, autoAdd = null, index = null) => {
    const issues = [];
    if (!valueSet(val)) {
      issues.push({
        message: "Quantity should be set.",
        field: ["q"],
        index
      });
      return issues;
    }
    val = parseInt(val);
    if (isNaN(val)) {
      issues.push({
        message: `Quantity value is not understood, got ${val}`,
        field: ["q"],
        index
      });
      return issues;
    }
    if (isDecimal(val)) {
      issues.push({
        message: "Quantity should be an integer.",
        field: ["q"],
        index
      });
    }
    if (val <= 0) {
      if (!autoAdd) {
        issues.push({
          message: `Quantity should be greater than or equal to zero, got ${val}`,
          field: ["q"],
          index
        });
      }
    }
    return issues;
  },
  orientationLock: (val, index = null) => {
    const issues = [];
    if (!valueSet(val)) return issues;
    val = val.toLowerCase();
    if (val !== "l" && val !== "w")
      issues.push({
        message: `Orientation lock must be l or w, got ${val}`,
        field: ["orientationLock"],
        index
      });
    return issues;
  },
  grain: (val, index = null) => {
    const issues = [];
    if (!valueSet(val)) return issues;
    val = val.toLowerCase();
    if (val !== "l" && val !== "w") issues.push({
      message: `Grain must be l or w, got ${val}`,
      index
    });
    return issues;
  },
  stockMatch: (inputShape, inputStockList, stockType, partTrim = 0, index = null) => {
    if (!inputShape.q) return [];
    inputShape.applyPartTrim(partTrim);
    if (inputShape.issues.length) return [];
    const matchResult = stockMatch([inputShape], inputStockList, stockType);
    if (!matchResult) return [];
    const issues = [];
    if (matchResult.unusableShapes.length) {
      const s2 = matchResult.unusableShapes[0];
      const stockMatchData = s2.stockMatch;
      if (!stockMatchData.fit) {
        const dims = s2.getTrimmedDimensions();
        issues.push({
          message: `${dims.l.toFixed(0)}x${dims.w.toFixed(0)} will not fit on any stock - check trim, dimensions & orientation lock.`,
          field: ["l", "w"],
          index
        });
      }
      if (!stockMatchData.material) {
        issues.push({
          message: "No matching stock material found.",
          field: ["material"],
          index
        });
      }
      if (!stockMatchData.thickness) {
        issues.push({
          message: "No matching stock thickness found.",
          field: ["t"],
          index
        });
      }
      if (!stockMatchData.width && stockType === "linear") {
        issues.push({
          message: "No matching stock width found - required for linear calculations.",
          field: ["w"],
          index
        });
      }
    }
    return issues;
  },
  machining: (inputShape, index = null) => {
    inputShape.machining.validateEverything(inputShape, index);
  }
};
function mapLegacyCutPreference(originalCutPreference) {
  let cutType;
  let cutPreference;
  switch (originalCutPreference) {
    case "l":
    case "length":
      cutType = "guillotine";
      cutPreference = "l";
      break;
    case "w":
    case "width":
      cutType = "guillotine";
      cutPreference = "w";
      break;
    case "flex":
      cutType = "guillotine";
      cutPreference = "flex";
      break;
    case "efficiency":
      cutType = "efficiency";
      cutPreference = "none";
      break;
    case "beam":
      cutType = "beam";
      cutPreference = "l";
      break;
    default:
      cutType = null;
      cutPreference = null;
      break;
  }
  return {
    cutPreference,
    cutType
  };
}
var freeGlobal$1 = typeof global == "object" && global && global.Object === Object && global;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal$1 || freeSelf$1 || Function("return this")();
var Symbol$3 = root$2.Symbol;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$3 = objectProto$c.toString;
var symToStringTag$3 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$3), tag = value2[symToStringTag$3];
  try {
    value2[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$3.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$3] = tag;
    } else {
      delete value2[symToStringTag$3];
    }
  }
  return result;
}
var objectProto$b = Object.prototype;
var nativeObjectToString$2 = objectProto$b.toString;
function objectToString$1(value2) {
  return nativeObjectToString$2.call(value2);
}
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$1(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value2) ? getRawTag$1(value2) : objectToString$1(value2);
}
function isObjectLike$1(value2) {
  return value2 != null && typeof value2 == "object";
}
var isArray$1 = Array.isArray;
function isObject$3(value2) {
  var type3 = typeof value2;
  return value2 != null && (type3 == "object" || type3 == "function");
}
function identity$3(value2) {
  return value2;
}
var asyncTag$1 = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$1(value2) {
  if (!isObject$3(value2)) {
    return false;
  }
  var tag = baseGetTag$1(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
}
var coreJsData$1 = root$2["__core-js_shared__"];
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$3 = Function.prototype;
var funcToString$3 = funcProto$3.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$2 = Function.prototype, objectProto$a = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$8).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value2) {
  if (!isObject$3(value2) || isMasked$1(value2)) {
    return false;
  }
  var pattern = isFunction$1(value2) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value2));
}
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative$1(object2, key) {
  var value2 = getValue$1(object2, key);
  return baseIsNative$1(value2) ? value2 : void 0;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant$3(value2) {
  return function() {
    return value2;
  };
}
var defineProperty$1 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var baseSetToString = !defineProperty$1 ? identity$3 : function(func, string2) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$3(string2),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value2, length) {
  var type3 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length && (type3 == "number" || type3 != "symbol" && reIsUint$1.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function eq$1(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
    while (++index < length) {
      array2[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array2);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start) {
  return setToString(overRest(func, start, identity$3), func + "");
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$1;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction$1(value2);
}
function isIterateeCall(value2, index, object2) {
  if (!isObject$3(object2)) {
    return false;
  }
  var type3 = typeof index;
  if (type3 == "number" ? isArrayLike(object2) && isIndex$1(index, object2.length) : type3 == "string" && index in object2) {
    return eq$1(object2[index], value2);
  }
  return false;
}
var objectProto$9 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
  return value2 === proto;
}
function baseTimes(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var argsTag$1 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike$1(value2) && baseGetTag$1(value2) == argsTag$1;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike$1(value2) && hasOwnProperty$7.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root$2.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag$1 = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike$1(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag$1(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject$3(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeysIn(object2);
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var defaults = baseRest(function(object2, sources) {
  object2 = Object(object2);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value2 = object2[key];
      if (value2 === void 0 || eq$1(value2, objectProto$6[key]) && !hasOwnProperty$5.call(object2, key)) {
        object2[key] = source[key];
      }
    }
  }
  return object2;
});
function getBandingCornerPrice(shape, corner, price) {
  if (!cornerSides.includes(corner)) return 0;
  if (!shape.machining.corners) return 0;
  const length = getCornerLength(shape, corner);
  const lengthPrice = price * length;
  return lengthPrice;
}
function getCornerLength(shape, corner) {
  if (!cornerSides.includes(corner)) return 0;
  if (!shape.machining.corners) return 0;
  const relevantCorner = shape.machining.corners.find((c2) => c2.getCorner() === corner);
  if (!relevantCorner) return 0;
  const length = relevantCorner.getLength();
  return length;
}
function extrasValidation(item, extras, issues, index) {
  Object.keys(extras).forEach((key) => {
    var _a3, _b2;
    if (key in item) {
      if (((_a3 = extras[key]) == null ? void 0 : _a3.min) && convertUnit(item[key]) < convertUnit(extras[key].min)) {
        issues.push({
          index,
          message: `${key.charAt(0).toUpperCase() + key.slice(1)} cannot be less than ${extras[key].min}.`,
          fields: [key]
        });
      } else if (((_b2 = extras[key]) == null ? void 0 : _b2.max) && convertUnit(item[key]) > convertUnit(extras[key].max)) {
        issues.push({
          index,
          message: `${key.charAt(0).toUpperCase() + key.slice(1)} cannot be greater than ${extras[key].max}.`,
          fields: [key]
        });
      }
    }
  });
}
class Hole {
  constructor({ x: x2, y: y2, diameter, depth = 0, face = 0, type: type3 = null }) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "diameter");
    __publicField(this, "depth");
    __publicField(this, "face");
    __publicField(this, "valid");
    __publicField(this, "type");
    this.x = x2;
    this.y = y2;
    this.diameter = diameter;
    this.depth = depth;
    this.face = face;
    this.type = type3;
  }
  getFace() {
    return faces[this.face];
  }
  getXDrawPosition(shape) {
    let position = 0;
    const x2 = convertUnit(this.x);
    if (shape.rot) {
      position = shape.l - convertUnit(this.y) + ("x" in shape ? convertUnit(shape.x) : 0);
    } else {
      position = x2 + ("x" in shape ? convertUnit(shape.x) : 0);
    }
    return position;
  }
  getYDrawPosition(shape, viewingFace, stock) {
    let position = shape.rot ? convertUnit(this.x) : convertUnit(this.y);
    position += "y" in shape ? convertUnit(shape.y) : 0;
    if (viewingFace === 1)
      if (stock) {
        position = convertUnit(stock.w) - position;
      } else {
        position = convertUnit(shape.w) - position;
      }
    return position;
  }
  shouldShow(shape, face) {
    if (this.face === face) return true;
    if (this.isThroughShape(shape) === true) return true;
    return false;
  }
  isThroughShape(shape) {
    return !this.depth || convertUnit(this.depth) >= convertUnit(shape.t);
  }
  getDistanceToEdge(shape) {
    const holeCenterX = this.x;
    const holeCenterY = this.y;
    const holeRadius = this.diameter / 2;
    const shapeLength = convertUnit(shape.getLongSide());
    const shapeWidth = convertUnit(shape.getShortSide());
    const cornerRadii = shape.machining.corners.map((c2) => c2.type ? c2.size : 0);
    const edgeDistances = [
      {
        edge: "left",
        distance: holeCenterX - holeRadius
      },
      {
        edge: "right",
        distance: shapeLength - holeCenterX - holeRadius
      },
      {
        edge: "bottom",
        distance: shapeWidth - holeCenterY - holeRadius
      },
      {
        edge: "top",
        distance: holeCenterY - holeRadius
      }
    ];
    const cornerDistances = shape.machining.corners.map((c2, index) => {
      const isLeft = index === 0 || index === 3;
      const isBottom = index < 2;
      const x2 = isLeft ? holeCenterX : shapeLength - holeCenterX;
      let y2 = null;
      if (this.face === 0) {
        y2 = isBottom ? holeCenterY : shapeWidth - holeCenterY;
      } else if (this.face === 1) {
        y2 = isBottom ? shapeWidth - holeCenterY : holeCenterY;
      }
      const distance = Math.sqrt(x2 * x2 + y2 * y2);
      return {
        c: c2,
        distance
      };
    });
    const distanceToNearestEdge = Math.min(...edgeDistances.map((d2) => d2.distance));
    const distanceToNearestCorner = Math.min(...cornerDistances.map((d2) => d2.distance));
    const closestCornerIndex = cornerDistances.findIndex((d2) => d2.distance === distanceToNearestCorner);
    const closestCorner = shape.machining.corners[closestCornerIndex];
    if (closestCorner && closestCorner.type === "radius") {
      let cornerCenterX = closestCornerIndex === 0 || closestCornerIndex === 3 ? 0 : shapeLength;
      let cornerCenterY = closestCornerIndex < 2 ? 0 : shapeWidth;
      const isBottomCorner = closestCornerIndex < 2;
      const isLeftCorner = closestCornerIndex === 0 || closestCornerIndex === 3;
      cornerCenterX += isLeftCorner ? cornerRadii[closestCornerIndex] : -cornerRadii[closestCornerIndex];
      cornerCenterY += isBottomCorner ? cornerRadii[closestCornerIndex] : -cornerRadii[closestCornerIndex];
      const dx = holeCenterX - cornerCenterX;
      const isBottom = closestCornerIndex < 2;
      let y2;
      if (this.face === 0) {
        y2 = isBottom ? holeCenterY : shapeWidth - holeCenterY;
      } else if (this.face === 1) {
        y2 = isBottom ? shapeWidth - holeCenterY : holeCenterY;
      }
      const dy = y2 - cornerCenterY;
      const distanceToCornerCenter = Math.sqrt(dx * dx + dy * dy);
      const distanceToCornerEdge = cornerRadii[closestCornerIndex] - distanceToCornerCenter - holeRadius;
      let inCorrectQuadrant = false;
      if (closestCorner.index === 0) {
        inCorrectQuadrant = holeCenterX <= cornerCenterX && y2 <= cornerCenterY;
      } else if (closestCorner.index === 1) {
        inCorrectQuadrant = holeCenterX >= cornerCenterX && y2 <= cornerCenterY;
      } else if (closestCorner.index === 2) {
        inCorrectQuadrant = holeCenterX >= cornerCenterX && y2 >= cornerCenterY;
      } else if (closestCorner.index === 3) {
        inCorrectQuadrant = holeCenterX <= cornerCenterX && y2 >= cornerCenterY;
      }
      return inCorrectQuadrant && distanceToCornerEdge < distanceToNearestEdge ? distanceToCornerEdge : distanceToNearestEdge;
    } else if (closestCorner && closestCorner.type === "bevel") {
      let A2, B2, C2;
      if (closestCorner.index === 0) {
        A2 = 1;
        B2 = 1;
        C2 = -closestCorner.size;
      } else if (closestCorner.index === 1) {
        A2 = 1;
        B2 = -1;
        C2 = -shapeLength + closestCorner.size;
      } else if (closestCorner.index === 2) {
        A2 = 1;
        B2 = 1;
        C2 = -shapeLength - shapeWidth + closestCorner.size;
      } else if (closestCorner.index === 3) {
        A2 = -1;
        B2 = 1;
        C2 = -shapeWidth + closestCorner.size;
      }
      const multiplier = closestCorner.index === 0 ? 1 : -1;
      const distanceToBevelEdge = (A2 * holeCenterX + B2 * holeCenterY + C2) / Math.sqrt(A2 * A2 + B2 * B2) * multiplier - holeRadius;
      return distanceToBevelEdge < distanceToNearestEdge ? distanceToBevelEdge : distanceToNearestEdge;
    } else {
      return distanceToNearestEdge;
    }
  }
  validate(shape, index, additionalValidation = null) {
    const issues = [];
    if (!valueSet(this.x) || !valueSet(this.y) || !valueSet(this.diameter)) {
      const issue = {
        index,
        message: "X, Y & diameter are all required.",
        fields: []
      };
      if (!this.x) issue.fields.push("x");
      if (!this.y) issue.fields.push("y");
      if (!this.diameter) issue.fields.push("diameter");
      issues.push(issue);
    }
    if (convertUnit(this.diameter) <= 0) {
      issues.push({
        index,
        message: "Diameter cannot be negative or zero.",
        fields: ["diameter"]
      });
    }
    if (convertUnit(this.depth) < 0) {
      issues.push({
        index,
        message: "Depth cannot be negative.",
        fields: ["depth"]
      });
    }
    if ("t" in shape && convertUnit(shape.t) > 0) {
      if (convertUnit(this.depth) > convertUnit(shape.t)) {
        issues.push({
          index,
          message: "Depth cannot be greater than part thickness.",
          fields: ["depth"]
        });
      }
    }
    if (!("t" in shape) || !shape.t) {
      if (convertUnit(this.depth) > 0) {
        issues.push({
          index,
          message: "Part thickness is not defined.",
          fields: ["depth"]
        });
      }
    }
    const distanceToEdge = this.getDistanceToEdge(shape);
    if (distanceToEdge < 0) {
      issues.push({
        index,
        message: "Outside of part."
      });
    }
    if (additionalValidation) {
      extrasValidation(this, additionalValidation, issues, index);
    }
    if (!issues.length) this.valid = true;
    else this.valid = false;
    return issues;
  }
}
class HingeHoles {
  constructor({
    position = null,
    //from left or bottom
    edge = "x1",
    face = 0,
    numHoles = null,
    diameter = 0,
    depth = 0,
    distanceFromEdge = 0,
    outerSpacing = 0,
    hingeLength = 0,
    minimumHoleDistance = 0,
    positionLimit = 0
  }, shape) {
    __publicField(this, "position");
    __publicField(this, "edge");
    __publicField(this, "face");
    __publicField(this, "numHoles");
    __publicField(this, "holes", []);
    __publicField(this, "diameter");
    __publicField(this, "depth");
    __publicField(this, "distanceFromEdge");
    //from edge to center of hole
    __publicField(this, "outerSpacing");
    //from edge to center of hole
    __publicField(this, "hingeLength");
    __publicField(this, "minimumHoleDistance");
    __publicField(this, "positionLimit");
    __publicField(this, "valid");
    this.position = position;
    this.edge = edge;
    this.face = face;
    this.numHoles = numHoles;
    this.diameter = diameter;
    this.depth = depth;
    this.distanceFromEdge = distanceFromEdge;
    this.outerSpacing = outerSpacing;
    this.hingeLength = hingeLength;
    this.minimumHoleDistance = minimumHoleDistance;
    this.positionLimit = positionLimit;
    if (shape) {
      this.createHoles(shape);
    }
  }
  getFace() {
    return faces[this.face];
  }
  getHoleSpacing() {
    const totalSpace = convertUnit(this.hingeLength) - convertUnit(this.outerSpacing) * 2;
    const numSpaces = this.numHoles - 1;
    const holeSpacing = totalSpace / numSpaces;
    return holeSpacing;
  }
  getHoleXPosition(shape, index) {
    let position = 0;
    const spacing = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
        position = this.distanceFromEdge;
        break;
      case "x2":
        position = shape.getLongSide() - convertUnit(this.distanceFromEdge);
        break;
      case "y1":
      case "y2":
        position = convertUnit(this.position) + convertUnit(this.outerSpacing) + spacing * index;
        break;
    }
    return position;
  }
  getHoleYPosition(shape, index) {
    let position = 0;
    const spacing = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
      case "x2":
        position = convertUnit(this.position) + convertUnit(this.outerSpacing) + spacing * index;
        break;
      case "y1":
        position = convertUnit(this.distanceFromEdge);
        break;
      case "y2":
        position = shape.getShortSide() - convertUnit(this.distanceFromEdge);
        break;
    }
    return position;
  }
  createHoles(shape) {
    this.holes = [];
    for (let i2 = 0; i2 < this.numHoles; i2++) {
      const hole = new Hole({
        x: this.getHoleXPosition(shape, i2),
        y: this.getHoleYPosition(shape, i2),
        diameter: this.diameter,
        depth: this.depth,
        face: this.face,
        type: "hinge"
      });
      this.holes.push(hole);
    }
    return this.holes;
  }
  validate(shape, index, additionalValidation = null) {
    const issues = [];
    this.holes.forEach((h2, i2) => {
      const holeIssues = h2.validate(shape, i2).map((m2) => {
        m2.index = index;
        m2.message = `Hole ${i2 + 1}: ${m2.message}`;
        return m2;
      });
      issues.push(...holeIssues);
    });
    if (additionalValidation) {
      extrasValidation(this, additionalValidation, issues, index);
    }
    if (!issues.length) this.valid = true;
    else this.valid = false;
    return issues;
  }
}
class Corner {
  constructor({ type: type3 = "radius", size, index }) {
    __publicField(this, "type");
    __publicField(this, "size");
    __publicField(this, "index");
    __publicField(this, "valid");
    this.type = type3;
    this.size = size;
    this.index = index;
  }
  getLength() {
    if (this.type === "radius") {
      return Math.PI * this.size / 2;
    } else if (this.type === "bevel") {
      return Math.sqrt(2) * this.size;
    }
    return 0;
  }
  getCorner() {
    return ["a", "b", "c", "d"][this.index];
  }
  isPresent() {
    return (this.valid === true || this.valid === void 0) && this.type !== null && this.size > 0;
  }
  validate(shape, index) {
    const shortSide = shape.getShortSide();
    const messages = [];
    if (this.type === null) {
      this.size = null;
      const corner = this.getCorner();
      shape.banding[corner] = false;
    }
    if (this.type && convertUnit(this.size) <= 0) {
      messages.push({
        index,
        message: "Corner size cannot be zero or negative"
      });
    }
    if (this.type && convertUnit(this.size) > shortSide / 2) {
      this.size = shortSide / 2;
    }
    if (!messages.length) this.valid = true;
    else this.valid = false;
    return messages;
  }
}
class Machining {
  //shelfHoles?: ShelfHoles[] = [];
  constructor({
    holes = [],
    hingeHoles = [],
    corners = []
  } = {}) {
    __publicField(this, "holes", []);
    __publicField(this, "corners", []);
    __publicField(this, "hingeHoles", []);
    if (corners && corners.length === 4) {
      this.corners = corners.map((c2) => new Corner(c2));
    } else {
      [0, 1, 2, 3].forEach((i2) => {
        this.corners.push(new Corner({
          type: null,
          size: null,
          index: i2
        }));
      });
    }
    if (holes) this.holes = holes.map((h2) => new Hole(h2));
    if (hingeHoles)
      this.hingeHoles = hingeHoles.map((h2) => new HingeHoles(h2));
  }
  validateEverything(shape, index = null) {
    const holeMessages = this.validate(shape, "holes");
    const hingeHolesMessages = this.validate(shape, "hingeHoles");
    const cornersMessages = this.validate(shape, "corners");
    shape.issues.push(...holeMessages.map((m2) => {
      if (isShape(shape)) {
        return { message: `Part ${shape.id} hole issue: ${m2.message}`, index };
      }
      return { message: `Hole issue: ${m2.message}`, index };
    }));
    shape.issues.push(...hingeHolesMessages.map((m2) => {
      if (isShape(shape)) {
        return { message: `Part ${shape.id} hinge hole issue: ${m2.message}`, index };
      }
      return { message: `Hinge hole issue: ${m2.message}`, index };
    }));
    shape.issues.push(...cornersMessages.map((m2) => {
      if (isShape(shape)) {
        return { message: `Part ${shape.id} corner issue: ${m2.message}`, index };
      }
      return { message: `Corner issue: ${m2.message}`, index };
    }));
  }
  validate(shape, type3, additionalValidation = null) {
    if (!shape) return [];
    if (!type3) return [];
    const messages = [];
    messages.push(...this.validateAll(shape, type3, additionalValidation));
    return messages;
  }
  validateAll(shape, item, additionalValidation = null) {
    if (!shape) return [];
    const messages = [];
    this[item].forEach((i2, index) => messages.push(...i2.validate(shape, index, additionalValidation)));
    return messages;
  }
  createHole(x2, y2, diameter, depth = 0, face = 0) {
    const hole = new Hole({
      x: x2,
      y: y2,
      diameter,
      depth,
      face
    });
    this.holes.push(hole);
    return hole;
  }
  createHingeHoles({
    numHoles,
    position,
    diameter,
    depth = 0,
    edge = "x1",
    face = 0,
    distanceFromEdge = 0,
    outerSpacing = 0,
    minimumHoleDistance = 0,
    hingeLength = 0
  }) {
    const hingeHoles = new HingeHoles({
      numHoles,
      position,
      //from left or bottom
      edge,
      face,
      diameter,
      depth,
      distanceFromEdge,
      outerSpacing,
      minimumHoleDistance,
      hingeLength
    });
    this.hingeHoles.push(hingeHoles);
    return hingeHoles;
  }
  updateHingeHoles(shape) {
    this.hingeHoles.forEach((h2) => h2.createHoles(shape));
  }
  getAllHingeHoles(shape) {
    const holes = [];
    this.hingeHoles.forEach((h2) => {
      if (h2.holes.length) holes.push(...h2.holes);
      else {
        h2.createHoles(shape);
        holes.push(...h2.holes);
      }
    });
    return holes;
  }
  getNumHoles() {
    return this.holes.length + this.hingeHoles.reduce(
      (total, hingeHoles) => total + hingeHoles.numHoles,
      0
    );
  }
  getNumCorners() {
    return this.corners.filter((c2) => c2.type !== null).length;
  }
}
function hasMachining(shape) {
  var _a3, _b2, _c, _d, _e, _f, _g, _h;
  if (!shape) return false;
  if (!(shape == null ? void 0 : shape.machining)) return false;
  if ((_b2 = (_a3 = shape.machining) == null ? void 0 : _a3.holes) == null ? void 0 : _b2.length) return true;
  if ((_d = (_c = shape.machining) == null ? void 0 : _c.hingeHoles) == null ? void 0 : _d.length) return true;
  if ((_f = (_e = shape.machining) == null ? void 0 : _e.corners) == null ? void 0 : _f.length) {
    return (_h = (_g = shape.machining) == null ? void 0 : _g.corners) == null ? void 0 : _h.some((c2) => c2.type && c2.size);
  }
  return false;
}
function compressMachining(shape) {
  var _a3, _b2, _c, _d;
  if (!("machining" in shape)) return;
  if (!hasMachining(shape)) {
    shape.machining = null;
    return;
  }
  if (!((_a3 = shape.machining.holes) == null ? void 0 : _a3.length)) shape.machining.holes = null;
  if (!((_b2 = shape.machining.hingeHoles) == null ? void 0 : _b2.length)) shape.machining.hingeHoles = null;
  if (!((_d = (_c = shape.machining) == null ? void 0 : _c.corners) == null ? void 0 : _d.some((c2) => c2.type && c2.size))) shape.machining.corners = null;
}
class InputUserGroup {
  constructor(data = null) {
    __publicField(this, "id");
    //api
    __publicField(this, "listId");
    __publicField(this, "shapeListIds", []);
    __publicField(this, "shapes");
    __publicField(this, "direction");
    __publicField(this, "q");
    __publicField(this, "duplicate", false);
    __publicField(this, "issues", []);
    __publicField(this, "stockMatch");
    var _a3;
    this.listId = (data == null ? void 0 : data.listId) ? data.listId : Date.now().toString() + Math.ceil(Math.random() * 1e16);
    this.id = data == null ? void 0 : data.id;
    this.shapes = valueSet(data == null ? void 0 : data.shapes) ? data.shapes.map((s2) => s2.toString()) : [];
    this.shapeListIds = valueSet(data == null ? void 0 : data.shapeListIds) ? data.shapeListIds : [];
    this.direction = valueSet(data == null ? void 0 : data.direction) ? data.direction : "l";
    this.q = valueSet(data == null ? void 0 : data.q) ? data.q : 1;
    if (valueSet(data == null ? void 0 : data.shapeList) && ((_a3 = data.shapeList) == null ? void 0 : _a3.length)) {
      this.validate(data.shapeList);
    }
  }
  validate(shapeList = []) {
    var _a3, _b2;
    this.issues = [];
    if (!(shapeList == null ? void 0 : shapeList.length))
      throw new Error("shapeList is required to validate user group");
    const allShapes = this.findShapes(shapeList);
    if (!allShapes.length) {
      this.issues.push({ message: "Must have 2 or more parts." });
      return this.issues;
    }
    const referenceShape = allShapes[0];
    if (isShape(referenceShape)) {
      if (!(this == null ? void 0 : this.shapes) || ((_a3 = this.shapes) == null ? void 0 : _a3.length) < 2) {
        this.issues.push({ message: "Must have 2 or more parts." });
        return this.issues;
      }
    } else {
      if (!(this == null ? void 0 : this.shapeListIds) || ((_b2 = this.shapeListIds) == null ? void 0 : _b2.length) < 2) {
        this.issues.push({ message: "Must have 2 or more parts." });
        return this.issues;
      }
    }
    allShapes.forEach((s2, i2) => {
      if (!s2.isSquare() && !["l", "w"].includes(s2.orientationLock)) {
        this.issues.push({ message: `Part in position ${i2 + 1} must have orientation lock set to be part of a group.` });
      }
    });
    if (this.issues.length) return this.issues;
    const joinDimension = getReverseDimension(this.direction);
    const referenceDimension = referenceShape.getTrimmedDimensions(true)[joinDimension];
    allShapes.forEach((s2, i2) => {
      if (s2.id === referenceShape.id) return;
      const shapeDimension = s2.getTrimmedDimensions(true)[joinDimension];
      if (!maths.equalTo(shapeDimension, referenceDimension)) {
        this.issues.push({ message: `Part in position ${i2 + 1} final ${joinDimension === "l" ? "length" : "width"} is not correct for the group. Expected ${referenceDimension} and is ${shapeDimension}. Check the dimensions, trim & orientation lock.` });
      }
    });
    return this.issues;
  }
  findShapes(shapeList = []) {
    var _a3, _b2;
    if (!shapeList.length) return [];
    let foundShapes = [];
    if (isInputShape(shapeList[0])) {
      if (!((_a3 = this.shapeListIds) == null ? void 0 : _a3.length)) return [];
      foundShapes = this.shapeListIds.map((s2) => shapeList.find((shape) => {
        return shape.listId === s2;
      })).filter((s2) => s2);
      if (!foundShapes.length)
        throw new Error("could not map group shapes to shape list");
      return foundShapes;
    } else {
      if (!((_b2 = this.shapes) == null ? void 0 : _b2.length)) return [];
      const foundShapeIds = /* @__PURE__ */ new Set();
      foundShapes = this.shapes.map((s2) => {
        const shape = shapeList.find((shape2) => shape2.parentID === s2 && !shape2.inUserGroup && !foundShapeIds.has(shape2.id));
        if (shape) {
          foundShapeIds.add(shape.id);
          return shape;
        }
        return null;
      }).filter((s2) => s2);
    }
    if (!foundShapes.length)
      throw new Error("could not map group shapes to shape list");
    return foundShapes;
  }
  populateParentID(shapeList) {
    var _a3;
    if (!(shapeList == null ? void 0 : shapeList.length)) return;
    if (!((_a3 = this == null ? void 0 : this.shapeListIds) == null ? void 0 : _a3.length)) return;
    this.shapes = this.shapeListIds.map((s2) => {
      const index = shapeList.findIndex((shape) => shape.listId === s2);
      return (index + 1).toString();
    });
  }
  //create a group from a user group
  createGroup(groupParentID = 0, groupIndex = 0, shapeList = [], stock = null) {
    if (!(shapeList == null ? void 0 : shapeList.length))
      throw new Error("some parts are required to create a user group");
    if (!isShape(shapeList[0]))
      throw new Error("shapeList must be of type Shape[]");
    const shapes = this.findShapes(shapeList);
    if (!shapes.length) return false;
    const referenceShape = shapes[0];
    shapes.forEach((s2) => {
      const shapeIndex = shapeList.findIndex((sh) => !sh.inUserGroup && sh.parentID === s2.parentID);
      if (shapeIndex === -1)
        throw new Error("shape not found in shapeList while creating user group.");
      shapeList.splice(shapeIndex, 1);
      s2.setRotationToOrientationLockWithoutContainer();
      s2.inUserGroup = true;
    });
    let l2 = 0;
    let w2 = 0;
    if (this.direction === "l") w2 = referenceShape.w;
    else l2 = referenceShape.l;
    let group;
    try {
      const groupData = {
        id: `ug${groupParentID}.${groupIndex}`,
        shapes,
        l: l2,
        w: w2,
        t: referenceShape == null ? void 0 : referenceShape.t,
        material: referenceShape == null ? void 0 : referenceShape.material,
        // joinDimension:
        //     referenceShape.l === l ? referenceShape.l : referenceShape.w,
        direction: this.direction,
        preventAutoRotation: true,
        container: stock,
        type: "user"
      };
      group = new Group(groupData);
    } catch (err2) {
      console.error(err2);
      return false;
    }
    group.parentID = `ug${groupParentID}`;
    if (stock) {
      group.updateShapeSpacing(stock);
    }
    return group;
  }
}
const mainSides = ["y1", "y2", "x1", "x2"];
const cornerSides = ["a", "b", "c", "d"];
const allSides = [...mainSides, ...cornerSides];
const faces = ["a", "b"];
function isCornerSide(side) {
  return cornerSides.includes(side);
}
function isSide(side) {
  return allSides.includes(side);
}
const userFriendlyFieldMap = {
  x: "x",
  y: "y",
  l: "length",
  w: "width",
  t: "thickness",
  q: "quantity",
  orientationLock: "rotation",
  name: "name",
  material: "material",
  banding: "banding",
  finish: "finish",
  cost: "cost",
  grain: "grain",
  trim: "trim",
  x1: "w1",
  x2: "w2",
  y1: "l1",
  y2: "l2",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  all: "all"
};
function getMainSidesArray(sides) {
  return mainSides.map((side) => sides[side] ?? null);
}
function sanitiseData(object2) {
  if (!valueSet(object2) || typeof object2 !== "object") return {};
  object2 = { ...object2 };
  for (const [key, value2] of Object.entries(object2)) {
    if (key === "_id") continue;
    if (key.startsWith("_")) {
      object2[key.substring(1)] = value2;
      delete object2[key];
    }
  }
  return object2;
}
function recreateInputShapes(inputObjects, units = null) {
  if (!inputObjects || !(inputObjects == null ? void 0 : inputObjects.length)) return [];
  return inputObjects.map((s2) => {
    var _a3;
    delete s2.id;
    if (units) s2.units = units;
    else if (!s2.units) s2.units = ((_a3 = this == null ? void 0 : this.optionsStore) == null ? void 0 : _a3.units) ?? "decimal";
    return new InputShape(s2);
  });
}
function recreateStockList({
  stockList,
  removeScores = false,
  saw = null,
  preventAutoRotation = false,
  preventGrainRotation = false
}) {
  if (!stockList || !(stockList == null ? void 0 : stockList.length)) return [];
  return stockList.filter((s2) => s2).map((s2) => {
    if (saw) s2.saw = saw;
    if (preventAutoRotation) s2.preventAutoRotation = true;
    if (preventGrainRotation) s2.preventGrainRotation = true;
    const stock = new Stock(s2);
    if (stock.issues.length) {
      throw new Error(
        `Issues found when attempting to recreate stock list - ${stock.issues.map((i2) => i2.message).join()}`,
        { cause: stock.issues }
      );
    }
    if (removeScores) delete stock.algoBenchmark;
    return stock;
  }).sort(sort.ID);
}
function recreateShapeList({
  shapeList,
  stockList,
  preventAutoRotation = false
}) {
  if (typeof stockList === "undefined")
    throw new Error("recreateShapeList requires stockList");
  if (!shapeList || !(shapeList == null ? void 0 : shapeList.length)) return [];
  return shapeList.filter((s2) => s2).map((s2) => {
    var _a3;
    if (preventAutoRotation) s2.preventAutoRotation = true;
    let shape;
    if (isGroupData(s2) && ((_a3 = s2 == null ? void 0 : s2.shapes) == null ? void 0 : _a3.length)) {
      s2.shapes = s2.shapes.map((shapeData) => new Shape(shapeData));
      try {
        shape = new Group(s2);
      } catch {
        throw new Error("error creating group from shape data");
      }
    } else {
      shape = new Shape(s2);
    }
    if (shape.issues.length) {
      throw new Error(`Issues found when attempting to recreate shape list - ${shape.issues.join()}`);
    }
    const stock = stockList.find((stock2) => {
      var _a4;
      return stock2.id === (((_a4 = s2 == null ? void 0 : s2.stock) == null ? void 0 : _a4.id) ?? (s2 == null ? void 0 : s2.stockId));
    });
    shape.stock = stock;
    return shape;
  }).sort(sort.ID);
}
function recreateCutList({
  cutList,
  stockList
}) {
  if (typeof stockList === "undefined")
    throw new Error("recreateCutList requires stockList");
  if (!cutList || !(cutList == null ? void 0 : cutList.length)) return [];
  return cutList.map((cutObject) => {
    const cut = new Cut(cutObject);
    const stock = stockList.find((stock2) => {
      var _a3;
      return stock2.id === (((_a3 = cutObject == null ? void 0 : cutObject.stock) == null ? void 0 : _a3.id) ?? (cutObject == null ? void 0 : cutObject.stockId));
    });
    cut.stock = stock;
    return cut;
  });
}
function recreateSegmentList({
  segmentList,
  stockList
}) {
  if (!segmentList || !(segmentList == null ? void 0 : segmentList.length)) return [];
  return segmentList.map((segmentObject) => {
    const stock = stockList.find((stock2) => {
      var _a3;
      return stock2.id === (((_a3 = segmentObject == null ? void 0 : segmentObject.stock) == null ? void 0 : _a3.id) ?? (segmentObject == null ? void 0 : segmentObject.stockId));
    });
    segmentObject.stock = stock;
    const segment = new Segment(segmentObject);
    return segment;
  });
}
function willItFit(container = null, shape = null, rotation = null) {
  if (!container) throw new Error("no container supplied to willItFit");
  if (!shape) throw new Error("no shape supplied to willItFit");
  const originalRotation = shape.rot;
  function checkDimension(reverse = false, dimension = "l") {
    var _a3, _b2;
    return maths.equalTo(
      shape[reverse ? getReverseDimension(dimension) : dimension],
      container[dimension]
    ) || maths.lessThanOrEqualTo(shape[reverse ? getReverseDimension(dimension) : dimension], container[dimension] - (isContainer(container) ? (_b2 = (_a3 = container == null ? void 0 : container.saw) == null ? void 0 : _a3.options) == null ? void 0 : _b2.minSpacing : 0));
  }
  function resetShape(success = true) {
    shape.forceRotate(originalRotation);
    return success;
  }
  const requiredOrientation = shape.getNecessaryOrientation(container);
  let requiredRotation = null;
  if (requiredOrientation) {
    requiredRotation = requiredOrientation === "l" ? 0 : 1;
  }
  if (shape.orientationLock) {
    if (valueSet(rotation) && rotation !== requiredRotation)
      return resetShape(false);
    shape.forceRotate(requiredRotation);
  } else if (valueSet(rotation)) {
    shape.forceRotate(rotation);
  }
  if (requiredRotation) {
    if (shape.rot !== requiredRotation) return resetShape(false);
  }
  const lengthCheck = checkDimension(false, "l");
  const widthCheck = checkDimension(false, "w");
  const lengthCheckReverse = checkDimension(true, "l");
  const widthCheckReverse = checkDimension(true, "w");
  if (valueSet(rotation) || requiredOrientation) {
    return resetShape(lengthCheck && widthCheck);
  }
  return resetShape(lengthCheck && widthCheck || lengthCheckReverse && widthCheckReverse);
}
function processInputUnitValue(data, key, units = "decimal", parseLocale = false) {
  return valueSet(data == null ? void 0 : data[key]) ? convertUnit(data[key], units, false, parseLocale) : null;
}
class InputStock {
  constructor(data, parseLocale = false) {
    __publicField(this, "readonly");
    __publicField(this, "id");
    __publicField(this, "listId");
    __publicField(this, "units", "decimal");
    __publicField(this, "l");
    __publicField(this, "w");
    __publicField(this, "t");
    __publicField(this, "q");
    __publicField(this, "name");
    __publicField(this, "material");
    __publicField(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    __publicField(this, "cost", null);
    __publicField(this, "grain", "");
    __publicField(this, "selected", false);
    //used for multiple editing
    __publicField(this, "multiEdit", false);
    //is this the multi-select stock
    __publicField(this, "type", null);
    __publicField(this, "autoAdd", false);
    __publicField(this, "used");
    __publicField(this, "saw");
    __publicField(this, "preventGrainRotation");
    __publicField(this, "allowExactFitShapes");
    __publicField(this, "issues", []);
    __publicField(this, "warnings", []);
    __publicField(this, "notes", "");
    var _a3, _b2;
    data = sanitiseData(data);
    if (!valueSet(data.units))
      console.warn("Attempting to create InputStock without units");
    this.units = data.units;
    this.readonly = data.readonly;
    this.id = data.id;
    this.listId = (data == null ? void 0 : data.listId) ? data.listId : Date.now().toString() + v4();
    const keys = ["l", "w", "t"];
    keys.forEach((key) => {
      this[key] = processInputUnitValue(data, key, this.units, parseLocale);
    });
    this.q = valueSet(data.q) ? typeof data.q === "string" ? parseInt(data.q) : data.q : null;
    this.autoAdd = valueSet(data.autoAdd) ? data.autoAdd : false;
    this.name = valueSet(data.name) ? sanitiseString(data.name).toUpperCase() : "";
    this.material = valueSet(data.material) ? data.material.trim().toUpperCase() : "";
    const trimKeys = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    };
    trimKeys.forEach((key) => {
      this.trim[key] = processInputUnitValue(data.trim, key, this.units, parseLocale);
    });
    this.cost = valueSet(data.cost) ? data.cost : null;
    data.grain = (_a3 = data == null ? void 0 : data.grain) == null ? void 0 : _a3.toLowerCase();
    if ((data == null ? void 0 : data.grain) === " ") {
      data.grain = "";
    }
    this.grain = data.grain;
    this.multiEdit = data.multiEdit;
    this.type = data.type;
    this.allowExactFitShapes = valueSet(data == null ? void 0 : data.allowExactFitShapes) ? data.allowExactFitShapes : false;
    this.preventGrainRotation = true;
    this.notes = (data == null ? void 0 : data.notes) ? (_b2 = data.notes) == null ? void 0 : _b2.replace(/,/g, "") : "";
  }
  //change the units of the stock
  changeUnits(newUnits, decimalPlaces, fractionRoundTo) {
    if (!(newUnits === "decimal" || newUnits === "fraction")) return;
    this.units = newUnits;
    function convertUnit$1(value2) {
      return value2 ? convertUnit(value2, newUnits, false, false, fractionRoundTo) : null;
    }
    this.l = convertUnit$1(this.l);
    this.w = convertUnit$1(this.w);
    this.t = convertUnit$1(this.t);
    const trimKeys = ["x1", "x2", "y1", "y2"];
    trimKeys.forEach((key) => {
      var _a3;
      this.trim[key] = valueSet((_a3 = this.trim) == null ? void 0 : _a3[key]) ? convertUnit$1(this.trim[key]) : null;
    });
  }
  //change the type of stock
  changeType(newType) {
    if (newType !== "sheet") this.grain = "";
    switch (newType) {
      case "linear":
        this.trim.y1 = 0;
        this.trim.y2 = 0;
        break;
      case "roll":
        this.trim.x1 = 0;
        this.trim.x2 = 0;
        this.trim.y1 = 0;
        this.trim.y2 = 0;
        this.t = null;
        break;
    }
  }
  //create an id from an index
  createId(index, secondaryIndex = 0) {
    this.id = `${index + 1}.${secondaryIndex}`;
  }
  isSquare() {
    if (this.l === this.w) return true;
    return false;
  }
  getWarnings() {
    this.warnings = [];
    ["q"].forEach((key) => this.warnings.push(...validation[key](this[key])));
  }
  validate() {
    this.issues = [];
    ["l", "w", "t"].forEach((key) => this.issues.push(...validation[key](this[key])));
    this.issues.push(...validation.trim(this));
    this.getWarnings();
    return this.issues;
  }
}
class InputShape {
  constructor(data, parseLocale = false) {
    __publicField(this, "readonly");
    __publicField(this, "id");
    __publicField(this, "listId");
    __publicField(this, "units", "decimal");
    __publicField(this, "l");
    __publicField(this, "w");
    __publicField(this, "t");
    __publicField(this, "q", 1);
    __publicField(this, "name", "");
    __publicField(this, "material", "");
    __publicField(this, "cost");
    __publicField(this, "orientationLock");
    __publicField(this, "selectedMaterial");
    __publicField(this, "selected", false);
    //used for multiple editing
    __publicField(this, "multiEdit", false);
    __publicField(this, "issues", []);
    __publicField(this, "warnings", []);
    __publicField(this, "notes", "");
    __publicField(this, "stockLock");
    __publicField(this, "stockMatch");
    __publicField(this, "customData");
    //objects
    __publicField(this, "machining");
    __publicField(this, "trim", Object.fromEntries(
      mainSides.map((side) => [side, 0])
    ));
    __publicField(this, "banding", Object.fromEntries(
      allSides.map((side) => [side, false])
    ));
    __publicField(this, "bandingOptions", Object.fromEntries([
      ...allSides,
      "all"
    ].map((side) => [side, {}])));
    __publicField(this, "finish", Object.fromEntries(
      faces.map((face) => [face, ""])
    ));
    __publicField(this, "finishOptions", Object.fromEntries(
      faces.map((face) => [face, {}])
    ));
    var _a3, _b2, _c, _d, _e;
    data = data = sanitiseData(data);
    this.units = data.units;
    this.readonly = data.readonly;
    this.id = data.id;
    this.listId = (data == null ? void 0 : data.listId) ? data.listId : Date.now().toString() + v4();
    const keys = ["l", "w", "t"];
    keys.forEach((key) => {
      this[key] = processInputUnitValue(data, key, this.units, parseLocale);
    });
    this.q = valueSet(data == null ? void 0 : data.q) ? typeof data.q === "string" ? parseInt(data.q) : data.q : null;
    this.name = valueSet(data.name) ? sanitiseString(data.name).toUpperCase() : "";
    this.material = valueSet(data.material) ? data.material.trim().toUpperCase() : "";
    this.multiEdit = data.multiEdit;
    this.notes = (data == null ? void 0 : data.notes) ? (_a3 = data.notes) == null ? void 0 : _a3.replace(/,/g, "") : "";
    this.stockLock = (data == null ? void 0 : data.stockLock) ?? [];
    for (const key of Object.keys(this.trim)) {
      this.trim[key] = processInputUnitValue(data.trim, key, this.units, parseLocale);
    }
    for (const key of Object.keys(this.banding)) {
      this.banding[key] = valueSet((_b2 = data == null ? void 0 : data.banding) == null ? void 0 : _b2[key]) ? data.banding[key] : false;
    }
    for (const key of Object.keys(this.bandingOptions)) {
      this.bandingOptions[key] = valueSet((_c = data == null ? void 0 : data.bandingOptions) == null ? void 0 : _c[key]) ? data.bandingOptions[key] : {};
    }
    for (const key of Object.keys(this.finish)) {
      this.finish[key] = valueSet((_d = data == null ? void 0 : data.finish) == null ? void 0 : _d[key]) ? data.finish[key] : "";
    }
    for (const key of Object.keys(this.finishOptions)) {
      this.finishOptions[key] = valueSet((_e = data == null ? void 0 : data.finishOptions) == null ? void 0 : _e[key]) ? data.finishOptions[key] : {};
    }
    this.orientationLock = valueSet(data.orientationLock) ? data.orientationLock.toLowerCase() : "";
    this.machining = new Machining(data.machining ?? {
      holes: [],
      hingeHoles: [],
      corners: []
    });
    this.customData = (data == null ? void 0 : data.customData) ?? {};
  }
  /**
   * change the units of the shape
   * @param {String} newUnits
   */
  changeUnits(newUnits, decimalPlaces, fractionRoundTo) {
    if (!(newUnits === "decimal" || newUnits === "fraction")) return;
    this.units = newUnits;
    function convertUnit$1(value2) {
      return value2 ? convertUnit(value2, newUnits, false, false, fractionRoundTo) : null;
    }
    this.l = convertUnit$1(this.l);
    this.w = convertUnit$1(this.w);
    this.t = convertUnit$1(this.t);
    const trimKeys = ["x1", "x2", "y1", "y2"];
    trimKeys.forEach((key) => {
      var _a3;
      this.trim[key] = valueSet((_a3 = this.trim) == null ? void 0 : _a3[key]) ? convertUnit$1(this.trim[key]) : null;
    });
  }
  isSquare() {
    if (this.l === this.w) return true;
    return false;
  }
  /**
   * change the type of the stock
   * @param {String} newType
   */
  changeStockType(newType) {
    switch (newType) {
      case "sheet":
      case "roll":
        this.orientationLock = "";
        if (newType === "roll") this.t = null;
        break;
      case "linear":
        this.orientationLock = "";
        this.banding = Object.fromEntries(
          allSides.map((side) => [side, false])
        );
        break;
    }
  }
  /**
   * create an id from an index
   * @param {Integer} index
   * @param {Integer} secondaryIndex
   */
  createId(index, secondaryIndex = 0) {
    this.id = `${index + 1}.${secondaryIndex}`;
  }
  getLongSide() {
    return convertUnit(this.l) > convertUnit(this.w) ? convertUnit(this.l) : convertUnit(this.w);
  }
  getShortSide() {
    return convertUnit(this.l) < convertUnit(this.w) ? convertUnit(this.l) : convertUnit(this.w);
  }
  getRotatedDimensions() {
    if (["l", "w"].includes(this.orientationLock)) {
      return {
        name: this.name,
        listId: this.listId,
        l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
        w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
        orientationLock: this.orientationLock
      };
    }
    return {
      name: this.name,
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  getTrimmedDimensions(rotated = false) {
    let dimensions = { l: convertUnit(this.l), w: convertUnit(this.w) };
    if (rotated) {
      dimensions = this.getRotatedDimensions();
    }
    return {
      name: this.name,
      listId: this.listId,
      l: dimensions.l - (this.trim.x1 + this.trim.x2),
      w: dimensions.w - (this.trim.y1 + this.trim.y2),
      orientationLock: this.orientationLock
    };
  }
  //used to apply a single trim value to all sides
  applyPartTrim(partTrim, stockType) {
    if (this.readonly) return;
    partTrim = convertUnit(partTrim);
    if (this.trim) {
      for (const key in this.trim) {
        this.trim[key] = partTrim;
      }
      if (stockType === "linear") {
        this.trim.y1 = 0;
        this.trim.y2 = 0;
      }
    } else {
      this.trim = {
        x1: partTrim,
        x2: partTrim,
        y1: stockType !== "linear" ? partTrim : 0,
        y2: stockType !== "linear" ? partTrim : 0
      };
    }
  }
  /**
   * to align with Shape
   * @remarks input shapes are always 0
   */
  get rot() {
    return 0;
  }
  validate(inputStockList, index, stockType, partTrim = 0, useInventory = false) {
    this.issues = [];
    ["l", "w", "t"].forEach((key) => {
      const issues = validation[key](this[key], index);
      if (issues.length) this.issues.push(...issues);
    });
    partTrim = convertUnit(partTrim);
    this.issues.push(...validation.partTrim(this, partTrim, index));
    this.issues.push(...validation.trim(this, index));
    validation.machining(this, index);
    this.getWarnings(inputStockList, index, stockType, partTrim, useInventory);
    return this.issues;
  }
  getWarnings(inputStockList, index = null, stockType, partTrim = 0, useInventory = false) {
    this.warnings = [];
    ["q"].forEach((key) => {
      this.warnings.push(...validation[key](this[key], index));
    });
    if (inputStockList.length && !useInventory) {
      this.warnings.push(...validation.stockMatch(this, inputStockList, stockType, partTrim, index));
    }
  }
}
class Rectangle {
  constructor(data) {
    __publicField(this, "id");
    __publicField(this, "parentID");
    __publicField(this, "name");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "l");
    __publicField(this, "w");
    __publicField(this, "t");
    __publicField(this, "q");
    __publicField(this, "material");
    __publicField(this, "grain");
    __publicField(this, "orientationLock");
    __publicField(this, "duplicate");
    __publicField(this, "trimmed");
    __publicField(this, "preventAutoRotation");
    __publicField(this, "preventGrainRotation");
    __publicField(this, "units");
    __publicField(this, "issues", []);
    __publicField(this, "stock");
    __publicField(this, "stockId");
    //used when object is compressed
    __publicField(this, "cost");
    __publicField(this, "offcut");
    __publicField(this, "notes");
    //for user notes
    __publicField(this, "proximity");
    //objects
    __publicField(this, "_trim", Object.fromEntries(
      mainSides.map((side) => [side, 0])
    ));
    __publicField(this, "customData");
    this.initRectangle(data);
  }
  validateRectangle(data) {
    if (!isGroup(this)) {
      ["x", "y", "l", "w", "t"].forEach((key) => {
        this.createIssues(validation[key](data[key]));
      });
    }
    if (isStock(this)) {
      if ("q" in data) {
        this.createIssues(validation.q((data == null ? void 0 : data.q) ?? 0, data.autoAdd));
      }
    }
    if ("q" in data && this.isShape() && !this.isGroup() && !this.isUserGroup()) {
      this.createIssues(validation.q((data == null ? void 0 : data.q) ?? 0));
    }
    if ("customData" in data) {
      this.createIssues(validation.customData((data == null ? void 0 : data.customData) ?? {}));
    }
  }
  initRectangle(data, update = false) {
    var _a3, _b2, _c;
    if (!update) {
      this.validateRectangle(data);
      if (this.issues.length) return;
      this.id = valueSet(data.id) ? data.id.toString() : this.id || null;
      this.setParentID();
      if (valueSet(data == null ? void 0 : data.q)) {
        if (typeof data.q === "string") {
          this.q = parseInt(data.q);
        } else {
          this.q = data.q;
        }
      } else {
        this.q = 0;
      }
      this.name = valueSet(data.name) && ((_a3 = data == null ? void 0 : data.name) == null ? void 0 : _a3.length) ? (_b2 = truncateString(sanitiseString(data == null ? void 0 : data.name))) == null ? void 0 : _b2.toUpperCase() : null;
      if (valueSet(data == null ? void 0 : data.cost)) {
        if (typeof data.cost === "string") {
          this.cost = parseFloat(data.cost);
        } else if (typeof data.cost === "number") {
          this.cost = data.cost;
        }
      } else {
        this.cost = 0;
      }
      this.material = valueSet(data.material) ? data.material.trim().toLowerCase() : null;
      this.duplicate = valueSet(data == null ? void 0 : data.duplicate) ? data.duplicate : false;
      this.grain = typeof data.grain !== "undefined" && valueSet(data == null ? void 0 : data.grain) ? data.grain.toLowerCase() : null;
      this.trimmed = valueSet(data == null ? void 0 : data.trimmed) ? data.trimmed : false;
      this.offcut = valueSet(data == null ? void 0 : data.offcut) ? data.offcut : false;
      this.notes = typeof (data == null ? void 0 : data.notes) === "string" && data.notes.length ? data.notes.replace(/,/g, "").substring(0, 200) : "";
      this.customData = (data == null ? void 0 : data.customData) ?? {};
      this.proximity = {
        rectangle: null,
        distance: null
      };
      try {
        this.trim = data == null ? void 0 : data.trim;
      } catch (error) {
        if ((_c = error == null ? void 0 : error.cause) == null ? void 0 : _c.issues) this.issues.push(...error.cause.issues);
        else throw new Error("error when attempting to set trim");
      }
    }
    const unitBasedValues = [
      {
        key: "x",
        default: 0,
        required: false
      },
      {
        key: "y",
        default: 0,
        required: false
      },
      {
        key: "l",
        default: null,
        required: true
      },
      {
        key: "w",
        default: 1,
        //for linear
        required: true
      },
      {
        key: "t",
        default: null,
        required: false
      }
    ];
    unitBasedValues.forEach((item) => {
      let value2 = data[item.key];
      if (!valueSet(value2)) {
        return this[item.key] = this[item.key] || item.default;
      }
      if (typeof value2 === "string") value2 = convertUnit(value2);
      this[item.key] = value2;
    });
    if (!(data == null ? void 0 : data.preventAutoRotation) && !data.trimmed && this.w > this.l) {
      [this.l, this.w] = [this.w, this.l];
      if (this.grain && !(data == null ? void 0 : data.preventGrainRotation))
        this.grain = getReverseDimension(this.grain);
    }
    if (valueSet(data == null ? void 0 : data.stock)) {
      if (isStock(data.stock)) {
        this.stock = data.stock;
      } else {
        this.stock = new Stock(data.stock);
      }
      this.stockId = this.stock.id;
    }
  }
  updateRectangle(data) {
    data.preventAutoRotation = true;
    this.initRectangle(data, true);
  }
  set trim(val) {
    this._trim = Object.fromEntries(
      mainSides.map((side) => [side, 0])
    );
    if (!objectValuesPresent(val)) return;
    for (const side of mainSides) {
      let value2;
      if (typeof val[side] === "string") {
        const converted = convertUnit(val[side]);
        if (isNaN(converted) || converted < 0) {
          this.issues.push(
            this.createIssue(
              `${val[side] ?? "N/A"} is not a valid value for trim: ${side}`
            )
          );
          value2 = 0;
        } else {
          value2 = converted;
        }
      } else {
        value2 = val[side];
      }
      this._trim[side] = value2;
    }
  }
  get trim() {
    return this._trim;
  }
  get rot() {
    return this.w > this.l ? 1 : 0;
  }
  setParentID() {
    this.parentID = this.getParentID();
  }
  getParentID() {
    if (!this.id) return null;
    if (this.parentID) return this.parentID;
    if (typeof this.id !== "number" && this.id.includes(".")) {
      return this.id.split(".")[0];
    } else if (typeof this.id !== "number" && !this.id.includes(".")) {
      return null;
    } else return (this == null ? void 0 : this.id) ? this.id.toString() : null;
  }
  getCopyNumber() {
    if (typeof this.id !== "number" && this.id.includes(".")) {
      return parseInt(this.id.split(".")[1]);
    }
    return 0;
  }
  createIssues(issues) {
    if (!(issues == null ? void 0 : issues.length)) return;
    issues.forEach((issue) => {
      this.issues.push(this.createIssue(issue.message, issue.field));
    });
  }
  createIssue(message, field = null) {
    var _a3;
    let type3 = "";
    const thisClass = this.getClass();
    switch (thisClass) {
      case "Shape":
        type3 = "part";
        break;
      case "Stock":
        type3 = "stock";
        break;
      default:
        type3 = thisClass.toLowerCase();
        break;
    }
    const itemIdentifier = ((_a3 = this == null ? void 0 : this.name) == null ? void 0 : _a3.length) ? this.name.toUpperCase() : this.parentID;
    if (itemIdentifier) {
      return {
        message: `${message} [${type3.charAt(0).toUpperCase() + type3.slice(1)} ${itemIdentifier}]`,
        field
      };
    } else {
      return { message, field };
    }
  }
  dimensions() {
    return {
      id: this.id,
      l: this.l,
      w: this.w,
      t: this.t
    };
  }
  getRotatedDimensions() {
    if (["l", "w"].includes(this.orientationLock)) {
      return {
        l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
        w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
        orientationLock: this.orientationLock
      };
    }
    return {
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  coords() {
    return {
      id: this.id,
      x: this.x,
      y: this.y
    };
  }
  hasCoords(x2, y2) {
    if (this.x === x2 && this.y === y2) return true;
    return false;
  }
  getAspect() {
    return this.l > this.w ? this.w / this.l : this.l / this.w;
  }
  getPerimeter() {
    return this.w * 2 + this.l * 2;
  }
  getLongSide() {
    return this.l > this.w ? this.l : this.w;
  }
  getShortSide() {
    return this.l < this.w ? this.l : this.w;
  }
  getSides() {
    return [
      this.getSide("bottom"),
      this.getSide("right"),
      this.getSide("top"),
      this.getSide("left")
    ];
  }
  getSide(side) {
    switch (side) {
      case "bottom":
        return new Line({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y,
          type: "bottom"
          // parentID: this.id
        });
      case "right":
        return new Line({
          x1: this.x + this.l,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y + this.w,
          type: "right"
          // parentID: this.id
        });
      case "top":
        return new Line({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y + this.w,
          y2: this.y + this.w,
          type: "top"
          // parentID: this.id
        });
      case "left":
        return new Line({
          x1: this.x,
          x2: this.x,
          y1: this.y,
          y2: this.y + this.w,
          type: "left"
          // parentID: this.id
        });
    }
  }
  getTopPosition(addBladeWidth = true, bladeWidth = null) {
    var _a3;
    if (addBladeWidth && typeof ((_a3 = this.stock) == null ? void 0 : _a3.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.y + this.w + ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.y + this.w;
  }
  getRightPosition(addBladeWidth = true, bladeWidth = null) {
    var _a3;
    if (addBladeWidth && typeof ((_a3 = this.stock) == null ? void 0 : _a3.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.x + this.l + ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.x + this.l;
  }
  getBottomPosition(addBladeWidth = true, bladeWidth = null) {
    var _a3;
    if (addBladeWidth && typeof ((_a3 = this.stock) == null ? void 0 : _a3.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.y - ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.y;
  }
  getLeftPosition(addBladeWidth = true, bladeWidth = null) {
    var _a3;
    if (addBladeWidth && typeof ((_a3 = this.stock) == null ? void 0 : _a3.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.x - ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.x;
  }
  sharesSide(rectangle, bladeWidth = 0, side = null) {
    switch (side) {
      case "left":
        return rectangle.x + rectangle.l + bladeWidth === this.x;
      case "right":
        return rectangle.x === this.x + this.l + bladeWidth;
      case "bottom":
        return rectangle.y + rectangle.w + bladeWidth === this.y;
      case "top":
        return rectangle.y === this.y + this.w + bladeWidth;
    }
    return false;
  }
  sameSide(rectangle, side = null) {
    switch (side) {
      case "left":
        return rectangle.x === this.x;
      case "right":
        return rectangle.x + rectangle.l === this.x + this.l;
      case "bottom":
        return rectangle.y === this.y;
      case "top":
        return rectangle.y + rectangle.w === this.y + this.w;
    }
    return false;
  }
  //considers if the shape can rotate
  getLongestDimension(dimension) {
    if (this.orientationLock) return this[dimension];
    else return this.getLongSide();
  }
  getArea() {
    return this.w * this.l;
  }
  getCoords(container, getAll = false) {
    const bottomRight = new Point(this.x + this.l, this.y);
    bottomRight.corner = "bottomRight";
    const topLeft = new Point(this.x, this.y + this.w);
    topLeft.corner = "topLeft";
    if ((container == null ? void 0 : container.cutType) !== "efficiency" && !getAll) {
      return [topLeft, bottomRight];
    }
    const bottomLeft = new Point(this.x, this.y);
    bottomLeft.corner = "bottomLeft";
    const topRight = new Point(this.x + this.l, this.y + this.w);
    topRight.corner = "topRight";
    return [bottomLeft, topLeft, topRight, bottomRight];
  }
  getCorners() {
    return {
      bottomLeft: new Point(this.x, this.y),
      topLeft: new Point(this.x, this.y + this.w),
      topRight: new Point(this.x + this.l, this.y + this.w),
      bottomRight: new Point(this.x + this.l, this.y)
    };
  }
  round() {
    return {
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  getClass() {
    return this.constructor.name;
  }
  getTrimmedDimensions(rotated = false) {
    let dimensions = { l: this.l, w: this.w };
    if (rotated) {
      dimensions = this.getRotatedDimensions();
    }
    if (!this.trimmed) {
      return {
        l: dimensions.l - (this.trim.x1 + this.trim.x2),
        w: dimensions.w - (this.trim.y1 + this.trim.y2)
      };
    }
    return dimensions;
  }
  //trim the rectangle
  trimDimensions() {
    var _a3, _b2, _c, _d;
    if (this.trimmed) return false;
    if (this.trim && Object.values(this.trim).filter((value2) => !isNaN(parseFloat(String(value2)))).length) {
      if (valueSet(this.l)) {
        this.l -= (((_a3 = this == null ? void 0 : this.trim) == null ? void 0 : _a3.x1) ? this.trim.x1 : 0) + (((_b2 = this == null ? void 0 : this.trim) == null ? void 0 : _b2.x2) ? this.trim.x2 : 0);
        if (this.l <= 0) {
          console.error(this);
          this.issues.push(this.createIssue("Applying trim has produced a negative length"));
        }
      }
      if (valueSet(this.w)) {
        this.w -= (((_c = this == null ? void 0 : this.trim) == null ? void 0 : _c.y1) ? this.trim.y1 : 0) + (((_d = this == null ? void 0 : this.trim) == null ? void 0 : _d.y2) ? this.trim.y2 : 0);
        if (this.w <= 0) {
          console.error(this);
          this.issues.push(this.createIssue("Applying trim has produced a negative width"));
        }
      }
    }
    this.trimmed = true;
    return true;
  }
  /**
   * change the size of the rectangle back to the original size
   */
  removeTrim() {
    var _a3, _b2, _c, _d;
    if (!this.trimmed) return;
    this.l += (typeof ((_a3 = this == null ? void 0 : this.trim) == null ? void 0 : _a3.x1) === "number" ? this.trim.x1 : 0) + (typeof ((_b2 = this == null ? void 0 : this.trim) == null ? void 0 : _b2.x2) === "number" ? this.trim.x2 : 0);
    this.w += (typeof ((_c = this == null ? void 0 : this.trim) == null ? void 0 : _c.y1) === "number" ? this.trim.y1 : 0) + (typeof ((_d = this == null ? void 0 : this.trim) == null ? void 0 : _d.y2) === "number" ? this.trim.y2 : 0);
    if (this.l <= 0)
      throw new Error(`trimming this ${this.id} has produced a negative length`);
    if (this.w <= 0)
      throw new Error(`trimming this ${this.id} has produced a negative width`);
    this.trimmed = false;
  }
  getUntrimmedDimensions() {
    var _a3, _b2, _c, _d;
    if (!this.trimmed) return { l: this.l, w: this.w };
    const l2 = this.getLongSide();
    const w2 = this.getShortSide();
    return {
      l: l2 + (typeof ((_a3 = this == null ? void 0 : this.trim) == null ? void 0 : _a3.x1) === "number" ? this.trim.x1 : 0) + (typeof ((_b2 = this == null ? void 0 : this.trim) == null ? void 0 : _b2.x2) === "number" ? this.trim.x2 : 0),
      w: w2 + (typeof ((_c = this == null ? void 0 : this.trim) == null ? void 0 : _c.y1) === "number" ? this.trim.y1 : 0) + (typeof ((_d = this == null ? void 0 : this.trim) == null ? void 0 : _d.y2) === "number" ? this.trim.y2 : 0)
    };
  }
  isIdentical(rectangle, matchParentId = false) {
    if (this.constructor !== rectangle.constructor) {
      return false;
    }
    if (this.t !== rectangle.t || this.orientationLock !== rectangle.orientationLock) {
      return false;
    }
    if (!isGroup(this)) {
      if (rectangle.parentID === this.parentID) return true;
      else if (isShape(this) && matchParentId && this.parentID !== rectangle.parentID) return false;
    } else {
      if (rectangle.id === this.id) return true;
    }
    const { w: w1, l: l1 } = this;
    const { w: w2, l: l2 } = rectangle;
    if (!(w1 === w2 && l1 === l2) && !(w1 === l2 && l1 === w2)) {
      return false;
    }
    const thisTrim = this.trim;
    const rectTrim = rectangle.trim;
    if (!thisTrim || !rectTrim) {
      return thisTrim === rectTrim;
    }
    return thisTrim.x1 === rectTrim.x1 && thisTrim.x2 === rectTrim.x2 && thisTrim.y1 === rectTrim.y1 && thisTrim.y2 === rectTrim.y2;
  }
  /**
   * is this rectangle a square
   */
  isSquare() {
    if (this.l === this.w) return true;
    return false;
  }
  getDistancesToContainerEdges(container) {
    return [
      this.x - container.x,
      container.l - (this.x + this.l),
      container.w - (this.y + this.w),
      this.y - container.y
    ];
  }
  isInsideStock(stock) {
    if (this.x + this.l > stock.l) return false;
    if (this.y + this.w > stock.w) return false;
    if (this.x < 0) return false;
    if (this.y < 0) return false;
    return true;
  }
  /**
  * Creates or retrieves a cached rectangle used for proximity detection.
  * Optimized for frequent calls with the same distance parameter.
  */
  getProximityRectangle(distance) {
    if (!distance || distance < 0) return null;
    const cache2 = this.proximity;
    if ((cache2 == null ? void 0 : cache2.distance) === distance) {
      const rect = cache2.rectangle;
      if (this.x === 0) {
        rect.x = 0;
        rect.l = this.l + distance;
      } else {
        rect.x = this.x - distance;
        rect.l = this.l + distance * 2;
      }
      if (this.y === 0) {
        rect.y = 0;
        rect.w = this.w + distance;
      } else {
        rect.y = this.y - distance;
        rect.w = this.w + distance * 2;
      }
      return rect;
    }
    const proxRect = new Rectangle({
      id: `${this.id}-proximity`,
      name: "proximity",
      x: this.x === 0 ? 0 : this.x - distance,
      y: this.y === 0 ? 0 : this.y - distance,
      l: this.x === 0 ? this.l + distance : this.l + distance * 2,
      w: this.y === 0 ? this.w + distance : this.w + distance * 2,
      preventAutoRotation: true
    });
    this.proximity = { rectangle: proxRect, distance };
    return proxRect;
  }
  isShape() {
    return isShape(this);
  }
  isSegment() {
    return isSegment(this);
  }
  isStock() {
    return isStock(this);
  }
  isGroup() {
    return isGroup(this);
  }
  isUserGroup() {
    return isUserGroup(this);
  }
}
class Container extends Rectangle {
  constructor(data) {
    super(data);
    __publicField(this, "type");
    __publicField(this, "saw");
    __publicField(this, "algoBenchmark");
    //used by evo
    __publicField(this, "shapes", []);
    this.shapes = data.shapes;
    if (!["sheet", "linear", "roll", null, void 0, ""].includes(data.type)) {
      this.issues.push({ message: `Container type ${data.type ?? "N/A"} is not valid` });
    } else this.type = data.type;
    if (!this.type) this.type = "sheet";
    this.setSaw(data);
    switch (this.cutType) {
      case "beam":
        if (!valueSet(this.t) || this.t <= 0) {
          this.issues.push(this.createIssue("Stock for beam saws must have a thickness set"));
        }
        break;
    }
  }
  setSaw(data) {
    var _a3, _b2, _c, _d;
    if (!valueSet(data)) this.saw = new Saw(null);
    if (!valueSet(data == null ? void 0 : data.saw)) {
      data.saw = {};
      const { cutType, cutPreference } = mapLegacyCutPreference(data.cutPreference);
      data.saw.cutType = cutType;
      data.saw.cutPreference = cutPreference;
      if (valueSet(data == null ? void 0 : data.bladeWidth))
        data.saw.bladeWidth = data.bladeWidth;
      if (valueSet((_a3 = data == null ? void 0 : data.blade) == null ? void 0 : _a3.width))
        data.saw.bladeWidth = data.blade.width;
      if (valueSet(data == null ? void 0 : data.efficiencyOptions))
        data.saw.efficiencyOptions = data.efficiencyOptions;
      if (valueSet(data == null ? void 0 : data.guillotineOptions))
        data.saw.guillotineOptions = data.guillotineOptions;
      if (valueSet(data == null ? void 0 : data.stackHeight))
        data.saw.stackHeight = data.stackHeight;
    } else {
      if (!((_b2 = data == null ? void 0 : data.saw) == null ? void 0 : _b2.cutType)) {
        const { cutType, cutPreference } = mapLegacyCutPreference(data.saw.cutPreference);
        data.saw.cutType = cutType;
        data.saw.cutPreference = cutPreference;
      }
    }
    try {
      if (valueSet(data == null ? void 0 : data.saw)) {
        if (isSaw(data.saw)) {
          this.saw = data.saw;
        } else {
          this.saw = new Saw(data.saw, this.type);
        }
      }
      if ((_d = (_c = this.saw) == null ? void 0 : _c.issues) == null ? void 0 : _d.length) this.issues.push(...this.saw.issues);
    } catch (error) {
      throw new Error("error creating saw", { cause: error });
    }
  }
  get cutType() {
    var _a3, _b2, _c, _d;
    if (valueSet((_a3 = this == null ? void 0 : this.saw) == null ? void 0 : _a3.cutType)) return this.saw.cutType;
    if (!((_b2 = this.stock) == null ? void 0 : _b2.isStock())) return ((_d = (_c = this == null ? void 0 : this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.cutType) ?? null;
    return null;
  }
  get cutPreference() {
    var _a3, _b2, _c, _d;
    if (valueSet((_a3 = this.saw) == null ? void 0 : _a3.cutPreference)) return this.saw.cutPreference;
    if (!((_b2 = this.stock) == null ? void 0 : _b2.isStock()))
      return ((_d = (_c = this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.cutPreference) ?? null;
    return null;
  }
  get guillotineOptions() {
    var _a3, _b2, _c, _d;
    if (valueSet((_a3 = this.saw) == null ? void 0 : _a3.guillotineOptions))
      return this.saw.guillotineOptions;
    if (!((_b2 = this.stock) == null ? void 0 : _b2.isStock()))
      return ((_d = (_c = this == null ? void 0 : this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.guillotineOptions) ?? null;
    return null;
  }
  get efficiencyOptions() {
    var _a3, _b2, _c, _d;
    if (valueSet((_a3 = this.saw) == null ? void 0 : _a3.efficiencyOptions))
      return this.saw.efficiencyOptions;
    if (!((_b2 = this.stock) == null ? void 0 : _b2.isStock()))
      return ((_d = (_c = this == null ? void 0 : this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.efficiencyOptions) ?? null;
    return null;
  }
  get primaryCompression() {
    var _a3, _b2;
    if (this.cutType === "efficiency") {
      if ((_b2 = (_a3 = this.saw) == null ? void 0 : _a3.efficiencyOptions) == null ? void 0 : _b2.primaryCompression) {
        return this.efficiencyOptions.primaryCompression;
      }
      return "y";
    }
    return void 0;
  }
  getHalfBladeWidth() {
    const bladeWidth = this.getBladeWidth();
    return bladeWidth ? bladeWidth / 2 : 0;
  }
  getBladeWidth() {
    var _a3, _b2, _c;
    const bladeWidth = (((_a3 = this == null ? void 0 : this.saw) == null ? void 0 : _a3.bladeWidth) || ((_c = (_b2 = this == null ? void 0 : this.stock) == null ? void 0 : _b2.saw) == null ? void 0 : _c.bladeWidth)) ?? 0;
    return isNaN(bladeWidth) ? 0 : bladeWidth;
  }
  getStock() {
    if (isStock(this)) return this;
    return (this == null ? void 0 : this.stock) ? this.stock : null;
  }
}
class Saw {
  constructor(data, stockType = "sheet") {
    __publicField(this, "issues");
    __publicField(this, "bladeWidth");
    __publicField(this, "cutType");
    __publicField(this, "cutPreference");
    __publicField(this, "guillotineOptions");
    __publicField(this, "efficiencyOptions");
    __publicField(this, "stackHeight");
    __publicField(this, "stockType");
    __publicField(this, "options");
    data = sanitiseData(data);
    this.options = defaults({}, data == null ? void 0 : data.options, {
      stockSelection: "efficiency",
      stackingMode: "dimensions",
      minSpacing: 0,
      minSpacingDimension: {}
    });
    this.stackHeight = (data == null ? void 0 : data.stackHeight) ?? null;
    this.stockType = (data == null ? void 0 : data.stockType) ?? stockType;
    this.issues = [];
    if (!["sheet", "linear", "roll"].includes(this.stockType))
      this.issues.push({ message: `Saw stock type: ${this.stockType} not valid` });
    if (!this.stockType) this.stockType = "sheet";
    this.cutType = data == null ? void 0 : data.cutType;
    switch (this.stockType) {
      case "sheet":
        if (![
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType)) {
          this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        }
        break;
      case "roll":
        if (!["efficiency", "guillotine", null, void 0].includes(this.cutType)) {
          this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        }
        break;
      case "linear":
        break;
      default:
        if (!["none", null, void 0].includes(this.cutType)) {
          this.issues.push({ message: `Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}` });
        }
        break;
    }
    this.cutPreference = data == null ? void 0 : data.cutPreference;
    switch (this.cutType) {
      case "guillotine":
        if (!["l", "w", "flex"].includes(this.cutPreference)) {
          this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` });
        }
        if (this.cutType === "guillotine" && this.cutPreference === "l" && this.stockType === "roll") {
          this.issues.push({ message: `Cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"} and stock type: ${this.stockType}` });
        }
        this.options.minSpacing = 0;
        break;
      case "beam":
        if (!["l", null, void 0].includes(this.cutPreference)) {
          this.issues.push({ message: `Saw cut preference: ${this.cutPreference || "N/A"} not valid for cut type: ${this.cutType || "N/A"}` });
        }
        this.options.minSpacing = 0;
        break;
    }
    if (valueSet(data == null ? void 0 : data.bladeWidth)) {
      if (typeof data.bladeWidth === "string") {
        this.bladeWidth = convertUnit(data.bladeWidth);
      } else {
        this.bladeWidth = data.bladeWidth;
      }
    } else this.bladeWidth = 0;
    if (isNaN(this.bladeWidth) || this.bladeWidth < 0) {
      this.issues.push({ message: `Blade width: ${this.bladeWidth ?? "N/A"} is not valid` });
      this.bladeWidth = 0;
    }
    switch (this.stockType) {
      case "sheet":
        if (![
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType)) {
          this.issues.push({ message: `Invalid cut type: ${this.cutType} for stock type: ${stockType}, cut preference: ${this.cutPreference}` });
        }
        if (this.cutType === "guillotine") {
          if (!["l", "w", "flex"].includes(this.cutPreference)) {
            this.issues.push({ message: `Invalid cut preference: ${this.cutPreference} for stock type: ${stockType}, cut type: ${this.cutType}` });
          }
        }
        if (this.cutType === "beam") {
          if ([null, void 0].includes(this.stackHeight)) {
            this.issues.push({ message: "Beam saws require a stack height to be set" });
          }
        }
        if (this.cutType === "beam") this.cutPreference = "l";
        if (!this.cutType) this.cutType = "efficiency";
        break;
      case "linear":
        this.cutType = null;
        this.cutPreference = null;
        break;
    }
    switch (this.cutType) {
      case "efficiency":
        this.efficiencyOptions = defaults({}, data == null ? void 0 : data.efficiencyOptions, { primaryCompression: "y" });
        break;
      case "guillotine":
        this.guillotineOptions = defaults({}, data == null ? void 0 : data.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        break;
      case "beam":
        this.guillotineOptions = defaults({}, data == null ? void 0 : data.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        this.cutPreference = "l";
        if ([null, void 0].includes(this.stackHeight)) {
          this.issues.push({ message: "Beam saws require a stack height to be set" });
        }
        break;
    }
  }
  clone() {
    const data = structuredClone(this);
    return new Saw(data);
  }
}
class Stock extends Container {
  constructor(data) {
    data = sanitiseData(data);
    data.preventAutoRotation = (data == null ? void 0 : data.type) === "roll";
    if (data.autoAdd && !data.q) data.q = 1;
    super(data);
    __publicField(this, "_id");
    //used for mongo
    __publicField(this, "autoAdd");
    __publicField(this, "allowExactFitShapes");
    __publicField(this, "analysis");
    __publicField(this, "tidy");
    __publicField(this, "used");
    __publicField(this, "stack");
    __publicField(this, "winningStrategy");
    //used for reporting
    __publicField(this, "unusable");
    //used by stock matching
    __publicField(this, "duplicatePattern");
    __publicField(this, "score");
    __publicField(this, "rootSegment");
    delete this.stock;
    this._id = data == null ? void 0 : data._id;
    this.autoAdd = valueSet(data == null ? void 0 : data.autoAdd) ? data.autoAdd : false;
    this.allowExactFitShapes = valueSet(data == null ? void 0 : data.allowExactFitShapes) ? data.allowExactFitShapes : false;
    this.analysis = valueSet(data.analysis) ? data.analysis : null;
    this.tidy = valueSet(data == null ? void 0 : data.tidy) ? data.tidy : false;
    this.algoBenchmark = null;
    this.used = valueSet(data == null ? void 0 : data.used) ? data.used : false;
    this.stack = valueSet(data == null ? void 0 : data.stack) ? data.stack : false;
    this.duplicatePattern = (data == null ? void 0 : data.duplicatePattern) ?? null;
    this.initStock(data);
  }
  initStock(data) {
    switch (this.type) {
      case "linear":
      case "roll":
        this.trim.y1 = 0;
        this.trim.y2 = 0;
        this.grain = null;
        break;
    }
    this.validateStock(data);
    if (this.issues.length) return;
  }
  reset() {
    this.used = false;
    this.stack = null;
    this.score = null;
    this.rootSegment = null;
    this.tidy = null;
    this.analysis = null;
    this.duplicatePattern = null;
    this.shapes = [];
  }
  validateStock(data) {
    ["grain"].forEach((key) => {
      this.createIssues(validation[key](data[key]));
    });
    this.createIssues(validation.trim(this));
  }
  /**
   * compress for saving / transfer
   */
  save() {
    delete this.tidy;
    delete this.score;
    delete this.rootSegment;
    delete this.shapes;
    delete this.saw;
    this == null ? true : delete this.algoBenchmark;
    this.stack = isStock(this.stack) ? this.stack.id : this.stack;
    if (!this.trim.x1 && !this.trim.x2 && !this.trim.y1 && !this.trim.y2) {
      this.trim = null;
    }
  }
  resetStrategies() {
    this.algoBenchmark = null;
  }
  isIdentical(stock) {
    let material = false;
    let thickness = false;
    let length = false;
    let width = false;
    if (this.material === stock.material) material = true;
    if (this.t === stock.t) thickness = true;
    if (this.l === stock.l) length = true;
    if (this.w === stock.w) width = true;
    if (material && thickness && length && width) return true;
  }
  hasStack() {
    return typeof this.stack === "number";
  }
  isStacked() {
    return isStock(this.stack) || typeof this.stack === "string";
  }
  clone(version = null) {
    const id = this.id.split(".");
    if (!version) {
      version = parseInt(id.pop());
      version++;
    } else {
      id.pop();
    }
    id.push(version.toString());
    const newId = id.join(".");
    const data = structuredClone(this);
    data.id = newId;
    data.used = false;
    data.duplicate = true;
    data.stack = false;
    data.saw = this.saw;
    const stock = new Stock(data);
    return stock;
  }
}
class Offcut extends Rectangle {
  constructor(data) {
    super(data);
    __publicField(this, "addToInventory");
    //for front end selection
    __publicField(this, "added");
    //for adding to inputStock
    __publicField(this, "placementOrder");
    __publicField(this, "flex");
    this.cost = this.getCost();
    this.addToInventory = (data == null ? void 0 : data.addToInventory) ?? true;
    this.added = false;
    this.placementOrder = (data == null ? void 0 : data.placementOrder) ?? null;
    this.offcut = true;
  }
  compressForSaving() {
    var _a3;
    this.stockId = (this == null ? void 0 : this.stockId) || ((_a3 = this == null ? void 0 : this.stock) == null ? void 0 : _a3.id);
    delete this.stock;
    delete this._trim;
    delete this.trimmed;
  }
  getCost() {
    var _a3;
    if ((_a3 = this.stock) == null ? void 0 : _a3.isStock())
      return this.stock ? parseFloat((this.getArea() / this.stock.getArea() * this.stock.cost).toFixed(2)) : 0;
    return 0;
  }
}
function recreateOffcuts({
  offcuts,
  stockList,
  preventAutoRotation = true
}) {
  if (!offcuts || !(offcuts == null ? void 0 : offcuts.length)) return [];
  return offcuts.map((offcutObject) => {
    const stock = stockList.find((stock2) => {
      var _a3;
      return stock2.id === (((_a3 = offcutObject == null ? void 0 : offcutObject.stock) == null ? void 0 : _a3.id) ?? (offcutObject == null ? void 0 : offcutObject.stockId));
    });
    offcutObject.stock = stock;
    if (preventAutoRotation) offcutObject.preventAutoRotation = true;
    const offcut = new Offcut(offcutObject);
    return offcut;
  });
}
class Shape extends Rectangle {
  constructor(data) {
    data = sanitiseData(data);
    super(data);
    __publicField(this, "added");
    __publicField(this, "guillotineData");
    __publicField(this, "stockLock");
    __publicField(this, "score");
    __publicField(this, "bestScore");
    __publicField(this, "placementOrder");
    //groups
    __publicField(this, "groupPlacementOrder");
    __publicField(this, "group");
    __publicField(this, "groupID");
    __publicField(this, "inGroup");
    //is the shape currently part of at least one group
    __publicField(this, "inUserGroup");
    //is the shape currently part of a user group`
    __publicField(this, "addedAsGroup");
    __publicField(this, "isFirstShape");
    __publicField(this, "firstShapeSampleRotations", []);
    //used for setting the rotation of the first shape (guillotine)
    __publicField(this, "index");
    //used for ptx
    __publicField(this, "patternMatch");
    //used for stack detection
    __publicField(this, "stockMatch");
    __publicField(this, "minSpacing");
    __publicField(this, "priority");
    __publicField(this, "weighting", {});
    //objects
    __publicField(this, "machining");
    __publicField(this, "_banding", Object.fromEntries(
      allSides.map((side) => [side, false])
    ));
    __publicField(this, "_finish", Object.fromEntries(
      faces.map((face) => [face, ""])
    ));
    this.initShape(data);
  }
  initShape(data, update = false) {
    var _a3;
    if (!update) {
      this.validateShape(data);
      if (this.issues.length) throw new Error(this.issues.map((i2) => i2.message).join("\n"));
      data.orientationLock = (_a3 = data == null ? void 0 : data.orientationLock) == null ? void 0 : _a3.toLowerCase();
      if ((data == null ? void 0 : data.orientationLock) === " ") {
        data.orientationLock = "";
      }
      this.orientationLock = valueSet(data == null ? void 0 : data.orientationLock) && this.l !== this.w ? data.orientationLock : null;
      if (valueSet(data == null ? void 0 : data.stockLock)) {
        if (Array.isArray(data == null ? void 0 : data.stockLock))
          this.stockLock = data.stockLock.map((sl) => sl.toString());
      } else {
        this.stockLock = [];
      }
      this.banding = data == null ? void 0 : data.banding;
      this.finish = data == null ? void 0 : data.finish;
      this.machining = valueSet(data == null ? void 0 : data.machining) ? new Machining(data.machining) : null;
    }
    this.added = valueSet(data == null ? void 0 : data.added) ? data.added : false;
    this.initGuillotineData(data);
    this.inGroup = valueSet(data == null ? void 0 : data.inGroup) ? data.inGroup : this.inGroup || false;
    this.inUserGroup = valueSet(data == null ? void 0 : data.inUserGroup) ? data.inUserGroup : this.inUserGroup || false;
    this.groupID = valueSet(data == null ? void 0 : data.groupID) ? data.groupID : this.groupID || null;
    this.addedAsGroup = valueSet(data == null ? void 0 : data.addedAsGroup) ? data.addedAsGroup : this.addedAsGroup || false;
    this.score = valueSet(data == null ? void 0 : data.score) ? data.score : this.score || null;
    this.bestScore = valueSet(data == null ? void 0 : data.bestScore) ? data.bestScore : this.bestScore || {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.placementOrder = valueSet(data == null ? void 0 : data.placementOrder) ? data.placementOrder : this.placementOrder || null;
    this.groupPlacementOrder = valueSet(data == null ? void 0 : data.groupPlacementOrder) ? data.groupPlacementOrder : this.groupPlacementOrder || null;
    this.minSpacing = (data == null ? void 0 : data.minSpacing) ?? (this.minSpacing || 0);
    this.priority = (data == null ? void 0 : data.priority) ?? {};
  }
  initGuillotineData(data) {
    var _a3, _b2, _c, _d, _e, _f, _g, _h;
    this.guillotineData = defaults({}, data == null ? void 0 : data.guillotineData, {
      firstShape: ((_a3 = this == null ? void 0 : this.guillotineData) == null ? void 0 : _a3.firstShape) || null,
      myPhase: ((_b2 = this == null ? void 0 : this.guillotineData) == null ? void 0 : _b2.myPhase) || null,
      myStripParent: ((_c = this == null ? void 0 : this.guillotineData) == null ? void 0 : _c.myStripParent) || null,
      myStripDirection: ((_d = this == null ? void 0 : this.guillotineData) == null ? void 0 : _d.myStripDirection) || null,
      stripShapeBatches: {
        subsetUsed: ((_f = (_e = this == null ? void 0 : this.guillotineData) == null ? void 0 : _e.stripShapeBatches) == null ? void 0 : _f.subsetUsed) || false,
        groups: ((_h = (_g = this == null ? void 0 : this.guillotineData) == null ? void 0 : _g.stripShapeBatches) == null ? void 0 : _h.groups) || {}
      }
    });
  }
  cloneGuillotineData() {
    var _a3;
    if (((_a3 = this.guillotineData) == null ? void 0 : _a3.myStripParent) && (isShape(this.guillotineData.myStripParent) || isGroup(this.guillotineData.myStripParent))) {
      this.guillotineData.myStripParent = this.guillotineData.myStripParent.compress();
    }
    return structuredClone(this.guillotineData);
  }
  getCopyNumber() {
    return parseInt(this.id.split(".").pop());
  }
  getMinSpacing(container, removeBlade = false) {
    var _a3, _b2;
    if (!container) return 0;
    let minSpacing = (this == null ? void 0 : this.minSpacing) || ((_b2 = (_a3 = container.saw) == null ? void 0 : _a3.options) == null ? void 0 : _b2.minSpacing) || 0;
    const bladeWidth = container.getBladeWidth();
    if (bladeWidth > minSpacing) minSpacing = bladeWidth;
    if (removeBlade) {
      minSpacing -= bladeWidth;
    }
    if (minSpacing < 0) minSpacing = 0;
    return minSpacing;
  }
  validateShape(data) {
    ["orientationLock", "banding"].forEach((key) => {
      this.createIssues(validation[key](data[key]));
    });
    if (this.machining) {
      this.machining.validateEverything(this);
    }
  }
  //individual shape weighting
  /* calculateWeighting()
  	{
  		// const aspect = this.w / this.l;
  		if ( aspect > 0.5 )
  		{
  			//cater for small parts
  			const area = s.getArea();
  			const areaPercentage = area / maxArea;
  
  			if ( areaPercentage <= 0.1 )
  			{
  				s.weighting.edge = areaPercentage;
  			}
  		}
  		//the closer to zero, the higher the edge weighting
  		this.weighting.edge = 1 - aspect;
  		this.weighting.edge *= 2;
  	} */
  update(data) {
    data = sanitiseData(data);
    this.initShape(data, true);
    this.updateRectangle(data);
  }
  //banding
  set banding(val) {
    this._banding = Object.fromEntries(
      allSides.map((side) => [side, false])
    );
    if (!objectValuesPresent(val)) return;
    for (const side of allSides) {
      this._banding[side] = valueSet(val == null ? void 0 : val[side]) ? val[side] : false;
    }
  }
  get banding() {
    return this._banding;
  }
  //get an array of banding in the order L1, L2, W1, W2
  get bandingArray() {
    return getMainSidesArray(this._banding);
  }
  get finish() {
    return this._finish;
  }
  get FacesArray() {
    return faces.map((face) => {
      var _a3;
      return (_a3 = this.finish) == null ? void 0 : _a3[face];
    });
  }
  set finish(val) {
    this._finish = Object.fromEntries(
      faces.map((face) => [face, ""])
    );
    if (!objectValuesPresent(val)) return;
    for (const face of faces) {
      this._finish[face] = valueSet(val == null ? void 0 : val[face]) ? val[face] : "";
    }
  }
  //compress for saving / transfer
  save() {
    var _a3, _b2, _c;
    delete this.group;
    {
      (_a3 = this == null ? void 0 : this.guillotineData) == null ? true : delete _a3.stripShapeBatches;
    }
    this.stockId = (_b2 = this == null ? void 0 : this.stock) == null ? void 0 : _b2.id;
    delete this.stock;
    delete this.score;
    {
      delete this.bestScore;
    }
    if (allSides.every((side) => {
      var _a4;
      return !((_a4 = this._banding) == null ? void 0 : _a4[side]);
    })) {
      this._banding = null;
    }
    if (faces.every((face) => {
      var _a4;
      return !((_a4 = this._finish) == null ? void 0 : _a4[face]);
    })) {
      this._finish = null;
    }
    compressMachining(this);
    {
      (_c = this.guillotineData) == null ? true : delete _c.myStripParent;
      delete this.score;
      delete this.inGroup;
      delete this.groupID;
      delete this.addedAsGroup;
      delete this.proximity;
    }
  }
  isExactFit(container) {
    return this.orientationLock === "w" && this.w === container.w || this.orientationLock === "l" && this.l === container.l || !this.orientationLock && (this.w === container.w && this.l === container.l);
  }
  addToStock(stock) {
    this.stock = stock;
    this.stockId = stock.id;
    this.added = true;
    this.inGroup = false;
    stock.used = true;
    this.grain = stock.grain;
    if ((stock == null ? void 0 : stock.grain) && this.rot) {
      this.grain = getReverseDimension(stock.grain);
    }
    test([
      () => expect(this.isInsideStock(stock), `shape ${this.id} is not inside stock`).to.be.true
    ]);
  }
  removeFromStock() {
    this.placementOrder = null;
    this.stock = null;
    this.stockId = null;
    this.added = false;
    this.addedAsGroup = false;
    this == null ? true : delete this.isFirstShape;
    if (isGroup(this)) {
      this.shapes.forEach((s2) => s2.removeFromStock());
    }
  }
  setBestScore(winner, point = null) {
    const bestScore = {
      x: winner.x,
      y: winner.y,
      rot: winner.rot,
      total: winner.score.total,
      score: winner.score,
      group: winner.group,
      weighting: null,
      point
    };
    this.bestScore = bestScore;
  }
  resetBestScore() {
    const bestScore = {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.bestScore = bestScore;
    this.resetGuillotineData(true);
  }
  resetScore() {
    this.score = null;
    this.resetGuillotineData(true);
  }
  resetBothScores() {
    this.resetBestScore();
    this.resetScore();
  }
  resetPosition() {
    this.x = 0;
    this.y = 0;
    this.placementOrder = null;
    this.resetGuillotineData(true);
  }
  resetGroupData() {
    this.inGroup = false;
    this.group = null;
    this.groupID = null;
    this.groupPlacementOrder = null;
    this.grain = null;
  }
  resetGuillotineData(keepStripShapeBatches = false) {
    var _a3, _b2;
    const guillotineData = {
      firstShape: false,
      myPhase: null,
      myStripDirection: null,
      stripShapeBatches: {
        subsetUsed: false,
        groups: {}
      }
    };
    if (keepStripShapeBatches) {
      guillotineData.stripShapeBatches.groups = (_b2 = (_a3 = this.guillotineData) == null ? void 0 : _a3.stripShapeBatches) == null ? void 0 : _b2.groups;
    }
    this.guillotineData = guillotineData;
  }
  reset(keepScores = false, keepGuillotineBatchData = true, keepGroupData = false) {
    this.removeFromStock();
    this.resetPosition();
    this.setRotation(0);
    this.placementOrder = null;
    this == null ? true : delete this.isFirstShape;
    this.patternMatch = false;
    if (!keepScores) this.resetBothScores();
    if (!keepGroupData) this.resetGroupData();
    this.resetGuillotineData(keepGuillotineBatchData);
  }
  round() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y),
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  //get an array of allowed rotations for this container
  getAllowedRotations(container) {
    const rotations = [];
    for (let i2 = 0; i2 <= 1; i2++) {
      if (this.canRotate(i2, container) && this.willItFit(container, i2)) {
        rotations.push(i2);
      }
    }
    return rotations;
  }
  /**
   * checks if a shape can rotate
   * checks for fit and grain
   * does not change the shape's rotation during the checks
   * @returns false if cannot rotate or can rotate but won't fit
   */
  canRotate(rotation = null, container = null) {
    if (!valueSet(rotation))
      throw new Error("no rotation provided to canRotate");
    if (rotation === true) rotation = 1;
    if (rotation === false) rotation = 0;
    if (this.isSquare() && rotation) return false;
    if (container) {
      if (!this.willItFit(container, rotation)) return false;
    }
    const orientationLock = this.getNecessaryOrientation(container);
    if (orientationLock === "l" && rotation === 1) return false;
    if (orientationLock === "w" && rotation === 0) return false;
    return true;
  }
  /**
   * can a shape rotate to produce the specified dimensions on a specific side
   * @todo tests
   */
  canRotateToDimension(value2, requiredSide, container = null) {
    if (!requiredSide) throw new Error("requiredSide not supplied to canRotateToDimension");
    if (this.l !== value2 && this.w !== value2) return false;
    if (this.l === this.w) return true;
    const long = this.getLongSide();
    const short = this.getShortSide();
    if (container) {
      if (requiredSide === "l") {
        if (long === value2 && this.canRotate(0, container)) return true;
        if (short === value2 && this.canRotate(1, container)) return true;
      } else if (requiredSide === "w") {
        if (short === value2 && this.canRotate(0, container)) return true;
        if (long === value2 && this.canRotate(1, container)) return true;
      }
    } else if (this.orientationLock) {
      if (this.orientationLock === "l") {
        return requiredSide === "l" && value2 === long;
      } else if (this.orientationLock === "w") {
        return requiredSide === "l" && value2 === short;
      }
    }
    return false;
  }
  canRotateToDimensionRange(minValue, maxValue, requiredSide, container = null) {
    if (!requiredSide) throw new Error("requiredSide not supplied to canRotateToDimensionRange");
    if (this.l >= minValue && this.l <= maxValue || this.w >= minValue && this.w <= maxValue) {
      if (this.l === this.w) return true;
      const long = this.getLongSide();
      const short = this.getShortSide();
      if (container) {
        if (requiredSide === "l") {
          if (long >= minValue && long <= maxValue && this.canRotate(0, container)) return true;
          if (short >= minValue && short <= maxValue && this.canRotate(1, container)) return true;
        } else if (requiredSide === "w") {
          if (short >= minValue && short <= maxValue && this.canRotate(0, container)) return true;
          if (long >= minValue && long <= maxValue && this.canRotate(1, container)) return true;
        }
      } else if (this.orientationLock) {
        if (this.orientationLock === "l") {
          return requiredSide === "l" && long >= minValue && long <= maxValue;
        } else if (this.orientationLock === "w") {
          return requiredSide === "l" && short >= minValue && short <= maxValue;
        }
      }
    }
    return false;
  }
  rotateToDimension(value2, requiredSide, stock) {
    if (!requiredSide) throw new Error("requiredSide not supplied to rotateToDimension");
    if (this.l !== value2 && this.w !== value2) return false;
    if (this.l === this.w) return true;
    const long = this.getLongSide();
    const short = this.getShortSide();
    if (requiredSide === "l") {
      if (long === value2 && this.canRotate(0, stock)) return this.setRotation(0);
      if (short === value2 && this.canRotate(1, stock)) return this.setRotation(1);
    } else if (requiredSide === "w") {
      if (short === value2 && this.canRotate(0, stock)) return this.setRotation(0);
      if (long === value2 && this.canRotate(1, stock)) return this.setRotation(1);
    }
    return false;
  }
  //get the orientation lock catering for container grain
  convertShapeGrainToOrientationLock(container) {
    if (!container) throw new Error("container not supplied to convertShapeGrainToOrientationLock");
    if (!isContainer(container)) throw new Error("container is not a container");
    if (isGroup(this)) return this.orientationLock;
    if (!valueSet(this.orientationLock)) return null;
    const stock = container.getStock();
    if (!valueSet(stock.grain)) return this.orientationLock;
    if (this.orientationLock === stock.grain) return "l";
    return "w";
  }
  /**
   * get the orientation lock catering for container grain
   */
  getNecessaryOrientation(container) {
    if (!container) return this.orientationLock;
    if (isGroup(this)) return this.orientationLock;
    if (!valueSet(this.orientationLock)) return null;
    if (isContainer(container)) {
      return this.convertShapeGrainToOrientationLock(container);
    } else if (isGroup(this) || isUserGroup(this)) {
      return valueSet(this.orientationLock) ? this.orientationLock : null;
    }
  }
  /**
   * get the required grain rotation
   * checks for stock grain and part orientationLock
   * does not check for fit
   */
  getGrainRotation(container) {
    if (isGroup(this)) return this.rot;
    if (!valueSet(this.orientationLock)) return null;
    const stock = container.getStock();
    if (!this.orientationLock) return null;
    if (!valueSet(stock == null ? void 0 : stock.grain)) return null;
    if (this.isGroup()) return this.orientationLock === "l" ? 0 : 1;
    if (this.orientationLock === (stock == null ? void 0 : stock.grain)) return 0;
    return 1;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  rotate(rot = null, container = null) {
    if (rot === null) rot = this.rot === 0 ? 1 : 0;
    if (!this.canRotate(rot, container)) return false;
    if (this.rot === rot) return true;
    this.swapDimensions();
    return true;
  }
  swapDimensions() {
    [this.l, this.w] = [this.w, this.l];
  }
  forceRotate(rot) {
    if (rot === null) rot = this.rot === 0 ? 1 : 0;
    if (this.rot === rot) return true;
    this.swapDimensions();
    return true;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotation(rot = null, container = null) {
    if (rot) rot = 1;
    else rot = 0;
    if (container && rot && !this.willItFit(container, rot)) return false;
    return this.rotate(rot, container);
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotationToOrientationLock(container) {
    if (!container)
      throw new Error("container not supplied to setRotationToOrientationLock");
    const requiredOrientation = this.getNecessaryOrientation(container);
    if (requiredOrientation === "l") return this.setRotation(0);
    if (requiredOrientation === "w") return this.setRotation(1);
  }
  setRotationToOrientationLockWithoutContainer() {
    if (this.orientationLock === "l") return this.setRotation(0);
    if (this.orientationLock === "w") return this.setRotation(1);
  }
  getBandingLength(key) {
    if (!isSide(key)) return 0;
    if (!this.banding[key]) return 0;
    if (key === "x1" || key === "x2") return this.getShortSide();
    if (key === "y1" || key === "y2") return this.getLongSide();
    if (isCornerSide(key)) {
      return getCornerLength(this, key);
    }
    return 0;
  }
  getPriority(stock) {
    var _a3;
    if (!stock) return 0;
    const id = stock.parentID;
    if ((_a3 = this.priority) == null ? void 0 : _a3[id]) return this.priority[id];
    return 0;
  }
  clearPriority() {
    this.priority = {};
  }
  getPerimeterCutVectors() {
    var _a3;
    const offset = ((_a3 = this.stock) == null ? void 0 : _a3.isStock()) ? this.stock.getBladeWidth() / 2 : null;
    const vectors = [
      //bottom
      {
        x1: this.x - offset,
        x2: this.x + this.l + offset,
        y1: this.y - offset,
        y2: this.y - offset,
        type: "bottom"
      },
      //right
      {
        x1: this.x + this.l + offset,
        x2: this.x + this.l + offset,
        y1: this.y - offset,
        y2: this.y + this.w + offset,
        type: "right"
      },
      //top
      {
        x1: this.x - offset,
        x2: this.x + this.l + offset,
        y1: this.y + this.w + offset,
        y2: this.y + this.w + offset,
        type: "top"
      },
      //left
      {
        x1: this.x - offset,
        x2: this.x - offset,
        y1: this.y - offset,
        y2: this.y + this.w + offset,
        type: "left"
      }
    ];
    return vectors;
  }
  /* getTrimmedDimensions()
  	{
  		if ( this.trimmed )
  			return {
  				l: this.l,
  				w: this.w
  			};
  
  		return {
  			l: this.l - this.trim.x1 - this.trim.x2,
  			w: this.w - this.trim.y1 - this.trim.y2
  		};
  	} */
  /**
   * create cuts around the perimeter of a shape
   * @param {Stock} stock
   * @returns {Array} cuts
   */
  createPerimeterCuts(stock = null) {
    let perimeterCuts = [];
    stock = stock ? stock : this.stock;
    if (!stock) throw new Error("stock is required to create a cut");
    const vectors = this.getPerimeterCutVectors();
    vectors.forEach((vector) => {
      var _a3;
      return perimeterCuts.push(new Cut({
        stock: ((_a3 = this.stock) == null ? void 0 : _a3.isStock()) ? this.stock : stock,
        x1: vector.x1,
        x2: vector.x2,
        y1: vector.y1,
        y2: vector.y2,
        type: vector.type
      }));
    });
    perimeterCuts = perimeterCuts.filter((cut) => cut.isInsideStock());
    return perimeterCuts;
  }
  createOffset(amount) {
    if (!this.stock) throw new Error("createOffset - stock not defined");
    const offset = {
      x: this.x - amount,
      y: this.y - amount,
      l: this.l + amount * 2,
      w: this.w + amount * 2
    };
    if (offset.x < 0) {
      offset.x = 0;
      offset.l -= amount;
    }
    if (offset.y < 0) {
      offset.y = 0;
      offset.w -= amount;
    }
    if (offset.x + offset.l > this.stock.l) {
      offset.l = this.stock.l - offset.x;
    }
    if (offset.y + offset.w > this.stock.w) {
      offset.w = this.stock.w - offset.y;
    }
    return offset;
  }
  setPositionToBestScore() {
    this.setRotation(this.bestScore.rot);
    this.x = this.bestScore.x;
    this.y = this.bestScore.y;
  }
  /**
   * will this shape fit in a container
   */
  willItFit(container, rotation = null) {
    return willItFit(container, this, rotation);
  }
  clone(version = null) {
    const id = this.id.split(".");
    if (!version) {
      version = id.pop();
      version++;
    } else {
      id.pop();
    }
    id.push(version);
    const newId = id.join(".");
    const stock = this.stock;
    this.stock = null;
    const data = structuredClone(this);
    data.stock = stock;
    data.id = newId;
    data.added = false;
    data.duplicate = true;
    delete data.score;
    delete data.bestScore;
    delete data.stock;
    delete data.placementOrder;
    delete data.inGroup;
    delete data.addedAsGroup;
    delete data.groupID;
    delete data.isFirstShape;
    const shape = new Shape(data);
    return shape;
  }
  //this is a compressed version of the shape to help with memory management
  compress() {
    const guillotineData = this.cloneGuillotineData();
    guillotineData.myStripParent = isShapeOrGroup(this.guillotineData.myStripParent) ? this.guillotineData.myStripParent.id : this.guillotineData.myStripParent;
    const clone = {
      id: this.id,
      x: this.added ? this.x : 0,
      y: this.added ? this.y : 0,
      l: this.l,
      w: this.w,
      added: this.added,
      guillotineData,
      placementOrder: this.placementOrder,
      bestScore: this.bestScore,
      inGroup: this.inGroup,
      groupID: this.groupID,
      addedAsGroup: this.addedAsGroup,
      groupPlacementOrder: this.groupPlacementOrder,
      minSpacing: this.minSpacing,
      cloneType: "shape",
      priority: Object.assign({}, this.priority)
    };
    return clone;
  }
  isTooCloseToEdges(container) {
    var _a3, _b2;
    const minSpacing = ((_b2 = (_a3 = container.saw) == null ? void 0 : _a3.options) == null ? void 0 : _b2.minSpacing) || this.minSpacing;
    if (!minSpacing) return false;
    return this.getDistancesToContainerEdges(container).some((d2) => d2 > 0 && d2 <= minSpacing);
  }
  validateStripShapeBatches() {
    const groups = Object.values(this.guillotineData.stripShapeBatches.groups);
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (group.id !== this.id) {
        throw new Error(`strip shape group id does not match shape id ${this.id} ${group.id} ${i2}`);
      }
      if (![this.l, this.w].includes(group.dimension)) {
        throw new Error(`strip shape group dimension does not match shape dimensions ${this.id} ${group.id} ${i2} ${this.l} ${this.w} ${group.dimension}`);
      }
    }
  }
  getStripShapeBatchData(batchNumber) {
    var _a3;
    if (typeof batchNumber !== "number") return false;
    if (!((_a3 = this == null ? void 0 : this.guillotineData) == null ? void 0 : _a3.stripShapeBatches)) return false;
    if (!this.guillotineData.stripShapeBatches.groups) return false;
    if (!(batchNumber in this.guillotineData.stripShapeBatches.groups))
      return false;
    return this.guillotineData.stripShapeBatches.groups[batchNumber];
  }
  isInStripShapeBatch(batchNumber) {
    const batchInfo = this.getStripShapeBatchData(batchNumber);
    if (!batchInfo) return false;
    return true;
  }
  isStacked() {
    return this.added && this.stock && this.stock.isStacked();
  }
}
class Segment extends Container {
  constructor(data) {
    if (!data) return;
    data.preventAutoRotation = true;
    super(data);
    __publicField(this, "firstShape");
    __publicField(this, "cuts");
    __publicField(this, "phase");
    __publicField(this, "merged");
    __publicField(this, "children");
    __publicField(this, "siblings");
    //used by vis only
    __publicField(this, "parent");
    __publicField(this, "segmentType");
    __publicField(this, "completed");
    //used by vis only
    __publicField(this, "rowSegment");
    //used by cuts
    __publicField(this, "placementOrder");
    __publicField(this, "hasBeamTrim");
    __publicField(this, "cutDirection");
    this.validateSegment(data);
    if (this.issues.length)
      throw new Error(`Segment validation failed - ${this.issues.join(" ")}`);
    delete this.trim;
    delete this.trimmed;
    this.shapes = valueSet(data == null ? void 0 : data.shapes) ? data.shapes : [];
    this.firstShape = valueSet(data == null ? void 0 : data.firstShape) ? data.firstShape : null;
    this.cuts = [];
    this.phase = valueSet(data == null ? void 0 : data.phase) ? data.phase : null;
    this.merged = valueSet(data == null ? void 0 : data.merged) ? data.merged : false;
    this.parent = valueSet(data == null ? void 0 : data.parent) ? data.parent : null;
    this.children = valueSet(data == null ? void 0 : data.children) ? data.children : [];
    this.siblings = valueSet(data == null ? void 0 : data.siblings) ? data.siblings : [];
    this.offcut = valueSet(data == null ? void 0 : data.offcut) ? data.offcut : false;
    this.segmentType = valueSet(data == null ? void 0 : data.segmentType) ? data.segmentType : null;
    this.placementOrder = null;
    this.cutDirection = valueSet(data == null ? void 0 : data.cutDirection) ? data.cutDirection : "l";
    this.hasBeamTrim = valueSet(data == null ? void 0 : data.hasBeamTrim) ? data.hasBeamTrim : false;
  }
  validateSegment(data) {
    var _a3, _b2;
    if (maths.lessThanOrEqualTo(data.w, 0) || maths.lessThanOrEqualTo(data.l, 0)) {
      this.issues.push({ message: `Zero / negative dimension - l: ${data.l}, w: ${data.w}.` });
    }
    if (maths.lessThan(data.x, 0) || maths.lessThan(data.y, 0)) {
      this.issues.push({ message: `Negative position - x: ${data == null ? void 0 : data.x}, y: ${data == null ? void 0 : data.y}.` });
    }
    if (data == null ? void 0 : data.stock) {
      if (maths.greaterThan(data.x + data.l, data.stock.l) || maths.greaterThan(data.y + data.w, data.stock.w)) {
        this.issues.push({ message: `Outside of stock ${data.stock.id} - x: ${data.x}, y: ${data.y}, l: ${data.l}, w: ${data.w}, sl: ${(_a3 = data == null ? void 0 : data.stock) == null ? void 0 : _a3.l}, sw: ${(_b2 = data == null ? void 0 : data.stock) == null ? void 0 : _b2.w}.` });
      }
    }
  }
  //compress for saving / transfer
  save() {
    var _a3;
    this.children = this.children.map((c2) => {
      return {
        id: c2.id,
        x: c2.x,
        y: c2.y,
        l: c2.l,
        w: c2.w,
        offcut: c2.offcut
      };
    });
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((_a3 = this == null ? void 0 : this.stock) == null ? void 0 : _a3.id);
    delete this.stock;
    delete this.shapes;
    delete this.saw;
    delete this.siblings;
    delete this.parent;
    delete this.trim;
    this.algoBenchmark = null;
  }
  getBladeWidth() {
    return this.stock.getBladeWidth();
  }
  /**
   * create a normalised shape list to allow searching for duplicates
   */
  getNormalisedShapes(shapes) {
    return shapes.map((shape) => {
      const normalisedShape = {
        x: shape.x - this.x,
        y: shape.y - this.y,
        l: shape.l,
        w: shape.w
      };
      return normalisedShape;
    });
  }
  reset() {
    this.stock.used = false;
    this.children = [];
    this.siblings = [];
    this.parent = null;
    this.cuts = [];
    this.phase = null;
  }
}
class Group extends Shape {
  //used for sorting
  constructor(data) {
    var _a3, _b2;
    data = sanitiseData(data);
    if (!((_a3 = data == null ? void 0 : data.shapes) == null ? void 0 : _a3.length))
      throw new Error("attempting to create a group with no shapes");
    data.preventAutoRotation = true;
    super(data);
    __publicField(this, "shapes");
    __publicField(this, "positions");
    __publicField(this, "direction");
    __publicField(this, "container");
    __publicField(this, "outOfBounds");
    __publicField(this, "collision");
    __publicField(this, "counter", 0);
    __publicField(this, "type");
    __publicField(this, "efficiency");
    this.q = 1;
    delete this._banding;
    delete this._finish;
    delete this._trim;
    this.shapes = data.shapes;
    this.positions = ((_b2 = data == null ? void 0 : data.positions) == null ? void 0 : _b2.length) ? data.positions : [];
    this.direction = data.direction;
    this.container = data.container;
    this.type = (data == null ? void 0 : data.type) ?? "auto";
    this.initGroup();
  }
  initGroup() {
    var _a3;
    if (!((_a3 = this == null ? void 0 : this.shapes) == null ? void 0 : _a3.length)) return;
    this.setShapePositions();
    if (this.w > this.l) this.orientationLock = "w";
    else this.orientationLock = "l";
    if (this.container) {
      this.efficiency = this[this.direction] / this.container[this.direction];
    }
  }
  setShapePositions() {
    if (!this.container) return;
    this.positions = [];
    if (this.type !== "user") this.sortShapes();
    let currentPosition = 0;
    const groupAxis = getAxisFromDimension(this.direction);
    this.shapes.forEach((s2, i2) => {
      this.positions.push({
        shape: s2.id,
        [groupAxis]: currentPosition,
        [getReverseAxis(groupAxis)]: 0,
        rot: s2.rot.valueOf()
      });
      s2.inGroup = true;
      currentPosition += i2 === this.shapes.length - 1 ? s2[this.direction] : s2[this.direction] + s2.getMinSpacing(this.container);
    });
    this[this.direction] = currentPosition;
    const secondaryDimension = getReverseDimension(this.direction);
    const largestShapeInOtherDirection = this.shapes.reduce((max2, shape) => shape[secondaryDimension] > max2 ? shape[secondaryDimension] : max2, 0);
    this[secondaryDimension] = largestShapeInOtherDirection;
    if (isDev()) {
      const totalSpacing = this.shapes.slice(0, -1).reduce((total, shape) => total + shape.getMinSpacing(this.container), 0);
      const totalShapeDimension = this.shapes.reduce((total, shape) => total + shape[this.direction], 0);
      const totalInDirection = totalShapeDimension + totalSpacing;
      test([
        () => expect(maths.equalTo(totalInDirection, this[this.direction]), "group dimension is incorrect in direction").to.be.true,
        () => expect(currentPosition, "currentPosition is incorrect in direction").to.equal(this[this.direction]),
        () => expect(largestShapeInOtherDirection, "group dimension in other direction is not correct").to.equal(this[secondaryDimension])
      ]);
    }
    if (this.w > this.container.w || this.l > this.container.l) {
      throw new Error(`group ${this.id} is bigger than container - group ${this.l}x${this.w}, container ${this.container.l}x${this.container.w}`);
    }
  }
  //update the shape spacing and overall group dimensions to account for min spacing
  updateShapeSpacing(container) {
    this.container = container;
    this.setShapePositions();
    if (this.w > this.l) this.orientationLock = "w";
    else this.orientationLock = "l";
    if (this.container) {
      this.efficiency = this[this.direction] / this.container[this.direction];
    }
  }
  //get the area of the shapes (does not include blade width) - overwrites the rectangle method
  getArea() {
    return this.shapes.reduce((total, shape) => total + shape.getArea(), 0);
  }
  destroy() {
    super.reset();
    for (const s2 of this.shapes) s2.reset(false, false, false);
  }
  reset() {
    super.reset();
    for (const s2 of this.shapes) s2.reset(false, false, true);
  }
  /**
   * orientate all the shapes correctly to fit in the group
   */
  orientateShapes(stock) {
    this.shapes.forEach((s2) => {
      const position = this.positions.find((p2) => p2.shape === s2.id);
      if (!position) throw new Error("position not found for shape in group");
      const result = s2.rotate(position.rot, stock);
      if (!result) throw new Error("orientateShapes - unable to rotate shape in group");
    });
  }
  /**
   * sort the shapes by size
   */
  sortShapes() {
    const sortDimension = getReverseDimension(this.direction);
    this.shapes.sort((a2, b2) => {
      if (b2[sortDimension] === a2[sortDimension]) {
        if (b2[this.direction] === a2[this.direction]) {
          return a2.id.localeCompare(b2.id, void 0, { numeric: true });
        }
        return b2[this.direction] - a2[this.direction];
      }
      return b2[sortDimension] - a2[sortDimension];
    });
  }
  /**
   * place the group shapes on the stock
   */
  placeMyShapes(stock) {
    if (!stock) throw new Error("placeShapes requires stock");
    this.addToStock(stock);
    for (let i2 = 0; i2 < this.shapes.length; i2++) {
      const s2 = this.shapes[i2];
      s2.addToStock(stock);
      const position = this.positions.find((p2) => p2.shape === s2.id);
      if (!position) throw new Error("position not found for shape in group");
      s2.x = this.x + position.x;
      s2.y = this.y + position.y;
      const rotationResult = s2.rotate(position.rot, stock);
      if (!rotationResult) throw new Error("placeMyShapes - unable to rotate shape in group");
      if (i2 === 0 && this.x === 0 && this.y === 0) {
        s2.isFirstShape = true;
      }
      s2.addedAsGroup = this.id;
      s2.inGroup = false;
      s2.score = this.score;
      const stripShapeBatchesData = s2.guillotineData.stripShapeBatches;
      s2.guillotineData = this.cloneGuillotineData();
      s2.guillotineData.stripShapeBatches = stripShapeBatchesData;
      s2.bestScore = this.bestScore;
      if (typeof this.placementOrder === "number") {
        s2.groupPlacementOrder = i2;
        s2.placementOrder = this.placementOrder + i2 / 1e6;
      }
    }
  }
  //this is for groups which are created once and reused between stock e.g. user groups
  orientateCorrectly(container) {
    this.orientateShapes(container);
    this.setRotationToOrientationLock(container);
  }
  clone(shapes = []) {
    const groupNumber = parseInt(this.id.split("g")[1]);
    const newID = `g${groupNumber + 1}`;
    const originalShapes = this.shapes;
    const originalContainer = this.container;
    const originalStock = this.stock;
    this.shapes = [];
    this.container = null;
    this.stock = null;
    const data = structuredClone(this);
    this.shapes = originalShapes;
    this.container = originalContainer;
    this.stock = originalStock;
    data.container = this.container;
    data.shapes = shapes;
    data.id = newID;
    return new Group(data);
  }
  compress() {
    const clone = super.compress.call(this);
    clone.direction = this.direction;
    clone.positions = structuredClone(this.positions);
    clone.shapes = this.shapes.map((s2) => s2.compress());
    clone.type = this.type;
    clone.cloneType = "group";
    return clone;
  }
}
function getMatchingStock(shape, stockList, stockMaterialPresent, stockThicknessPresent) {
  return stockList.filter((stock, stockIndex) => {
    var _a3, _b2;
    shape.stockMatch.material[stockIndex] = null;
    shape.stockMatch.thickness[stockIndex] = null;
    shape.stockMatch.width[stockIndex] = null;
    shape.stockMatch.fit[stockIndex] = null;
    if (isShape(shape) || isUserGroup(shape)) {
      if (willItFit(stock, shape)) {
        shape.stockMatch.fit[stockIndex] = true;
      } else {
        shape.stockMatch.fit[stockIndex] = false;
      }
    }
    if (!stockMaterialPresent) {
      shape.stockMatch.material[stockIndex] = true;
    } else if (!(stock == null ? void 0 : stock.material) && !(shape == null ? void 0 : shape.material) || ((_a3 = stock == null ? void 0 : stock.material) == null ? void 0 : _a3.toLowerCase()) === ((_b2 = shape == null ? void 0 : shape.material) == null ? void 0 : _b2.toLowerCase())) {
      shape.stockMatch.material[stockIndex] = true;
    } else {
      shape.stockMatch.material[stockIndex] = false;
    }
    if (!stockThicknessPresent) {
      shape.stockMatch.thickness[stockIndex] = true;
    } else if (valueSet(shape.t) && valueSet(stock.t)) {
      if (isShape(shape) && maths.equalTo(shape.t, stock.t)) {
        shape.stockMatch.thickness[stockIndex] = true;
      } else if (shape.t === stock.t) {
        shape.stockMatch.thickness[stockIndex] = true;
      }
    } else {
      shape.stockMatch.thickness[stockIndex] = false;
    }
    if (stock.type === "linear") {
      if (isShape(shape)) {
        if (shape.canRotate(0, stock) && maths.equalTo(shape.w, stock.w) || shape.canRotate(1, stock) && maths.equalTo(shape.l, stock.w))
          shape.stockMatch.width[stockIndex] = true;
        else {
          shape.stockMatch.width[stockIndex] = false;
        }
      }
    } else {
      shape.stockMatch.width[stockIndex] = true;
    }
    return shape.stockMatch.fit[stockIndex] && shape.stockMatch.material[stockIndex] && shape.stockMatch.thickness[stockIndex] && shape.stockMatch.width[stockIndex];
  });
}
function stockMatch(shapeList, stockList, stockType) {
  const isInputs = isInputShape(shapeList[0]);
  if (isInputs) {
    stockList = stockList.map((s2) => {
      const stock = new Stock(s2);
      stock.trimDimensions();
      return stock;
    });
    shapeList = shapeList.map((s2) => {
      const shape = new Shape(s2);
      shape.trimDimensions();
      return shape;
    });
  }
  if (isInputStock(stockList[0])) {
    stockList = stockList.map((s2, i2) => {
      s2.id = `${i2.toString()}.0`;
      return new Stock(s2);
    });
  }
  const stockLockSetManually = shapeList.some((s2) => valueSet(s2.stockLock) && s2.stockLock.length);
  if (stockLockSetManually) return;
  stockList = stockList.filter((s2) => s2.autoAdd === true || valueSet(s2.q) && s2.q > 0);
  const someStockMaterialSet = stockList.some((s2) => valueSet(s2.material));
  const someStockThicknessSet = stockList.some((s2) => valueSet(s2.t));
  const allocatedStock = /* @__PURE__ */ new Set();
  for (const shape of shapeList) {
    shape.stockMatch = {
      material: [],
      thickness: [],
      width: [],
      fit: []
    };
    const matchingStock = getMatchingStock(shape, stockList, someStockMaterialSet, someStockThicknessSet);
    shape.stockMatch.fit = !shape.stockMatch.fit.every((v2) => v2 === false);
    shape.stockMatch.material = !shape.stockMatch.material.every((v2) => v2 === false);
    shape.stockMatch.thickness = !shape.stockMatch.thickness.every((v2) => v2 === false);
    shape.stockMatch.width = !shape.stockMatch.width.every((v2) => v2 === false);
    if (!isInputs) {
      if (matchingStock.length) {
        const stockParentIds = matchingStock.map((stock) => stock.getParentID());
        shape.stockLock = stockParentIds;
        stockParentIds.forEach((id) => allocatedStock.add(id));
      } else {
        if (!shape.stockMatch.fit) {
          const dims = shape.getTrimmedDimensions();
          shape.issues.push({ message: `${dims.l.toFixed()}x${dims.w.toFixed()} will not fit on any stock - check dimensions, min spacing, trim & orientation lock` });
        } else {
          if (!shape.stockMatch.material) {
            shape.issues.push({ message: `materials must match - could not find any stock with ${shape.material ? shape.material + " material" : "no material set"}` });
          }
          if (!shape.stockMatch.thickness) {
            shape.issues.push({ message: `thicknesses must match - could not find any stock with ${shape.t ? "thickness " + shape.t : "no thickness set"}` });
          }
          if (stockType === "linear" && !shape.stockMatch.width) {
            shape.issues.push({ message: `widths must match for linear calculations - could not find any stock with ${shape.w ? "width " + shape.w : "no width set"}` });
          }
        }
      }
      shape.stockMatch = null;
    }
  }
  const unusableShapes = shapeList.filter((s2) => !s2.stockLock || !s2.stockLock.length).sort(sort.ID);
  const unusableStock = stockList.filter((s2) => !allocatedStock.has(s2.parentID)).sort(sort.ID);
  stockList = stockList.filter((s2) => isStock(s2)).filter((s2) => allocatedStock.has(s2.parentID));
  if (someStockMaterialSet || someStockThicknessSet)
    shapeList = shapeList.filter((s2) => {
      var _a3;
      return (_a3 = s2 == null ? void 0 : s2.stockLock) == null ? void 0 : _a3.length;
    });
  return {
    stockList,
    unusableStock,
    shapeList,
    unusableShapes
  };
}
function getStockGrainSummary(inputStock) {
  if (!inputStock.length) return "n";
  const grainValues = inputStock.map((s2) => s2.grain).filter((v2) => v2);
  if (!grainValues.length) return "n";
  if (grainValues.every((v2) => v2 === "l")) {
    return "l";
  } else if (grainValues.every((v2) => v2 === "w")) {
    return "w";
  } else if (grainValues.some((v2) => v2 === "l" || v2 === "w")) {
    return "y";
  } else {
    return "n";
  }
}
function isGroupData(data) {
  return data.shapes !== void 0;
}
function isGroup(object2) {
  return object2 instanceof Group && object2.type !== "user";
}
function isUserGroup(object2) {
  return object2 instanceof Group && object2.type === "user";
}
function isInputUserGroup(object2) {
  return object2 instanceof InputUserGroup;
}
function isInputStock(s2) {
  return s2 instanceof InputStock;
}
function isInputShape(s2) {
  return s2 instanceof InputShape;
}
function isStock(s2) {
  return s2 instanceof Stock;
}
function isContainer(s2) {
  return s2 instanceof Container;
}
function isShape(s2) {
  return s2 instanceof Shape && !(s2 instanceof Group);
}
function isShapeOrGroup(s2) {
  return s2 instanceof Shape || s2 instanceof Group;
}
function isSegment(s2) {
  return s2 instanceof Segment;
}
function isSaw(s2) {
  return s2 instanceof Saw;
}
function upperCase(string2) {
  if (!string2 || typeof string2 !== "string") return "";
  return string2.toUpperCase();
}
function checkObjectPathExists(obj, path2) {
  return path2.reduce((acc, key) => acc && acc[key] !== void 0 ? acc[key] : void 0, obj) !== void 0;
}
function getNestedObjectData(obj, path2) {
  return path2.reduce((acc, key) => acc && acc[key] !== void 0 ? acc[key] : void 0, obj);
}
function valueSet(value2) {
  if (value2 === void 0) return false;
  if (value2 === null || value2 === "") return false;
  if (typeof value2 === "object" && !Object.values(value2).length) return false;
  return true;
}
function objectValuesPresent(object2, truthy = true) {
  if (!valueSet(object2)) return false;
  if (typeof object2 !== "object") return false;
  const values = Object.values(object2);
  if (values.some((val) => {
    if (!valueSet(val)) return false;
    if (truthy && !val) return false;
    return true;
  })) {
    return true;
  }
  return false;
}
function getStackedStock(stockList) {
  if (!(stockList == null ? void 0 : stockList.length)) return [];
  return stockList.filter((stock) => stock.used && (stock.stack === false || typeof stock.stack === "number"));
}
function isElementFullScreenSupported() {
  const elem = document.documentElement;
  if ("requestFullscreen" in elem || "webkitRequestFullscreen" in elem || "mozRequestFullScreen" in elem || "msRequestFullscreen" in elem) {
    return true;
  }
  return false;
}
function sanitiseString(str) {
  if (!str) return null;
  str = str.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^ a-z0-9._\-|]/gim, "");
  return str.trim();
}
function truncateString(str, length = 100) {
  if (!str) return "";
  str = str.trim();
  str = str.substring(0, length);
  return str;
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b2[i2] = start += 1 << eb[i2 - 1];
  }
  var r = new i32(b2[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
      r[j2] = j2 - b2[i2] << 5 | i2;
    }
  }
  return { b: b2, r };
};
var _a2 = freb(fleb, 2), fl = _a2.b, revfl = _a2.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;
var rev = new u16(32768);
for (var i$1 = 0; i$1 < 32768; ++i$1) {
  var x$1 = (i$1 & 43690) >> 1 | (i$1 & 21845) << 1;
  x$1 = (x$1 & 52428) >> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >> 4 | (x$1 & 3855) << 4;
  rev[i$1] = ((x$1 & 65280) >> 8 | (x$1 & 255) << 8) >> 1;
}
var hMap = function(cd, mb, r) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2) {
    if (cd[i2])
      ++l2[cd[i2] - 1];
  }
  var le2 = new u16(mb);
  for (i2 = 1; i2 < mb; ++i2) {
    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le2[cd[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le2[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (var i$1 = 0; i$1 < 144; ++i$1)
  flt[i$1] = 8;
for (var i$1 = 144; i$1 < 256; ++i$1)
  flt[i$1] = 9;
for (var i$1 = 256; i$1 < 280; ++i$1)
  flt[i$1] = 7;
for (var i$1 = 280; i$1 < 288; ++i$1)
  flt[i$1] = 8;
var fdt = new u8(32);
for (var i$1 = 0; i$1 < 32; ++i$1)
  fdt[i$1] = 5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max$1 = function(a2) {
  var m2 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m2)
      m2 = a2[i2];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v2, s2, e) {
  if (e == null || e > v2.length)
    e = v2.length;
  return new u8(v2.subarray(s2, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt2) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt2)
    throw e;
  return e;
};
var inflt = function(dat, st2, buf, dict) {
  var sl = dat.length, dl = 0;
  if (!sl || st2.f && !st2.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st2.i != 2;
  var noSt = st2.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type3 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type3) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t2), bt2);
        st2.b = bt2 += l2, st2.p = pos = t2 * 8, st2.f = final;
        continue;
      } else if (type3 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type3 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max$1(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s2 = r >> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max$1(lt2);
        dbt = max$1(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c2)
        err(2);
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b2 = fleb[i2];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i2];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt2 + 131072);
        var end = bt2 + add;
        if (bt2 < dt2) {
          var shift = dl - dt2, dend = Math.min(dt2, end);
          if (shift + bt2 < 0)
            err(3);
          for (; bt2 < dend; ++bt2)
            buf[bt2] = dict[shift + bt2];
        }
        for (; bt2 < end; ++bt2)
          buf[bt2] = buf[bt2 - dt2];
      }
    }
    st2.l = lm, st2.p = lpos, st2.b = bt2, st2.f = final;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 != buf.length && noBuf ? slc(buf, 0, bt2) : buf.subarray(0, bt2);
};
var wbits = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
};
var wbits16 = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
  d2[o2 + 2] |= v2 >> 16;
};
var hTree = function(d2, mb) {
  var t2 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t2.push({ s: i2, f: d2[i2] });
  }
  var s2 = t2.length;
  var t22 = t2.slice();
  if (!s2)
    return { t: et$1, l: 0 };
  if (s2 == 1) {
    var v2 = new u8(t2[0].s + 1);
    v2[t2[0].s] = 1;
    return { t: v2, l: 1 };
  }
  t2.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l2 = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l2.f + r.f, l: l2, r };
  while (i1 != s2 - 1) {
    l2 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l2.f + r.f, l: l2, r };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt2; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return { c: cl.subarray(0, cli), n: s2 };
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a3 = hTree(lf, 15), dlt = _a3.t, mlb = _a3.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    ++lcfreq[lclt[i2] & 31];
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    ++lcfreq[lcdt[i2] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p2 + 3 * i2, lct[clim[i2]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    var sym = syms[i2];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
      var dst = sym & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[sym]), p2 += ll[sym];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
};
var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et$1 = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st2) {
  var s2 = st2.z || dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var lst = st2.l;
  var pos = (st2.r || 0) & 7;
  if (lvl) {
    if (pos)
      w2[0] = st2.r >> 3;
    var opt = deo[lvl - 1];
    var n2 = opt >> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
    for (; i2 + 2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
      syms[li++] = dat[i2];
      ++lf[dat[i2]];
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst) {
      st2.r = pos & 7 | w2[pos / 8 | 0] << 3;
      pos -= 7;
      st2.h = head, st2.p = prev, st2.i = i2, st2.w = wi;
    }
  } else {
    for (var i2 = st2.w || 0; i2 < s2 + lst; i2 += 65535) {
      var e = i2 + 65535;
      if (e >= s2) {
        w2[pos / 8 | 0] = lst;
        e = s2;
      }
      pos = wfblk(w2, pos + 1, dat.subarray(i2, e));
    }
    st2.i = s2;
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length | 0;
      for (var i2 = 0; i2 != l2; ) {
        var e = Math.min(i2 + 2655, l2);
        for (; i2 < e; ++i2)
          m2 += n2 += d2[i2];
        n2 = (n2 & 65535) + 15 * (n2 >> 16), m2 = (m2 & 65535) + 15 * (m2 >> 16);
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      a2 %= 65521, b2 %= 65521;
      return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b2 & 255) << 8 | b2 >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  if (!st2) {
    st2 = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st2.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
  c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
  if (o2.dictionary) {
    var h2 = adler();
    h2.p(o2.dictionary);
    wbytes(c2, 2, h2.d());
  }
};
var zls = function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
};
function zlibSync(data, opts) {
  if (!opts)
    opts = {};
  var a2 = adler();
  a2.p(data);
  var d2 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts), -4), { i: 2 }, opts, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et$1, { stream: true });
  tds = 1;
} catch (e) {
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var n = /* @__PURE__ */ function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i() {
  n.console && "function" == typeof n.console.log && n.console.log.apply(n.console, arguments);
}
var a = { log: i, warn: function(t2) {
  n.console && ("function" == typeof n.console.warn ? n.console.warn.apply(n.console, arguments) : i.call(null, arguments));
}, error: function(t2) {
  n.console && ("function" == typeof n.console.error ? n.console.error.apply(n.console, arguments) : i(t2));
} };
function o(t2, e, r) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t2), n2.responseType = "blob", n2.onload = function() {
    l(n2.response, e, r);
  }, n2.onerror = function() {
    a.error("could not download file");
  }, n2.send();
}
function s(t2) {
  var e = new XMLHttpRequest();
  e.open("HEAD", t2, false);
  try {
    e.send();
  } catch (t3) {
  }
  return e.status >= 200 && e.status <= 299;
}
function c(t2) {
  try {
    t2.dispatchEvent(new MouseEvent("click"));
  } catch (r) {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e);
  }
}
var u, h, l = n.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== n ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t2, e, r) {
  var i2 = n.URL || n.webkitURL, a2 = document.createElement("a");
  e = e || t2.name || "download", a2.download = e, a2.rel = "noopener", "string" == typeof t2 ? (a2.href = t2, a2.origin !== location.origin ? s(a2.href) ? o(t2, e, r) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = i2.createObjectURL(t2), setTimeout(function() {
    i2.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e, r, n2) {
  if (r = r || e.name || "download", "string" == typeof e) if (s(e)) o(e, r, n2);
  else {
    var i2 = document.createElement("a");
    i2.href = e, i2.target = "_blank", setTimeout(function() {
      c(i2);
    });
  }
  else navigator.msSaveOrOpenBlob(function(e3, r2) {
    return void 0 === r2 ? r2 = { autoBom: false } : "object" !== _typeof(r2) && (a.warn("Deprecated: Expected third argument to be a object"), r2 = { autoBom: !r2 }), r2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
  }(e, n2), r);
} : function(e, r, i2, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e) return o(e, r, i2);
  var s2 = "application/octet-stream" === e.type, c2 = /constructor/i.test(n.HTMLElement) || n.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
    var h2 = new FileReader();
    h2.onloadend = function() {
      var t2 = h2.result;
      t2 = u2 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t2 : location = t2, a2 = null;
    }, h2.readAsDataURL(e);
  } else {
    var l2 = n.URL || n.webkitURL, f2 = l2.createObjectURL(e);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function f(t2) {
  var e;
  t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6));
  t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
  for (var r = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
    return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
  } }], n2 = 0; n2 < r.length; n2++) {
    var i2 = r[n2].re, a2 = r[n2].process, o2 = i2.exec(t2);
    o2 && (e = a2(o2), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t3 = this.r.toString(16), e3 = this.g.toString(16), r2 = this.b.toString(16);
    return 1 == t3.length && (t3 = "0" + t3), 1 == e3.length && (e3 = "0" + e3), 1 == r2.length && (r2 = "0" + r2), "#" + t3 + e3 + r2;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function d(t2, e) {
  var r = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2[3];
  r = g(r, n2, i2, a2, e[0], 7, -680876936), a2 = g(a2, r, n2, i2, e[1], 12, -389564586), i2 = g(i2, a2, r, n2, e[2], 17, 606105819), n2 = g(n2, i2, a2, r, e[3], 22, -1044525330), r = g(r, n2, i2, a2, e[4], 7, -176418897), a2 = g(a2, r, n2, i2, e[5], 12, 1200080426), i2 = g(i2, a2, r, n2, e[6], 17, -1473231341), n2 = g(n2, i2, a2, r, e[7], 22, -45705983), r = g(r, n2, i2, a2, e[8], 7, 1770035416), a2 = g(a2, r, n2, i2, e[9], 12, -1958414417), i2 = g(i2, a2, r, n2, e[10], 17, -42063), n2 = g(n2, i2, a2, r, e[11], 22, -1990404162), r = g(r, n2, i2, a2, e[12], 7, 1804603682), a2 = g(a2, r, n2, i2, e[13], 12, -40341101), i2 = g(i2, a2, r, n2, e[14], 17, -1502002290), r = m(r, n2 = g(n2, i2, a2, r, e[15], 22, 1236535329), i2, a2, e[1], 5, -165796510), a2 = m(a2, r, n2, i2, e[6], 9, -1069501632), i2 = m(i2, a2, r, n2, e[11], 14, 643717713), n2 = m(n2, i2, a2, r, e[0], 20, -373897302), r = m(r, n2, i2, a2, e[5], 5, -701558691), a2 = m(a2, r, n2, i2, e[10], 9, 38016083), i2 = m(i2, a2, r, n2, e[15], 14, -660478335), n2 = m(n2, i2, a2, r, e[4], 20, -405537848), r = m(r, n2, i2, a2, e[9], 5, 568446438), a2 = m(a2, r, n2, i2, e[14], 9, -1019803690), i2 = m(i2, a2, r, n2, e[3], 14, -187363961), n2 = m(n2, i2, a2, r, e[8], 20, 1163531501), r = m(r, n2, i2, a2, e[13], 5, -1444681467), a2 = m(a2, r, n2, i2, e[2], 9, -51403784), i2 = m(i2, a2, r, n2, e[7], 14, 1735328473), r = v(r, n2 = m(n2, i2, a2, r, e[12], 20, -1926607734), i2, a2, e[5], 4, -378558), a2 = v(a2, r, n2, i2, e[8], 11, -2022574463), i2 = v(i2, a2, r, n2, e[11], 16, 1839030562), n2 = v(n2, i2, a2, r, e[14], 23, -35309556), r = v(r, n2, i2, a2, e[1], 4, -1530992060), a2 = v(a2, r, n2, i2, e[4], 11, 1272893353), i2 = v(i2, a2, r, n2, e[7], 16, -155497632), n2 = v(n2, i2, a2, r, e[10], 23, -1094730640), r = v(r, n2, i2, a2, e[13], 4, 681279174), a2 = v(a2, r, n2, i2, e[0], 11, -358537222), i2 = v(i2, a2, r, n2, e[3], 16, -722521979), n2 = v(n2, i2, a2, r, e[6], 23, 76029189), r = v(r, n2, i2, a2, e[9], 4, -640364487), a2 = v(a2, r, n2, i2, e[12], 11, -421815835), i2 = v(i2, a2, r, n2, e[15], 16, 530742520), r = b(r, n2 = v(n2, i2, a2, r, e[2], 23, -995338651), i2, a2, e[0], 6, -198630844), a2 = b(a2, r, n2, i2, e[7], 10, 1126891415), i2 = b(i2, a2, r, n2, e[14], 15, -1416354905), n2 = b(n2, i2, a2, r, e[5], 21, -57434055), r = b(r, n2, i2, a2, e[12], 6, 1700485571), a2 = b(a2, r, n2, i2, e[3], 10, -1894986606), i2 = b(i2, a2, r, n2, e[10], 15, -1051523), n2 = b(n2, i2, a2, r, e[1], 21, -2054922799), r = b(r, n2, i2, a2, e[8], 6, 1873313359), a2 = b(a2, r, n2, i2, e[15], 10, -30611744), i2 = b(i2, a2, r, n2, e[6], 15, -1560198380), n2 = b(n2, i2, a2, r, e[13], 21, 1309151649), r = b(r, n2, i2, a2, e[4], 6, -145523070), a2 = b(a2, r, n2, i2, e[11], 10, -1120210379), i2 = b(i2, a2, r, n2, e[2], 15, 718787259), n2 = b(n2, i2, a2, r, e[9], 21, -343485551), t2[0] = _(r, t2[0]), t2[1] = _(n2, t2[1]), t2[2] = _(i2, t2[2]), t2[3] = _(a2, t2[3]);
}
function p(t2, e, r, n2, i2, a2) {
  return e = _(_(e, t2), _(n2, a2)), _(e << i2 | e >>> 32 - i2, r);
}
function g(t2, e, r, n2, i2, a2, o2) {
  return p(e & r | ~e & n2, t2, e, i2, a2, o2);
}
function m(t2, e, r, n2, i2, a2, o2) {
  return p(e & n2 | r & ~n2, t2, e, i2, a2, o2);
}
function v(t2, e, r, n2, i2, a2, o2) {
  return p(e ^ r ^ n2, t2, e, i2, a2, o2);
}
function b(t2, e, r, n2, i2, a2, o2) {
  return p(r ^ (e | ~n2), t2, e, i2, a2, o2);
}
function y(t2) {
  var e, r = t2.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= t2.length; e += 64) d(n2, w(t2.substring(e - 64, e)));
  t2 = t2.substring(e - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < t2.length; e++) i2[e >> 2] |= t2.charCodeAt(e) << (e % 4 << 3);
  if (i2[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (d(n2, i2), e = 0; e < 16; e++) i2[e] = 0;
  return i2[14] = 8 * r, d(n2, i2), n2;
}
function w(t2) {
  var e, r = [];
  for (e = 0; e < 64; e += 4) r[e >> 2] = t2.charCodeAt(e) + (t2.charCodeAt(e + 1) << 8) + (t2.charCodeAt(e + 2) << 16) + (t2.charCodeAt(e + 3) << 24);
  return r;
}
u = n.atob.bind(n), h = n.btoa.bind(n);
var N = "0123456789abcdef".split("");
function L(t2) {
  for (var e = "", r = 0; r < 4; r++) e += N[t2 >> 8 * r + 4 & 15] + N[t2 >> 8 * r & 15];
  return e;
}
function A(t2) {
  return String.fromCharCode((255 & t2) >> 0, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
}
function x(t2) {
  return y(t2).map(A).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t2) {
  for (var e = 0; e < t2.length; e++) t2[e] = L(t2[e]);
  return t2.join("");
}(y("hello"));
function _(t2, e) {
  if (S) {
    var r = (65535 & t2) + (65535 & e);
    return (t2 >> 16) + (e >> 16) + (r >> 16) << 16 | 65535 & r;
  }
  return t2 + e & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function P(t2, e) {
  var r, n2, i2, a2;
  if (t2 !== r) {
    for (var o2 = (i2 = t2, a2 = 1 + (256 / t2.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++) s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h2 = s2[c2];
      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
    }
    r = t2, n2 = s2;
  } else s2 = n2;
  var l2 = e.length, f2 = 0, d2 = 0, p2 = "";
  for (c2 = 0; c2 < l2; c2++) d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e.charCodeAt(c2) ^ o2);
  return p2;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t2, e, r, n2) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t2.forEach(function(t3) {
    if (void 0 !== k.perm) throw new Error("Invalid permission: " + t3);
    i2 += k[t3];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var a2 = (e + this.padding).substr(0, 32), o2 = (r + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t2) {
  if (/[^\u0000-\u00ff]/.test(t2)) throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
  for (var e = "", r = t2.length, n2 = 0; n2 < r; n2++) {
    var i2 = t2.charCodeAt(n2);
    if (i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126) e += "#" + ("0" + i2.toString(16)).slice(-2);
    else e += t2[n2];
  }
  return e;
}
function C(e) {
  if ("object" !== _typeof(e)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r = {};
  this.subscribe = function(t2, e3, n2) {
    if (n2 = n2 || false, "string" != typeof t2 || "function" != typeof e3 || "boolean" != typeof n2) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r.hasOwnProperty(t2) || (r[t2] = {});
    var i2 = Math.random().toString(35);
    return r[t2][i2] = [e3, !!n2], i2;
  }, this.unsubscribe = function(t2) {
    for (var e3 in r) if (r[e3][t2]) return delete r[e3][t2], 0 === Object.keys(r[e3]).length && delete r[e3], true;
    return false;
  }, this.publish = function(t2) {
    if (r.hasOwnProperty(t2)) {
      var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r[t2]) {
        var c2 = r[t2][s2];
        try {
          c2[0].apply(e, i2);
        } catch (t3) {
          n.console && a.error("jsPDF PubSub Error", t3.message, t3);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r;
  };
}
function j(t2) {
  if (!(this instanceof j)) return new j(t2);
  var e = "opacity,stroke-opacity".split(",");
  for (var r in t2) t2.hasOwnProperty(r) && e.indexOf(r) >= 0 && (this[r] = t2[r]);
  this.id = "", this.objectNumber = -1;
}
function O(t2, e) {
  this.gState = t2, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function B(t2, e, r, n2, i2) {
  if (!(this instanceof B)) return new B(t2, e, r, n2, i2);
  this.type = "axial" === t2 ? 2 : 3, this.coords = e, this.colors = r, O.call(this, n2, i2);
}
function M(t2, e, r, n2, i2) {
  if (!(this instanceof M)) return new M(t2, e, r, n2, i2);
  this.boundingBox = t2, this.xStep = e, this.yStep = r, this.stream = "", this.cloneIndex = 0, O.call(this, n2, i2);
}
function E(e) {
  var r, i2 = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
  "object" === _typeof(e = e || {}) && (i2 = e.orientation, o2 = e.unit || o2, s2 = e.format || s2, c2 = e.compress || e.compressPdf || c2, null !== (m2 = e.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = "number" == typeof e.userUnit ? Math.abs(e.userUnit) : 1, void 0 !== e.precision && (r = e.precision), void 0 !== e.floatPrecision && (p2 = e.floatPrecision), g2 = e.defaultPathOperation || "S"), u2 = e.filters || (true === c2 ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
  var v2 = e.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t2) {
    w2 = t2;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t2) {
    return L2[t2];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t2, e3) {
    if ("bold" == t2 && "normal" == e3 || "bold" == t2 && 400 == e3 || "normal" == t2 && "italic" == e3 || "bold" == t2 && "italic" == e3) throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t2 = 400 == e3 || "normal" === e3 ? "italic" === t2 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t2 ? (700 == e3 ? "bold" : e3) + "" + t2 : "bold"), t2;
  };
  y2.advancedAPI = function(t2) {
    var e3 = S2 === x2.COMPAT;
    return e3 && _2.call(this), "function" != typeof t2 || (t2(this), e3 && P2.call(this)), this;
  }, y2.compatAPI = function(t2) {
    var e3 = S2 === x2.ADVANCED;
    return e3 && P2.call(this), "function" != typeof t2 || (t2(this), e3 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = function(t2) {
    if (S2 !== x2.ADVANCED) throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t2, e3) {
    var n2 = r || e3;
    if (isNaN(t2) || isNaN(n2)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t2.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, p2);
  } : "smart" === p2 ? function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, t2 > -1 && t2 < 1 ? 16 : 5);
  } : function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t2, 2);
  }, T2 = y2.__private__.f3 = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t2, 3);
  }, U2 = y2.scale = y2.__private__.scale = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t2 * _t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, z2 = function(t2) {
    return S2 === x2.COMPAT ? Rr() - t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, H2 = function(t2) {
    return U2(z2(t2));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t2) {
    "number" == typeof parseInt(t2, 10) && (r = parseInt(t2, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t2) {
    return V2 = void 0 !== t2 && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m2 && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t2) {
    return Y2(t2), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t2) {
    var e3 = t2.getTimezoneOffset(), r2 = e3 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e3 / 60)), i3 = Math.abs(e3 % 60), a2 = [r2, Q2(n2), "'", Q2(i3), "'"].join("");
    return ["D:", t2.getFullYear(), Q2(t2.getMonth() + 1), Q2(t2.getDate()), Q2(t2.getHours()), Q2(t2.getMinutes()), Q2(t2.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t2) {
    var e3 = parseInt(t2.substr(2, 4), 10), r2 = parseInt(t2.substr(6, 2), 10) - 1, n2 = parseInt(t2.substr(8, 2), 10), i3 = parseInt(t2.substr(10, 2), 10), a2 = parseInt(t2.substr(12, 2), 10), o3 = parseInt(t2.substr(14, 2), 10);
    return new Date(e3, r2, n2, i3, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t2) {
    var e3;
    if (void 0 === t2 && (t2 = /* @__PURE__ */ new Date()), t2 instanceof Date) e3 = J2(t2);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t2;
    }
    return W2 = e3;
  }, Z2 = y2.__private__.getCreationDate = function(t2) {
    var e3 = W2;
    return "jsDate" === t2 && (e3 = X2(W2)), e3;
  };
  y2.setCreationDate = function(t2) {
    return K2(t2), this;
  }, y2.getCreationDate = function(t2) {
    return Z2(t2);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t2) {
    return ("0" + parseInt(t2)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t2) {
    return ("00" + (t2 = t2.toString())).substr(t2.length);
  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y2.__private__.setCustomOutputDestination = function(t2) {
    st2 = true, ct2 = t2;
  };
  var ht2 = function(t2) {
    st2 || (ct2 = t2);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t2) {
    return t2 = t2.toString(), it2 += t2.length + 1, ct2.push(t2), ct2;
  }, ft2 = y2.__private__.write = function(t2) {
    return lt2(1 === arguments.length ? t2.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t2) {
    for (var e3 = t2.length, r2 = new ArrayBuffer(e3), n2 = new Uint8Array(r2); e3--; ) n2[e3] = t2.charCodeAt(e3);
    return r2;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t2) {
    return gt2 = S2 === x2.ADVANCED ? t2 / _t2 : t2, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t2) {
    return bt2 = t2, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t2) {
    var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2)) mt2 = t2;
    else if (isNaN(t2)) {
      if (-1 === e3.indexOf(t2)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
      mt2 = t2;
    } else mt2 = parseInt(t2, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t2) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
    yt2 = t2;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t2) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
    Nt2 = t2;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t2, e3, r2) {
    return wt2(t2), At2(e3), Lt2(r2), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t2) {
    if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t2];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t2) {
    for (var e3 in xt2) xt2.hasOwnProperty(e3) && t2[e3] && (xt2[e3] = t2[e3]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t2, e3) {
    if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t2] = e3;
  };
  var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), Ut2 = e.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t2(e3, r2, n2, i3, a2, o3) {
    if (!(this instanceof t2)) return new t2(e3, r2, n2, i3, a2, o3);
    isNaN(e3) && (e3 = 1), isNaN(r2) && (r2 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r2, n2, i3, a2, o3];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t2) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t2);
  }, Vt2.prototype.multiply = function(t2) {
    var e3 = t2.sx * this.sx + t2.shy * this.shx, r2 = t2.sx * this.shy + t2.shy * this.sy, n2 = t2.shx * this.sx + t2.sy * this.shx, i3 = t2.shx * this.shy + t2.sy * this.sy, a2 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o3 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
    return new Vt2(e3, r2, n2, i3, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t2 = this.sx, e3 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t2 * t2 + e3 * e3), s3 = (t2 /= o3) * r2 + (e3 /= o3) * n2;
    r2 -= t2 * s3, n2 -= e3 * s3;
    var c3 = Math.sqrt(r2 * r2 + n2 * n2);
    return s3 /= c3, t2 * (n2 /= c3) < e3 * (r2 /= c3) && (t2 = -t2, e3 = -e3, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t2, e3, -e3, t2, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t2) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t2 = this.sx, e3 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t2 * n2 - e3 * r2), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r2 * o3, h2 = t2 * o3;
    return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);
  }, Vt2.prototype.applyToPoint = function(t2) {
    var e3 = t2.x * this.sx + t2.y * this.shx + this.tx, r2 = t2.x * this.shy + t2.y * this.sy + this.ty;
    return new Cr(e3, r2);
  }, Vt2.prototype.applyToRectangle = function(t2) {
    var e3 = this.applyToPoint(t2), r2 = this.applyToPoint(new Cr(t2.x + t2.w, t2.y + t2.h));
    return new jr(e3.x, e3.y, r2.x - e3.x, r2.y - e3.y);
  }, Vt2.prototype.clone = function() {
    var t2 = this.sx, e3 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
    return new Vt2(t2, e3, r2, n2, i3, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t2, e3) {
    return e3.multiply(t2);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = function(t2, e3) {
    if (!Bt2[t2]) {
      var r2 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e3.id = r2, Bt2[t2] = r2, Ot2[r2] = e3, Tt2.publish("addPattern", e3);
    }
  };
  y2.ShadingPattern = B, y2.TilingPattern = M, y2.addShadingPattern = function(t2, e3) {
    return q2("addShadingPattern()"), Jt2(t2, e3), this;
  }, y2.beginTilingPattern = function(t2) {
    q2("beginTilingPattern()"), Br(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
  }, y2.endTilingPattern = function(t2, e3) {
    q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t2, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
  };
  var Xt2 = y2.__private__.newObject = function() {
    var t2 = Kt2();
    return Zt2(t2, true), t2;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, rt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = function(t2, e3) {
    return e3 = "boolean" == typeof e3 && e3, rt2[t2] = it2, e3 && lt2(t2 + " 0 obj"), t2;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t2 = { objId: Kt2(), content: "" };
    return at2.push(t2), t2;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t2) {
    var e3 = t2.split(" ");
    if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) {
      if (5 === e3.length && ("k" === e3[4] || "K" === e3[4])) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r2 = parseFloat(e3[0]);
      e3 = [r2, r2, r2, "r"];
    }
    for (var n2 = "#", i3 = 0; i3 < 3; i3++) n2 += ("0" + Math.floor(255 * parseFloat(e3[i3])).toString(16)).slice(-2);
    return n2;
  }, re2 = y2.__private__.encodeColorString = function(e3) {
    var r2;
    "string" == typeof e3 && (e3 = { ch1: e3 });
    var n2 = e3.ch1, i3 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n2 && "#" !== n2.charAt(0)) {
      var c3 = new f(n2);
      if (c3.ok) n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2)) throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n2 && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), "string" == typeof n2 && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (void 0 === i3 || void 0 === o3 && n2 === i3 && i3 === a2) if ("string" == typeof n2) r2 = n2 + " " + s3[0];
    else switch (e3.precision) {
      case 2:
        r2 = R2(n2 / 255) + " " + s3[0];
        break;
      case 3:
      default:
        r2 = T2(n2 / 255) + " " + s3[0];
    }
    else if (void 0 === o3 || "object" === _typeof(o3)) {
      if (o3 && !isNaN(o3.a) && 0 === o3.a) return r2 = ["1.", "1.", "1.", s3[1]].join(" ");
      if ("string" == typeof n2) r2 = [n2, i3, a2, s3[1]].join(" ");
      else switch (e3.precision) {
        case 2:
          r2 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
          break;
        default:
        case 3:
          r2 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
      }
    } else if ("string" == typeof n2) r2 = [n2, i3, a2, o3, s3[2]].join(" ");
    else switch (e3.precision) {
      case 2:
        r2 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
        break;
      case 3:
      default:
        r2 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
    }
    return r2;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t2) {
    var e3 = (t2 = t2 || {}).data || "", r2 = t2.filters || ne2(), n2 = t2.alreadyAppliedFilters || [], i3 = t2.addLength1 || false, a2 = e3.length, o3 = t2.objectId, s3 = function(t3) {
      return t3;
    };
    if (null !== m2 && void 0 === o3) throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m2 && (s3 = Ye.encryptor(o3, 0));
    var c3 = {};
    true === r2 && (r2 = ["FlateEncode"]);
    var u3 = t2.additionalKeyValues || [], h2 = (c3 = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e3, r2) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (0 !== c3.data.length && (u3.push({ key: "Length", value: c3.data.length }), true === i3 && u3.push({ key: "Length1", value: a2 })), 0 != h2.length) if (h2.split("/").length - 1 == 1) u3.push({ key: "Filter", value: h2 });
    else {
      u3.push({ key: "Filter", value: "[" + h2 + "]" });
      for (var l2 = 0; l2 < u3.length; l2 += 1) if ("DecodeParms" === u3[l2].key) {
        for (var f2 = [], d4 = 0; d4 < c3.reverseChain.split("/").length - 1; d4 += 1) f2.push("null");
        f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
      }
    }
    lt2("<<");
    for (var p3 = 0; p3 < u3.length; p3++) lt2("/" + u3[p3].key + " " + u3[p3].value);
    lt2(">>"), 0 !== c3.data.length && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t2) {
    var e3 = t2.number, r2 = t2.data, n2 = t2.objId, i3 = t2.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t2.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t2.mediaBox.bottomLeftY)) + " " + O2(t2.mediaBox.topRightX) + " " + O2(t2.mediaBox.topRightY) + "]"), null !== t2.cropBox && lt2("/CropBox [" + O2(t2.cropBox.bottomLeftX) + " " + O2(t2.cropBox.bottomLeftY) + " " + O2(t2.cropBox.topRightX) + " " + O2(t2.cropBox.topRightY) + "]"), null !== t2.bleedBox && lt2("/BleedBox [" + O2(t2.bleedBox.bottomLeftX) + " " + O2(t2.bleedBox.bottomLeftY) + " " + O2(t2.bleedBox.topRightX) + " " + O2(t2.bleedBox.topRightY) + "]"), null !== t2.trimBox && lt2("/TrimBox [" + O2(t2.trimBox.bottomLeftX) + " " + O2(t2.trimBox.bottomLeftY) + " " + O2(t2.trimBox.topRightX) + " " + O2(t2.trimBox.topRightY) + "]"), null !== t2.artBox && lt2("/ArtBox [" + O2(t2.artBox.bottomLeftX) + " " + O2(t2.artBox.bottomLeftY) + " " + O2(t2.artBox.topRightX) + " " + O2(t2.artBox.topRightY) + "]"), "number" == typeof t2.userUnit && 1 !== t2.userUnit && lt2("/UserUnit " + t2.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e3], pageNumber: e3, page: r2 }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r2.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t2, e3, r2 = [];
    for (t2 = 1; t2 <= Dt2; t2++) Rt2[t2].objId = Kt2(), Rt2[t2].contentsObjId = Kt2();
    for (t2 = 1; t2 <= Dt2; t2++) r2.push(ae2({ number: t2, data: ot2[t2], objId: Rt2[t2].objId, contentsObjId: Rt2[t2].contentsObjId, mediaBox: Rt2[t2].mediaBox, cropBox: Rt2[t2].cropBox, bleedBox: Rt2[t2].bleedBox, trimBox: Rt2[t2].trimBox, artBox: Rt2[t2].artBox, userUnit: Rt2[t2].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e3 = 0; e3 < Dt2; e3++) n2 += r2[e3] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t2) {
    Tt2.publish("putFont", { font: t2, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t2.isAlreadyPutted && (t2.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t2.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t2.encoding && lt2("/Encoding /" + t2.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t2 in Ft2) Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && se2(Ft2[t2]);
  }, ue2 = function(t2) {
    t2.objectNumber = Xt2();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O2(t2.x), O2(t2.y), O2(t2.x + t2.width), O2(t2.y + t2.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
    var r2 = t2.pages[1].join("\n");
    ie2({ data: r2, additionalKeyValues: e3, objectId: t2.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t2 in zt2) zt2.hasOwnProperty(t2) && ue2(zt2[t2]);
  }, le2 = function(t2, e3) {
    var r2, n2 = [], i3 = 1 / (e3 - 1);
    for (r2 = 0; r2 < 1; r2 += i3) n2.push(r2);
    if (n2.push(1), 0 != t2[0].offset) {
      var a2 = { offset: 0, color: t2[0].color };
      t2.unshift(a2);
    }
    if (1 != t2[t2.length - 1].offset) {
      var o3 = { offset: 1, color: t2[t2.length - 1].color };
      t2.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r2 = n2[u3]; r2 > t2[c3 + 1].offset; ) c3++;
      var h2 = t2[c3].offset, l2 = (r2 - h2) / (t2[c3 + 1].offset - h2), f2 = t2[c3].color, d4 = t2[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d4[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d4[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d4[2]).toString(16));
    }
    return s3.trim();
  }, fe2 = function(t2, e3) {
    e3 || (e3 = 21);
    var r2 = Xt2(), n2 = le2(t2.colors, e3), i3 = [];
    i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e3 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r2 }), lt2("endobj"), t2.objectNumber = Xt2(), lt2("<< /ShadingType " + t2.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t2.coords[0])) + " " + O2(parseFloat(t2.coords[1])) + " ";
    2 === t2.type ? a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) : a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) + " " + O2(parseFloat(t2.coords[4])) + " " + O2(parseFloat(t2.coords[5])), lt2(a2 += "]"), t2.matrix && lt2("/Matrix [" + t2.matrix.toString() + "]"), lt2("/Function " + r2 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t2, e3) {
    var r2 = Kt2(), n2 = Xt2();
    e3.push({ resourcesOid: r2, objectOid: n2 }), t2.objectNumber = n2;
    var i3 = [];
    i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t2.boundingBox.map(O2).join(" ") + "]" }), i3.push({ key: "XStep", value: O2(t2.xStep) }), i3.push({ key: "YStep", value: O2(t2.yStep) }), i3.push({ key: "Resources", value: r2 + " 0 R" }), t2.matrix && i3.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie2({ data: t2.stream, additionalKeyValues: i3, objectId: t2.objectNumber }), lt2("endobj");
  }, pe2 = function(t2) {
    var e3;
    for (e3 in Ot2) Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M && de2(Ot2[e3], t2));
  }, ge2 = function(t2) {
    for (var e3 in t2.objectNumber = Xt2(), lt2("<<"), t2) switch (e3) {
      case "opacity":
        lt2("/ca " + R2(t2[e3]));
        break;
      case "stroke-opacity":
        lt2("/CA " + R2(t2[e3]));
    }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t2;
    for (t2 in Mt2) Mt2.hasOwnProperty(t2) && ge2(Mt2[t2]);
  }, ve2 = function() {
    for (var t2 in lt2("/XObject <<"), zt2) zt2.hasOwnProperty(t2) && zt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + zt2[t2].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t2 in lt2("/Font <<"), Ft2) Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && lt2("/" + t2 + " " + Ft2[t2].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t2 in lt2("/Shading <<"), Ot2) Ot2.hasOwnProperty(t2) && Ot2[t2] instanceof B && Ot2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Ot2[t2].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t2) {
    if (Object.keys(Ot2).length > 0) {
      for (var e3 in lt2("/Pattern <<"), Ot2) Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t2 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t2;
      for (t2 in lt2("/ExtGState <<"), Mt2) Mt2.hasOwnProperty(t2) && Mt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Mt2[t2].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t2) {
    Zt2(t2.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t2.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t2 = [];
    ce2(), me2(), he2(), pe2(t2), Tt2.publish("putResources"), t2.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t2 = 0; t2 < at2.length; t2++) {
      var e3 = at2[t2];
      Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t2) {
    Ct2[t2.fontName] = Ct2[t2.fontName] || {}, Ct2[t2.fontName][t2.fontStyle] = t2.id;
  }, Pe = function(t2, e3, r2, n2, i3) {
    var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t2, fontName: e3, fontStyle: r2, encoding: n2, isStandardFont: i3 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
  }, ke = function(t2) {
    for (var e3 = 0, r2 = pt2.length; e3 < r2; e3++) {
      var n2 = Pe.call(this, t2[e3][0], t2[e3][1], t2[e3][2], pt2[e3][3], true);
      false === v2 && (b2[n2] = true);
      var i3 = t2[e3][0].split("-");
      _e({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t2) {
    return t2.foo = function() {
      try {
        return t2.apply(this, arguments);
      } catch (t3) {
        var e3 = t3.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r2 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t3.message;
        if (!n.console) throw new Error(r2);
        n.console.error(r2, t3), n.alert && alert(r2);
      }
    }, t2.foo.bar = t2, t2.foo;
  }, Fe = function(t2, e3) {
    var r2, n2, i3, a2, o3, s3, c3, u3, h2;
    if (i3 = (e3 = e3 || {}).sourceEncoding || "Unicode", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft2[St2].metadata && Ft2[St2].metadata[i3] && Ft2[St2].metadata[i3].encoding && (a2 = Ft2[St2].metadata[i3].encoding, !o3 && Ft2[St2].encoding && (o3 = Ft2[St2].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), "string" == typeof o3 && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r2 = 0, n2 = t2.length; r2 < n2; r2++) (u3 = o3[t2.charCodeAt(r2)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t2[r2]), s3[r2].charCodeAt(0) >> 8 && (c3 = true);
      t2 = s3.join("");
    }
    for (r2 = t2.length; void 0 === c3 && 0 !== r2; ) t2.charCodeAt(r2 - 1) >> 8 && (c3 = true), r2--;
    if (!c3) return t2;
    for (s3 = e3.noBOM ? [] : [254, 255], r2 = 0, n2 = t2.length; r2 < n2; r2++) {
      if ((h2 = (u3 = t2.charCodeAt(r2)) >> 8) >> 8) throw new Error("Character at position " + r2 + " of string '" + t2 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h2), s3.push(u3 - (h2 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t2, e3) {
    return Fe(t2, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y2.__private__.beginPage = function(t2) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t2, e3) {
    var r2, n2, o3;
    switch (i2 = e3 || i2, "string" == typeof t2 && (r2 = A2(t2.toLowerCase()), Array.isArray(r2) && (n2 = r2[0], o3 = r2[1])), Array.isArray(t2) && (n2 = t2[0] * _t2, o3 = t2[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je(s2), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t2) {
    t2 > 0 && t2 <= Dt2 && (ot2.splice(t2, 1), Rt2.splice(t2, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t2) {
    t2 > 0 && t2 <= Dt2 && ($2 = t2);
  }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = function(t2, e3, r2) {
    var n2, i3 = void 0;
    return r2 = r2 || {}, t2 = void 0 !== t2 ? t2 : Ft2[St2].fontName, e3 = void 0 !== e3 ? e3 : Ft2[St2].fontStyle, n2 = t2.toLowerCase(), void 0 !== Ct2[n2] && void 0 !== Ct2[n2][e3] ? i3 = Ct2[n2][e3] : void 0 !== Ct2[t2] && void 0 !== Ct2[t2][e3] ? i3 = Ct2[t2][e3] : false === r2.disableWarning && a.warn("Unable to look up font label for font '" + t2 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i3 || r2.noFallback || null == (i3 = Ct2.times[e3]) && (i3 = Ct2.times.normal), i3;
  }, De = y2.__private__.putInfo = function() {
    var t2 = Xt2(), e3 = function(t3) {
      return t3;
    };
    for (var r2 in null !== m2 && (e3 = Ye.encryptor(t2, 0)), lt2("<<"), lt2("/Producer (" + Ce(e3("jsPDF " + E.version)) + ")"), xt2) xt2.hasOwnProperty(r2) && xt2[r2] && lt2("/" + r2.substr(0, 1).toUpperCase() + r2.substr(1) + " (" + Ce(e3(xt2[r2])) + ")");
    lt2("/CreationDate (" + Ce(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y2.__private__.putCatalog = function(t2) {
    var e3 = (t2 = t2 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r2 = "" + mt2;
        "%" === r2.substr(r2.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%ºß¬à");
  }, ze = y2.__private__.putXRef = function() {
    var t2 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et2; e3++) {
      "function" == typeof rt2[e3] ? lt2((t2 + rt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e3] ? lt2((t2 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue(), oe2(), Se(), xe(), null !== m2 && be2(), De(), Re();
    var t2 = it2;
    return ze(), Te(), lt2("startxref"), lt2("" + t2), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y2.__private__.getBlob = function(t2) {
    return new Blob([dt2(t2)], { type: "application/pdf" });
  }, Ve = y2.output = y2.__private__.output = Ie(function(t2, e3) {
    switch ("string" == typeof (e3 = e3 || {}) ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t2) {
      case void 0:
        return He();
      case "save":
        y2.save(e3.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n.URL && "function" == typeof n.URL.createObjectURL) return n.URL && n.URL.createObjectURL(We(He())) || void 0;
        a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r2 = "", i3 = He();
        try {
          r2 = h(i3);
        } catch (t3) {
          r2 = h(unescape(encodeURIComponent(i3)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r2;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e3.pdfObjectUrl && (o3 = e3.pdfObjectUrl, s3 = "");
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", u3 = n.open();
          return null !== u3 && u3.document.write(c3), u3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', f2 = n.open();
          if (null !== f2) {
            f2.document.write(l2);
            var d4 = this;
            f2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f2.document.title = e3.filename, f2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d4.output("bloburl"));
            };
          }
          return f2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = n.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e3.filename), g3 || "undefined" == typeof safari) return g3;
        break;
      case "datauri":
      case "dataurl":
        return n.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge = function(t2) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t2) > -1;
  };
  switch (o2) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if ("number" != typeof o2) throw new Error("Invalid unit: " + o2);
      _t2 = o2;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t2) {
    return null !== m2 ? Ye.encryptor(t2, 0) : function(t3) {
      return t3;
    };
  }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t2].objId, pageNumber: t2, pageContext: Rt2[t2] };
  }, Ke = y2.__private__.getPageInfoByObjId = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2) if (Rt2[e3].objId === t2) break;
    return Xe(e3);
  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t2) {
    return this.addPage(), this.movePage($2, t2), this;
  }, y2.movePage = function(t2, e3) {
    var r2, n2;
    if (t2 > e3) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var i3 = t2; i3 > e3; i3--) ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
      ot2[e3] = r2, Rt2[e3] = n2, this.setPage(e3);
    } else if (t2 < e3) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var a2 = t2; a2 < e3; a2++) ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e3] = r2, Rt2[e3] = n2, this.setPage(e3);
    }
    return this;
  }, y2.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e3, r2, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d4, p3, g3 = (i3 = i3 || {}).scope || this;
    if ("number" == typeof e3 && "number" == typeof r2 && ("string" == typeof n2 || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r2, r2 = e3, e3 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], "object" === _typeof(f2 = arguments[3]) && null !== f2 || ("string" == typeof c3 && (u3 = c3, c3 = null), "string" == typeof f2 && (u3 = f2, f2 = null), "number" == typeof f2 && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r2) || isNaN(n2) || null == e3) throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e3.length) return g3;
    var v3 = "", y3 = false, w3 = "number" == typeof i3.lineHeightFactor ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t2) {
      return t2 = t2.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce(t2, f2);
    }
    function A3(t2) {
      for (var e4, r3 = t2.concat(), n3 = [], i4 = r3.length; i4--; ) "string" == typeof (e4 = r3.shift()) ? n3.push(e4) : Array.isArray(t2) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);
      return n3;
    }
    function _3(t2, e4) {
      var r3;
      if ("string" == typeof t2) r3 = e4(t2)[0];
      else if (Array.isArray(t2)) {
        for (var n3, i4, a3 = t2.concat(), o4 = [], s4 = a3.length; s4--; ) "string" == typeof (n3 = a3.shift()) ? o4.push(e4(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i4 = e4(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
        r3 = o4;
      }
      return r3;
    }
    var P3 = false, k3 = true;
    if ("string" == typeof e3) P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; ) ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3) throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt2 / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
    switch (i3.baseline) {
      case "bottom":
        n2 -= B2;
        break;
      case "top":
        n2 += j2 - B2;
        break;
      case "hanging":
        n2 += j2 - 2 * B2;
        break;
      case "middle":
        n2 += j2 / 2 - B2;
    }
    if ((l2 = i3.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, l2) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t2, e4) {
      return t2.concat(g3.splitTextToSize(e4, l2));
    }, []))), o3 = { text: e3, x: r2, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e3 = o3.text, c3 = (i3 = o3.options).angle, p3 instanceof Vt2 == false && c3 && "number" == typeof c3) {
      c3 *= Math.PI / 180, 0 === i3.rotationDirection && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else c3 && c3 instanceof Vt2 && (p3 = c3);
    S2 !== x2.ADVANCED || p3 || (p3 = Yt2), void 0 !== (h2 = i3.charSpace || _r) && (v3 += O2(U2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d4 = i3.horizontalScale) && (v3 += O2(100 * d4) + " Tz\n");
    i3.lang;
    var D3 = -1, R3 = void 0 !== i3.renderingMode ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
    -1 !== D3 ? v3 += D3 + " Tr\n" : -1 !== z3 && (v3 += "0 Tr\n"), -1 !== D3 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
    var H3, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St2];
    h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);
    var Y3 = [], J3 = function(t2) {
      return g3.getStringUnitWidth(t2, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
    };
    if ("[object Array]" === Object.prototype.toString.call(e3)) {
      var X3;
      s3 = A3(e3), "left" !== u3 && (H3 = s3.map(J3));
      var K3, Z3 = 0;
      if ("right" === u3) {
        r2 -= H3[0], e3 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++) 0 === $3 ? (K3 = br(r2), X3 = yr(n2)) : (K3 = U2(Z3 - H3[$3]), X3 = -W3), e3.push([s3[$3], K3, X3]), Z3 = H3[$3];
      } else if ("center" === u3) {
        r2 -= H3[0] / 2, e3 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++) 0 === Q3 ? (K3 = br(r2), X3 = yr(n2)) : (K3 = U2((Z3 - H3[Q3]) / 2), X3 = -W3), e3.push([s3[Q3], K3, X3]), Z3 = H3[Q3];
      } else if ("left" === u3) {
        e3 = [], C2 = s3.length;
        for (var tt3 = 0; tt3 < C2; tt3++) e3.push(s3[tt3]);
      } else if ("justify" === u3 && "Identity-H" === G3.encoding) {
        e3 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (var et3 = 0, rt3 = 0; rt3 < C2; rt3++) if (X3 = 0 === rt3 ? yr(n2) : -W3, K3 = 0 === rt3 ? br(r2) : et3, rt3 < C2 - 1) {
          var nt3 = U2((l2 - H3[rt3]) / (s3[rt3].split(" ").length - 1)), it3 = s3[rt3].split(" ");
          e3.push([it3[0] + " ", K3, X3]), et3 = 0;
          for (var at3 = 1; at3 < it3.length; at3++) {
            var ot3 = (J3(it3[at3 - 1] + " " + it3[at3]) - J3(it3[at3])) * N3 + nt3;
            at3 == it3.length - 1 ? e3.push([it3[at3], ot3, 0]) : e3.push([it3[at3] + " ", ot3, 0]), et3 -= ot3;
          }
        } else e3.push([s3[rt3], K3, X3]);
        e3.push(["", et3, 0]);
      } else {
        if ("justify" !== u3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (rt3 = 0; rt3 < C2; rt3++) X3 = 0 === rt3 ? yr(n2) : -W3, K3 = 0 === rt3 ? br(r2) : 0, rt3 < C2 - 1 ? Y3.push(O2(U2((l2 - H3[rt3]) / (s3[rt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s3[rt3], K3, X3]);
      }
    }
    var st3 = "boolean" == typeof i3.R2L ? i3.R2L : bt2;
    true === st3 && (e3 = _3(e3, function(t2, e4, r3) {
      return [t2.split("").reverse().join(""), e4, r3];
    })), o3 = { text: e3, x: r2, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;
    var ct3 = Ft2[St2].encoding;
    "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e3 = _3(e3, function(t2, e4, r3) {
      return [L3(t2), e4, r3];
    })), s3 = A3(e3), e3 = [];
    for (var ut3, ht3, ft3, dt3 = 0, pt3 = 1, mt3 = Array.isArray(s3[0]) ? pt3 : dt3, vt3 = "", yt3 = function(t2, e4, r3) {
      var n3 = "";
      return r3 instanceof Vt2 ? (r3 = "number" == typeof i3.angle ? Gt2(r3, new Vt2(1, 0, 0, 1, t2, e4)) : Gt2(new Vt2(1, 0, 0, 1, t2, e4), r3), S2 === x2.ADVANCED && (r3 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r3)), n3 = r3.join(" ") + " Tm\n") : n3 = O2(t2) + " " + O2(e4) + " Td\n", n3;
    }, wt3 = 0; wt3 < s3.length; wt3++) {
      switch (vt3 = "", mt3) {
        case pt3:
          ft3 = (y3 ? "<" : "(") + s3[wt3][0] + (y3 ? ">" : ")"), ut3 = parseFloat(s3[wt3][1]), ht3 = parseFloat(s3[wt3][2]);
          break;
        case dt3:
          ft3 = (y3 ? "<" : "(") + s3[wt3] + (y3 ? ">" : ")"), ut3 = br(r2), ht3 = yr(n2);
      }
      void 0 !== Y3 && void 0 !== Y3[wt3] && (vt3 = Y3[wt3] + " Tw\n"), 0 === wt3 ? e3.push(vt3 + yt3(ut3, ht3, p3) + ft3) : mt3 === dt3 ? e3.push(vt3 + ft3) : mt3 === pt3 && e3.push(vt3 + yt3(ut3, ht3, p3) + ft3);
    }
    e3 = mt3 === dt3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var Nt3 = "BT\n/";
    return Nt3 += St2 + " " + gt2 + " Tf\n", Nt3 += O2(gt2 * w3) + " TL\n", Nt3 += xr + "\n", Nt3 += v3, Nt3 += e3, lt2(Nt3 += "ET"), b2[St2] = true, g3;
  };
  var $e = y2.__private__.clip = y2.clip = function(t2) {
    return lt2("evenodd" === t2 ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y2.__private__.isValidStyle = function(t2) {
    var e3 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) && (e3 = true), e3;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t2) {
    return Qe(t2) && (g2 = t2), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t2) {
    var e3 = g2;
    switch (t2) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t2;
    }
    return e3;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t2) {
    return rr("f", t2), this;
  }, y2.fillEvenOdd = function(t2) {
    return rr("f*", t2), this;
  }, y2.fillStroke = function(t2) {
    return rr("B", t2), this;
  }, y2.fillStrokeEvenOdd = function(t2) {
    return rr("B*", t2), this;
  };
  var rr = function(e3, r2) {
    "object" === _typeof(r2) ? ar(r2, e3) : lt2(e3);
  }, nr = function(t2) {
    null === t2 || S2 === x2.ADVANCED && void 0 === t2 || (t2 = tr(t2), lt2(t2));
  };
  function ir(t2, e3, r2, n2, i3) {
    var a2 = new M(e3 || this.boundingBox, r2 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
    a2.stream = this.stream;
    var o3 = t2 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  var ar = function(t2, e3) {
    var r2 = Bt2[t2.key], n2 = Ot2[r2];
    if (n2 instanceof B) lt2("q"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t2.matrix.toString() + " cm"), lt2("/" + r2 + " sh"), lt2("Q");
    else if (n2 instanceof M) {
      var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
      t2.matrix && (i3 = i3.multiply(t2.matrix || Yt2), r2 = ir.call(n2, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r2 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2("Q");
    }
  }, or = function(t2) {
    switch (t2) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y2.moveTo = function(t2, e3) {
    return lt2(O2(U2(t2)) + " " + O2(H2(e3)) + " m"), this;
  }, cr = y2.lineTo = function(t2, e3) {
    return lt2(O2(U2(t2)) + " " + O2(H2(e3)) + " l"), this;
  }, ur = y2.curveTo = function(t2, e3, r2, n2, i3, a2) {
    return lt2([O2(U2(t2)), O2(H2(e3)), O2(U2(r2)), O2(H2(n2)), O2(U2(i3)), O2(H2(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t2, e3, r2, n2, i3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || !Qe(i3)) throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r2 - t2, n2 - e3]], t2, e3, [1, 1], i3 || "S") : this.lines([[r2 - t2, n2 - e3]], t2, e3, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t2, e3, r2, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d4, p3, g3, m3, v3;
    if ("number" == typeof t2 && (v3 = r2, r2 = e3, e3 = t2, t2 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r2) || !Array.isArray(t2) || !Array.isArray(n2) || !Qe(i3) || "boolean" != typeof a2) throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r2), o3 = n2[0], s3 = n2[1], u3 = t2.length, g3 = e3, m3 = r2, c3 = 0; c3 < u3; c3++) 2 === (h2 = t2[c3]).length ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d4 = h2[2] * o3 + g3, p3 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d4, p3, g3, m3));
    return a2 && er(), nr(i3), this;
  }, y2.path = function(t2) {
    for (var e3 = 0; e3 < t2.length; e3++) {
      var r2 = t2[e3], n2 = r2.c;
      switch (r2.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t2, e3, r2, n2, i3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || !Qe(i3)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(U2(t2)), O2(H2(e3)), O2(U2(r2)), O2(U2(n2)), "re"].join(" ")), nr(i3), this;
  }, y2.__private__.triangle = y2.triangle = function(t2, e3, r2, n2, i3, a2, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r2 - t2, n2 - e3], [i3 - r2, a2 - n2], [t2 - i3, e3 - a2]], t2, e3, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t2, e3, r2, n2, i3, a2, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i3 = Math.min(i3, 0.5 * r2), a2 = Math.min(a2, 0.5 * n2), this.lines([[r2 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r2, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t2 + i3, e3, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t2, e3, r2, n2, i3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n2) || !Qe(i3)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r2, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t2 + r2, e3), ur(t2 + r2, e3 - o3, t2 + a2, e3 - n2, t2, e3 - n2), ur(t2 - a2, e3 - n2, t2 - r2, e3 - o3, t2 - r2, e3), ur(t2 - r2, e3 + o3, t2 - a2, e3 + n2, t2, e3 + n2), ur(t2 + a2, e3 + n2, t2 + r2, e3 + o3, t2 + r2, e3), nr(i3), this;
  }, y2.__private__.circle = y2.circle = function(t2, e3, r2, n2) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || !Qe(n2)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t2, e3, r2, r2, n2);
  }, y2.setFont = function(t2, e3, r2) {
    return r2 && (e3 = k2(e3, r2)), St2 = qe(t2, e3, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[qe.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t2, e3, r2 = {};
    for (t2 in Ct2) if (Ct2.hasOwnProperty(t2)) for (e3 in r2[t2] = [], Ct2[t2]) Ct2[t2].hasOwnProperty(e3) && r2[t2].push(e3);
    return r2;
  }, y2.addFont = function(t2, e3, r2, n2, i3) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a2.indexOf(arguments[3]) ? i3 = arguments[3] : arguments[3] && -1 == a2.indexOf(arguments[3]) && (r2 = k2(r2, n2)), i3 = i3 || "Identity-H", Pe.call(this, t2, e3, r2, i3);
  };
  var lr, fr = e.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t2) {
    return fr = t2, lt2(O2(U2(t2)) + " w"), this;
  };
  y2.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t2, e3) {
    if (t2 = t2 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t2)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t2 = t2.map(function(t3) {
      return O2(U2(t3));
    }).join(" "), e3 = O2(U2(e3)), lt2("[" + t2 + "] " + e3 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t2) {
    return "number" == typeof (t2 = t2 || 1.15) && (lr = t2), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t2) {
    return U2(t2);
  }, yr = y2.__private__.getVerticalCoordinate = function(t2) {
    return S2 === x2.ADVANCED ? t2 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t2);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t2) {
    return O2(br(t2));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t2) {
    return O2(yr(t2));
  }, Lr = e.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t2, e3, r2, n2) {
    return Lr = re2({ ch1: t2, ch2: e3, ch3: r2, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t2, e3, r2, n2) {
    return Ar = re2({ ch1: t2, ch2: e3, ch3: r2, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t2, e3, r2, n2) {
    return xr = re2({ ch1: t2, ch2: e3, ch3: r2, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t2, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t2) {
    var e3 = y2.CapJoinStyles[t2];
    if (void 0 === e3) throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt2(e3 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t2) {
    var e3 = y2.CapJoinStyles[t2];
    if (void 0 === e3) throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt2(e3 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t2) {
    if (t2 = t2 || 0, isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(U2(t2)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t2) {
    (t2 = "string" == typeof t2 ? Mt2[Et2[t2]] : Fr(null, t2)).equals(qt2) || (lt2("/" + t2.id + " gs"), qt2 = t2);
  };
  var Fr = function(t2, e3) {
    if (!t2 || !Et2[t2]) {
      var r2 = false;
      for (var n2 in Mt2) if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {
        r2 = true;
        break;
      }
      if (r2) e3 = Mt2[n2];
      else {
        var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i3] = e3, e3.id = i3;
      }
      return t2 && (Et2[t2] = e3.id), Tt2.publish("addGState", e3), e3;
    }
  };
  y2.addGState = function(t2, e3) {
    return Fr(t2, e3), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t2 = jt2.pop();
    return St2 = t2.key, gt2 = t2.size, xr = t2.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t2) {
    return lt2(t2.toString() + " cm"), this;
  }, y2.comment = function(t2) {
    return lt2("#" + t2), this;
  };
  var Cr = function(t2, e3) {
    var r2 = t2 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      isNaN(t3) || (r2 = parseFloat(t3));
    } });
    var n2 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t3) {
      isNaN(t3) || (n2 = parseFloat(t3));
    } });
    var i3 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i3;
    }, set: function(t3) {
      i3 = t3.toString();
    } }), this;
  }, jr = function(t2, e3, r2, n2) {
    Cr.call(this, t2, e3), this.type = "rect";
    var i3 = r2 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i3;
    }, set: function(t3) {
      isNaN(t3) || (i3 = parseFloat(t3));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = parseFloat(t3));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t2, e3, r2, n2, i3) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t2, kt2 = e3, It2 = i3, je([r2, n2]);
  }, Mr = function(t2) {
    if (Ht2[t2]) Wt2.pop().restore();
    else {
      var e3 = new Or(), r2 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
      e3.id = r2, Ht2[t2] = r2, zt2[r2] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
    }
  };
  for (var Er in y2.beginFormObject = function(t2, e3, r2, n2, i3) {
    return Br(t2, e3, r2, n2, i3), this;
  }, y2.endFormObject = function(t2) {
    return Mr(t2), this;
  }, y2.doFormObject = function(t2, e3) {
    var r2 = zt2[Ht2[t2]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r2.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t2) {
    var e3 = zt2[Ht2[t2]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y2.save = function(t2, e3) {
    return t2 = t2 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l(We(He()), t2), "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e4, r2) {
      try {
        var i3 = l(We(He()), t2);
        "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), e4(i3);
      } catch (t3) {
        r2(t3.message);
      }
    });
  }, E.API) E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t2, e3) {
    var r2, n2, i3;
    for (i3 = e3.length - 1; -1 !== i3; i3--) r2 = e3[i3][0], n2 = e3[i3][1], t2.subscribe.apply(t2, [r2].concat("function" == typeof n2 ? [n2] : n2));
  }(Tt2, E.API.events) : y2[Er] = E.API[Er]);
  var qr = y2.getPageWidth = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightX - Rt2[t2].mediaBox.bottomLeftX) / _t2;
  }, Dr = y2.setPageWidth = function(t2, e3) {
    Rt2[t2].mediaBox.topRightX = e3 * _t2 + Rt2[t2].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightY - Rt2[t2].mediaBox.bottomLeftY) / _t2;
  }, Tr = y2.setPageHeight = function(t2, e3) {
    Rt2[t2].mediaBox.topRightY = e3 * _t2 + Rt2[t2].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t2) {
    Dr($2, t2);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t2) {
    Tr($2, t2);
  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t2) {
    Dr($2, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t2) {
    Tr($2, t2);
  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St2 = "F1", Oe(s2, i2), Tt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t2) {
  return String.fromCharCode(t2 >> 0 & 255, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
}, I.prototype.toHexString = function(t2) {
  return t2.split("").map(function(t3) {
    return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t2) {
  for (var e = [], r = 0; r < t2.length; r += 2) e.push(String.fromCharCode(parseInt(t2.substr(r, 2), 16)));
  return e.join("");
}, I.prototype.processOwnerPassword = function(t2, e) {
  return P(x(e).substr(0, 5), t2);
}, I.prototype.encryptor = function(t2, e) {
  var r = x(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(t3) {
    return P(r, t3);
  };
}, j.prototype.equals = function(e) {
  var r, n2 = "id,objectNumber,equals";
  if (!e || _typeof(e) !== _typeof(this)) return false;
  var i2 = 0;
  for (r in this) if (!(n2.indexOf(r) >= 0)) {
    if (this.hasOwnProperty(r) && !e.hasOwnProperty(r)) return false;
    if (this[r] !== e[r]) return false;
    i2++;
  }
  for (r in e) e.hasOwnProperty(r) && n2.indexOf(r) < 0 && i2--;
  return 0 === i2;
}, E.API = { events: [] }, E.version = "2.5.2";
var q = E.API, D = 1, R = function(t2) {
  return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, T = function(t2) {
  return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, U = function(t2) {
  return t2.toFixed(2);
}, z = function(t2) {
  return t2.toFixed(5);
};
q.__acroform__ = {};
var H = function(t2, e) {
  t2.prototype = Object.create(e.prototype), t2.prototype.constructor = t2;
}, W = function(t2) {
  return t2 * D;
}, V = function(t2) {
  var e = new ut(), r = At.internal.getHeight(t2) || 0, n2 = At.internal.getWidth(t2) || 0;
  return e.BBox = [0, 0, Number(U(n2)), Number(U(r))], e;
}, G = q.__acroform__.setBit = function(t2, e) {
  if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t2 |= 1 << e;
}, Y = q.__acroform__.clearBit = function(t2, e) {
  if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t2 &= ~(1 << e);
}, J = q.__acroform__.getBit = function(t2, e) {
  if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t2 & 1 << e) ? 0 : 1;
}, X = q.__acroform__.getBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t2, e - 1);
}, K = q.__acroform__.setBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t2, e - 1);
}, Z = q.__acroform__.clearBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t2, e - 1);
}, $ = q.__acroform__.calculateCoordinates = function(t2, e) {
  var r = e.internal.getHorizontalCoordinate, n2 = e.internal.getVerticalCoordinate, i2 = t2[0], a2 = t2[1], o2 = t2[2], s2 = t2[3], c2 = {};
  return c2.lowerLeft_X = r(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(U(c2.lowerLeft_X)), Number(U(c2.lowerLeft_Y)), Number(U(c2.upperRight_X)), Number(U(c2.upperRight_Y))];
}, Q = function(t2) {
  if (t2.appearanceStreamContent) return t2.appearanceStreamContent;
  if (t2.V || t2.DV) {
    var e = [], r = t2._V || t2.DV, n2 = tt(t2, r), i2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(t2.scope.__private__.encodeColorString(t2.color)), e.push("/" + i2 + " " + U(n2.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n2.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var a2 = V(t2);
    return a2.scope = t2.scope, a2.stream = e.join("\n"), a2;
  }
}, tt = function(t2, e) {
  var r = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e = ")" == (e = "(" == e.substr(0, 1) ? e.substr(1) : e).substr(e.length - 1) ? e.substr(0, e.length - 1) : e).split(" ");
  i2 = t2.multiline ? i2.map(function(t3) {
    return t3.split("\n");
  }) : i2.map(function(t3) {
    return [t3];
  });
  var a2 = r, o2 = At.internal.getHeight(t2) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t2) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = function(e3, r2, n3) {
    if (e3 + 1 < i2.length) {
      var a3 = r2 + " " + i2[e3 + 1][0];
      return et(a3, t2, n3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t: for (; a2 > 0; ) {
    e = "", a2--;
    var u2, h2, l2 = et("3", t2, a2).height, f2 = t2.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
    if (a2 <= 0) {
      e = "(...) Tj\n", e += "% Width of Text: " + et(e, t2, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
      break;
    }
    for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++) if (i2.hasOwnProperty(y2)) {
      var w2 = false;
      if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
        if ((l2 + 2) * (b2 + 2) + 2 > o2) continue t;
        v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
      } else {
        v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
        var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
        if (L2 && !A2) {
          v2 += " ", m2 = 0;
          continue;
        }
        if (L2 || A2) {
          if (A2) g2 = N2;
          else if (t2.multiline && (l2 + 2) * (b2 + 2) + 2 > o2) continue t;
        } else {
          if (!t2.multiline) continue t;
          if ((l2 + 2) * (b2 + 2) + 2 > o2) continue t;
          g2 = N2;
        }
      }
      for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
        var _2 = i2[S2];
        if (t2.multiline) {
          if (S2 === g2) {
            x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
            continue;
          }
          if (S2 === p2) {
            x2 += _2[_2.length - 1] + " ";
            continue;
          }
        }
        x2 += _2[0] + " ";
      }
      switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t2, a2).width, t2.textAlign) {
        case "right":
          u2 = s2 - h2 - 2;
          break;
        case "center":
          u2 = (s2 - h2) / 2;
          break;
        case "left":
        default:
          u2 = 2;
      }
      e += U(u2) + " " + U(d2) + " Td\n", e += "(" + R(x2) + ") Tj\n", e += -U(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
    }
    break;
  }
  return n2.text = e, n2.fontSize = a2, n2;
}, et = function(t2, e, r) {
  var n2 = e.scope.internal.getFont(e.fontName, e.fontStyle), i2 = e.scope.getStringUnitWidth(t2, { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r);
  return { height: e.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r) * 1.5, width: i2 };
}, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = function(t2, e) {
  var r = { type: "reference", object: t2 };
  void 0 === e.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
    return t3.type === r.type && t3.object === r.object;
  }) && e.internal.getPageInfo(t2.page).pageContext.annotations.push(r);
}, it = function(e, r) {
  for (var n2 in e) if (e.hasOwnProperty(n2)) {
    var i2 = n2, a2 = e[n2];
    r.internal.newObjectDeferredBegin(a2.objId, true), "object" === _typeof(a2) && "function" == typeof a2.putStream && a2.putStream(), delete e[i2];
  }
}, at = function(e, r) {
  if (r.scope = e, void 0 !== e.internal && (void 0 === e.internal.acroformPlugin || false === e.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    D = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
      !function(t2) {
        t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
      }(e);
    }), e.internal.events.subscribe("buildDocument", function() {
      !function(t2) {
        t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r2 in e3) if (e3.hasOwnProperty(r2)) {
          var n2 = e3[r2];
          n2.objId = void 0, n2.hasAnnotation && nt(n2, t2);
        }
      }(e);
    }), e.internal.events.subscribe("putCatalog", function() {
      !function(t2) {
        if (void 0 === t2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
        t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e);
    }), e.internal.events.subscribe("postPutPages", function(r2) {
      !function(e3, r3) {
        var n2 = !e3;
        for (var i2 in e3 || (r3.internal.newObjectDeferredBegin(r3.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r3.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r3.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (e3.hasOwnProperty(i2)) {
          var a2 = e3[i2], o2 = [], s2 = a2.Rect;
          if (a2.Rect && (a2.Rect = $(a2.Rect, r3)), r3.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), "object" === _typeof(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
            var c2 = Q(a2);
            o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r3.internal.acroformPlugin.xForms.push(c2);
          }
          if (a2.appearanceStreamContent) {
            var u2 = "";
            for (var h2 in a2.appearanceStreamContent) if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
              var l2 = a2.appearanceStreamContent[h2];
              if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                for (var i2 in l2) if (l2.hasOwnProperty(i2)) {
                  var f2 = l2[i2];
                  "function" == typeof f2 && (f2 = f2.call(r3, a2)), u2 += "/" + i2 + " " + f2 + " ", r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                }
              } else "function" == typeof (f2 = l2) && (f2 = f2.call(r3, a2)), u2 += "/" + i2 + " " + f2, r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
              u2 += ">>";
            }
            o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
          }
          r3.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r3.internal.out("endobj");
        }
        n2 && it(r3.internal.acroformPlugin.xForms, r3);
      }(r2, e);
    }), e.internal.acroformPlugin.isInitialized = true;
  }
}, ot = q.__acroform__.arrayToPdfArray = function(e, r, n2) {
  var i2 = function(t2) {
    return t2;
  };
  if (Array.isArray(e)) {
    for (var a2 = "[", o2 = 0; o2 < e.length; o2++) switch (0 !== o2 && (a2 += " "), _typeof(e[o2])) {
      case "boolean":
      case "number":
      case "object":
        a2 += e[o2].toString();
        break;
      case "string":
        "/" !== e[o2].substr(0, 1) ? (void 0 !== r && n2 && (i2 = n2.internal.getEncryptor(r)), a2 += "(" + R(i2(e[o2].toString())) + ")") : a2 += e[o2].toString();
    }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t2, e, r) {
  var n2 = function(t3) {
    return t3;
  };
  return void 0 !== e && r && (n2 = r.internal.getEncryptor(e)), (t2 = t2 || "").toString(), t2 = "(" + R(n2(t2)) + ")";
}, ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t2) {
    this._objId = t2;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t2 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t2 = [], e = Object.getOwnPropertyNames(this).filter(function(t3) {
    return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
  });
  for (var r in e) if (false === Object.getOwnPropertyDescriptor(this, e[r]).configurable) {
    var n2 = e[r], i2 = this[n2];
    i2 && (Array.isArray(i2) ? t2.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t2.push({ key: n2, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t2.push({ key: n2, value: i2 }));
  }
  return t2;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t2, e = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e;
  }, set: function(t3) {
    e = t3;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t2 = e3.trim();
  }, get: function() {
    return t2 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t2, e = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t2) {
      var e3 = function(t3) {
        return t3;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t2)) + ")";
    }
  }, set: function(e3) {
    t2 = e3;
  } });
};
H(ht, ct);
var lt = function t() {
  ct.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    if (isNaN(t2)) throw new Error('Invalid value "' + t2 + '" for attribute F supplied.');
    e = t2;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.F = K(e, 3) : this.F = Z(e, 3);
  } });
  var r = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r;
  }, set: function(t2) {
    if (isNaN(t2)) throw new Error('Invalid value "' + t2 + '" for attribute Ff supplied.');
    r = t2;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n2.length) return n2;
  }, set: function(t2) {
    n2 = void 0 !== t2 ? t2 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t2) {
    n2[0] = t2;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t2) {
    n2[1] = t2;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t2) {
    n2[2] = t2;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t2) {
    n2[3] = t2;
  } });
  var i2 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i2;
  }, set: function(t2) {
    switch (t2) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i2 = t2;
        break;
      default:
        throw new Error('Invalid value "' + t2 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt) return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e3 = function(t2) {
      return t2;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a2)) + ")";
  }, set: function(t2) {
    a2 = t2.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t2) {
    a2 = t2;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t2) {
    o2 = t2;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t2) {
    s2 = t2;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t2) {
    c2 = t2;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u2 ? 50 / D : u2;
  }, set: function(t2) {
    u2 = t2;
  } });
  var h2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h2;
  }, set: function(t2) {
    h2 = t2;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt)) return st(l2, this.objId, this.scope);
  }, set: function(t2) {
    t2 = t2.toString(), l2 = t2;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2) return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == true ? "/" + t2 : t2;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2) return d2;
  }, set: function(t2) {
    this.V = t2;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2) return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == true ? "/" + t2 : t2;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p2, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t2) {
    t2 = Boolean(t2), g2 = t2;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p2) return p2;
  }, set: function(t2) {
    p2 = t2;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m2) return m2;
  }, set: function(t2) {
    if (-1 === [0, 1, 2].indexOf(t2)) throw new Error('Invalid value "' + t2 + '" for attribute Q supplied.');
    m2 = t2;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t2;
    switch (m2) {
      case 0:
      default:
        t2 = "left";
        break;
      case 1:
        t2 = "center";
        break;
      case 2:
        t2 = "right";
    }
    return t2;
  }, configurable: true, enumerable: true, set: function(t2) {
    switch (t2) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t2 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e3) {
    t2 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e3) {
    t2 = e3;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e, this.objId, this.scope);
  }, set: function(t3) {
    var r, n2;
    n2 = [], "string" == typeof (r = t3) && (n2 = function(t4, e3, r2) {
      r2 || (r2 = 1);
      for (var n3, i2 = []; n3 = e3.exec(t4); ) i2.push(n3[r2]);
      return i2;
    }(r, /\((.*?)\)/g)), e = n2;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t3) {
    e = t3, this.sort && e.sort();
  }, this.addOption = function(t3) {
    t3 = (t3 = t3 || "").toString(), e.push(t3), this.sort && e.sort();
  }, this.removeOption = function(t3, r) {
    for (r = r || false, t3 = (t3 = t3 || "").toString(); -1 !== e.indexOf(t3) && (e.splice(e.indexOf(t3), 1), false !== r); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t3) {
    true === this.combo && (true === Boolean(t3) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t3) {
    true === Boolean(t3) ? (this.Ff = K(this.Ff, 20), e.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e, r = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = function(t3) {
      return t3;
    };
    if (this.scope && (t2 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r).length) {
      var e3, n2 = [];
      for (e3 in n2.push("<<"), r) n2.push("/" + e3 + " (" + R(t2(r[e3])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e3) {
    "object" === _typeof(e3) && (r = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (r.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    e = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(t2) {
    e = "/" + t2;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t2 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e) {
    t2 = void 0 !== e ? e : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e, r;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    e = t2;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r;
  }, set: function(t2) {
    r = t2;
  } });
  var n2, i2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = function(t3) {
      return t3;
    };
    this.scope && (t2 = this.scope.internal.getEncryptor(this.objId));
    var e3, r2 = [];
    for (e3 in r2.push("<<"), i2) r2.push("/" + e3 + " (" + R(t2(i2[e3])) + ")");
    return r2.push(">>"), r2.join("\n");
  }, set: function(e3) {
    "object" === _typeof(e3) && (i2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i2.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (i2.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t2) {
    n2 = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t2) {
    n2 = "/" + t2;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t2) {
  if (!("createAppearanceStream" in t2) || !("getCA" in t2)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var r = this.Kids[e];
    r.appearanceStreamContent = t2.createAppearanceStream(r.optionName), r.caption = t2.getCA();
  }
}, bt.prototype.createOption = function(t2) {
  var e = new yt();
  return e.Parent = this, e.optionName = t2, this.Kids.push(e), xt.call(this.scope, e), e;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t2 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e) {
    t2 = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e) {
    Number.isInteger(e) && (t2 = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i2 = t2.scope.__private__.encodeColorString(t2.color), a2 = tt(t2, t2.caption);
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), r.push("BMC"), r.push("q"), r.push("0 0 1 rg"), r.push("/" + n2 + " " + U(a2.fontSize) + " Tf " + i2), r.push("BT"), r.push(a2.text), r.push("ET"), r.push("Q"), r.push("EMC"), e.stream = r.join("\n"), e;
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n2 = t2.scope.__private__.encodeColorString(t2.color), i2 = [], a2 = At.internal.getHeight(t2), o2 = At.internal.getWidth(t2), s2 = tt(t2, t2.caption);
  return i2.push("1 g"), i2.push("0 0 " + U(o2) + " " + U(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U(o2 - 1) + " " + U(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r + " " + U(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e.stream = i2.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
  var e = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[t2] = At.RadioButton.Circle.YesNormal, e.D[t2] = At.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
  return r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(i2 + " 0 m"), r.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r.push("f"), r.push("Q"), r.push("0 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(i2 + " 0 m"), r.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
} }, Cross: { createAppearanceStream: function(t2) {
  var e = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[t2] = At.RadioButton.Cross.YesNormal, e.D[t2] = At.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.calculateCross(t2);
  return r.push("q"), r.push("1 1 " + U(At.internal.getWidth(t2) - 2) + " " + U(At.internal.getHeight(t2) - 2) + " re"), r.push("W"), r.push("n"), r.push(U(n2.x1.x) + " " + U(n2.x1.y) + " m"), r.push(U(n2.x2.x) + " " + U(n2.x2.y) + " l"), r.push(U(n2.x4.x) + " " + U(n2.x4.y) + " m"), r.push(U(n2.x3.x) + " " + U(n2.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = At.internal.calculateCross(t2), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + U(At.internal.getWidth(t2) - 2) + " " + U(At.internal.getHeight(t2) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U(r.x1.x) + " " + U(r.x1.y) + " m"), n2.push(U(r.x2.x) + " " + U(r.x2.y) + " l"), n2.push(U(r.x4.x) + " " + U(r.x4.y) + " m"), n2.push(U(r.x3.x) + " " + U(r.x3.y) + " l"), n2.push("s"), n2.push("Q"), e.stream = n2.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
} } }, createDefaultAppearanceStream: function(t2) {
  var e = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r = t2.scope.__private__.encodeColorString(t2.color);
  return "/" + e + " " + t2.fontSize + " Tf " + r;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
  var e = At.internal.getWidth(t2), r = At.internal.getHeight(t2), n2 = Math.min(e, r);
  return { x1: { x: (e - n2) / 2, y: (r - n2) / 2 + n2 }, x2: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 }, x3: { x: (e - n2) / 2, y: (r - n2) / 2 }, x4: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e) {
  var r = 0;
  return "object" === _typeof(e) && (r = W(e.Rect[2])), r;
}, At.internal.getHeight = function(e) {
  var r = 0;
  return "object" === _typeof(e) && (r = W(e.Rect[3])), r;
};
var xt = q.addField = function(t2) {
  if (at(this, t2), !(t2 instanceof lt)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = t2).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = false, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
var St = E.AcroForm;
function _t(t2) {
  return t2.reduce(function(t3, e, r) {
    return t3[e] = r, t3;
  }, {});
}
!function(e) {
  e.__addimage__ = {};
  var r = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e.__addimage__.getImageFileTypeByImageData = function(t2, e3) {
    var i3, a3, o3, s3, c3, u2 = r;
    if ("RGBA" === (e3 = e3 || r) || void 0 !== t2.data && t2.data instanceof Uint8ClampedArray && "height" in t2 && "width" in t2) return "RGBA";
    if (x2(t2)) for (c3 in n2) for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
      for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1) if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t2[a3]) {
        s3 = false;
        break;
      }
      if (true === s3) {
        u2 = c3;
        break;
      }
    }
    else for (c3 in n2) for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
      for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1) if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t2.charCodeAt(a3)) {
        s3 = false;
        break;
      }
      if (true === s3) {
        u2 = c3;
        break;
      }
    }
    return u2 === r && e3 !== r && (u2 = e3), u2;
  }, a2 = function t2(e3) {
    for (var r2 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); ) i3.splice(i3.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++) o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    void 0 !== e3.sMask && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var u2 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
    if (n3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e3.objectId }), r2("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
      var h3 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l3 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h3, data: e3.sMask };
      "filter" in e3 && (l3.filter = e3.filter), t2.call(this, l3);
    }
    if (e3.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e3.palette)), objectId: f3 }), r2("endobj");
    }
  }, o2 = function() {
    var t2 = this.internal.collections.addImage_images;
    for (var e3 in t2) a2.call(this, t2[e3]);
  }, s2 = function() {
    var t2, e3 = this.internal.collections.addImage_images, r2 = this.internal.write;
    for (var n3 in e3) r2("/I" + (t2 = e3[n3]).index, t2.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, h2 = function() {
    var t2 = this.internal.collections.addImage_images;
    return c2.call(this), t2;
  }, l2 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f2 = function(t2) {
    return "function" == typeof e["process" + t2.toUpperCase()];
  }, d2 = function(e3) {
    return "object" === _typeof(e3) && 1 === e3.nodeType;
  }, p2 = function(t2, r2) {
    if ("IMG" === t2.nodeName && t2.hasAttribute("src")) {
      var n3 = "" + t2.getAttribute("src");
      if (0 === n3.indexOf("data:image/")) return u(unescape(n3).split("base64,").pop());
      var i3 = e.loadFile(n3, true);
      if (void 0 !== i3) return i3;
    }
    if ("CANVAS" === t2.nodeName) {
      if (0 === t2.width || 0 === t2.height) throw new Error("Given canvas must have data. Canvas width: " + t2.width + ", height: " + t2.height);
      var a3;
      switch (r2) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u(t2.toDataURL(a3, 1).split("base64,").pop());
    }
  }, g2 = function(t2) {
    var e3 = this.internal.collections.addImage_images;
    if (e3) {
      for (var r2 in e3) if (t2 === e3[r2].alias) return e3[r2];
    }
  }, m2 = function(t2, e3, r2) {
    return t2 || e3 || (t2 = -96, e3 = -96), t2 < 0 && (t2 = -1 * r2.width * 72 / t2 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r2.height * 72 / e3 / this.internal.scaleFactor), 0 === t2 && (t2 = e3 * r2.width / r2.height), 0 === e3 && (e3 = t2 * r2.height / r2.width), [t2, e3];
  }, v2 = function(t2, e3, r2, n3, i3, a3) {
    var o3 = m2.call(this, r2, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
    if (r2 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d4 = function(t3) {
        return t3.toFixed(4);
      }, p3 = [d4(l3), d4(f3), d4(-1 * f3), d4(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t2), c3(e3 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r2), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r2), "0", "0", s3(n3), s3(t2), c3(e3 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
  }, b2 = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e.__addimage__.sHashCode = function(t2) {
    var e3, r2, n3 = 0;
    if ("string" == typeof t2) for (r2 = t2.length, e3 = 0; e3 < r2; e3++) n3 = (n3 << 5) - n3 + t2.charCodeAt(e3), n3 |= 0;
    else if (x2(t2)) for (r2 = t2.byteLength / 2, e3 = 0; e3 < r2; e3++) n3 = (n3 << 5) - n3 + t2[e3], n3 |= 0;
    return n3;
  }, N2 = e.__addimage__.validateStringAsBase64 = function(t2) {
    (t2 = t2 || "").toString().trim();
    var e3 = true;
    return 0 === t2.length && (e3 = false), t2.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t2.substr(0, t2.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t2.substr(-2)) && (e3 = false), e3;
  }, L2 = e.__addimage__.extractImageFromDataUrl = function(t2) {
    var e3 = (t2 = t2 || "").split("base64,"), r2 = null;
    if (2 === e3.length) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
      Array.isArray(n3) && (r2 = { mimeType: n3[1], charset: n3[2], data: e3[1] });
    }
    return r2;
  }, A2 = e.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e.__addimage__.isArrayBuffer = function(t2) {
    return A2() && t2 instanceof ArrayBuffer;
  };
  var x2 = e.__addimage__.isArrayBufferView = function(t2) {
    return A2() && "undefined" != typeof Uint32Array && (t2 instanceof Int8Array || t2 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t2 instanceof Uint8ClampedArray || t2 instanceof Int16Array || t2 instanceof Uint16Array || t2 instanceof Int32Array || t2 instanceof Uint32Array || t2 instanceof Float32Array || t2 instanceof Float64Array);
  }, S2 = e.__addimage__.binaryStringToUint8Array = function(t2) {
    for (var e3 = t2.length, r2 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++) r2[n3] = t2.charCodeAt(n3);
    return r2;
  }, _2 = e.__addimage__.arrayBufferToBinaryString = function(t2) {
    for (var e3 = "", r2 = x2(t2) ? t2 : new Uint8Array(t2), n3 = 0; n3 < r2.length; n3 += 8192) e3 += String.fromCharCode.apply(null, r2.subarray(n3, n3 + 8192));
    return e3;
  };
  e.addImage = function() {
    var e3, n3, i3, a3, o3, s3, u2, h3, l3;
    if ("number" == typeof arguments[1] ? (n3 = r, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), "object" === _typeof(e3 = arguments[0]) && !d2(e3) && "imageData" in e3) {
      var f3 = e3;
      e3 = f3.imageData, n3 = f3.format || n3 || r, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
    }
    var p3 = this.internal.getFilters();
    if (void 0 === h3 && -1 !== p3.indexOf("FlateEncode") && (h3 = "SLOW"), isNaN(i3) || isNaN(a3)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e3, n3, u2, h3);
    return v2.call(this, i3, a3, o3, s3, g3, l3), this;
  };
  var P2 = function(t2, n3, a3, o3) {
    var s3, c3, u2;
    if ("string" == typeof t2 && i2(t2) === r) {
      t2 = unescape(t2);
      var h3 = k2(t2, false);
      ("" !== h3 || void 0 !== (h3 = e.loadFile(t2, true))) && (t2 = h3);
    }
    if (d2(t2) && (t2 = p2(t2, n3)), n3 = i2(t2, n3), !f2(n3)) throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if ((null == (u2 = a3) || 0 === u2.length) && (a3 = function(t3) {
      return "string" == typeof t3 || x2(t3) ? w2(t3) : x2(t3.data) ? w2(t3.data) : null;
    }(t2)), (s3 = g2.call(this, a3)) || (A2() && (t2 instanceof Uint8Array || "RGBA" === n3 || (c3 = t2, t2 = S2(t2))), s3 = this["process" + n3.toUpperCase()](t2, l2.call(this), a3, function(t3) {
      return t3 && "string" == typeof t3 && (t3 = t3.toUpperCase()), t3 in e.image_compression ? t3 : y2.NONE;
    }(o3), c3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e.__addimage__.convertBase64ToBinaryString = function(t2, e3) {
    var r2;
    e3 = "boolean" != typeof e3 || e3;
    var n3, i3 = "";
    if ("string" == typeof t2) {
      n3 = null !== (r2 = L2(t2)) ? r2.data : t2;
      try {
        i3 = u(n3);
      } catch (t3) {
        if (e3) throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i3;
  };
  e.getImageProperties = function(t2) {
    var n3, a3, o3 = "";
    if (d2(t2) && (t2 = p2(t2)), "string" == typeof t2 && i2(t2) === r && ("" === (o3 = k2(t2, false)) && (o3 = e.loadFile(t2) || ""), t2 = o3), a3 = i2(t2), !f2(a3)) throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t2 instanceof Uint8Array || (t2 = S2(t2)), !(n3 = this["process" + a3.toUpperCase()](t2))) throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function(t3) {
    if (void 0 !== t3 && "" != t3) return true;
  };
  E.API.events.push(["addPage", function(t3) {
    this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
  }]), t2.events.push(["putPage", function(t3) {
    for (var r, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), c2 = t3.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++) switch ((r = c2[h2]).type) {
      case "link":
        (e(r.options.url) || e(r.options.pageNumber)) && (u2 = true);
        break;
      case "reference":
      case "text":
      case "freetext":
        u2 = true;
    }
    if (0 != u2) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t3.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r.title || "Note";
            i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y) + "] ") + "/Contents (" + f2(m2(r.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
            var b2 = p2.objId + " 0 R";
            i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r.bounds.x + 30) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w + 30) + " " + o2(r.bounds.y) + "] ") + " /Parent " + b2, r.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y + r.bounds.h) + "] ";
            var y2 = r.color || "#000000";
            i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
            break;
          case "link":
            if (r.options.name) {
              var w2 = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = w2.page, r.options.top = w2.y;
            } else r.options.top || (r.options.top = 0);
            if (n2 = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", i2 = "", r.options.url) i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r.options.url)) + ") >>";
            else if (r.options.pageNumber) {
              switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
                case "Fit":
                  i2 += " /Fit]";
                  break;
                case "FitH":
                  i2 += " /FitH " + r.options.top + "]";
                  break;
                case "FitV":
                  r.options.left = r.options.left || 0, i2 += " /FitV " + r.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r.options.top);
                  r.options.left = r.options.left || 0, void 0 === r.options.zoom && (r.options.zoom = 0), i2 += " /XYZ " + r.options.left + " " + N2 + " " + r.options.zoom + "]";
              }
            }
            "" != i2 && (i2 += " >>", this.internal.write(i2));
        }
      }
      this.internal.write("]");
    }
  }]), t2.createAnnotation = function(t3) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t3.type) {
      case "link":
        this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t3);
    }
  }, t2.link = function(t3, e3, r, n2, i2) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e3), w: o2(t3 + r), h: s2(e3 + n2) }, options: i2, type: "link" });
  }, t2.textWithLink = function(t3, e3, r, n2) {
    var i2, a2, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n2.maxWidth) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t3, a2).length;
      i2 = Math.ceil(s2 * c2);
    } else a2 = o2, i2 = s2;
    return this.text(t3, e3, r, n2), r += 0.2 * s2, "center" === n2.align && (e3 -= o2 / 2), "right" === n2.align && (e3 -= o2), this.link(e3, r - s2, a2, i2, n2), o2;
  }, t2.getTextWidth = function(t3) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t3) * e3 / this.internal.scaleFactor;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
  t2.__arabicParser__ = {};
  var a2 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
    return void 0 !== e[t3.charCodeAt(0)];
  }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
    return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
  }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length <= 2;
  }, c2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
    return o2(t3) && i2.indexOf(t3.charCodeAt(0)) >= 0;
  };
  t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 1;
  };
  var u2 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 2;
  };
  t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 3;
  };
  var h2 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
    return o2(t3) && a2(t3) && 4 == e[t3.charCodeAt(0)].length;
  }, l2 = t2.__arabicParser__.resolveLigatures = function(t3) {
    var e3 = 0, n3 = r, i3 = "", a3 = 0;
    for (e3 = 0; e3 < t3.length; e3 += 1) void 0 !== n3[t3.charCodeAt(e3)] ? (a3++, "number" == typeof (n3 = n3[t3.charCodeAt(e3)]) && (i3 += String.fromCharCode(n3), n3 = r, a3 = 0), e3 === t3.length - 1 && (n3 = r, i3 += t3.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r, i3 += t3.charAt(e3 - a3), e3 -= a3, a3 = 0);
    return i3;
  };
  t2.__arabicParser__.isArabicDiacritic = function(t3) {
    return void 0 !== t3 && void 0 !== n2[t3.charCodeAt(0)];
  };
  var f2 = t2.__arabicParser__.getCorrectForm = function(t3, e3, r2) {
    return o2(t3) ? false === a2(t3) ? -1 : !u2(t3) || !o2(e3) && !o2(r2) || !o2(r2) && s2(e3) || s2(t3) && !o2(e3) || s2(t3) && c2(e3) || s2(t3) && s2(e3) ? 0 : h2(t3) && o2(e3) && !s2(e3) && o2(r2) && u2(r2) ? 3 : s2(t3) || !o2(r2) ? 1 : 2 : -1;
  }, d2 = function(t3) {
    var r2 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t3 = t3 || "").split("\\s+"), h3 = [];
    for (r2 = 0; r2 < u3.length; r2 += 1) {
      for (h3.push(""), n3 = 0; n3 < u3[r2].length; n3 += 1) a3 = u3[r2][n3], s3 = u3[r2][n3 - 1], c3 = u3[r2][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r2] += -1 !== i3 ? String.fromCharCode(e[a3.charCodeAt(0)][i3]) : a3) : h3[r2] += a3;
      h3[r2] = l2(h3[r2]);
    }
    return h3.join(" ");
  }, p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
    var t3, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r2 = [];
    if (Array.isArray(e3)) {
      var n3 = 0;
      for (r2 = [], n3 = 0; n3 < e3.length; n3 += 1) Array.isArray(e3[n3]) ? r2.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r2.push([d2(e3[n3])]);
      t3 = r2;
    } else t3 = d2(e3);
    return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
  };
  t2.events.push(["preProcessText", p2]);
}(E.API), E.API.autoPrint = function(t2) {
  var e;
  switch ((t2 = t2 || {}).variant = t2.variant || "non-conform", t2.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function() {
    var t3 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t4) {
      e3 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(t4) {
      r = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t4) {
      n2 = t4;
    } });
    var i2 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i2;
    }, set: function(t4) {
      i2 = t4;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t3, e3) {
    var r;
    if ("2d" !== (t3 = t3 || "2d")) return null;
    for (r in e3) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = e3[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t2.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(E.API), function(e) {
  var r = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t2 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t2;
    }, set: function(e4) {
      t2 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t3) {
      e3 = t3;
    } });
    var r2 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      r2 = t3;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t3) {
      n3 = t3;
    } });
    var i3 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i3;
    }, set: function(t3) {
      i3 = t3;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t3) {
      a3 = t3;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e.setHeaderFunction = function(t2) {
    return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t2 ? t2 : void 0, this;
  }, e.getTextDimensions = function(t2, e3) {
    i2.call(this);
    var r2 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t2) && "string" != typeof t2) {
      if ("number" != typeof t2) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t2 = String(t2);
    }
    var h2 = e3.maxWidth;
    h2 > 0 ? "string" == typeof t2 ? t2 = this.splitTextToSize(t2, h2) : "[object Array]" === Object.prototype.toString.call(t2) && (t2 = t2.reduce(function(t3, e4) {
      return t3.concat(u2.splitTextToSize(e4, h2));
    }, [])) : t2 = Array.isArray(t2) ? t2 : [t2];
    for (var l2 = 0; l2 < t2.length; l2++) o3 < (c3 = this.getStringUnitWidth(t2[l2], { font: n3 }) * r2) && (o3 = c3);
    return 0 !== o3 && (s3 = t2.length), { w: o3 /= a3, h: Math.max((s3 * r2 * this.getLineHeightFactor() - r2 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e.cellAddPage = function() {
    i2.call(this), this.addPage();
    var t2 = this.internal.__cell__.margins || r;
    return this.internal.__cell__.lastCell = new o2(t2.left, t2.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e.cell = function() {
    var t2;
    t2 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return void 0 !== e3.lineNumber && (e3.lineNumber === t2.lineNumber ? (t2.x = (e3.x || 0) + (e3.width || 0), t2.y = e3.y || 0) : e3.y + e3.height + t2.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t2.y = s3.top, u2 && c3 && (this.printHeaderRow(t2.lineNumber, true), t2.y += c3[0].height)) : t2.y = e3.y + e3.height || t2.y), void 0 !== t2.text[0] && (this.rect(t2.x, t2.y, t2.width, t2.height, true === n2 ? "FD" : void 0), "right" === t2.align ? this.text(t2.text, t2.x + t2.width - a3, t2.y + a3, { align: "right", baseline: "top" }) : "center" === t2.align ? this.text(t2.text, t2.x + t2.width / 2, t2.y + a3, { align: "center", baseline: "top", maxWidth: t2.width - a3 - a3 }) : this.text(t2.text, t2.x + a3, t2.y + a3, { align: "left", baseline: "top", maxWidth: t2.width - a3 - a3 })), this.internal.__cell__.lastCell = t2, this;
  };
  e.table = function(e3, n3, u2, h2, l2) {
    if (i2.call(this), !u2) throw new Error("No data for PDF table.");
    var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, S2 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r), P2 = "number" == typeof l2.padding ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h2) v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
      return "left";
    });
    else if (Array.isArray(h2) && "object" === _typeof(h2[0])) for (m2 = h2.map(function(t2) {
      return t2.name;
    }), v2 = h2.map(function(t2) {
      return t2.prompt || t2.name || "";
    }), b2 = h2.map(function(t2) {
      return t2.align || "left";
    }), f2 = 0; f2 < h2.length; f2 += 1) w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
    else Array.isArray(h2) && "string" == typeof h2[0] && (v2 = m2 = h2, b2 = m2.map(function() {
      return "left";
    }));
    if (A2 || Array.isArray(h2) && "string" == typeof h2[0]) for (f2 = 0; f2 < m2.length; f2 += 1) {
      for (y2[g2 = m2[f2]] = u2.map(function(t2) {
        return t2[g2];
      }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1) N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
    }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1) F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t2) {
        return new o2(e3, n3, w2[t2], C2, F2[t2].text, void 0, F2[t2].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h2.reduce(function(t2, e4) {
      return t2[e4.name] = e4.align, t2;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p2 = 0; p2 < m2.length; p2 += 1) {
        var B2 = u2[f2][m2[p2]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p2, data: B2 }, this), s2.call(this, new o2(e3, n3, w2[m2[p2]], O2, B2, f2 + 2, j2[m2[p2]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = function(t2, e3) {
    var r2 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
    return Object.keys(t2).map(function(n4) {
      var i4 = t2[n4];
      return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[n4] - r2 - r2);
    }, this).map(function(t3) {
      return this.getLineHeightFactor() * t3.length * n3 / i3 + r2 + r2;
    }, this).reduce(function(t3, e4) {
      return Math.max(t3, e4);
    }, 0);
  };
  e.setTableHeaderRow = function(t2) {
    i2.call(this), this.internal.__cell__.tableHeaderRow = t2;
  }, e.printHeaderRow = function(t2, e3) {
    if (i2.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var r2;
    if (n2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r2 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r2.y = this.internal.__cell__.margins.top || 0, c3.push(r2)), r2.lineNumber = t2;
      var h2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r2), this.setTextColor(h2);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft);
function jt(t2) {
  var e = t2.family.replace(/"|'/g, "").toLowerCase(), r = function(t3) {
    return Pt[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.style), n2 = function(t3) {
    if (!t3) return 400;
    if ("number" == typeof t3) return t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400;
    if (/^\d00$/.test(t3)) return parseInt(t3);
    switch (t3) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t2.weight), i2 = function(t3) {
    return "number" == typeof It[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.stretch);
  return { family: e, style: r, weight: n2, stretch: i2, src: t2.src || [], ref: t2.ref || { name: e, style: [i2, r, n2].join(" ") } };
}
function Ot(t2, e, r, n2) {
  var i2;
  for (i2 = r; i2 >= 0 && i2 < e.length; i2 += n2) if (t2[e[i2]]) return t2[e[i2]];
  for (i2 = r; i2 >= 0 && i2 < e.length; i2 -= n2) if (t2[e[i2]]) return t2[e[i2]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t2) {
  return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
}
function qt(t2, e, r) {
  for (var n2 = (r = r || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt, r.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e.length; ++s2) if (i2[(a2 = jt(e[s2])).family] && (a2.family = i2[a2.family]), t2.hasOwnProperty(a2.family)) {
    o2 = t2[a2.family];
    break;
  }
  if (!(o2 = o2 || t2[n2])) throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t3, e3) {
    if (e3[t3]) return e3[t3];
    var r2 = It[t3], n3 = r2 <= It.normal ? -1 : 1, i3 = Ot(e3, kt, r2, n3);
    if (!i3) throw new Error("Could not find a matching font-stretch value for " + t3);
    return i3;
  }(a2.stretch, o2), o2 = function(t3, e3) {
    if (e3[t3]) return e3[t3];
    for (var r2 = Pt[t3], n3 = 0; n3 < r2.length; ++n3) if (e3[r2[n3]]) return e3[r2[n3]];
    throw new Error("Could not find a matching font-style for " + t3);
  }(a2.style, o2), !(o2 = function(t3, e3) {
    if (e3[t3]) return e3[t3];
    if (400 === t3 && e3[500]) return e3[500];
    if (500 === t3 && e3[400]) return e3[400];
    var r2 = Ct[t3], n3 = Ot(e3, Ft, r2, t3 < 400 ? -1 : 1);
    if (!n3) throw new Error("Could not find a matching font-weight for value " + t3);
    return n3;
  }(a2.weight, o2))) throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
  return o2;
}
function Dt(t2) {
  return t2.trimLeft();
}
function Rt(t2, e) {
  for (var r = 0; r < t2.length; ) {
    if (t2.charAt(r) === e) return [t2.substring(0, r), t2.substring(r + 1)];
    r += 1;
  }
  return null;
}
function Tt(t2) {
  var e = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e ? null : [e[0], t2.substring(e[0].length)];
}
var Ut, zt, Ht, Wt = ["times"];
!function(e) {
  var r, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t2) {
    return t2 = t2 || {}, this.isStrokeTransparent = t2.isStrokeTransparent || false, this.strokeOpacity = t2.strokeOpacity || 1, this.strokeStyle = t2.strokeStyle || "#000000", this.fillStyle = t2.fillStyle || "#000000", this.isFillTransparent = t2.isFillTransparent || false, this.fillOpacity = t2.fillOpacity || 1, this.font = t2.font || "10px sans-serif", this.textBaseline = t2.textBaseline || "alphabetic", this.textAlign = t2.textAlign || "left", this.lineWidth = t2.lineWidth || 1, this.lineJoin = t2.lineJoin || "miter", this.lineCap = t2.lineCap || "butt", this.path = t2.path || [], this.transform = void 0 !== t2.transform ? t2.transform.clone() : new h2(), this.globalCompositeOperation = t2.globalCompositeOperation || "normal", this.globalAlpha = t2.globalAlpha || 1, this.clip_path = t2.clip_path || [], this.currentPoint = t2.currentPoint || new c2(), this.miterLimit = t2.miterLimit || 10, this.lastPoint = t2.lastPoint || new c2(), this.lineDashOffset = t2.lineDashOffset || 0, this.lineDash = t2.lineDash || [], this.margin = t2.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t2.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t2.ignoreClearRect || t2.ignoreClearRect, this;
  };
  e.events.push(["initialized", function() {
    this.context2d = new p2(this), r = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
  }]);
  var p2 = function(t2) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t2;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var r2 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r2;
    }, set: function(t3) {
      r2 = Boolean(t3);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t3) {
      n3 = Boolean(t3);
    } });
    var i3 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i3;
    }, set: function(t3) {
      isNaN(t3) || (i3 = t3);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = t3);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t3) {
      var e4;
      "number" == typeof t3 ? e4 = [t3, t3, t3, t3] : ((e4 = new Array(4))[0] = t3[0], e4[1] = t3.length >= 2 ? t3[1] : e4[0], e4[2] = t3.length >= 3 ? t3[2] : e4[0], e4[3] = t3.length >= 4 ? t3[3] : e4[1]), l2.margin = e4;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t3) {
      s3 = t3;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t3) {
      c3 = t3;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t3) {
      t3 instanceof d2 && (l2 = t3);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t3) {
      l2.path = t3;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t3) {
      u3 = t3;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t3) {
      var e4;
      e4 = g2(t3), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t3) {
      var e4 = g2(t3);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t3) {
      -1 !== ["butt", "round", "square"].indexOf(t3) && (this.ctx.lineCap = t3, this.pdf.setLineCap(t3));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.lineWidth = t3, this.pdf.setLineWidth(t3));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t3) {
      -1 !== ["bevel", "round", "miter"].indexOf(t3) && (this.ctx.lineJoin = t3, this.pdf.setLineJoin(t3));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.miterLimit = t3, this.pdf.setMiterLimit(t3));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t3) {
      this.ctx.textBaseline = t3;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t3) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t3) && (this.ctx.textAlign = t3);
    } });
    var h3 = null;
    function f2(t3, e4) {
      if (null === h3) {
        var r3 = function(t4) {
          var e6 = [];
          return Object.keys(t4).forEach(function(r4) {
            t4[r4].forEach(function(t5) {
              var n4 = null;
              switch (t5) {
                case "bold":
                  n4 = { family: r4, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r4, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r4, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r4 };
              }
              null !== n4 && (n4.ref = { name: r4, style: t5 }, e6.push(n4));
            });
          }), e6;
        }(t3.getFontList());
        h3 = function(t4) {
          for (var e6 = {}, r4 = 0; r4 < t4.length; ++r4) {
            var n4 = jt(t4[r4]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e6[i4] = e6[i4] || {}, e6[i4][a3] = e6[i4][a3] || {}, e6[i4][a3][o4] = e6[i4][a3][o4] || {}, e6[i4][a3][o4][s4] = n4;
          }
          return e6;
        }(r3.concat(e4));
      }
      return h3;
    }
    var p3 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p3;
    }, set: function(t3) {
      h3 = null, p3 = t3;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t3) {
      var e4;
      if (this.ctx.font = t3, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t3))) {
        var r3 = e4[1], n4 = (e4[2], e4[3]), i4 = e4[4], a3 = (e4[5], e4[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
        i4 = "px" === o4 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
        var s4 = function(t4) {
          var e6, r4, n5 = [], i5 = t4.trim();
          if ("" === i5) return Wt;
          if (i5 in Mt) return [Mt[i5]];
          for (; "" !== i5; ) {
            switch (r4 = null, e6 = (i5 = Dt(i5)).charAt(0)) {
              case '"':
              case "'":
                r4 = Rt(i5.substring(1), e6);
                break;
              default:
                r4 = Tt(i5);
            }
            if (null === r4) return Wt;
            if (n5.push(r4[0]), "" !== (i5 = Dt(r4[1])) && "," !== i5.charAt(0)) return Wt;
            i5 = i5.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t4) {
            return { family: t4, stretch: "normal", weight: n4, style: r3 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          ("bold" === n4 || parseInt(n4, 10) >= 700 || "bold" === r3) && (u4 = "bold"), "italic" === r3 && (u4 += "italic"), 0 === u4.length && (u4 = "normal");
          for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d4 = 0; d4 < s4.length; d4++) {
            if (void 0 !== this.pdf.internal.getFont(s4[d4], u4, { noFallback: true, disableWarning: true })) {
              h4 = s4[d4];
              break;
            }
            if ("bolditalic" === u4 && void 0 !== this.pdf.internal.getFont(s4[d4], "bold", { noFallback: true, disableWarning: true })) h4 = s4[d4], u4 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s4[d4], "normal", { noFallback: true, disableWarning: true })) {
              h4 = s4[d4], u4 = "normal";
              break;
            }
          }
          if ("" === h4) {
            for (var p4 = 0; p4 < s4.length; p4++) if (l3[s4[p4]]) {
              h4 = l3[s4[p4]];
              break;
            }
          }
          h4 = "" === h4 ? "Times" : h4, this.pdf.setFont(h4, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t3) {
      this.ctx.globalCompositeOperation = t3;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t3) {
      this.ctx.globalAlpha = t3;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t3) {
      this.ctx.lineDashOffset = t3, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t3) {
      this.ctx.lineDash = t3, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t3) {
      this.ctx.ignoreClearRect = Boolean(t3);
    } });
  };
  p2.prototype.setLineDash = function(t2) {
    this.lineDash = t2;
  }, p2.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p2.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p2.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p2.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p2.prototype.moveTo = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e3));
    this.path.push({ type: "mt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(t2, e3);
  }, p2.prototype.closePath = function() {
    var e3 = new c2(0, 0), r2 = 0;
    for (r2 = this.path.length - 1; -1 !== r2; r2--) if ("begin" === this.path[r2].type && "object" === _typeof(this.path[r2 + 1]) && "number" == typeof this.path[r2 + 1].x) {
      e3 = new c2(this.path[r2 + 1].x, this.path[r2 + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e3.x, e3.y);
  }, p2.prototype.lineTo = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e3));
    this.path.push({ type: "lt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(r2.x, r2.y);
  }, p2.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p2.prototype.quadraticCurveTo = function(t2, e3, r2, n3) {
    if (isNaN(r2) || isNaN(n3) || isNaN(t2) || isNaN(e3)) throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i3 = this.ctx.transform.applyToPoint(new c2(r2, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t2, e3));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
  }, p2.prototype.bezierCurveTo = function(t2, e3, r2, n3, i3, o3) {
    if (isNaN(i3) || isNaN(o3) || isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t2, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r2, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p2.prototype.arc = function(t2, e3, r2, n3, i3, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3) || isNaN(i3)) throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t2, e3));
      t2 = s3.x, e3 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r2)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r2 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
    }
    Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t2, y: e3, radius: r2, startAngle: n3, endAngle: i3, counterclockwise: o3 });
  }, p2.prototype.arcTo = function(t2, e3, r2, n3, i3) {
    throw new Error("arcTo not implemented.");
  }, p2.prototype.rect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t2, e3), this.lineTo(t2 + r2, e3), this.lineTo(t2 + r2, e3 + n3), this.lineTo(t2, e3 + n3), this.lineTo(t2, e3), this.lineTo(t2 + r2, e3), this.lineTo(t2, e3);
  }, p2.prototype.fillRect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i3 = {};
      "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t2, e3, r2, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
    }
  }, p2.prototype.strokeRect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t2, e3, r2, n3), this.stroke());
  }, p2.prototype.clearRect = function(t2, e3, r2, n3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3)) throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t2, e3, r2, n3));
  }, p2.prototype.save = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++) this.pdf.setPage(r2 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t2) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p2.prototype.restore = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++) this.pdf.setPage(r2 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t2 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p2.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t2) {
    var e3, r2, n3, i3;
    if (true === t2.isCanvasGradient && (t2 = t2.getColor()), !t2) return { r: 0, g: 0, b: 0, a: 0, style: t2 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t2)) e3 = 0, r2 = 0, n3 = 0, i3 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t2);
      if (null !== a2) e3 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
      else if (null !== (a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t2))) e3 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
      else {
        if (i3 = 1, "string" == typeof t2 && "#" !== t2.charAt(0)) {
          var o3 = new f(t2);
          t2 = o3.ok ? o3.toHex() : "#000000";
        }
        4 === t2.length ? (e3 = t2.substring(1, 2), e3 += e3, r2 = t2.substring(2, 3), r2 += r2, n3 = t2.substring(3, 4), n3 += n3) : (e3 = t2.substring(1, 3), r2 = t2.substring(3, 5), n3 = t2.substring(5, 7)), e3 = parseInt(e3, 16), r2 = parseInt(r2, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e3, g: r2, b: n3, a: i3, style: t2 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p2.prototype.fillText = function(t2, e3, r2, n3) {
    if (isNaN(e3) || isNaN(r2) || "string" != typeof t2) throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e3, y: r2, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.strokeText = function(t2, e3, r2, n3) {
    if (isNaN(e3) || isNaN(r2) || "string" != typeof t2) throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e3, y: r2, scale: o3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.measureText = function(t2) {
    if ("string" != typeof t2) throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, r2 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t2) * n3 / e3.internal.scaleFactor, o3 = function(t3) {
      var e4 = (t3 = t3 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    };
    return new o3({ width: i3 *= Math.round(96 * r2 / 72 * 1e4) / 1e4 });
  }, p2.prototype.scale = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r2 = new h2(t2, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.rotate = function(t2) {
    if (isNaN(t2)) throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new h2(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p2.prototype.translate = function(t2, e3) {
    if (isNaN(t2) || isNaN(e3)) throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r2 = new h2(1, 0, 0, 1, t2, e3);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.transform = function(t2, e3, r2, n3, i3, o3) {
    if (isNaN(t2) || isNaN(e3) || isNaN(r2) || isNaN(n3) || isNaN(i3) || isNaN(o3)) throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h2(t2, e3, r2, n3, i3, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p2.prototype.setTransform = function(t2, e3, r2, n3, i3, a2) {
    t2 = isNaN(t2) ? 1 : t2, e3 = isNaN(e3) ? 0 : e3, r2 = isNaN(r2) ? 0 : r2, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t2, e3, r2, n3, i3, a2);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p2.prototype.drawImage = function(t2, e3, r2, n3, i3, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t2), f2 = 1, d4 = 1, p3 = 1, g3 = 1;
    void 0 !== n3 && void 0 !== s3 && (p3 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d4 = l3.height / i3 * c3 / i3), void 0 === a2 && (a2 = e3, o3 = r2, e3 = 0, r2 = 0), void 0 !== n3 && void 0 === s3 && (s3 = n3, c3 = i3), void 0 === n3 && void 0 === s3 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p3, o3 - r2 * g3, n3 * f2, i3 * d4)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1) -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging) for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
      this.pdf.setPage(C3);
      var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B3 + (C3 - 2) * M3;
      if (0 !== this.ctx.clip_path.length) {
        var D3 = this.path;
        m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
      }
      var R3 = JSON.parse(JSON.stringify(S3));
      R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
      var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
      T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t2, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(t2, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t2, e3, r2) {
    var n3 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, r2 = r2 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i3 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t2.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t2.y + i3) / r2) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t2.y + i3 - t2.radius) / r2) + 1), n3.push(Math.floor((t2.y + i3 + t2.radius) / r2) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x, t2.y);
        n3.push(Math.floor((a2.y + i3) / r2) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r2) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x2, t2.y2, t2.x, t2.y);
        n3.push(Math.floor((o3.y + i3) / r2) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r2) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t2.y + i3) / r2) + 1), n3.push(Math.floor((t2.y + t2.h + i3) / r2) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1) for (; this.pdf.internal.getNumberOfPages() < n3[s3]; ) w2.call(this);
    return n3;
  }, w2 = function() {
    var t2 = this.fillStyle, e3 = this.strokeStyle, r2 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t2, this.strokeStyle = e3, this.font = r2, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
  }, N2 = function(t2, e3, r2) {
    for (var n3 = 0; n3 < t2.length; n3++) switch (t2[n3].type) {
      case "bct":
        t2[n3].x2 += e3, t2[n3].y2 += r2;
      case "qct":
        t2[n3].x1 += e3, t2[n3].y1 += r2;
      case "mt":
      case "lt":
      case "arc":
      default:
        t2[n3].x += e3, t2[n3].y += r2;
    }
    return t2;
  }, L2 = function(t2) {
    return t2.sort(function(t3, e3) {
      return t3 - e3;
    });
  }, A2 = function(t2, e3) {
    for (var r2, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d4 = 0; d4 < l3.length; d4++) if (void 0 !== l3[d4].x) for (var p3 = y2.call(this, l3[d4]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f2.indexOf(p3[g3]) && f2.push(p3[g3]);
    for (var m3 = 0; m3 < f2.length; m3++) for (; this.pdf.internal.getNumberOfPages() < f2[m3]; ) w2.call(this);
    if (L2(f2), this.autoPaging) for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
      this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
      var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
      if (0 !== this.ctx.clip_path.length) {
        var C3 = this.path;
        r2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r2, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t2, true), this.path = C3;
      }
      if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
        var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
        j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t2, e3), j3 && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = s3;
    }
    else this.lineWidth = c3, x2.call(this, t2, e3), this.lineWidth = s3;
    this.path = h3;
  }, x2 = function(t2, e3) {
    if (("stroke" !== t2 || e3 || !v2.call(this)) && ("stroke" === t2 || e3 || !m2.call(this))) {
      for (var r2, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i3.push({ begin: true });
            break;
          case "close":
            i3.push({ close: true });
            break;
          case "mt":
            i3.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i3.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r2 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--) if (true !== i3[c3 - 1].close && true !== i3[c3 - 1].begin) {
                i3[c3 - 1].deltas.push(r2), i3[c3 - 1].abs.push(s3);
                break;
              }
            }
            break;
          case "bct":
            r2 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r2);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d4 = s3.x, p3 = s3.y;
            r2 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d4 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r2);
            break;
          case "arc":
            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
        }
      }
      n3 = e3 ? null : "stroke" === t2 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i3.length; b3++) if (i3[b3].arc) for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
        var N3 = y3[w3];
        "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
      }
      else if (true === i3[b3].close) this.pdf.internal.out("h"), g3 = false;
      else if (true !== i3[b3].begin) {
        var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
        O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
      }
      n3 && k2.call(this, n3), e3 && I2.call(this);
    }
  }, S2 = function(t2) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r2 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t2 - r2;
      case "top":
        return t2 + e3 - r2;
      case "hanging":
        return t2 + e3 - 2 * r2;
      case "middle":
        return t2 + e3 / 2 - r2;
      case "ideographic":
        return t2;
      case "alphabetic":
      default:
        return t2;
    }
  }, _2 = function(t2) {
    return t2 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p2.prototype.createLinearGradient = function() {
    var t2 = function() {
    };
    return t2.colorStops = [], t2.addColorStop = function(t3, e3) {
      this.colorStops.push([t3, e3]);
    }, t2.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t2.isCanvasGradient = true, t2;
  }, p2.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p2.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t2, e3, r2, n3, i3, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r2, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {
      var l3 = u3[h3];
      0 === h3 && (c3 ? F2.call(this, l3.x1 + t2, l3.y1 + e3) : j2.call(this, l3.x1 + t2, l3.y1 + e3)), B2.call(this, t2, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, k2 = function(t2) {
    switch (t2) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t2, e3) {
    this.pdf.internal.out(n2(t2) + " " + i2(e3) + " m");
  }, C2 = function(t2) {
    var e3;
    switch (t2.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      case "left":
      case "start":
      default:
        e3 = "left";
    }
    var r2 = this.pdf.getTextDimensions(t2.text), n3 = S2.call(this, t2.y), i3 = _2.call(this, n3) - r2.h, a2 = this.ctx.transform.applyToPoint(new c2(t2.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d4, p3 = this.ctx.transform.applyToRectangle(new u2(t2.x, n3, r2.w, r2.h)), g3 = s3.applyToRectangle(new u2(t2.x, i3, r2.w, r2.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1) -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging) for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
      this.pdf.setPage(k3);
      var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
      if (0 !== this.ctx.clip_path.length) {
        var E3 = this.path;
        l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
      }
      var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
      t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d4 = this.lineWidth, this.lineWidth = d4 * t2.scale);
      var D3 = "text" !== this.autoPaging;
      if (D3 || q3.y + q3.h <= C3) {
        if (D3 || q3.y >= I3 && q3.x <= O3) {
          var R3 = D3 ? t2.text : this.pdf.splitTextToSize(t2.text, t2.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
          U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t2.angle, align: e3, renderingMode: t2.renderingMode }), U2 && this.pdf.restoreGraphicsState();
        }
      } else q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
      t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d4);
    }
    else t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d4 = this.lineWidth, this.lineWidth = d4 * t2.scale), this.pdf.text(t2.text, a2.x + this.posX, a2.y + this.posY, { angle: t2.angle, align: e3, renderingMode: t2.renderingMode, maxWidth: t2.maxWidth }), t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d4);
  }, j2 = function(t2, e3, r2, a2) {
    r2 = r2 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t2 + r2) + " " + i2(e3 + a2) + " l");
  }, O2 = function(t2, e3, r2) {
    return this.pdf.lines(t2, e3, r2, null, null);
  }, B2 = function(t2, e3, n3, i3, a2, c3, u3, h3) {
    this.pdf.internal.out([r(o2(n3 + t2)), r(s2(i3 + e3)), r(o2(a2 + t2)), r(s2(c3 + e3)), r(o2(u3 + t2)), r(s2(h3 + e3)), "c"].join(" "));
  }, M2 = function(t2, e3, r2, n3) {
    for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r2; ) e3 -= i3;
    var o3 = Math.abs(r2 - e3);
    o3 < i3 && n3 && (o3 = i3 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {
      var h3 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t2, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
    }
    return s3;
  }, E2 = function(t2, e3, r2) {
    var n3 = (r2 - e3) / 2, i3 = t2 * Math.cos(n3), a2 = t2 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d4 = l3, p3 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t2 * Math.cos(e3), y1: t2 * Math.sin(e3), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d4 * m3 - p3 * v3, y3: d4 * v3 + p3 * m3, x4: t2 * Math.cos(r2), y4: t2 * Math.sin(r2) };
  }, q2 = function(t2) {
    return 180 * t2 / Math.PI;
  }, D2 = function(t2, e3, r2, n3, i3, a2) {
    var o3 = t2 + 0.5 * (r2 - t2), s3 = e3 + 0.5 * (n3 - e3), c3 = i3 + 0.5 * (r2 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t2, i3, o3, c3), f2 = Math.max(t2, i3, o3, c3), d4 = Math.min(e3, a2, s3, h3), p3 = Math.max(e3, a2, s3, h3);
    return new u2(l3, d4, f2 - l3, p3 - d4);
  }, R2 = function(t2, e3, r2, n3, i3, a2, o3, s3) {
    var c3, h3, l3, f2, d4, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r2 - t2, x3 = n3 - e3, S3 = i3 - r2, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
    for (h3 = 0; h3 < 41; h3++) v3 = (g3 = (l3 = t2 + (c3 = h3 / 40) * A3) + c3 * ((d4 = r2 + c3 * S3) - l3)) + c3 * (d4 + c3 * (i3 + c3 * P3 - d4) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), 0 == h3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t2, e3, r2 = (t2 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t2, lineDashOffset: e3 }));
      this.prevLineDash !== r2 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r2);
    }
  };
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var r = function(t3) {
    var e, r2, n3, i3, a3, o2, s2, c2, u2, h2;
    for (r2 = [], n3 = 0, i3 = (t3 += e = "\0\0\0\0".slice(t3.length % 4 || 4)).length; i3 > n3; n3 += 4) 0 !== (a3 = (t3.charCodeAt(n3) << 24) + (t3.charCodeAt(n3 + 1) << 16) + (t3.charCodeAt(n3 + 2) << 8) + t3.charCodeAt(n3 + 3)) ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r2.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r2.push(122);
    return function(t4, e3) {
      for (var r3 = e3; r3 > 0; r3--) t4.pop();
    }(r2, e.length), String.fromCharCode.apply(String, r2) + "~>";
  }, n2 = function(t3) {
    var e, r2, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
    for (t3[h2](-2), t3 = t3[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t3 += e = "uuuuu"[h2](t3[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5) r2 = 52200625 * (t3[u2](i3) - 33) + 614125 * (t3[u2](i3 + 1) - 33) + 7225 * (t3[u2](i3 + 2) - 33) + 85 * (t3[u2](i3 + 3) - 33) + (t3[u2](i3 + 4) - 33), n3.push(c2 & r2 >> 24, c2 & r2 >> 16, c2 & r2 >> 8, c2 & r2);
    return function(t4, e3) {
      for (var r3 = e3; r3 > 0; r3--) t4.pop();
    }(n3, e[s2]), o2.fromCharCode.apply(o2, n3);
  }, i2 = function(t3) {
    var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t3 = t3.replace(/\s/g, "")).indexOf(">") && (t3 = t3.substr(0, t3.indexOf(">"))), t3.length % 2 && (t3 += "0"), false === e.test(t3)) return "";
    for (var r2 = "", n3 = 0; n3 < t3.length; n3 += 2) r2 += String.fromCharCode("0x" + (t3[n3] + t3[n3 + 1]));
    return r2;
  }, a2 = function(t3) {
    for (var r2 = new Uint8Array(t3.length), n3 = t3.length; n3--; ) r2[n3] = t3.charCodeAt(n3);
    return t3 = (r2 = zlibSync(r2)).reduce(function(t4, e) {
      return t4 + String.fromCharCode(e);
    }, "");
  };
  t2.processDataByFilters = function(t3, e) {
    var o2 = 0, s2 = t3 || "", c2 = [];
    for ("string" == typeof (e = e || []) && (e = [e]), o2 = 0; o2 < e.length; o2 += 1) switch (e[o2]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        s2 = n2(s2), c2.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        s2 = r(s2), c2.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        s2 = i2(s2), c2.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        s2 = s2.split("").map(function(t4) {
          return ("0" + t4.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", c2.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        s2 = a2(s2), c2.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + e[o2] + '" is not implemented');
    }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.loadFile = function(t3, e, r) {
    return function(t4, e3, r2) {
      e3 = false !== e3, r2 = "function" == typeof r2 ? r2 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t5, e4, r3) {
          var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t6) {
            var e6 = t6.length, r4 = [], n4 = String.fromCharCode;
            for (i2 = 0; i2 < e6; i2 += 1) r4.push(n4(255 & t6.charCodeAt(i2)));
            return r4.join("");
          };
          if (n3.open("GET", t5, !e4), n3.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (n3.onload = function() {
            200 === n3.status ? r3(a2(this.responseText)) : r3(void 0);
          }), n3.send(null), e4 && 200 === n3.status) return a2(n3.responseText);
        }(t4, e3, r2);
      } catch (t5) {
      }
      return n2;
    }(t3, e, r);
  }, t2.loadImageFile = t2.loadFile;
}(E.API), function(e) {
  function r() {
    return (n.html2canvas ? Promise.resolve(n.html2canvas) : import("./html2canvas.esm-Dtsxr8dG.js")).catch(function(t2) {
      return Promise.reject(new Error("Could not load html2canvas: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  function i2() {
    return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : import("./purify.es-CrcqugU7.js")).catch(function(t2) {
      return Promise.reject(new Error("Could not load dompurify: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  var a2 = function(e3) {
    var r2 = _typeof(e3);
    return "undefined" === r2 ? "undefined" : "string" === r2 || e3 instanceof String ? "string" : "number" === r2 || e3 instanceof Number ? "number" : "function" === r2 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === r2 ? "object" : "unknown";
  }, o2 = function(t2, e3) {
    var r2 = document.createElement(t2);
    for (var n2 in e3.className && (r2.className = e3.className), e3.innerHTML && e3.dompurify && (r2.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style) r2.style[n2] = e3.style[n2];
    return r2;
  }, s2 = function t2(e3) {
    var r2 = Object.assign(t2.convert(Promise.resolve()), JSON.parse(JSON.stringify(t2.template))), n2 = t2.convert(Promise.resolve(), r2);
    return n2 = (n2 = n2.setProgress(1, t2, 1, [t2])).set(e3);
  };
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t2, e3) {
    return t2.__proto__ = e3 || s2.prototype, t2;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t2, e3) {
    return this.then(function() {
      switch (e3 = e3 || function(t3) {
        switch (a2(t3)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t3.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t2)) {
        case "string":
          return this.then(i2).then(function(e4) {
            return this.set({ src: o2("div", { innerHTML: t2, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t2 });
        case "canvas":
          return this.set({ canvas: t2 });
        case "img":
          return this.set({ img: t2 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t2) {
    switch (t2) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t2 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t3(e4, r2) {
        for (var n2 = 3 === e4.nodeType ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i3 = e4.firstChild; i3; i3 = i3.nextSibling) true !== r2 && 1 === i3.nodeType && "SCRIPT" === i3.nodeName || n2.appendChild(t3(i3, r2));
        return 1 === e4.nodeType && ("CANVAS" === e4.nodeName ? (n2.width = e4.width, n2.height = e4.height, n2.getContext("2d").drawImage(e4, 0, 0)) : "TEXTAREA" !== e4.nodeName && "SELECT" !== e4.nodeName || (n2.value = e4.value), n2.addEventListener("load", function() {
          n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;
        }, true)), n2;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e3.tagName && (t2.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t2 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t3(this.prop.container, e3);
    }).then(function(t3) {
      (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e3 = this.opt.jsPDF, r2 = this.opt.fontFaces, n2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i3.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r2, r2) for (var a3 = 0; a3 < r2.length; ++a3) {
        var o3 = r2[a3], s3 = o3.src.find(function(t4) {
          return "truetype" === t4.format;
        });
        s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
      }
      return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = 0 == i3.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e3.context2d.save(true), t3(this.prop.container, i3);
    }).then(function(t3) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t2 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t2;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t2, e3, r2) {
    return "img" === (r2 = r2 || "pdf").toLowerCase() || "image" === r2.toLowerCase() ? this.outputImg(t2, e3) : this.outputPdf(t2, e3);
  }, s2.prototype.outputPdf = function(t2, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t2, e3);
    });
  }, s2.prototype.outputImg = function(t2) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t2) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t2 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t2) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t2 ? { filename: t2 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t2) {
    if ("object" !== a2(t2)) return this;
    var e3 = Object.keys(t2 || {}).map(function(e4) {
      if (e4 in s2.template.prop) return function() {
        this.prop[e4] = t2[e4];
      };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t2.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t2.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t2.pageSize);
        default:
          return function() {
            this.opt[e4] = t2[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, s2.prototype.get = function(t2, e3) {
    return this.then(function() {
      var r2 = t2 in s2.template.prop ? this.prop[t2] : this.opt[t2];
      return e3 ? e3(r2) : r2;
    });
  }, s2.prototype.setMargin = function(t2) {
    return this.then(function() {
      switch (a2(t2)) {
        case "number":
          t2 = [t2, t2, t2, t2];
        case "array":
          if (2 === t2.length && (t2 = [t2[0], t2[1], t2[0], t2[1]]), 4 === t2.length) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t2;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t2) {
    function e3(t3, e4) {
      return Math.floor(t3 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t2 = t2 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t2.inner = { width: t2.width - this.opt.margin[1] - this.opt.margin[3], height: t2.height - this.opt.margin[0] - this.opt.margin[2] }, t2.inner.px = { width: e3(t2.inner.width, t2.k), height: e3(t2.inner.height, t2.k) }, t2.inner.ratio = t2.inner.height / t2.inner.width), this.prop.pageSize = t2;
    });
  }, s2.prototype.setProgress = function(t2, e3, r2, n2) {
    return null != t2 && (this.progress.val = t2), null != e3 && (this.progress.state = e3), null != r2 && (this.progress.n = r2), null != n2 && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t2, e3, r2, n2) {
    return this.setProgress(t2 ? this.progress.val + t2 : null, e3 || null, r2 ? this.progress.n + r2 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t2, e3) {
    var r2 = this;
    return this.thenCore(t2, e3, function(t3, e4) {
      return r2.updateProgress(null, null, 1, [t3]), Promise.prototype.then.call(this, function(e6) {
        return r2.updateProgress(null, t3), e6;
      }).then(t3, e4).then(function(t4) {
        return r2.updateProgress(1), t4;
      });
    });
  }, s2.prototype.thenCore = function(t2, e3, r2) {
    r2 = r2 || Promise.prototype.then;
    t2 && (t2 = t2.bind(this)), e3 && (e3 = e3.bind(this));
    var n2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r2.call(n2, t2, e3);
    return s2.convert(i3, this.__proto__);
  }, s2.prototype.thenExternal = function(t2, e3) {
    return Promise.prototype.then.call(this, t2, e3);
  }, s2.prototype.thenList = function(t2) {
    var e3 = this;
    return t2.forEach(function(t3) {
      e3 = e3.thenCore(t3);
    }), e3;
  }, s2.prototype.catch = function(t2) {
    t2 && (t2 = t2.bind(this));
    var e3 = Promise.prototype.catch.call(this, t2);
    return s2.convert(e3, this);
  }, s2.prototype.catchExternal = function(t2) {
    return Promise.prototype.catch.call(this, t2);
  }, s2.prototype.error = function(t2) {
    return this.then(function() {
      throw new Error(t2);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E.getPageSize = function(e3, r2, n2) {
    if ("object" === _typeof(e3)) {
      var i3 = e3;
      e3 = i3.orientation, r2 = i3.unit || r2, n2 = i3.format || n2;
    }
    r2 = r2 || "mm", n2 = n2 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r2) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r2;
    }
    var c2, u2 = 0, h2 = 0;
    if (s3.hasOwnProperty(o3)) u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
    else try {
      u2 = n2[1], h2 = n2[0];
    } catch (t2) {
      throw new Error("Invalid format: " + n2);
    }
    if ("p" === e3 || "portrait" === e3) e3 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
    else {
      if ("l" !== e3 && "landscape" !== e3) throw "Invalid orientation: " + e3;
      e3 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
    }
    return { width: h2, height: u2, unit: r2, k: a3, orientation: e3 };
  }, e.html = function(t2, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
    var r2 = new s2(e3);
    return e3.worker ? r2 : r2.from(t2).doCallback();
  };
}(E.API), E.API.addJS = function(t2) {
  return Ht = t2, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e;
  t2.events.push(["postPutResources", function() {
    var t3 = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var n2 = t3.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
      var a2 = n2[i2], o2 = r.exec(a2);
      if (null != o2) {
        var s2 = o2[1];
        t3.internal.newObjectDeferredBegin(s2, false);
      }
      t3.internal.write(a2);
    }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i2 = 0; i2 < c2; i2++) {
        var h2 = t3.internal.newObject();
        u2.push(h2);
        var l2 = t3.internal.getPageInfo(i2 + 1);
        t3.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t3.internal.newObject();
      t3.internal.write("<< /Names [ ");
      for (i2 = 0; i2 < u2.length; i2++) t3.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
      t3.internal.write(" ] >>", "endobj"), e = t3.internal.newObject(), t3.internal.write("<< /Dests " + f2 + " 0 R"), t3.internal.write(">>", "endobj");
    }
  }]), t2.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), t2.events.push(["initialized", function() {
    var t3 = this;
    t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e3, r) {
      var n2 = { title: e3, options: r, children: [] };
      return null == t4 && (t4 = this.root), t4.children.push(n2), n2;
    }, t3.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t3.outline.genIds_r = function(e3) {
      e3.id = t3.internal.newObjectDeferred();
      for (var r = 0; r < e3.children.length; r++) this.genIds_r(e3.children[r]);
    }, t3.outline.renderRoot = function(t4) {
      this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
    }, t3.outline.renderItems = function(e3) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {
        var i2 = e3.children[n2];
        this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), n2 > 0 && this.line("/Prev " + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i2);
        if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
          var o2 = t3.internal.getPageInfo(i2.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e3.children.length; s2++) this.renderItems(e3.children[s2]);
    }, t3.outline.line = function(t4) {
      this.ctx.val += t4 + "\r\n";
    }, t3.outline.makeRef = function(t4) {
      return t4.id + " 0 R";
    }, t3.outline.makeString = function(e3) {
      return "(" + t3.internal.pdfEscape(e3) + ")";
    }, t3.outline.objStart = function(t4) {
      this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
    }, t3.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t3.outline.count_r = function(t4, e3) {
      for (var r = 0; r < e3.children.length; r++) t4.count++, this.count_r(t4, e3.children[r]);
      return t4.count;
    };
  }]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  t2.processJPEG = function(t3, r, n2, i2, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
      switch (t3 = a2 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, (s2 = function(t4) {
        for (var r2, n3 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i3 = t4.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
          if (o3 += n3, -1 !== e.indexOf(t4.charCodeAt(o3 + 1))) {
            r2 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a3 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: r2, numcomponents: t4.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
        }
        return a3;
      }(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r, alias: n2 };
    }
    return u2;
  };
}(E.API);
var Vt, Gt, Yt, Jt, Xt, Kt = function() {
  var t2, e, i2;
  function a2(t3) {
    var e3, r, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p2;
    for (this.data = t3, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e3 = this.readUInt32(), u2 = (function() {
        var t4, e4;
        for (e4 = [], t4 = 0; t4 < 4; ++t4) e4.push(String.fromCharCode(this.data[this.pos++]));
        return e4;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e3);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u2 && (this.pos += 4, e3 -= 4), t3 = (null != o3 ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2) t3.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2) throw new Error("More transparent colors than palette size");
              if ((h2 = n2 - this.transparency.indexed.length) > 0) for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e3)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e3);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (p2 = this.colorType) || 6 === p2, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e3;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a2.prototype.read = function(t3) {
    var e3, r;
    for (r = [], e3 = 0; 0 <= t3 ? e3 < t3 : e3 > t3; 0 <= t3 ? ++e3 : --e3) r.push(this.data[this.pos++]);
    return r;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t3) {
    var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i3 = 0, a3 = this;
    if (null == t3 && (t3 = this.imgData), 0 === t3.length) return new Uint8Array(0);
    function o3(r, o4, s2, c2) {
      var u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t3.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p2; ) {
        switch (t3[i3++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1) w2[h2++] = t3[i3++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1) u2 = t3[i3++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1) u2 = t3[i3++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1) u2 = t3[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1) u2 = t3[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], 0 === N2 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t3[i3 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r) * e3, B2 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e3; M2 += 1) n2[O2++] = w2[B2++];
            O2 += (s2 - 1) * e3;
          }
        }
        N2++;
      }
    }
    return t3 = unzlibSync(t3), 1 == a3.interlaceMethod ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t3, e3, r, n2, i3, a3, o3, s2, c2;
    for (r = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r.length), n2 = 0, t3 = 0, e3 = o3 = 0, s2 = r.length; o3 < s2; e3 = o3 += 3) i3[n2++] = r[e3], i3[n2++] = r[e3 + 1], i3[n2++] = r[e3 + 2], i3[n2++] = null != (c2 = a3[t3++]) ? c2 : 255;
    return i3;
  }, a2.prototype.copyToImageData = function(t3, e3) {
    var r, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;
    if (n2 = this.colors, h2 = null, r = this.hasAlphaChannel, this.palette.length && (h2 = null != (f2 = this._decodedPalette) ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r = true), u2 = (i3 = t3.data || t3).length, o3 = h2 || e3, a3 = s2 = 0, 1 === n2) for (; a3 < u2; ) c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r ? o3[c2++] : 255, s2 = c2;
    else for (; a3 < u2; ) c2 = h2 ? 4 * e3[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t3;
    return t3 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t3, this.decodePixels()), t3;
  };
  var o2 = function() {
    if ("[object Window]" === Object.prototype.toString.call(n)) {
      try {
        e = n.document.createElement("canvas"), i2 = e.getContext("2d");
      } catch (t3) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o2(), t2 = function(t3) {
    var r;
    if (true === o2()) return i2.width = t3.width, i2.height = t3.height, i2.clearRect(0, 0, t3.width, t3.height), i2.putImageData(t3, 0, 0), (r = new Image()).src = e.toDataURL(), r;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a2.prototype.decodeFrames = function(e3) {
    var r, n2, i3, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3) r = c2[n2], i3 = e3.createImageData(r.width, r.height), a3 = this.decodePixels(new Uint8Array(r.data)), this.copyToImageData(i3, a3), r.imageData = i3, u2.push(r.image = t2(i3));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t3, e3) {
    var r, n2, i3;
    return r = (n2 = this.animation.frames)[e3], i3 = n2[e3 - 1], 0 === e3 && t3.clearRect(0, 0, this.width, this.height), 1 === (null != i3 ? i3.disposeOp : void 0) ? t3.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : 2 === (null != i3 ? i3.disposeOp : void 0) && t3.putImageData(i3.imageData, i3.xOffset, i3.yOffset), 0 === r.blendOp && t3.clearRect(r.xOffset, r.yOffset, r.width, r.height), t3.drawImage(r.image, r.xOffset, r.yOffset);
  }, a2.prototype.animate = function(t3) {
    var e3, r, n2, i3, a3, o3, s2 = this;
    return r = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {
      var o4, c2;
      if (o4 = r++ % i3, c2 = n2[o4], s2.renderFrame(t3, o4), i3 > 1 && r / i3 < a3) return s2.animation._timeout = setTimeout(e3, c2.delay);
    })();
  }, a2.prototype.stopAnimation = function() {
    var t3;
    return clearTimeout(null != (t3 = this.animation) ? t3._timeout : void 0);
  }, a2.prototype.render = function(t3) {
    var e3, r;
    return t3._png && t3._png.stopAnimation(), t3._png = this, t3.width = this.width, t3.height = this.height, e3 = t3.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r = e3.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e3.putImageData(r, 0, 0));
  }, a2;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Zt(t2) {
  var e = 0;
  if (71 !== t2[e++] || 73 !== t2[e++] || 70 !== t2[e++] || 56 !== t2[e++] || 56 != (t2[e++] + 1 & 253) || 97 !== t2[e++]) throw new Error("Invalid GIF 87a/89a header.");
  var r = t2[e++] | t2[e++] << 8, n2 = t2[e++] | t2[e++] << 8, i2 = t2[e++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
  t2[e++];
  t2[e++];
  var s2 = null, c2 = null;
  a2 && (s2 = e, c2 = o2, e += 3 * o2);
  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
  for (this.width = r, this.height = n2; u2 && e < t2.length; ) switch (t2[e++]) {
    case 33:
      switch (t2[e++]) {
        case 255:
          if (11 !== t2[e] || 78 == t2[e + 1] && 69 == t2[e + 2] && 84 == t2[e + 3] && 83 == t2[e + 4] && 67 == t2[e + 5] && 65 == t2[e + 6] && 80 == t2[e + 7] && 69 == t2[e + 8] && 50 == t2[e + 9] && 46 == t2[e + 10] && 48 == t2[e + 11] && 3 == t2[e + 12] && 1 == t2[e + 13] && 0 == t2[e + 16]) e += 14, p2 = t2[e++] | t2[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((P2 = t2[e++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e += P2;
          }
          break;
        case 249:
          if (4 !== t2[e++] || 0 !== t2[e + 4]) throw new Error("Invalid graphics extension block.");
          var g2 = t2[e++];
          l2 = t2[e++] | t2[e++] << 8, f2 = t2[e++], 0 == (1 & g2) && (f2 = null), d2 = g2 >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((P2 = t2[e++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e += P2;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + t2[e - 1].toString(16));
      }
      break;
    case 44:
      var m2 = t2[e++] | t2[e++] << 8, v2 = t2[e++] | t2[e++] << 8, b2 = t2[e++] | t2[e++] << 8, y2 = t2[e++] | t2[e++] << 8, w2 = t2[e++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
      if (w2 >> 7) {
        S2 = true;
        A2 = e, x2 = L2, e += 3 * L2;
      }
      var _2 = e;
      for (e++; ; ) {
        var P2;
        if (!((P2 = t2[e++]) >= 0)) throw Error("Invalid block size");
        if (0 === P2) break;
        e += P2;
      }
      h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
      break;
    case 59:
      u2 = false;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + t2[e - 1].toString(16));
  }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t3) {
    if (t3 < 0 || t3 >= h2.length) throw new Error("Frame index out of range.");
    return h2[t3];
  }, this.decodeAndBlitFrameBGRA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t2, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i3.width, h3 = r - u3, l3 = u3, f3 = 4 * (i3.y * r + i3.x), d4 = 4 * ((i3.y + i3.height) * r + i3.x), p3 = f3, g3 = 4 * h3;
    true === i3.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d4 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t2, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i3.width, h3 = r - u3, l3 = u3, f3 = 4 * (i3.y * r + i3.x), d4 = 4 * ((i3.y + i3.height) * r + i3.x), p3 = f3, g3 = 4 * h3;
    true === i3.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d4 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3) p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
      }
      --l3;
    }
  };
}
function $t(t2, e, r, n2) {
  for (var i2 = t2[e++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t2[e++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && 0 !== p2; ) f2 |= t2[e++] << l2, l2 += 8, 1 === p2 ? p2 = t2[e++] : --p2;
    if (l2 < u2) break;
    var v2 = f2 & h2;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2) break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; ) w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2) return void a.log("Warning, gif stream longer than expected.");
      r[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r[d2++] = N2), w2 = b2; y2--; ) w2 = g2[w2], r[--L2] = 255 & w2, w2 >>= 8;
      null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
    } else c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a.log("Warning, gif stream shorter than expected."), r;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Qt(t2) {
  var e, r, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t3, e3) {
    for (var r2 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t3[a3]; o3++) i3[e3[n3]] = [], i3[e3[n3]][0] = r2, i3[e3[n3]][1] = a3, n3++, r2++;
      r2 *= 2;
    }
    return i3;
  }
  function O2(t3) {
    for (var e3 = t3[0], r2 = t3[1] - 1; r2 >= 0; ) e3 & 1 << r2 && (m2 |= 1 << v2), r2--, --v2 < 0 && (255 == m2 ? (B2(255), B2(0)) : B2(m2), v2 = 7, m2 = 0);
  }
  function B2(t3) {
    g2.push(t3);
  }
  function M2(t3) {
    B2(t3 >> 8 & 255), B2(255 & t3);
  }
  function E2(t3, e3, r2, n3, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t4, e4) {
      var r3, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
      for (h4 = 0; h4 < 8; ++h4) {
        r3 = t4[f3], n4 = t4[f3 + 1], i4 = t4[f3 + 2], a4 = t4[f3 + 3], o4 = t4[f3 + 4], s4 = t4[f3 + 5], c4 = t4[f3 + 6];
        var p3 = r3 + (u4 = t4[f3 + 7]), g4 = r3 - u4, m4 = n4 + c4, v5 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t4[f3] = L3 + x3, t4[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t4[f3 + 2] = A3 + _3, t4[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v5 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v5), C3 = g4 + F3, j3 = g4 - F3;
        t4[f3 + 5] = j3 + k3, t4[f3 + 3] = j3 - k3, t4[f3 + 1] = C3 + I3, t4[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
        r3 = t4[f3], n4 = t4[f3 + 8], i4 = t4[f3 + 16], a4 = t4[f3 + 24], o4 = t4[f3 + 32], s4 = t4[f3 + 40], c4 = t4[f3 + 48];
        var O3 = r3 + (u4 = t4[f3 + 56]), B3 = r3 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, U2 = O3 + R2, z2 = O3 - R2, H2 = M3 + q3, W2 = M3 - q3;
        t4[f3] = U2 + H2, t4[f3 + 32] = U2 - H2;
        var V2 = 0.707106781 * (W2 + z2);
        t4[f3 + 16] = z2 + V2, t4[f3 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T2 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
        t4[f3 + 40] = Z2 + Y2, t4[f3 + 24] = Z2 - Y2, t4[f3 + 8] = K2 + J2, t4[f3 + 56] = K2 - J2, f3++;
      }
      for (h4 = 0; h4 < 64; ++h4) l3 = t4[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t3, e3), u3 = 0; u3 < 64; ++u3) p2[A2[u3]] = c3[u3];
    var h3 = p2[0] - r2;
    r2 = p2[0], 0 == h3 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
    if (0 == g3) return O2(o3), r2;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; 0 == p2[v3] && v3 <= g3; ) ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3) O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return 63 != g3 && O2(o3), r2;
  }
  function q2(t3) {
    (t3 = Math.min(Math.max(t3, 1), 100), a2 != t3) && (!function(t4) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r2 = 0; r2 < 64; r2++) {
        var n3 = o2((e3[r2] * t4 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r2]] = n3;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i3[a3] * t4 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d4 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) u2[d4] = 1 / (s2[A2[d4]] * f3[p3] * f3[g3] * 8), h2[d4] = 1 / (c2[A2[d4]] * f3[p3] * f3[g3] * 8), d4++;
    }(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a2 = t3);
  }
  this.encode = function(t3, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
      M2(65499), M2(132), B2(0);
      for (var t4 = 0; t4 < 64; t4++) B2(s2[t4]);
      B2(1);
      for (var e3 = 0; e3 < 64; e3++) B2(c2[e3]);
    }(), function(t4, e3) {
      M2(65472), M2(17), B2(8), M2(e3), M2(t4), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
    }(t3.width, t3.height), function() {
      M2(65476), M2(418), B2(0);
      for (var t4 = 0; t4 < 16; t4++) B2(x2[t4 + 1]);
      for (var e3 = 0; e3 <= 11; e3++) B2(S2[e3]);
      B2(16);
      for (var r2 = 0; r2 < 16; r2++) B2(_2[r2 + 1]);
      for (var n3 = 0; n3 <= 161; n3++) B2(P2[n3]);
      B2(1);
      for (var i3 = 0; i3 < 16; i3++) B2(k2[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++) B2(I2[a4]);
      B2(17);
      for (var o4 = 0; o4 < 16; o4++) B2(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++) B2(C2[s3]);
    }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d4, p3, N3, A3, j3, D2, R2, T2, U2, z2 = t3.data, H2 = t3.width, W2 = t3.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
      for (d4 = 0; d4 < V2; ) {
        for (j3 = V2 * G2 + d4, R2 = -1, T2 = 0, U2 = 0; U2 < 64; U2++) D2 = j3 + (T2 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d4 + R2 >= V2 && (D2 -= d4 + R2 - V2 + 4), p3 = z2[D2++], N3 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[U2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e, n2), l3 = E2(y2, h2, l3, r, i2), f3 = E2(w2, h2, f3, r, i2), d4 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t2 = t2 || 50, function() {
    for (var t3 = String.fromCharCode, e3 = 0; e3 < 256; e3++) N2[e3] = t3(e3);
  }(), e = j2(x2, S2), r = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {
    for (var t3 = 1, e3 = 2, r2 = 1; r2 <= 15; r2++) {
      for (var n3 = t3; n3 < e3; n3++) f2[32767 + n3] = r2, l2[32767 + n3] = [], l2[32767 + n3][1] = r2, l2[32767 + n3][0] = n3;
      for (var i3 = -(e3 - 1); i3 <= -t3; i3++) f2[32767 + i3] = r2, l2[32767 + i3] = [], l2[32767 + i3][1] = r2, l2[32767 + i3][0] = e3 - 1 + i3;
      t3 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t3 = 0; t3 < 256; t3++) L2[t3] = 19595 * t3, L2[t3 + 256 >> 0] = 38470 * t3, L2[t3 + 512 >> 0] = 7471 * t3 + 32768, L2[t3 + 768 >> 0] = -11059 * t3, L2[t3 + 1024 >> 0] = -21709 * t3, L2[t3 + 1280 >> 0] = 32768 * t3 + 8421375, L2[t3 + 1536 >> 0] = -27439 * t3, L2[t3 + 1792 >> 0] = -5329 * t3;
  }(), q2(t2);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function te(t2, e) {
  if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t2) {
  function e(t3) {
    if (!t3) throw Error("assert :P");
  }
  function r(t3, e3, r2) {
    for (var n3 = 0; 4 > n3; n3++) if (t3[e3 + n3] != r2.charCodeAt(n3)) return true;
    return false;
  }
  function n2(t3, e3, r2, n3, i3) {
    for (var a3 = 0; a3 < i3; a3++) t3[e3 + a3] = r2[n3 + a3];
  }
  function i2(t3, e3, r2, n3) {
    for (var i3 = 0; i3 < n3; i3++) t3[e3 + i3] = r2;
  }
  function a2(t3) {
    return new Int32Array(t3);
  }
  function o2(t3, e3) {
    for (var r2 = [], n3 = 0; n3 < t3; n3++) r2.push(new e3());
    return r2;
  }
  function s2(t3, e3) {
    var r2 = [];
    return function t4(r3, n3, i3) {
      for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r3.push(i3.length > n3 + 1 ? [] : new e3()), !(i3.length < n3 + 1)); o3++) t4(r3[o3], n3 + 1, i3);
    }(r2, 0, t3), r2;
  }
  var c2 = function() {
    var t3 = this;
    function c3(t4, e3) {
      for (var r2 = 1 << e3 - 1 >>> 0; t4 & r2; ) r2 >>>= 1;
      return r2 ? (t4 & r2 - 1) + r2 : t4;
    }
    function u3(t4, r2, n3, i3, a3) {
      e(!(i3 % n3));
      do {
        t4[r2 + (i3 -= n3)] = a3;
      } while (0 < i3);
    }
    function h3(t4, r2, n3, i3, o3) {
      if (e(2328 >= o3), 512 >= o3) var s3 = a2(512);
      else if (null == (s3 = a2(o3))) return 0;
      return function(t5, r3, n4, i4, o4, s4) {
        var h4, f4, d5 = r3, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e(0 != o4), e(null != i4), e(null != t5), e(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4]) return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4) return 0;
        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
          if (g4[h4] > 1 << h4) return 0;
          m4[h4 + 1] = m4[h4] + g4[h4];
        }
        for (f4 = 0; f4 < o4; ++f4) h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);
        if (1 == m4[15]) return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t5, d5, 1, p4, i4), p4;
        var v5, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4])) return 0;
          for (; 0 < g4[h4]; --g4[h4]) (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t5, d5 + w4, o4, A4, i4), w4 = c3(w4, h4);
        }
        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4])) return 0;
          for (; 0 < g4[h4]; --g4[h4]) {
            if (i4 = new l3(), (w4 & y4) != b4) {
              for (d5 += A4, v5 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v5 -= g4[b4])); ) ++b4, v5 <<= 1;
              p4 += A4 = 1 << (v5 = b4 - n4), t5[r3 + (b4 = w4 & y4)].g = v5 + n4, t5[r3 + b4].value = d5 - r3 - b4;
            }
            i4.g = h4 - n4, i4.value = s4[f4++], u3(t5, d5 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p4;
      }(t4, r2, n3, i3, o3, s3);
    }
    function l3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d4() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    function p3(t4, r2, n3, i3) {
      e(null != t4), e(null != r2), e(2147483648 > i3), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = r2, t4.pa = n3, t4.Jd = r2, t4.Yc = n3 + i3, t4.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t4);
    }
    function g3(t4, e3) {
      for (var r2 = 0; 0 < e3--; ) r2 |= k2(t4, 128) << e3;
      return r2;
    }
    function m3(t4, e3) {
      var r2 = g3(t4, e3);
      return P2(t4) ? -r2 : r2;
    }
    function v3(t4, r2, n3, i3) {
      var a3, o3 = 0;
      for (e(null != t4), e(null != r2), e(4294967288 > i3), t4.Sb = i3, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3) o3 += r2[n3 + a3] << 8 * a3;
      t4.Ra = o3, t4.bb = i3, t4.oa = r2, t4.pa = n3;
    }
    function b3(t4) {
      for (; 8 <= t4.u && t4.bb < t4.Sb; ) t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << Ur - 8 >>> 0, ++t4.bb, t4.u -= 8;
      A3(t4) && (t4.h = 1, t4.u = 0);
    }
    function y3(t4, r2) {
      if (e(0 <= r2), !t4.h && r2 <= Tr) {
        var n3 = L3(t4) & Rr[r2];
        return t4.u += r2, b3(t4), n3;
      }
      return t4.h = 1, t4.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t4) {
      return t4.Ra >>> (t4.u & Ur - 1) >>> 0;
    }
    function A3(t4) {
      return e(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > Ur;
    }
    function x2(t4, e3) {
      t4.u = e3, t4.h = A3(t4);
    }
    function S2(t4) {
      t4.u >= zr && (e(t4.u >= zr), b3(t4));
    }
    function _2(t4) {
      e(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
    }
    function P2(t4) {
      return g3(t4, 1);
    }
    function k2(t4, e3) {
      var r2 = t4.Ca;
      0 > t4.b && _2(t4);
      var n3 = t4.b, i3 = r2 * e3 >>> 8, a3 = (t4.I >>> n3 > i3) + 0;
      for (a3 ? (r2 -= i3, t4.I -= i3 + 1 << n3 >>> 0) : r2 = i3 + 1, n3 = r2, i3 = 0; 256 <= n3; ) i3 += 8, n3 >>= 8;
      return n3 = 7 ^ i3 + Hr[n3], t4.b -= n3, t4.Ca = (r2 << n3) - 1, a3;
    }
    function I2(t4, e3, r2) {
      t4[e3 + 0] = r2 >> 24 & 255, t4[e3 + 1] = r2 >> 16 & 255, t4[e3 + 2] = r2 >> 8 & 255, t4[e3 + 3] = r2 >> 0 & 255;
    }
    function F2(t4, e3) {
      return t4[e3 + 0] << 0 | t4[e3 + 1] << 8;
    }
    function C2(t4, e3) {
      return F2(t4, e3) | t4[e3 + 2] << 16;
    }
    function j2(t4, e3) {
      return F2(t4, e3) | F2(t4, e3 + 2) << 16;
    }
    function O2(t4, r2) {
      var n3 = 1 << r2;
      return e(null != t4), e(0 < r2), t4.X = a2(n3), null == t4.X ? 0 : (t4.Mb = 32 - r2, t4.Xa = r2, 1);
    }
    function B2(t4, r2) {
      e(null != t4), e(null != r2), e(t4.Xa == r2.Xa), n2(r2.X, 0, t4.X, 0, 1 << r2.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t4, r2, n3, i3) {
      e(null != n3), e(null != i3);
      var a3 = n3[0], o3 = i3[0];
      return 0 == a3 && (a3 = (t4 * o3 + r2 / 2) / r2), 0 == o3 && (o3 = (r2 * a3 + t4 / 2) / t4), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
    }
    function q2(t4, e3) {
      return t4 + (1 << e3) - 1 >>> e3;
    }
    function D2(t4, e3) {
      return ((4278255360 & t4) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r2) {
      t3[r2] = function(r3, n3, i3, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h4 = t3[e3](s3[c4 + u4 - 1], i3, a3 + u4);
          s3[c4 + u4] = D2(r3[n3 + u4], h4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t4, e3) {
      return ((4278124286 & (t4 ^ e3)) >>> 1) + (t4 & e3) >>> 0;
    }
    function z2(t4) {
      return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
    }
    function H2(t4, e3) {
      return z2(t4 + (t4 - e3 + 0.5 >> 1));
    }
    function W2(t4, e3, r2) {
      return Math.abs(e3 - r2) - Math.abs(t4 - r2);
    }
    function V2(t4, e3, r2, n3, i3, a3, o3) {
      for (n3 = a3[o3 - 1], r2 = 0; r2 < i3; ++r2) a3[o3 + r2] = n3 = D2(t4[e3 + r2], n3);
    }
    function G2(t4, e3, r2, n3, i3) {
      var a3;
      for (a3 = 0; a3 < r2; ++a3) {
        var o3 = t4[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    function Y2(t4, e3) {
      e3.jd = t4 >> 0 & 255, e3.hd = t4 >> 8 & 255, e3.ud = t4 >> 16 & 255;
    }
    function J2(t4, e3, r2, n3, i3, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e3[r2 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t4.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t4.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
        i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
      }
    }
    function X2(e3, r2, n3, i3, a3) {
      t3[r2] = function(t4, e4, r3, n4, o3, s3, c4, u4, h4) {
        for (n4 = c4; n4 < u4; ++n4) for (c4 = 0; c4 < h4; ++c4) o3[s3++] = a3(r3[i3(t4[e4++])]);
      }, t3[e3] = function(e4, r3, o3, s3, c4, u4, h4) {
        var l4 = 8 >> e4.b, f4 = e4.Ea, d5 = e4.K[0], p4 = e4.w;
        if (8 > l4) for (e4 = (1 << e4.b) - 1, p4 = (1 << l4) - 1; r3 < o3; ++r3) {
          var g4, m4 = 0;
          for (g4 = 0; g4 < f4; ++g4) g4 & e4 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d5[m4 & p4]), m4 >>= l4;
        }
        else t3["VP8LMapColor" + n3](s3, c4, d5, p4, u4, h4, r3, o3, f4);
      };
    }
    function K2(t4, e3, r2, n3, i3) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = t4[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
      }
    }
    function Z2(t4, e3, r2, n3, i3) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = t4[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
      }
    }
    function $2(t4, e3, r2, n3, i3) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = (o3 = t4[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function Q2(t4, e3, r2, n3, i3) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = (o3 = t4[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function tt2(t4, e3, r2, n3, i3) {
      for (r2 = e3 + r2; e3 < r2; ) {
        var a3 = t4[e3++];
        n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
      }
    }
    function et2(t4, e3, r2, i3, a3, o3) {
      if (0 == o3) for (r2 = e3 + r2; e3 < r2; ) I2(i3, ((o3 = t4[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else n2(i3, a3, t4, e3, r2);
    }
    function rt2(e3, r2) {
      t3[r2][0] = t3[e3 + "0"], t3[r2][1] = t3[e3 + "1"], t3[r2][2] = t3[e3 + "2"], t3[r2][3] = t3[e3 + "3"], t3[r2][4] = t3[e3 + "4"], t3[r2][5] = t3[e3 + "5"], t3[r2][6] = t3[e3 + "6"], t3[r2][7] = t3[e3 + "7"], t3[r2][8] = t3[e3 + "8"], t3[r2][9] = t3[e3 + "9"], t3[r2][10] = t3[e3 + "10"], t3[r2][11] = t3[e3 + "11"], t3[r2][12] = t3[e3 + "12"], t3[r2][13] = t3[e3 + "13"], t3[r2][14] = t3[e3 + "0"], t3[r2][15] = t3[e3 + "0"];
    }
    function nt2(t4) {
      return t4 == Hn || t4 == Wn || t4 == Vn || t4 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t4) {
      return alert("todo:WebPSamplerProcessPlane"), t4.T;
    }
    function ht2(t4, e3) {
      var r2 = t4.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t4.ka * i3.A, s3 = vi[e3.ba.S], c4 = t4.y, u4 = t4.O, h4 = t4.f, l4 = t4.N, f4 = t4.ea, d5 = t4.W, p4 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v5 = e3.Nc, b4 = t4.ka, y4 = t4.ka + t4.T, w4 = t4.U, N4 = w4 + 1 >> 1;
      for (0 == b4 ? s3(c4, u4, null, null, h4, l4, f4, d5, h4, l4, f4, d5, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p4, g4, m4, v5, h4, l4, f4, d5, a3, o3 - i3.A, a3, o3, w4), ++r2); b4 + 2 < y4; b4 += 2) p4 = h4, g4 = l4, m4 = f4, v5 = d5, l4 += t4.Rc, d5 += t4.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t4.fa) - t4.fa, c4, u4, p4, g4, m4, v5, h4, l4, f4, d5, a3, o3 - i3.A, a3, o3, w4);
      return u4 += t4.fa, t4.j + y4 < t4.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d5, N4), r2--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d5, h4, l4, f4, d5, a3, o3 + i3.A, null, null, w4), r2;
    }
    function lt2(t4, r2, n3) {
      var i3 = t4.F, a3 = [t4.J];
      if (null != i3) {
        var o3 = t4.U, s3 = r2.ba.S, c4 = s3 == Tn || s3 == Vn;
        r2 = r2.ba.f.RGBA;
        var u4 = [0], h4 = t4.ka;
        u4[0] = t4.T, t4.Kb && (0 == h4 ? --u4[0] : (--h4, a3[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (u4[0] = t4.o - t4.j - h4));
        var l4 = r2.eb;
        h4 = r2.fb + h4 * r2.A;
        t4 = Sn(i3, a3[0], t4.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r2.A), e(n3 == u4), t4 && nt2(s3) && An(l4, h4, c4, o3, u4, r2.A);
      }
      return 0;
    }
    function ft2(t4) {
      var e3 = t4.ma, r2 = e3.ba.S, n3 = 11 > r2, i3 = r2 == qn || r2 == Rn || r2 == Tn || r2 == Un || 12 == r2 || nt2(r2);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t4, i3 ? 11 : 12)) return 0;
      if (i3 && nt2(r2) && br(), t4.da) alert("todo:use_scaling");
      else {
        if (n3) {
          if (e3.Ib = ut2, t4.Kb) {
            if (r2 = t4.U + 1 >> 1, e3.memory = a2(t4.U + 2 * r2), null == e3.memory) return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t4.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r2, e3.Ib = ht2, br();
          }
        } else alert("todo:EmitYUV");
        i3 && (e3.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci) {
        for (t4 = 0; 256 > t4; ++t4) ji[t4] = 89858 * (t4 - 128) + _i >> Si, Mi[t4] = -22014 * (t4 - 128) + _i, Bi[t4] = -45773 * (t4 - 128), Oi[t4] = 113618 * (t4 - 128) + _i >> Si;
        for (t4 = Pi; t4 < ki; ++t4) e3 = 76283 * (t4 - 16) + _i >> Si, Ei[t4 - Pi] = Vt2(e3, 255), qi[t4 - Pi] = Vt2(e3 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t4) {
      var r2 = t4.ma, n3 = t4.U, i3 = t4.T;
      return e(!(1 & t4.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r2.Ib(t4, r2), null != r2.Jb && r2.Jb(t4, r2, n3), r2.Dc += n3, 1);
    }
    function pt2(t4) {
      t4.ma.memory = null;
    }
    function gt2(t4, e3, r2, n3) {
      return 47 != y3(t4, 8) ? 0 : (e3[0] = y3(t4, 14) + 1, r2[0] = y3(t4, 14) + 1, n3[0] = y3(t4, 1), 0 != y3(t4, 3) ? 0 : !t4.h);
    }
    function mt2(t4, e3) {
      if (4 > t4) return t4 + 1;
      var r2 = t4 - 2 >> 1;
      return (2 + (1 & t4) << r2) + y3(e3, r2) + 1;
    }
    function vt2(t4, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r2 = ((r2 = $n[e3 - 1]) >> 4) * t4 + (8 - (15 & r2))) ? r2 : 1;
      var r2;
    }
    function bt2(t4, e3, r2) {
      var n3 = L3(r2), i3 = t4[e3 += 255 & n3].g - 8;
      return 0 < i3 && (x2(r2, r2.u + 8), n3 = L3(r2), e3 += t4[e3].value, e3 += n3 & (1 << i3) - 1), x2(r2, r2.u + t4[e3].g), t4[e3].value;
    }
    function yt2(t4, r2, n3) {
      return n3.g += t4.g, n3.value += t4.value << r2 >>> 0, e(8 >= n3.g), t4.g;
    }
    function wt2(t4, r2, n3) {
      var i3 = t4.xc;
      return e((r2 = 0 == i3 ? 0 : t4.vc[t4.md * (n3 >> i3) + (r2 >> i3)]) < t4.Wb), t4.Ya[r2];
    }
    function Nt2(t4, r2, i3, a3) {
      var o3 = t4.ab, s3 = t4.c * r2, c4 = t4.C;
      r2 = c4 + r2;
      var u4 = i3, h4 = a3;
      for (a3 = t4.Ta, i3 = t4.Ua; 0 < o3--; ) {
        var l4 = t4.gc[o3], f4 = c4, d5 = r2, p4 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);
        switch (e(f4 < d5), e(d5 <= l4.nc), l4.hc) {
          case 2:
            Gr(p4, g4, (d5 - f4) * m4, h4, u4);
            break;
          case 0:
            var v5 = f4, b4 = d5, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
            0 == v5 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v5);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v5 >> _3.b) * x3; v5 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v5 & A4 || (_3 += x3);
            }
            d5 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d5 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v5 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v5; f4 < d5; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; ) Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v5);
            }
            break;
          case 3:
            if (p4 == h4 && g4 == u4 && 0 < l4.b) {
              for (b4 = h4, p4 = m4 = u4 + (d5 - f4) * m4 - (w4 = (d5 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v5 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4) v5[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4) b4[p4 + w4] = v5[w4];
              Yr(l4, f4, d5, h4, m4, h4, u4);
            } else Yr(l4, f4, d5, p4, g4, h4, u4);
        }
        u4 = a3, h4 = i3;
      }
      h4 != i3 && n2(a3, i3, u4, h4, s3);
    }
    function Lt2(t4, r2) {
      var n3 = t4.V, i3 = t4.Ba + t4.c * t4.C, a3 = r2 - t4.C;
      if (e(r2 <= t4.l.o), e(16 >= a3), 0 < a3) {
        var o3 = t4.l, s3 = t4.Ta, c4 = t4.Ua, u4 = o3.width;
        if (Nt2(t4, a3, n3, i3), a3 = c4 = [c4], e((n3 = t4.C) < (i3 = r2)), e(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
          var h4 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h4 * u4;
        }
        if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t4.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d5 = o3;
            for (l4 = l4.fb + t4.Ma * l4.A; 0 < d5--; ) {
              var p4 = s3, g4 = c4, m4 = a3, v5 = h4, b4 = l4;
              switch (i3) {
                case En:
                  Qr(p4, g4, m4, v5, b4);
                  break;
                case qn:
                  tn(p4, g4, m4, v5, b4);
                  break;
                case Hn:
                  tn(p4, g4, m4, v5, b4), An(v5, b4, 0, m4, 1, 0);
                  break;
                case Dn:
                  nn(p4, g4, m4, v5, b4);
                  break;
                case Rn:
                  et2(p4, g4, m4, v5, b4, 1);
                  break;
                case Wn:
                  et2(p4, g4, m4, v5, b4, 1), An(v5, b4, 0, m4, 1, 0);
                  break;
                case Tn:
                  et2(p4, g4, m4, v5, b4, 0);
                  break;
                case Vn:
                  et2(p4, g4, m4, v5, b4, 0), An(v5, b4, 1, m4, 1, 0);
                  break;
                case Un:
                  en(p4, g4, m4, v5, b4);
                  break;
                case Gn:
                  en(p4, g4, m4, v5, b4), xn(v5, b4, m4, 1, 0);
                  break;
                case zn:
                  rn(p4, g4, m4, v5, b4);
                  break;
                default:
                  e(0);
              }
              c4 += u4, l4 += f4;
            }
            t4.Ma += o3;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(t4.Ma <= n3.height);
        }
      }
      t4.C = r2, e(t4.C <= t4.i);
    }
    function At2(t4) {
      var e3;
      if (0 < t4.ua) return 0;
      for (e3 = 0; e3 < t4.Wb; ++e3) {
        var r2 = t4.Ya[e3].G, n3 = t4.Ya[e3].H;
        if (0 < r2[1][n3[1] + 0].g || 0 < r2[2][n3[2] + 0].g || 0 < r2[3][n3[3] + 0].g) return 0;
      }
      return 1;
    }
    function xt2(t4, r2, n3, i3, a3, o3) {
      if (0 != t4.Z) {
        var s3 = t4.qd, c4 = t4.rd;
        for (e(null != mi[t4.Z]); r2 < n3; ++r2) mi[t4.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
        t4.qd = s3, t4.rd = c4;
      }
    }
    function St2(t4, r2) {
      var n3 = t4.l.ma, i3 = 0 == n3.Z || 1 == n3.Z ? t4.l.j : t4.C;
      i3 = t4.C < i3 ? i3 : t4.C;
      if (e(r2 <= t4.l.o), r2 > i3) {
        var a3 = t4.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t4.V, u4 = t4.Ba + t4.c * i3, h4 = t4.gc;
        e(1 == t4.ab), e(3 == h4[0].hc), Xr(h4[0], i3, r2, c4, u4, o3, s3), xt2(n3, i3, r2, o3, s3, a3);
      }
      t4.C = t4.Ma = r2;
    }
    function _t2(t4, r2, n3, i3, a3, o3, s3) {
      var c4 = t4.$ / i3, u4 = t4.$ % i3, h4 = t4.m, l4 = t4.s, f4 = n3 + t4.$, d5 = f4;
      a3 = n3 + i3 * a3;
      var p4 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t4.Pb ? c4 : 16777216, v5 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
      e(t4.C < o3), e(p4 <= a3);
      var w4 = false;
      t: for (; ; ) {
        for (; w4 || f4 < p4; ) {
          var N4 = 0;
          if (c4 >= m4) {
            var _3 = f4 - n3;
            e((m4 = t4).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B2(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
          }
          if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e(null != y4), y4.Qb && (r2[f4] = y4.qb, w4 = true), !w4) if (S2(h4), y4.jc) {
            N4 = h4, _3 = r2;
            var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
            e(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
          } else N4 = bt2(y4.G[0], y4.H[0], h4);
          if (h4.h) break;
          if (w4 || 256 > N4) {
            if (!w4) if (y4.nd) r2[f4] = (y4.qb | N4 << 8) >>> 0;
            else {
              if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h) break;
              r2[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
            }
            if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4), null != v5)) for (; d5 < f4; ) N4 = r2[d5++], v5.X[(506832829 * N4 & 4294967295) >>> v5.Mb] = N4;
          } else if (280 > N4) {
            if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h) break;
            if (f4 - n3 < _3 || a3 - f4 < N4) break t;
            for (P3 = 0; P3 < N4; ++P3) r2[f4 + P3] = r2[f4 + P3 - _3];
            for (f4 += N4, u4 += N4; u4 >= i3; ) u4 -= i3, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4);
            if (e(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), null != v5) for (; d5 < f4; ) N4 = r2[d5++], v5.X[(506832829 * N4 & 4294967295) >>> v5.Mb] = N4;
          } else {
            if (!(N4 < g4)) break t;
            for (w4 = N4 - 280, e(null != v5); d5 < f4; ) N4 = r2[d5++], v5.X[(506832829 * N4 & 4294967295) >>> v5.Mb] = N4;
            N4 = f4, e(!(w4 >>> (_3 = v5).Xa)), r2[N4] = _3.X[w4], w4 = true;
          }
          w4 || e(h4.h == A3(h4));
        }
        if (t4.Pb && h4.h && f4 < a3) e(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B2(t4.s.vb, t4.s.Wa);
        else {
          if (h4.h) break t;
          null != s3 && s3(t4, c4 > o3 ? o3 : c4), t4.a = 0, t4.$ = f4 - n3;
        }
        return 1;
      }
      return t4.a = 3, 0;
    }
    function Pt2(t4) {
      e(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
      var r2 = t4.Wa;
      null != r2 && (r2.X = null), t4.vb = null, e(null != t4);
    }
    function kt2() {
      var e3 = new or();
      return null == e3 ? null : (e3.a = 0, e3.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t3.VP8LMapColor32b = Jr, t3.VP8LMapColor8b = Kr, e3);
    }
    function It2(t4, r2, n3, s3, c4) {
      var u4 = 1, f4 = [t4], p4 = [r2], g4 = s3.m, m4 = s3.s, v5 = null, b4 = 0;
      t: for (; ; ) {
        if (n3) for (; u4 && y3(g4, 1); ) {
          var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
          if (A4.Oc & 1 << I3) u4 = 0;
          else {
            switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e(4 >= A4.ab), I3) {
              case 0:
              case 1:
                k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                break;
              case 3:
                var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                  var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                  if (null == T3) F3 = 0;
                  else {
                    var U3 = E3.K[0], z3 = E3.w;
                    for (T3[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3) T3[B3] = D2(U3[z3 + B3], T3[B3 - 1]);
                    for (; B3 < 4 * R3; ++B3) T3[B3] = 0;
                    E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                  }
                }
                _3 = F3;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            u4 = _3;
          }
        }
        if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
          s3.a = 3;
          break t;
        }
        var H3;
        if (H3 = u4) e: {
          var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
          r: for (; ; ) {
            if (Z3 && y3($3, 1)) {
              var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
              if (!It2(at3, ot3, 0, Y3, tt3)) break r;
              for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                var ct3 = tt3[W3] >> 8 & 65535;
                tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
              }
            }
            if ($3.h) break r;
            for (V3 = 0; 5 > V3; ++V3) {
              var ut3 = Xn[V3];
              !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
            }
            var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d4);
            if (null == ft3) var dt3 = null;
            else e(65536 >= lt3), dt3 = ft3;
            var pt3 = a2(rt3);
            if (null == dt3 || null == pt3 || null == ht3) {
              Y3.a = 1;
              break r;
            }
            var gt3 = ht3;
            for (W3 = G3 = 0; W3 < et3; ++W3) {
              var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
              for (V3 = 0; 5 > V3; ++V3) {
                ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                n: {
                  var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                  if (i2(kt3, 0, 0, xt3), Bt3) {
                    var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, 0 == Et3 ? 1 : 8);
                    kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                    var Dt3 = 1;
                  } else {
                    var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                    if (19 < Tt3) {
                      St3.a = 3;
                      var Ut3 = 0;
                      break n;
                    }
                    for (At3 = 0; At3 < Tt3; ++At3) Rt3[Zn[At3]] = y3(Ot3, 3);
                    var zt3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                    i: for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                      if (y3(Xt3, 1)) {
                        var $t3 = 2 + 2 * y3(Xt3, 3);
                        if ((zt3 = 2 + y3(Xt3, $t3)) > Gt3) break i;
                      } else zt3 = Gt3;
                      for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                        S2(Xt3);
                        var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                        x2(Xt3, Xt3.u + Qt3.g);
                        var te3 = Qt3.value;
                        if (16 > te3) Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                        else {
                          var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;
                          if (Ht3 + ie3 > Gt3) break i;
                          for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; ) Yt3[Ht3++] = ae3;
                        }
                      }
                      Jt3 = 1;
                      break i;
                    }
                    Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                  }
                  (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                }
                if (0 == Ut3) break r;
                if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                  var oe3, se3 = pt3[0];
                  for (oe3 = 1; oe3 < ut3; ++oe3) pt3[oe3] > se3 && (se3 = pt3[oe3]);
                  Lt3 += se3;
                }
              }
              if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                var ce3, ue3 = mt3;
                for (ce3 = 0; ce3 < Dr; ++ce3) {
                  var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                  256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                }
              }
            }
            Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
            break e;
          }
          H3 = 0;
        }
        if (!(u4 = H3)) {
          s3.a = 3;
          break t;
        }
        if (0 < b4) {
          if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
            s3.a = 1, u4 = 0;
            break t;
          }
        } else m4.ua = 0;
        var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
        if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
          s3.xb = pi2;
          break t;
        }
        if (null == (v5 = a2(f4 * p4))) {
          s3.a = 1, u4 = 0;
          break t;
        }
        u4 = (u4 = _t2(s3, v5, 0, f4, p4, p4, null)) && !g4.h;
        break t;
      }
      return u4 ? (null != c4 ? c4[0] = v5 : (e(null == v5), e(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    function Ft2(t4, r2) {
      var n3 = t4.c * t4.i, i3 = n3 + r2 + 16 * r2;
      return e(t4.c <= r2), t4.V = a2(i3), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + n3 + r2, 1);
    }
    function Ct2(t4, r2) {
      var n3 = t4.C, i3 = r2 - n3, a3 = t4.V, o3 = t4.Ba + t4.c * n3;
      for (e(r2 <= t4.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, c4 = t4.l.ma, u4 = t4.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d5 = t4.Ta, p4 = t4.Ua;
        Nt2(t4, s3, a3, o3), _n(d5, p4, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t4.c, n3 += s3;
      }
      e(n3 == r2), t4.C = t4.Ma = r2;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t4 = [];
        return function t5(e3, r2, n3) {
          for (var i3 = n3[r2], a3 = 0; a3 < i3 && (e3.push(n3.length > r2 + 1 ? [] : 0), !(n3.length < r2 + 1)); a3++) t5(e3[a3], r2 + 1, n3);
        }(t4, 0, [3, 11]), t4;
      }();
    }
    function Et2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t4, e3) {
      return 0 > t4 ? 0 : t4 > e3 ? e3 : t4;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t4 = new Wt2();
      return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ni || (ni = Zt2)), t4;
    }
    function Jt2(t4, e3, r2) {
      return 0 == t4.a && (t4.a = e3, t4.sc = r2, t4.cb = 0), 0;
    }
    function Xt2(t4, e3, r2) {
      return 3 <= r2 && 157 == t4[e3 + 0] && 1 == t4[e3 + 1] && 42 == t4[e3 + 2];
    }
    function Kt2(t4, r2) {
      if (null == t4) return 0;
      if (t4.a = 0, t4.sc = "OK", null == r2) return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r2.data, a3 = r2.w, o3 = r2.ha;
      if (4 > o3) return Jt2(t4, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t4.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td) return Jt2(t4, 3, "Incorrect keyframe parameters.");
      if (!c4.yd) return Jt2(t4, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t4.Kc;
      if (c4.Rb) {
        if (7 > o3) return Jt2(t4, 7, "cannot parse picture header");
        if (!Xt2(n3, a3, o3)) return Jt2(t4, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t4.za = u4.c + 15 >> 4, t4.Ub = u4.i + 15 >> 4, r2.width = u4.c, r2.height = u4.i, r2.Da = 0, r2.j = 0, r2.v = 0, r2.va = r2.width, r2.o = r2.height, r2.da = 0, r2.ib = r2.width, r2.hb = r2.height, r2.U = r2.width, r2.T = r2.height, i2((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3) return Jt2(t4, 7, "bad partition length");
      p3(s3 = t4.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t4.Qa;
      var h4, l4 = t4.Pa;
      if (e(null != s3), e(null != u4), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4) u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
          for (h4 = 0; 4 > h4; ++h4) u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb) for (h4 = 0; 3 > h4; ++h4) l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
      } else u4.Bb = 0;
      if (s3.Ka) return Jt2(t4, 3, "cannot parse segment header");
      if ((u4 = t4.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4) P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4) P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t4.L = 0 == u4.Tb ? 0 : u4.zd ? 1 : 2, s3.Ka) return Jt2(t4, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t4.Xb = (1 << g3(t4.m, 2)) - 1, f4 < 3 * (l4 = t4.Xb)) n3 = 7;
      else {
        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d5 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d5 > u4 && (d5 = u4), p3(t4.Jc[+f4], n3, h4, d5), h4 += d5, u4 -= d5, o3 += 3;
        }
        p3(t4.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
      }
      if (0 != n3) return Jt2(t4, n3, "cannot parse partitions");
      for (n3 = g3(h4 = t4.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t4.Qa, d5 = 0; 4 > d5; ++d5) {
        if (f4.Cb) {
          var v5 = f4.Zb[d5];
          f4.Fb || (v5 += n3);
        } else {
          if (0 < d5) {
            t4.pb[d5] = t4.pb[0];
            continue;
          }
          v5 = n3;
        }
        var b4 = t4.pb[d5];
        b4.Sc[0] = ei[Vt2(v5 + o3, 127)], b4.Sc[1] = ri[Vt2(v5 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v5 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v5 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v5 + l4, 117)], b4.Qc[1] = ri[Vt2(v5 + h4, 127)], b4.lc = v5 + h4;
      }
      if (!c4.Rb) return Jt2(t4, 4, "Not a key frame.");
      for (P2(s3), c4 = t4.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3) for (a3 = 0; 3 > a3; ++a3) for (u4 = 0; 11 > u4; ++u4) l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3) c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
      }
      return t4.kc = P2(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
    }
    function Zt2(t4, e3, r2, n3, i3, a3, o3) {
      var s3 = e3[i3].Yb[r2];
      for (r2 = 0; 16 > i3; ++i3) {
        if (!k2(t4, s3[r2 + 0])) return i3;
        for (; !k2(t4, s3[r2 + 1]); ) if (s3 = e3[++i3].Yb[0], r2 = 0, 16 == i3) return 16;
        var c4 = e3[i3 + 1].Yb;
        if (k2(t4, s3[r2 + 2])) {
          var u4 = t4, h4 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r2) + 3])) if (k2(u4, f4[l4 + 6])) {
            for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3) h4 += h4 + k2(u4, f4[s3]);
            h4 += 3 + (8 << l4);
          } else k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
          else h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else h4 = 1, s3 = c4[1];
        c4 = o3 + ai[i3], 0 > (u4 = t4).b && _2(u4);
        var l4, f4 = u4.b, d5 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d5, u4.Ca |= 1, u4.I -= (l4 + 1 & d5) << f4, a3[c4] = ((h4 ^ d5) - d5) * n3[(0 < i3) + 0];
      }
      return 16;
    }
    function $t2(t4) {
      var e3 = t4.rb[t4.sb - 1];
      e3.la = 0, e3.Na = 0, i2(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
    }
    function Qt2(t4, r2) {
      if (null == t4) return 0;
      if (null == r2) return Jt2(t4, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t4.cb && !Kt2(t4, r2)) return 0;
      if (e(t4.cb), null == r2.ac || r2.ac(r2)) {
        r2.ob && (t4.L = 0);
        var s3 = Ri[t4.L];
        if (2 == t4.L ? (t4.yb = 0, t4.zb = 0) : (t4.yb = r2.v - s3 >> 4, t4.zb = r2.j - s3 >> 4, 0 > t4.yb && (t4.yb = 0), 0 > t4.zb && (t4.zb = 0)), t4.Va = r2.o + 15 + s3 >> 4, t4.Hb = r2.va + 15 + s3 >> 4, t4.Hb > t4.za && (t4.Hb = t4.za), t4.Va > t4.Ub && (t4.Va = t4.Ub), 0 < t4.L) {
          var c4 = t4.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t4.Qa.Cb) {
              var h4 = t4.Qa.Lb[s3];
              t4.Qa.Fb || (h4 += c4.Tb);
            } else h4 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t4.gd[s3][u4], f4 = h4;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d5 = f4;
                0 < c4.wb && ((d5 = 4 < c4.wb ? d5 >> 2 : d5 >> 1) > 9 - c4.wb && (d5 = 9 - c4.wb)), 1 > d5 && (d5 = 1), l4.dd = d5, l4.tc = 2 * f4 + d5, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else Jt2(t4, 6, "Frame setup failed"), s3 = t4.a;
      if (s3 = 0 == s3) {
        if (s3) {
          t4.$c = 0, 0 < t4.Aa || (t4.Ic = Ui);
          t: {
            s3 = t4.Ic;
            c4 = 4 * (d5 = t4.za);
            var p4 = 32 * d5, g4 = d5 + 1, m4 = 0 < t4.L ? d5 * (0 < t4.Aa ? 2 : 1) : 0, v5 = (2 == t4.Aa ? 2 : 1) * d5;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t4.L]) / 2 * p4) + (h4 = null != t4.Fa && 0 < t4.Fa.length ? t4.Kc.c * t4.Kc.i : 0)) != l4) s3 = 0;
            else {
              if (l4 > t4.Vb) {
                if (t4.Vb = 0, t4.Ec = a2(l4), t4.Fc = 0, null == t4.Ec) {
                  s3 = Jt2(t4, 1, "no memory during frame initialization.");
                  break t;
                }
                t4.Vb = l4;
              }
              l4 = t4.Ec, f4 = t4.Fc, t4.Ac = l4, t4.Bc = f4, f4 += c4, t4.Gd = o2(p4, Ht2), t4.Hd = 0, t4.rb = o2(g4 + 1, Rt2), t4.sb = 1, t4.wa = m4 ? o2(m4, Dt2) : null, t4.Y = 0, t4.D.Nb = 0, t4.D.wa = t4.wa, t4.D.Y = t4.Y, 0 < t4.Aa && (t4.D.Y += d5), e(true), t4.oc = l4, t4.pc = f4, f4 += 832, t4.ya = o2(v5, Ut2), t4.aa = 0, t4.D.ya = t4.ya, t4.D.aa = t4.aa, 2 == t4.Aa && (t4.D.aa += d5), t4.R = 16 * d5, t4.B = 8 * d5, d5 = (p4 = Ri[t4.L]) * t4.R, p4 = p4 / 2 * t4.B, t4.sa = l4, t4.ta = f4 + d5, t4.qa = t4.sa, t4.ra = t4.ta + 16 * s3 * t4.R + p4, t4.Ha = t4.qa, t4.Ia = t4.ra + 8 * s3 * t4.B + p4, t4.$c = 0, f4 += u4, t4.mb = h4 ? l4 : null, t4.nb = h4 ? f4 : null, e(f4 + h4 <= t4.Fc + t4.Vb), $t2(t4), i2(t4.Ac, t4.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r2.ka = 0, r2.y = t4.sa, r2.O = t4.ta, r2.f = t4.qa, r2.N = t4.ra, r2.ea = t4.Ha, r2.Vd = t4.Ia, r2.fa = t4.R, r2.Rc = t4.B, r2.F = null, r2.J = 0, !Cn) {
              for (s3 = -255; 255 >= s3; ++s3) Pn[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3) kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3) In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3) Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn = 1;
            }
            an2 = ue2, on2 = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
          } else s3 = 0;
        }
        s3 && (s3 = function(t5, r3) {
          for (t5.M = 0; t5.M < t5.Va; ++t5.M) {
            var o3, s4 = t5.Jc[t5.M & t5.Xb], c5 = t5.m, u5 = t5;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h5 = c5, l5 = u5, f5 = l5.Ac, d6 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v6 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p5[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci[f5[d6 + b4]][y4];
                    for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; ) w4 = oi[2 * w4 + k2(h5, y4[w4])];
                    y4 = -w4, f5[d6 + b4] = y4;
                  }
                  n2(m5, v6, f5, d6, 4), v6 += 4, p5[0 + l5] = y4;
                }
              } else y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d6, y4, 4), i2(p5, 0, y4, 4);
              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka) return Jt2(t5, 7, "Premature end-of-partition0 encountered.");
            for (; t5.ja < t5.za; ++t5.ja) {
              if (u5 = s4, h5 = (c5 = t5).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d6 = c5.kc ? o3.Ad : 0) h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h5 = f5, f5 = u5, d6 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                if (l5 = p5.ad, m5 = 0, v6 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p5.Za) var A4 = 0, x3 = d6[3];
                else {
                  w4 = a2(16);
                  var S3 = h5.Na + v6.Na;
                  if (S3 = ni(f5, d6[1], S3, g5.Eb, 0, w4, 0), h5.Na = v6.Na = (0 < S3) + 0, 1 < S3) an2(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16) l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d6[0];
                }
                var P3 = 15 & h5.la, I3 = 15 & v6.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3) P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v6.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3) S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d6[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h5.la = x3, v6.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d6 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d6), u5.Ka) return Jt2(t5, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t5), c5 = r3, u5 = 1, o3 = (s4 = t5).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, 0 == s4.Aa) t: {
              if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d6 = s4.sa, p5 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v6 = s4.Ia - f5 + _3, I3 = 0 == (P3 = L4.M), b4 = P3 >= s4.Va - 1, 2 == s4.Aa && Or(s4, L4), L4.uc) for (F3 = (S3 = s4).D.M, e(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                A4 = L4, x3 = F3;
                var C3 = (j3 = (U3 = S3).D).Nb;
                N4 = U3.R;
                var j3 = j3.wa[j3.Y + A4], O3 = U3.sa, B3 = U3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                if (0 != E3) if (e(3 <= E3), 1 == U3.L) 0 < A4 && wn(O3, B3, N4, E3 + 4), j3.La && Ln(O3, B3, N4, E3), 0 < x3 && yn(O3, B3, N4, E3 + 4), j3.La && Nn(O3, B3, N4, E3);
                else {
                  var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T3 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                  C3 = j3.ld;
                  0 < A4 && (fn(O3, B3, N4, E3 + 4, M3, C3), pn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B3, N4, E3, M3, C3), bn(D3, R3, T3, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B3, N4, E3 + 4, M3, C3), dn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B3, N4, E3, M3, C3), vn(D3, R3, T3, U3, q3, E3, M3, C3));
                }
              }
              if (s4.ia && alert("todo:DitherRow"), null != c5.put) {
                if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d6, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v6), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, null != s4.Fa && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, null == c5.F && 0 == c5.F.length)) {
                  u5 = Jt2(s4, 3, "Could not decode alpha data.");
                  break t;
                }
                L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), null != c5.F && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, null != c5.F && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
              }
              o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d6, p5 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v6 + 8 * s4.B, f5));
            }
            if (!u5) return Jt2(t5, 6, "Output aborted.");
          }
          return 1;
        }(t4, r2)), null != r2.bc && r2.bc(r2), s3 &= 1;
      }
      return s3 ? (t4.cb = 0, s3) : 0;
    }
    function te2(t4, e3, r2, n3, i3) {
      i3 = t4[e3 + r2 + 32 * n3] + (i3 >> 3), t4[e3 + r2 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    function ee2(t4, e3, r2, n3, i3, a3) {
      te2(t4, e3, 0, r2, n3 + i3), te2(t4, e3, 1, r2, n3 + a3), te2(t4, e3, 2, r2, n3 - a3), te2(t4, e3, 3, r2, n3 - i3);
    }
    function re2(t4) {
      return (20091 * t4 >> 16) + t4;
    }
    function ne2(t4, e3, r2, n3) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var c4 = t4[e3 + 0] + t4[e3 + 8], u4 = t4[e3 + 0] - t4[e3 + 8], h4 = (35468 * t4[e3 + 4] >> 16) - re2(t4[e3 + 12]), l4 = re2(t4[e3 + 4]) + (35468 * t4[e3 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3) c4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t4 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r2, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r2, n3, 1, 0, u4 + h4), te2(r2, n3, 2, 0, u4 - h4), te2(r2, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    function ie2(t4, e3, r2, n3) {
      var i3 = t4[e3 + 0] + 4, a3 = 35468 * t4[e3 + 4] >> 16, o3 = re2(t4[e3 + 4]), s3 = 35468 * t4[e3 + 1] >> 16;
      ee2(r2, n3, 0, i3 + o3, t4 = re2(t4[e3 + 1]), s3), ee2(r2, n3, 1, i3 + a3, t4, s3), ee2(r2, n3, 2, i3 - a3, t4, s3), ee2(r2, n3, 3, i3 - o3, t4, s3);
    }
    function ae2(t4, e3, r2, n3, i3) {
      ne2(t4, e3, r2, n3), i3 && ne2(t4, e3 + 16, r2, n3 + 4);
    }
    function oe2(t4, e3, r2, n3) {
      on2(t4, e3 + 0, r2, n3, 1), on2(t4, e3 + 32, r2, n3 + 128, 1);
    }
    function se2(t4, e3, r2, n3) {
      var i3;
      for (t4 = t4[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3) for (e3 = 0; 4 > e3; ++e3) te2(r2, n3, e3, i3, t4);
    }
    function ce2(t4, e3, r2, n3) {
      t4[e3 + 0] && un(t4, e3 + 0, r2, n3), t4[e3 + 16] && un(t4, e3 + 16, r2, n3 + 4), t4[e3 + 32] && un(t4, e3 + 32, r2, n3 + 128), t4[e3 + 48] && un(t4, e3 + 48, r2, n3 + 128 + 4);
    }
    function ue2(t4, e3, r2, n3) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t4[e3 + 0 + i3] + t4[e3 + 12 + i3], c4 = t4[e3 + 4 + i3] + t4[e3 + 8 + i3], u4 = t4[e3 + 4 + i3] - t4[e3 + 8 + i3], h4 = t4[e3 + 0 + i3] - t4[e3 + 12 + i3];
        o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;
      }
      for (i3 = 0; 4 > i3; ++i3) s3 = (t4 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t4 - o3[3 + 4 * i3], r2[n3 + 0] = s3 + c4 >> 3, r2[n3 + 16] = h4 + u4 >> 3, r2[n3 + 32] = s3 - c4 >> 3, r2[n3 + 48] = h4 - u4 >> 3, n3 += 64;
    }
    function he2(t4, e3, r2) {
      var n3, i3 = e3 - 32, a3 = Bn, o3 = 255 - t4[i3 - 1];
      for (n3 = 0; n3 < r2; ++n3) {
        var s3, c4 = a3, u4 = o3 + t4[e3 - 1];
        for (s3 = 0; s3 < r2; ++s3) t4[e3 + s3] = c4[u4 + t4[i3 + s3]];
        e3 += 32;
      }
    }
    function le2(t4, e3) {
      he2(t4, e3, 4);
    }
    function fe2(t4, e3) {
      he2(t4, e3, 8);
    }
    function de2(t4, e3) {
      he2(t4, e3, 16);
    }
    function pe2(t4, e3) {
      var r2;
      for (r2 = 0; 16 > r2; ++r2) n2(t4, e3 + 32 * r2, t4, e3 - 32, 16);
    }
    function ge2(t4, e3) {
      var r2;
      for (r2 = 16; 0 < r2; --r2) i2(t4, e3, t4[e3 - 1], 16), e3 += 32;
    }
    function me2(t4, e3, r2) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3) i2(e3, r2 + 32 * n3, t4, 16);
    }
    function ve2(t4, e3) {
      var r2, n3 = 16;
      for (r2 = 0; 16 > r2; ++r2) n3 += t4[e3 - 1 + 32 * r2] + t4[e3 + r2 - 32];
      me2(n3 >> 5, t4, e3);
    }
    function be2(t4, e3) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2) n3 += t4[e3 - 1 + 32 * r2];
      me2(n3 >> 4, t4, e3);
    }
    function ye2(t4, e3) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2) n3 += t4[e3 + r2 - 32];
      me2(n3 >> 4, t4, e3);
    }
    function we2(t4, e3) {
      me2(128, t4, e3);
    }
    function Ne2(t4, e3, r2) {
      return t4 + 2 * e3 + r2 + 2 >> 2;
    }
    function Le2(t4, e3) {
      var r2, i3 = e3 - 32;
      i3 = new Uint8Array([Ne2(t4[i3 - 1], t4[i3 + 0], t4[i3 + 1]), Ne2(t4[i3 + 0], t4[i3 + 1], t4[i3 + 2]), Ne2(t4[i3 + 1], t4[i3 + 2], t4[i3 + 3]), Ne2(t4[i3 + 2], t4[i3 + 3], t4[i3 + 4])]);
      for (r2 = 0; 4 > r2; ++r2) n2(t4, e3 + 32 * r2, i3, 0, i3.length);
    }
    function Ae(t4, e3) {
      var r2 = t4[e3 - 1], n3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96];
      I2(t4, e3 + 0, 16843009 * Ne2(t4[e3 - 1 - 32], r2, n3)), I2(t4, e3 + 32, 16843009 * Ne2(r2, n3, i3)), I2(t4, e3 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t4, e3 + 96, 16843009 * Ne2(i3, a3, a3));
    }
    function xe(t4, e3) {
      var r2, n3 = 4;
      for (r2 = 0; 4 > r2; ++r2) n3 += t4[e3 + r2 - 32] + t4[e3 - 1 + 32 * r2];
      for (n3 >>= 3, r2 = 0; 4 > r2; ++r2) i2(t4, e3 + 32 * r2, n3, 4);
    }
    function Se(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 - 32], o3 = t4[e3 + 0 - 32], s3 = t4[e3 + 1 - 32], c4 = t4[e3 + 2 - 32], u4 = t4[e3 + 3 - 32];
      t4[e3 + 0 + 96] = Ne2(n3, i3, t4[e3 - 1 + 96]), t4[e3 + 1 + 96] = t4[e3 + 0 + 64] = Ne2(r2, n3, i3), t4[e3 + 2 + 96] = t4[e3 + 1 + 64] = t4[e3 + 0 + 32] = Ne2(a3, r2, n3), t4[e3 + 3 + 96] = t4[e3 + 2 + 64] = t4[e3 + 1 + 32] = t4[e3 + 0 + 0] = Ne2(o3, a3, r2), t4[e3 + 3 + 64] = t4[e3 + 2 + 32] = t4[e3 + 1 + 0] = Ne2(s3, o3, a3), t4[e3 + 3 + 32] = t4[e3 + 2 + 0] = Ne2(c4, s3, o3), t4[e3 + 3 + 0] = Ne2(u4, c4, s3);
    }
    function _e(t4, e3) {
      var r2 = t4[e3 + 1 - 32], n3 = t4[e3 + 2 - 32], i3 = t4[e3 + 3 - 32], a3 = t4[e3 + 4 - 32], o3 = t4[e3 + 5 - 32], s3 = t4[e3 + 6 - 32], c4 = t4[e3 + 7 - 32];
      t4[e3 + 0 + 0] = Ne2(t4[e3 + 0 - 32], r2, n3), t4[e3 + 1 + 0] = t4[e3 + 0 + 32] = Ne2(r2, n3, i3), t4[e3 + 2 + 0] = t4[e3 + 1 + 32] = t4[e3 + 0 + 64] = Ne2(n3, i3, a3), t4[e3 + 3 + 0] = t4[e3 + 2 + 32] = t4[e3 + 1 + 64] = t4[e3 + 0 + 96] = Ne2(i3, a3, o3), t4[e3 + 3 + 32] = t4[e3 + 2 + 64] = t4[e3 + 1 + 96] = Ne2(a3, o3, s3), t4[e3 + 3 + 64] = t4[e3 + 2 + 96] = Ne2(o3, s3, c4), t4[e3 + 3 + 96] = Ne2(s3, c4, c4);
    }
    function Pe(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 - 32], o3 = t4[e3 + 0 - 32], s3 = t4[e3 + 1 - 32], c4 = t4[e3 + 2 - 32], u4 = t4[e3 + 3 - 32];
      t4[e3 + 0 + 0] = t4[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t4[e3 + 1 + 0] = t4[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t4[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t4[e3 + 0 + 96] = Ne2(i3, n3, r2), t4[e3 + 0 + 64] = Ne2(n3, r2, a3), t4[e3 + 0 + 32] = t4[e3 + 1 + 96] = Ne2(r2, a3, o3), t4[e3 + 1 + 32] = t4[e3 + 2 + 96] = Ne2(a3, o3, s3), t4[e3 + 2 + 32] = t4[e3 + 3 + 96] = Ne2(o3, s3, c4), t4[e3 + 3 + 32] = Ne2(s3, c4, u4);
    }
    function ke(t4, e3) {
      var r2 = t4[e3 + 0 - 32], n3 = t4[e3 + 1 - 32], i3 = t4[e3 + 2 - 32], a3 = t4[e3 + 3 - 32], o3 = t4[e3 + 4 - 32], s3 = t4[e3 + 5 - 32], c4 = t4[e3 + 6 - 32], u4 = t4[e3 + 7 - 32];
      t4[e3 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e3 + 1 + 0] = t4[e3 + 0 + 64] = n3 + i3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t4[e3 + 3 + 0] = t4[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t4[e3 + 0 + 32] = Ne2(r2, n3, i3), t4[e3 + 1 + 32] = t4[e3 + 0 + 96] = Ne2(n3, i3, a3), t4[e3 + 2 + 32] = t4[e3 + 1 + 96] = Ne2(i3, a3, o3), t4[e3 + 3 + 32] = t4[e3 + 2 + 96] = Ne2(a3, o3, s3), t4[e3 + 3 + 64] = Ne2(o3, s3, c4), t4[e3 + 3 + 96] = Ne2(s3, c4, u4);
    }
    function Ie(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96];
      t4[e3 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 0 + 32] = n3 + i3 + 1 >> 1, t4[e3 + 2 + 32] = t4[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t4[e3 + 1 + 0] = Ne2(r2, n3, i3), t4[e3 + 3 + 0] = t4[e3 + 1 + 32] = Ne2(n3, i3, a3), t4[e3 + 3 + 32] = t4[e3 + 1 + 64] = Ne2(i3, a3, a3), t4[e3 + 3 + 64] = t4[e3 + 2 + 64] = t4[e3 + 0 + 96] = t4[e3 + 1 + 96] = t4[e3 + 2 + 96] = t4[e3 + 3 + 96] = a3;
    }
    function Fe(t4, e3) {
      var r2 = t4[e3 - 1 + 0], n3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96], o3 = t4[e3 - 1 - 32], s3 = t4[e3 + 0 - 32], c4 = t4[e3 + 1 - 32], u4 = t4[e3 + 2 - 32];
      t4[e3 + 0 + 0] = t4[e3 + 2 + 32] = r2 + o3 + 1 >> 1, t4[e3 + 0 + 32] = t4[e3 + 2 + 64] = n3 + r2 + 1 >> 1, t4[e3 + 0 + 64] = t4[e3 + 2 + 96] = i3 + n3 + 1 >> 1, t4[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t4[e3 + 3 + 0] = Ne2(s3, c4, u4), t4[e3 + 2 + 0] = Ne2(o3, s3, c4), t4[e3 + 1 + 0] = t4[e3 + 3 + 32] = Ne2(r2, o3, s3), t4[e3 + 1 + 32] = t4[e3 + 3 + 64] = Ne2(n3, r2, o3), t4[e3 + 1 + 64] = t4[e3 + 3 + 96] = Ne2(i3, n3, r2), t4[e3 + 1 + 96] = Ne2(a3, i3, n3);
    }
    function Ce(t4, e3) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2) n2(t4, e3 + 32 * r2, t4, e3 - 32, 8);
    }
    function je(t4, e3) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2) i2(t4, e3, t4[e3 - 1], 8), e3 += 32;
    }
    function Oe(t4, e3, r2) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3) i2(e3, r2 + 32 * n3, t4, 8);
    }
    function Be(t4, e3) {
      var r2, n3 = 8;
      for (r2 = 0; 8 > r2; ++r2) n3 += t4[e3 + r2 - 32] + t4[e3 - 1 + 32 * r2];
      Oe(n3 >> 4, t4, e3);
    }
    function Me(t4, e3) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2) n3 += t4[e3 + r2 - 32];
      Oe(n3 >> 3, t4, e3);
    }
    function Ee(t4, e3) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2) n3 += t4[e3 - 1 + 32 * r2];
      Oe(n3 >> 3, t4, e3);
    }
    function qe(t4, e3) {
      Oe(128, t4, e3);
    }
    function De(t4, e3, r2) {
      var n3 = t4[e3 - r2], i3 = t4[e3 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t4[e3 - 2 * r2] - t4[e3 + r2]], o3 = On[112 + (a3 + 4 >> 3)];
      t4[e3 - r2] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t4[e3 + 0] = Bn[255 + i3 - o3];
    }
    function Re(t4, e3, r2, n3) {
      var i3 = t4[e3 + 0], a3 = t4[e3 + r2];
      return Mn[255 + t4[e3 - 2 * r2] - t4[e3 - r2]] > n3 || Mn[255 + a3 - i3] > n3;
    }
    function Te(t4, e3, r2, n3) {
      return 4 * Mn[255 + t4[e3 - r2] - t4[e3 + 0]] + Mn[255 + t4[e3 - 2 * r2] - t4[e3 + r2]] <= n3;
    }
    function Ue(t4, e3, r2, n3, i3) {
      var a3 = t4[e3 - 3 * r2], o3 = t4[e3 - 2 * r2], s3 = t4[e3 - r2], c4 = t4[e3 + 0], u4 = t4[e3 + r2], h4 = t4[e3 + 2 * r2], l4 = t4[e3 + 3 * r2];
      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t4[e3 - 4 * r2] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h4] <= i3 && Mn[255 + h4 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;
    }
    function ze(t4, e3, r2, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3) Te(t4, e3 + n3, r2, i3) && De(t4, e3 + n3, r2);
    }
    function He(t4, e3, r2, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3) Te(t4, e3 + n3 * r2, 1, i3) && De(t4, e3 + n3 * r2, 1);
    }
    function We(t4, e3, r2, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3) ze(t4, e3 += 4 * r2, r2, n3);
    }
    function Ve(t4, e3, r2, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3) He(t4, e3 += 4, r2, n3);
    }
    function Ge(t4, e3, r2, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Ue(t4, e3, r2, a3, o3)) if (Re(t4, e3, r2, s3)) De(t4, e3, r2);
        else {
          var c4 = t4, u4 = e3, h4 = r2, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d5 = c4[u4 + 0], p4 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d5 - f4) + jn[1020 + l4 - p4]]) + 63 >> 7, v5 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
          c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v5], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d5 - m4], c4[u4 + h4] = Bn[255 + p4 - v5], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
        }
        e3 += n3;
      }
    }
    function Ye(t4, e3, r2, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Ue(t4, e3, r2, a3, o3)) if (Re(t4, e3, r2, s3)) De(t4, e3, r2);
        else {
          var c4 = t4, u4 = e3, h4 = r2, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d5 = c4[u4 + h4], p4 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
          c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p4], c4[u4 + h4] = Bn[255 + d5 - m4];
        }
        e3 += n3;
      }
    }
    function Je(t4, e3, r2, n3, i3, a3) {
      Ge(t4, e3, r2, 1, 16, n3, i3, a3);
    }
    function Xe(t4, e3, r2, n3, i3, a3) {
      Ge(t4, e3, 1, r2, 16, n3, i3, a3);
    }
    function Ke(t4, e3, r2, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ye(t4, e3 += 4 * r2, r2, 1, 16, n3, i3, a3);
    }
    function Ze(t4, e3, r2, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ye(t4, e3 += 4, 1, r2, 16, n3, i3, a3);
    }
    function $e(t4, e3, r2, n3, i3, a3, o3, s3) {
      Ge(t4, e3, i3, 1, 8, a3, o3, s3), Ge(r2, n3, i3, 1, 8, a3, o3, s3);
    }
    function Qe(t4, e3, r2, n3, i3, a3, o3, s3) {
      Ge(t4, e3, 1, i3, 8, a3, o3, s3), Ge(r2, n3, 1, i3, 8, a3, o3, s3);
    }
    function tr(t4, e3, r2, n3, i3, a3, o3, s3) {
      Ye(t4, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r2, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    function er(t4, e3, r2, n3, i3, a3, o3, s3) {
      Ye(t4, e3 + 4, 1, i3, 8, a3, o3, s3), Ye(r2, n3 + 4, 1, i3, 8, a3, o3, s3);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d4(), this.yc = new l3();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t4, e3, r2, n3, i3, a3, o3) {
      for (t4 = null == t4 ? 0 : t4[e3 + 0], e3 = 0; e3 < o3; ++e3) i3[a3 + e3] = t4 + r2[n3 + e3] & 255, t4 = i3[a3 + e3];
    }
    function ur(t4, e3, r2, n3, i3, a3, o3) {
      var s3;
      if (null == t4) cr(null, null, r2, n3, i3, a3, o3);
      else for (s3 = 0; s3 < o3; ++s3) i3[a3 + s3] = t4[e3 + s3] + r2[n3 + s3] & 255;
    }
    function hr(t4, e3, r2, n3, i3, a3, o3) {
      if (null == t4) cr(null, null, r2, n3, i3, a3, o3);
      else {
        var s3, c4 = t4[e3 + 0], u4 = c4, h4 = c4;
        for (s3 = 0; s3 < o3; ++s3) u4 = h4 + (c4 = t4[e3 + s3]) - u4, h4 = r2[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;
      }
    }
    function lr(t4, r2, i3, o3) {
      var s3 = r2.width, c4 = r2.o;
      if (e(null != t4 && null != r2), 0 > i3 || 0 >= o3 || i3 + o3 > c4) return null;
      if (!t4.Cc) {
        if (null == t4.ga) {
          var u4;
          if (t4.ga = new sr(), (u4 = null == t4.ga) || (u4 = r2.width * r2.o, e(0 == t4.Gb.length), t4.Gb = a2(u4), t4.Uc = 0, null == t4.Gb ? u4 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t4.ga;
            var h4 = t4.Fa, l4 = t4.P, f4 = t4.qc, d5 = t4.mb, p4 = t4.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e(null != h4 && null != d5 && null != r2), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d5, u4.tb = p4, u4.c = r2.width, u4.i = r2.height, e(0 < u4.c && 0 < u4.i), 1 >= f4) r2 = 0;
            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4) r2 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r2.width, b4.height = r2.height, b4.Da = r2.Da, b4.v = r2.v, b4.va = r2.va, b4.j = r2.j, b4.o = r2.o, u4.$a) t: {
              e(1 == u4.$a), r2 = kt2();
              e: for (; ; ) {
                if (null == r2) {
                  r2 = 0;
                  break t;
                }
                if (e(null != u4), u4.mc = r2, r2.c = u4.c, r2.i = u4.i, r2.l = u4.l, r2.l.ma = u4, r2.l.width = u4.c, r2.l.height = u4.i, r2.a = 0, v3(r2.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r2, null)) break e;
                if (1 == r2.ab && 3 == r2.gc[0].hc && At2(r2.s) ? (u4.ic = 1, h4 = r2.c * r2.i, r2.Ta = null, r2.Ua = 0, r2.V = a2(h4), r2.Ba = 0, null == r2.V ? (r2.a = 1, r2 = 0) : r2 = 1) : (u4.ic = 0, r2 = Ft2(r2, u4.c)), !r2) break e;
                r2 = 1;
                break t;
              }
              u4.mc = null, r2 = 0;
            }
            else r2 = m4 >= u4.c * u4.i;
            u4 = !r2;
          }
          if (u4) return null;
          1 != t4.ga.Lc ? t4.Ga = 0 : o3 = c4 - i3;
        }
        e(null != t4.ga), e(i3 + o3 <= c4);
        t: {
          if (r2 = (h4 = t4.ga).c, c4 = h4.l.o, 0 == h4.$a) {
            if (g4 = t4.rc, m4 = t4.Vc, b4 = t4.Fa, l4 = t4.P + 1 + i3 * r2, f4 = t4.mb, d5 = t4.nb + i3 * r2, e(l4 <= t4.P + t4.qc), 0 != h4.Z) for (e(null != mi[h4.Z]), u4 = 0; u4 < o3; ++u4) mi[h4.Z](g4, m4, b4, l4, f4, d5, r2), g4 = f4, m4 = d5, d5 += r2, l4 += r2;
            else for (u4 = 0; u4 < o3; ++u4) n2(f4, d5, b4, l4, r2), g4 = f4, m4 = d5, d5 += r2, l4 += r2;
            t4.rc = g4, t4.Vc = m4;
          } else {
            if (e(null != h4.mc), r2 = i3 + o3, e(null != (u4 = h4.mc)), e(r2 <= u4.i), u4.C >= r2) r2 = 1;
            else if (h4.ic || mr(), h4.ic) {
              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d5 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r2, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
              e(w4 <= N4), e(r2 <= y4), e(At2(p4));
              e: for (; ; ) {
                for (; !d5.h && w4 < L4; ) {
                  if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e(null != _3), S2(d5), 256 > (y4 = bt2(_3.G[0], _3.H[0], d5))) h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4));
                  else {
                    if (!(280 > y4)) {
                      b4 = 0;
                      break e;
                    }
                    y4 = mt2(y4 - 256, d5);
                    var P3, k3 = bt2(_3.G[4], _3.H[4], d5);
                    if (S2(d5), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d5))) && N4 - w4 >= y4)) {
                      b4 = 0;
                      break e;
                    }
                    for (P3 = 0; P3 < y4; ++P3) h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                    for (w4 += y4, f4 += y4; f4 >= m4; ) f4 -= m4, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4);
                    w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                  }
                  e(d5.h == A3(d5));
                }
                St2(u4, l4 > r2 ? r2 : l4);
                break e;
              }
              !b4 || d5.h && w4 < N4 ? (b4 = 0, u4.a = d5.h ? 5 : 3) : u4.$ = w4, r2 = b4;
            } else r2 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r2, Ct2);
            if (!r2) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= c4 && (t4.Cc = 1), o3 = 1;
        }
        if (!o3) return null;
        if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return t4.nb + i3 * s3;
    }
    function fr(t4, e3, r2, n3, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t4, c4 = e3 + (r2 ? 1 : 0), u4 = t4, h4 = e3 + (r2 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h4 + 4 * o3];
          255 != l4 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e3 += a3;
      }
    }
    function dr(t4, e3, r2, n3, i3) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r2; ++a3) {
          var o3 = t4[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t4[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t4[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t4[e3 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e3 += i3;
      }
    }
    function pr(t4, e3, r2, n3, i3, a3, o3, s3) {
      var c4, u4, h4 = 255;
      for (u4 = 0; u4 < i3; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t4[e3 + c4];
          a3[o3 + 4 * c4] = l4, h4 &= l4;
        }
        e3 += r2, o3 += s3;
      }
      return 255 != h4;
    }
    function gr(t4, e3, r2, n3, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3) r2[n3 + a3] = t4[e3 + a3] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r2, n3, i3) {
      t3[r2] = function(t4, r3, a3, o3, s3, c4, u4, h4, l4, f4, d5, p4, g4, m4, v5, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d5[p4 + 0] << 16;
        e(null != t4);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t4[r3 + 0], 255 & x3, x3 >> 16, g4, m4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v5, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d5[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t4[r3 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t4[r3 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a3 && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v5, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v5, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t4[r3 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v5, b4 + (y4 - 1) * i3)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t4) {
      return t4 & ~Fi ? 0 > t4 ? 0 : 255 : t4 >> Ii;
    }
    function wr(t4, e3) {
      return yr((19077 * t4 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t4, e3, r2) {
      return yr((19077 * t4 >> 8) - (6419 * e3 >> 8) - (13320 * r2 >> 8) + 8708);
    }
    function Lr(t4, e3) {
      return yr((19077 * t4 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t4, e3, r2, n3, i3) {
      n3[i3 + 0] = wr(t4, r2), n3[i3 + 1] = Nr(t4, e3, r2), n3[i3 + 2] = Lr(t4, e3);
    }
    function xr(t4, e3, r2, n3, i3) {
      n3[i3 + 0] = Lr(t4, e3), n3[i3 + 1] = Nr(t4, e3, r2), n3[i3 + 2] = wr(t4, r2);
    }
    function Sr(t4, e3, r2, n3, i3) {
      var a3 = Nr(t4, e3, r2);
      e3 = a3 << 3 & 224 | Lr(t4, e3) >> 3, n3[i3 + 0] = 248 & wr(t4, r2) | a3 >> 5, n3[i3 + 1] = e3;
    }
    function _r(t4, e3, r2, n3, i3) {
      var a3 = 240 & Lr(t4, e3) | 15;
      n3[i3 + 0] = 240 & wr(t4, r2) | Nr(t4, e3, r2) >> 4, n3[i3 + 1] = a3;
    }
    function Pr(t4, e3, r2, n3, i3) {
      n3[i3 + 0] = 255, Ar(t4, e3, r2, n3, i3 + 1);
    }
    function kr(t4, e3, r2, n3, i3) {
      xr(t4, e3, r2, n3, i3), n3[i3 + 3] = 255;
    }
    function Ir(t4, e3, r2, n3, i3) {
      Ar(t4, e3, r2, n3, i3), n3[i3 + 3] = 255;
    }
    function Vt2(t4, e3) {
      return 0 > t4 ? 0 : t4 > e3 ? e3 : t4;
    }
    function Fr(e3, r2, n3) {
      t3[e3] = function(t4, e4, i3, a3, o3, s3, c4, u4, h4) {
        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; ) r2(t4[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r2(t4[e4 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h4 && r2(t4[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    function Cr(t4, e3, r2) {
      return 0 == r2 ? 0 == t4 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : r2;
    }
    function jr(t4, e3, r2, n3, i3) {
      switch (t4 >>> 30) {
        case 3:
          on2(e3, r2, n3, i3, 0);
          break;
        case 2:
          sn(e3, r2, n3, i3);
          break;
        case 1:
          un(e3, r2, n3, i3);
      }
    }
    function Or(t4, e3) {
      var r2, a3, o3 = e3.M, s3 = e3.Nb, c4 = t4.oc, u4 = t4.pc + 40, h4 = t4.oc, l4 = t4.pc + 584, f4 = t4.oc, d5 = t4.pc + 600;
      for (r2 = 0; 16 > r2; ++r2) c4[u4 + 32 * r2 - 1] = 129;
      for (r2 = 0; 8 > r2; ++r2) h4[l4 + 32 * r2 - 1] = 129, f4[d5 + 32 * r2 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d5 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d5 - 32 - 1, 127, 9)), a3 = 0; a3 < t4.za; ++a3) {
        var p4 = e3.ya[e3.aa + a3];
        if (0 < a3) {
          for (r2 = -1; 16 > r2; ++r2) n2(c4, u4 + 32 * r2 - 4, c4, u4 + 32 * r2 + 12, 4);
          for (r2 = -1; 8 > r2; ++r2) n2(h4, l4 + 32 * r2 - 4, h4, l4 + 32 * r2 + 4, 4), n2(f4, d5 + 32 * r2 - 4, f4, d5 + 32 * r2 + 4, 4);
        }
        var g4 = t4.Gd, m4 = t4.Hd + a3, v5 = p4.ad, b4 = p4.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d5 - 32, g4[m4].ea, 0, 8)), p4.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t4.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r2 = 0; 4 > r2; r2++) y4[w4 + 128 + r2] = y4[w4 + 256 + r2] = y4[w4 + 384 + r2] = y4[w4 + 0 + r2];
          for (r2 = 0; 16 > r2; ++r2, b4 <<= 2) y4 = c4, w4 = u4 + Di[r2], fi[p4.Ob[r2]](y4, w4), jr(b4, v5, 16 * +r2, y4, w4);
        } else if (y4 = Cr(a3, o3, p4.Ob[0]), li[y4](c4, u4), 0 != b4) for (r2 = 0; 16 > r2; ++r2, b4 <<= 2) jr(b4, v5, 16 * +r2, c4, u4 + Di[r2]);
        for (r2 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di[y4](h4, l4), di[y4](f4, d5), b4 = v5, y4 = h4, w4 = l4, 255 & (p4 = r2 >> 0) && (170 & p4 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p4 = f4, b4 = d5, 255 & (r2 >>= 8) && (170 & r2 ? cn(v5, 320, p4, b4) : hn(v5, 320, p4, b4)), o3 < t4.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d5 + 224, 8)), r2 = 8 * s3 * t4.B, g4 = t4.sa, m4 = t4.ta + 16 * a3 + 16 * s3 * t4.R, v5 = t4.qa, p4 = t4.ra + 8 * a3 + r2, b4 = t4.Ha, y4 = t4.Ia + 8 * a3 + r2, r2 = 0; 16 > r2; ++r2) n2(g4, m4 + r2 * t4.R, c4, u4 + 32 * r2, 16);
        for (r2 = 0; 8 > r2; ++r2) n2(v5, p4 + r2 * t4.B, h4, l4 + 32 * r2, 8), n2(b4, y4 + r2 * t4.B, f4, d5 + 32 * r2, 8);
      }
    }
    function Br(t4, n3, i3, a3, o3, s3, c4, u4, h4) {
      var l4 = [0], f4 = [0], d5 = 0, p4 = null != h4 ? h4.kd : 0, g4 = null != h4 ? h4 : new nr();
      if (null == t4 || 12 > i3) return 7;
      g4.data = t4, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i3, y4 = g4.gb;
        if (e(null != t4), e(null != b4), e(null != y4), y4[0] = 0, 12 <= b4[0] && !r(t4, m4[0], "RIFF")) {
          if (r(t4, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t4, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p4 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (0 != y4) return y4;
      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L4 = t4;
          b4 = n3, y4 = i3;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d5 = [d5])[0] = 0, 8 > y4[0]) y4 = 7;
          else {
            if (!r(L4, b4[0], "VP8X")) {
              if (10 != j2(L4, b4[0] + 4)) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              null != S3 && (S3[0] = _3), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d5 = d5[0], m4 = m4[0], 0 != y4) return y4;
        if (b4 = !!(2 & m4), !w4 && d5) return 3;
        if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u4 && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d5 && b4 && null == h4) {
          y4 = 0;
          break;
        }
        if (4 > i3) {
          y4 = 7;
          break;
        }
        if (w4 && d5 || !w4 && !d5 && !r(t4, n3[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t4, y4 = n3, w4 = i3;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e(null != _3), e(null != w4), L4 = y4[0];
            var I3 = w4[0];
            for (e(null != A4), e(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r(_3, L4, "VP8 ") || !r(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4) break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t: if (k3 = t4, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r(k3, _3, "VP8 "), P3 = !r(k3, _3, "VP8L"), e(null != k3), e(null != w4), e(null != x3), e(null != S3), 8 > w4[0]) y4 = 7;
        else {
          if (L4 || P3) {
            if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
              y4 = 3;
              break t;
            }
            if (p4 && k3 > w4[0] - 8) {
              y4 = 7;
              break t;
            }
            x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
          } else S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
          y4 = 0;
        }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4) break;
        if (4294967286 < g4.Ja) return 3;
        if (null == u4 || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i3) {
            y4 = 7;
            break;
          }
          u4 = c4, p4 = m4, b4 = s3, null == t4 || 5 > i3 ? t4 = 0 : 5 <= i3 && 47 == t4[n3 + 0] && !(t4[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t4, n3, i3), gt2(x3, w4, k3, A4) ? (null != u4 && (u4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t4 = 1) : t4 = 0) : t4 = 0;
        } else {
          if (10 > i3) {
            y4 = 7;
            break;
          }
          u4 = m4, null == t4 || 10 > i3 || !Xt2(t4, n3 + 3, i3 - 3) ? t4 = 0 : (p4 = t4[n3 + 0] | t4[n3 + 1] << 8 | t4[n3 + 2] << 16, b4 = 16383 & (t4[n3 + 7] << 8 | t4[n3 + 6]), t4 = 16383 & (t4[n3 + 9] << 8 | t4[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t4 ? t4 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t4), t4 = 1));
        }
        if (!t4) return 3;
        if (c4 = c4[0], m4 = m4[0], d5 && (l4[0] != c4 || f4[0] != m4)) return 3;
        null != h4 && (h4[0] = g4, h4.offset = n3 - h4.w, e(4294967286 > n3 - h4.w), e(h4.offset == h4.ha - i3));
        break;
      }
      return 0 == y4 || 7 == y4 && d5 && null == h4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
    }
    function Mr(t4, e3, r2) {
      var n3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
      if (e3.Da = null != t4 && 0 < t4.Da, e3.Da && (s3 = t4.cd, c4 = t4.bd, a3 = t4.v, o3 = t4.j, 11 > r2 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3)) return 0;
      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = null != t4 && 0 < t4.da, e3.da) {
        if (!E2(s3, c4, r2 = [t4.ib], a3 = [t4.hb])) return 0;
        e3.ib = r2[0], e3.hb = a3[0];
      }
      return e3.ob = null != t4 && t4.ob, e3.Kb = null == t4 || !t4.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
    }
    function Er(t4) {
      if (null == t4) return 2;
      if (11 > t4.S) {
        var e3 = t4.f.RGBA;
        e3.fb += (t4.height - 1) * e3.A, e3.A = -e3.A;
      } else e3 = t4.f.kb, t4 = t4.height, e3.O += (t4 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t4 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t4 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t4 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t4, e3, r2, n3) {
      if (null == n3 || 0 >= t4 || 0 >= e3) return 2;
      if (null != r2) {
        if (r2.Da) {
          var i3 = r2.cd, o3 = r2.bd, s3 = -2 & r2.v, c4 = -2 & r2.j;
          if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t4 || c4 + o3 > e3) return 2;
          t4 = i3, e3 = o3;
        }
        if (r2.da) {
          if (!E2(t4, e3, i3 = [r2.ib], o3 = [r2.hb])) return 2;
          t4 = i3[0], e3 = o3[0];
        }
      }
      n3.width = t4, n3.height = e3;
      t: {
        var u4 = n3.width, h4 = n3.height;
        if (t4 = n3.S, 0 >= u4 || 0 >= h4 || !(t4 >= En && 13 > t4)) t4 = 2;
        else {
          if (0 >= n3.Rd && null == n3.sd) {
            s3 = o3 = i3 = e3 = 0;
            var l4 = (c4 = u4 * zi[t4]) * h4;
            if (11 > t4 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), 12 == t4 && (s3 = (i3 = u4) * h4)), null == (h4 = a2(l4 + 2 * o3 + s3))) {
              t4 = 1;
              break t;
            }
            n3.sd = h4, 11 > t4 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, 12 == t4 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
          }
          if (e3 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3) if (11 > i3) t4 = n3.f.RGBA, e3 &= (c4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e3 &= c4 >= o3 * zi[i3], e3 &= null != t4.eb;
          else {
            t4 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t4.fa);
            h4 = Math.abs(t4.Ab);
            var f4 = Math.abs(t4.Db), d5 = Math.abs(t4.lb), p4 = d5 * (s3 - 1) + o3;
            e3 &= u4 * (s3 - 1) + o3 <= t4.Fd, e3 &= h4 * (l4 - 1) + c4 <= t4.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t4.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= null != t4.y, e3 &= null != t4.f, e3 &= null != t4.ea, 12 == i3 && (e3 &= d5 >= o3, e3 &= p4 <= t4.Tc, e3 &= null != t4.F);
          }
          else e3 = 0;
          t4 = e3 ? 0 : 2;
        }
      }
      return 0 != t4 || null != r2 && r2.fd && (t4 = Er(n3)), t4;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
      return 4278190080;
    }, t3.Predictor1 = function(t4) {
      return t4;
    }, t3.Predictor2 = function(t4, e3, r2) {
      return e3[r2 + 0];
    }, t3.Predictor3 = function(t4, e3, r2) {
      return e3[r2 + 1];
    }, t3.Predictor4 = function(t4, e3, r2) {
      return e3[r2 - 1];
    }, t3.Predictor5 = function(t4, e3, r2) {
      return U2(U2(t4, e3[r2 + 1]), e3[r2 + 0]);
    }, t3.Predictor6 = function(t4, e3, r2) {
      return U2(t4, e3[r2 - 1]);
    }, t3.Predictor7 = function(t4, e3, r2) {
      return U2(t4, e3[r2 + 0]);
    }, t3.Predictor8 = function(t4, e3, r2) {
      return U2(e3[r2 - 1], e3[r2 + 0]);
    }, t3.Predictor9 = function(t4, e3, r2) {
      return U2(e3[r2 + 0], e3[r2 + 1]);
    }, t3.Predictor10 = function(t4, e3, r2) {
      return U2(U2(t4, e3[r2 - 1]), U2(e3[r2 + 0], e3[r2 + 1]));
    }, t3.Predictor11 = function(t4, e3, r2) {
      var n3 = e3[r2 + 0];
      return 0 >= W2(n3 >> 24 & 255, t4 >> 24 & 255, (e3 = e3[r2 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t4 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t4 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t4, 255 & e3) ? n3 : t4;
    }, t3.Predictor12 = function(t4, e3, r2) {
      var n3 = e3[r2 + 0];
      return (z2((t4 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r2 - 1]) >> 24 & 255)) << 24 | z2((t4 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | z2((t4 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | z2((255 & t4) + (255 & n3) - (255 & e3))) >>> 0;
    }, t3.Predictor13 = function(t4, e3, r2) {
      var n3 = e3[r2 - 1];
      return (H2((t4 = U2(t4, e3[r2 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H2(t4 >> 16 & 255, n3 >> 16 & 255) << 16 | H2(t4 >> 8 & 255, n3 >> 8 & 255) << 8 | H2(t4 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t3.PredictorAdd0;
    t3.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t3.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
      return t4 >> 8 & 255;
    }, function(t4) {
      return t4;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
      return t4;
    }, function(t4) {
      return t4 >> 8 & 255;
    });
    var Gr, Yr = t3.ColorIndexInverseTransform, Jr = t3.MapARGB, Xr = t3.VP8LColorIndexInverseTransformAlpha, Kr = t3.MapAlpha, Zr = t3.VP8LPredictorsAdd = [];
    Zr.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an2, on2, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi2 = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t3.UpsampleRgbLinePair, yi = t3.UpsampleBgrLinePair, wi = t3.UpsampleRgbaLinePair, Ni = t3.UpsampleBgraLinePair, Li = t3.UpsampleArgbLinePair, Ai = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t4, r2, n3, i3, a3) {
      var o3 = qn, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h4 = c4.height, l4 = new st2();
      if (null == l4 || null == t4) var f4 = 2;
      else e(null != l4), f4 = Br(t4, r2, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (0 != f4 ? u4 = 0 : (null != u4 && (u4[0] = l4.width[0]), null != h4 && (h4[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], null != i3 && (i3[0] = c4.width), null != a3 && (a3[0] = c4.height);
        t: {
          if (i3 = new Gt2(), (a3 = new nr()).data = t4, a3.w = r2, a3.ha = n3, a3.kd = 1, r2 = [0], e(null != a3), (0 == (t4 = Br(a3.data, a3.w, a3.ha, null, null, null, r2, null, a3)) || 7 == t4) && r2[0] && (t4 = 4), 0 == (r2 = t4)) {
            if (e(null != s3), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
              if (null == (t4 = kt2())) {
                s3 = 1;
                break t;
              }
              if (function(t5, r3) {
                var n4 = [0], i4 = [0], a4 = [0];
                e: for (; ; ) {
                  if (null == t5) return 0;
                  if (null == r3) return t5.a = 2, 0;
                  if (t5.l = r3, t5.a = 0, v3(t5.m, r3.data, r3.w, r3.ha), !gt2(t5.m, n4, i4, a4)) {
                    t5.a = 3;
                    break e;
                  }
                  if (t5.xb = gi, r3.width = n4[0], r3.height = i4[0], !It2(n4[0], i4[0], 1, t5, null)) break e;
                  return 1;
                }
                return e(0 != t5.a), 0;
              }(t4, i3)) {
                if (i3 = 0 == (r2 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                  e: {
                    i3 = t4;
                    r: for (; ; ) {
                      if (null == i3) {
                        i3 = 0;
                        break e;
                      }
                      if (e(null != i3.s.yc), e(null != i3.s.Ya), e(0 < i3.s.Wb), e(null != (n3 = i3.l)), e(null != (a3 = n3.ma)), 0 != i3.xb) {
                        if (i3.ca = a3.ba, i3.tb = a3.tb, e(null != i3.ca), !Mr(a3.Oa, n3, Rn)) {
                          i3.a = 2;
                          break r;
                        }
                        if (!Ft2(i3, n3.width)) break r;
                        if (n3.da) break r;
                        if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i3.ca.f.kb.F && mr()), i3.Pb && 0 < i3.s.ua && null == i3.s.vb.X && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                          i3.a = 1;
                          break r;
                        }
                        i3.xb = 0;
                      }
                      if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2)) break r;
                      a3.Dc = i3.Ma, i3 = 1;
                      break e;
                    }
                    e(0 != i3.a), i3 = 0;
                  }
                  i3 = !i3;
                }
                i3 && (r2 = t4.a);
              } else r2 = t4.a;
            } else {
              if (null == (t4 = new Yt2())) {
                s3 = 1;
                break t;
              }
              if (t4.Fa = a3.na, t4.P = a3.P, t4.qc = a3.Sa, Kt2(t4, i3)) {
                if (0 == (r2 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                  if (t4.Aa = 0, n3 = s3.Oa, e(null != (a3 = t4)), null != n3) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h4 = l4 = 0; 4 > h4; ++h4) 12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t4, i3) || (r2 = t4.a);
                }
              } else r2 = t4.a;
            }
            0 == r2 && null != s3.Oa && s3.Oa.fd && (r2 = Er(s3.ba));
          }
          s3 = r2;
        }
        o3 = 0 != s3 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else o3 = null;
      return o3;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u2(t3, e3) {
    for (var r2 = "", n3 = 0; n3 < 4; n3++) r2 += String.fromCharCode(t3[e3++]);
    return r2;
  }
  function h2(t3, e3) {
    return (t3[e3 + 0] << 0 | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) >>> 0;
  }
  function l2(t3, e3) {
    return (t3[e3 + 0] << 0 | t3[e3 + 1] << 8 | t3[e3 + 2] << 16 | t3[e3 + 3] << 24) >>> 0;
  }
  new c2();
  var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t2, v2 = function(t3, e3) {
    var r2 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
    if (r2.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t4, e4, r3, n4) {
      for (var i4 = 0; i4 < n4; i4++) if (t4[e4 + i4] != r3.charCodeAt(i4)) return true;
      return false;
    }(t3, e3, "RIFF", 4)) {
      var s3, c3;
      l2(t3, e3 += 4);
      for (e3 += 8; e3 < t3.length; ) {
        var f3 = u2(t3, e3), d4 = l2(t3, e3 += 4);
        e3 += 4;
        var p3 = d4 + (1 & d4);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            void 0 === r2.frames[n3] && (r2.frames[n3] = {});
            (v3 = r2.frames[n3]).src_off = i3 ? o3 : e3 - 8, v3.src_size = a3 + d4 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r2.header = {}).feature_flags = t3[e3];
            var g3 = e3 + 4;
            v3.canvas_width = 1 + h2(t3, g3);
            g3 += 3;
            v3.canvas_height = 1 + h2(t3, g3);
            g3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = p3 + 8, o3 = e3 - 8;
            break;
          case "ANIM":
            (v3 = r2.header).bgcolor = l2(t3, e3);
            g3 = e3 + 4;
            v3.loop_count = (s3 = t3)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r2.frames[n3] = {}).offset_x = 2 * h2(t3, e3), e3 += 3, v3.offset_y = 2 * h2(t3, e3), e3 += 3, v3.width = 1 + h2(t3, e3), e3 += 3, v3.height = 1 + h2(t3, e3), e3 += 3, v3.duration = h2(t3, e3), e3 += 3, m3 = t3[e3++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        "ANMF" != f3 && (e3 += p3);
      }
      return r2;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && 0 != y2[w2].blend; w2++) ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++) p2[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p2, this;
}
!function(t2) {
  var r = function() {
    return "function" == typeof zlibSync;
  }, n2 = function(r2, n3, a3, h3) {
    var l3 = 4, f3 = s2;
    switch (h3) {
      case t2.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t2.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t2.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r2 = i2(r2, n3, a3, f3);
    var d2 = zlibSync(r2, { level: l3 });
    return t2.__addimage__.arrayBufferToBinaryString(d2);
  }, i2 = function(t3, e, r2, n3) {
    for (var i3, a3, o3, s3 = t3.length / e, c3 = new Uint8Array(t3.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
      if (o3 = h3 * e, i3 = t3.subarray(o3, o3 + e), n3) c3.set(n3(i3, r2, a3), o3 + h3);
      else {
        for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1) g2[d2] = u3[d2](i3, r2, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h3);
      }
      a3 = i3;
    }
    return c3;
  }, a2 = function(t3) {
    var e = Array.apply([], t3);
    return e.unshift(0), e;
  }, o2 = function(t3, e) {
    var r2, n3 = [], i3 = t3.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i3; a3 += 1) r2 = t3[a3 - e] || 0, n3[a3 + 1] = t3[a3] - r2 + 256 & 255;
    return n3;
  }, s2 = function(t3, e, r2) {
    var n3, i3 = [], a3 = t3.length;
    i3[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1) n3 = r2 && r2[o3] || 0, i3[o3 + 1] = t3[o3] - n3 + 256 & 255;
    return i3;
  }, c2 = function(t3, e, r2) {
    var n3, i3, a3 = [], o3 = t3.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1) n3 = t3[s3 - e] || 0, i3 = r2 && r2[s3] || 0, a3[s3 + 1] = t3[s3] + 256 - (n3 + i3 >>> 1) & 255;
    return a3;
  }, u2 = function(t3, e, r2) {
    var n3, i3, a3, o3, s3 = [], c3 = t3.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1) n3 = t3[u3 - e] || 0, i3 = r2 && r2[u3] || 0, a3 = r2 && r2[u3 - e] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t3[u3] - o3 + 256 & 255;
    return s3;
  }, h2 = function(t3, e, r2) {
    if (t3 === e && e === r2) return t3;
    var n3 = Math.abs(e - r2), i3 = Math.abs(t3 - r2), a3 = Math.abs(t3 + e - r2 - r2);
    return n3 <= i3 && n3 <= a3 ? t3 : i3 <= a3 ? e : r2;
  }, l2 = function() {
    return [a2, o2, s2, c2, u2];
  }, f2 = function(t3) {
    var e = t3.map(function(t4) {
      return t4.reduce(function(t5, e3) {
        return t5 + Math.abs(e3);
      }, 0);
    });
    return e.indexOf(Math.min.apply(null, e));
  };
  t2.processPNG = function(e, i3, a3, o3) {
    var s3, c3, u3, h3, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e) && (e = new Uint8Array(e)), this.__addimage__.isArrayBufferView(e)) {
      if (e = (u3 = new Kt(e)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, -1 !== [4, 6].indexOf(u3.colorType)) {
        if (8 === u3.bits) {
          g2 = (p2 = 32 == u3.pixelBitlength ? new Uint32Array(u3.decodePixels().buffer) : 16 == u3.pixelBitlength ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p2[w2], x2 = 0; x2 < S2; ) v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (16 === u3.bits) {
          g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; ) y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t2.image_compression.NONE && r() ? (e = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e = v2, d2 = m2, L2 = void 0);
      }
      if (3 === u3.colorType && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2) k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0)) h3 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++) m2[w2] = P2[p2[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e3) {
        var r2;
        switch (e3) {
          case t2.image_compression.FAST:
            r2 = 11;
            break;
          case t2.image_compression.MEDIUM:
            r2 = 13;
            break;
          case t2.image_compression.SLOW:
            r2 = 14;
            break;
          default:
            r2 = 12;
        }
        return r2;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) && (e = this.__addimage__.arrayBufferToBinaryString(e)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e, index: i3, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E.API), function(t2) {
  t2.processGIF89A = function(e, r, n2, i2) {
    var a2 = new Zt(e), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
    return t2.processJPEG.call(this, h2, r, n2, i2);
  }, t2.processGIF87A = t2.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t2);
    for (var e = 0; e < t2; e++) {
      var r = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e] = { red: i2, green: n2, blue: r, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t2 = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[t2]();
  } catch (t3) {
    a.log("bit decode error:" + t3);
  }
}, te.prototype.bit1 = function() {
  var t2, e = Math.ceil(this.width / 8), r = e % 4;
  for (t2 = this.height - 1; t2 >= 0; t2--) {
    for (var n2 = this.bottom_up ? t2 : this.height - 1 - t2, i2 = 0; i2 < e; i2++) for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
      var c2 = this.palette[a2 >> 7 - s2 & 1];
      this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
    }
    0 !== r && (this.pos += 4 - r);
  }
}, te.prototype.bit4 = function() {
  for (var t2 = Math.ceil(this.width / 2), e = t2 % 4, r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i2 = 0; i2 < t2; i2++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width) break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    0 !== e && (this.pos += 4 - e);
  }
}, te.prototype.bit8 = function() {
  for (var t2 = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var r = this.bottom_up ? e : this.height - 1 - e, n2 = 0; n2 < this.width; n2++) {
      var i2 = this.datav.getUint8(this.pos++, true), a2 = r * this.width * 4 + 4 * n2;
      if (i2 < this.palette.length) {
        var o2 = this.palette[i2];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    0 !== t2 && (this.pos += 4 - t2);
  }
}, te.prototype.bit15 = function() {
  for (var t2 = this.width % 3, e = parseInt("11111", 2), r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i2 = 0; i2 < this.width; i2++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e) / e * 255 | 0, s2 = (a2 >> 5 & e) / e * 255 | 0, c2 = (a2 >> 10 & e) / e * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;
      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
    }
    this.pos += t2;
  }
}, te.prototype.bit16 = function() {
  for (var t2 = this.width % 3, e = parseInt("11111", 2), r = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e) / e * 255 | 0, c2 = (o2 >> 5 & r) / r * 255 | 0, u2 = (o2 >> 11) / e * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;
      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
    }
    this.pos += t2;
  }
}, te.prototype.bit24 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--) {
    for (var e = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e * this.width * 4 + 4 * r;
      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--) for (var e = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
    var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e * this.width * 4 + 4 * r;
    this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
  }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processBMP = function(e, r, n2, i2) {
    var a2 = new te(e, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i2);
  };
}(E.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processWEBP = function(e, r, n2, i2) {
    var a2 = new ee(e), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i2);
  };
}(E.API), E.API.processRGBA = function(t2, e, r) {
  for (var n2 = t2.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e, alias: r, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
}, E.API.setLanguage = function(t2) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e, r) {
  var n2, i2, a2 = (r = r || {}).font || this.internal.getFont(), o2 = r.fontSize || this.internal.getFontSize(), s2 = r.charSpace || this.internal.getCharSpace(), c2 = r.widths ? r.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r.kerning ? r.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = false !== r.doKerning, d2 = 0, p2 = e.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p2; n2++) i2 = e.charCodeAt(n2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof(h2[i2]) && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t2, e) {
  var r = (e = e || {}).fontSize || this.internal.getFontSize(), n2 = e.font || this.internal.getFont(), i2 = e.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t2 = Vt.processArabic(t2)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t2, r, i2) / r : Gt.apply(this, arguments).reduce(function(t3, e3) {
    return t3 + e3;
  }, 0);
}, Jt = function(t2, e, r, n2) {
  for (var i2 = [], a2 = 0, o2 = t2.length, s2 = 0; a2 !== o2 && s2 + e[a2] < r; ) s2 += e[a2], a2++;
  i2.push(t2.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; ) s2 + e[a2] > n2 && (i2.push(t2.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e[a2], a2++;
  return c2 !== a2 && i2.push(t2.slice(c2, a2)), i2;
}, Xt = function(t2, e, r) {
  r || (r = {});
  var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r.textIndent || 0, d2 = 0, p2 = 0, g2 = t2.split(" "), m2 = Gt.apply(this, [" ", r])[0];
  if (c2 = -1 === r.lineIndent ? g2[0].length + 2 : r.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t3) {
      (t3 = t3.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t3.map(function(t4, e3) {
        return (e3 && t4.length ? "\n" : "") + t4;
      })) : b2.push(t3[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Gt.apply(this, [n2, r])).reduce(function(t3, e3) {
      return t3 + e3;
    }, 0)) > e || y2) {
      if (p2 > e) {
        for (s2 = Jt.apply(this, [n2, i2, e - (f2 + d2), e]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; ) l2.push([s2.shift()]);
        p2 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t3, e3) {
          return t3 + e3;
        }, 0);
      } else h2 = [n2];
      l2.push(h2), f2 = p2 + c2, d2 = m2;
    } else h2.push(n2), f2 += d2 + p2, d2 = m2;
  }
  return u2 = c2 ? function(t3, e3) {
    return (e3 ? v2 : "") + t3.join(" ");
  } : function(t3) {
    return t3.join(" ");
  }, l2.map(u2);
}, Vt.splitTextToSize = function(t2, e, r) {
  var n2, i2 = (r = r || {}).fontSize || this.internal.getFontSize(), a2 = (function(t3) {
    if (t3.widths && t3.kerning) return { widths: t3.widths, kerning: t3.kerning };
    var e3 = this.internal.getFont(t3.fontName, t3.fontStyle);
    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, r);
  n2 = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e / i2;
  a2.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++) u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e) {
  e.__fontmetrics__ = e.__fontmetrics__ || {};
  for (var r = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r.length; a2++) n2[r[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r[a2];
  var o2 = function(t2) {
    return "0x" + parseInt(t2, 10).toString(16);
  }, s2 = e.__fontmetrics__.compress = function(e3) {
    var r2, n3, a3, c3, u3 = ["{"];
    for (var h3 in e3) {
      if (r2 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), "number" == typeof r2) r2 < 0 ? (a3 = o2(r2).slice(3), c3 = "-") : (a3 = o2(r2).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
      else {
        if ("object" !== _typeof(r2)) throw new Error("Don't know what to do with value type " + _typeof(r2) + ".");
        a3 = s2(r2);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e.__fontmetrics__.uncompress = function(t2) {
    if ("string" != typeof t2) throw new Error("Invalid argument passed to uncompress.");
    for (var e3, r2, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t2.length - 1, d2 = 1; d2 < f2; d2 += 1) "'" == (a3 = t2[d2]) ? e3 ? (i3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : "{" == a3 ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : "}" == a3 ? ((r2 = u3.pop())[0][r2[1]] = c3, i3 = void 0, c3 = r2[0]) : "-" == a3 ? s3 = -1 : void 0 === i3 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e.events.push(["addFont", function(t2) {
    var e3 = t2.font, r2 = l2.Unicode[e3.postScriptName];
    r2 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r2.widths, e3.metadata.Unicode.kerning = r2.kerning);
    var n3 = h2.Unicode[e3.postScriptName];
    n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);
  }]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function(t3) {
    for (var e3 = t3.length, r = new Uint8Array(e3), n2 = 0; n2 < e3; n2++) r[n2] = t3.charCodeAt(n2);
    return r;
  };
  t2.API.events.push(["addFont", function(r) {
    var n2 = void 0, i2 = r.font, a2 = r.instance;
    if (!i2.isStandardFont) {
      if (void 0 === a2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      if ("string" != typeof (n2 = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      !function(r2, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e(n3) : e(u(n3)), r2.metadata = t2.API.TTFFont.open(n3), r2.metadata.Unicode = r2.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r2.metadata.glyIdsUsed = [0];
      }(i2, n2);
    }
  }]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  function e() {
    return (n.canvg ? Promise.resolve(n.canvg) : import("./index.es-B3vejIBQ.js")).catch(function(t3) {
      return Promise.reject(new Error("Could not load canvg: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  E.API.addSvgAsImage = function(t3, r, n2, i2, o2, s2, c2, u2) {
    if (isNaN(r) || isNaN(n2)) throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i2) || isNaN(o2)) throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h2 = document.createElement("canvas");
    h2.width = i2, h2.height = o2;
    var l2 = h2.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e().then(function(e3) {
      return e3.fromString(l2, t3, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t4) {
      return t4.render(f2);
    }).then(function() {
      d2.addImage(h2.toDataURL("image/jpeg", 1), r, n2, i2, o2, c2, u2);
    });
  };
}(), E.API.putTotalPages = function(t2) {
  var e, r = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t2, "g"), r = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), r = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++) for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++) this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e, r);
  return this;
}, E.API.viewerPreferences = function(e, r) {
  var n2;
  e = e || {}, r = r || false;
  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
  function d2(t2, e3) {
    var r2, n3 = false;
    for (r2 = 0; r2 < t2.length; r2 += 1) t2[r2] === e3 && (n3 = true);
    return n3;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, "reset" === e || true === r) {
    var p2 = c2.length;
    for (f2 = 0; f2 < p2; f2 += 1) n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if ("object" === _typeof(e)) {
    for (a2 in e) if (o2 = e[a2], d2(c2, a2) && void 0 !== o2) {
      if ("boolean" === n2[a2].type && "boolean" == typeof o2) n2[a2].value = o2;
      else if ("name" === n2[a2].type && d2(n2[a2].valueSet, o2)) n2[a2].value = o2;
      else if ("integer" === n2[a2].type && Number.isInteger(o2)) n2[a2].value = o2;
      else if ("array" === n2[a2].type) {
        for (h2 = 0; h2 < o2.length; h2 += 1) if (i2 = true, 1 === o2[h2].length && "number" == typeof o2[h2][0]) u2.push(String(o2[h2] - 1));
        else if (o2[h2].length > 1) {
          for (l2 = 0; l2 < o2[h2].length; l2 += 1) "number" != typeof o2[h2][l2] && (i2 = false);
          true === i2 && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
        }
        n2[a2].value = "[" + u2.join(" ") + "]";
      } else n2[a2].value = n2[a2].defaultValue;
      n2[a2].explicitSet = true;
    }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t2, e3 = [];
    for (t2 in n2) true === n2[t2].explicitSet && ("name" === n2[t2].type ? e3.push("/" + t2 + " /" + n2[t2].value) : e3.push("/" + t2 + " " + n2[t2].value));
    0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  var e = function() {
    var t3 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r2 = unescape(encodeURIComponent(t3)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r2.length + n2.length + i2.length + e3.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r2 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, r = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t2.addMetadata = function(t3, n2) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t3, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(E.API), function(t2) {
  var e = t2.API, r = e.pdfEscape16 = function(t3, e3) {
    for (var r2, n3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
      if (r2 = e3.metadata.characterToGlyph(t3.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r2), e3.metadata.toUnicode[r2] = t3.charCodeAt(o2), -1 == n3.indexOf(r2) && (n3.push(r2), n3.push([parseInt(e3.metadata.widthOfGlyph(r2), 10)])), "0" == r2) return a2.join("");
      r2 = r2.toString(16), a2.push(i3[4 - r2.length], r2);
    }
    return a2.join("");
  }, n2 = function(t3) {
    var e3, r2, n3, i3, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r2 = Object.keys(t3).sort(function(t4, e4) {
      return t4 - e4;
    })).length; o2 < s2; o2++) e3 = r2[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t3[e3] && null !== t3[e3] && "function" == typeof t3[e3].toString && (i3 = ("0000" + t3[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n3.push("<" + e3 + "><" + i3 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e.events.push(["putFont", function(e3) {
    !function(e4) {
      var r2 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "Identity-H" === r2.encoding) {
        for (var s2 = r2.metadata.Unicode.widths, c2 = r2.metadata.subset.encode(r2.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++) u2 += String.fromCharCode(c2[h2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
        var d2 = a2();
        i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F(r2.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i3("/Flags " + r2.metadata.flags), i3("/StemV " + r2.metadata.stemV), i3("/ItalicAngle " + r2.metadata.italicAngle), i3("/Ascent " + r2.metadata.ascender), i3("/Descent " + r2.metadata.decender), i3("/CapHeight " + r2.metadata.capHeight), i3(">>"), i3("endobj");
        var p2 = a2();
        i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F(r2.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t2.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r2.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r2.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F(r2.fontName)), i3("/Encoding /" + r2.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), r2.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  e.events.push(["putFont", function(e3) {
    !function(e4) {
      var r2 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === r2.encoding) {
        for (var s2 = r2.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++) c2 += String.fromCharCode(s2[u2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
        var l2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        i3("<<"), i3("/Descent " + r2.metadata.decender), i3("/CapHeight " + r2.metadata.capHeight), i3("/StemV " + r2.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i3("/FontName /" + F(r2.fontName)), i3("/ItalicAngle " + r2.metadata.italicAngle), i3("/Ascent " + r2.metadata.ascender), i3(">>"), i3("endobj"), r2.objectNumber = a2();
        for (var d2 = 0; d2 < r2.metadata.hmtx.widths.length; d2++) r2.metadata.hmtx.widths[d2] = parseInt(r2.metadata.hmtx.widths[d2] * (1e3 / r2.metadata.head.unitsPerEm));
        i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F(r2.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r2.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(r2.metadata.hmtx.widths) + ">>"), i3("endobj"), r2.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  var i2 = function(t3) {
    var e3, n3 = t3.text || "", i3 = t3.x, a2 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h2[l2].encoding;
    if ("Identity-H" !== h2[l2].encoding) return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };
    for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1) h2[l2].metadata.hasOwnProperty("cmap") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e3 || p2[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f2, l2).split("").map(function(t4) {
      return t4.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m2 = r(f2, h2[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
  };
  e.events.push(["postProcessText", function(t3) {
    var e3 = t3.text || "", r2 = [], n3 = { text: e3, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
    if (Array.isArray(e3)) {
      var a2 = 0;
      for (a2 = 0; a2 < e3.length; a2 += 1) Array.isArray(e3[a2]) && 3 === e3[a2].length ? r2.push([i2(Object.assign({}, n3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : r2.push(i2(Object.assign({}, n3, { text: e3[a2] })).text);
      t3.text = r2;
    } else t3.text = i2(Object.assign({}, n3, { text: e3 })).text;
  }]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t2.existsFileInVFS = function(t3) {
    return e.call(this), void 0 !== this.internal.vFS[t3];
  }, t2.addFileToVFS = function(t3, r) {
    return e.call(this), this.internal.vFS[t3] = r, this;
  }, t2.getFileFromVFS = function(t3) {
    return e.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
  };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t2) {
  t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
    var r2, n2, i2, a2, o2, s2, c2, u2 = e, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t4) {
      var e3 = t4.charCodeAt(), r3 = e3 >> 8, n3 = d2[r3];
      return void 0 !== n3 ? u2[256 * n3 + (255 & e3)] : 252 === r3 || 253 === r3 ? "AL" : g2.test(r3) ? "L" : 8 === r3 ? "R" : "N";
    }, y2 = function(t4) {
      for (var e3, r3 = 0; r3 < t4.length; r3++) {
        if ("L" === (e3 = b2(t4.charAt(r3)))) return false;
        if ("R" === e3) return true;
      }
      return false;
    }, w2 = function(t4, e3, o3, s3) {
      var c3, u3, h3, l3, f3 = e3[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e3.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u3 = e3[s3 + 1]) && "AN" !== u3 ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e3.length && "EN" === e3[s3 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && "EN" === o3[s3 - 1]) {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && "ET" === e3[h3]; ) h3++;
          f3 = h3 < l3 && "EN" === e3[h3] ? "EN" : "N";
          break;
        case "NSM":
          if (i2 && !a2) {
            for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && "NSM" === e3[h3]; ) h3++;
            if (h3 < l3) {
              var d4 = t4[s3], p3 = d4 >= 1425 && d4 <= 2303 || 64286 === d4;
              if (c3 = e3[h3], p3 && ("R" === c3 || "AL" === c3)) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || "B" === (c3 = e3[s3 - 1]) ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r2 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, N2 = function(t4, e3, r3) {
      var n3 = t4.split("");
      return r3 && L2(n3, r3, { hiLevel: v2 }), n3.reverse(), e3 && e3.reverse(), n3.join("");
    }, L2 = function(t4, e3, i3) {
      var a3, o3, s3, c3, u3, d4 = -1, p3 = t4.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
      for (m2 = false, r2 = false, n2 = false, o3 = 0; o3 < p3; o3++) L3[o3] = b2(t4[o3]);
      for (s3 = 0; s3 < p3; s3++) {
        if (u3 = g3, y3[s3] = w2(t4, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0) if (16 === a3) {
          for (o3 = d4; o3 < s3; o3++) e3[o3] = 1;
          d4 = -1;
        } else d4 = -1;
        if (N3[g3][6]) -1 === d4 && (d4 = s3);
        else if (d4 > -1) {
          for (o3 = d4; o3 < s3; o3++) e3[o3] = c3;
          d4 = -1;
        }
        "B" === L3[s3] && (e3[s3] = 0), i3.hiLevel |= c3;
      }
      n2 && function(t5, e4, r3) {
        for (var n3 = 0; n3 < r3; n3++) if ("S" === t5[n3]) {
          e4[n3] = v2;
          for (var i4 = n3 - 1; i4 >= 0 && "WS" === t5[i4]; i4--) e4[i4] = v2;
        }
      }(L3, e3, p3);
    }, A2 = function(t4, e3, n3, i3, a3) {
      if (!(a3.hiLevel < t4)) {
        if (1 === t4 && 1 === v2 && !r2) return e3.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {
          if (i3[l3] >= t4) {
            for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t4; ) c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--) o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, x2 = function(t4, e3, r3) {
      var n3 = t4.split(""), i3 = { hiLevel: v2 };
      return r3 || (r3 = []), L2(n3, r3, i3), function(t5, e4, r4) {
        if (0 !== r4.hiLevel && c2) for (var n4, i4 = 0; i4 < t5.length; i4++) 1 === e4[i4] && (n4 = p2.indexOf(t5[i4])) >= 0 && (t5[i4] = p2[n4 + 1]);
      }(n3, r3, i3), A2(2, n3, e3, r3, i3), A2(1, n3, e3, r3, i3), n3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t4, e3, r3) {
      if (function(t5, e4) {
        if (e4) for (var r4 = 0; r4 < t5.length; r4++) e4[r4] = r4;
        void 0 === a2 && (a2 = y2(t5)), void 0 === s2 && (s2 = y2(t5));
      }(t4, e3), i2 || !o2 || s2) if (i2 && o2 && a2 ^ s2) v2 = a2 ? 1 : 0, t4 = N2(t4, e3, r3);
      else if (!i2 && o2 && s2) v2 = a2 ? 1 : 0, t4 = x2(t4, e3, r3), t4 = N2(t4, e3);
      else if (!i2 || a2 || o2 || s2) {
        if (i2 && !o2 && a2 ^ s2) t4 = N2(t4, e3), a2 ? (v2 = 0, t4 = x2(t4, e3, r3)) : (v2 = 1, t4 = x2(t4, e3, r3), t4 = N2(t4, e3));
        else if (i2 && a2 && !o2 && s2) v2 = 1, t4 = x2(t4, e3, r3), t4 = N2(t4, e3);
        else if (!i2 && !o2 && a2 ^ s2) {
          var n3 = c2;
          a2 ? (v2 = 1, t4 = x2(t4, e3, r3), v2 = 0, c2 = false, t4 = x2(t4, e3, r3), c2 = n3) : (v2 = 0, t4 = x2(t4, e3, r3), t4 = N2(t4, e3), v2 = 1, c2 = false, t4 = x2(t4, e3, r3), c2 = n3, t4 = N2(t4, e3));
        }
      } else v2 = 0, t4 = x2(t4, e3, r3);
      else v2 = a2 ? 1 : 0, t4 = x2(t4, e3, r3);
      return t4;
    }, this.__bidiEngine__.setOptions = function(t4) {
      t4 && (i2 = t4.isInputVisual, o2 = t4.isOutputVisual, a2 = t4.isInputRtl, s2 = t4.isOutputRtl, c2 = t4.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r = new t2.__bidiEngine__({ isInputVisual: true });
  t2.API.events.push(["postProcessText", function(t3) {
    var e3 = t3.text, n2 = (t3.x, t3.y, t3.options || {}), i2 = (t3.mutex, n2.lang, []);
    if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e3)) {
      var a2 = 0;
      for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1) "[object Array]" === Object.prototype.toString.call(e3[a2]) ? i2.push([r.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([r.doBidiReorder(e3[a2])]);
      t3.text = i2;
    } else t3.text = r.doBidiReorder(e3);
    r.setOptions({ isInputVisual: true });
  }]);
}(E), E.API.TTFFont = function() {
  function t2(t3) {
    var e;
    if (this.rawData = t3, e = this.contents = new ne(t3), this.contents.pos = 4, "ttcf" === e.readString(4)) throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t2.open = function(e) {
    return new t2(e);
  }, t2.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t2.prototype.registerTTF = function() {
    var t3, e, r, n2, i2;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var e3, r2, n3, i3;
      for (i3 = [], e3 = 0, r2 = (n3 = this.bbox).length; e3 < r2; e3++) t3 = n3[e3], i3.push(Math.round(t3 * this.scaleFactor));
      return i3;
    }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n2 = this.post.italic_angle), 0 != (32768 & (e = n2 >> 16)) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, t2.prototype.characterToGlyph = function(t3) {
    var e;
    return (null != (e = this.cmap.unicode) ? e.codeMap[t3] : void 0) || 0;
  }, t2.prototype.widthOfGlyph = function(t3) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e;
  }, t2.prototype.widthOfString = function(t3, e, r) {
    var n2, i2, a2, o2;
    for (a2 = 0, i2 = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2) n2 = t3.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r * (1e3 / e) || 0;
    return a2 * (e / 1e3);
  }, t2.prototype.lineHeight = function(t3, e) {
    var r;
    return null == e && (e = false), r = e ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t3;
  }, t2;
}();
var re$2, ne = function() {
  function t2(t3) {
    this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
  }
  return t2.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t2.prototype.writeByte = function(t3) {
    return this.data[this.pos++] = t3;
  }, t2.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t2.prototype.writeUInt32 = function(t3) {
    return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt32 = function() {
    var t3;
    return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
  }, t2.prototype.writeInt32 = function(t3) {
    return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
  }, t2.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t2.prototype.writeUInt16 = function(t3) {
    return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt16 = function() {
    var t3;
    return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
  }, t2.prototype.writeInt16 = function(t3) {
    return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
  }, t2.prototype.readString = function(t3) {
    var e, r;
    for (r = [], e = 0; 0 <= t3 ? e < t3 : e > t3; e = 0 <= t3 ? ++e : --e) r[e] = String.fromCharCode(this.readByte());
    return r.join("");
  }, t2.prototype.writeString = function(t3) {
    var e, r, n2;
    for (n2 = [], e = 0, r = t3.length; 0 <= r ? e < r : e > r; e = 0 <= r ? ++e : --e) n2.push(this.writeByte(t3.charCodeAt(e)));
    return n2;
  }, t2.prototype.readShort = function() {
    return this.readInt16();
  }, t2.prototype.writeShort = function(t3) {
    return this.writeInt16(t3);
  }, t2.prototype.readLongLong = function() {
    var t3, e, r, n2, i2, a2, o2, s2;
    return t3 = this.readByte(), e = this.readByte(), r = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e + 1099511627776 * r + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
  }, t2.prototype.writeLongLong = function(t3) {
    var e, r;
    return e = Math.floor(t3 / 4294967296), r = 4294967295 & t3, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, t2.prototype.readInt = function() {
    return this.readInt32();
  }, t2.prototype.writeInt = function(t3) {
    return this.writeInt32(t3);
  }, t2.prototype.read = function(t3) {
    var e, r;
    for (e = [], r = 0; 0 <= t3 ? r < t3 : r > t3; r = 0 <= t3 ? ++r : --r) e.push(this.readByte());
    return e;
  }, t2.prototype.write = function(t3) {
    var e, r, n2, i2;
    for (i2 = [], r = 0, n2 = t3.length; r < n2; r++) e = t3[r], i2.push(this.writeByte(e));
    return i2;
  }, t2;
}(), ie = function() {
  var t2;
  function e(t3) {
    var e3, r, n2;
    for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, r = 0, n2 = this.tableCount; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r) e3 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e3.tag] = e3;
  }
  return e.prototype.encode = function(e3) {
    var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2;
    for (p2 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e3) for (l2 = e3[p2], n2.writeString(p2), n2.writeInt(t2(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), "head" === p2 && (o2 = c2), c2 += l2.length; c2 % 4; ) d2.push(0), c2++;
    return n2.write(d2), r = 2981146554 - t2(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r), n2.data;
  }, t2 = function(t3) {
    var e3, r, n2, i2;
    for (t3 = ve.call(t3); t3.length % 4; ) t3.push(0);
    for (n2 = new ne(t3), r = 0, e3 = 0, i2 = t3.length; e3 < i2; e3 = e3 += 4) r += n2.readUInt32();
    return 4294967295 & r;
  }, e;
}(), ae = {}.hasOwnProperty, oe = function(t2, e) {
  for (var r in e) ae.call(e, r) && (t2[r] = e[r]);
  function n2() {
    this.constructor = t2;
  }
  return n2.prototype = e.prototype, t2.prototype = new n2(), t2.__super__ = e.prototype, t2;
};
re$2 = function() {
  function t2(t3) {
    var e;
    this.file = t3, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  return t2.prototype.parse = function() {
  }, t2.prototype.encode = function() {
  }, t2.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t2;
}();
var se = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "head", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
  }, e.prototype.encode = function(t3) {
    var e3;
    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t3), e3.writeShort(this.glyphDataFormat), e3.data;
  }, e;
}(), ce = function() {
  function t2(t3, e) {
    var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2;
    switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e + t3.readInt(), h2 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t3.readByte();
        break;
      case 4:
        for (f2 = t3.readUInt16(), l2 = f2 / 2, t3.pos += 6, i2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), t3.pos += 2, p2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), c2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), u2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), n2 = (this.length - t3.pos + this.offset) / 2, o2 = function() {
          var e3, r2;
          for (r2 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3) r2.push(t3.readUInt16());
          return r2;
        }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2) for (g2 = i2[s2], r = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r = d2 <= g2 ? ++v2 : --v2) 0 === u2[s2] ? a2 = r + c2[s2] : 0 !== (a2 = o2[u2[s2] / 2 + (r - d2) - (l2 - s2)] || 0) && (a2 += c2[s2]), this.codeMap[r] = 65535 & a2;
    }
    t3.pos = h2;
  }
  return t2.encode = function(t3, e) {
    var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B2, M2, E2, q2, D2, R2, T2, U2, z2, H2, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t3).sort(function(t4, e3) {
      return t4 - e3;
    }), e) {
      case "macroman":
        for (p2 = 0, g2 = function() {
          var t4 = [];
          for (d2 = 0; d2 < 256; ++d2) t4.push(0);
          return t4;
        }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B2 = a2.length; F2 < B2; F2++) null == v2[W2 = t3[n2 = a2[F2]]] && (v2[W2] = ++p2), i2[n2] = { old: t3[n2], new: v2[t3[n2]] }, g2[n2] = v2[t3[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p2 + 1 };
      case "unicode":
        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++) null == v2[w2 = t3[n2 = a2[C2]]] && (v2[w2] = ++b2), r[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h2[d2], 65535 === _2) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r[_2].new) >= 32768) for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2) f2.push(r[n2].new);
          else s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), z2 = 0, q2 = h2.length; z2 < q2; z2++) n2 = h2[z2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++) n2 = P2[H2], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++) o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++) y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, U2 = f2.length; Y2 < U2; Y2++) p2 = f2[Y2], I2.writeUInt16(p2);
        return { charMap: r, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t2;
}(), ue = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "cmap", e.prototype.parse = function(t3) {
    var e3, r, n2;
    for (t3.pos = this.offset, this.version = t3.readUInt16(), n2 = t3.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r) e3 = new ce(t3, this.offset), this.tables.push(e3), e3.isUnicode && null == this.unicode && (this.unicode = e3);
    return true;
  }, e.encode = function(t3, e3) {
    var r, n2;
    return null == e3 && (e3 = "macroman"), r = ce.encode(t3, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r.table = n2.data.concat(r.subtable), r;
  }, e;
}(), he = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "hhea", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
  }, e;
}(), le = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "OS/2", e.prototype.parse = function(t3) {
    if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = function() {
      var e3, r;
      for (r = [], e3 = 0; e3 < 10; ++e3) r.push(t3.readByte());
      return r;
    }(), this.charRange = function() {
      var e3, r;
      for (r = [], e3 = 0; e3 < 4; ++e3) r.push(t3.readInt());
      return r;
    }(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = function() {
      var e3, r;
      for (r = [], e3 = 0; e3 < 2; e3 = ++e3) r.push(t3.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
  }, e;
}(), fe = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "post", e.prototype.parse = function(t3) {
    var e3, r, n2;
    switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i2;
        for (r = t3.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r ? i2 < r : i2 > r; i2 = 0 <= r ? ++i2 : --i2) this.glyphNameIndex.push(t3.readUInt16());
        for (this.names = [], n2 = []; t3.pos < this.offset + this.length; ) e3 = t3.readByte(), n2.push(this.names.push(t3.readString(e3)));
        return n2;
      case 151552:
        return r = t3.readUInt16(), this.offsets = t3.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var e4, r2, n3;
          for (n3 = [], i2 = e4 = 0, r2 = this.file.maxp.numGlyphs; 0 <= r2 ? e4 < r2 : e4 > r2; i2 = 0 <= r2 ? ++e4 : --e4) n3.push(t3.readUInt32());
          return n3;
        }).call(this);
    }
  }, e;
}(), de = function(t2, e) {
  this.raw = t2, this.length = t2.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, pe = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "name", e.prototype.parse = function(t3) {
    var e3, r, n2, i2, a2, o2, s2, c2, u2, h2, l2;
    for (t3.pos = this.offset, t3.readShort(), e3 = t3.readShort(), o2 = t3.readShort(), r = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2) r.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
    for (s2 = {}, i2 = u2 = 0, h2 = r.length; u2 < h2; i2 = ++u2) n2 = r[i2], t3.pos = n2.offset, c2 = t3.readString(n2.length), a2 = new de(c2, n2), null == s2[l2 = n2.nameID] && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t4) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e;
}(), ge = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "maxp", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
  }, e;
}(), me = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "hmtx", e.prototype.parse = function(t3) {
    var e3, r, n2, i2, a2, o2, s2;
    for (t3.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3) this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r2, i3;
      for (i3 = [], e3 = r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; e3 = 0 <= n2 ? ++r2 : --r2) i3.push(t3.readInt16());
      return i3;
    }(), this.widths = (function() {
      var t4, e4, r2, n3;
      for (n3 = [], t4 = 0, e4 = (r2 = this.metrics).length; t4 < e4; t4++) i2 = r2[t4], n3.push(i2.advance);
      return n3;
    }).call(this), r = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2) s2.push(this.widths.push(r));
    return s2;
  }, e.prototype.forGlyph = function(t3) {
    return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
  }, e;
}(), ve = [].slice, be = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t3) {
    var e3, r, n2, i2, a2, o2, s2, c2, u2, h2;
    return t3 in this.cache ? this.cache[t3] : (i2 = this.file.loca, e3 = this.file.contents, r = i2.indexOf(t3), 0 === (n2 = i2.lengthOf(t3)) ? this.cache[t3] = null : (e3.pos = this.offset + r, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t3] = -1 === a2 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t3]));
  }, e.prototype.encode = function(t3, e3, r) {
    var n2, i2, a2, o2, s2;
    for (a2 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++) n2 = t3[e3[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r)));
    return i2.push(a2.length), { table: a2, offsets: i2 };
  }, e;
}(), ye = function() {
  function t2(t3, e, r, n2, i2, a2) {
    this.raw = t3, this.numberOfContours = e, this.xMin = r, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
  }
  return t2.prototype.encode = function() {
    return this.raw.data;
  }, t2;
}(), we = function() {
  function t2(t3, e, r, n2, i2) {
    var a2, o2;
    for (this.raw = t3, this.xMin = e, this.yMin = r, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; ) a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return t2.prototype.encode = function() {
    var t3, e, r;
    for (e = new ne(ve.call(this.raw.data)), t3 = 0, r = this.glyphIDs.length; t3 < r; ++t3) e.pos = this.glyphOffsets[t3];
    return e.data;
  }, t2;
}(), Ne = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re$2), e.prototype.tag = "loca", e.prototype.parse = function(t3) {
    var e3, r;
    return t3.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = 0 === e3 ? (function() {
      var e4, n2;
      for (n2 = [], r = 0, e4 = this.length; r < e4; r += 2) n2.push(2 * t3.readUInt16());
      return n2;
    }).call(this) : (function() {
      var e4, n2;
      for (n2 = [], r = 0, e4 = this.length; r < e4; r += 4) n2.push(t3.readUInt32());
      return n2;
    }).call(this);
  }, e.prototype.indexOf = function(t3) {
    return this.offsets[t3];
  }, e.prototype.lengthOf = function(t3) {
    return this.offsets[t3 + 1] - this.offsets[t3];
  }, e.prototype.encode = function(t3, e3) {
    for (var r = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r.length; ++a2) if (r[a2] = n2, i2 < e3.length && e3[i2] == a2) {
      ++i2, r[a2] = n2;
      var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
      s2 > 0 && (n2 += s2);
    }
    for (var c2 = new Array(4 * r.length), u2 = 0; u2 < r.length; ++u2) c2[4 * u2 + 3] = 255 & r[u2], c2[4 * u2 + 2] = (65280 & r[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r[u2]) >> 16, c2[4 * u2] = (4278190080 & r[u2]) >> 24;
    return c2;
  }, e;
}(), Le = function() {
  function t2(t3) {
    this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t2.prototype.generateCmap = function() {
    var t3, e, r, n2, i2;
    for (e in n2 = this.font.cmap.tables[0].codeMap, t3 = {}, i2 = this.subset) r = i2[e], t3[e] = n2[r];
    return t3;
  }, t2.prototype.glyphsFor = function(t3) {
    var e, r, n2, i2, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t3.length; a2 < o2; a2++) n2[i2 = t3[a2]] = this.font.glyf.glyphFor(i2);
    for (i2 in e = [], n2) (null != (r = n2[i2]) ? r.compound : void 0) && e.push.apply(e, r.glyphIDs);
    if (e.length > 0) for (i2 in s2 = this.glyphsFor(e)) r = s2[i2], n2[i2] = r;
    return n2;
  }, t2.prototype.encode = function(t3, e) {
    var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2;
    for (n2 in r = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t3), f2 = { 0: 0 }, m2 = r.charMap) f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r.maxGlyphID, a2) d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t4) {
      var e3, r2;
      for (e3 in r2 = {}, t4) r2[t4[e3]] = e3;
      return r2;
    }(f2), h2 = Object.keys(u2).sort(function(t4, e3) {
      return t4 - e3;
    }), p2 = function() {
      var t4, e3, r2;
      for (r2 = [], t4 = 0, e3 = h2.length; t4 < e3; t4++) o2 = h2[t4], r2.push(u2[o2]);
      return r2;
    }(), i2 = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t2;
}();
E.API.PDFObject = function() {
  var t2;
  function e() {
  }
  return t2 = function(t3, e3) {
    return (Array(e3 + 1).join("0") + t3).slice(-e3);
  }, e.convert = function(r) {
    var n2, i2, a2, o2;
    if (Array.isArray(r)) return "[" + function() {
      var t3, i3, a3;
      for (a3 = [], t3 = 0, i3 = r.length; t3 < i3; t3++) n2 = r[t3], a3.push(e.convert(n2));
      return a3;
    }().join(" ") + "]";
    if ("string" == typeof r) return "/" + r;
    if (null != r ? r.isString : void 0) return "(" + r + ")";
    if (r instanceof Date) return "(D:" + t2(r.getUTCFullYear(), 4) + t2(r.getUTCMonth(), 2) + t2(r.getUTCDate(), 2) + t2(r.getUTCHours(), 2) + t2(r.getUTCMinutes(), 2) + t2(r.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r)) {
      for (i2 in a2 = ["<<"], r) o2 = r[i2], a2.push("/" + i2 + " " + e.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r;
  }, e;
}();
const jspdf_es_min = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AcroForm: St,
  AcroFormAppearance: At,
  AcroFormButton: mt,
  AcroFormCheckBox: wt,
  AcroFormChoiceField: ft,
  AcroFormComboBox: pt,
  AcroFormEditBox: gt,
  AcroFormListBox: dt,
  AcroFormPasswordField: Lt,
  AcroFormPushButton: vt,
  AcroFormRadioButton: bt,
  AcroFormTextField: Nt,
  GState: j,
  ShadingPattern: B,
  TilingPattern: M,
  default: E,
  jsPDF: E
}, Symbol.toStringTag, { value: "Module" }));
var jspdf_plugin_autotable = { exports: {} };
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(jspdf_es_min);
/*!
 * 
 *               jsPDF AutoTable plugin v3.8.4
 *
 *               Copyright (c) 2024 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable
 *               Licensed under the MIT License.
 *               http://opensource.org/licenses/mit-license
 *
 */
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module2.exports = factory(function webpackLoadOptionalExternalModule() {
      try {
        return require$$0;
      } catch (e) {
      }
    }());
  })(typeof globalThis !== "undefined" ? globalThis : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE__964__) {
    return (
      /******/
      function() {
        var __webpack_modules__ = {
          /***/
          172: (
            /***/
            function(__unused_webpack_module, exports3) {
              var __extends = this && this.__extends || /* @__PURE__ */ function() {
                var extendStatics = function(d2, b2) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
                    d4.__proto__ = b3;
                  } || function(d4, b3) {
                    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
                  };
                  return extendStatics(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.CellHookData = exports3.HookData = void 0;
              var HookData = (
                /** @class */
                /* @__PURE__ */ function() {
                  function HookData2(doc, table, cursor) {
                    this.table = table;
                    this.pageNumber = table.pageNumber;
                    this.pageCount = this.pageNumber;
                    this.settings = table.settings;
                    this.cursor = cursor;
                    this.doc = doc.getDocument();
                  }
                  return HookData2;
                }()
              );
              exports3.HookData = HookData;
              var CellHookData = (
                /** @class */
                function(_super) {
                  __extends(CellHookData2, _super);
                  function CellHookData2(doc, table, cell, row, column, cursor) {
                    var _this = _super.call(this, doc, table, cursor) || this;
                    _this.cell = cell;
                    _this.row = row;
                    _this.column = column;
                    _this.section = row.section;
                    return _this;
                  }
                  return CellHookData2;
                }(HookData)
              );
              exports3.CellHookData = CellHookData;
            }
          ),
          /***/
          340: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              var htmlParser_1 = __webpack_require__2(4);
              var autoTableText_1 = __webpack_require__2(136);
              var documentHandler_1 = __webpack_require__2(744);
              var inputParser_1 = __webpack_require__2(776);
              var tableDrawer_1 = __webpack_require__2(664);
              var tableCalculator_1 = __webpack_require__2(972);
              function default_1(jsPDF) {
                jsPDF.API.autoTable = function() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                  }
                  var options;
                  if (args.length === 1) {
                    options = args[0];
                  } else {
                    console.error("Use of deprecated autoTable initiation");
                    options = args[2] || {};
                    options.columns = args[0];
                    options.body = args[1];
                  }
                  var input = (0, inputParser_1.parseInput)(this, options);
                  var table = (0, tableCalculator_1.createTable)(this, input);
                  (0, tableDrawer_1.drawTable)(this, table);
                  return this;
                };
                jsPDF.API.lastAutoTable = false;
                jsPDF.API.previousAutoTable = false;
                jsPDF.API.autoTable.previous = false;
                jsPDF.API.autoTableText = function(text, x2, y2, styles2) {
                  (0, autoTableText_1.default)(text, x2, y2, styles2, this);
                };
                jsPDF.API.autoTableSetDefaults = function(defaults2) {
                  documentHandler_1.DocHandler.setDefaults(defaults2, this);
                  return this;
                };
                jsPDF.autoTableSetDefaults = function(defaults2, doc) {
                  documentHandler_1.DocHandler.setDefaults(defaults2, doc);
                };
                jsPDF.API.autoTableHtmlToJson = function(tableElem, includeHiddenElements) {
                  var _a3;
                  if (includeHiddenElements === void 0) {
                    includeHiddenElements = false;
                  }
                  if (typeof window === "undefined") {
                    console.error("Cannot run autoTableHtmlToJson in non browser environment");
                    return null;
                  }
                  var doc = new documentHandler_1.DocHandler(this);
                  var _b2 = (0, htmlParser_1.parseHtml)(doc, tableElem, window, includeHiddenElements, false), head = _b2.head, body = _b2.body;
                  var columns = ((_a3 = head[0]) === null || _a3 === void 0 ? void 0 : _a3.map(function(c2) {
                    return c2.content;
                  })) || [];
                  return { columns, rows: body, data: body };
                };
                jsPDF.API.autoTableEndPosY = function() {
                  console.error("Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.");
                  var prev = this.lastAutoTable;
                  if (prev && prev.finalY) {
                    return prev.finalY;
                  } else {
                    return 0;
                  }
                };
                jsPDF.API.autoTableAddPageContent = function(hook) {
                  console.error("Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead.");
                  if (!jsPDF.API.autoTable.globalDefaults) {
                    jsPDF.API.autoTable.globalDefaults = {};
                  }
                  jsPDF.API.autoTable.globalDefaults.addPageContent = hook;
                  return this;
                };
                jsPDF.API.autoTableAddPage = function() {
                  console.error("Use of deprecated function: autoTableAddPage. Use doc.addPage()");
                  this.addPage();
                  return this;
                };
              }
              exports3["default"] = default_1;
            }
          ),
          /***/
          136: (
            /***/
            function(__unused_webpack_module, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              function default_1(text, x2, y2, styles2, doc) {
                styles2 = styles2 || {};
                var PHYSICAL_LINE_HEIGHT = 1.15;
                var k2 = doc.internal.scaleFactor;
                var fontSize = doc.internal.getFontSize() / k2;
                var lineHeightFactor = doc.getLineHeightFactor ? doc.getLineHeightFactor() : PHYSICAL_LINE_HEIGHT;
                var lineHeight = fontSize * lineHeightFactor;
                var splitRegex = /\r\n|\r|\n/g;
                var splitText = "";
                var lineCount = 1;
                if (styles2.valign === "middle" || styles2.valign === "bottom" || styles2.halign === "center" || styles2.halign === "right") {
                  splitText = typeof text === "string" ? text.split(splitRegex) : text;
                  lineCount = splitText.length || 1;
                }
                y2 += fontSize * (2 - PHYSICAL_LINE_HEIGHT);
                if (styles2.valign === "middle")
                  y2 -= lineCount / 2 * lineHeight;
                else if (styles2.valign === "bottom")
                  y2 -= lineCount * lineHeight;
                if (styles2.halign === "center" || styles2.halign === "right") {
                  var alignSize = fontSize;
                  if (styles2.halign === "center")
                    alignSize *= 0.5;
                  if (splitText && lineCount >= 1) {
                    for (var iLine = 0; iLine < splitText.length; iLine++) {
                      doc.text(splitText[iLine], x2 - doc.getStringUnitWidth(splitText[iLine]) * alignSize, y2);
                      y2 += lineHeight;
                    }
                    return doc;
                  }
                  x2 -= doc.getStringUnitWidth(text) * alignSize;
                }
                if (styles2.halign === "justify") {
                  doc.text(text, x2, y2, {
                    maxWidth: styles2.maxWidth || 100,
                    align: "justify"
                  });
                } else {
                  doc.text(text, x2, y2);
                }
                return doc;
              }
              exports3["default"] = default_1;
            }
          ),
          /***/
          420: (
            /***/
            function(__unused_webpack_module, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.getPageAvailableWidth = exports3.parseSpacing = exports3.getFillStyle = exports3.addTableBorder = exports3.getStringWidth = void 0;
              function getStringWidth(text, styles2, doc) {
                doc.applyStyles(styles2, true);
                var textArr = Array.isArray(text) ? text : [text];
                var widestLineWidth = textArr.map(function(text2) {
                  return doc.getTextWidth(text2);
                }).reduce(function(a2, b2) {
                  return Math.max(a2, b2);
                }, 0);
                return widestLineWidth;
              }
              exports3.getStringWidth = getStringWidth;
              function addTableBorder(doc, table, startPos, cursor) {
                var lineWidth = table.settings.tableLineWidth;
                var lineColor = table.settings.tableLineColor;
                doc.applyStyles({ lineWidth, lineColor });
                var fillStyle = getFillStyle(lineWidth, false);
                if (fillStyle) {
                  doc.rect(startPos.x, startPos.y, table.getWidth(doc.pageSize().width), cursor.y - startPos.y, fillStyle);
                }
              }
              exports3.addTableBorder = addTableBorder;
              function getFillStyle(lineWidth, fillColor) {
                var drawLine = lineWidth > 0;
                var drawBackground = fillColor || fillColor === 0;
                if (drawLine && drawBackground) {
                  return "DF";
                } else if (drawLine) {
                  return "S";
                } else if (drawBackground) {
                  return "F";
                } else {
                  return null;
                }
              }
              exports3.getFillStyle = getFillStyle;
              function parseSpacing(value2, defaultValue) {
                var _a3, _b2, _c, _d;
                value2 = value2 || defaultValue;
                if (Array.isArray(value2)) {
                  if (value2.length >= 4) {
                    return {
                      top: value2[0],
                      right: value2[1],
                      bottom: value2[2],
                      left: value2[3]
                    };
                  } else if (value2.length === 3) {
                    return {
                      top: value2[0],
                      right: value2[1],
                      bottom: value2[2],
                      left: value2[1]
                    };
                  } else if (value2.length === 2) {
                    return {
                      top: value2[0],
                      right: value2[1],
                      bottom: value2[0],
                      left: value2[1]
                    };
                  } else if (value2.length === 1) {
                    value2 = value2[0];
                  } else {
                    value2 = defaultValue;
                  }
                }
                if (typeof value2 === "object") {
                  if (typeof value2.vertical === "number") {
                    value2.top = value2.vertical;
                    value2.bottom = value2.vertical;
                  }
                  if (typeof value2.horizontal === "number") {
                    value2.right = value2.horizontal;
                    value2.left = value2.horizontal;
                  }
                  return {
                    left: (_a3 = value2.left) !== null && _a3 !== void 0 ? _a3 : defaultValue,
                    top: (_b2 = value2.top) !== null && _b2 !== void 0 ? _b2 : defaultValue,
                    right: (_c = value2.right) !== null && _c !== void 0 ? _c : defaultValue,
                    bottom: (_d = value2.bottom) !== null && _d !== void 0 ? _d : defaultValue
                  };
                }
                if (typeof value2 !== "number") {
                  value2 = defaultValue;
                }
                return { top: value2, right: value2, bottom: value2, left: value2 };
              }
              exports3.parseSpacing = parseSpacing;
              function getPageAvailableWidth(doc, table) {
                var margins = parseSpacing(table.settings.margin, 0);
                return doc.pageSize().width - (margins.left + margins.right);
              }
              exports3.getPageAvailableWidth = getPageAvailableWidth;
            }
          ),
          /***/
          796: (
            /***/
            function(__unused_webpack_module, exports3) {
              var __extends = this && this.__extends || /* @__PURE__ */ function() {
                var extendStatics = function(d2, b2) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
                    d4.__proto__ = b3;
                  } || function(d4, b3) {
                    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
                  };
                  return extendStatics(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.getTheme = exports3.defaultStyles = exports3.HtmlRowInput = void 0;
              var HtmlRowInput = (
                /** @class */
                function(_super) {
                  __extends(HtmlRowInput2, _super);
                  function HtmlRowInput2(element) {
                    var _this = _super.call(this) || this;
                    _this._element = element;
                    return _this;
                  }
                  return HtmlRowInput2;
                }(Array)
              );
              exports3.HtmlRowInput = HtmlRowInput;
              function defaultStyles(scaleFactor) {
                return {
                  font: "helvetica",
                  // helvetica, times, courier
                  fontStyle: "normal",
                  // normal, bold, italic, bolditalic
                  overflow: "linebreak",
                  // linebreak, ellipsize, visible or hidden
                  fillColor: false,
                  // Either false for transparent, rbg array e.g. [255, 255, 255] or gray level e.g 200
                  textColor: 20,
                  halign: "left",
                  // left, center, right, justify
                  valign: "top",
                  // top, middle, bottom
                  fontSize: 10,
                  cellPadding: 5 / scaleFactor,
                  // number or {top,left,right,left,vertical,horizontal}
                  lineColor: 200,
                  lineWidth: 0,
                  cellWidth: "auto",
                  // 'auto'|'wrap'|number
                  minCellHeight: 0,
                  minCellWidth: 0
                };
              }
              exports3.defaultStyles = defaultStyles;
              function getTheme(name) {
                var themes = {
                  striped: {
                    table: { fillColor: 255, textColor: 80, fontStyle: "normal" },
                    head: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    body: {},
                    foot: { textColor: 255, fillColor: [41, 128, 185], fontStyle: "bold" },
                    alternateRow: { fillColor: 245 }
                  },
                  grid: {
                    table: {
                      fillColor: 255,
                      textColor: 80,
                      fontStyle: "normal",
                      lineWidth: 0.1
                    },
                    head: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    body: {},
                    foot: {
                      textColor: 255,
                      fillColor: [26, 188, 156],
                      fontStyle: "bold",
                      lineWidth: 0
                    },
                    alternateRow: {}
                  },
                  plain: {
                    head: { fontStyle: "bold" },
                    foot: { fontStyle: "bold" }
                  }
                };
                return themes[name];
              }
              exports3.getTheme = getTheme;
            }
          ),
          /***/
          903: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.parseCss = void 0;
              var common_1 = __webpack_require__2(420);
              function parseCss(supportedFonts, element, scaleFactor, style, window2) {
                var result = {};
                var pxScaleFactor = 96 / 72;
                var backgroundColor = parseColor(element, function(elem) {
                  return window2.getComputedStyle(elem)["backgroundColor"];
                });
                if (backgroundColor != null)
                  result.fillColor = backgroundColor;
                var textColor = parseColor(element, function(elem) {
                  return window2.getComputedStyle(elem)["color"];
                });
                if (textColor != null)
                  result.textColor = textColor;
                var padding = parsePadding(style, scaleFactor);
                if (padding)
                  result.cellPadding = padding;
                var borderColorSide = "borderTopColor";
                var finalScaleFactor = pxScaleFactor * scaleFactor;
                var btw = style.borderTopWidth;
                if (style.borderBottomWidth === btw && style.borderRightWidth === btw && style.borderLeftWidth === btw) {
                  var borderWidth = (parseFloat(btw) || 0) / finalScaleFactor;
                  if (borderWidth)
                    result.lineWidth = borderWidth;
                } else {
                  result.lineWidth = {
                    top: (parseFloat(style.borderTopWidth) || 0) / finalScaleFactor,
                    right: (parseFloat(style.borderRightWidth) || 0) / finalScaleFactor,
                    bottom: (parseFloat(style.borderBottomWidth) || 0) / finalScaleFactor,
                    left: (parseFloat(style.borderLeftWidth) || 0) / finalScaleFactor
                  };
                  if (!result.lineWidth.top) {
                    if (result.lineWidth.right) {
                      borderColorSide = "borderRightColor";
                    } else if (result.lineWidth.bottom) {
                      borderColorSide = "borderBottomColor";
                    } else if (result.lineWidth.left) {
                      borderColorSide = "borderLeftColor";
                    }
                  }
                }
                var borderColor = parseColor(element, function(elem) {
                  return window2.getComputedStyle(elem)[borderColorSide];
                });
                if (borderColor != null)
                  result.lineColor = borderColor;
                var accepted = ["left", "right", "center", "justify"];
                if (accepted.indexOf(style.textAlign) !== -1) {
                  result.halign = style.textAlign;
                }
                accepted = ["middle", "bottom", "top"];
                if (accepted.indexOf(style.verticalAlign) !== -1) {
                  result.valign = style.verticalAlign;
                }
                var res = parseInt(style.fontSize || "");
                if (!isNaN(res))
                  result.fontSize = res / pxScaleFactor;
                var fontStyle = parseFontStyle(style);
                if (fontStyle)
                  result.fontStyle = fontStyle;
                var font = (style.fontFamily || "").toLowerCase();
                if (supportedFonts.indexOf(font) !== -1) {
                  result.font = font;
                }
                return result;
              }
              exports3.parseCss = parseCss;
              function parseFontStyle(style) {
                var res = "";
                if (style.fontWeight === "bold" || style.fontWeight === "bolder" || parseInt(style.fontWeight) >= 700) {
                  res = "bold";
                }
                if (style.fontStyle === "italic" || style.fontStyle === "oblique") {
                  res += "italic";
                }
                return res;
              }
              function parseColor(element, styleGetter) {
                var cssColor = realColor(element, styleGetter);
                if (!cssColor)
                  return null;
                var rgba2 = cssColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)$/);
                if (!rgba2 || !Array.isArray(rgba2)) {
                  return null;
                }
                var color2 = [
                  parseInt(rgba2[1]),
                  parseInt(rgba2[2]),
                  parseInt(rgba2[3])
                ];
                var alpha = parseInt(rgba2[4]);
                if (alpha === 0 || isNaN(color2[0]) || isNaN(color2[1]) || isNaN(color2[2])) {
                  return null;
                }
                return color2;
              }
              function realColor(elem, styleGetter) {
                var bg = styleGetter(elem);
                if (bg === "rgba(0, 0, 0, 0)" || bg === "transparent" || bg === "initial" || bg === "inherit") {
                  if (elem.parentElement == null) {
                    return null;
                  }
                  return realColor(elem.parentElement, styleGetter);
                } else {
                  return bg;
                }
              }
              function parsePadding(style, scaleFactor) {
                var val = [
                  style.paddingTop,
                  style.paddingRight,
                  style.paddingBottom,
                  style.paddingLeft
                ];
                var pxScaleFactor = 96 / (72 / scaleFactor);
                var linePadding = (parseInt(style.lineHeight) - parseInt(style.fontSize)) / scaleFactor / 2;
                var inputPadding = val.map(function(n2) {
                  return parseInt(n2 || "0") / pxScaleFactor;
                });
                var padding = (0, common_1.parseSpacing)(inputPadding, 0);
                if (linePadding > padding.top) {
                  padding.top = linePadding;
                }
                if (linePadding > padding.bottom) {
                  padding.bottom = linePadding;
                }
                return padding;
              }
            }
          ),
          /***/
          744: (
            /***/
            function(__unused_webpack_module, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.DocHandler = void 0;
              var globalDefaults = {};
              var DocHandler = (
                /** @class */
                function() {
                  function DocHandler2(jsPDFDocument) {
                    this.jsPDFDocument = jsPDFDocument;
                    this.userStyles = {
                      // Black for versions of jspdf without getTextColor
                      textColor: jsPDFDocument.getTextColor ? this.jsPDFDocument.getTextColor() : 0,
                      fontSize: jsPDFDocument.internal.getFontSize(),
                      fontStyle: jsPDFDocument.internal.getFont().fontStyle,
                      font: jsPDFDocument.internal.getFont().fontName,
                      // 0 for versions of jspdf without getLineWidth
                      lineWidth: jsPDFDocument.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,
                      // Black for versions of jspdf without getDrawColor
                      lineColor: jsPDFDocument.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0
                    };
                  }
                  DocHandler2.setDefaults = function(defaults2, doc) {
                    if (doc === void 0) {
                      doc = null;
                    }
                    if (doc) {
                      doc.__autoTableDocumentDefaults = defaults2;
                    } else {
                      globalDefaults = defaults2;
                    }
                  };
                  DocHandler2.unifyColor = function(c2) {
                    if (Array.isArray(c2)) {
                      return c2;
                    } else if (typeof c2 === "number") {
                      return [c2, c2, c2];
                    } else if (typeof c2 === "string") {
                      return [c2];
                    } else {
                      return null;
                    }
                  };
                  DocHandler2.prototype.applyStyles = function(styles2, fontOnly) {
                    var _a3, _b2, _c;
                    if (fontOnly === void 0) {
                      fontOnly = false;
                    }
                    if (styles2.fontStyle)
                      this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(styles2.fontStyle);
                    var _d = this.jsPDFDocument.internal.getFont(), fontStyle = _d.fontStyle, fontName = _d.fontName;
                    if (styles2.font)
                      fontName = styles2.font;
                    if (styles2.fontStyle) {
                      fontStyle = styles2.fontStyle;
                      var availableFontStyles = this.getFontList()[fontName];
                      if (availableFontStyles && availableFontStyles.indexOf(fontStyle) === -1) {
                        this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(availableFontStyles[0]);
                        fontStyle = availableFontStyles[0];
                      }
                    }
                    this.jsPDFDocument.setFont(fontName, fontStyle);
                    if (styles2.fontSize)
                      this.jsPDFDocument.setFontSize(styles2.fontSize);
                    if (fontOnly) {
                      return;
                    }
                    var color2 = DocHandler2.unifyColor(styles2.fillColor);
                    if (color2)
                      (_a3 = this.jsPDFDocument).setFillColor.apply(_a3, color2);
                    color2 = DocHandler2.unifyColor(styles2.textColor);
                    if (color2)
                      (_b2 = this.jsPDFDocument).setTextColor.apply(_b2, color2);
                    color2 = DocHandler2.unifyColor(styles2.lineColor);
                    if (color2)
                      (_c = this.jsPDFDocument).setDrawColor.apply(_c, color2);
                    if (typeof styles2.lineWidth === "number") {
                      this.jsPDFDocument.setLineWidth(styles2.lineWidth);
                    }
                  };
                  DocHandler2.prototype.splitTextToSize = function(text, size, opts) {
                    return this.jsPDFDocument.splitTextToSize(text, size, opts);
                  };
                  DocHandler2.prototype.rect = function(x2, y2, width, height, fillStyle) {
                    return this.jsPDFDocument.rect(x2, y2, width, height, fillStyle);
                  };
                  DocHandler2.prototype.getLastAutoTable = function() {
                    return this.jsPDFDocument.lastAutoTable || null;
                  };
                  DocHandler2.prototype.getTextWidth = function(text) {
                    return this.jsPDFDocument.getTextWidth(text);
                  };
                  DocHandler2.prototype.getDocument = function() {
                    return this.jsPDFDocument;
                  };
                  DocHandler2.prototype.setPage = function(page) {
                    this.jsPDFDocument.setPage(page);
                  };
                  DocHandler2.prototype.addPage = function() {
                    return this.jsPDFDocument.addPage();
                  };
                  DocHandler2.prototype.getFontList = function() {
                    return this.jsPDFDocument.getFontList();
                  };
                  DocHandler2.prototype.getGlobalOptions = function() {
                    return globalDefaults || {};
                  };
                  DocHandler2.prototype.getDocumentOptions = function() {
                    return this.jsPDFDocument.__autoTableDocumentDefaults || {};
                  };
                  DocHandler2.prototype.pageSize = function() {
                    var pageSize = this.jsPDFDocument.internal.pageSize;
                    if (pageSize.width == null) {
                      pageSize = {
                        width: pageSize.getWidth(),
                        height: pageSize.getHeight()
                      };
                    }
                    return pageSize;
                  };
                  DocHandler2.prototype.scaleFactor = function() {
                    return this.jsPDFDocument.internal.scaleFactor;
                  };
                  DocHandler2.prototype.getLineHeightFactor = function() {
                    var doc = this.jsPDFDocument;
                    return doc.getLineHeightFactor ? doc.getLineHeightFactor() : 1.15;
                  };
                  DocHandler2.prototype.getLineHeight = function(fontSize) {
                    return fontSize / this.scaleFactor() * this.getLineHeightFactor();
                  };
                  DocHandler2.prototype.pageNumber = function() {
                    var pageInfo = this.jsPDFDocument.internal.getCurrentPageInfo();
                    if (!pageInfo) {
                      return this.jsPDFDocument.internal.getNumberOfPages();
                    }
                    return pageInfo.pageNumber;
                  };
                  return DocHandler2;
                }()
              );
              exports3.DocHandler = DocHandler;
            }
          ),
          /***/
          4: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.parseHtml = void 0;
              var cssParser_1 = __webpack_require__2(903);
              var config_1 = __webpack_require__2(796);
              function parseHtml(doc, input, window2, includeHiddenHtml, useCss) {
                var _a3, _b2;
                if (includeHiddenHtml === void 0) {
                  includeHiddenHtml = false;
                }
                if (useCss === void 0) {
                  useCss = false;
                }
                var tableElement;
                if (typeof input === "string") {
                  tableElement = window2.document.querySelector(input);
                } else {
                  tableElement = input;
                }
                var supportedFonts = Object.keys(doc.getFontList());
                var scaleFactor = doc.scaleFactor();
                var head = [], body = [], foot = [];
                if (!tableElement) {
                  console.error("Html table could not be found with input: ", input);
                  return { head, body, foot };
                }
                for (var i2 = 0; i2 < tableElement.rows.length; i2++) {
                  var element = tableElement.rows[i2];
                  var tagName = (_b2 = (_a3 = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a3 === void 0 ? void 0 : _a3.tagName) === null || _b2 === void 0 ? void 0 : _b2.toLowerCase();
                  var row = parseRowContent(supportedFonts, scaleFactor, window2, element, includeHiddenHtml, useCss);
                  if (!row)
                    continue;
                  if (tagName === "thead") {
                    head.push(row);
                  } else if (tagName === "tfoot") {
                    foot.push(row);
                  } else {
                    body.push(row);
                  }
                }
                return { head, body, foot };
              }
              exports3.parseHtml = parseHtml;
              function parseRowContent(supportedFonts, scaleFactor, window2, row, includeHidden, useCss) {
                var resultRow = new config_1.HtmlRowInput(row);
                for (var i2 = 0; i2 < row.cells.length; i2++) {
                  var cell = row.cells[i2];
                  var style_1 = window2.getComputedStyle(cell);
                  if (includeHidden || style_1.display !== "none") {
                    var cellStyles = void 0;
                    if (useCss) {
                      cellStyles = (0, cssParser_1.parseCss)(supportedFonts, cell, scaleFactor, style_1, window2);
                    }
                    resultRow.push({
                      rowSpan: cell.rowSpan,
                      colSpan: cell.colSpan,
                      styles: cellStyles,
                      _element: cell,
                      content: parseCellContent(cell)
                    });
                  }
                }
                var style = window2.getComputedStyle(row);
                if (resultRow.length > 0 && (includeHidden || style.display !== "none")) {
                  return resultRow;
                }
              }
              function parseCellContent(orgCell) {
                var cell = orgCell.cloneNode(true);
                cell.innerHTML = cell.innerHTML.replace(/\n/g, "").replace(/ +/g, " ");
                cell.innerHTML = cell.innerHTML.split(/<br.*?>/).map(function(part) {
                  return part.trim();
                }).join("\n");
                return cell.innerText || cell.textContent || "";
              }
            }
          ),
          /***/
          776: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.parseInput = void 0;
              var htmlParser_1 = __webpack_require__2(4);
              var polyfills_1 = __webpack_require__2(356);
              var common_1 = __webpack_require__2(420);
              var documentHandler_1 = __webpack_require__2(744);
              var inputValidator_1 = __webpack_require__2(792);
              function parseInput(d2, current) {
                var doc = new documentHandler_1.DocHandler(d2);
                var document2 = doc.getDocumentOptions();
                var global2 = doc.getGlobalOptions();
                (0, inputValidator_1.default)(doc, global2, document2, current);
                var options = (0, polyfills_1.assign)({}, global2, document2, current);
                var win;
                if (typeof window !== "undefined") {
                  win = window;
                }
                var styles2 = parseStyles(global2, document2, current);
                var hooks = parseHooks(global2, document2, current);
                var settings = parseSettings(doc, options);
                var content = parseContent(doc, options, win);
                return {
                  id: current.tableId,
                  content,
                  hooks,
                  styles: styles2,
                  settings
                };
              }
              exports3.parseInput = parseInput;
              function parseStyles(gInput, dInput, cInput) {
                var styleOptions = {
                  styles: {},
                  headStyles: {},
                  bodyStyles: {},
                  footStyles: {},
                  alternateRowStyles: {},
                  columnStyles: {}
                };
                var _loop_1 = function(prop2) {
                  if (prop2 === "columnStyles") {
                    var global_1 = gInput[prop2];
                    var document_1 = dInput[prop2];
                    var current = cInput[prop2];
                    styleOptions.columnStyles = (0, polyfills_1.assign)({}, global_1, document_1, current);
                  } else {
                    var allOptions = [gInput, dInput, cInput];
                    var styles2 = allOptions.map(function(opts) {
                      return opts[prop2] || {};
                    });
                    styleOptions[prop2] = (0, polyfills_1.assign)({}, styles2[0], styles2[1], styles2[2]);
                  }
                };
                for (var _i = 0, _a3 = Object.keys(styleOptions); _i < _a3.length; _i++) {
                  var prop = _a3[_i];
                  _loop_1(prop);
                }
                return styleOptions;
              }
              function parseHooks(global2, document2, current) {
                var allOptions = [global2, document2, current];
                var result = {
                  didParseCell: [],
                  willDrawCell: [],
                  didDrawCell: [],
                  willDrawPage: [],
                  didDrawPage: []
                };
                for (var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++) {
                  var options = allOptions_1[_i];
                  if (options.didParseCell)
                    result.didParseCell.push(options.didParseCell);
                  if (options.willDrawCell)
                    result.willDrawCell.push(options.willDrawCell);
                  if (options.didDrawCell)
                    result.didDrawCell.push(options.didDrawCell);
                  if (options.willDrawPage)
                    result.willDrawPage.push(options.willDrawPage);
                  if (options.didDrawPage)
                    result.didDrawPage.push(options.didDrawPage);
                }
                return result;
              }
              function parseSettings(doc, options) {
                var _a3, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                var margin2 = (0, common_1.parseSpacing)(options.margin, 40 / doc.scaleFactor());
                var startY = (_a3 = getStartY(doc, options.startY)) !== null && _a3 !== void 0 ? _a3 : margin2.top;
                var showFoot;
                if (options.showFoot === true) {
                  showFoot = "everyPage";
                } else if (options.showFoot === false) {
                  showFoot = "never";
                } else {
                  showFoot = (_b2 = options.showFoot) !== null && _b2 !== void 0 ? _b2 : "everyPage";
                }
                var showHead;
                if (options.showHead === true) {
                  showHead = "everyPage";
                } else if (options.showHead === false) {
                  showHead = "never";
                } else {
                  showHead = (_c = options.showHead) !== null && _c !== void 0 ? _c : "everyPage";
                }
                var useCss = (_d = options.useCss) !== null && _d !== void 0 ? _d : false;
                var theme = options.theme || (useCss ? "plain" : "striped");
                var horizontalPageBreak = !!options.horizontalPageBreak;
                var horizontalPageBreakRepeat = (_e = options.horizontalPageBreakRepeat) !== null && _e !== void 0 ? _e : null;
                return {
                  includeHiddenHtml: (_f = options.includeHiddenHtml) !== null && _f !== void 0 ? _f : false,
                  useCss,
                  theme,
                  startY,
                  margin: margin2,
                  pageBreak: (_g = options.pageBreak) !== null && _g !== void 0 ? _g : "auto",
                  rowPageBreak: (_h = options.rowPageBreak) !== null && _h !== void 0 ? _h : "auto",
                  tableWidth: (_j = options.tableWidth) !== null && _j !== void 0 ? _j : "auto",
                  showHead,
                  showFoot,
                  tableLineWidth: (_k = options.tableLineWidth) !== null && _k !== void 0 ? _k : 0,
                  tableLineColor: (_l = options.tableLineColor) !== null && _l !== void 0 ? _l : 200,
                  horizontalPageBreak,
                  horizontalPageBreakRepeat,
                  horizontalPageBreakBehaviour: (_m = options.horizontalPageBreakBehaviour) !== null && _m !== void 0 ? _m : "afterAllRows"
                };
              }
              function getStartY(doc, userStartY) {
                var previous = doc.getLastAutoTable();
                var sf = doc.scaleFactor();
                var currentPage = doc.pageNumber();
                var isSamePageAsPreviousTable = false;
                if (previous && previous.startPageNumber) {
                  var endingPage = previous.startPageNumber + previous.pageNumber - 1;
                  isSamePageAsPreviousTable = endingPage === currentPage;
                }
                if (typeof userStartY === "number") {
                  return userStartY;
                } else if (userStartY == null || userStartY === false) {
                  if (isSamePageAsPreviousTable && (previous === null || previous === void 0 ? void 0 : previous.finalY) != null) {
                    return previous.finalY + 20 / sf;
                  }
                }
                return null;
              }
              function parseContent(doc, options, window2) {
                var head = options.head || [];
                var body = options.body || [];
                var foot = options.foot || [];
                if (options.html) {
                  var hidden = options.includeHiddenHtml;
                  if (window2) {
                    var htmlContent = (0, htmlParser_1.parseHtml)(doc, options.html, window2, hidden, options.useCss) || {};
                    head = htmlContent.head || head;
                    body = htmlContent.body || head;
                    foot = htmlContent.foot || head;
                  } else {
                    console.error("Cannot parse html in non browser environment");
                  }
                }
                var columns = options.columns || parseColumns(head, body, foot);
                return {
                  columns,
                  head,
                  body,
                  foot
                };
              }
              function parseColumns(head, body, foot) {
                var firstRow = head[0] || body[0] || foot[0] || [];
                var result = [];
                Object.keys(firstRow).filter(function(key) {
                  return key !== "_element";
                }).forEach(function(key) {
                  var colSpan = 1;
                  var input;
                  if (Array.isArray(firstRow)) {
                    input = firstRow[parseInt(key)];
                  } else {
                    input = firstRow[key];
                  }
                  if (typeof input === "object" && !Array.isArray(input)) {
                    colSpan = (input === null || input === void 0 ? void 0 : input.colSpan) || 1;
                  }
                  for (var i2 = 0; i2 < colSpan; i2++) {
                    var id = void 0;
                    if (Array.isArray(firstRow)) {
                      id = result.length;
                    } else {
                      id = key + (i2 > 0 ? "_".concat(i2) : "");
                    }
                    var rowResult = { dataKey: id };
                    result.push(rowResult);
                  }
                });
                return result;
              }
            }
          ),
          /***/
          792: (
            /***/
            function(__unused_webpack_module, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              function default_1(doc, global2, document2, current) {
                var _loop_1 = function(options2) {
                  if (options2 && typeof options2 !== "object") {
                    console.error("The options parameter should be of type object, is: " + typeof options2);
                  }
                  if (typeof options2.extendWidth !== "undefined") {
                    options2.tableWidth = options2.extendWidth ? "auto" : "wrap";
                    console.error("Use of deprecated option: extendWidth, use tableWidth instead.");
                  }
                  if (typeof options2.margins !== "undefined") {
                    if (typeof options2.margin === "undefined")
                      options2.margin = options2.margins;
                    console.error("Use of deprecated option: margins, use margin instead.");
                  }
                  if (options2.startY && typeof options2.startY !== "number") {
                    console.error("Invalid value for startY option", options2.startY);
                    delete options2.startY;
                  }
                  if (!options2.didDrawPage && (options2.afterPageContent || options2.beforePageContent || options2.afterPageAdd)) {
                    console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead");
                    options2.didDrawPage = function(data) {
                      doc.applyStyles(doc.userStyles);
                      if (options2.beforePageContent)
                        options2.beforePageContent(data);
                      doc.applyStyles(doc.userStyles);
                      if (options2.afterPageContent)
                        options2.afterPageContent(data);
                      doc.applyStyles(doc.userStyles);
                      if (options2.afterPageAdd && data.pageNumber > 1) {
                        data.afterPageAdd(data);
                      }
                      doc.applyStyles(doc.userStyles);
                    };
                  }
                  [
                    "createdHeaderCell",
                    "drawHeaderRow",
                    "drawRow",
                    "drawHeaderCell"
                  ].forEach(function(name) {
                    if (options2[name]) {
                      console.error('The "'.concat(name, '" hook has changed in version 3.0, check the changelog for how to migrate.'));
                    }
                  });
                  [
                    ["showFoot", "showFooter"],
                    ["showHead", "showHeader"],
                    ["didDrawPage", "addPageContent"],
                    ["didParseCell", "createdCell"],
                    ["headStyles", "headerStyles"]
                  ].forEach(function(_a4) {
                    var current2 = _a4[0], deprecated = _a4[1];
                    if (options2[deprecated]) {
                      console.error("Use of deprecated option ".concat(deprecated, ". Use ").concat(current2, " instead"));
                      options2[current2] = options2[deprecated];
                    }
                  });
                  [
                    ["padding", "cellPadding"],
                    ["lineHeight", "rowHeight"],
                    "fontSize",
                    "overflow"
                  ].forEach(function(o2) {
                    var deprecatedOption = typeof o2 === "string" ? o2 : o2[0];
                    var style = typeof o2 === "string" ? o2 : o2[1];
                    if (typeof options2[deprecatedOption] !== "undefined") {
                      if (typeof options2.styles[style] === "undefined") {
                        options2.styles[style] = options2[deprecatedOption];
                      }
                      console.error("Use of deprecated option: " + deprecatedOption + ", use the style " + style + " instead.");
                    }
                  });
                  for (var _b2 = 0, _c = [
                    "styles",
                    "bodyStyles",
                    "headStyles",
                    "footStyles"
                  ]; _b2 < _c.length; _b2++) {
                    var styleProp = _c[_b2];
                    checkStyles(options2[styleProp] || {});
                  }
                  var columnStyles = options2["columnStyles"] || {};
                  for (var _d = 0, _e = Object.keys(columnStyles); _d < _e.length; _d++) {
                    var key = _e[_d];
                    checkStyles(columnStyles[key] || {});
                  }
                };
                for (var _i = 0, _a3 = [global2, document2, current]; _i < _a3.length; _i++) {
                  var options = _a3[_i];
                  _loop_1(options);
                }
              }
              exports3["default"] = default_1;
              function checkStyles(styles2) {
                if (styles2.rowHeight) {
                  console.error("Use of deprecated style rowHeight. It is renamed to minCellHeight.");
                  if (!styles2.minCellHeight) {
                    styles2.minCellHeight = styles2.rowHeight;
                  }
                } else if (styles2.columnWidth) {
                  console.error("Use of deprecated style columnWidth. It is renamed to cellWidth.");
                  if (!styles2.cellWidth) {
                    styles2.cellWidth = styles2.columnWidth;
                  }
                }
              }
            }
          ),
          /***/
          260: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.Column = exports3.Cell = exports3.Row = exports3.Table = void 0;
              var config_1 = __webpack_require__2(796);
              var HookData_1 = __webpack_require__2(172);
              var common_1 = __webpack_require__2(420);
              var Table = (
                /** @class */
                function() {
                  function Table2(input, content) {
                    this.pageNumber = 1;
                    this.pageCount = 1;
                    this.id = input.id;
                    this.settings = input.settings;
                    this.styles = input.styles;
                    this.hooks = input.hooks;
                    this.columns = content.columns;
                    this.head = content.head;
                    this.body = content.body;
                    this.foot = content.foot;
                  }
                  Table2.prototype.getHeadHeight = function(columns) {
                    return this.head.reduce(function(acc, row) {
                      return acc + row.getMaxCellHeight(columns);
                    }, 0);
                  };
                  Table2.prototype.getFootHeight = function(columns) {
                    return this.foot.reduce(function(acc, row) {
                      return acc + row.getMaxCellHeight(columns);
                    }, 0);
                  };
                  Table2.prototype.allRows = function() {
                    return this.head.concat(this.body).concat(this.foot);
                  };
                  Table2.prototype.callCellHooks = function(doc, handlers2, cell, row, column, cursor) {
                    for (var _i = 0, handlers_1 = handlers2; _i < handlers_1.length; _i++) {
                      var handler = handlers_1[_i];
                      var data = new HookData_1.CellHookData(doc, this, cell, row, column, cursor);
                      var result = handler(data) === false;
                      cell.text = Array.isArray(cell.text) ? cell.text : [cell.text];
                      if (result) {
                        return false;
                      }
                    }
                    return true;
                  };
                  Table2.prototype.callEndPageHooks = function(doc, cursor) {
                    doc.applyStyles(doc.userStyles);
                    for (var _i = 0, _a3 = this.hooks.didDrawPage; _i < _a3.length; _i++) {
                      var handler = _a3[_i];
                      handler(new HookData_1.HookData(doc, this, cursor));
                    }
                  };
                  Table2.prototype.callWillDrawPageHooks = function(doc, cursor) {
                    for (var _i = 0, _a3 = this.hooks.willDrawPage; _i < _a3.length; _i++) {
                      var handler = _a3[_i];
                      handler(new HookData_1.HookData(doc, this, cursor));
                    }
                  };
                  Table2.prototype.getWidth = function(pageWidth) {
                    if (typeof this.settings.tableWidth === "number") {
                      return this.settings.tableWidth;
                    } else if (this.settings.tableWidth === "wrap") {
                      var wrappedWidth = this.columns.reduce(function(total, col) {
                        return total + col.wrappedWidth;
                      }, 0);
                      return wrappedWidth;
                    } else {
                      var margin2 = this.settings.margin;
                      return pageWidth - margin2.left - margin2.right;
                    }
                  };
                  return Table2;
                }()
              );
              exports3.Table = Table;
              var Row = (
                /** @class */
                function() {
                  function Row2(raw, index, section, cells, spansMultiplePages) {
                    if (spansMultiplePages === void 0) {
                      spansMultiplePages = false;
                    }
                    this.height = 0;
                    this.raw = raw;
                    if (raw instanceof config_1.HtmlRowInput) {
                      this.raw = raw._element;
                      this.element = raw._element;
                    }
                    this.index = index;
                    this.section = section;
                    this.cells = cells;
                    this.spansMultiplePages = spansMultiplePages;
                  }
                  Row2.prototype.getMaxCellHeight = function(columns) {
                    var _this = this;
                    return columns.reduce(function(acc, column) {
                      var _a3;
                      return Math.max(acc, ((_a3 = _this.cells[column.index]) === null || _a3 === void 0 ? void 0 : _a3.height) || 0);
                    }, 0);
                  };
                  Row2.prototype.hasRowSpan = function(columns) {
                    var _this = this;
                    return columns.filter(function(column) {
                      var cell = _this.cells[column.index];
                      if (!cell)
                        return false;
                      return cell.rowSpan > 1;
                    }).length > 0;
                  };
                  Row2.prototype.canEntireRowFit = function(height, columns) {
                    return this.getMaxCellHeight(columns) <= height;
                  };
                  Row2.prototype.getMinimumRowHeight = function(columns, doc) {
                    var _this = this;
                    return columns.reduce(function(acc, column) {
                      var cell = _this.cells[column.index];
                      if (!cell)
                        return 0;
                      var lineHeight = doc.getLineHeight(cell.styles.fontSize);
                      var vPadding = cell.padding("vertical");
                      var oneRowHeight = vPadding + lineHeight;
                      return oneRowHeight > acc ? oneRowHeight : acc;
                    }, 0);
                  };
                  return Row2;
                }()
              );
              exports3.Row = Row;
              var Cell = (
                /** @class */
                function() {
                  function Cell2(raw, styles2, section) {
                    var _a3, _b2;
                    this.contentHeight = 0;
                    this.contentWidth = 0;
                    this.wrappedWidth = 0;
                    this.minReadableWidth = 0;
                    this.minWidth = 0;
                    this.width = 0;
                    this.height = 0;
                    this.x = 0;
                    this.y = 0;
                    this.styles = styles2;
                    this.section = section;
                    this.raw = raw;
                    var content = raw;
                    if (raw != null && typeof raw === "object" && !Array.isArray(raw)) {
                      this.rowSpan = raw.rowSpan || 1;
                      this.colSpan = raw.colSpan || 1;
                      content = (_b2 = (_a3 = raw.content) !== null && _a3 !== void 0 ? _a3 : raw.title) !== null && _b2 !== void 0 ? _b2 : raw;
                      if (raw._element) {
                        this.raw = raw._element;
                      }
                    } else {
                      this.rowSpan = 1;
                      this.colSpan = 1;
                    }
                    var text = content != null ? "" + content : "";
                    var splitRegex = /\r\n|\r|\n/g;
                    this.text = text.split(splitRegex);
                  }
                  Cell2.prototype.getTextPos = function() {
                    var y2;
                    if (this.styles.valign === "top") {
                      y2 = this.y + this.padding("top");
                    } else if (this.styles.valign === "bottom") {
                      y2 = this.y + this.height - this.padding("bottom");
                    } else {
                      var netHeight = this.height - this.padding("vertical");
                      y2 = this.y + netHeight / 2 + this.padding("top");
                    }
                    var x2;
                    if (this.styles.halign === "right") {
                      x2 = this.x + this.width - this.padding("right");
                    } else if (this.styles.halign === "center") {
                      var netWidth = this.width - this.padding("horizontal");
                      x2 = this.x + netWidth / 2 + this.padding("left");
                    } else {
                      x2 = this.x + this.padding("left");
                    }
                    return { x: x2, y: y2 };
                  };
                  Cell2.prototype.getContentHeight = function(scaleFactor, lineHeightFactor) {
                    if (lineHeightFactor === void 0) {
                      lineHeightFactor = 1.15;
                    }
                    var lineCount = Array.isArray(this.text) ? this.text.length : 1;
                    var lineHeight = this.styles.fontSize / scaleFactor * lineHeightFactor;
                    var height = lineCount * lineHeight + this.padding("vertical");
                    return Math.max(height, this.styles.minCellHeight);
                  };
                  Cell2.prototype.padding = function(name) {
                    var padding = (0, common_1.parseSpacing)(this.styles.cellPadding, 0);
                    if (name === "vertical") {
                      return padding.top + padding.bottom;
                    } else if (name === "horizontal") {
                      return padding.left + padding.right;
                    } else {
                      return padding[name];
                    }
                  };
                  return Cell2;
                }()
              );
              exports3.Cell = Cell;
              var Column = (
                /** @class */
                function() {
                  function Column2(dataKey, raw, index) {
                    this.wrappedWidth = 0;
                    this.minReadableWidth = 0;
                    this.minWidth = 0;
                    this.width = 0;
                    this.dataKey = dataKey;
                    this.raw = raw;
                    this.index = index;
                  }
                  Column2.prototype.getMaxCustomCellWidth = function(table) {
                    var max2 = 0;
                    for (var _i = 0, _a3 = table.allRows(); _i < _a3.length; _i++) {
                      var row = _a3[_i];
                      var cell = row.cells[this.index];
                      if (cell && typeof cell.styles.cellWidth === "number") {
                        max2 = Math.max(max2, cell.styles.cellWidth);
                      }
                    }
                    return max2;
                  };
                  return Column2;
                }()
              );
              exports3.Column = Column;
            }
          ),
          /***/
          356: (
            /***/
            function(__unused_webpack_module, exports3) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.assign = void 0;
              function assign2(target, s2, s1, s22, s3) {
                if (target == null) {
                  throw new TypeError("Cannot convert undefined or null to object");
                }
                var to = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                  var nextSource = arguments[index];
                  if (nextSource != null) {
                    for (var nextKey in nextSource) {
                      if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                      }
                    }
                  }
                }
                return to;
              }
              exports3.assign = assign2;
            }
          ),
          /***/
          972: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.createTable = void 0;
              var documentHandler_1 = __webpack_require__2(744);
              var models_1 = __webpack_require__2(260);
              var widthCalculator_1 = __webpack_require__2(324);
              var config_1 = __webpack_require__2(796);
              var polyfills_1 = __webpack_require__2(356);
              function createTable(jsPDFDoc, input) {
                var doc = new documentHandler_1.DocHandler(jsPDFDoc);
                var content = parseContent(input, doc.scaleFactor());
                var table = new models_1.Table(input, content);
                (0, widthCalculator_1.calculateWidths)(doc, table);
                doc.applyStyles(doc.userStyles);
                return table;
              }
              exports3.createTable = createTable;
              function parseContent(input, sf) {
                var content = input.content;
                var columns = createColumns(content.columns);
                if (content.head.length === 0) {
                  var sectionRow = generateSectionRow(columns, "head");
                  if (sectionRow)
                    content.head.push(sectionRow);
                }
                if (content.foot.length === 0) {
                  var sectionRow = generateSectionRow(columns, "foot");
                  if (sectionRow)
                    content.foot.push(sectionRow);
                }
                var theme = input.settings.theme;
                var styles2 = input.styles;
                return {
                  columns,
                  head: parseSection("head", content.head, columns, styles2, theme, sf),
                  body: parseSection("body", content.body, columns, styles2, theme, sf),
                  foot: parseSection("foot", content.foot, columns, styles2, theme, sf)
                };
              }
              function parseSection(sectionName, sectionRows, columns, styleProps, theme, scaleFactor) {
                var rowSpansLeftForColumn = {};
                var result = sectionRows.map(function(rawRow, rowIndex) {
                  var skippedRowForRowSpans = 0;
                  var cells = {};
                  var colSpansAdded = 0;
                  var columnSpansLeft = 0;
                  for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {
                      if (columnSpansLeft === 0) {
                        var rawCell = void 0;
                        if (Array.isArray(rawRow)) {
                          rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];
                        } else {
                          rawCell = rawRow[column.dataKey];
                        }
                        var cellInputStyles = {};
                        if (typeof rawCell === "object" && !Array.isArray(rawCell)) {
                          cellInputStyles = (rawCell === null || rawCell === void 0 ? void 0 : rawCell.styles) || {};
                        }
                        var styles2 = cellStyles(sectionName, column, rowIndex, theme, styleProps, scaleFactor, cellInputStyles);
                        var cell = new models_1.Cell(rawCell, styles2, sectionName);
                        cells[column.dataKey] = cell;
                        cells[column.index] = cell;
                        columnSpansLeft = cell.colSpan - 1;
                        rowSpansLeftForColumn[column.index] = {
                          left: cell.rowSpan - 1,
                          times: columnSpansLeft
                        };
                      } else {
                        columnSpansLeft--;
                        colSpansAdded++;
                      }
                    } else {
                      rowSpansLeftForColumn[column.index].left--;
                      columnSpansLeft = rowSpansLeftForColumn[column.index].times;
                      skippedRowForRowSpans++;
                    }
                  }
                  return new models_1.Row(rawRow, rowIndex, sectionName, cells);
                });
                return result;
              }
              function generateSectionRow(columns, section) {
                var sectionRow = {};
                columns.forEach(function(col) {
                  if (col.raw != null) {
                    var title = getSectionTitle(section, col.raw);
                    if (title != null)
                      sectionRow[col.dataKey] = title;
                  }
                });
                return Object.keys(sectionRow).length > 0 ? sectionRow : null;
              }
              function getSectionTitle(section, column) {
                if (section === "head") {
                  if (typeof column === "object") {
                    return column.header || column.title || null;
                  } else if (typeof column === "string" || typeof column === "number") {
                    return column;
                  }
                } else if (section === "foot" && typeof column === "object") {
                  return column.footer;
                }
                return null;
              }
              function createColumns(columns) {
                return columns.map(function(input, index) {
                  var _a3, _b2;
                  var key;
                  if (typeof input === "object") {
                    key = (_b2 = (_a3 = input.dataKey) !== null && _a3 !== void 0 ? _a3 : input.key) !== null && _b2 !== void 0 ? _b2 : index;
                  } else {
                    key = index;
                  }
                  return new models_1.Column(key, input, index);
                });
              }
              function cellStyles(sectionName, column, rowIndex, themeName, styles2, scaleFactor, cellInputStyles) {
                var theme = (0, config_1.getTheme)(themeName);
                var sectionStyles;
                if (sectionName === "head") {
                  sectionStyles = styles2.headStyles;
                } else if (sectionName === "body") {
                  sectionStyles = styles2.bodyStyles;
                } else if (sectionName === "foot") {
                  sectionStyles = styles2.footStyles;
                }
                var otherStyles = (0, polyfills_1.assign)({}, theme.table, theme[sectionName], styles2.styles, sectionStyles);
                var columnStyles = styles2.columnStyles[column.dataKey] || styles2.columnStyles[column.index] || {};
                var colStyles = sectionName === "body" ? columnStyles : {};
                var rowStyles = sectionName === "body" && rowIndex % 2 === 0 ? (0, polyfills_1.assign)({}, theme.alternateRow, styles2.alternateRowStyles) : {};
                var defaultStyle = (0, config_1.defaultStyles)(scaleFactor);
                var themeStyles = (0, polyfills_1.assign)({}, defaultStyle, otherStyles, rowStyles, colStyles);
                return (0, polyfills_1.assign)(themeStyles, cellInputStyles);
              }
            }
          ),
          /***/
          664: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.addPage = exports3.drawTable = void 0;
              var common_1 = __webpack_require__2(420);
              var models_1 = __webpack_require__2(260);
              var documentHandler_1 = __webpack_require__2(744);
              var polyfills_1 = __webpack_require__2(356);
              var autoTableText_1 = __webpack_require__2(136);
              var tablePrinter_1 = __webpack_require__2(224);
              function drawTable(jsPDFDoc, table) {
                var settings = table.settings;
                var startY = settings.startY;
                var margin2 = settings.margin;
                var cursor = {
                  x: margin2.left,
                  y: startY
                };
                var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
                var minTableBottomPos = startY + margin2.bottom + sectionsHeight;
                if (settings.pageBreak === "avoid") {
                  var rows = table.body;
                  var tableHeight = rows.reduce(function(acc, row) {
                    return acc + row.height;
                  }, 0);
                  minTableBottomPos += tableHeight;
                }
                var doc = new documentHandler_1.DocHandler(jsPDFDoc);
                if (settings.pageBreak === "always" || settings.startY != null && minTableBottomPos > doc.pageSize().height) {
                  nextPage(doc);
                  cursor.y = margin2.top;
                }
                table.callWillDrawPageHooks(doc, cursor);
                var startPos = (0, polyfills_1.assign)({}, cursor);
                table.startPageNumber = doc.pageNumber();
                if (settings.horizontalPageBreak) {
                  printTableWithHorizontalPageBreak(doc, table, startPos, cursor);
                } else {
                  doc.applyStyles(doc.userStyles);
                  if (settings.showHead === "firstPage" || settings.showHead === "everyPage") {
                    table.head.forEach(function(row) {
                      return printRow(doc, table, row, cursor, table.columns);
                    });
                  }
                  doc.applyStyles(doc.userStyles);
                  table.body.forEach(function(row, index) {
                    var isLastRow = index === table.body.length - 1;
                    printFullRow(doc, table, row, isLastRow, startPos, cursor, table.columns);
                  });
                  doc.applyStyles(doc.userStyles);
                  if (settings.showFoot === "lastPage" || settings.showFoot === "everyPage") {
                    table.foot.forEach(function(row) {
                      return printRow(doc, table, row, cursor, table.columns);
                    });
                  }
                }
                (0, common_1.addTableBorder)(doc, table, startPos, cursor);
                table.callEndPageHooks(doc, cursor);
                table.finalY = cursor.y;
                jsPDFDoc.lastAutoTable = table;
                jsPDFDoc.previousAutoTable = table;
                if (jsPDFDoc.autoTable)
                  jsPDFDoc.autoTable.previous = table;
                doc.applyStyles(doc.userStyles);
              }
              exports3.drawTable = drawTable;
              function printTableWithHorizontalPageBreak(doc, table, startPos, cursor) {
                var allColumnsCanFitResult = (0, tablePrinter_1.calculateAllColumnsCanFitInPage)(doc, table);
                var settings = table.settings;
                if (settings.horizontalPageBreakBehaviour === "afterAllRows") {
                  allColumnsCanFitResult.forEach(function(colsAndIndexes, index) {
                    doc.applyStyles(doc.userStyles);
                    if (index > 0) {
                      addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);
                    } else {
                      printHead(doc, table, cursor, colsAndIndexes.columns);
                    }
                    printBody(doc, table, startPos, cursor, colsAndIndexes.columns);
                    printFoot(doc, table, cursor, colsAndIndexes.columns);
                  });
                } else {
                  var lastRowIndexOfLastPage_1 = -1;
                  var firstColumnsToFitResult = allColumnsCanFitResult[0];
                  var _loop_1 = function() {
                    var lastPrintedRowIndex = lastRowIndexOfLastPage_1;
                    if (firstColumnsToFitResult) {
                      doc.applyStyles(doc.userStyles);
                      var firstColumnsToFit = firstColumnsToFitResult.columns;
                      if (lastRowIndexOfLastPage_1 >= 0) {
                        addPage(doc, table, startPos, cursor, firstColumnsToFit, true);
                      } else {
                        printHead(doc, table, cursor, firstColumnsToFit);
                      }
                      lastPrintedRowIndex = printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, firstColumnsToFit);
                      printFoot(doc, table, cursor, firstColumnsToFit);
                    }
                    var maxNumberOfRows = lastPrintedRowIndex - lastRowIndexOfLastPage_1;
                    allColumnsCanFitResult.slice(1).forEach(function(colsAndIndexes) {
                      doc.applyStyles(doc.userStyles);
                      addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);
                      printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, colsAndIndexes.columns, maxNumberOfRows);
                      printFoot(doc, table, cursor, colsAndIndexes.columns);
                    });
                    lastRowIndexOfLastPage_1 = lastPrintedRowIndex;
                  };
                  while (lastRowIndexOfLastPage_1 < table.body.length - 1) {
                    _loop_1();
                  }
                }
              }
              function printHead(doc, table, cursor, columns) {
                var settings = table.settings;
                doc.applyStyles(doc.userStyles);
                if (settings.showHead === "firstPage" || settings.showHead === "everyPage") {
                  table.head.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                }
              }
              function printBody(doc, table, startPos, cursor, columns) {
                doc.applyStyles(doc.userStyles);
                table.body.forEach(function(row, index) {
                  var isLastRow = index === table.body.length - 1;
                  printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);
                });
              }
              function printBodyWithoutPageBreaks(doc, table, startRowIndex, cursor, columns, maxNumberOfRows) {
                doc.applyStyles(doc.userStyles);
                maxNumberOfRows = maxNumberOfRows !== null && maxNumberOfRows !== void 0 ? maxNumberOfRows : table.body.length;
                var endRowIndex = Math.min(startRowIndex + maxNumberOfRows, table.body.length);
                var lastPrintedRowIndex = -1;
                table.body.slice(startRowIndex, endRowIndex).forEach(function(row, index) {
                  var isLastRow = startRowIndex + index === table.body.length - 1;
                  var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);
                  if (row.canEntireRowFit(remainingSpace, columns)) {
                    printRow(doc, table, row, cursor, columns);
                    lastPrintedRowIndex = startRowIndex + index;
                  }
                });
                return lastPrintedRowIndex;
              }
              function printFoot(doc, table, cursor, columns) {
                var settings = table.settings;
                doc.applyStyles(doc.userStyles);
                if (settings.showFoot === "lastPage" || settings.showFoot === "everyPage") {
                  table.foot.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                }
              }
              function getRemainingLineCount(cell, remainingPageSpace, doc) {
                var lineHeight = doc.getLineHeight(cell.styles.fontSize);
                var vPadding = cell.padding("vertical");
                var remainingLines = Math.floor((remainingPageSpace - vPadding) / lineHeight);
                return Math.max(0, remainingLines);
              }
              function modifyRowToFit(row, remainingPageSpace, table, doc) {
                var cells = {};
                row.spansMultiplePages = true;
                row.height = 0;
                var rowHeight = 0;
                for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                  var column = _a3[_i];
                  var cell = row.cells[column.index];
                  if (!cell)
                    continue;
                  if (!Array.isArray(cell.text)) {
                    cell.text = [cell.text];
                  }
                  var remainderCell = new models_1.Cell(cell.raw, cell.styles, cell.section);
                  remainderCell = (0, polyfills_1.assign)(remainderCell, cell);
                  remainderCell.text = [];
                  var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace, doc);
                  if (cell.text.length > remainingLineCount) {
                    remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);
                  }
                  var scaleFactor = doc.scaleFactor();
                  var lineHeightFactor = doc.getLineHeightFactor();
                  cell.contentHeight = cell.getContentHeight(scaleFactor, lineHeightFactor);
                  if (cell.contentHeight >= remainingPageSpace) {
                    cell.contentHeight = remainingPageSpace;
                    remainderCell.styles.minCellHeight -= remainingPageSpace;
                  }
                  if (cell.contentHeight > row.height) {
                    row.height = cell.contentHeight;
                  }
                  remainderCell.contentHeight = remainderCell.getContentHeight(scaleFactor, lineHeightFactor);
                  if (remainderCell.contentHeight > rowHeight) {
                    rowHeight = remainderCell.contentHeight;
                  }
                  cells[column.index] = remainderCell;
                }
                var remainderRow = new models_1.Row(row.raw, -1, row.section, cells, true);
                remainderRow.height = rowHeight;
                for (var _b2 = 0, _c = table.columns; _b2 < _c.length; _b2++) {
                  var column = _c[_b2];
                  var remainderCell = remainderRow.cells[column.index];
                  if (remainderCell) {
                    remainderCell.height = remainderRow.height;
                  }
                  var cell = row.cells[column.index];
                  if (cell) {
                    cell.height = row.height;
                  }
                }
                return remainderRow;
              }
              function shouldPrintOnCurrentPage(doc, row, remainingPageSpace, table) {
                var pageHeight = doc.pageSize().height;
                var margin2 = table.settings.margin;
                var marginHeight = margin2.top + margin2.bottom;
                var maxRowHeight = pageHeight - marginHeight;
                if (row.section === "body") {
                  maxRowHeight -= table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
                }
                var minRowHeight = row.getMinimumRowHeight(table.columns, doc);
                var minRowFits = minRowHeight < remainingPageSpace;
                if (minRowHeight > maxRowHeight) {
                  console.error("Will not be able to print row ".concat(row.index, " correctly since it's minimum height is larger than page height"));
                  return true;
                }
                if (!minRowFits) {
                  return false;
                }
                var rowHasRowSpanCell = row.hasRowSpan(table.columns);
                var rowHigherThanPage = row.getMaxCellHeight(table.columns) > maxRowHeight;
                if (rowHigherThanPage) {
                  if (rowHasRowSpanCell) {
                    console.error("The content of row ".concat(row.index, " will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported."));
                  }
                  return true;
                }
                if (rowHasRowSpanCell) {
                  return false;
                }
                if (table.settings.rowPageBreak === "avoid") {
                  return false;
                }
                return true;
              }
              function printFullRow(doc, table, row, isLastRow, startPos, cursor, columns) {
                var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);
                if (row.canEntireRowFit(remainingSpace, columns)) {
                  printRow(doc, table, row, cursor, columns);
                } else if (shouldPrintOnCurrentPage(doc, row, remainingSpace, table)) {
                  var remainderRow = modifyRowToFit(row, remainingSpace, table, doc);
                  printRow(doc, table, row, cursor, columns);
                  addPage(doc, table, startPos, cursor, columns);
                  printFullRow(doc, table, remainderRow, isLastRow, startPos, cursor, columns);
                } else {
                  addPage(doc, table, startPos, cursor, columns);
                  printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);
                }
              }
              function printRow(doc, table, row, cursor, columns) {
                cursor.x = table.settings.margin.left;
                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                  var column = columns_1[_i];
                  var cell = row.cells[column.index];
                  if (!cell) {
                    cursor.x += column.width;
                    continue;
                  }
                  doc.applyStyles(cell.styles);
                  cell.x = cursor.x;
                  cell.y = cursor.y;
                  var result = table.callCellHooks(doc, table.hooks.willDrawCell, cell, row, column, cursor);
                  if (result === false) {
                    cursor.x += column.width;
                    continue;
                  }
                  drawCellRect(doc, cell, cursor);
                  var textPos = cell.getTextPos();
                  (0, autoTableText_1.default)(cell.text, textPos.x, textPos.y, {
                    halign: cell.styles.halign,
                    valign: cell.styles.valign,
                    maxWidth: Math.ceil(cell.width - cell.padding("left") - cell.padding("right"))
                  }, doc.getDocument());
                  table.callCellHooks(doc, table.hooks.didDrawCell, cell, row, column, cursor);
                  cursor.x += column.width;
                }
                cursor.y += row.height;
              }
              function drawCellRect(doc, cell, cursor) {
                var cellStyles = cell.styles;
                doc.getDocument().setFillColor(doc.getDocument().getFillColor());
                if (typeof cellStyles.lineWidth === "number") {
                  var fillStyle = (0, common_1.getFillStyle)(cellStyles.lineWidth, cellStyles.fillColor);
                  if (fillStyle) {
                    doc.rect(cell.x, cursor.y, cell.width, cell.height, fillStyle);
                  }
                } else if (typeof cellStyles.lineWidth === "object") {
                  if (cellStyles.fillColor) {
                    doc.rect(cell.x, cursor.y, cell.width, cell.height, "F");
                  }
                  drawCellBorders(doc, cell, cursor, cellStyles.lineWidth);
                }
              }
              function drawCellBorders(doc, cell, cursor, lineWidth) {
                var x1, y1, x2, y2;
                if (lineWidth.top) {
                  x1 = cursor.x;
                  y1 = cursor.y;
                  x2 = cursor.x + cell.width;
                  y2 = cursor.y;
                  if (lineWidth.right) {
                    x2 += 0.5 * lineWidth.right;
                  }
                  if (lineWidth.left) {
                    x1 -= 0.5 * lineWidth.left;
                  }
                  drawLine(lineWidth.top, x1, y1, x2, y2);
                }
                if (lineWidth.bottom) {
                  x1 = cursor.x;
                  y1 = cursor.y + cell.height;
                  x2 = cursor.x + cell.width;
                  y2 = cursor.y + cell.height;
                  if (lineWidth.right) {
                    x2 += 0.5 * lineWidth.right;
                  }
                  if (lineWidth.left) {
                    x1 -= 0.5 * lineWidth.left;
                  }
                  drawLine(lineWidth.bottom, x1, y1, x2, y2);
                }
                if (lineWidth.left) {
                  x1 = cursor.x;
                  y1 = cursor.y;
                  x2 = cursor.x;
                  y2 = cursor.y + cell.height;
                  if (lineWidth.top) {
                    y1 -= 0.5 * lineWidth.top;
                  }
                  if (lineWidth.bottom) {
                    y2 += 0.5 * lineWidth.bottom;
                  }
                  drawLine(lineWidth.left, x1, y1, x2, y2);
                }
                if (lineWidth.right) {
                  x1 = cursor.x + cell.width;
                  y1 = cursor.y;
                  x2 = cursor.x + cell.width;
                  y2 = cursor.y + cell.height;
                  if (lineWidth.top) {
                    y1 -= 0.5 * lineWidth.top;
                  }
                  if (lineWidth.bottom) {
                    y2 += 0.5 * lineWidth.bottom;
                  }
                  drawLine(lineWidth.right, x1, y1, x2, y2);
                }
                function drawLine(width, x12, y12, x22, y22) {
                  doc.getDocument().setLineWidth(width);
                  doc.getDocument().line(x12, y12, x22, y22, "S");
                }
              }
              function getRemainingPageSpace(doc, table, isLastRow, cursor) {
                var bottomContentHeight = table.settings.margin.bottom;
                var showFoot = table.settings.showFoot;
                if (showFoot === "everyPage" || showFoot === "lastPage" && isLastRow) {
                  bottomContentHeight += table.getFootHeight(table.columns);
                }
                return doc.pageSize().height - cursor.y - bottomContentHeight;
              }
              function addPage(doc, table, startPos, cursor, columns, suppressFooter) {
                if (columns === void 0) {
                  columns = [];
                }
                if (suppressFooter === void 0) {
                  suppressFooter = false;
                }
                doc.applyStyles(doc.userStyles);
                if (table.settings.showFoot === "everyPage" && !suppressFooter) {
                  table.foot.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                }
                table.callEndPageHooks(doc, cursor);
                var margin2 = table.settings.margin;
                (0, common_1.addTableBorder)(doc, table, startPos, cursor);
                nextPage(doc);
                table.pageNumber++;
                table.pageCount++;
                cursor.x = margin2.left;
                cursor.y = margin2.top;
                startPos.y = margin2.top;
                table.callWillDrawPageHooks(doc, cursor);
                if (table.settings.showHead === "everyPage") {
                  table.head.forEach(function(row) {
                    return printRow(doc, table, row, cursor, columns);
                  });
                  doc.applyStyles(doc.userStyles);
                }
              }
              exports3.addPage = addPage;
              function nextPage(doc) {
                var current = doc.pageNumber();
                doc.setPage(current + 1);
                var newCurrent = doc.pageNumber();
                if (newCurrent === current) {
                  doc.addPage();
                  return true;
                }
                return false;
              }
            }
          ),
          /***/
          224: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.calculateAllColumnsCanFitInPage = void 0;
              var common_1 = __webpack_require__2(420);
              function getColumnsCanFitInPage(doc, table, config2) {
                var _a3;
                if (config2 === void 0) {
                  config2 = {};
                }
                var remainingWidth = (0, common_1.getPageAvailableWidth)(doc, table);
                var repeatColumnsMap = /* @__PURE__ */ new Map();
                var colIndexes = [];
                var columns = [];
                var horizontalPageBreakRepeat = [];
                table.settings.horizontalPageBreakRepeat;
                if (Array.isArray(table.settings.horizontalPageBreakRepeat)) {
                  horizontalPageBreakRepeat = table.settings.horizontalPageBreakRepeat;
                } else if (typeof table.settings.horizontalPageBreakRepeat === "string" || typeof table.settings.horizontalPageBreakRepeat === "number") {
                  horizontalPageBreakRepeat = [table.settings.horizontalPageBreakRepeat];
                }
                horizontalPageBreakRepeat.forEach(function(field) {
                  var col = table.columns.find(function(item) {
                    return item.dataKey === field || item.index === field;
                  });
                  if (col && !repeatColumnsMap.has(col.index)) {
                    repeatColumnsMap.set(col.index, true);
                    colIndexes.push(col.index);
                    columns.push(table.columns[col.index]);
                    remainingWidth -= col.wrappedWidth;
                  }
                });
                var first = true;
                var i2 = (_a3 = config2 === null || config2 === void 0 ? void 0 : config2.start) !== null && _a3 !== void 0 ? _a3 : 0;
                while (i2 < table.columns.length) {
                  if (repeatColumnsMap.has(i2)) {
                    i2++;
                    continue;
                  }
                  var colWidth = table.columns[i2].wrappedWidth;
                  if (first || remainingWidth >= colWidth) {
                    first = false;
                    colIndexes.push(i2);
                    columns.push(table.columns[i2]);
                    remainingWidth -= colWidth;
                  } else {
                    break;
                  }
                  i2++;
                }
                return { colIndexes, columns, lastIndex: i2 - 1 };
              }
              function calculateAllColumnsCanFitInPage(doc, table) {
                var allResults = [];
                for (var i2 = 0; i2 < table.columns.length; i2++) {
                  var result = getColumnsCanFitInPage(doc, table, { start: i2 });
                  if (result.columns.length) {
                    allResults.push(result);
                    i2 = result.lastIndex;
                  }
                }
                return allResults;
              }
              exports3.calculateAllColumnsCanFitInPage = calculateAllColumnsCanFitInPage;
            }
          ),
          /***/
          324: (
            /***/
            function(__unused_webpack_module, exports3, __webpack_require__2) {
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.ellipsize = exports3.resizeColumns = exports3.calculateWidths = void 0;
              var common_1 = __webpack_require__2(420);
              function calculateWidths(doc, table) {
                calculate(doc, table);
                var resizableColumns = [];
                var initialTableWidth = 0;
                table.columns.forEach(function(column) {
                  var customWidth = column.getMaxCustomCellWidth(table);
                  if (customWidth) {
                    column.width = customWidth;
                  } else {
                    column.width = column.wrappedWidth;
                    resizableColumns.push(column);
                  }
                  initialTableWidth += column.width;
                });
                var resizeWidth = table.getWidth(doc.pageSize().width) - initialTableWidth;
                if (resizeWidth) {
                  resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {
                    return Math.max(column.minReadableWidth, column.minWidth);
                  });
                }
                if (resizeWidth) {
                  resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {
                    return column.minWidth;
                  });
                }
                resizeWidth = Math.abs(resizeWidth);
                if (!table.settings.horizontalPageBreak && resizeWidth > 0.1 / doc.scaleFactor()) {
                  resizeWidth = resizeWidth < 1 ? resizeWidth : Math.round(resizeWidth);
                  console.warn("Of the table content, ".concat(resizeWidth, " units width could not fit page"));
                }
                applyColSpans(table);
                fitContent(table, doc);
                applyRowSpans(table);
              }
              exports3.calculateWidths = calculateWidths;
              function calculate(doc, table) {
                var sf = doc.scaleFactor();
                var horizontalPageBreak = table.settings.horizontalPageBreak;
                var availablePageWidth = (0, common_1.getPageAvailableWidth)(doc, table);
                table.allRows().forEach(function(row) {
                  for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                    var column = _a3[_i];
                    var cell = row.cells[column.index];
                    if (!cell)
                      continue;
                    var hooks = table.hooks.didParseCell;
                    table.callCellHooks(doc, hooks, cell, row, column, null);
                    var padding = cell.padding("horizontal");
                    cell.contentWidth = (0, common_1.getStringWidth)(cell.text, cell.styles, doc) + padding;
                    var longestWordWidth = (0, common_1.getStringWidth)(cell.text.join(" ").split(/[^\S\u00A0]+/), cell.styles, doc);
                    cell.minReadableWidth = longestWordWidth + cell.padding("horizontal");
                    if (typeof cell.styles.cellWidth === "number") {
                      cell.minWidth = cell.styles.cellWidth;
                      cell.wrappedWidth = cell.styles.cellWidth;
                    } else if (cell.styles.cellWidth === "wrap" || horizontalPageBreak === true) {
                      if (cell.contentWidth > availablePageWidth) {
                        cell.minWidth = availablePageWidth;
                        cell.wrappedWidth = availablePageWidth;
                      } else {
                        cell.minWidth = cell.contentWidth;
                        cell.wrappedWidth = cell.contentWidth;
                      }
                    } else {
                      var defaultMinWidth = 10 / sf;
                      cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;
                      cell.wrappedWidth = cell.contentWidth;
                      if (cell.minWidth > cell.wrappedWidth) {
                        cell.wrappedWidth = cell.minWidth;
                      }
                    }
                  }
                });
                table.allRows().forEach(function(row) {
                  for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                    var column = _a3[_i];
                    var cell = row.cells[column.index];
                    if (cell && cell.colSpan === 1) {
                      column.wrappedWidth = Math.max(column.wrappedWidth, cell.wrappedWidth);
                      column.minWidth = Math.max(column.minWidth, cell.minWidth);
                      column.minReadableWidth = Math.max(column.minReadableWidth, cell.minReadableWidth);
                    } else {
                      var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};
                      var cellWidth = columnStyles.cellWidth || columnStyles.minCellWidth;
                      if (cellWidth && typeof cellWidth === "number") {
                        column.minWidth = cellWidth;
                        column.wrappedWidth = cellWidth;
                      }
                    }
                    if (cell) {
                      if (cell.colSpan > 1 && !column.minWidth) {
                        column.minWidth = cell.minWidth;
                      }
                      if (cell.colSpan > 1 && !column.wrappedWidth) {
                        column.wrappedWidth = cell.minWidth;
                      }
                    }
                  }
                });
              }
              function resizeColumns(columns, resizeWidth, getMinWidth) {
                var initialResizeWidth = resizeWidth;
                var sumWrappedWidth = columns.reduce(function(acc, column2) {
                  return acc + column2.wrappedWidth;
                }, 0);
                for (var i2 = 0; i2 < columns.length; i2++) {
                  var column = columns[i2];
                  var ratio = column.wrappedWidth / sumWrappedWidth;
                  var suggestedChange = initialResizeWidth * ratio;
                  var suggestedWidth = column.width + suggestedChange;
                  var minWidth = getMinWidth(column);
                  var newWidth = suggestedWidth < minWidth ? minWidth : suggestedWidth;
                  resizeWidth -= newWidth - column.width;
                  column.width = newWidth;
                }
                resizeWidth = Math.round(resizeWidth * 1e10) / 1e10;
                if (resizeWidth) {
                  var resizableColumns = columns.filter(function(column2) {
                    return resizeWidth < 0 ? column2.width > getMinWidth(column2) : true;
                  });
                  if (resizableColumns.length) {
                    resizeWidth = resizeColumns(resizableColumns, resizeWidth, getMinWidth);
                  }
                }
                return resizeWidth;
              }
              exports3.resizeColumns = resizeColumns;
              function applyRowSpans(table) {
                var rowSpanCells = {};
                var colRowSpansLeft = 1;
                var all = table.allRows();
                for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
                  var row = all[rowIndex];
                  for (var _i = 0, _a3 = table.columns; _i < _a3.length; _i++) {
                    var column = _a3[_i];
                    var data = rowSpanCells[column.index];
                    if (colRowSpansLeft > 1) {
                      colRowSpansLeft--;
                      delete row.cells[column.index];
                    } else if (data) {
                      data.cell.height += row.height;
                      colRowSpansLeft = data.cell.colSpan;
                      delete row.cells[column.index];
                      data.left--;
                      if (data.left <= 1) {
                        delete rowSpanCells[column.index];
                      }
                    } else {
                      var cell = row.cells[column.index];
                      if (!cell) {
                        continue;
                      }
                      cell.height = row.height;
                      if (cell.rowSpan > 1) {
                        var remaining = all.length - rowIndex;
                        var left2 = cell.rowSpan > remaining ? remaining : cell.rowSpan;
                        rowSpanCells[column.index] = { cell, left: left2, row };
                      }
                    }
                  }
                }
              }
              function applyColSpans(table) {
                var all = table.allRows();
                for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
                  var row = all[rowIndex];
                  var colSpanCell = null;
                  var combinedColSpanWidth = 0;
                  var colSpansLeft = 0;
                  for (var columnIndex = 0; columnIndex < table.columns.length; columnIndex++) {
                    var column = table.columns[columnIndex];
                    colSpansLeft -= 1;
                    if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {
                      combinedColSpanWidth += column.width;
                      delete row.cells[column.index];
                    } else if (colSpanCell) {
                      var cell = colSpanCell;
                      delete row.cells[column.index];
                      colSpanCell = null;
                      cell.width = column.width + combinedColSpanWidth;
                    } else {
                      var cell = row.cells[column.index];
                      if (!cell)
                        continue;
                      colSpansLeft = cell.colSpan;
                      combinedColSpanWidth = 0;
                      if (cell.colSpan > 1) {
                        colSpanCell = cell;
                        combinedColSpanWidth += column.width;
                        continue;
                      }
                      cell.width = column.width + combinedColSpanWidth;
                    }
                  }
                }
              }
              function fitContent(table, doc) {
                var rowSpanHeight = { count: 0, height: 0 };
                for (var _i = 0, _a3 = table.allRows(); _i < _a3.length; _i++) {
                  var row = _a3[_i];
                  for (var _b2 = 0, _c = table.columns; _b2 < _c.length; _b2++) {
                    var column = _c[_b2];
                    var cell = row.cells[column.index];
                    if (!cell)
                      continue;
                    doc.applyStyles(cell.styles, true);
                    var textSpace = cell.width - cell.padding("horizontal");
                    if (cell.styles.overflow === "linebreak") {
                      cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / doc.scaleFactor(), { fontSize: cell.styles.fontSize });
                    } else if (cell.styles.overflow === "ellipsize") {
                      cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, "...");
                    } else if (cell.styles.overflow === "hidden") {
                      cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, "");
                    } else if (typeof cell.styles.overflow === "function") {
                      var result = cell.styles.overflow(cell.text, textSpace);
                      if (typeof result === "string") {
                        cell.text = [result];
                      } else {
                        cell.text = result;
                      }
                    }
                    cell.contentHeight = cell.getContentHeight(doc.scaleFactor(), doc.getLineHeightFactor());
                    var realContentHeight = cell.contentHeight / cell.rowSpan;
                    if (cell.rowSpan > 1 && rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan) {
                      rowSpanHeight = { height: realContentHeight, count: cell.rowSpan };
                    } else if (rowSpanHeight && rowSpanHeight.count > 0) {
                      if (rowSpanHeight.height > realContentHeight) {
                        realContentHeight = rowSpanHeight.height;
                      }
                    }
                    if (realContentHeight > row.height) {
                      row.height = realContentHeight;
                    }
                  }
                  rowSpanHeight.count--;
                }
              }
              function ellipsize(text, width, styles2, doc, overflow) {
                return text.map(function(str) {
                  return ellipsizeStr(str, width, styles2, doc, overflow);
                });
              }
              exports3.ellipsize = ellipsize;
              function ellipsizeStr(text, width, styles2, doc, overflow) {
                var precision = 1e4 * doc.scaleFactor();
                width = Math.ceil(width * precision) / precision;
                if (width >= (0, common_1.getStringWidth)(text, styles2, doc)) {
                  return text;
                }
                while (width < (0, common_1.getStringWidth)(text + overflow, styles2, doc)) {
                  if (text.length <= 1) {
                    break;
                  }
                  text = text.substring(0, text.length - 1);
                }
                return text.trim() + overflow;
              }
            }
          ),
          /***/
          964: (
            /***/
            function(module3) {
              if (typeof __WEBPACK_EXTERNAL_MODULE__964__ === "undefined") {
                var e = new Error("Cannot find module 'undefined'");
                e.code = "MODULE_NOT_FOUND";
                throw e;
              }
              module3.exports = __WEBPACK_EXTERNAL_MODULE__964__;
            }
          )
          /******/
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module3 = __webpack_module_cache__[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          return module3.exports;
        }
        var __webpack_exports__ = {};
        !function() {
          var exports3 = __webpack_exports__;
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Cell = exports3.Column = exports3.Row = exports3.Table = exports3.CellHookData = exports3.__drawTable = exports3.__createTable = exports3.applyPlugin = void 0;
          var applyPlugin_1 = __webpack_require__(340);
          var inputParser_1 = __webpack_require__(776);
          var tableDrawer_1 = __webpack_require__(664);
          var tableCalculator_1 = __webpack_require__(972);
          var models_1 = __webpack_require__(260);
          Object.defineProperty(exports3, "Table", { enumerable: true, get: function() {
            return models_1.Table;
          } });
          var HookData_1 = __webpack_require__(172);
          Object.defineProperty(exports3, "CellHookData", { enumerable: true, get: function() {
            return HookData_1.CellHookData;
          } });
          var models_2 = __webpack_require__(260);
          Object.defineProperty(exports3, "Cell", { enumerable: true, get: function() {
            return models_2.Cell;
          } });
          Object.defineProperty(exports3, "Column", { enumerable: true, get: function() {
            return models_2.Column;
          } });
          Object.defineProperty(exports3, "Row", { enumerable: true, get: function() {
            return models_2.Row;
          } });
          function applyPlugin(jsPDF2) {
            (0, applyPlugin_1.default)(jsPDF2);
          }
          exports3.applyPlugin = applyPlugin;
          function autoTable2(d2, options) {
            var input = (0, inputParser_1.parseInput)(d2, options);
            var table = (0, tableCalculator_1.createTable)(d2, input);
            (0, tableDrawer_1.drawTable)(d2, table);
          }
          function __createTable(d2, options) {
            var input = (0, inputParser_1.parseInput)(d2, options);
            return (0, tableCalculator_1.createTable)(d2, input);
          }
          exports3.__createTable = __createTable;
          function __drawTable(d2, table) {
            (0, tableDrawer_1.drawTable)(d2, table);
          }
          exports3.__drawTable = __drawTable;
          try {
            var jsPDF = __webpack_require__(964);
            if (jsPDF.jsPDF)
              jsPDF = jsPDF.jsPDF;
            applyPlugin(jsPDF);
          } catch (error) {
          }
          exports3["default"] = autoTable2;
        }();
        return __webpack_exports__;
      }()
    );
  });
})(jspdf_plugin_autotable);
var jspdf_plugin_autotableExports = jspdf_plugin_autotable.exports;
const autoTable = /* @__PURE__ */ getDefaultExportFromCjs(jspdf_plugin_autotableExports);
const headingSpacing = 5;
const sectionSpacing = 10;
const extrasSeparator = ",";
const headStyles = {
  fillColor: [7, 59, 76],
  fontStyle: "normal"
};
const styles = {
  fontSize: 9
};
const margin = { left: 10 };
let headings = [];
const generateOrderSummaryPDF = (resultData, hardware, formatNumber = (number2) => number2.toString()) => {
  const { t: t2 } = i18n.global;
  const doc = new E({ orientation: "landscape" });
  let yOffset = 10;
  doc.setFontSize(20);
  doc.text(t2("pdf.orderSummary"), 10, yOffset);
  yOffset += 15;
  doc.setFontSize(14);
  doc.text("Your parts", 10, yOffset);
  yOffset += headingSpacing;
  headings = [
    t2("length"),
    t2("width"),
    t2("thickness"),
    t2("material"),
    t2("quantity"),
    t2("name"),
    `Banding (${mainSides.join(extrasSeparator)})`,
    `Finish (${faces.join(extrasSeparator)})`
  ];
  const partsData = resultData.parts.map((part) => {
    var _a3;
    const banding = mainSides.map((side) => part.banding[side] || "-").join(extrasSeparator);
    const finish = faces.map((face) => part.banding[face] || "-").join(extrasSeparator);
    return [
      formatNumber(part.l),
      formatNumber(part.w),
      formatNumber(part.t) || "-",
      ((_a3 = part.material) == null ? void 0 : _a3.toUpperCase()) || "-",
      formatNumber(part.q),
      part.name || "-",
      banding,
      finish
    ];
  });
  autoTable(doc, {
    startY: yOffset,
    head: [headings],
    body: partsData,
    margin,
    headStyles,
    styles
  });
  yOffset = doc.autoTable.previous.finalY + sectionSpacing;
  doc.setFontSize(14);
  doc.text(t2("pdf.stockRequirements"), 10, yOffset);
  yOffset += headingSpacing;
  headings = [
    t2("length"),
    t2("width"),
    t2("thickness"),
    t2("material"),
    t2("quantity")
    // 'Cost'
  ];
  const stockData = resultData.stock.map((stock) => {
    var _a3;
    return [
      formatNumber(stock.l),
      formatNumber(stock.w),
      formatNumber(stock.t) || "-",
      ((_a3 = stock.material) == null ? void 0 : _a3.toUpperCase()) || "-",
      formatNumber(stock.q)
      // stock.cost
    ];
  });
  autoTable(doc, {
    startY: yOffset,
    head: [headings],
    body: stockData,
    margin,
    headStyles,
    styles
  });
  yOffset = doc.autoTable.previous.finalY + sectionSpacing;
  if (hardware) {
    if (Object.values(hardware)) {
      doc.setFontSize(14);
      doc.text("Hardware", 10, yOffset);
      yOffset += headingSpacing;
      const hardwareData = Object.values(hardware).map((item) => [
        item.name.toUpperCase(),
        formatNumber(item.q)
        // item.totalCost.toFixed( 2 )
      ]);
      autoTable(doc, {
        startY: yOffset,
        head: [[t2("pdf.item"), t2("quantity")]],
        body: hardwareData,
        margin,
        headStyles,
        styles
      });
      yOffset = doc.autoTable.previous.finalY + sectionSpacing;
    }
  }
  doc.setFontSize(14);
  doc.text(t2("pdf.totals"), 10, yOffset);
  yOffset += headingSpacing;
  const totalsData = [
    [t2("pdf.totalParts"), formatNumber(resultData.metadata.totalPartsProduced)],
    [t2("pdf.partArea"), formatNumber(resultData.metadata.totalPartArea)],
    [t2("pdf.totalStockRequired"), formatNumber(resultData.metadata.totalUsedStock)],
    [t2("pdf.totalBandingLength"), formatNumber(resultData.metadata.totalBandingLength)],
    [t2("pdf.totalFinishArea"), formatNumber(resultData.metadata.totalFinishArea)]
  ];
  autoTable(doc, {
    startY: yOffset,
    body: totalsData,
    margin,
    headStyles,
    styles
  });
  return doc.output("blob");
};
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const toString$2 = Object.prototype.toString;
const isObject$2 = (val) => toString$2.call(val) === "[object Object]";
const noop = () => {
};
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function getLifeCycleTarget(target) {
  return getCurrentInstance();
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter2,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick$1(fn);
}
function unrefElement(elRef) {
  var _a3;
  const plain = toValue(elRef);
  return (_a3 = plain == null ? void 0 : plain.$el) != null ? _a3 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let events2;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events2, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$2(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a3;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    },
    initOnMounted
  } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults2);
  const type3 = guessSerializerType(rawInit);
  const serializer = (_a3 = options.serializer) != null ? _a3 : StorageSerializers[type3];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      useEventListener(window2, "storage", update);
      useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update();
    });
  }
  if (!initOnMounted)
    update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      window2.dispatchEvent(new CustomEvent(customStorageEventName, {
        detail: {
          key,
          oldValue,
          newValue,
          storageArea: storage
        }
      }));
    }
  }
  function write(v2) {
    try {
      const oldValue = storage.getItem(key);
      if (v2 == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v2);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value2 = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value2, rawInit);
      else if (type3 === "object" && !Array.isArray(value2))
        return { ...rawInit, ...value2 };
      return value2;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        nextTick$1(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type: type3, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type3] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup$1[chars.charCodeAt(i2)] = i2;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i2)];
    encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type3 = encodedPacket.charAt(0);
  if (type3 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type3];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type3],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type3]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j2 = 0;
  for (let i2 = 0; i2 < size; i2++) {
    buffer[i2] = chunks[0][j2++];
    if (j2 === chunks[0].length) {
      chunks.shift();
      j2 = 0;
    }
  }
  if (chunks.length && j2 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j2);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n2 = view.getUint32(0);
          if (n2 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k2) => {
    if (obj.hasOwnProperty(k2)) {
      acc[k2] = obj[k2];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length = 0;
  for (let i2 = 0, l2 = str.length; i2 < l2; i2++) {
    c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      length += 1;
    } else if (c2 < 2048) {
      length += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length += 3;
    } else {
      i2++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l2 = pairs.length; i2 < l2; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err2) {
}
const hasCORS = value;
function empty$1() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a3;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this._opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a3 = this._opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a4;
        if (xhr.readyState === 3) {
          (_a4 = this._opts.cookieJar) === null || _a4 === void 0 ? void 0 : _a4.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this._onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request.requestsCount++;
      Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err2) {
    this.emitReserved("error", err2, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty$1;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
const hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err2) {
      return this.emitReserved("error", err2);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err2) {
      return this.emitReserved("error", err2);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err2) => {
      this.onError("webtransport error", err2);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err2) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a3;
    (_a3 = this._transport) === null || _a3 === void 0 ? void 0 : _a3.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re$1 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b2 = str.indexOf("["), e = str.indexOf("]");
  if (b2 != -1 && e != -1) {
    str = str.substring(0, b2) + str.substring(b2, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m2 = re$1.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m2[i2] || "";
  }
  if (b2 != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t2) => {
      const transportName = t2.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t2;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err2 = new Error("server error");
          err2.code = packet.data;
          this._onError(err2);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type3, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type: type3,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err2) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err2);
    this._onClose("transport error", err2);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i2 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i2 !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i2, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i2 = 0; i2 < this._upgrades.length; i2++) {
        this._probe(this._upgrades[i2]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err2 = new Error("probe error");
          err2.transport = transport.name;
          this.emitReserved("upgradeError", err2);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err2) => {
      const error = new Error("probe error: " + err2);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i2 = 0; i2 < upgrades.length; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o2 = typeof uri === "object" ? uri : opts;
    if (!o2.transports || o2.transports && typeof o2.transports[0] === "string") {
      o2.transports = (o2.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t2) => !!t2);
    }
    super(uri, o2);
  }
};
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString$1 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$1.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$1.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject$1(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i2 = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if ("," === c2)
          break;
        if (i2 === str.length)
          break;
      }
      p2.nsp = str.substring(start, i2);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if (null == c2 || Number(c2) != c2) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type3, payload) {
    switch (type3) {
      case PacketType.CONNECT:
        return isObject$1(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject$1(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a3, _b2, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b2 = (_a3 = this.io.engine) === null || _a3 === void 0 ? void 0 : _a3.transport) === null || _b2 === void 0 ? void 0 : _b2.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) ;
    else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a3;
    const timeout = (_a3 = this.flags.timeout) !== null && _a3 !== void 0 ? _a3 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err2, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err2 !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err2);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err2) {
    if (!this.connected) {
      this.emitReserved("connect_error", err2);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err2 = new Error(packet.data.message);
        err2.data = packet.data.data;
        this.emitReserved("connect_error", err2);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min2) {
  this.ms = min2;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a3;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a3 = opts.randomizationFactor) !== null && _a3 !== void 0 ? _a3 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    if (!v2) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a3;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a3;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a3;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err2) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err2);
      if (fn) {
        fn(err2);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err2) {
    this.emitReserved("error", err2);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a3;
    this.cleanup();
    (_a3 = this.engine) === null || _a3 === void 0 ? void 0 : _a3.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err2) => {
          if (err2) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err2);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache[id] && path2 in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal || freeSelf || Function("return this")();
var Symbol$2 = root$1.Symbol;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
var nativeObjectToString$1 = objectProto$5.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$4.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var nativeObjectToString = objectProto$4.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var symbolTag = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
}
function arrayMap(array2, iteratee) {
  var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array2[index], index, array2);
  }
  return result;
}
var isArray = Array.isArray;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$1 ? "-0" : result;
}
function isObject(value2) {
  var type3 = typeof value2;
  return value2 != null && (type3 == "object" || type3 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative(object2, key) {
  var value2 = getValue(object2, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type3 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object2, key, value2) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object2[key] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function assignValue(object2, key, value2) {
  var objValue = object2[key];
  if (!(hasOwnProperty$2.call(object2, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value2);
  }
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value2, object2) {
  if (isArray(value2)) {
    return false;
  }
  var type3 = typeof value2;
  if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value2 == null || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type3 = typeof value2;
  return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
function toString(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function castPath(value2, object2) {
  if (isArray(value2)) {
    return value2;
  }
  return isKey(value2, object2) ? [value2] : stringToPath(toString(value2));
}
var INFINITY = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function baseGet(object2, path2) {
  path2 = castPath(path2, object2);
  var index = 0, length = path2.length;
  while (object2 != null && index < length) {
    object2 = object2[toKey(path2[index++])];
  }
  return index && index == length ? object2 : void 0;
}
function get2(object2, path2, defaultValue) {
  var result = object2 == null ? void 0 : baseGet(object2, path2);
  return result === void 0 ? defaultValue : result;
}
function baseSet(object2, path2, value2, customizer) {
  if (!isObject(object2)) {
    return object2;
  }
  path2 = castPath(path2, object2);
  var index = -1, length = path2.length, lastIndex = length - 1, nested = object2;
  while (nested != null && ++index < length) {
    var key = toKey(path2[index]), newValue = value2;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object2;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = void 0;
      if (newValue === void 0) {
        newValue = isObject(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object2;
}
function set2(object2, path2, value2) {
  return object2 == null ? object2 : baseSet(object2, path2, value2);
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns") name = name.slice(i2 + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function") select2 = selector(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function") select2 = arrayAll(select2);
  else select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        subgroups.push(select2.call(node, node.__data__, i2, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node, i2 = 0; i2 < n2; ++i2) {
      if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$2(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i2 = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i2 < dataLength; ++i2) {
    if (node = group[i2]) {
      node.__data__ = data[i2];
      update[i2] = node;
    } else {
      enter[i2] = new EnterNode(parent, data[i2]);
    }
  }
  for (; i2 < groupLength; ++i2) {
    if (node = group[i2]) {
      exit[i2] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2) {
    if (node = group[i2]) {
      keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i2] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i2 = 0; i2 < dataLength; ++i2) {
    keyValue = key.call(parent, data[i2], i2, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i2] = node;
      node.__data__ = data[i2];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i2] = new EnterNode(parent, data[i2]);
    }
  }
  for (i2 = 0; i2 < groupLength; ++i2) {
    if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
      exit[i2] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value2, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value2 !== "function") value2 = constant$2(value2);
  for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value2.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge[i2] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; ) {
    for (var group = groups[j2], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
      if (node = group[i2]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare2) {
  if (!compare2) compare2 = ascending$1;
  function compareNode(a2, b2) {
    return a2 && b2 ? compare2(a2.__data__, b2.__data__) : !a2 - !b2;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, sortgroup = sortgroups[j2] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
      if (node = group[i2]) {
        sortgroup[i2] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending$1(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
    for (var group = groups[j2], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node = group[i2];
      if (node) return node;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
    for (var group = groups[j2], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
      if (node = group[i2]) callback.call(node, node.__data__, i2, group);
    }
  }
  return this;
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value2) {
  return function() {
    this.setAttribute(name, value2);
  };
}
function attrConstantNS(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction(name, value2) {
  return function() {
    var v2 = value2.apply(this, arguments);
    if (v2 == null) this.removeAttribute(name);
    else this.setAttribute(name, v2);
  };
}
function attrFunctionNS(fullname, value2) {
  return function() {
    var v2 = value2.apply(this, arguments);
    if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name, value2) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value2 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value2));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value2, priority) {
  return function() {
    this.style.setProperty(name, value2, priority);
  };
}
function styleFunction(name, value2, priority) {
  return function() {
    var v2 = value2.apply(this, arguments);
    if (v2 == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v2, priority);
  };
}
function selection_style(name, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove : typeof value2 === "function" ? styleFunction : styleConstant)(name, value2, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value2) {
  return function() {
    this[name] = value2;
  };
}
function propertyFunction(name, value2) {
  return function() {
    var v2 = value2.apply(this, arguments);
    if (v2 == null) delete this[name];
    else this[name] = v2;
  };
}
function selection_property(name, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 >= 0) {
      this._names.splice(i2, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i2 = -1, n2 = names.length;
  while (++i2 < n2) list.add(names[i2]);
}
function classedRemove(node, names) {
  var list = classList(node), i2 = -1, n2 = names.length;
  while (++i2 < n2) list.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value2) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i2 = -1, n2 = names.length;
    while (++i2 < n2) if (!list.contains(names[i2])) return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}
function textRemove() {
  this.textContent = "";
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var v2 = value2.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function selection_text(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction : textConstant)(value2)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v2 = value2.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function selection_html(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2) return;
    for (var j2 = 0, i2 = -1, m2 = on2.length, o2; j2 < m2; ++j2) {
      if (o2 = on2[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on2[++i2] = o2;
      }
    }
    if (++i2) on2.length = i2;
    else delete this.__on;
  };
}
function onAdd(typename, value2, options) {
  return function() {
    var on2 = this.__on, o2, listener = contextListener(value2);
    if (on2) for (var j2 = 0, m2 = on2.length; j2 < m2; ++j2) {
      if ((o2 = on2[j2]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
        o2.value = value2;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o2 = { type: typename.type, name: typename.name, value: value2, listener, options };
    if (!on2) this.__on = [o2];
    else on2.push(o2);
  };
}
function selection_on(typename, value2, options) {
  var typenames = parseTypenames(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) for (var j2 = 0, m2 = on2.length, o2; j2 < m2; ++j2) {
      for (i2 = 0, o2 = on2[j2]; i2 < n2; ++i2) {
        if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on2 = value2 ? onAdd : onRemove;
  for (i2 = 0; i2 < n2; ++i2) this.each(on2(typenames[i2], value2, options));
  return this;
}
function dispatchEvent(node, type3, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type3, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type3, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type3, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params);
  };
}
function dispatchFunction(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params.apply(this, arguments));
  };
}
function selection_dispatch(type3, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type3, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
    for (var group = groups[j2], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
      if (node = group[i2]) yield node;
    }
  }
}
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection_selection() {
  return this;
}
Selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root);
}
function selectAll(selector2) {
  return typeof selector2 === "string" ? new Selection([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection([array(selector2)], root);
}
function ascending(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function descending(a2, b2) {
  return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
}
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x2) => ascending(f2(d2), x2);
    delta = (d2, x2) => f2(d2) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero$1;
    compare2 = f2;
    delta = f2;
  }
  function left2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a2, x2, lo = 0, hi = a2.length) {
    const i2 = left2(a2, x2, lo, hi - 1);
    return i2 > lo && delta(a2[i2 - 1], x2) > -delta(a2[i2], x2) ? i2 - 1 : i2;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$1() {
  return 0;
}
function number$2(x2) {
  return x2 === null ? NaN : +x2;
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse) {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) * inc;
  } else {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r, g2, b2, a2) {
  if (a2 <= 0) r = g2 = b2 = NaN;
  return new Rgb(r, g2, b2, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb$1(r, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r, g2, b2, opacity) {
  this.r = +r;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0) h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
  else if (s2 <= 0) h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r, g2, b2), max2 = Math.max(r, g2, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r === max2) h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max2) h2 = (b2 - r) / s2 + 2;
    else h2 = (r - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$1 = (x2) => () => x2;
function linear$1(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant$1(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear$1(a2, d2) : constant$1(isNaN(a2) ? b2 : a2);
}
const rgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g2 = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t2) {
      start.r = r(t2);
      start.g = g2(t2);
      start.b = b2(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a2, b2) {
  if (!b2) b2 = [];
  var n2 = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2) c2[i2] = a2[i2] * (1 - t2) + b2[i2] * t2;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2) x2[i2] = interpolate(a2[i2], b2[i2]);
  for (; i2 < nb; ++i2) c2[i2] = b2[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2) c2[i2] = x2[i2](t2);
    return c2;
  };
}
function date(a2, b2) {
  var d2 = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
  };
}
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
function object(a2, b2) {
  var i2 = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b2 === null || typeof b2 !== "object") b2 = {};
  for (k2 in b2) {
    if (k2 in a2) {
      i2[k2] = interpolate(a2[k2], b2[k2]);
    } else {
      c2[k2] = b2[k2];
    }
  }
  return function(t2) {
    for (k2 in i2) c2[k2] = i2[k2](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function string(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2]) s2[i2] += bm;
      else s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s2[i2]) s2[i2] += bs;
    else s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
function interpolate(a2, b2) {
  var t2 = typeof b2, c2;
  return b2 == null || t2 === "boolean" ? constant$1(b2) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb) : string : b2 instanceof color ? rgb : b2 instanceof Date ? date : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : interpolateNumber)(a2, b2);
}
function interpolateRound(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return Math.round(a2 * (1 - t2) + b2 * t2);
  };
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$2(x2) {
  return x2;
}
function normalize(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t2;
  if (a2 > b2) t2 = a2, a2 = b2, b2 = t2;
  return function(x2) {
    return Math.max(a2, Math.min(b2, x2));
  };
}
function bimap(domain, range, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range, interpolate2) {
  var j2 = Math.min(domain.length, range.length) - 1, d2 = new Array(j2), r = new Array(j2), i2 = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i2 < j2) {
    d2[i2] = normalize(domain[i2], domain[i2 + 1]);
    r[i2] = interpolate2(range[i2], range[i2 + 1]);
  }
  return function(x2) {
    var i3 = bisectRight(domain, x2, 1, j2) - 1;
    return r[i3](d2[i3](x2));
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$1() {
  var domain = unit, range = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp = identity$2, piecewise, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range.length);
    if (clamp !== identity$2) clamp = clamper(domain[0], domain[n2 - 1]);
    piecewise = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number$1), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range = Array.from(_2), rescale()) : range.slice();
  };
  scale.rangeRound = function(_2) {
    return range = Array.from(_2), interpolate$1 = interpolateRound, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? true : identity$2, rescale()) : clamp !== identity$2;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate$1 = _2, rescale()) : interpolate$1;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2, u2) {
    transform = t2, untransform = u2;
    return rescale();
  };
}
function continuous() {
  return transformer$1()(identity$2, identity$2);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i2 = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
  var i2, coefficient = x2.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i2 + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value2, width) {
    var i2 = value2.length, t2 = [], j2 = 0, g2 = grouping[0], length = 0;
    while (i2 > 0 && g2 > 0) {
      if (length + g2 + 1 > width) g2 = Math.max(1, width - length);
      t2.push(value2.substring(i2 -= g2, i2 + g2));
      if ((length += g2 + 1) > width) break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out: for (var n2 = s2.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
    switch (s2[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s2[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2) return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i2 - 1))[0];
}
function formatRounded(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2) return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded(x2 * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$1(x2) {
  return x2;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$1 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$1 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type3 = specifier.type;
    if (type3 === "n") comma = true, type3 = "g";
    else if (!formatTypes[type3]) precision === void 0 && (precision = 12), trim = true, type3 = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
    var formatType = formatTypes[type3], maybeSuffix = /[defgprs%]/.test(type3);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n2, c2;
      if (type3 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim(value2);
        if (valueNegative && +value2 === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type3 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value2.length;
          while (++i2 < n2) {
            if (c2 = value2.charCodeAt(i2), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value2.slice(i2 + 1) : value2.slice(i2)) + valueSuffix;
              value2 = value2.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value2 = group(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value2 = group(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f2(k2 * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value2))) specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d2 = domain();
    return ticks(d2[0], d2[d2.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d2 = domain();
    return tickFormat(d2[0], d2[d2.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null) count = 10;
    var d2 = domain();
    var i0 = 0;
    var i1 = d2.length - 1;
    var start = d2[i0];
    var stop = d2[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d2[i0] = start;
        d2[i1] = stop;
        return domain(d2);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy$1(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function transformer() {
  var x0 = 0, x1 = 1, t0, t1, k10, transform, interpolator = identity$2, clamp = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t0) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x0, x1] = _2, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  function range(interpolate2) {
    return function(_2) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _2, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range(interpolate);
  scale.rangeRound = range(interpolateRound);
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t2) {
    transform = t2, t0 = t2(x0), t1 = t2(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer()(identity$2));
  scale.copy = function() {
    return copy(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function identity(x2) {
  return x2;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon$2 = 1e-6;
function translateX(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number(scale) {
  return (d2) => +scale(d2);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return (d2) => +scale(d2) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + offset, range1 = +range[range.length - 1] + offset, position = (scale.bandwidth ? center : number)(scale.copy(), offset), selection = context.selection ? context.selection() : context, path2 = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$2).attr("transform", function(d2) {
        return isFinite(d2 = position(d2)) ? transform(d2 + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$2).attr("transform", function(d2) {
        var p2 = this.parentNode.__axis;
        return transform((p2 && isFinite(p2 = p2(d2)) ? p2 : position(d2)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d2) {
      return transform(position(d2) + offset);
    });
    line.attr(x2 + "2", k2 * tickSizeInner);
    text.attr(x2, k2 * spacing).text(format2);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_2) {
    return arguments.length ? (scale = _2, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
  };
  axis2.offset = function(_2) {
    return arguments.length ? (offset = +_2, axis2) : offset;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
const pi$1 = Math.PI, tau$1 = 2 * pi$1, epsilon$1 = 1e-6, tauEpsilon = tau$1 - epsilon$1;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
      this._ += Math.round(arguments[i2] * k2) / k2 + strings[i2];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon$1)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._append`L${x0},${y0}`;
    }
    if (!r) return;
    if (da < 0) da = da % tau$1 + tau$1;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon$1) {
      this._append`A${r},${r},0,${+(da >= pi$1)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
}
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function constant(x2) {
  return function constant2() {
    return x2;
  };
}
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;
const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_2) {
    if (!arguments.length) return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d2 = Math.floor(_2);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
      digits = d2;
    }
    return shape;
  };
  return () => new Path(digits);
}
function arcInnerRadius(d2) {
  return d2.innerRadius;
}
function arcOuterRadius(d2) {
  return d2.outerRadius;
}
function arcStartAngle(d2) {
  return d2.startAngle;
}
function arcEndAngle(d2) {
  return d2.endAngle;
}
function arcPadAngle(d2) {
  return d2 && d2.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t2 = y32 * x10 - x32 * y10;
  if (t2 * t2 < epsilon) return;
  t2 = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t2;
  return [x0 + t2 * x10, y0 + t2 * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d4 = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d4) / d2, cy0 = (-D2 * dx - dy * d4) / d2, cx1 = (D2 * dy + dx * d4) / d2, cy1 = (-D2 * dx + dy * d4) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc2);
  function arc2() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc2 = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min(rc, (r0 - lc2) / (kc - 1));
            rc1 = min(rc, (r1 - lc2) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc2.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant(+_2), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant(+_2), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant(+_2), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant(+_2), arc2) : padRadius;
  };
  arc2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant(+_2), arc2) : startAngle;
  };
  arc2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant(+_2), arc2) : endAngle;
  };
  arc2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant(+_2), arc2) : padAngle;
  };
  arc2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc2) : context;
  };
  return arc2;
}
const circle = {
  draw(context, size) {
    const r = sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};
const symbolSquare = {
  draw(context, size) {
    const w2 = sqrt(size);
    const x2 = -w2 / 2;
    context.rect(x2, x2, w2, w2);
  }
};
const sqrt3 = sqrt(3);
const symbolTriangle = {
  draw(context, size) {
    const y2 = -sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
function Symbol$1(type3, size) {
  let context = null, path2 = withPath(symbol);
  type3 = typeof type3 === "function" ? type3 : constant(type3 || circle);
  size = typeof size === "function" ? size : constant(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path2();
    type3.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_2) {
    return arguments.length ? (type3 = typeof _2 === "function" ? _2 : constant(_2), symbol) : type3;
  };
  symbol.size = function(_2) {
    return arguments.length ? (size = typeof _2 === "function" ? _2 : constant(+_2), symbol) : size;
  };
  symbol.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, symbol) : context;
  };
  return symbol;
}
const d3 = {
  precisionFixed,
  format,
  select,
  selectAll,
  scaleLinear: linear,
  scaleSequential: sequential,
  axisTop,
  axisBottom,
  axisRight,
  axisLeft,
  symbol: Symbol$1,
  path,
  arc,
  symbolTriangle,
  symbolSquare
};
function isHexColor(hex2) {
  return typeof hex2 === "string" && hex2.length === 6 && !isNaN(Number("0x" + hex2.replace("#", "")));
}
class Vis {
  constructor({
    elementID,
    env = "production",
    main = true,
    units = "decimal",
    decimalPlaces = 2,
    fractionRoundTo = 0,
    saw = null,
    app = false,
    embed = false,
    height = 0,
    width = 0,
    flipY = false,
    flipX = false,
    colors = {
      partA: "#1d9bc4",
      partB: "#127da1",
      partHover: "#29c778",
      partSelected: "#1bc319",
      stock: "#ffd166",
      text: "#ffffff"
    },
    options = {
      disableClick: false,
      enableStretch: true
    },
    vueComponent
  }) {
    __publicField(this, "env");
    __publicField(this, "main");
    //is this the main vis or not
    __publicField(this, "units", "decimal");
    __publicField(this, "decimalPlaces");
    __publicField(this, "fractionRoundTo");
    __publicField(this, "formatNumber", (val) => {
      return convertUnit(
        val,
        this.units,
        this.decimalPlaces ?? 2,
        false,
        this.fractionRoundTo ?? 0
      ).toString();
    });
    __publicField(this, "saw");
    __publicField(this, "stockType");
    __publicField(this, "numUniqueShapes");
    __publicField(this, "app");
    __publicField(this, "embed");
    __publicField(this, "height");
    __publicField(this, "width");
    __publicField(this, "device");
    __publicField(this, "vueComponent");
    __publicField(this, "elWidth");
    __publicField(this, "elHeight");
    __publicField(this, "w");
    __publicField(this, "h");
    __publicField(this, "padding");
    __publicField(this, "mobileBreakpoint");
    //scales
    __publicField(this, "xScale", d3.scaleLinear());
    __publicField(this, "yScale", d3.scaleLinear());
    __publicField(this, "yPositionScale", d3.scaleLinear());
    __publicField(this, "xPositionScale", d3.scaleLinear());
    __publicField(this, "yAxisScale", d3.scaleLinear());
    __publicField(this, "measurementScale", d3.scaleLinear());
    __publicField(this, "xAxis");
    __publicField(this, "yAxis");
    __publicField(this, "stretched");
    __publicField(this, "shapeXAxis");
    __publicField(this, "shapeYAxis");
    __publicField(this, "cutMeasurementXAxes");
    __publicField(this, "cutMeasurementYAxes");
    __publicField(this, "axisSpacing");
    __publicField(this, "flipY");
    __publicField(this, "flipX");
    __publicField(this, "colors");
    __publicField(this, "options");
    __publicField(this, "moveMode");
    __publicField(this, "moveRotation");
    __publicField(this, "moving");
    __publicField(this, "shape");
    __publicField(this, "shapeColorScale");
    __publicField(this, "scoreColorScale");
    __publicField(this, "hasTouch");
    __publicField(this, "highlightguillotine");
    __publicField(this, "debug", "");
    //groups | guillotine | positions
    __publicField(this, "elementID");
    //the id of the element to draw the vis in
    __publicField(this, "el");
    __publicField(this, "htmlEl");
    __publicField(this, "svgCanvas");
    __publicField(this, "axisGroup");
    __publicField(this, "stockGroup");
    __publicField(this, "stockWrappers");
    __publicField(this, "stock");
    __publicField(this, "shapeGroup");
    __publicField(this, "shapeWrappers");
    __publicField(this, "shapes");
    __publicField(this, "shapeIDText");
    __publicField(this, "shapeNameText");
    __publicField(this, "shapeLengthText");
    __publicField(this, "shapeWidthText");
    __publicField(this, "groupGroup");
    __publicField(this, "groups");
    __publicField(this, "bandingGroup");
    __publicField(this, "bandingWrappers");
    __publicField(this, "banding");
    __publicField(this, "segmentGroup");
    __publicField(this, "segments");
    __publicField(this, "segment");
    __publicField(this, "positionGroup");
    __publicField(this, "position");
    __publicField(this, "dotGroup");
    __publicField(this, "placementPositionGroup");
    __publicField(this, "dot");
    __publicField(this, "cutGroup");
    __publicField(this, "cuts");
    __publicField(this, "cut");
    if (!elementID) throw new Error("elementID is required");
    this.el = d3.select(elementID);
    if (this.el === null) return;
    const htmlElement = this.el.node();
    if (htmlElement === null) return;
    this.htmlEl = htmlElement;
    this.vueComponent = vueComponent;
    this.env = getData.call(this.vueComponent, ["env"]) === "development" ? "development" : "production";
    this.debug = this.env === "development" ? "groups" : "";
    this.app = app ? app : false;
    this.embed = embed ? embed : false;
    this.height = height;
    this.width = width;
    this.device = app ? "app" : "desktop";
    this.stretched = false;
    this.elWidth = this.htmlEl.offsetWidth;
    this.elHeight = this.htmlEl.offsetHeight;
    this.w = 0;
    this.h = 0;
    this.padding = 0;
    this.mobileBreakpoint = 450;
    this.main = main;
    this.saw = saw;
    this.cutMeasurementXAxes = [];
    this.cutMeasurementYAxes = [];
    this.axisSpacing = 16;
    this.flipY = flipY;
    this.flipX = flipX;
    colors = {
      ...colors
    };
    for (const [key, value2] of Object.entries(colors)) {
      if (value2) colors[key] = value2.replace("#", "");
    }
    this.colors = {
      partA: isHexColor(colors == null ? void 0 : colors.partA) ? rgb$1("#" + colors.partA) : rgb$1("#1d9bc4"),
      partB: isHexColor(colors == null ? void 0 : colors.partB) ? rgb$1("#" + colors.partB) : rgb$1("#127da1"),
      partHover: isHexColor(colors == null ? void 0 : colors.partHover) ? rgb$1("#" + colors.partHover) : rgb$1("#29c778"),
      partSelected: isHexColor(colors == null ? void 0 : colors.partSelected) ? rgb$1("#" + colors.partSelected) : rgb$1("#1bc319"),
      stock: isHexColor(colors == null ? void 0 : colors.stock) ? rgb$1("#" + colors.stock) : rgb$1("#ffd166"),
      text: isHexColor(colors == null ? void 0 : colors.text) ? rgb$1("#" + colors.text) : rgb$1("#ffffff")
    };
    this.shapeColorScale = d3.scaleSequential([
      this.colors.partA,
      this.colors.partB
    ]);
    this.env = env;
    this.moveMode = false;
    this.moving = false;
    this.moveRotation = false;
    this.units = units;
    this.decimalPlaces = decimalPlaces;
    this.fractionRoundTo = fractionRoundTo;
    this.hasTouch = false;
    this.options = options;
    this.init();
  }
  /**
      * sets up the various wrappers - only needs to be called once
      * the z index is set by the order drawn
      */
  init() {
    if (!this.el) return false;
    if (this.decimalPlaces === null || this.decimalPlaces === void 0 || isNaN(this.decimalPlaces))
      this.decimalPlaces = 2;
    if (this.fractionRoundTo === null || this.fractionRoundTo === void 0 || isNaN(this.fractionRoundTo))
      this.fractionRoundTo = 0;
    if (!this.svgCanvas) {
      const svgElement = this.htmlEl.querySelector("svg");
      if (svgElement === null) {
        const svg = this.el.append("svg").attr("class", "vis");
        if (svg === null) return;
        svg.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").attr("id", "stripes").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1");
        svg.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(90)").attr("id", "grain-l").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1");
        svg.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("id", "grain-w").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1");
        this.svgCanvas = svg;
      }
      this.axisGroup = this.svgCanvas.append("g").attr("class", "axis-group");
      this.stockGroup = this.svgCanvas.append("g").attr("class", "stock-group");
      this.shapeGroup = this.svgCanvas.append("g").attr("class", "shapes");
      this.bandingGroup = this.svgCanvas.append("g").attr("class", "banding-group");
      this.segmentGroup = this.svgCanvas.append("g").attr("class", "segments").attr("display", "none");
      this.groupGroup = this.svgCanvas.append("g").attr("class", "groups").attr("display", "none");
      this.positionGroup = this.svgCanvas.append("g").attr("class", "positions");
      this.dotGroup = this.svgCanvas.append("g").attr("class", "dots");
      if (this.env === "development") {
        this.placementPositionGroup = this.svgCanvas.append("g").attr("class", "placements");
      }
      this.cutGroup = this.svgCanvas.append("g").attr("class", "cuts");
    }
    if (this.elWidth > 0) this.updateSize(true);
    this.hasTouch = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
  updateUnits(newUnits, decimalPlaces, fractionRoundTo) {
    if (newUnits) this.units = newUnits;
    if (decimalPlaces) this.decimalPlaces = decimalPlaces;
    if (fractionRoundTo) this.fractionRoundTo = fractionRoundTo;
    this.refreshShapes();
    this.refreshStock();
  }
  trimNameToFit(shapes, vis) {
    function trim(shape, index, items) {
      const item = items[index];
      const self2 = d3.select(item);
      self2.text(shape.name);
      let text = self2.text();
      const node = self2.node();
      if (!node) return;
      let textLength = node.getComputedTextLength();
      const space = this.getWidthAttribute(shape) - 20;
      while (textLength > space && text.length > 0) {
        text = text.slice(0, -1);
        self2.text(text.length ? text + "..." : "");
        textLength = self2.node().getComputedTextLength();
      }
    }
    shapes.each(trim.bind(vis));
  }
  getShapeColor(shape) {
    var _a3;
    if (this.env === "development") {
      switch (this.debug) {
        case "guillotine":
          if (shape.guillotineData.firstShape) {
            return rgb$1(252, 3, 182);
          }
          if (shape.addedAsGroup) {
            return rgb$1(43, 156, 16);
          }
          if (typeof shape.guillotineData.myPhase === "number") {
            const startColor = [0, 115, 255];
            const endColor = [176, 255, 231];
            const color2 = startColor.map((start, i2) => {
              return Math.round(start + shape.guillotineData.myPhase / 5 * (endColor[i2] - start));
            });
            return `rgb(${color2.join(",")})`;
          }
          break;
        case "groups":
          if (shape.addedAsGroup !== false) {
            return rgb$1(43, 156, 16);
          }
          break;
        case "priorityShapes":
          if ((shape == null ? void 0 : shape.priority) && ((_a3 = shape.priority) == null ? void 0 : _a3[shape.stock.parentID])) {
            return rgb$1(139, 171, 46);
          }
          break;
        case "score":
          return this.scoreColorScale(shape.bestScore.total);
      }
    }
    return this.shapeColorScale(shape.parentID - 1);
  }
  setDevice() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    if (!this.htmlEl.offsetWidth) return;
    this.elWidth = this.htmlEl.offsetWidth;
    this.elHeight = this.htmlEl.offsetHeight;
    if (this.elWidth === 0) return false;
    if (!this.main) {
      this.padding = 0;
    } else {
      if (this.elWidth <= this.mobileBreakpoint || this.app) {
        this.device = "mobile";
        this.padding = 0;
      } else {
        this.device = "desktop";
        this.padding = 50;
      }
    }
    this.w = this.elWidth;
  }
  //find the largest dimensions of all the stock (not just the active one)
  findLargestStockDimensions() {
    const stockList = getData.call(this.vueComponent, ["stockList"]).filter((s2) => s2.used);
    if (!(stockList == null ? void 0 : stockList.length)) return [null, null];
    const longestStock = stockList.reduce((prev, current) => prev.l > current.l ? prev : current);
    const widestStock = stockList.reduce((prev, current) => prev.w > current.w ? prev : current);
    return [longestStock, widestStock];
  }
  debounce(func, wait, immediate = false) {
    let timeout;
    return (...args) => {
      return new Promise((resolve) => {
        const later = () => {
          timeout = null;
          if (!immediate) {
            resolve(func.apply(this, args));
          }
        };
        clearTimeout(timeout);
        if (immediate) {
          const callNow = !timeout;
          if (callNow) resolve(func.apply(this, args));
        }
        timeout = setTimeout(later, wait);
      });
    };
  }
  updateSize(immediate = false) {
    return this.debounce(this._updateSize.bind(this), 10, immediate)();
  }
  requiresStretch(activeStock, aspectRatio = null) {
    if (!activeStock) return false;
    if (aspectRatio === null) aspectRatio = activeStock.w / activeStock.l;
    if (aspectRatio < 0.15) return true;
    return false;
  }
  setAspectRatio(activeStock) {
    if (activeStock) {
      this.w = this.elWidth;
      const aspectRatio = activeStock.w / activeStock.l;
      this.xScale.domain([0, activeStock.l]).range([this.padding, this.w - this.padding]);
      if (this.requiresStretch(activeStock, aspectRatio) && this.options.enableStretch) {
        this.h = this.htmlEl.clientWidth * 0.15 + this.padding * 2;
        this.stretched = true;
      } else {
        this.h = this.xScale(activeStock.getShortSide()) + this.padding;
        this.stretched = false;
      }
      this.yScale.domain([0, activeStock.w]).range([this.padding, this.h - this.padding]);
      this.yAxisScale.domain(this.flipY ? [0, activeStock.w] : [activeStock.w, 0]).range([this.padding, this.h - this.padding]);
      this.yPositionScale.domain([0, activeStock.w]).range(this.flipY ? [this.padding, this.h - this.padding] : [this.h - this.padding, this.padding]);
      if (aspectRatio > 2) {
        this.w = this.htmlEl.clientWidth / aspectRatio + this.padding * 2;
        this.xScale.domain([0, activeStock.l]).range([this.padding, this.w - this.padding]);
        this.h = this.xScale(activeStock.getShortSide()) + this.padding;
      }
      this.xPositionScale.domain([0, activeStock.l]).range(this.flipX ? [this.w - this.padding, this.padding] : [this.padding, this.w - this.padding]);
      this.measurementScale.domain([0, activeStock.l]).range([0, this.w - this.padding * 2]);
      if (this.w > 0 && this.h > 0) {
        if (aspectRatio > 2) this.el.style("width", this.w + "px");
        else this.el.style("width", "");
        this.el.style("height", this.h + "px");
      }
    }
  }
  _updateSize() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    if (this.vueComponent && "suppressResizeObserver" in this.vueComponent) {
      this.vueComponent.suppressResizeObserver = true;
    }
    const stockList = getData.call(this.vueComponent, ["stockList"]);
    const shapeList = getData.call(this.vueComponent, ["shapeList"]);
    if (!(stockList == null ? void 0 : stockList.length) || !(shapeList == null ? void 0 : shapeList.length)) return false;
    this.setDevice();
    this.refreshStock();
    this.refreshShapes();
    if (this.env === "development") {
      this.refreshPlacementPositions();
    }
  }
  refreshCuts() {
    const activeCuts = getData.call(this.vueComponent, ["activeCuts"]);
    this.resetSegments();
    this.initCuts(activeCuts);
  }
  refreshStock() {
    const stockList = getData.call(this.vueComponent, ["stockList"]);
    if (!(stockList == null ? void 0 : stockList.length)) return false;
    const activeStock = getData.call(this.vueComponent, ["activeStock"]);
    this.initStock(activeStock);
    this.refreshCuts();
    const activeSegments = getData.call(this.vueComponent, ["activeSegments"]);
    this.initSegments(activeSegments);
    this.resetPositions();
    if (typeof this.vueComponent.toggleSegments === "function")
      this.vueComponent.toggleSegments(false);
  }
  refreshShapes() {
    const shapeList = getData.call(this.vueComponent, ["shapeList"]);
    if (!(shapeList == null ? void 0 : shapeList.length)) return false;
    this.resetPositions();
    const activeShapes = getData.call(this.vueComponent, ["activeShapes"]);
    this.initShapes(activeShapes, shapeList);
  }
  refreshPlacementPositions() {
    const placementPositions = getData.call(this.vueComponent, ["placementPositions"]);
    if (!(placementPositions == null ? void 0 : placementPositions.length)) return false;
    this.resetPlacementPositions();
    const activePositions = placementPositions.filter((p2) => p2.stockID === getData.call(this.vueComponent, ["activeStock"]).id);
    this.initPlacementPositions(activePositions);
  }
  recreateUerGroups(activeShapes) {
    activeShapes.filter((s2) => s2.inUserGroup);
    const groupedShapes = [];
    for (let i2 = 0; i2 < activeShapes.length; i2++) {
      const shape = activeShapes[i2];
      const groupId = shape.addedAsGroup;
      const groupShapes = activeShapes.filter((s2) => s2.addedAsGroup === groupId);
      groupedShapes.push(groupShapes);
      i2 += groupShapes.length;
    }
    const groups = [];
    groupedShapes.forEach((gs) => {
      const x2 = Math.min(...gs.map((s2) => s2.x));
      const y2 = Math.min(...gs.map((s2) => s2.y));
      const l2 = Math.max(...gs.map((s2) => s2.x + s2.l)) - x2;
      const w2 = Math.max(...gs.map((s2) => s2.y + s2.w)) - y2;
      const group = {
        x: x2,
        y: y2,
        l: l2,
        w: w2,
        shapes: gs
      };
      groups.push(group);
    });
    this.initGroups(groups);
  }
  //init or update the stock
  initStock(activeStock) {
    this.resetStock();
    this.setAspectRatio(activeStock);
    if (!activeStock || !(activeStock == null ? void 0 : activeStock.w) || !(activeStock == null ? void 0 : activeStock.l) || !this.elWidth)
      return false;
    this.stockType = activeStock.type;
    let stock;
    if (typeof activeStock === "object") stock = [activeStock];
    if (this.device === "desktop") {
      if (this.main) {
        this.xAxis = this.axisGroup.append("g").attr("transform", `translate(0, ${this.padding})`).attr("class", "axis stock x").call(d3.axisTop(this.xScale).ticks(5).tickSize(5)).selectAll("text").attr("dy", -5);
        const requiresStretch = this.requiresStretch(activeStock);
        if (!requiresStretch || requiresStretch && this.stretched) {
          this.yAxis = this.axisGroup.append("g").attr(
            "transform",
            `translate(${this.w - this.padding}, 0)`
          ).attr("class", "axis stock y").call(d3.axisRight(this.yAxisScale).ticks(5).tickSize(5)).selectAll("text").attr("dx", 5);
        }
      }
    }
    this.stockGroup.data(stock).attr(
      "transform",
      () => `translate(${this.padding},${this.padding})`
    );
    this.stockGroup.append("rect").attr("class", "background stock").style("fill", this.colors.stock).attr("width", (s2) => this.getWidthAttribute(s2)).attr("height", (s2) => this.getHeightAttribute(s2)).attr("x", (s2) => {
      s2.x = 0;
      const original = s2.x;
      s2.x = 0;
      const pos = this.getRectangleCoordinate(s2, "x") - this.padding;
      s2.x = original;
      return pos;
    }).attr("y", (s2) => {
      s2.y = 0;
      const original = s2.y;
      s2.y = 0;
      const pos = this.getRectangleCoordinate(s2, "y") - this.padding;
      s2.y = original;
      return pos;
    });
    this.stock = this.stockGroup.append("rect").attr("width", (s2) => this.getWidthAttribute(s2)).attr("height", (s2) => this.getHeightAttribute(s2)).attr(
      "x",
      (s2) => this.getRectangleCoordinate(s2, "x") - this.padding
    ).attr(
      "y",
      (s2) => this.getRectangleCoordinate(s2, "y") - this.padding
    ).attr("class", "stock-pattern").style("fill", (s2) => (s2 == null ? void 0 : s2.grain) ? `url(#grain-${s2.grain.toLowerCase()})` : "url(#stripes)");
  }
  getWidthAttribute(item) {
    return this.xScale(item.l) - this.padding;
  }
  getHeightAttribute(item) {
    return this.yScale(item.w) - this.padding;
  }
  //init or update the shapes
  initShapes(shapeList, allShapes) {
    var _a3, _b2, _c;
    this.resetShapes();
    if (!shapeList || !shapeList.length || !this.elWidth) return;
    this.numUniqueShapes = allShapes.filter((shape) => !shape.duplicate).length;
    this.shapeColorScale.domain([0, this.numUniqueShapes]);
    if ((_a3 = this == null ? void 0 : this.vueComponent) == null ? void 0 : _a3.gs) {
      setData.call(this.vueComponent, ["shapeColors"], {});
      for (let i2 = shapeList.length; i2--; ) {
        const s2 = shapeList[i2];
        if (s2.parentID && getData.call(this.vueComponent, ["shapeColors", s2.parentID]))
          continue;
        if (s2.parentID) {
          setData.call(this.vueComponent, ["shapeColors", s2.parentID], color(this.shapeColorScale(parseInt(s2.parentID) - 1)).formatHex());
        }
      }
    }
    if (this.env === "development") {
      let initialMin = Infinity;
      let initialMax = -Infinity;
      for (const shape of shapeList) {
        const score = (_b2 = shape == null ? void 0 : shape.bestScore) == null ? void 0 : _b2.total;
        if (score !== 0 && score !== null && score !== void 0) {
          initialMin = score;
          initialMax = score;
          break;
        }
      }
      const minBestScore = shapeList.reduce((min2, shape) => {
        var _a4;
        const score = (_a4 = shape == null ? void 0 : shape.bestScore) == null ? void 0 : _a4.total;
        if (score === 0 || score === null || score === void 0)
          return min2;
        return score < min2 ? score : min2;
      }, initialMin);
      const maxBestScore = shapeList.reduce((max2, shape) => {
        var _a4;
        const score = (_a4 = shape == null ? void 0 : shape.bestScore) == null ? void 0 : _a4.total;
        if (score === null || score === void 0) return max2;
        return score > max2 ? score : max2;
      }, initialMax);
      this.scoreColorScale = d3.scaleSequential([rgb$1(251, 224, 255), rgb$1(122, 0, 138)]).domain([minBestScore, maxBestScore]);
    }
    if (!shapeList || !shapeList.length) return false;
    this.shapeWrappers = this.shapeGroup.selectAll("g").data(shapeList).join("g").attr("class", "shape-group");
    if (!this.shapeWrappers.size()) return false;
    this.shapes = this.shapeWrappers.append("rect").attr("class", "shape").attr("fill", (s2) => this.getShapeColor(s2)).attr("stroke-width", () => this.env === "development" ? 3 : 0).attr("width", (s2) => this.getWidthAttribute(s2)).attr("height", (s2) => this.getHeightAttribute(s2));
    if (this.main) {
      const bandingData = [];
      shapeList.forEach((shape) => {
        if (shape == null ? void 0 : shape._banding) {
          for (const [key, value2] of Object.entries(shape._banding)) {
            if (!value2) continue;
            if (["a", "b", "c", "d"].includes(key)) continue;
            let side = key;
            if (shape.rot) {
              switch (key) {
                case "x1":
                  side = "y1";
                  break;
                case "x2":
                  side = "y2";
                  break;
                case "y1":
                  side = "x2";
                  break;
                case "y2":
                  side = "x1";
                  break;
              }
            }
            switch (side) {
              case "x1":
                bandingData.push({
                  x1: shape.x,
                  x2: shape.x,
                  y1: shape.y,
                  y2: shape.y + shape.w,
                  type: "x1"
                });
                break;
              case "x2":
                bandingData.push({
                  x1: shape.x + shape.l,
                  x2: shape.x + shape.l,
                  y1: shape.y,
                  y2: shape.y + shape.w,
                  type: "x2"
                });
                break;
              case "y1":
                bandingData.push({
                  x1: shape.x,
                  x2: shape.x + shape.l,
                  y1: shape.y,
                  y2: shape.y,
                  type: "y1"
                });
                break;
              case "y2":
                bandingData.push({
                  x1: shape.x,
                  x2: shape.x + shape.l,
                  y1: shape.y + shape.w,
                  y2: shape.y + shape.w,
                  type: "y2"
                });
                break;
            }
          }
        }
      });
      this.bandingWrappers = this.bandingGroup.selectAll("g").data(bandingData).join("line").attr("class", "banding").attr(
        "x1",
        (d2) => this.xPositionScale(d2.x1) + this.getBandingAdjustment(d2.type, "x")
      ).attr(
        "x2",
        (d2) => this.xPositionScale(d2.x2) + this.getBandingAdjustment(d2.type, "x")
      ).attr(
        "y1",
        (d2) => this.yPositionScale(d2.y1) + this.getBandingAdjustment(d2.type, "y")
      ).attr(
        "y2",
        (d2) => this.yPositionScale(d2.y2) + this.getBandingAdjustment(d2.type, "y")
      ).attr("stroke-width", 2).attr("stroke", "white");
      this.shapeIDText = this.shapeWrappers.append("text").attr("class", "shape-text id").text((shape) => {
        var _a4, _b3;
        if (this.env === "development") {
          switch (this.debug) {
            case "guillotine": {
              const stripDirection = shape.guillotineData.myStripDirection;
              const group = shape.addedAsGroup;
              let shapeText = "";
              if (stripDirection === "l") {
                shapeText = `→ ${shape.parentID}`;
              } else if (stripDirection === "w") {
                shapeText = `↑ ${shape.parentID}`;
              }
              if ((_b3 = shape == null ? void 0 : shape.priotity) == null ? void 0 : _b3[(_a4 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a4.parentID]) {
                shapeText += "P";
              }
              if (group) shapeText += "G";
              if (shapeText.length) return shapeText;
              return this.shapeNameText;
            }
            case "groups":
              {
                const group = shape.addedAsGroup;
                if (group) return group.split(".")[0].toUpperCase();
              }
              break;
            case "positions":
              return shape.id;
          }
        }
        return shape.parentID ? shape.parentID : shape.getParentID();
      }).classed("hidden", (shape, b2, c2) => {
        const bbox = c2[b2].getBBox();
        if (bbox.width >= this.measurementScale(shape.l))
          return true;
        if (bbox.height >= this.yScale(shape.w) - this.padding)
          return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      this.shapeNameText = this.shapeWrappers.append("text").attr("class", "shape-text name").text((shape) => {
        if (!(shape == null ? void 0 : shape.name)) return null;
        if (typeof (shape == null ? void 0 : shape.name) !== "string") return null;
        const result = shape.name.toUpperCase().trim();
        return result;
      }).call(this.trimNameToFit, this).classed("hidden", (shape, b2, c2) => {
        const bbox = c2[b2].getBBox();
        if (bbox.width >= this.measurementScale(shape.l))
          return true;
        if (this.measurementScale(shape.w) < 40) return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      this.shapeLengthText = this.shapeWrappers.append("text").attr("class", "shape-text length").text((shape) => {
        if (this.debug === "guillotine") return "";
        return convertUnit(
          shape.l,
          this.units,
          this.decimalPlaces,
          false,
          this.fractionRoundTo
        );
      }).classed("hidden", (shape, b2, c2) => {
        var _a4;
        if (this.app)
          return this.measurementScale(shape.l) < 50 || this.measurementScale(shape.w) < 50;
        if (((_a4 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a4.type) === "linear") return false;
        const bbox = c2[b2].getBBox();
        if (bbox.width >= this.measurementScale(shape.l))
          return true;
        if (this.measurementScale(shape.w) < 30) return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      this.shapeWidthText = this.shapeWrappers.append("text").attr("class", "shape-text width").text((shape) => {
        if (this.debug === "guillotine") return "";
        return convertUnit(
          shape.w,
          this.units,
          this.decimalPlaces,
          false,
          this.fractionRoundTo
        );
      }).classed("hidden", (shape, b2, c2) => {
        if (this.app) {
          return this.measurementScale(shape.l) < 50 || this.measurementScale(shape.w) < 50;
        }
        const bbox = c2[b2].getBBox();
        if (this.measurementScale(shape.l) < 30) return true;
        if (bbox.height >= this.measurementScale(shape.w))
          return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
    }
    if ((this.main || this.app) && !((_c = this == null ? void 0 : this.options) == null ? void 0 : _c.disableClick)) {
      this.shapes.on("mousedown", (event, shape) => {
        var _a4, _b3, _c2, _d, _e;
        if (this.moving) return false;
        if (this.env === "development") {
          console.clear();
          if (shape) {
            let logProperties = ["id", "placementOrder", "priority", "addedAsGroup"];
            if (this.debug === "guillotine") {
              logProperties = [
                "id",
                "placementOrder",
                "priority",
                "guillotineData.myPhase",
                "guillotineData.myStripDirection",
                "guillotineData.myStripParent",
                "guillotineData.firstShape",
                "addedAsGroup"
              ];
            } else if (this.debug === "groups") {
              logProperties = [
                "id",
                "addedAsGroup"
              ];
            }
            console.table(logProperties.reduce((obj, prop) => {
              const value2 = getNestedProperty(shape, prop);
              obj[prop] = Array.isArray(value2) ? value2.join(", ") : value2;
              return obj;
            }, {}));
          }
          if (this.debug === "guillotine") {
            this.shapeWrappers.selectAll(".highlight-a").classed("highlight-a", false);
            this.shapeWrappers.selectAll(".highlight-b").classed("highlight-b", false);
            this.shapeWrappers.selectAll(".highlight-c").classed("highlight-c", false);
            const stripParentId = (_a4 = shape.guillotineData) == null ? void 0 : _a4.myStripParent;
            const stripParentParentId = (_c2 = (_b3 = shapeList.find((s2) => s2.id === stripParentId)) == null ? void 0 : _b3.guillotineData) == null ? void 0 : _c2.myStripParent;
            if (stripParentId) {
              const el = this.shapeWrappers.filter((d2) => d2.id === stripParentId || d2.addedAsGroup === stripParentId);
              const rect = el.select("rect");
              rect.classed("highlight-a", true);
            }
            if (stripParentParentId) {
              const el = this.shapeWrappers.filter((d2) => d2.id === stripParentParentId || d2.addedAsGroup === stripParentId);
              const rect = el.select("rect");
              rect.classed("highlight-b", true);
            }
          }
        }
        if (this.app || this.embed) {
          const eventData = {
            name: shape.name,
            id: shape.id,
            x: shape.x,
            y: shape.y,
            l: shape.l,
            w: shape.w,
            banding: (shape == null ? void 0 : shape.banding) && typeof shape.banding === "object" ? shape.banding : null,
            rot: shape.rot,
            stock: (_d = shape == null ? void 0 : shape.stock) == null ? void 0 : _d.id,
            color: (_e = this.getShapeColor(shape)) == null ? void 0 : _e.toString(),
            notes: shape == null ? void 0 : shape.notes
          };
          const partClickEvent = new CustomEvent("partClick", {
            detail: eventData
          });
          if (this.env === "development") {
            console.log(eventData);
          }
          this.htmlEl.dispatchEvent(partClickEvent);
          if (this.app) return false;
        }
        if (this.device === "desktop") {
          this.resetCutMeasurementAxes();
          this.addShapeAxes(shape);
        }
        if (this.moveMode) {
          const partsBin = getRef.call(this.vueComponent, "partsBin");
          if (partsBin) partsBin.addToPartBin(shape);
        } else {
          this.findShape(shape.id);
        }
      });
      if (!this.app && !this.hasTouch) {
        this.shapes.on(
          "mouseover",
          (event) => {
            if ((this == null ? void 0 : this.moveMode) && this.moving) return;
            d3.select(event.target).classed("hover", true);
            if (!d3.select(event.target).classed("selected")) {
              d3.select(event.target).style(
                "fill",
                this.colors.partHover.toString()
              );
            }
          },
          {
            passive: true
          }
        ).on(
          "mouseout",
          (event, s2) => {
            var _a4;
            d3.select(event.target).classed("hover", false);
            if (!d3.select(event.target).classed("selected")) {
              d3.select(event.target).style(
                "fill",
                (_a4 = this.getShapeColor(s2)) == null ? void 0 : _a4.toString()
              );
            }
          },
          {
            passive: true
          }
        );
      }
    }
    this.setShapePosition();
  }
  findShapeElement(id) {
    const shape = this.shapeWrappers.filter((d2) => d2.id === id);
    if (!shape.empty()) return shape.node();
    else return null;
  }
  findShape(id) {
    const shapeEl = this.findShapeElement(id);
    const shape = getData.call(this.vueComponent, ["shapeList"]).find((s2) => s2.id === id);
    if (shapeEl) {
      this.selectShape(shapeEl, shape);
    }
  }
  selectShape(shapeEl, shape) {
    setData.call(this.vueComponent, ["examineShape"], shape);
    this.shapes.classed("selected", false);
    this.shapes.style("fill", (s2) => this.getShapeColor(s2));
    const shapeEL = d3.select(shapeEl).select("rect");
    if (shapeEL) {
      shapeEL.classed("selected", true);
      shapeEL.style("fill", this.colors.partSelected.toString());
    }
  }
  /**
      * update SHAPE visibility - used for replay
      * @param {Number} number
      */
  updateShapeVisibility(number2) {
    var _a3;
    (_a3 = this == null ? void 0 : this.shapeWrappers) == null ? void 0 : _a3.style("visibility", (shape) => {
      if ((shape == null ? void 0 : shape.placementOrder) >= number2) return "hidden";
      else return "visible";
    });
  }
  isCutComplete(c2, parentSegmentID, segmentCutOrder) {
    return c2.guillotineData.parentSegmentID === parentSegmentID && segmentCutOrder && c2.guillotineData.segmentCutOrder < segmentCutOrder;
  }
  isCutInsideSegment(c2, parentSegmentID) {
    var _a3;
    return ((_a3 = c2.guillotineData) == null ? void 0 : _a3.parentSegmentID) !== null && !(c2 == null ? void 0 : c2.isTrim) ? c2.guillotineData.parentSegmentID === parentSegmentID : false;
  }
  //update CUT visibility
  updateCutVisibility(cut, index = null, sorting = "") {
    var _a3, _b2, _c, _d, _e, _f, _g, _h, _i;
    if (index === null) return;
    if (cut === void 0 || cut === null) return;
    if (this == null ? void 0 : this.cuts.empty()) return;
    this.resetShapeAxes();
    this.resetCutMeasurementAxes();
    d3.select(this.cuts.nodes()[index].parentNode).raise();
    const parentSegmentID = (_a3 = cut.guillotineData) == null ? void 0 : _a3.parentSegmentID;
    const halfBladeWidth = this.getHalfBladeWidth(cut.stock);
    const axis2 = cut.dimension === "l" ? "y" : "x";
    const trim = (_b2 = cut == null ? void 0 : cut.stock) == null ? void 0 : _b2.trim;
    const orderKey = sorting === "ptx" ? "ptxOrder" : "order";
    if ((((_c = cut == null ? void 0 : cut.stock) == null ? void 0 : _c.cutType) === "guillotine" || ((_d = cut == null ? void 0 : cut.stock) == null ? void 0 : _d.cutType) === "beam") && parentSegmentID !== null && typeof parentSegmentID !== "undefined") {
      this.cuts.style("visibility", (c2) => {
        if (typeof cut.guillotineData[orderKey] === "number" && c2.guillotineData[orderKey] <= cut.guillotineData[orderKey]) {
          return "visible";
        }
        if (!sorting && c2.guillotineData.parentSegmentID === parentSegmentID) {
          return "visible";
        }
        return "hidden";
      });
      this.cuts.classed("highlight", (c2) => {
        if (cut.stock.cutType === "guillotine" && c2.isTrim)
          return c2.type === cut.type;
        return c2.guillotineData[orderKey] === cut.guillotineData[orderKey];
      });
      this.cuts.classed("ptx-dummy", (c2) => {
        return c2.guillotineData.ptxDummyCut;
      });
      if (!sorting) {
        const segmentCutOrder = (_e = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _e.segmentCutOrder;
        if (segmentCutOrder === void 0 || segmentCutOrder === null)
          return;
        this.cuts.classed("completed", (c2) => this.isCutComplete(c2, parentSegmentID, segmentCutOrder));
        this.cuts.classed("inside-segment", (c2) => this.isCutInsideSegment(c2, parentSegmentID));
        let measurements, values;
        const segments = this.getCutSegments(cut);
        if (segments === false) return;
        const relevantSegment = (_g = segments == null ? void 0 : segments.siblings) == null ? void 0 : _g[((_f = segments.main) == null ? void 0 : _f.hasBeamTrim) ? segmentCutOrder - 1 : segmentCutOrder];
        if (relevantSegment) {
          if ((cut == null ? void 0 : cut.dimension) === "l") {
            measurements = [
              [
                relevantSegment.y,
                relevantSegment.y + relevantSegment.w
              ],
              [
                cut.y1 + halfBladeWidth,
                (segments == null ? void 0 : segments.main.y) + (segments == null ? void 0 : segments.main.w)
              ]
            ];
          } else if ((cut == null ? void 0 : cut.dimension) === "w") {
            measurements = [
              [
                relevantSegment.x,
                relevantSegment.x + relevantSegment.l
              ],
              [
                cut.x1 + halfBladeWidth,
                (segments == null ? void 0 : segments.main.x) + (segments == null ? void 0 : segments.main.l)
              ]
            ];
          }
          if ((cut == null ? void 0 : cut.dimension) === "l") {
            values = [(_h = cut == null ? void 0 : cut.distances) == null ? void 0 : _h.bottom, cut == null ? void 0 : cut.distances.top];
          } else if ((cut == null ? void 0 : cut.dimension) === "w") {
            values = [cut == null ? void 0 : cut.distances.left, (_i = cut == null ? void 0 : cut.distances) == null ? void 0 : _i.right];
          }
          if (this.device === "desktop" && !cut.isTrim)
            this.addCutMeasurementAxes(measurements, values, axis2);
        }
      }
    } else {
      this.cuts.style("visibility", (c2, thisIndex) => thisIndex <= index ? "visible" : "hidden");
      let measurements;
      if ((cut == null ? void 0 : cut.dimension) === "l") {
        measurements = [
          [0 + (trim.y1 ?? 0), cut.y1 - halfBladeWidth],
          [
            cut.y1 + halfBladeWidth,
            cut.stock.w - ((trim == null ? void 0 : trim.y2) ? trim.y2 : 0)
          ]
        ];
      } else if ((cut == null ? void 0 : cut.dimension) === "w") {
        measurements = [
          [0 + (trim.x1 ?? 0), cut.x1 - halfBladeWidth],
          [
            cut.x1 + halfBladeWidth,
            cut.stock.l - ((trim == null ? void 0 : trim.x2) ? trim.x2 : 0)
          ]
        ];
      }
      if (measurements == null ? void 0 : measurements.length) {
        const values = [
          measurements[0][1] - measurements[0][0],
          measurements[1][1] - measurements[1][0]
        ];
        if (this.device === "desktop" && !cut.isTrim)
          this.addCutMeasurementAxes(measurements, values, axis2);
      }
      this.cuts.classed(
        "highlight",
        (cut2, cutIndex) => cutIndex === index
      );
    }
    this.cuts.attr("stroke-width", (c2, cutIndex) => {
      var _a4;
      let width = Math.ceil(this.measurementScale(this.getBladeWidth(c2.stock)));
      const segmentCutOrder = (_a4 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _a4.segmentCutOrder;
      if (this.isCutComplete(c2, parentSegmentID, segmentCutOrder)) {
        width += 1;
      } else if (this.isCutInsideSegment(c2, parentSegmentID)) {
        width += 1;
      }
      if (cutIndex === index && Math.ceil(this.measurementScale(this.getBladeWidth(c2.stock))) < 5) {
        width = 5;
      }
      return width;
    });
  }
  //highlight a specific cut (by order or index), segments and related measurements
  showCut(cut, index = null, sorting = "") {
    var _a3;
    if (index === null) return false;
    this.updateCutVisibility(cut, index, sorting);
    if (sorting === "ptx") {
      this.resetSegments();
      return;
    }
    const cutSegments = this.getCutSegments(cut);
    if (cutSegments === false) return;
    const { main, siblings } = cutSegments;
    if (!((_a3 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _a3.parentSegmentID)) {
      return this.initSegments([main]);
    }
    const numSiblings = siblings == null ? void 0 : siblings.length;
    let segments = [];
    if (numSiblings) {
      for (let i2 = numSiblings; i2--; ) {
        if (siblings[i2]) siblings[i2].completed = false;
      }
      if (cut.guillotineData.segmentCutOrder === void 0 || cut.guillotineData.segmentCutOrder === null)
        return;
      const order = cut.guillotineData.segmentCutOrder;
      for (let i2 = 0; i2 < numSiblings; i2++) {
        if (i2 < order) siblings[i2].completed = true;
      }
      segments.push(...siblings);
      segments = segments.filter((s2) => s2);
    }
    if (segments.length) {
      this.resetSegments();
      this.initSegments(segments);
    }
  }
  /**
      * toggle the visibility of the shapes
      * @param {Boolean} show
      */
  toggleShapes(show = false) {
    if (show) {
      this.shapeGroup.attr("display", "block");
      this.bandingGroup.attr("display", "block");
    } else {
      this.shapeGroup.attr("display", "none");
      this.bandingGroup.attr("display", "none");
    }
  }
  /**
      * add measurements to an axis
      * @param {Array} measurements array of arrays
      * @param {Array} values array of values
      * @param {String} axis x | y
      */
  addCutMeasurementAxes(measurements, values, axis2) {
    if (!axis2 || !(measurements == null ? void 0 : measurements.length)) return;
    measurements.forEach((measurement, index) => {
      const start = measurement[0];
      const end = measurement[1];
      if (axis2 === "x") {
        const xScale = d3.scaleLinear().domain([start, end]).range([
          this.xPositionScale(start),
          this.xPositionScale(end)
        ]);
        const tickPosition = (xScale.domain()[1] - xScale.domain()[0]) / 2 + xScale.domain()[0];
        const axis22 = this.axisGroup.append("g").attr(
          "transform",
          `translate(0, ${this.h - this.padding + this.axisSpacing})`
        ).attr("class", "axis measurement x").call(d3.axisBottom(xScale).tickValues([tickPosition]).tickSize(4).tickFormat(() => this.formatNumber(values[index])));
        axis22.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (text, index2, list) => list[index2].getBBox().height + 10
        );
        this.cutMeasurementXAxes.push(axis22);
      } else {
        const yScale = d3.scaleLinear().domain([start, end]).range([
          this.yPositionScale(start),
          this.yPositionScale(end)
        ]);
        const tickPosition = (yScale.domain()[1] - yScale.domain()[0]) / 2 + yScale.domain()[0];
        const axis22 = this.axisGroup.append("g").attr(
          "transform",
          `translate(${this.padding - this.axisSpacing}, 0)`
        ).attr("class", "axis measurement y").call(d3.axisLeft(yScale).tickValues([tickPosition]).tickSize(4).tickFormat(() => this.formatNumber(values[index])));
        axis22.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (text, index2, list) => list[index2].getBBox().height + 10
        ).attr(
          "dx",
          (text, index2, list) => list[index2].getBBox().width / 4
        ).attr(
          "transform",
          (text, index2, list) => "rotate(90) translate(" + list[index2].getBBox().width / 4 + ")"
        );
        this.cutMeasurementYAxes.push(axis22);
      }
    });
  }
  /**
      * add the shape axes
      * @param {Shape} shape
      */
  addShapeAxes(shape) {
    var _a3;
    if (this.shapeXAxis) this.shapeXAxis.remove();
    if (this.shapeYAxis) this.shapeYAxis.remove();
    const x1 = shape.x;
    const x2 = shape.x + shape.l;
    const xScale = d3.scaleLinear().domain([x1, x2]).range([this.xPositionScale(x1), this.xPositionScale(x2)]);
    const y1 = shape.y;
    const y2 = shape.y + shape.w;
    const yScale = d3.scaleLinear().domain([y1, y2]).range([this.yPositionScale(y1), this.yPositionScale(y2)]);
    this.shapeXAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(0, ${this.h - this.padding + this.axisSpacing})`
    ).attr("class", "axis shape x").call(d3.axisBottom(xScale).tickValues(xScale.domain()).tickSize(4).tickFormat(this.formatNumber));
    this.shapeXAxis.selectAll("text").attr("dx", (text, index, list) => {
      const thisEl = list[index];
      if (thisEl === null) return;
      const bbox = thisEl.getBBox();
      if (index === 0) return -bbox.width / 2;
      else return bbox.width / 2;
    });
    if (((_a3 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a3.type) !== "linear") {
      this.shapeYAxis = this.axisGroup.append("g").attr(
        "transform",
        `translate(${this.padding - this.axisSpacing}, 0)`
      ).attr("class", "axis shape y").call(d3.axisLeft(yScale).tickValues(yScale.domain()).tickSize(4).tickFormat(this.formatNumber));
      this.shapeYAxis.selectAll("text").attr("x", 0).attr("y", 0).attr(
        "dy",
        (text, index, list) => {
          var _a4, _b2;
          return ((_b2 = (_a4 = list[index]) == null ? void 0 : _a4.getBBox()) == null ? void 0 : _b2.height) + 2;
        }
      ).attr(
        "dx",
        (text, index, list) => {
          var _a4, _b2;
          return ((_b2 = (_a4 = list[index]) == null ? void 0 : _a4.getBBox()) == null ? void 0 : _b2.width) / 2;
        }
      ).attr("transform", (text, index, list) => {
        var _a4, _b2, _c, _d, _e, _f, _g, _h;
        if (this.flipY) {
          if (index === 0)
            return "rotate(90) translate(-" + ((_b2 = (_a4 = list[index]) == null ? void 0 : _a4.getBBox()) == null ? void 0 : _b2.width) / 2 + ")";
          return "rotate(90) translate(" + ((_d = (_c = list[index]) == null ? void 0 : _c.getBBox()) == null ? void 0 : _d.width) / 2 + ")";
        } else {
          if (index === 0)
            return "rotate(90) translate(" + ((_f = (_e = list[index]) == null ? void 0 : _e.getBBox()) == null ? void 0 : _f.width) / 2 + ")";
          else
            return "rotate(90) translate(-" + ((_h = (_g = list[index]) == null ? void 0 : _g.getBBox()) == null ? void 0 : _h.width) / 2 + ")";
        }
      });
    }
  }
  getBandingAdjustment(type3, coordinate) {
    switch (type3) {
      case "y1":
        if (coordinate === "x") return 0;
        if (coordinate === "y") return this.flipY ? 1 : -1;
        break;
      case "y2":
        if (coordinate === "x") return 0;
        if (coordinate === "y") return this.flipY ? -1 : 1;
        break;
      case "x1":
        if (coordinate === "x") return this.flipX ? -1 : 1;
        if (coordinate === "y") return 0;
        break;
      case "x2":
        if (coordinate === "x") return this.flipX ? 1 : -1;
        if (coordinate === "y") return 0;
        break;
    }
    return 0;
  }
  getRectangleCoordinate(rectangle, coordinate, position, adjustment) {
    let coord;
    if (coordinate === "x") {
      let x2;
      switch (position) {
        case "center":
          x2 = this.xPositionScale(rectangle.x + rectangle.l / 2);
          if (adjustment) x2 += adjustment;
          break;
        case "right":
          x2 = this.xPositionScale(rectangle.x + rectangle.l);
          if (adjustment) x2 -= adjustment;
          break;
        case "left":
        default:
          x2 = this.xPositionScale(this.flipX ? rectangle.x - rectangle.l : rectangle.x);
          if (adjustment) x2 -= adjustment;
      }
      coord = x2;
    } else if (coordinate === "y") {
      let y2;
      switch (position) {
        case "center":
          y2 = this.yPositionScale(rectangle.y + rectangle.w / 2);
          if (adjustment) y2 += adjustment;
          break;
        case "bottom":
          y2 = this.yPositionScale(this.flipY ? rectangle.y + rectangle.w : rectangle.y);
          if (adjustment) y2 += adjustment;
          break;
        case "top":
        default:
          y2 = this.yPositionScale(this.flipY ? rectangle.y : rectangle.y + rectangle.w);
          if (adjustment) y2 -= adjustment;
      }
      coord = y2;
    }
    return coord;
  }
  getRotatedSide(position) {
    switch (position) {
      case "x1":
      case "l1":
        return "w1";
      case "x2":
      case "l2":
        return "w2";
      case "y1":
      case "w1":
        return "l2";
      case "y2":
      case "w2":
        return "l1";
    }
  }
  /**
      * update the position of the shapes and the content within
      */
  setShapePosition() {
    if (!this.shapes) return false;
    this.shapes.attr("x", (s2) => this.getRectangleCoordinate(s2, "x")).attr("y", (s2) => this.getRectangleCoordinate(s2, "y")).attr("width", (s2) => this.getWidthAttribute(s2)).attr("height", (s2) => this.getHeightAttribute(s2));
    if (this.main) {
      this.shapeIDText.attr("x", (s2) => this.getRectangleCoordinate(s2, "x", "center")).attr("y", (s2) => this.getRectangleCoordinate(s2, "y", "center")).attr("dy", 1);
      if (this.shapeNameText) {
        this.shapeNameText.attr("x", (s2) => this.getRectangleCoordinate(s2, "x", "center")).attr("y", (s2, b2, c2) => this.getRectangleCoordinate(
          s2,
          "y",
          "bottom",
          -(c2[b2].getBBox().height / 2 + 1)
        ));
      }
      this.shapeLengthText.attr("x", (s2) => this.getRectangleCoordinate(s2, "x", "center")).attr("y", (s2, b2, c2) => this.getRectangleCoordinate(
        s2,
        "y",
        "top",
        -(c2[b2].getBBox().height / 2 + 2)
      ));
      this.shapeWidthText.attr(
        "transform",
        (s2, b2, c2) => `translate(${this.getRectangleCoordinate(
          s2,
          "x",
          "left",
          -(c2[b2].getBBox().height / 2 + 2)
        )},${this.getRectangleCoordinate(s2, "y", "center")}) ${this.device === "mobile" ? "rotate(90)" : "rotate(-90)"}`
      );
    }
  }
  //init or update the cuts
  initCuts(cutList) {
    this.resetCuts();
    if (!cutList || !(cutList == null ? void 0 : cutList.length) || !this.main || !this.elWidth)
      return false;
    this.cuts = this.cutGroup.selectAll("line").data(cutList).join("line").attr("class", "cut").attr("stroke-width", (cut) => {
      const width = this.measurementScale(this.getBladeWidth(cut.stock));
      if (width < 1) return 1;
      return Math.ceil(width);
    }).attr("x1", (cut) => this.xPositionScale(cut.getVisCoords("x1"))).attr("x2", (cut) => this.xPositionScale(cut.getVisCoords("x2"))).attr("y1", (cut) => this.yPositionScale(cut.getVisCoords("y1"))).attr("y2", (cut) => this.yPositionScale(cut.getVisCoords("y2"))).classed("trim", (cut) => cut.isTrim);
  }
  //init or update the segments
  initSegments(segments) {
    if (!segments || !(segments == null ? void 0 : segments.length) || !this.main || !this.elWidth)
      return false;
    this.resetSegments();
    this.segments = this.segmentGroup.selectAll("rect").data(segments).join("rect").attr("class", "segment").style("opacity", (segment) => {
      if ((segment == null ? void 0 : segment.offcut) === true) return 0.5;
    }).classed("offcut", (segment) => segment.offcut).classed("merged", (segment) => segment.merged).classed("near", (segment) => segment.shapePosition === "near").classed("far", (segment) => segment.shapePosition === "far").classed("completed", (segment) => segment.completed).attr("x", (segment) => this.getRectangleCoordinate(segment, "x")).attr("y", (segment) => this.getRectangleCoordinate(segment, "y")).attr("width", (segment) => this.getWidthAttribute(segment)).attr("height", (segment) => this.getHeightAttribute(segment));
    this.segmentGroup.selectAll("text").data(segments).join("text").attr("class", "segment-text").attr("x", (segment) => this.getRectangleCoordinate(segment, "x", "center")).attr("y", (s2) => this.getRectangleCoordinate(s2, "y", "center")).attr("text-anchor", "middle").text((segment) => {
      if (this.env !== "development") return null;
      if (segment.offcut) return null;
      if (segment.cutDirection === "l") {
        return this.env === "development" ? `→ ${segment.id}` : "→";
      } else if (segment.cutDirection === "w") {
        return this.env === "development" ? `↑ ${segment.id}` : "↑";
      }
    }).attr("dominant-baseline", "middle");
    if (!this.app && this.env === "development") {
      this.segments.on("mousedown", function(event, segment) {
        const logSegment = structuredClone(segment);
        const logProperties = [
          "id",
          "x",
          "y",
          "l",
          "w",
          "cutDirection",
          "cutPreference"
        ];
        console.log(logProperties.reduce((obj, prop) => {
          obj[prop] = getNestedProperty(logSegment, prop);
          return obj;
        }, {}));
      });
    }
  }
  initGroups(groups) {
    if (!groups || !(groups == null ? void 0 : groups.length) || !this.main || !this.elWidth)
      return false;
    this.resetGroups();
    this.groups = this.groupGroup.selectAll("rect").data(groups).join("rect").attr("class", "group").attr("x", (g2) => this.getRectangleCoordinate(g2, "x")).attr("y", (g2) => this.getRectangleCoordinate(g2, "y")).attr("width", (g2) => this.getWidthAttribute(g2)).attr("height", (g2) => this.getHeightAttribute(g2));
    this.groupGroup.attr("display", "block");
  }
  //get relevant segments for a specific cut
  getCutSegments(cut) {
    var _a3, _b2, _c, _d;
    const parentSegmentID = (_a3 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _a3.parentSegmentID;
    const activeSegments = ((_c = (_b2 = this.vueComponent) == null ? void 0 : _b2.gs) == null ? void 0 : _c.activeSegments) ?? ((_d = this.vueComponent) == null ? void 0 : _d.activeSegments);
    if (!activeSegments.length) return false;
    let mainSegment;
    if (parentSegmentID) {
      mainSegment = activeSegments.find((s2) => s2.id === parentSegmentID);
    } else {
      mainSegment = activeSegments.find((s2) => s2.segmentType === "root");
    }
    if (mainSegment === void 0) return false;
    const children2 = mainSegment == null ? void 0 : mainSegment.children;
    if (children2 == null ? void 0 : children2.length) {
      const siblings = children2.map((child) => {
        const s2 = activeSegments.find((segment) => {
          return segment.x === child.x && segment.y === child.y && segment.l === child.l && segment.w === child.w;
        });
        if (s2 !== void 0) return s2;
        return null;
      }).filter((s2) => s2 !== null);
      const segments = {
        main: mainSegment,
        siblings
      };
      return segments;
    }
    return false;
  }
  /**
      * toggle the visibility of the segments
      * @param {Boolean} show
      */
  toggleSegments(show = true) {
    if (show) this.segmentGroup.attr("display", "block");
    else this.segmentGroup.attr("display", "none");
  }
  /**
      * show a list of possible movement positions
      */
  initPositions(shape, stock) {
    if (!stock) return false;
    if (!shape || !this.main) return false;
    let positions;
    stock.trimDimensions();
    if (!shape.willItFit(stock, shape.rot)) return false;
    stock.removeTrim();
    const placedShapes = getData.call(this.vueComponent, ["shapeList"]).filter((otherShape) => {
      var _a3;
      return otherShape.added && ((_a3 = otherShape == null ? void 0 : otherShape.stock) == null ? void 0 : _a3.id) === stock.id;
    });
    const placementCollection = getPlacementPositions(
      null,
      placedShapes,
      stock
    );
    let rayCastCoords;
    if (stock.cutType === "efficiency") {
      if (this.env === "development") {
        const shapeRays = precomputeShapeRays(placedShapes, stock);
        this.positionGroup.selectAll("line").remove();
        const allRays = shapeRays.flatMap((sr) => Object.values(sr.rays));
        this.positionGroup.selectAll("line").data(allRays).enter().append("line").attr("x1", (d2) => this.xPositionScale(d2.x1)).attr("x2", (d2) => this.xPositionScale(d2.x2)).attr("y1", (d2) => this.yPositionScale(d2.y1)).attr("y2", (d2) => this.yPositionScale(d2.y2)).attr("stroke", "rgba(245, 66, 227, 0.5)").attr("stroke-width", 2).on("mousedown", (e, d2) => console.log(d2));
      }
      rayCastCoords = getRayCastCoordinates(
        stock,
        placedShapes
      );
    }
    const positionCollection = new PointCollection();
    for (const p2 of placementCollection.toArray()) {
      const shapePositions = convertPointToShapePositions(shape, p2, stock);
      if (shapePositions) {
        positionCollection.addPoints(shapePositions.toArray());
      }
    }
    if (rayCastCoords) {
      const rayCastCoordsArray = rayCastCoords.toArray();
      for (const p2 of rayCastCoordsArray) {
        const shapePositions = convertRaycastCollisionPointToShapePositions(shape, p2, stock);
        if (shapePositions) {
          positionCollection.addPoints(shapePositions.toArray());
        }
      }
    }
    if (stock.cutType === "efficiency") {
      [
        new Point(0 + (stock.trim.x1 ?? 0), 0 + (stock.trim.y1 ?? 0)),
        new Point(0 + (stock.trim.x1 ?? 0), 0 + (stock.trim.y1 ?? 0)),
        new Point(
          stock.l - shape.l - (stock.trim.x2 ?? 0),
          0 + (stock.trim.y1 ?? 0)
        ),
        new Point(
          0 + (stock.trim.x1 ?? 0),
          stock.w - shape.w - (stock.trim.y2 ?? 0)
        ),
        new Point(
          stock.l - shape.l - (stock.trim.x2 ?? 0),
          stock.w - shape.w - (stock.trim.y2 ?? 0)
        )
      ].forEach((c2) => positionCollection.addPoint(c2));
      positions = positionCollection.toArray();
    } else {
      positionCollection.addPoint(new Point(0 + (stock.trim.x1 ?? 0), 0 + (stock.trim.y1 ?? 0)));
      positions = positionCollection.toArray();
    }
    for (let i2 = positions.length; i2--; ) {
      const p2 = positions[i2];
      shape.x = p2.x;
      shape.y = p2.y;
      for (const placedShape of placedShapes) {
        if (this.collision(shape, placedShape, stock)) {
          positions.splice(i2, 1);
          break;
        }
      }
    }
    this.positionGroup.selectAll("rect").data(positions).join("rect").attr("data-id", (_p, index) => index).attr("class", "shape ghost").attr("x", (p2) => {
      shape.x = p2.x;
      return this.getRectangleCoordinate(shape, "x");
    }).attr("y", (p2) => {
      shape.y = p2.y;
      return this.getRectangleCoordinate(shape, "y");
    }).attr("width", this.getWidthAttribute(shape)).attr("height", this.getHeightAttribute(shape)).on("mousedown", (event, position) => {
      event.stopPropagation();
      const partsBin = getRef.call(this.vueComponent, "partsBin");
      if (partsBin) partsBin.moveShape(
        event.currentTarget,
        shape,
        position
      );
    });
    if (!this.hasTouch) {
      this.positionGroup.selectAll("rect").on(
        "mouseover",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", true);
          d3.select(this).raise();
        },
        {
          passive: true
        }
      ).on(
        "mouseout",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", false);
        },
        {
          passive: true
        }
      );
    }
    this.dotGroup.selectAll("circle").data(positions).join("circle").attr("data-id", (_p, index) => index).attr("class", "dot").classed("raycast", (p2) => {
      if (this.env !== "development") return false;
      return p2.raycast;
    }).attr("cx", (p2) => {
      shape.x = p2.x;
      return this.getRectangleCoordinate(shape, "x");
    }).attr("cy", (p2) => {
      shape.y = p2.y;
      return this.getRectangleCoordinate(shape, "y", "bottom");
    }).attr("r", 8).on("mousedown", (event, p2) => {
      event.stopPropagation();
      const partsBin = getRef.call(this.vueComponent, "partsBin");
      if (partsBin) partsBin.moveShape(
        event.currentTarget,
        shape,
        p2
      );
    });
    shape.x = 0;
    shape.y = 0;
    if (!this.hasTouch) {
      this.dotGroup.selectAll("circle").on(
        "mouseover",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", true);
          const id = d3.select(this).attr("data-id");
          const ghost = d3.select(`.ghost[data-id="${id}"]`);
          ghost.raise();
          ghost.classed("highlight", true);
        },
        {
          passive: true
        }
      ).on(
        "mouseout",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", false);
          const id = d3.select(this).attr("data-id");
          d3.select(`.ghost[data-id="${id}"]`).classed(
            "highlight",
            false
          );
        },
        {
          passive: true
        }
      );
    }
    if (!(positions == null ? void 0 : positions.length)) return false;
    return true;
  }
  /**
      * show a list of placement positions
      */
  initPlacementPositions(placementPositions) {
    if (this.env !== "development" || this.debug !== "positions") return;
    if (!(placementPositions == null ? void 0 : placementPositions.length)) return false;
    this.placementPositionGroup.selectAll("circle").data(placementPositions).join("circle").attr("data-id", (_p, index) => index).attr("class", "dot").attr("cx", (p2) => this.xPositionScale(p2.x)).attr("cy", (p2) => this.yPositionScale(p2.y)).attr("r", 3).on("mousedown", (event) => {
      event.stopPropagation();
    });
  }
  /**
      * toggle the visibility of the cuts
      * @param {Boolean} show
      */
  toggleCuts(show = true) {
    if (show) this.cutGroup.attr("display", "block");
    else this.cutGroup.attr("display", "none");
  }
  clearSelection() {
    var _a3;
    if (this == null ? void 0 : this.shapes) {
      this.shapes.classed("selected", false);
      this.shapes.classed("hover", false);
      this.shapes.style("fill", (s2) => this.getShapeColor(s2));
    }
    if (this == null ? void 0 : this.cuts) {
      this.cuts.classed("selected", false);
      this.cuts.classed("highlight", false);
      this.cuts.classed("inside-segment", false);
      this.cuts.style("visibility", "visible");
      this.cuts.attr("stroke-width", (cut) => {
        const width = this.measurementScale(this.getBladeWidth(cut.stock));
        if (width < 1) return 1;
        return Math.ceil(width);
      });
    }
    if ((_a3 = this == null ? void 0 : this.shapes) == null ? void 0 : _a3.length) this.shapes.classed("selected", false);
  }
  /**
      * add padding
      * this.padding will be 0 when necessary
      * @param {number} value
      */
  addPadding(value2) {
    return value2 + this.padding;
  }
  /**
      * @param {Container} container
      * @returns {number} blade width
      */
  getBladeWidth(container = null) {
    var _a3, _b2;
    if (valueSet((_a3 = this == null ? void 0 : this.saw) == null ? void 0 : _a3.bladeWidth)) {
      return (_b2 = this.saw) == null ? void 0 : _b2.bladeWidth;
    } else if (valueSet(container) && container !== null) {
      return container.getBladeWidth();
    }
    return 0;
  }
  getHalfBladeWidth(container = null) {
    const bladeWidth = this.getBladeWidth(container);
    if (bladeWidth !== void 0 && bladeWidth > 0) return bladeWidth / 2;
    return 0;
  }
  resetShapes() {
    if (this.shapeGroup) this.shapeGroup.selectAll("*").remove();
    if (this.bandingGroup) this.bandingGroup.selectAll("*").remove();
    this.resetShapeAxes();
  }
  resetShapeAxes() {
    if (this.shapeXAxis) this.shapeXAxis.remove();
    if (this.shapeYAxis) this.shapeYAxis.remove();
  }
  resetStock() {
    if (this.stockGroup) this.stockGroup.selectAll("*").remove();
    if (this.axisGroup) this.axisGroup.selectAll("*").remove();
    this.resetStockAxes();
  }
  resetStockAxes() {
    if (this.xAxis) this.xAxis.remove();
    if (this.yAxis) this.yAxis.remove();
  }
  resetCuts() {
    if (this.cutGroup) this.cutGroup.selectAll("*").remove();
    this.resetCutMeasurementAxes();
  }
  resetSegments() {
    if (this.segmentGroup) this.segmentGroup.selectAll("*").remove();
  }
  resetGroups() {
    if (this.groupGroup) this.groupGroup.selectAll("*").remove();
  }
  resetCutMeasurementAxes() {
    var _a3, _b2;
    if ((_a3 = this.cutMeasurementXAxes) == null ? void 0 : _a3.length) {
      this.cutMeasurementXAxes.forEach((axis2) => axis2.remove());
      this.cutMeasurementXAxes.length = 0;
    }
    if ((_b2 = this.cutMeasurementYAxes) == null ? void 0 : _b2.length) {
      this.cutMeasurementYAxes.forEach((axis2) => axis2.remove());
      this.cutMeasurementYAxes.length = 0;
    }
  }
  resetPositions() {
    if (this.positionGroup) this.positionGroup.selectAll("*").remove();
    if (this.dotGroup) this.dotGroup.selectAll("*").remove();
  }
  resetPlacementPositions() {
    if (this.placementPositionGroup) this.dotGroup.selectAll("*").remove();
  }
  reset() {
    this.resetPositions();
    this.resetPlacementPositions();
    this.resetShapes();
    this.resetStock();
    this.resetCuts();
    this.resetSegments();
  }
  /**
      * detect collision - required for move mode
      * @param {object} thisShape
      * @param {object} testShape
      * @param {object} container
      * @returns {boolean} true if collision
      */
  collision(thisShape, testShape, container) {
    if (thisShape.id === testShape.id)
      throw new Error("collision comparing to self");
    return (
      // 1 left
      thisShape.x < testShape.x + testShape.l + this.getBladeWidth(container) && // 2 right
      thisShape.x + thisShape.l + this.getBladeWidth(container) > testShape.x && // 3 bottom
      thisShape.y < testShape.y + testShape.w + this.getBladeWidth(container) && // 4 top
      thisShape.y + thisShape.w + this.getBladeWidth(container) > testShape.y
    );
  }
}
function getNestedProperty(obj, prop) {
  return prop.split(".").reduce((res, prop2) => res[prop2], obj);
}
function showShapeInputIssue(issueType = "issues", shape, field, subfield = null) {
  var _a3;
  if (!shape || !((_a3 = shape == null ? void 0 : shape[issueType]) == null ? void 0 : _a3.length)) return false;
  const allIssueFields = shape[issueType].map((i2) => i2.field).flat();
  if (allIssueFields.includes(field)) {
    if (!subfield) return true;
    const allSubFields = shape[issueType].map((i2) => i2.subField).flat();
    return allSubFields.includes(subfield);
  }
}
function isShallowRef(value2) {
  if (!isRef(value2)) return false;
  const descriptor = Object.getOwnPropertyDescriptor(value2, "value");
  return (descriptor == null ? void 0 : descriptor.configurable) === false;
}
function setData(path2, value2) {
  var _a3;
  if (!(path2 == null ? void 0 : path2[0]) || !this) return false;
  const detectReactiveType = (target) => {
    if (isRef(target)) {
      return isShallowRef(target) ? "shallowRef" : "ref";
    }
    if (isReactive(target)) return "reactive";
    if (!isProxy(target) && typeof target === "object") return "raw";
    return "ref";
  };
  let container, existingValue, lastKey;
  if ("gs" in this && typeof ((_a3 = this.gs) == null ? void 0 : _a3[path2[0]]) !== "undefined") {
    container = this.gs;
    existingValue = get2(this.gs, path2);
    lastKey = path2[path2.length - 1];
  } else if (typeof (this == null ? void 0 : this[path2[0]]) !== "undefined") {
    container = this;
    existingValue = get2(this, path2);
    lastKey = path2[path2.length - 1];
  } else {
    return false;
  }
  if (isRef(existingValue)) {
    existingValue.value = value2;
    return true;
  }
  const detectedType = existingValue ? detectReactiveType(existingValue) : detectReactiveType(value2);
  let transformedValue = value2;
  switch (detectedType) {
    case "shallowRef":
      transformedValue = shallowRef(value2);
      break;
    case "raw":
      if (typeof value2 === "object" && value2 !== null && value2.constructor !== Object && value2.constructor !== Array) {
        transformedValue = markRaw(value2);
      } else if (Array.isArray(value2)) {
        transformedValue = markRaw(value2.map((item) => typeof item === "object" && item !== null && item.constructor !== Object ? item : JSON.parse(JSON.stringify(item))));
      } else {
        transformedValue = typeof value2 === "object" ? markRaw(JSON.parse(JSON.stringify(value2))) : markRaw(value2);
      }
      break;
    case "ref":
      if (isRef(value2)) {
        transformedValue = value2;
      } else {
        transformedValue = ref(value2);
      }
      break;
    case "reactive":
      transformedValue = isReactive(value2) ? value2 : reactive(value2);
      break;
  }
  if (path2.length > 1) {
    const parentPath = path2.slice(0, -1);
    const parent = get2(container, parentPath);
    if (isRef(parent)) {
      set2(parent.value, lastKey, transformedValue);
      return true;
    }
  }
  set2(container, path2, transformedValue);
  return true;
}
function getData(path2) {
  var _a3;
  if (!(path2 == null ? void 0 : path2[0]) || !this) return null;
  let value2;
  if ("gs" in this && typeof ((_a3 = this == null ? void 0 : this.gs) == null ? void 0 : _a3[path2[0]]) !== "undefined") {
    value2 = get2(this.gs, path2);
  } else if (typeof (this == null ? void 0 : this[path2[0]]) !== "undefined") {
    value2 = get2(this, path2);
  } else {
    console.warn("getData path not found", path2);
    return null;
  }
  if (isRef(value2) || value2 && typeof value2 === "object" && "value" in value2) {
    return value2.value;
  }
  return value2;
}
function getOptions(path2) {
  var _a3;
  if (!(path2 == null ? void 0 : path2[0])) return null;
  if ("optionsStore" in this && typeof ((_a3 = this == null ? void 0 : this.optionsStore) == null ? void 0 : _a3[path2[0]]) !== "undefined")
    return get2(this.optionsStore, path2);
  else if (typeof (this == null ? void 0 : this[path2[0]]) !== "undefined") return get2(this, path2);
}
function resetProgress(progress) {
  progress.queue = 0;
  progress.stockCount = 0;
  progress.shapeCount = 0;
  progress.resultCount = 0;
  progress.complete = false;
}
function getActiveStock(stockList, activeStockId) {
  if (!(stockList == null ? void 0 : stockList.length)) return null;
  return stockList.find((stock) => stock.id === activeStockId);
}
function getActiveCuts(cutList, activeStock, sorting = "") {
  if (!(cutList == null ? void 0 : cutList.length) || !activeStock) return [];
  const cuts = cutList.filter((cut) => {
    var _a3, _b2, _c;
    if (!sorting) return (((_a3 = cut == null ? void 0 : cut.stock) == null ? void 0 : _a3.id) ?? (cut == null ? void 0 : cut.stockId)) === activeStock.id && !((_b2 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _b2.ptxDummyCut);
    else if (sorting === "ptx") return (((_c = cut == null ? void 0 : cut.stock) == null ? void 0 : _c.id) ?? (cut == null ? void 0 : cut.stockId)) === activeStock.id;
  });
  cuts.sort((a2, b2) => {
    var _a3, _b2;
    return ((_a3 = a2 == null ? void 0 : a2.guillotineData) == null ? void 0 : _a3.order) - ((_b2 = b2 == null ? void 0 : b2.guillotineData) == null ? void 0 : _b2.order);
  });
  return cuts;
}
function getUsedStock(stockList) {
  if (!(stockList == null ? void 0 : stockList.length)) return [];
  return stockList.filter((stock) => stock.used === true);
}
function createStockList(globalAutoAdd = false) {
  let inputStock = getData.call(this, ["inputStock"]);
  if (!(inputStock == null ? void 0 : inputStock.length)) return [{ message: "No stock input" }];
  const stockList = getData.call(this, ["stockList"]);
  if (stockList) stockList.length = 0;
  const issues = [];
  if (globalAutoAdd) inputStock = [inputStock[0]];
  for (let i2 = 0; i2 < inputStock.length; i2++) {
    const stock = inputStock[i2];
    if (!(stock == null ? void 0 : stock.q) && !stock.autoAdd && !globalAutoAdd) continue;
    issues.push(...this.createStock(stock, i2));
  }
  return issues;
}
function refreshShapes() {
  const vis = getData.call(this, ["vis"]);
  if (!vis) return;
  const shapeList = getData.call(this, ["shapeList"]);
  if (!(shapeList == null ? void 0 : shapeList.length)) return false;
  vis.resetPositions();
  vis.resetShapes();
  const activeShapes = getData.call(this, ["activeShapes"]);
  vis.initShapes(activeShapes, shapeList);
  const PartsBin = getRef.call(this, "PartsBin");
  if (PartsBin) PartsBin.clear(false);
}
function refreshStock() {
  const vis = getData.call(this, ["vis"]);
  if (!vis) return;
  const stockList = getData.call(this, ["stockList"]);
  if (!(stockList == null ? void 0 : stockList.length)) return false;
  const activeStock = getData.call(this, ["activeStock"]);
  vis.initStock(activeStock);
  const activeCuts = getData.call(this, ["activeCuts"]);
  vis.initCuts(activeCuts);
  const activeSegments = getData.call(this, ["activeSegments"]);
  vis.initSegments(activeSegments);
  vis.resetPositions();
  if (typeof this.toggleSegments === "function") this.toggleSegments(false);
  if (this == null ? void 0 : this.cutMode) this == null ? void 0 : this.showCut(0);
}
function clearSelection() {
  var _a3;
  const vis = ((_a3 = this == null ? void 0 : this.gs) == null ? void 0 : _a3.vis) ?? (this == null ? void 0 : this.vis);
  if (!vis) return;
  vis.clearSelection();
  vis.resetShapeAxes();
  vis.resetCutMeasurementAxes();
  vis.resetPositions();
}
function showStock(id) {
  const examineShape = getData.call(this, ["examineShape"]);
  if (examineShape) this.examineShape = null;
  setData.call(this, ["activeStockId"], id);
}
function getParent() {
  if (this == null ? void 0 : this.$parent) return this.$parent;
  return null;
}
function getRef(id, levelsUp = 0) {
  var _a3;
  let currentInstance = this;
  for (let i2 = 0; i2 < levelsUp; i2++) {
    if (!getParent.call(currentInstance)) {
      return null;
    }
    currentInstance = getParent.call(currentInstance);
  }
  const ref2 = (_a3 = currentInstance == null ? void 0 : currentInstance.$refs) == null ? void 0 : _a3[id];
  return ref2 ? ref2 : null;
}
function initSocket(server = void 0) {
  this.socket = lookup(server, {
    withCredentials: true,
    //this is required to send passport user data
    autoConnect: false
  });
  this.socket.on("connect", () => {
    setData.call(this, ["connected"], true);
  });
  this.socket.on("maintenance", () => {
    setData.call(this, ["maintenanceMode"], true);
    this.socket.disconnect();
    if (this.env === "development")
      console.log("SmartCut - maintenance mode flag received from server");
  });
  this.socket.on("connect_error", (err2) => {
    setData.call(this, ["connected"], false);
    console.warn(`SmartCut - socket connect_error: ${err2.message}`);
    if (typeof alert !== "undefined")
      alert("We are having trouble connecting to the server. Please try again later.");
    this.socket.close();
  });
  this.socket.on("message", (data) => console.log(data));
  this.socket.on("user", (data) => {
    setData.call(this, ["user"], data);
  });
  this.socket.on("queued", () => {
    setData.call(this, ["progress", "queue"], 1);
  });
  this.socket.on("jobInProgess", (jobID) => {
    alert(`You already have a job in progress, please wait for it to finish

Job ID: ${jobID}`);
    return false;
  });
  this.socket.on("jobStart", () => setData.call(this, ["progress", "queue"], 2));
  this.socket.on("progress", (res) => {
    const data = res.data;
    if (typeof data.shapeCount !== "undefined") {
      setData.call(this, ["progress", "shapeCount"], data.shapeCount);
    }
    if (typeof data.stockCount !== "undefined") {
      setData.call(this, ["progress", "stockCount"], data.stockCount);
    }
    if (!data.stockCount && !data.shapeCount) {
      const originalResultCount = getData.call(this, ["progress", "resultCount"]);
      setData.call(this, ["progress", "resultCount"], originalResultCount + 1);
    }
  });
  this.socket.on("upgrade", () => {
    if ("showUpgradeModal" in this && typeof this.showUpgradeModal === "function") {
      this.showUpgradeModal();
    }
    setData.call(this, ["thinking"], false);
  });
  this.socket.on("error", (data) => {
    var _a3;
    setData.call(this, ["thinking"], false);
    const reset = getData.call(this, ["reset"]);
    if (typeof reset === "function") reset();
    console.error("SmartCut error:", data);
    (_a3 = window == null ? void 0 : window.top) == null ? void 0 : _a3.postMessage(
      {
        type: "scError",
        message: data
      },
      "*"
    );
    if ("showMessage" in this && typeof this.showMessage === "function") {
      this.showMessage(data);
    }
    if (typeof this.showModalMessage === "function") {
      this.showModalMessage({
        heading: "Issue",
        main: data ? `<p>${data}</p>` : "<p>We are having trouble connecting to the server.</p><p>Please try again later and let us know.</p>"
      });
    }
  });
  this.socket.on("result", (data) => {
    var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
    this.socket.disconnect();
    const result = data.result;
    setData.call(this, ["metadata"], result.metadata ?? {});
    setData.call(this, ["unusableShapes"], result.unusableShapes ?? []);
    setData.call(this, ["unavailableStock"], result.unavailableStock ?? []);
    if (!((_a3 = result.shapeList) == null ? void 0 : _a3.length) || !((_b2 = result.stockList) == null ? void 0 : _b2.length)) {
      const progress = getData.call(this, ["progress"]);
      resetProgress(progress);
      if (typeof this.showModalMessage === "function") {
        let message = "<p>We did not manage to fit any parts.</p>";
        if ((_c = result == null ? void 0 : result.unusableShapes) == null ? void 0 : _c.length) {
          message = "<p>No parts were usable.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>";
          this.showModalMessage({
            heading: "Parts unusable",
            main: message,
            buttonText: "Show me",
            buttonCallback: (modal) => {
              modal.showInputPanel(
                "parts",
                "inputs-unusable-parts"
              );
            }
          });
        } else {
          message += "<p>Please double check your list.</p>";
          this.$nextTick(() => {
            this.showModalMessage({
              heading: "Parts unusable",
              main: message
            });
          });
        }
      }
      (_d = window == null ? void 0 : window.top) == null ? void 0 : _d.postMessage(
        {
          type: "scError",
          message: "No parts were added - please double check your list."
        },
        "*"
      );
      if ("showMessage" in this && typeof this.showMessage === "function") {
        this.showMessage("No parts were added - please double check your list.");
      }
      setData.call(this, ["thinking"], false);
      if (typeof this.toggleWidget === "function")
        this.toggleWidget.call(this, "inputs", true);
      return false;
    }
    if (result.shapeList.find((s2) => !s2.added)) {
      if (typeof this.showModalMessage === "function") {
        this.$nextTick(() => {
          this.showModalMessage({
            heading: "Parts not used",
            main: "<p>We did not use all your parts.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>",
            buttonText: "Show me",
            buttonCallback: (modal) => {
              modal.showInputPanel(
                "parts",
                "inputs-unusable-parts"
              );
            }
          });
        });
      }
    }
    setData.call(this, ["progress", "complete"], true);
    setData.call(this, ["jobId"], data == null ? void 0 : data.jobId);
    if (typeof this.toggleWidget === "function") {
      this.toggleWidget("updateStock", false);
      this.toggleWidget("options", false);
      this.toggleWidget("offcuts", false);
      this.toggleWidget("results", false);
      this.toggleWidget("cutlist", false);
      this.toggleWidget("export", false);
      this.toggleWidget("labels", false);
    }
    let saw;
    if (result == null ? void 0 : result.saw) {
      saw = new Saw(
        result == null ? void 0 : result.saw,
        ((_e = result == null ? void 0 : result.saw) == null ? void 0 : _e.stockType) ?? ((_g = (_f = result.stockList) == null ? void 0 : _f[0]) == null ? void 0 : _g.type)
      );
      setData.call(this, ["saw"], saw);
    }
    const stockList = recreateStockList({
      saw,
      stockList: result.stockList,
      removeScores: true,
      preventAutoRotation: true
    });
    setData.call(this, ["stockList"], stockList);
    const usedStock = getData.call(this, ["usedStock"]);
    if (usedStock.length) {
      setData.call(this, ["activeStockId"], usedStock[0].id);
    }
    setData.call(
      this,
      ["shapeList"],
      recreateShapeList({
        shapeList: result.shapeList,
        stockList,
        preventAutoRotation: true
      })
    );
    if (result == null ? void 0 : result.cutList) {
      setData.call(
        this,
        ["cutList"],
        recreateCutList({
          cutList: result.cutList,
          stockList
        })
      );
    }
    if (result == null ? void 0 : result.segmentList)
      setData.call(
        this,
        ["segmentList"],
        recreateSegmentList({
          segmentList: result.segmentList,
          stockList
        })
      );
    if (result == null ? void 0 : result.offcuts)
      setData.call(
        this,
        ["offcuts"],
        recreateOffcuts({
          offcuts: result.offcuts,
          stockList,
          preventAutoRotation: true
        })
      );
    if (result == null ? void 0 : result.metadata) setData.call(this, ["metadata"], result.metadata);
    if ((_h = result == null ? void 0 : result.evolutionVisData) == null ? void 0 : _h.length) {
      setData.call(this, ["evolutionVisData"], result.evolutionVisData);
    } else if (typeof this.toggleWidget === "function") {
      this.toggleWidget.call(this, "evolution", false);
    }
    if (typeof this.toggleWidget === "function") {
      this.toggleWidget.call(this, "workbench", true);
    }
    setData.call(this, ["thinking"], false);
    const inputs = getRef.call(this, "inputs");
    if (inputs && (inputs == null ? void 0 : inputs.success)) inputs.success = false;
    const addedShapes = getData.call(this, ["addedShapes"]);
    if (addedShapes.length === 0) {
      const progress = getData.call(this, ["progress"]);
      resetProgress(progress);
      if (typeof this.showModalMessage === "function") {
        let message = "<p>We could not fit any parts.</p>";
        if ((_i = result == null ? void 0 : result.unusableShapes) == null ? void 0 : _i.length) {
          message += "<p>Some parts were not usable - click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>";
          this.showModalMessage({
            heading: "No layouts",
            main: message,
            buttonText: "More info",
            buttonCallback: (modal) => {
              modal.showInputPanel(
                "parts",
                "inputs-unusable-parts"
              );
            }
          });
        } else {
          message += "<p>Please double check your list.</p>";
          this.showModalMessage({
            heading: "No layouts",
            main: message
          });
        }
      }
      (_j = window == null ? void 0 : window.top) == null ? void 0 : _j.postMessage(
        {
          type: "scError",
          message: "No parts were added."
        },
        "*"
      );
      console.warn("No parts were added.");
      if (typeof this.toggleWidget === "function")
        this.toggleWidget.call(this, "inputs", true);
    }
  });
  return this.socket;
}
function createExtraStringFromOptions(options) {
  if (!options) return "";
  if (!objectValuesPresent(options)) return "";
  return Object.values(options).filter((o2) => o2).join("|");
}
function checkIfValidExtra(shape, extrasKey, type3 = "Options") {
  if (!type3 && `${extrasKey}` in shape && typeof shape[extrasKey] === "object") return true;
  const typeKey = `${extrasKey}${type3}`;
  if (type3 && typeKey in shape && typeof shape[typeKey] === "object") return true;
  return false;
}
function getExtraOptionsKey(extraKey) {
  return `${extraKey}Options`;
}
function initExtraOptions(shape, extraKey, keys) {
  const optionsKey = getExtraOptionsKey(extraKey);
  for (const option in shape[optionsKey]) {
    const existingOptionsKeys = Object.keys(shape[optionsKey][option]);
    for (const existingKey of existingOptionsKeys) {
      if (!keys.includes(existingKey)) {
        if (existingKey in shape[optionsKey][option]) {
          delete shape[optionsKey][option][existingKey];
        }
      }
    }
    for (const key of keys) {
      if (option === "all" || !(key in shape[optionsKey][option])) {
        shape[optionsKey][option][key] = "";
      }
    }
  }
}
function removeExtras(shape, extrasKey, clearOptions = true) {
  if (!checkIfValidExtra(shape, extrasKey, "Options")) return;
  const extras = shape[extrasKey];
  const extraKeys = Object.keys(extras);
  for (const option of extraKeys) {
    removeSingleExtra(shape, extrasKey, option, clearOptions);
  }
  if (clearOptions) {
    clearExtrasOptions(shape, extrasKey, "all");
  }
}
function removeSingleExtra(shape, extrasKey, option, clearOptions = true) {
  if (clearOptions) clearExtrasOptions(shape, extrasKey, option);
  if (option === "all") return;
  if (checkIfValidExtra(shape, extrasKey)) shape[extrasKey][option] = false;
}
function clearExtrasOptions(shape, extrasKey, option) {
  if (!checkIfValidExtra(shape, extrasKey, "Options")) return;
  const options = shape[`${extrasKey}Options`];
  const optionObj = options[option];
  if (typeof optionObj !== "object" || optionObj === null) return;
  const optionsKeys = Object.keys(optionObj);
  optionsKeys.forEach((key) => optionObj[key] = "");
}
function setExtrasOption(shape, extrasKey, option, key, value2, findExtrasPrice) {
  var _a3;
  const optionsKey = extrasKey + "Options";
  if (!((_a3 = shape == null ? void 0 : shape[optionsKey]) == null ? void 0 : _a3[option])) return;
  if (!(key in shape[optionsKey][option])) return;
  setExtra(shape, extrasKey, option, false);
  shape[optionsKey][option][key] = value2;
  const selectedOptions = shape[optionsKey][option];
  const options = Object.values(selectedOptions || {}).filter((o2) => o2);
  if (!Array.isArray(options)) return;
  const price = getExtrasPrice(shape, extrasKey, option, findExtrasPrice);
  setExtra(shape, extrasKey, option, price ? true : false);
}
function setAllExtrasOptions(shape, extrasKey, option, value2, keysToIgnore = [], findExtrasPrice) {
  const optionsKey = extrasKey + "Options";
  if (!shape[optionsKey] || typeof shape[optionsKey] !== "object") return;
  const options = Object.keys(shape[optionsKey]);
  if (!options.length) return;
  const price = getExtrasPrice(shape, extrasKey, "all", findExtrasPrice);
  const selectedOptions = shape[optionsKey][option];
  const populatedOptions = Object.values(selectedOptions || {}).filter((o2) => o2);
  for (const key of options) {
    if (key === "all") continue;
    if (keysToIgnore.includes(key)) continue;
    setExtrasOption(shape, extrasKey, key, option, value2, findExtrasPrice);
    if (!Array.isArray(populatedOptions)) {
      setExtra(shape, extrasKey, key, false);
    }
    setExtra(shape, extrasKey, key, price ? true : false);
  }
}
function setExtra(shape, extrasKey, option, mark) {
  var _a3;
  if (option === "all") return;
  const optionsKey = getExtraOptionsKey(extrasKey);
  const optionsString = createExtraStringFromOptions((_a3 = shape == null ? void 0 : shape[optionsKey]) == null ? void 0 : _a3[option]);
  if (mark) {
    shape[extrasKey][option] = optionsString || true;
  } else {
    shape[extrasKey][option] = false;
  }
}
function getExtrasPrice(shape, extraType, key, findExtrasPrice) {
  var _a3;
  const optionsKey = extraType + "Options";
  if (!((_a3 = shape == null ? void 0 : shape[optionsKey]) == null ? void 0 : _a3[key])) return false;
  const selectedOptions = shape[optionsKey][key];
  const options = Object.values(selectedOptions || {}).filter((o2) => o2);
  if (!Array.isArray(options)) return false;
  if (!findExtrasPrice || typeof findExtrasPrice !== "function") {
    return false;
  }
  const price = findExtrasPrice(extraType, options);
  if (extraType === "banding" && isCornerSide(key) && price) {
    const bandingCornerPrice = getBandingCornerPrice(shape, key, price);
    return bandingCornerPrice / 1e3;
  }
  return price;
}
function mapLegacyInitData(initData) {
  if (initData == null ? void 0 : initData.type) delete initData.type;
  mapLegacyBanding.call(this, initData);
}
function mapLegacyBanding(initData) {
  if (!(initData == null ? void 0 : initData.banding)) return;
  if (!(typeof initData.banding === "object")) return;
  const bandingKeys = Object.keys(initData.banding);
  if (!bandingKeys.length) return;
  const newBandingKeys = ["labels", "pricing"];
  if (!bandingKeys.every((k2) => newBandingKeys.includes(k2))) {
    this.error("legacy banding data provided - please update to use { labels: string[], pricing: Record<string, number> }");
  } else return;
  initData.banding = {
    labels: Object.keys(initData.banding),
    pricing: initData.bandingPricing
  };
}
function mapLegacyOptions(options) {
  if (options == null ? void 0 : options.enable) return;
  options.enable = {};
  const fieldMap = {
    showDiagram: { new: "diagram", map: "equal" },
    enableFocus: { new: "focus", map: "equal" },
    enableMachining: { new: "machining", map: "equal" },
    enableCSVImport: { new: "csvImport", map: "equal" },
    showProgressNumber: { new: "progressNumber", map: "equal" },
    disableBanding: { new: "banding", map: "reverse" },
    disableFinish: { new: "finish", map: "reverse" },
    disableOrientation: { new: "orientation", map: "reverse" },
    disableClick: { new: "click", map: "reverse" },
    disablePartName: { new: "partName", map: "reverse" }
  };
  for (const oldKey of Object.keys(fieldMap)) {
    if (oldKey in options) {
      options.enable[fieldMap[oldKey].new] = fieldMap[oldKey].map === "reverse" ? !options[oldKey] : options[oldKey];
      delete options[oldKey];
    }
  }
  console.log(options);
}
function shouldRotateDiagram(orientationModel = 0, stockGrainSummary, rectangle = null, rectangleType = null, shapeOrientation = null) {
  if (!isInputShape(rectangle) && !isInputUserGroup || rectangleType === "stock") return false;
  let orientation, rotate;
  if (isInputShape(rectangle)) {
    orientation = rectangle.orientationLock;
  } else if (isInputUserGroup(rectangle)) {
    orientation = rectangle.direction;
  } else if (rectangleType === "shape") {
    orientation = shapeOrientation;
  }
  if (orientationModel === 0 || isInputUserGroup(rectangle)) {
    switch (stockGrainSummary) {
      case "n":
        rotate = orientation === "w" || shapeOrientation === "w";
        break;
      case "l":
      case "y":
        rotate = orientation === "w" || shapeOrientation === "w";
        break;
      case "w":
        rotate = orientation === "l" || shapeOrientation === "l";
        break;
      default:
        rotate = shapeOrientation === "w";
    }
  } else if (orientationModel === 1) {
    rotate = rectangle.w > rectangle.l;
  } else if (orientationModel === 2) {
    switch (stockGrainSummary) {
      case "n":
        rotate = rectangle.w > rectangle.l;
        break;
      case "y":
      case "l":
        rotate = rectangle.w > rectangle.l;
        break;
      case "w":
        rotate = rectangle.l >= rectangle.w;
        break;
      default:
        rotate = false;
    }
  }
  return rotate;
}
function getSideRotation(orientationModel, stockGrainSummary, rectangle = null, rectangleType = null, shapeOrientation = null) {
  if (!isInputShape(rectangle) || rectangleType === "shape") return false;
  let rotate;
  if (orientationModel === 0) {
    return shouldRotateDiagram(orientationModel, stockGrainSummary, rectangle, rectangleType, shapeOrientation) ? "cc" : false;
  } else if (orientationModel === 1) {
    return shouldRotateDiagram(orientationModel, stockGrainSummary, rectangle, rectangleType, shapeOrientation) ? "cc" : false;
  } else if (orientationModel === 2) {
    if (stockGrainSummary === "w") {
      if (rectangle.l < rectangle.w) return "c";
      return "cc";
    }
    return false;
  }
  return rotate;
}
function rotateShapeProperties(shape) {
  if (shape.banding) {
    shape.banding = rotateSides(shape.banding, "cc");
  }
  if (shape.trim) {
    shape.trim = rotateSides(shape.trim, "cc");
  }
}
function mapOrientation(shape, orientationModel = 0) {
  if (!orientationModel) return shape;
  if (orientationModel === 1 || orientationModel === 2) {
    shape.preventAutoRotation = true;
    if (orientationModel === 2) {
      if (shape.l < shape.w) {
        rotateShapeProperties(shape);
      }
    }
  }
  return shape;
}
function rotateSides(sidesObject, direction = "cc", mainSideMapping = {
  "x1": "y1",
  "x2": "y2",
  "y1": "x1",
  "y2": "x2"
}, cornerMapping = {
  "a": "d",
  "b": "a",
  "c": "b",
  "d": "c"
}) {
  const newObject = {
    x1: null,
    x2: null,
    y1: null,
    y2: null
  };
  if (direction === "c") {
    for (const [key, value2] of Object.entries(mainSideMapping)) {
      newObject[value2] = sidesObject[key];
    }
    for (const [key, value2] of Object.entries(cornerMapping)) {
      if (value2 in sidesObject) {
        newObject[value2] = sidesObject[key];
      }
    }
  } else if (direction === "cc") {
    for (const [key, value2] of Object.entries(mainSideMapping)) {
      newObject[key] = sidesObject[value2];
    }
    for (const [key, value2] of Object.entries(cornerMapping)) {
      if (value2 in sidesObject) {
        newObject[key] = sidesObject[value2];
      }
    }
  }
  console.log(newObject);
  return newObject;
}
const _sfc_main$a = {
  name: "StockNavigation",
  props: {
    stockList: {
      type: Array,
      default: () => []
    },
    primaryColor: {
      type: String,
      default: ""
    },
    secondaryColor: {
      type: String,
      default: ""
    },
    activeStockId: {
      type: String,
      default: null
    }
  },
  emits: ["show-stock"],
  methods: {
    showStock(stockID) {
      this.$emit("show-stock", stockID);
    }
  }
};
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$9 = { id: "mini-stock-nav" };
const _hoisted_2$6 = ["onMousedown"];
const _hoisted_3$4 = { class: "id" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.stockList, (stock, index) => {
      return openBlock(), createElementBlock("button", {
        key: index,
        class: normalizeClass(["nav-button", { selected: stock.id === $props.activeStockId }]),
        type: "button",
        style: normalizeStyle({
          backgroundColor: stock.id === $props.activeStockId ? "#" + $props.secondaryColor : "#" + $props.primaryColor
        }),
        onMousedown: ($event) => $options.showStock(stock.id)
      }, [
        createBaseVNode("div", _hoisted_3$4, toDisplayString(index + 1), 1),
        withDirectives(createBaseVNode("div", { class: "stack legibility" }, toDisplayString(stock.stack), 513), [
          [vShow, typeof stock.stack === "number" && stock.stack > 1]
        ])
      ], 46, _hoisted_2$6);
    }), 128))
  ]);
}
const StockNavigation = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$3]]);
const _sfc_main$9 = {
  name: "Spinner",
  props: {
    size: {
      type: Number,
      default: 100
    },
    showNumber: {
      type: Boolean,
      default: true
    },
    number: {
      type: Number,
      default: 0
    },
    complete: {
      type: Boolean,
      default: false
    }
  }
};
const _hoisted_1$8 = { id: "spinner" };
const _hoisted_2$5 = ["width", "height"];
const _hoisted_3$3 = {
  key: 2,
  id: "spinner-number",
  class: "stock-number"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    !$props.complete ? (openBlock(), createElementBlock("svg", {
      key: 0,
      class: "loading",
      style: normalizeStyle({ width: $props.size + "px", height: $props.size + "px" }),
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 300 300"
    }, _cache[0] || (_cache[0] = [
      createStaticVNode('<rect class="square s1" x="0" y="0"></rect><rect class="square s2" x="100" y="0"></rect><rect class="square s3" x="200" y="0"></rect><rect class="square s4" x="0" y="100"></rect><rect class="square s5" x="200" y="100"></rect><rect class="square s6" x="0" y="200"></rect><rect class="square s7" x="100" y="200"></rect>', 7)
    ]), 12, _hoisted_2$5)) : createCommentVNode("", true),
    $props.complete ? (openBlock(), createElementBlock("svg", {
      key: 1,
      class: "complete",
      style: normalizeStyle({ width: $props.size + "px", height: $props.size + "px" }),
      viewBox: "0 0 448 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[1] || (_cache[1] = [
      createBaseVNode("path", { d: "m203.3 331.3c-6.2 6.3-16.4 6.3-22.6 0l-64-64c-6.3-6.2-6.3-16.4 0-22.6 6.2-6.3 16.4-6.3 22.6 0l52.7 52.7 116.7-116.7c6.2-6.3 16.4-6.3 22.6 0 6.3 6.2 6.3 16.4 0 22.6zm-203.3-235.3c0-35.35 28.65-64 64-64h320c35.3 0 64 28.65 64 64v320c0 35.3-28.7 64-64 64h-320c-35.35 0-64-28.7-64-64zm32 0v320c0 17.7 14.33 32 32 32h320c17.7 0 32-14.3 32-32v-320c0-17.67-14.3-32-32-32h-320c-17.67 0-32 14.33-32 32z" }, null, -1)
    ]), 4)) : createCommentVNode("", true),
    $props.showNumber ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString($props.number), 1)) : createCommentVNode("", true)
  ]);
}
const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$2]]);
function getInputMode(type3, units) {
  if (type3 === "unitDependent") {
    return units === "decimal" ? "decimal" : "text";
  }
  if (type3 === "float") return "decimal";
  if (type3 === "integer") return "numeric";
  return "text";
}
function getInputType(type3, units) {
  if (type3 === "unitDependent") {
    return units === "decimal" ? "number" : "text";
  }
  if (type3 === "checkbox") return "checkbox";
  if (type3 === "float") return "number";
  if (type3 === "integer") return "number";
  return "text";
}
function getOutputType(type3, outputType = null, units = "decimal") {
  switch (type3) {
    case "float":
    case "integer":
    case "string":
      return type3;
    case "unitDependent":
      return units === "decimal" ? "float" : "string";
    case "checkbox":
      if (outputType) return outputType;
      return "boolean";
    case "select":
      if (outputType) return outputType;
      return "string";
    default:
      return "string";
  }
}
function parseBoolean(val) {
  if (val) return true;
  return false;
}
function getNestedValue(obj, path2) {
  if (!path2) return null;
  const keys = path2.split(".");
  return keys.reduce((acc, key) => acc && acc[key] !== "undefined" ? acc[key] : void 0, obj);
}
function setNestedValue(obj, path2, value2, force = true) {
  const keys = path2.split(".");
  let current = obj;
  for (let i2 = 0; i2 < keys.length - 1; i2++) {
    if (!current[keys[i2]]) {
      current[keys[i2]] = {};
    }
    current = current[keys[i2]];
  }
  if (force || !valueSet(current[keys[keys.length - 1]])) {
    current[keys[keys.length - 1]] = value2;
  }
}
function setFieldEnabled(allFields, group, type3, fieldId, enabled = true) {
  var _a3;
  if (!allFields) return;
  if (!type3) return;
  if (!fieldId) return;
  if (!((_a3 = allFields == null ? void 0 : allFields[group]) == null ? void 0 : _a3[type3])) return;
  const field = allFields[group][type3].find((f2) => f2.id === fieldId);
  if (!field) return;
  if (enabled) {
    field.enabled = true;
  } else {
    field.enabled = false;
  }
  return true;
}
function getEnabledFields(allFields, group, type3) {
  var _a3;
  if (!((_a3 = allFields == null ? void 0 : allFields[group]) == null ? void 0 : _a3[type3])) return [];
  return allFields[group][type3].filter((f2) => f2.enabled === true).map((f2) => f2.id);
}
function getRelevantFieldDefinitions(allFields, fieldDefinitions, group, type3, order = []) {
  const enabledFields = getEnabledFields(allFields, group, type3);
  if (!enabledFields.length) return [];
  const relevantFieldDefinitions = fieldDefinitions.filter((def) => enabledFields.includes(def.id) || def.custom === true);
  const filteredFieldDefinitions = relevantFieldDefinitions.filter((f2) => (f2 == null ? void 0 : f2.fieldMap) && !f2.fieldMap.startsWith("customData."));
  if (enabledFields.length !== filteredFieldDefinitions.length) {
    const filteredIds = new Set(filteredFieldDefinitions.map((field) => field.id));
    const missingIds = relevantFieldDefinitions.map((field) => field.id).filter((id) => !filteredIds.has(id)).map((id) => `'${id}'`);
    console.warn(`Inputs - these fields do not have a field definition - ${missingIds.join()}`);
  }
  if (!order.length) return relevantFieldDefinitions;
  relevantFieldDefinitions.sort((a2, b2) => {
    const indexA = order.indexOf(a2.id);
    const indexB = order.indexOf(b2.id);
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
  return relevantFieldDefinitions;
}
const _hoisted_1$7 = ["id"];
const _hoisted_2$4 = {
  key: 0,
  class: "delete",
  viewBox: "0 0 512 512",
  xmlns: "http://www.w3.org/2000/svg"
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "OrientationButton",
  props: {
    id: { default: "" },
    orientationModel: { default: 0 },
    rectangleType: { default: null },
    rectangle: { default: () => null },
    shapeOrientation: { default: "" },
    stockGrain: { default: "n" },
    buttonBackground: { default: "#848484" },
    iconColor: { default: "#FFFFFF" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["updateOrientation"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const orientationIndex = ref(0);
    const orientationOptions = computed(() => {
      if (!props.rectangle) return ["l", "w"];
      if (isInputUserGroup(props.rectangle)) return ["l", "w"];
      let options = ["", "l", "w"];
      if (props.rectangle.multiEdit) options = [" ", "", "l", "w"];
      if (isSquare.value) {
        options = options.filter((option) => option !== "w");
      }
      return options;
    });
    const isSquare = computed(() => {
      var _a3, _b2, _c, _d;
      if (isInputShape(props.rectangle) || isInputStock(props.rectangle)) {
        return props.rectangle.isSquare();
      }
      if (props.rectangleType && ((_a3 = props.rectangle) == null ? void 0 : _a3.l) && ((_b2 = props.rectangle) == null ? void 0 : _b2.w)) {
        return ((_c = props.rectangle) == null ? void 0 : _c.l) === ((_d = props.rectangle) == null ? void 0 : _d.w);
      }
      return false;
    });
    const calculateOrientationLock = () => {
      if (!isInputShape(props.rectangle)) return "";
      let calculatedOrientationLock = "";
      switch (props.orientationModel) {
        case 0:
          calculatedOrientationLock = currentOrientation.value;
          break;
        case 1:
          if (props.stockGrain === "y" || props.stockGrain === "n") calculatedOrientationLock = props.rectangle.l >= props.rectangle.w ? "l" : "w";
          else if (props.rectangle.l >= props.rectangle.w) calculatedOrientationLock = props.stockGrain;
          else calculatedOrientationLock = calculatedOrientationLock = props.stockGrain === "l" ? "w" : "l";
          break;
        case 2:
          calculatedOrientationLock = props.rectangle.l >= props.rectangle.w ? "l" : "w";
          break;
      }
      return calculatedOrientationLock;
    };
    const getCurrentOrientationIndex = (orientation) => {
      const index = orientationOptions.value.findIndex((o2) => o2 === orientation);
      return index;
    };
    const click = () => {
      if (props.disabled) return;
      if (orientationOptions.value.length <= 1) return;
      let requiredIndex = null;
      if ([1, 2].includes(props.orientationModel)) {
        if (currentOrientation.value === "") {
          const requiredOrientationLock = calculateOrientationLock();
          requiredIndex = orientationOptions.value.findIndex((o2) => o2 === requiredOrientationLock);
        } else {
          requiredIndex = orientationOptions.value.findIndex((o2) => o2 === "");
        }
      } else if (props.orientationModel === 0) {
        const currentIndex = getCurrentOrientationIndex(currentOrientation.value);
        requiredIndex = currentIndex + 1;
        if (requiredIndex > orientationOptions.value.length - 1) requiredIndex = 0;
      }
      orientationIndex.value = requiredIndex;
    };
    const handleKeyDown = (e) => {
      if (e.key === "Enter" || e.key === " ") click();
    };
    const emitOrientationUpdate = (newValue) => {
      emit("updateOrientation", newValue);
    };
    const getModelIconKey = () => {
      const orientation = currentOrientation.value;
      switch (props.orientationModel) {
        case 0:
          if (!orientation) return "default";
          if (props.stockGrain === "n") return orientation || props.shapeOrientation || "default";
          return props.stockGrain === "w" ? orientation === "w" ? "w" : "l" : orientation === "l" ? "l" : "w";
        case 1:
          if (!orientation) return "default";
          if (props.stockGrain === "n") return orientation || props.shapeOrientation || "default";
          return props.stockGrain === "w" ? orientation === "w" ? "w" : "l" : orientation === "l" ? "l" : "w";
        case 2:
          if (!orientation) return "default";
          if (props.stockGrain === "n") return orientation || props.shapeOrientation || "default";
          return props.stockGrain === "w" ? orientation === "w" ? "w" : "l" : orientation === "l" ? "l" : "w";
        default:
          return "default";
      }
    };
    const currentOrientation = computed(() => {
      let orientation = "";
      if (isInputUserGroup(props.rectangle)) {
        orientation = props.rectangle.direction;
      } else if (isInputShape(props.rectangle)) {
        orientation = props.rectangle.orientationLock;
      } else if (isInputStock(props.rectangle)) {
        orientation = props.rectangle.grain;
      }
      return orientation;
    });
    const dimensions = computed(() => {
      if (isInputUserGroup(props.rectangle) || !props.rectangle) return {
        l: null,
        w: null
      };
      return {
        l: props.rectangle.l,
        w: props.rectangle.w
      };
    });
    const shouldRotate = computed(() => {
      return shouldRotateDiagram(
        props.orientationModel,
        props.stockGrain,
        props.rectangle,
        props.rectangleType,
        props.shapeOrientation
      );
    });
    const icon = computed(() => {
      var _a3;
      if (!props.rectangle) {
        return !props.shapeOrientation ? "freeRotation" : "noGrain";
      }
      if (isInputStock(props.rectangle) || props.rectangleType === "stock") {
        const grainMap = {
          " ": "delete",
          "l": "grainLeftRight",
          "w": "grainTopBottom"
        };
        return grainMap[props.rectangle.grain] || "noGrain";
      }
      const iconMap = {
        n: { " ": "delete", l: "leftRight", w: "leftRight", default: "freeRotation" },
        y: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        l: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        w: { " ": "delete", l: "grainLeftRight", w: "grainTopBottom", default: "freeRotation" },
        default: { " ": "delete", l: "leftRight", w: "topBottom", default: "freeRotation" }
      };
      const grain = props.stockGrain || "default";
      let iconKey = "default";
      if (isInputShape(props.rectangle) || props.rectangleType === "shape") {
        iconKey = getModelIconKey();
      } else if (isInputUserGroup(props.rectangle)) {
        iconKey = props.rectangle.direction || "default";
      }
      return ((_a3 = iconMap[grain]) == null ? void 0 : _a3[iconKey]) || iconMap[grain].default;
    });
    watch(orientationIndex, (newIndex) => {
      emitOrientationUpdate(orientationOptions.value[newIndex]);
    }, { immediate: false });
    watch(dimensions, () => {
      if (!props.rectangle) return;
      if (props.orientationModel === 0) return;
      if (!isInputShape(props.rectangle)) return;
      const requiredOrientationLock = calculateOrientationLock();
      if (!currentOrientation.value) return;
      if (currentOrientation.value === requiredOrientationLock) return;
      emitOrientationUpdate(requiredOrientationLock);
    }, { immediate: false });
    onMounted(() => {
      document.addEventListener("keydown", handleKeyDown);
      if (isInputShape(props.rectangle)) {
        orientationIndex.value = getCurrentOrientationIndex(calculateOrientationLock());
      } else {
        orientationIndex.value = getCurrentOrientationIndex(currentOrientation.value);
      }
    });
    onUnmounted(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: _ctx.id,
        class: normalizeClass(["orientation-button", { rot: shouldRotate.value, square: isSquare.value, disabled: _ctx.disabled, [icon.value]: true }]),
        tabindex: "0",
        "aria-label": "Part orientation",
        style: normalizeStyle({
          backgroundColor: _ctx.buttonBackground
        }),
        onClick: click
      }, [
        icon.value === "delete" ? (openBlock(), createElementBlock("svg", _hoisted_2$4, _cache[0] || (_cache[0] = [
          createBaseVNode("path", { d: "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z" }, null, -1)
        ]))) : createCommentVNode("", true),
        icon.value === "freeRotation" ? (openBlock(), createElementBlock("svg", {
          key: 1,
          class: "arrow",
          style: normalizeStyle({
            stroke: _ctx.iconColor ? _ctx.iconColor : "#ffffff"
          }),
          viewBox: "0 0 67 63",
          xmlns: "http://www.w3.org/2000/svg"
        }, _cache[1] || (_cache[1] = [
          createBaseVNode("g", null, [
            createBaseVNode("path", { d: "m9.296 31.378c0-3.305.67-6.455 1.88-9.322 3.642-8.621 12.179-14.678 22.12-14.678 10.63 0 19.656 6.927 22.806 16.509" }),
            createBaseVNode("path", { d: "m57.296 31.378c0 13.246-10.754 24-24 24-10.631 0-19.656-6.926-22.806-16.508" }),
            createBaseVNode("path", { d: "m61.183 5.408-4.622 17.851-18.347-1.838" }),
            createBaseVNode("path", { d: "m5.408 57.349 4.622-17.851 18.348 1.838" })
          ], -1)
        ]), 4)) : createCommentVNode("", true),
        icon.value === "leftRight" ? (openBlock(), createElementBlock("svg", {
          key: 2,
          class: "arrow",
          style: normalizeStyle({
            stroke: _ctx.iconColor ? _ctx.iconColor : "#ffffff"
          }),
          viewBox: "0 0 72 39",
          xmlns: "http://www.w3.org/2000/svg"
        }, _cache[2] || (_cache[2] = [
          createBaseVNode("g", null, [
            createBaseVNode("path", { d: "m5.408 19.408h61.095" }),
            createBaseVNode("g", null, [
              createBaseVNode("path", { d: "m52.695 5.408 13.808 14-13.808 14" }),
              createBaseVNode("path", { d: "m17.408 33.408-12-14 12-14" })
            ])
          ], -1)
        ]), 4)) : createCommentVNode("", true),
        icon.value === "topBottom" ? (openBlock(), createElementBlock("svg", {
          key: 3,
          class: "arrow",
          style: normalizeStyle({
            stroke: _ctx.iconColor ? _ctx.iconColor : "#ffffff"
          }),
          viewBox: "0 0 39 72",
          xmlns: "http://www.w3.org/2000/svg"
        }, _cache[3] || (_cache[3] = [
          createBaseVNode("g", null, [
            createBaseVNode("path", { d: "m19.408 66.503v-61.095" }),
            createBaseVNode("g", null, [
              createBaseVNode("path", { d: "m5.408 19.216 14-13.808 14 13.808" }),
              createBaseVNode("path", { d: "m33.408 54.503-14 12-14-12" })
            ])
          ], -1)
        ]), 4)) : createCommentVNode("", true),
        icon.value === "grainLeftRight" ? (openBlock(), createElementBlock("svg", {
          key: 4,
          class: "grain",
          style: normalizeStyle({
            stroke: _ctx.iconColor ? _ctx.iconColor : "#ffffff"
          }),
          viewBox: "0 0 106 64",
          xmlns: "http://www.w3.org/2000/svg"
        }, _cache[4] || (_cache[4] = [
          createBaseVNode("g", null, [
            createBaseVNode("path", { d: "m3 3h99.887" }),
            createBaseVNode("path", { d: "m3.113 32h99.887" }),
            createBaseVNode("path", { d: "m3.113 61h99.887" })
          ], -1)
        ]), 4)) : createCommentVNode("", true),
        icon.value === "grainTopBottom" ? (openBlock(), createElementBlock("svg", {
          key: 5,
          class: "grain",
          style: normalizeStyle({
            stroke: _ctx.iconColor ? _ctx.iconColor : "#ffffff"
          }),
          viewBox: "0 0 64 106",
          xmlns: "http://www.w3.org/2000/svg"
        }, _cache[5] || (_cache[5] = [
          createBaseVNode("g", null, [
            createBaseVNode("path", { d: "m61 3v99.887" }),
            createBaseVNode("path", { d: "m32 3.113v99.887" }),
            createBaseVNode("path", { d: "m3 3.113v99.887" })
          ], -1)
        ]), 4)) : createCommentVNode("", true)
      ], 14, _hoisted_1$7);
    };
  }
});
const _hoisted_1$6 = ["id"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "BandingButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: false },
    id: { default: "" },
    orientationModel: { default: 0 },
    stockGrain: { default: "n" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["clicked"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const bandingState = ref({
      x1: false,
      x2: false,
      y1: false,
      y2: false
    });
    watch(() => props.inputShape.orientationLock, () => {
      let bandingObject = {
        x1: props.inputShape.banding.x1,
        x2: props.inputShape.banding.x2,
        y1: props.inputShape.banding.y1,
        y2: props.inputShape.banding.y2
      };
      const requiredRotation = getSideRotation(
        props.orientationModel,
        props.stockGrain,
        props.inputShape
      );
      if (requiredRotation) {
        bandingObject = rotateSides(bandingObject, requiredRotation, {
          "x1": "y2",
          "x2": "y1",
          "y1": "x1",
          "y2": "x2"
        });
      }
      bandingState.value = bandingObject;
    }, { deep: true, immediate: true });
    watch([
      () => {
        var _a3;
        return (_a3 = props.inputShape) == null ? void 0 : _a3.banding;
      },
      () => props.orientationModel,
      () => props.stockGrain,
      () => {
        var _a3;
        return (_a3 = props.inputShape) == null ? void 0 : _a3.orientationLock;
      }
    ], () => {
      var _a3;
      if (!((_a3 = props.inputShape) == null ? void 0 : _a3.banding)) return;
      let bandingObject = {
        x1: props.inputShape.banding.x1,
        x2: props.inputShape.banding.x2,
        y1: props.inputShape.banding.y1,
        y2: props.inputShape.banding.y2
      };
      const requiredRotation = getSideRotation(
        props.orientationModel,
        props.stockGrain,
        props.inputShape
      );
      if (requiredRotation) {
        bandingObject = rotateSides(bandingObject, requiredRotation, {
          "x1": "y2",
          "x2": "y1",
          "y1": "x1",
          "y2": "x2"
        });
      }
      bandingState.value = bandingObject;
    }, { deep: true, immediate: true });
    const mappedBanding = computed(() => bandingState.value);
    const handleKeyDown = (e) => {
      if (e.key === "Enter" || e.key === " ") click();
    };
    const click = () => {
      if (props.disabled) return;
      emit("clicked");
    };
    onMounted(() => {
      var _a3;
      (_a3 = document.getElementById(props.id)) == null ? void 0 : _a3.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      var _a3;
      (_a3 = document.getElementById(props.id)) == null ? void 0 : _a3.removeEventListener("keydown", handleKeyDown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: _ctx.id,
        class: normalizeClass(["banding-button", { open: _ctx.open, disabled: _ctx.disabled }]),
        tabindex: "0",
        onClick: click
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["outer", {
            x1: mappedBanding.value.x1,
            x2: mappedBanding.value.x2,
            y1: mappedBanding.value.y1,
            y2: mappedBanding.value.y2
          }])
        }, _cache[0] || (_cache[0] = [
          createBaseVNode("div", { class: "inner" }, null, -1)
        ]), 2)
      ], 10, _hoisted_1$6);
    };
  }
});
const inputTypes = ["unitDependent", "string", "integer", "float", "checkbox", "select"];
const _sfc_main$6 = {
  name: "CustomInput",
  props: {
    type: {
      type: String,
      default: "string",
      validator(value2) {
        return inputTypes.includes(value2);
      }
    },
    value: {
      type: [String, Boolean, Number],
      default: null
    },
    //element id
    id: {
      type: String,
      default: ""
    },
    focus: {
      type: Boolean,
      default: false
    },
    enableLabel: {
      type: Boolean,
      default: true
    },
    labelPosition: {
      type: String,
      default: "first",
      validator(value2) {
        return ["first", "last"].includes(value2);
      }
    },
    //used for select / checkbox
    output: {
      type: String,
      default: "string",
      validator(value2) {
        return ["string", "integer", "float", "boolean"].includes(value2);
      }
    },
    options: {
      type: Array,
      default: () => []
    },
    selectFirstOptionDisabled: {
      type: Boolean,
      default: true
    },
    placeholder: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: true
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: false
    },
    default: {
      type: [String, Number, Boolean],
      default: ""
    },
    units: {
      type: String,
      default: "decimal",
      validator(value2) {
        return ["decimal", "fraction"].includes(value2);
      }
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    custom: {
      type: Boolean,
      default: false
    },
    multiEdit: {
      type: Boolean,
      default: false
    },
    allowBlank: {
      type: Boolean,
      default: false
    },
    text: {
      type: Object,
      default: () => {
        return {
          select: "Select",
          delete: "Delete"
        };
      }
    },
    issue: {
      type: Boolean,
      default: false
    },
    warning: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update", "default"],
  computed: {
    thisId() {
      return this.custom ? "custom-" + this.id : this.id;
    },
    inputType() {
      return getInputType(this.type, this.units);
    },
    inputMode() {
      return getInputMode(this.type, this.units);
    },
    outputType() {
      return getOutputType(this.type, this.output, this.units);
    }
  },
  watch: {
    options: {
      handler() {
        if (!this.value) return;
        if (!this.options.find((option) => option.value == this.value)) {
          this.updateValue("");
        }
      },
      deep: false,
      immediate: false
    }
    /* value: {
    	handler( value )
    	{
    		console.log( 'value changed', value )
    	},
    	deep: false,
    	immediate: true
    } */
  },
  created() {
    this.setDefault();
  },
  mounted() {
    const input = getRef.call(this, "input");
    if (input && this.focus) {
      this.$nextTick(() => input.focus());
    }
  },
  methods: {
    getType() {
      if (this.type === "unitDependent") {
        return this.units === "fraction" ? "string" : "float";
      }
      return this.type;
    },
    handleInput(event) {
      let value2 = event.target.value;
      if ((value2 === "" || value2 === null) && this.allowBlank) this.updateValue(null);
      switch (this.getType()) {
        case "integer":
          value2 = value2.replace(/[^0-9-]/g, "");
          value2 = parseInt(value2);
          break;
        case "float":
          value2 = value2.replace(/[^0-9.-]/g, "");
          value2 = parseFloat(value2);
          break;
      }
      if (this.getType() === "integer" || this.getType() === "float") {
        if (isNaN(value2)) return this.updateValue(null);
      }
      if (typeof this.min === "number") {
        if (value2 < this.min) value2 = this.min;
      }
      if (typeof this.max === "number") {
        if (value2 > this.max) value2 = this.max;
      }
      this.updateValue(value2);
    },
    updateValue(value2, updateType = "update") {
      if (value2 === null) return this.$emit(updateType, value2);
      if (this.type === "unitDependent" || this.output === "unitDependent") {
        if (this.units === "fraction") {
          value2 = value2.replace(/[^0-9/ ]+/g, "").replace(/\s{2,}/g, " ").trim();
          return this.$emit(updateType, value2);
        } else if (this.units === "decimal") {
          return this.$emit(updateType, parseFloat(value2));
        }
      }
      switch (this.outputType) {
        case "string":
          return this.$emit(updateType, value2);
        case "integer":
          return this.$emit(updateType, parseInt(value2));
        case "float":
          return this.$emit(updateType, parseFloat(value2));
        case "boolean":
          return this.$emit(updateType, parseBoolean(value2));
        default:
          return this.$emit(updateType, value2);
      }
    },
    setDefault() {
      if (!valueSet(this.value) && valueSet(this.default)) {
        this.updateValue(this.default);
      }
    }
  }
};
const _hoisted_1$5 = ["for"];
const _hoisted_2$3 = ["id", "inputmode", "type", "value", "placeholder", "disabled", "readonly", "min", "max", "aria-label"];
const _hoisted_3$2 = ["id", "disabled", "checked", "aria-label"];
const _hoisted_4$2 = ["id", "value", "disabled", "aria-label"];
const _hoisted_5$2 = ["disabled", "selected"];
const _hoisted_6$2 = {
  key: 0,
  value: " "
};
const _hoisted_7$2 = ["hidden", "value"];
const _hoisted_8$1 = ["for"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _a3, _b2, _c, _d;
  return openBlock(), createElementBlock(Fragment, null, [
    $props.label && $props.enableLabel && $props.labelPosition === "first" ? (openBlock(), createElementBlock("label", {
      key: 0,
      for: $options.thisId
    }, toDisplayString($props.label), 9, _hoisted_1$5)) : createCommentVNode("", true),
    $props.type === "string" || $props.type === "integer" || $props.type === "float" || $props.type === "unitDependent" ? (openBlock(), createElementBlock("input", {
      key: 1,
      id: $options.thisId,
      ref: "input",
      inputmode: $options.inputMode,
      type: $options.inputType,
      value: $props.value,
      placeholder: $props.placeholder,
      disabled: $props.disabled,
      readonly: $props.readonly,
      class: normalizeClass({ "issue": $props.issue, "warning": $props.warning }),
      min: $props.min,
      max: $props.max,
      "aria-label": $props.label,
      onChange: _cache[0] || (_cache[0] = (...args) => $options.handleInput && $options.handleInput(...args))
    }, null, 42, _hoisted_2$3)) : createCommentVNode("", true),
    $props.type === "checkbox" ? (openBlock(), createElementBlock("input", {
      key: 2,
      id: $options.thisId,
      ref: "input",
      type: "checkbox",
      disabled: $props.readonly || $props.disabled,
      checked: $props.value === $props.trueValue,
      "aria-label": $props.label,
      class: normalizeClass({ "issue": $props.issue, "warning": $props.warning }),
      onChange: _cache[1] || (_cache[1] = ($event) => $options.updateValue($event.target.checked ? $props.trueValue : $props.falseValue))
    }, null, 42, _hoisted_3$2)) : createCommentVNode("", true),
    $props.type === "select" ? (openBlock(), createElementBlock("select", {
      key: 3,
      id: $options.thisId,
      ref: "input",
      value: $props.value,
      disabled: $props.readonly || $props.disabled,
      "aria-label": $props.label,
      class: normalizeClass({ "issue": $props.issue, "warning": $props.warning }),
      onChange: _cache[2] || (_cache[2] = ($event) => $options.updateValue($event.target.value))
    }, [
      createBaseVNode("option", {
        value: "",
        disabled: $props.selectFirstOptionDisabled,
        selected: !$props.value
      }, toDisplayString(((_b2 = (_a3 = $props.text) == null ? void 0 : _a3.select) == null ? void 0 : _b2.toUpperCase()) ?? "SELECT"), 9, _hoisted_5$2),
      $props.multiEdit ? (openBlock(), createElementBlock("option", _hoisted_6$2, toDisplayString(((_d = (_c = $props.text) == null ? void 0 : _c.delete) == null ? void 0 : _d.toUpperCase()) ?? "DELETE"), 1)) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (option) => {
        var _a4, _b3, _c2;
        return openBlock(), createElementBlock("option", {
          key: option.value,
          hidden: option.hidden,
          value: option.value
        }, toDisplayString(((_a4 = option == null ? void 0 : option.label) == null ? void 0 : _a4.toUpperCase()) ?? ((_c2 = (_b3 = option == null ? void 0 : option.value) == null ? void 0 : _b3.toString()) == null ? void 0 : _c2.toUpperCase())), 9, _hoisted_7$2);
      }), 128))
    ], 42, _hoisted_4$2)) : createCommentVNode("", true),
    $props.label && $props.enableLabel && $props.labelPosition === "last" ? (openBlock(), createElementBlock("label", {
      key: 4,
      for: $props.id
    }, toDisplayString($props.label), 9, _hoisted_8$1)) : createCommentVNode("", true)
  ], 64);
}
const InputField = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$1]]);
const _hoisted_1$4 = {
  key: 0,
  class: "inputs"
};
const _hoisted_2$2 = { class: "label" };
const _hoisted_3$1 = { class: "label" };
const _hoisted_4$1 = { class: "label" };
const _hoisted_5$1 = ["onClick"];
const _hoisted_6$1 = { class: "price" };
const _hoisted_7$1 = ["aria-label"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ExtrasInputs",
  props: {
    translate: { type: Boolean, default: true },
    shape: {},
    shapeIndex: { default: 0 },
    extraType: {},
    extraLabel: {},
    extraKeys: {},
    allOptions: {},
    pricing: { default: () => ({}) },
    labels: {},
    userFriendlyFieldMap: {},
    partColumns: {},
    orientationModel: { default: 0 },
    getPrice: {},
    formatPrice: {},
    getAvailablePricingOptions: {}
  },
  emits: ["update-all", "set"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { t: t2 } = useI18n({
      inheritLocale: true,
      useScope: "global"
    });
    const preFlightIssues = ref(false);
    const extraOptionsKey = computed(() => props.extraType + "Options");
    const columnsStyle = computed(() => {
      var _a3;
      if (!((_a3 = props.allOptions) == null ? void 0 : _a3.length)) return "auto";
      const numOptions = props.allOptions.length;
      if (!numOptions) return "auto";
      const cols = numOptions + 3;
      return `repeat(${cols - 1}, minmax(20px, max-content)) 1fr`;
    });
    const updateAll = (key, value2) => {
      emit("update-all", props.shape, props.extraType, key, value2);
    };
    const setOption = (key, option, value2) => {
      emit("set", props.shape, props.extraType, key, option, value2);
    };
    const getPricingOptions = (pricing, shape, option, key, optionsIndex) => {
      var _a3;
      if (!pricing) return [];
      const options = (_a3 = shape == null ? void 0 : shape[option]) == null ? void 0 : _a3[key];
      if (!options) {
        console.error(`ExtrasInputs: cannot find pricing options for ${option} > ${key}`);
        return [];
      }
      const values = Object.values(options);
      if (!values.length) {
        console.error(`ExtrasInputs: cannot find pricing options for ${option} > ${key}`);
        return [];
      }
      const theseOptions = values.filter((value2) => typeof value2 === "string");
      if (!props.getAvailablePricingOptions) {
        console.error("ExtrasInputs: cannot find pricing function in parent");
        return [];
      }
      return props.getAvailablePricingOptions(pricing, theseOptions, optionsIndex);
    };
    const getPrice = (key) => {
      if (!props.pricing || !Object.values(props.pricing).length) return "";
      if (!props.getPrice) {
        console.error("ExtrasInputs: cannot find getExtrasPrice or formatPrice in parent");
        return "";
      }
      const price = props.getPrice(props.shape, props.extraType, key);
      if (!price) return "";
      return props.formatPrice(price);
    };
    const preFlightCheck = () => {
      const issues = [];
      if (!(props.extraType in props.shape)) {
        issues.push({ message: `The extra type '${props.extraType}' does not exist in the shape.` });
      }
      if (!(extraOptionsKey.value in props.shape)) {
        issues.push({ message: `The options key '${extraOptionsKey.value}' does not exist in the shape.` });
      }
      if (issues.length) {
        preFlightIssues.value = true;
        console.error("pre-flight issues found in ExtrasInputs: " + issues.map((i2) => i2.message).join(" "));
      }
    };
    const upper = (string2) => upperCase(string2);
    onMounted(() => preFlightCheck());
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h;
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      return !preFlightIssues.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["extras group", [_ctx.extraType]]),
        style: normalizeStyle({ "grid-column-end": "span " + (_ctx.partColumns + 1) })
      }, [
        _ctx.allOptions.length === 1 && _ctx.allOptions[0].length === 1 ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
          createBaseVNode("div", _hoisted_2$2, toDisplayString(upper((_b2 = (_a3 = _ctx.allOptions) == null ? void 0 : _a3[0]) == null ? void 0 : _b2[0])), 1),
          ((_c = _ctx.shape) == null ? void 0 : _c[extraOptionsKey.value]) && "all" in _ctx.shape[extraOptionsKey.value] ? (openBlock(), createBlock(InputField, {
            key: 0,
            id: `${_ctx.extraType}-all-${_ctx.shapeIndex}`,
            type: "checkbox",
            label: upper(unref(t2)("all")),
            "true-value": (_e = (_d = _ctx.allOptions) == null ? void 0 : _d[0]) == null ? void 0 : _e[0],
            "false-value": "",
            value: (_g = _ctx.shape[extraOptionsKey.value]["all"]) == null ? void 0 : _g[(_f = _ctx.labels) == null ? void 0 : _f[0]],
            onUpdate: _cache[0] || (_cache[0] = (value2) => {
              var _a4, _b3;
              setOption("all", (_a4 = _ctx.labels) == null ? void 0 : _a4[0], value2);
              updateAll((_b3 = _ctx.labels) == null ? void 0 : _b3[0], value2);
            })
          }, null, 8, ["id", "label", "true-value", "value"])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.extraKeys, (key) => {
            var _a4, _b3, _c2, _d2, _e2, _f2;
            return openBlock(), createElementBlock(Fragment, { key }, [
              ((_a4 = _ctx.labels) == null ? void 0 : _a4[0]) && ((_c2 = (_b3 = _ctx.shape) == null ? void 0 : _b3[extraOptionsKey.value]) == null ? void 0 : _c2[key]) && _ctx.labels[0] in _ctx.shape[extraOptionsKey.value][key] ? (openBlock(), createBlock(InputField, {
                key: 0,
                id: `${_ctx.extraType}-${key}-${_ctx.shapeIndex}`,
                type: "checkbox",
                label: upper(unref(t2)((_d2 = _ctx.userFriendlyFieldMap) == null ? void 0 : _d2[key])),
                "true-value": (_f2 = (_e2 = _ctx.allOptions) == null ? void 0 : _e2[0]) == null ? void 0 : _f2[0],
                "false-value": "",
                value: _ctx.shape[extraOptionsKey.value][key][_ctx.labels[0]],
                onUpdate: (value2) => setOption(key, _ctx.labels[0], value2)
              }, null, 8, ["id", "label", "true-value", "value", "onUpdate"])) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ])) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "grid inputs",
          style: normalizeStyle({
            "grid-template-columns": columnsStyle.value
          })
        }, [
          ((_h = _ctx.shape) == null ? void 0 : _h[extraOptionsKey.value]) && "all" in _ctx.shape[extraOptionsKey.value] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_3$1, toDisplayString(upper(unref(t2)("all"))), 1),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.allOptions, (options, optionsIndex) => {
              var _a4, _b3;
              return openBlock(), createBlock(InputField, {
                id: `${_ctx.extraType}-all-${_ctx.labels[optionsIndex]}-${optionsIndex}-${_ctx.shapeIndex}`,
                key: `${_ctx.extraType}-all-${_ctx.labels[optionsIndex]}-${optionsIndex}-${_ctx.shapeIndex}`,
                type: "select",
                disabled: getPricingOptions(_ctx.pricing, _ctx.shape, extraOptionsKey.value, "all", optionsIndex).length === 0,
                options: getPricingOptions(_ctx.pricing, _ctx.shape, extraOptionsKey.value, "all", optionsIndex).map((option) => ({ value: option, label: option })),
                text: { select: "✘" },
                "select-first-option-disabled": false,
                value: (_b3 = _ctx.shape[extraOptionsKey.value]["all"]) == null ? void 0 : _b3[(_a4 = _ctx.labels) == null ? void 0 : _a4[optionsIndex]],
                onUpdate: (value2) => {
                  var _a5, _b4;
                  setOption("all", (_a5 = _ctx.labels) == null ? void 0 : _a5[optionsIndex], value2);
                  updateAll((_b4 = _ctx.labels) == null ? void 0 : _b4[optionsIndex], value2);
                }
              }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
            }), 128)),
            _cache[2] || (_cache[2] = createBaseVNode("div", null, null, -1)),
            _cache[3] || (_cache[3] = createBaseVNode("div", null, null, -1))
          ], 64)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.extraKeys, (option) => {
            var _a4, _b3;
            return openBlock(), createElementBlock(Fragment, { key: option }, [
              ((_a4 = _ctx.shape) == null ? void 0 : _a4[extraOptionsKey.value]) && option in _ctx.shape[extraOptionsKey.value] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_4$1, toDisplayString(upper(unref(t2)((_b3 = _ctx.userFriendlyFieldMap) == null ? void 0 : _b3[option]))), 1),
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.allOptions, (options, optionsIndex) => {
                  var _a5;
                  return openBlock(), createBlock(InputField, {
                    id: `${_ctx.extraType}-${option}-${_ctx.labels[optionsIndex]}-${optionsIndex}-${_ctx.shapeIndex}`,
                    key: `${_ctx.extraType}-${option}-${_ctx.labels[optionsIndex]}-${optionsIndex}-${_ctx.shapeIndex}`,
                    type: "select",
                    disabled: getPricingOptions(_ctx.pricing, _ctx.shape, extraOptionsKey.value, option, optionsIndex).length === 0,
                    options: getPricingOptions(_ctx.pricing, _ctx.shape, extraOptionsKey.value, option, optionsIndex).map((option2) => ({
                      value: option2,
                      label: option2
                    })),
                    text: { select: "✘" },
                    "select-first-option-disabled": false,
                    value: _ctx.shape[extraOptionsKey.value][option][(_a5 = _ctx.labels) == null ? void 0 : _a5[optionsIndex]],
                    onUpdate: (value2) => {
                      var _a6;
                      return setOption(option, (_a6 = _ctx.labels) == null ? void 0 : _a6[optionsIndex], value2);
                    }
                  }, null, 8, ["id", "disabled", "options", "value", "onUpdate"]);
                }), 128))
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: "delete",
                onClick: () => unref(removeSingleExtra)(_ctx.shape, _ctx.extraType, option)
              }, [
                createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] })
              ], 8, _hoisted_5$1),
              createBaseVNode("div", _hoisted_6$1, toDisplayString(getPrice(option) || unref(t2)("N/A")), 1)
            ], 64);
          }), 128))
        ], 4)),
        createBaseVNode("button", {
          type: "button",
          class: "delete icon-left",
          "aria-label": unref(t2)(`delete ${_ctx.extraLabel}`),
          onClick: _cache[1] || (_cache[1] = () => unref(removeExtras)(_ctx.shape, _ctx.extraType, true))
        }, [
          createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] }),
          createTextVNode(" " + toDisplayString(unref(t2)(`delete ${_ctx.extraLabel}`)), 1)
        ], 8, _hoisted_7$1)
      ], 6)) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$3 = ["id", "disabled"];
const _hoisted_2$1 = { class: "icon" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "FinishButton",
  props: {
    inputShape: { default: null },
    open: { type: Boolean, default: false },
    id: { default: "" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["clicked"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const click = () => {
      if (props.disabled) return;
      emit("clicked");
    };
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d;
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      return openBlock(), createElementBlock("button", {
        id: _ctx.id,
        class: normalizeClass(["finish-button", {
          "face-a": (_b2 = (_a3 = _ctx.inputShape) == null ? void 0 : _a3.finish) == null ? void 0 : _b2.a,
          "face-b": (_d = (_c = _ctx.inputShape) == null ? void 0 : _c.finish) == null ? void 0 : _d.b,
          "selected": _ctx.open
        }]),
        type: "button",
        tabindex: "0",
        disabled: _ctx.disabled,
        onClick: click
      }, [
        createBaseVNode("div", _hoisted_2$1, [
          createVNode(_component_font_awesome_icon, { icon: ["fass", "spray-can"] })
        ]),
        _cache[0] || (_cache[0] = createBaseVNode("div", { class: "indicator" }, null, -1))
      ], 10, _hoisted_1$3);
    };
  }
});
const _sfc_main$3 = defineComponent({
  name: "MachiningButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    },
    id: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["open"],
  computed: {
    hasMachining() {
      return hasMachining(this.inputShape);
    },
    disabledOrReadonly() {
      var _a3;
      return this.disabled || (((_a3 = this.inputShape) == null ? void 0 : _a3.readonly) ? true : false);
    }
  },
  methods: {
    openMachining() {
      if (this.disabled) return;
      this.$emit("open");
    }
  }
});
const _hoisted_1$2 = ["id", "disabled"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  return openBlock(), createElementBlock("button", {
    id: _ctx.id,
    class: normalizeClass(["machining-button", { "has-machining": _ctx.hasMachining }]),
    type: "button",
    disabled: _ctx.disabled,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openMachining && _ctx.openMachining(...args))
  }, [
    createVNode(_component_font_awesome_icon, { icon: ["fass", "hammer"] })
  ], 10, _hoisted_1$2);
}
const MachiningButton = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render]]);
const _hoisted_1$1 = {
  key: 0,
  class: "debug"
};
const _hoisted_2 = { key: 2 };
const _hoisted_3 = {
  key: 0,
  class: "row table-heading"
};
const _hoisted_4 = {
  key: 0,
  class: "cell center"
};
const _hoisted_5 = {
  key: 1,
  class: "cell delete"
};
const _hoisted_6 = { class: "cell" };
const _hoisted_7 = {
  key: 0,
  class: "cell center"
};
const _hoisted_8 = ["onClick"];
const _hoisted_9 = {
  key: 1,
  class: "cell"
};
const _hoisted_10 = ["disabled", "aria-label", "onClick"];
const _hoisted_11 = { class: "button-wrapper main" };
const _hoisted_12 = ["aria-label"];
const _hoisted_13 = ["aria-label", "disabled"];
const _hoisted_14 = ["aria-label"];
const _hoisted_15 = { id: "part-count" };
const _hoisted_16 = {
  key: 3,
  id: "messages"
};
const _hoisted_17 = {
  key: 0,
  class: "heading"
};
const _hoisted_18 = { class: "content" };
const _hoisted_19 = {
  key: 4,
  id: "progress"
};
const _hoisted_20 = {
  id: "diagram",
  class: "diagram production"
};
const _hoisted_21 = {
  key: 0,
  id: "stack"
};
const showDevInfo$1 = true;
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "CheckoutCalculator",
  props: {
    debug: {
      type: Boolean,
      default: false
    },
    units: {
      type: String,
      default: "decimal"
    },
    stock: {
      type: Array,
      default: () => []
    },
    findExtrasPrice: {
      type: Function,
      required: true
    },
    formatPrice: {
      type: Function,
      required: true
    },
    readonly: {
      type: Boolean,
      default: false
    }
  },
  emits: ["inputs-changed", "calculating", "result", "log", "error"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const Machining2 = defineAsyncComponent(() => import("./Machining-_k9j8LAh.js"));
    const ImportCSV = defineAsyncComponent(() => import("./ImportCSV-BINq50-H.js"));
    const ObjectViewer = defineAsyncComponent(() => import("./ObjectViewer-BiwJbooS.js"));
    const props = __props;
    const emit = __emit;
    const { t: t2, locale: locale2 } = useI18n({
      locale: "en_US",
      useScope: "global"
    });
    const env = "development";
    const domain = window.location.hostname;
    let debouncedHandleResize = null;
    let socket = null;
    const connected = ref(false);
    const maintenanceMode = ref(false);
    const creditVisible = ref(true);
    const currentURL = useLocalStorage("Checkout/currentURL", window.location.href);
    const viewportWidth = ref(window.innerWidth);
    const mounted = ref(false);
    const loaded = ref(false);
    const thinking = ref(false);
    const success = ref(false);
    const jobId = ref(0);
    const enableEvo = ref(false);
    const CSVImportEnabled = ref(false);
    const canGoFullScreen = ref(isElementFullScreenSupported());
    const options = reactive({
      enable: {
        banding: true,
        finish: true,
        orientation: true,
        diagram: true,
        focus: true,
        machining: true,
        csvImport: true,
        click: true,
        partName: true,
        progressNumber: true
      },
      decimalPlaces: 2,
      stackHeight: 100,
      maxParts: null,
      locale: "en_US",
      orientationModel: 0,
      customFields: [],
      fieldOrder: [],
      units: "decimal",
      minDimension: 0,
      stockSelection: null,
      cutPreference: null,
      bladeWidth: null,
      stockType: null,
      minSpacing: 0,
      stockGrain: null
    });
    const saw = ref(null);
    const sawData = reactive({
      bladeWidth: 1,
      cutPreference: "l",
      cutType: "guillotine",
      stockType: "sheet",
      stackHeight: 0,
      options: {
        stockSelection: "efficiency",
        minSpacing: 0
      }
    });
    const inputShapes = useLocalStorage(
      "Checkout/inputShapes",
      [],
      {
        serializer: {
          read: (v2) => {
            if (!v2) return [];
            const inputs2 = v2 ? JSON.parse(v2) : [];
            return recreateInputShapes(inputs2, props.units);
          },
          write: (v2) => {
            return JSON.stringify(v2);
          }
        },
        listenToStorageChanges: false
      }
    );
    const inputStock = ref([]);
    const stockList = shallowRef([]);
    const shapeList = shallowRef([]);
    const cutList = shallowRef([]);
    const offcuts = shallowRef([]);
    const inputs = ref({
      parts: [],
      stock: []
    });
    const metadata = ref(null);
    const currentInputShape = ref(null);
    const activeStockId = ref(null);
    const addedShapes = computed(() => {
      return shapeList.value.filter((shape) => shape.added);
    });
    const uniqueShapes = computed(() => {
      return shapeList.value.filter((shape) => shape.added && !shape.duplicate);
    });
    const uniqueAddedShapes = computed(() => {
      return uniqueShapes.value.filter((s2) => s2.added);
    });
    const uniqueStock = computed(() => {
      return stockList.value.filter((stock) => stock.used && !stock.duplicate);
    });
    const uniqueUsedStock = computed(() => {
      return uniqueStock.value.filter((s2) => s2.used).map((s2) => {
        s2.q = uniqueStock.value.filter((u2) => u2.parentID === s2.parentID).reduce(
          (total, s22) => total + (typeof (s22 == null ? void 0 : s22.stack) === "number" && s22.stack > 0 ? s22.stack : 1),
          0
        );
        return s2;
      });
    });
    const usedStock = computed(() => getUsedStock(stockList.value));
    const activeStock = computed(() => {
      if (!activeStockId.value) return null;
      return getActiveStock(stockList.value, activeStockId.value);
    });
    const stackedStock = computed(() => getStackedStock(stockList.value));
    const activeShapes = computed(() => {
      return shapeList.value.filter((shape) => {
        var _a3, _b2;
        return shape.added && ((_a3 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a3.id) === ((_b2 = activeStock.value) == null ? void 0 : _b2.id);
      });
    });
    const activeCuts = computed(() => {
      return getActiveCuts(cutList.value, activeStock.value);
    });
    const totalInputShapes = computed(() => {
      return inputShapes.value.reduce((total, s2) => total + s2.q, 0);
    });
    const messageVisible = ref(false);
    const messageHeading = ref("");
    const messageContent = ref("");
    const extrasIndex = reactive({
      banding: null,
      finish: null,
      info: null
    });
    const materials = ref([]);
    const thicknesses = ref([]);
    const bondedThicknesses = ref([]);
    const machiningEnabled = ref(false);
    const machiningOptions = reactive({
      units: "decimal",
      faces: { enabled: true },
      holes: { enabled: false },
      corners: {
        enabled: false,
        types: []
      },
      banding: { enabled: false },
      hingeHoles: { enabled: false },
      shelfHoles: { enabled: false }
    });
    const bandingData = reactive({
      labels: [],
      pricing: {},
      options: {},
      keys: mainSides
    });
    const finishData = reactive({
      labels: [],
      pricing: {},
      options: {},
      keys: ["a", "b"]
    });
    const progress = ref({
      queue: 0,
      stockCount: 0,
      shapeCount: 0,
      complete: false
    });
    const colors = reactive({
      partA: "#118ab2",
      partB: null,
      partHover: null,
      partSelected: null,
      stock: "#ffd166",
      button: "#118ab2",
      buttonText: "#ffffff",
      text: "#ffffff"
    });
    let vis = null;
    const visInit = ref(false);
    const isFullScreen = ref(false);
    const visOptions = reactive({
      disableClick: false,
      enableStretch: true
    });
    const user = shallowRef(null);
    const allFields = reactive({
      parts: {
        sheet: [
          { id: "material", enabled: false },
          { id: "l", enabled: true },
          { id: "w", enabled: true },
          { id: "t", enabled: false },
          { id: "q", enabled: true },
          { id: "name", enabled: true },
          { id: "orientationLock", enabled: true },
          { id: "banding", enabled: false },
          { id: "finish", enabled: false },
          { id: "machining", enabled: false }
        ],
        linear: [
          { id: "l", enabled: true },
          { id: "q", enabled: true },
          { id: "name", enabled: true },
          { id: "finish", enabled: false }
        ],
        roll: [
          { id: "l", enabled: true },
          { id: "w", enabled: true },
          { id: "q", enabled: true },
          { id: "name", enabled: true },
          { id: "orientationLock", enabled: true }
        ]
      }
    });
    const customFieldDefinitions = ref([]);
    const fieldDefinitions = computed(() => {
      var _a3;
      const fieldDefinitions2 = [
        {
          id: "material",
          fieldMap: "material",
          label: t2("material"),
          w: "minmax(20px, max-content)",
          type: "select",
          output: "string",
          default: (_a3 = materials.value[0]) == null ? void 0 : _a3.name,
          options: materials.value.map((m2) => ({
            value: m2.name,
            label: m2.name
          }))
        },
        {
          id: "t",
          fieldMap: "t",
          w: "minmax(20px, max-content)",
          type: "select",
          output: props.units === "decimal" ? "float" : "string",
          label: t2("thickness")
        },
        {
          id: "l",
          fieldMap: "l",
          type: "unitDependent",
          label: t2("length"),
          min: 0
        },
        {
          id: "w",
          fieldMap: "w",
          type: "unitDependent",
          label: t2("width"),
          min: 0
        },
        {
          id: "q",
          fieldMap: "q",
          type: "integer",
          default: 1,
          label: t2("quantity"),
          min: 0
        },
        {
          id: "name",
          fieldMap: "name",
          type: "string",
          label: t2("name")
        },
        {
          id: "orientationLock",
          w: "32px",
          label: t2("orientation"),
          fieldMap: "orientationLock"
        },
        {
          id: "banding",
          w: "32px",
          label: t2("banding"),
          fieldMap: "bandingOptions"
        },
        {
          id: "finish",
          type: "checkbox",
          w: "32px",
          label: t2("finish"),
          fieldMap: "finish"
        },
        {
          id: "machining",
          w: "32px",
          label: t2("machining"),
          fieldMap: "machining"
        }
      ];
      return [...fieldDefinitions2, ...customFieldDefinitions.value];
    });
    const relevantFieldDefinitions = computed(() => {
      return getRelevantFieldDefinitions(
        allFields,
        fieldDefinitions.value,
        "parts",
        sawData.stockType,
        options.fieldOrder
      );
    });
    const partColumns = computed(() => {
      let number2 = relevantFieldDefinitions.value.length;
      number2++;
      if (inputShapes.value.length > 1) number2++;
      return number2;
    });
    const partColumnsStyle = computed(() => {
      const widthValues = {
        id: "34px",
        del: "30px",
        info: "30px"
      };
      const widths = [];
      for (const field of relevantFieldDefinitions.value) {
        if (field.id === "trim") continue;
        widths.push(field.w ?? "minmax(20px, 1fr)");
      }
      widths.unshift(widthValues.id);
      widths.push(widthValues.info);
      if (inputShapes.value.length > 1) widths.push(widthValues.del);
      return widths.join(" ");
    });
    const creditStyles = computed(() => ({
      fontSize: "11px",
      textAlign: "right",
      width: "100%",
      height: "auto",
      position: "relative",
      display: "flex",
      visibility: "visible",
      opacity: "1",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-end",
      paddingRight: "10px",
      marginTop: "10px",
      marginBottom: "2px",
      userSelect: "none",
      alignItems: "center"
    }));
    const creditLinkStyles = computed(() => ({
      width: "auto",
      height: "auto",
      display: "inline-block",
      position: "relative",
      visibility: "visible",
      opacity: "1",
      color: "#4e4e4e"
    }));
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };
    const getNestedValue$1 = (obj, path2) => {
      return getNestedValue(obj, path2);
    };
    const setNestedValue$1 = (obj, path2, value2, force = true) => {
      setNestedValue(obj, path2, value2, force);
    };
    const init = (initData) => {
      if (props.debug) {
        emit("log", ["checkout init...", initData]);
      }
      if (initData == null ? void 0 : initData.options) {
        const sentOptions = initData.options;
        mapLegacyOptions(sentOptions);
        const requiredOptions = [
          "stockType",
          "cutPreference",
          "bladeWidth"
        ];
        requiredOptions.forEach((o2) => {
          if (!(o2 in sentOptions)) {
            emit("error", `${o2} is a required option`);
          }
        });
        const optionHandlers = {
          stockType: () => {
            const validOptions = ["sheet", "linear"];
            if (!validOptions.includes(sentOptions.stockType)) {
              console.warn(`${sentOptions.stockType} is not a valid stockType, expected ${validOptions.join("|")}`);
            }
            sawData.stockType = sentOptions.stockType;
          },
          stockSelection: () => {
            const validOptions = [void 0, "efficiency", "smallest"];
            if (!validOptions.includes(sentOptions.stockSelection)) {
              console.warn(`${sentOptions.stockSelection} is not a valid stockSelection, expected ${validOptions.join("|")}`);
            }
            sawData.options.stockSelection = sentOptions.stockSelection;
          },
          minSpacing: () => {
            sawData.options.minSpacing = sentOptions.minSpacing;
          },
          cutPreference: () => {
            const allowedCutPreferences = ["efficiency", "length", "width", "beam"];
            if (allowedCutPreferences.includes(sentOptions.cutPreference)) {
              const { cutType, cutPreference } = mapLegacyCutPreference(sentOptions.cutPreference);
              sawData.cutType = cutType;
              sawData.cutPreference = cutPreference;
              sawData.stackHeight = sentOptions.stackHeight;
              if (sentOptions.stockType === "linear") {
                sawData.cutType = null;
                sawData.cutPreference = null;
              }
              if (sentOptions.cutPreference === "beam") {
                sawData.stackHeight = sentOptions.stackHeight;
              }
            } else {
              console.warn(`SmartCut - ${sentOptions.cutPreference} is not one of ${allowedCutPreferences.join("|")}`);
            }
          },
          bladeWidth: () => {
            if (sentOptions.bladeWidth >= 0) {
              sawData.bladeWidth = sentOptions.bladeWidth;
            } else {
              console.warn(`SmartCut - you provided an incorrect blade width of: ${sentOptions.bladeWidth}`);
            }
          },
          colors: () => {
            for (const [key, value2] of Object.entries(sentOptions == null ? void 0 : sentOptions.colors)) {
              if (value2) colors[key] = value2;
            }
          },
          maxParts: () => {
            options.maxParts = sentOptions.maxParts;
          },
          enable: () => {
            setFieldEnabled$1("banding", getNestedObjectData(sentOptions, ["enable", "banding"]));
            setFieldEnabled$1("finish", getNestedObjectData(sentOptions, ["enable", "finish"]));
            setFieldEnabled$1("orientationLock", getNestedObjectData(sentOptions, ["enable", "orientation"]));
            setFieldEnabled$1("machining", getNestedObjectData(sentOptions, ["enable", "machining"]));
            CSVImportEnabled.value = getNestedObjectData(sentOptions, ["enable", "csvImport"]);
            visOptions.disableClick = getNestedObjectData(sentOptions, ["enable", "click"]) === false;
            setFieldEnabled$1("name", getNestedObjectData(sentOptions, ["enable", "partName"]));
          },
          locale: () => {
            locale2.value = sentOptions.locale;
          },
          customFields: () => {
            var _a3;
            if (!Array.isArray(sentOptions.customFields) || !((_a3 = sentOptions.customFields) == null ? void 0 : _a3.length)) return;
            const newCustomFieldDefinitions = [];
            sentOptions.customFields.forEach((cf, index) => {
              newCustomFieldDefinitions.push(cf);
              newCustomFieldDefinitions[index].custom = true;
              const id = getCustomFieldId(cf.id);
              newCustomFieldDefinitions[index].id = id;
              newCustomFieldDefinitions[index].fieldMap = "customData." + id;
              if (cf.type === "checkbox") {
                newCustomFieldDefinitions[index].w = "32px";
              }
              if (cf.type === "select") {
                newCustomFieldDefinitions[index].output = cf.output ?? "string";
                newCustomFieldDefinitions[index].options = cf.options;
              }
            });
            customFieldDefinitions.value = newCustomFieldDefinitions;
            inputShapes.value.forEach((s2) => {
              s2.customData = sentOptions.customFields.reduce((acc, cf) => {
                const id = getCustomFieldId(cf.id);
                acc[id] = s2.customData[id] || cf.default || "";
                return acc;
              }, {});
            });
          }
        };
        for (const option in sentOptions) {
          options[option] = sentOptions[option];
          if (option in optionHandlers) optionHandlers[option]();
        }
      }
      initExtra("banding", initData);
      initExtra("finish", initData);
      initMachining(initData);
      initMaterialsThicknesses(initData);
      loaded.value = true;
      nextTick$1(() => {
        if (!visInit.value) {
          initVisualization();
        }
        if (!isCreditVisible()) {
          alert("The SmartCut credit seems to have been tampered with - this is against our terms of service. Please contact support.");
        }
      });
      window.smartcutCheckout = { init };
    };
    const getShapeStockGrainSummary = (shape) => {
      if (!inputStock.value.length) return "n";
      const thisMaterial = shape.material;
      const thisThickness = shape.t;
      const matchingStock = inputStock.value.filter((s2) => s2.material === thisMaterial && s2.t === thisThickness);
      if (!matchingStock.length) return "n";
      return getStockGrainSummary(matchingStock);
    };
    const updateShapeOrientation = (shape, orientation) => {
      shape.orientationLock = orientation;
    };
    const setFieldEnabled$1 = (fieldId, enabled = true) => {
      setFieldEnabled(allFields, "parts", sawData.stockType, fieldId, enabled);
    };
    const getCustomFieldId = (id) => {
      if (!id) return null;
      return sanitiseString(id).toLowerCase();
    };
    const initMachining = (initData) => {
      var _a3, _b2, _c, _d, _e;
      if (!getNestedObjectData(options, ["enable", "machining"])) return;
      if (!(initData == null ? void 0 : initData.machining)) return;
      for (const key in machiningOptions) {
        if (initData.machining[key]) {
          machiningOptions[key] = initData.machining[key];
        }
      }
      ["holes", "hingeHoles"].forEach((m2) => {
        var _a4, _b3;
        if ((_a4 = initData == null ? void 0 : initData.machining) == null ? void 0 : _a4[m2]) {
          machiningOptions[m2].enabled = (_b3 = initData == null ? void 0 : initData.machining) == null ? void 0 : _b3[m2].enabled;
        }
      });
      if ((_c = (_b2 = (_a3 = initData == null ? void 0 : initData.machining) == null ? void 0 : _a3.corners) == null ? void 0 : _b2.types) == null ? void 0 : _c.length) {
        machiningOptions.corners.enabled = true;
        machiningOptions.corners.types = initData.machining.corners.types;
      }
      if (initData.banding && ((_e = (_d = initData == null ? void 0 : initData.options) == null ? void 0 : _d.enable) == null ? void 0 : _e.banding)) {
        if (!bandingData) return;
        machiningOptions.banding = {
          enabled: true
        };
        if (bandingData.options.length) {
          machiningOptions.banding.options = bandingData.options;
        }
        if (bandingData.labels.length) {
          machiningOptions.banding.labels = bandingData.labels;
        }
        if (objectValuesPresent(bandingData.pricing)) {
          machiningOptions.banding.pricing = bandingData.pricing;
        }
      }
    };
    const openMachining = (shape = null) => {
      currentInputShape.value = shape;
      if (shape && shape.l && shape.w) {
        machiningEnabled.value = true;
      } else {
        alert("Please enter dimensions first");
      }
    };
    const closeMachining = () => {
      machiningEnabled.value = false;
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    };
    const getThicknessesFromStock = (stockList2 = []) => {
      thicknesses.value = [];
      bondedThicknesses.value = [];
      setFieldEnabled$1("t", false);
      if (!stockList2.length) return;
      for (const st2 of stockList2) {
        if (!(st2 == null ? void 0 : st2.t)) continue;
        if (typeof st2.t === "string" && st2.t.includes(",")) {
          const bondedThickness = getBondedThicknesses(st2.t, true);
          if (bondedThickness.length === 2) {
            addBondedThicknesses(bondedThickness);
            setFieldEnabled$1("t", true);
            st2.t = thicknesses.value[0];
          } else {
            emit("error", "bonded thickness found which does not have 2 options");
          }
        } else if (!thicknesses.value.includes(st2.t)) {
          thicknesses.value.push(st2.t);
        }
      }
      if (thicknesses.value.length > 1) setFieldEnabled$1("t", true);
    };
    const getShapeThicknessOptions = (shape) => {
      const thicknesses2 = getShapeThicknesses(shape).thicknesses;
      return thicknesses2.map((t22) => ({
        label: t22 == null ? void 0 : t22.toString(),
        value: t22
      }));
    };
    const getShapeThicknesses = (shape) => {
      var _a3;
      if (!shape) return { thicknesses: [], bondedThicknesses: [] };
      if (!((_a3 = materials.value) == null ? void 0 : _a3.length)) {
        return {
          thicknesses: thicknesses.value,
          bondedThicknesses: []
        };
      }
      if (!shape.material) return { thicknesses: [], bondedThicknesses: [] };
      const material = materials.value.find((m2) => m2.name === shape.material);
      if (!material) return { thicknesses: [], bondedThicknesses: [] };
      const thicknessesList = [...material.thicknesses];
      const bondedThicknessesList = [];
      for (let i2 = 0; i2 < thicknessesList.length; i2++) {
        const t22 = thicknessesList[i2];
        const bonded = getBondedThicknesses(t22);
        const bondedIndexes = [];
        if (bonded.length) {
          for (const b2 of bonded) {
            thicknessesList[i2] = convertUnit(b2);
            bondedIndexes.push(i2);
          }
          i2++;
        }
        if (bondedIndexes.length) {
          bondedThicknessesList.push(bondedIndexes);
        }
      }
      return {
        thicknesses: thicknessesList,
        bondedThicknesses: bondedThicknessesList
      };
    };
    const initMaterialsThicknesses = (initData) => {
      var _a3;
      if ((_a3 = initData == null ? void 0 : initData.stock) == null ? void 0 : _a3.some((s2) => s2 == null ? void 0 : s2.material)) {
        materials.value = [];
        thicknesses.value = [];
        bondedThicknesses.value = [];
        const materialMap = /* @__PURE__ */ new Map();
        initData.stock.forEach((stock) => {
          var _a4;
          if (!stock.material) return;
          const materialName = stock.material.toUpperCase();
          if (!materialMap.has(materialName)) {
            materialMap.set(materialName, /* @__PURE__ */ new Set());
          }
          if (stock.t != null) {
            const thickness = Number(stock.t);
            if (!isNaN(thickness)) {
              (_a4 = materialMap.get(materialName)) == null ? void 0 : _a4.add(thickness);
            }
          }
        });
        materials.value = Array.from(materialMap.entries()).map(([name, thicknessSet]) => {
          const material = {
            name,
            thicknesses: Array.from(thicknessSet).sort((a2, b2) => a2 - b2)
          };
          return material;
        });
        if (materials.value.length > 1) {
          setFieldEnabled$1("material", true);
        }
      } else {
        getThicknessesFromStock(initData.stock);
      }
    };
    const addBondedThicknesses = (bonded, material = null) => {
      if (!Array.isArray(bonded)) {
        emit("error", "addBondedThicknesses expects an array");
        return;
      }
      const bondexIndexes = [];
      for (let i2 = 0; i2 < bonded.length; i2++) {
        let bondedThickness = bonded[i2];
        if (props.units === "decimal") {
          bondedThickness = parseFloat(bondedThickness);
        }
        thicknesses.value.push(bondedThickness);
        if (material) {
          material.thicknesses.push(bondedThickness);
        }
        bondexIndexes.push(thicknesses.value.length - 1);
      }
      bondedThicknesses.value.push(bondexIndexes);
    };
    const getBondedThicknesses = (t22, cu = false) => {
      if (typeof t22 === "string" && t22.includes(",")) {
        const bonded = t22.split(",");
        if (cu) return bonded.map((t3) => convertUnit(t3));
        return bonded;
      }
      return [];
    };
    const toggleFullScreen = () => {
      if (isFullScreen.value) closeFullScreen();
      else openFullScreen();
    };
    const openFullScreen = () => {
      document.getElementById("smartcut-checkout").requestFullscreen();
      isFullScreen.value = true;
    };
    const closeFullScreen = () => {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
      isFullScreen.value = false;
    };
    const handleResize = () => {
      viewportWidth.value = window.innerWidth;
    };
    debouncedHandleResize = debounce(handleResize, 30);
    const isCreditVisible = () => {
      var _a3, _b2;
      if ((_b2 = (_a3 = user.value) == null ? void 0 : _a3.api) == null ? void 0 : _b2.whiteLabel) return true;
      let visible = true;
      const wrapper = document.querySelector("#smartcut-app #credit");
      const link = document.querySelector("#smartcut-app #credit a");
      [wrapper, link].forEach((el, index) => {
        if (!el) return visible = false;
        const style = window.getComputedStyle(el);
        if (style.display === "none") return visible = false;
        if (style.display === "hidden") return visible = false;
        if (style.opacity === "0") return visible = false;
        if (style.color === "transparent") return visible = false;
        if (style.position !== "relative") return visible = false;
        if (index === 1) {
          if (style.color !== "#4e4e4e" && style.color !== "rgb(78, 78, 78)") {
            return visible = false;
          }
        }
      });
      creditVisible.value = visible;
      return visible;
    };
    const setExtrasOption$1 = (shape, extraType, option, key, value2) => {
      setExtrasOption(
        shape,
        extraType,
        option,
        key,
        value2,
        props.findExtrasPrice
      );
    };
    const setAllExtrasOptions$1 = (shape, extraType, option, value2) => {
      setAllExtrasOptions(
        shape,
        extraType,
        option,
        value2,
        extraType === "banding" ? cornerSides : [],
        props.findExtrasPrice
      );
    };
    const initExtrasOptions = (shape, extraType) => {
      const labelsKeys = extraType === "banding" ? bandingData == null ? void 0 : bandingData.labels : finishData == null ? void 0 : finishData.labels;
      initExtraOptions(shape, extraType, labelsKeys);
      const extraOptionsKey = getExtraOptionsKey(extraType);
      if (shape == null ? void 0 : shape[extraOptionsKey]) {
        for (const option in shape[extraOptionsKey]) {
          const price = getExtrasPrice(shape, extraType, option, props.findExtrasPrice);
          setExtra(shape, extraType, option, price ? true : false);
        }
      }
    };
    const getMaxPricingLevels = (pricingObject) => {
      const pricingKeys = Object.keys(pricingObject);
      const maxLevels = Math.max(...pricingKeys.map((key) => key.split("|").length));
      return maxLevels;
    };
    const getAllOptionsFromPricingObject = (pricingObject) => {
      const options2 = [];
      const pricingKeys = Object.keys(pricingObject);
      const maxLevels = getMaxPricingLevels(pricingObject);
      for (let i2 = maxLevels; i2--; ) options2.push(/* @__PURE__ */ new Set());
      for (const key of pricingKeys) {
        const values = key.split("|");
        values.forEach((value2, index) => options2[index].add(value2));
      }
      for (let i2 = 0; i2 < maxLevels; i2++) {
        options2[i2] = Array.from(options2[i2]);
      }
      return options2;
    };
    const getAvailablePricingOptions = (pricingObject, currentOptions = [], index) => {
      if (!pricingObject) return [];
      if (index > 0 && !currentOptions[index - 1]) return [];
      const availableOptions = /* @__PURE__ */ new Set();
      for (const key of Object.keys(pricingObject)) {
        const keyParts = key.split("|");
        if (keyParts.length > index) {
          let isCompatible = true;
          for (let i2 = 0; i2 < index; i2++) {
            if (currentOptions[i2] && keyParts[i2] !== currentOptions[i2]) {
              isCompatible = false;
              break;
            }
          }
          if (isCompatible) {
            availableOptions.add(keyParts[index]);
          }
        }
      }
      return Array.from(availableOptions);
    };
    const getExtrasPrice$1 = (shape, extraType, key) => {
      return getExtrasPrice(
        shape,
        extraType,
        key,
        props.findExtrasPrice
      );
    };
    const showShapeInputIssue$1 = (issueType = "issues", shape, field) => {
      return showShapeInputIssue(issueType, shape, field);
    };
    const addInputShape = (number2 = 1) => {
      for (let i2 = number2; i2--; ) {
        let newInputShape;
        if (inputShapes.value.length > 0) {
          const lastShape = inputShapes.value[inputShapes.value.length - 1];
          newInputShape = createShapeInput({
            material: lastShape.material,
            t: lastShape.t
          });
        } else {
          newInputShape = createShapeInput();
        }
        inputShapes.value.push(newInputShape);
      }
    };
    const removeShape = (index) => {
      var _a3;
      if (props.readonly) return;
      if (inputShapes.value.length === 1) return;
      const listId = inputShapes.value[index].listId;
      inputShapes.value.splice(index, 1);
      if (((_a3 = currentInputShape.value) == null ? void 0 : _a3.listId) === listId) {
        currentInputShape.value = null;
      }
      resetProgress(progress);
    };
    const createShapeInput = ({
      l: l2 = null,
      w: w2 = sawData.stockType === "linear" ? ((_a3) => (_a3 = inputStock.value[0]) == null ? void 0 : _a3.w)() : null,
      t: t22 = thicknesses.value.length ? thicknesses.value[0] : null,
      q: q2 = 1,
      material = ((_b2) => (_b2 = materials.value) == null ? void 0 : _b2.length)() === 1 ? materials.value[0].name : "",
      name = null,
      orientationLock = options.orientationModel === 2 ? "l" : null,
      bandingOptions = null,
      finishOptions = null,
      banding = null,
      finish = null,
      customData = null,
      readonly: readonly2 = false
    } = {}) => {
      var _a4, _b3;
      const inputShape = new InputShape({
        id: (inputShapes.value.length + 1).toString(),
        units: props.units,
        l: l2,
        w: w2,
        t: t22,
        q: q2,
        material,
        name,
        orientationLock,
        banding,
        bandingOptions,
        finish,
        finishOptions,
        customData,
        readonly: readonly2
      });
      if ((_a4 = bandingData == null ? void 0 : bandingData.labels) == null ? void 0 : _a4.length) {
        initExtrasOptions(inputShape, "banding");
      }
      if ((_b3 = finishData == null ? void 0 : finishData.labels) == null ? void 0 : _b3.length) {
        initExtrasOptions(inputShape, "finish");
      }
      return inputShape;
    };
    const createStockInput = ({
      name = "",
      l: l2 = null,
      w: w2 = null,
      t: t22 = null,
      material = "",
      q: q2 = 1,
      trim = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      grain = "",
      cost = 0,
      allowExactFitShapes = false,
      notes = ""
    }) => {
      return new InputStock({
        id: (inputStock.value.length + 1).toString(),
        name,
        units: props.units,
        l: l2,
        w: w2,
        t: t22,
        material,
        q: q2,
        autoAdd: true,
        trim,
        grain,
        cost,
        allowExactFitShapes,
        notes
      });
    };
    const createStock = (stockData, i2) => {
      const l2 = convertUnit(stockData.l);
      const w2 = convertUnit(stockData.w);
      const t22 = stockData.t ? convertUnit(stockData.t) : null;
      const saw2 = new Saw(sawData);
      const stock = new Stock({
        id: (i2 + 1).toString() + ".0",
        name: (stockData == null ? void 0 : stockData.name) ? stockData.name : `${l2}x${w2}`,
        l: l2,
        w: w2,
        t: t22,
        saw: saw2,
        material: stockData.material,
        grain: stockData.grain,
        autoAdd: true,
        cost: stockData == null ? void 0 : stockData.cost,
        trim: stockData.trim,
        allowExactFitShapes: stockData.allowExactFitShapes,
        type: sawData.stockType,
        notes: stockData == null ? void 0 : stockData.notes
      });
      stockList.value.push(stock);
      return stock.issues;
    };
    const createShapeList = () => {
      var _a3, _b2;
      const issues = [];
      for (let index = 0; index < inputShapes.value.length; index++) {
        const inputShape = inputShapes.value[index];
        if (convertUnit(inputShape.l) < convertUnit(options.minDimension)) {
          inputShape.issues.push({
            message: t2("Part") + ` ${index + 1}: ` + t2("Minimum dimension is") + ` ${options.minDimension}`,
            field: ["l"],
            index
          });
        }
        if (convertUnit(inputShape.w) < convertUnit(options.minDimension)) {
          inputShape.issues.push({
            message: t2("Part") + ` ${index + 1}: ` + t2("Minimum dimension is") + ` ${options.minDimension}`,
            field: ["w"],
            index
          });
        }
        if ((_a3 = inputShape == null ? void 0 : inputShape.issues) == null ? void 0 : _a3.length) {
          issues.push(...inputShape.issues.map((i2) => {
            i2.message = t2("Part") + ` ${index + 1}: ${i2.message}`;
            return i2;
          }));
        }
        if (!inputShape.l || !inputShape.w || !inputShape.q) continue;
        const shapeData = {
          id: (index + 1).toString() + ".0",
          l: convertUnit(inputShape == null ? void 0 : inputShape.l),
          w: convertUnit(inputShape == null ? void 0 : inputShape.w),
          t: (inputShape == null ? void 0 : inputShape.t) ? convertUnit(inputShape.t) : null,
          material: (inputShape == null ? void 0 : inputShape.material) ? inputShape.material : null,
          q: typeof inputShape.q !== "number" ? parseInt(inputShape.q) : inputShape.q,
          name: inputShape.name,
          orientationLock: inputShape.orientationLock,
          banding: inputShape.banding,
          finish: inputShape.finish,
          machining: inputShape.machining,
          customData: inputShape.customData
        };
        const s2 = new Shape(mapOrientation(shapeData, options.orientationModel));
        shapeList.value.push(s2);
        if ((_b2 = s2 == null ? void 0 : s2.issues) == null ? void 0 : _b2.length) issues.push(...s2.issues);
      }
      updatePartQuantitiesBasedOnThickness();
      return issues;
    };
    const showStock$1 = (id) => {
      showStock.call({ activeStockId }, id);
    };
    const updatePartQuantitiesBasedOnThickness = () => {
      if (!thicknesses.value.length) return;
      shapeList.value.forEach((s2) => {
        if (!s2.t) return;
        const thicknessIndex = thicknesses.value.findIndex(
          (t22) => convertUnit(t22) === s2.t
        );
        const bondedIndexes = bondedThicknesses.value.find((bonded) => {
          return bonded.includes(thicknessIndex);
        });
        if (!bondedIndexes) return;
        const smallestThickness = Math.min(
          ...bondedIndexes.map((i2) => thicknesses.value[i2])
        );
        if (s2.t > smallestThickness) {
          s2.q = s2.q * (s2.t / smallestThickness);
          s2.t = smallestThickness;
        }
      });
    };
    const refresh = () => {
      refreshStock.call({
        vis,
        stockList,
        activeStock,
        activeCuts
      });
      refreshShapes.call({
        vis,
        shapeList,
        activeShapes
      }, uniqueShapes.value.length);
    };
    const reset = () => {
      resetProgress(progress);
      stockList.value = [];
      shapeList.value = [];
      cutList.value = [];
      jobId.value = 0;
    };
    const clear = () => {
      inputShapes.value.length = 0;
      addInputShape(1);
    };
    const calculate = () => {
      var _a3, _b2, _c;
      clearMessage();
      if (options.maxParts && totalInputShapes.value > options.maxParts) {
        showMessage(t2("The maximum number of parts is") + " " + options.maxParts);
        return;
      }
      emit("calculating");
      if (thinking.value) return false;
      thinking.value = true;
      success.value = false;
      const issues = [];
      let index = 0;
      for (const s2 of inputShapes.value) {
        issues.push(...s2.validate(
          inputStock.value,
          index,
          sawData.stockType,
          null,
          false
        ));
        index++;
      }
      if (issues.length) {
        console.warn(issues);
        showMessage({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.map( i => i.message ).slice( 0, 5 )
        });
        thinking.value = false;
        return;
      }
      reset();
      issues.push(...createStockList.call({
        inputStock,
        stockList,
        createStock
      }, false));
      if (issues.length) {
        showMessage({
          heading: `Stock issue${issues.length > 1 ? "s" : ""}`,
          main: `${issues.length} issue${issues.length > 1 ? "s" : ""} found with stock inputs`,
          list: issues.map((i2) => i2.message)
        });
        thinking.value = false;
        return;
      }
      issues.push(...createShapeList());
      if (issues.length) {
        showMessage({
          heading: "Part issue",
          main: "Issue with part inputs"
          // list: issues.slice( 0, 5 )
        });
        thinking.value = false;
        return;
      }
      saw.value = new Saw(
        sawData,
        (sawData == null ? void 0 : sawData.stockType) ?? ((_a3 = stockList.value) == null ? void 0 : _a3[0].type)
      );
      if (saw.value.issues.length) {
        showMessage({
          heading: `Saw issue${saw.value.issues.length > 1 ? "s" : ""}`,
          main: `${saw.value.issues.length} issue${saw.value.issues.length > 1 ? "s" : ""} found with saw inputs`
          // list: saw.value.issues.slice( 0, 5 )
        });
        thinking.value = false;
        return;
      }
      if (!((_b2 = stockList.value) == null ? void 0 : _b2.length)) {
        showMessage({
          heading: "No stock",
          main: "No stock items were found",
          list: []
        });
        thinking.value = false;
        return;
      }
      if (!((_c = shapeList.value) == null ? void 0 : _c.length)) {
        showMessage({
          heading: "No parts",
          main: "No parts in list",
          list: []
        });
        thinking.value = false;
        return;
      }
      if (props.debug)
        console.log(
          "SmartCut - calculating",
          "stock",
          stockList.value.map((s2) => s2.dimensions()),
          "parts",
          shapeList.value.map((s2) => s2.dimensions())
        );
      socket.connect();
      const calculationData = {
        inputs: {
          parts: inputShapes.value,
          stock: inputStock.value,
          saw: saw.value
        },
        saw: saw.value,
        shapeList: shapeList.value,
        stockList: stockList.value,
        enableEvo: enableEvo.value,
        domain
      };
      socket.compress(true).emit("calculate", calculationData);
    };
    const showMessage = (content = {
      main: null,
      heading: null,
      list: []
    }) => {
      var _a3;
      if (typeof content === "object") {
        messageContent.value = t2(content == null ? void 0 : content.main);
        messageHeading.value = t2(content.heading);
        if ((content == null ? void 0 : content.list) && Array.isArray(content.list) && ((_a3 = content.list) == null ? void 0 : _a3.length)) {
          content.list.forEach((item) => {
            if (!item) return;
            messageContent.value += `

${t2(item)}`;
          });
        }
      } else {
        messageContent.value = t2(content);
      }
      messageVisible.value = true;
    };
    const clearMessage = () => {
      messageVisible.value = false;
      messageContent.value = "";
      messageHeading.value = "";
    };
    const initVisualization = () => {
      const visData = {
        elementID: "#diagram",
        env,
        main: true,
        units: props.units,
        decimalPlaces: options.decimalPlaces,
        saw: sawData,
        app: false,
        embed: true,
        colors,
        options: visOptions,
        vueComponent: {
          env,
          stockList,
          shapeList,
          activeStock,
          activeShapes,
          activeCuts
        }
      };
      vis = new Vis(visData);
      vis.initStock(activeStock.value);
      vis.initShapes(activeShapes.value, shapeList.value);
      vis.initCuts(activeCuts.value);
      visInit.value = true;
    };
    const updateVisSize = async (immediate = false) => {
      if (!vis) return false;
      await vis.updateSize(immediate);
      clearSelection.call({ vis });
    };
    const initExtra = (extraType, initData) => {
      var _a3;
      setFieldEnabled$1(extraType, false);
      if (!extraType || !initData || !(initData == null ? void 0 : initData[extraType])) return;
      if (!getNestedObjectData(options, ["enable", extraType])) return;
      const pricingPath = [extraType, "pricing"];
      if (!checkObjectPathExists(initData, pricingPath)) {
        emit("error", `${pricingPath.join(".")} not found in sent data`);
        return;
      }
      const pricingData = getNestedObjectData(initData, pricingPath);
      if (typeof pricingData !== "object") {
        emit("error", `${pricingPath.join(".")} data must be an object`);
        return;
      }
      if (!objectValuesPresent(pricingData)) {
        emit("error", `if provided, ${pricingPath.join(".")} data must contain some values`);
        return;
      }
      const pricingKeys = Object.keys(pricingData);
      const pricingValues = Object.values(pricingData);
      if (!pricingKeys.length) {
        emit("error", `no ${pricingPath.join(".")} pricing found`);
        return;
      }
      const commaRegex = /,/;
      for (const key of pricingKeys) {
        if (commaRegex.test(key)) {
          emit("error", `${pricingPath} keys must not contain commas and should only be separated by a pipe (|)`);
          return;
        }
      }
      if (pricingValues.some((v2) => isNaN(v2))) {
        emit("error", `${pricingPath} values must be a number`);
        return;
      }
      const maxPricingLevels = getMaxPricingLevels(pricingData);
      const labelsPath = [extraType, "labels"];
      let labelsData = [];
      if (!checkObjectPathExists(initData, labelsPath)) {
        emit("error", `${labelsPath.join(".")} not found`);
        return;
      } else {
        labelsData = getNestedObjectData(initData, labelsPath);
      }
      if (!labelsData) {
        emit("error", `${labelsPath.join(".")} data not provided`);
        return;
      }
      if (!Array.isArray(labelsData)) {
        emit("error", `${labelsPath.join(".")} data must be an array`);
        return;
      }
      if (!(labelsData == null ? void 0 : labelsData.length)) {
        emit("error", `if provided, ${labelsPath.join(".")} data must contain values`);
        return;
      }
      if (labelsData.length !== maxPricingLevels) {
        emit("error", `${labelsPath.join(".")} length (${labelsData.length}) must match the number of levels in ${pricingPath.join(".")} (${maxPricingLevels})`);
        return;
      }
      switch (extraType) {
        case "banding":
          bandingData.labels = labelsData;
          bandingData.pricing = pricingData;
          bandingData.options = getAllOptionsFromPricingObject(pricingData);
          break;
        case "finish":
          finishData.labels = labelsData;
          finishData.pricing = pricingData;
          finishData.options = getAllOptionsFromPricingObject(pricingData);
          break;
      }
      setFieldEnabled$1(extraType, true);
      if (!((_a3 = inputShapes.value) == null ? void 0 : _a3.length)) return;
      for (const inputShape of inputShapes.value) {
        initExtrasOptions(inputShape, extraType);
      }
    };
    const openExtra = (extraType, shape) => {
      if (!shape) return;
      if (extraType !== "info") {
        Object.keys(extrasIndex).forEach((key) => {
          if (key !== extraType && key !== "info") {
            extrasIndex[key] = null;
          }
        });
      }
      const index = inputShapes.value.indexOf(shape);
      if (extrasIndex[extraType] === index) {
        currentInputShape.value = null;
        extrasIndex[extraType] = null;
      } else {
        currentInputShape.value = shape;
        extrasIndex[extraType] = index;
      }
    };
    const handleSmartcutLoad = (e) => {
      emit("log", ["SmartCut - load event received"]);
      parseInputs(e.detail);
    };
    const parseInputs = (detail) => {
      emit("log", ["SmartCut - loading parts..."]);
      nextTick$1(() => {
        var _a3, _b2, _c;
        if (!detail || !((_b2 = (_a3 = detail == null ? void 0 : detail.inputs) == null ? void 0 : _a3.parts) == null ? void 0 : _b2.length)) return;
        inputShapes.value = [];
        let index = 0;
        for (const d2 of detail.inputs.parts) {
          const inputShape = createShapeInput(d2);
          if (inputShape) {
            inputShapes.value.push(inputShape);
            if ((_c = inputShape.issues) == null ? void 0 : _c.length) {
              emit("log", [`SmartCut - issues found while importing part at index ${index}`, inputShape.issues]);
            }
          } else {
            emit("log", [`SmartCut - error loading part at index ${index}`, d2]);
          }
          index++;
        }
        emit("log", [`SmartCut - loaded ${inputShapes.value.length} parts`]);
      });
    };
    const importParts = (inputData) => {
      inputShapes.value.length = 0;
      nextTick$1(() => {
        var _a3, _b2;
        for (const d2 of inputData) {
          d2.t = ((_b2 = (_a3 = inputStock.value) == null ? void 0 : _a3[0]) == null ? void 0 : _b2.t) ?? null;
          inputShapes.value.push(createShapeInput(d2));
        }
      });
    };
    watch(() => props.stock, (stock) => {
      reset();
      if (!Array.isArray(stock)) {
        console.warn("SmartCut - stock must be passed as an array");
      }
      if (!(stock == null ? void 0 : stock.length)) return;
      inputStock.value = [];
      if (!materials.value.length) {
        getThicknessesFromStock(stock);
      }
      for (const st2 of stock) {
        st2.type = sawData.stockType;
        const stockInput = createStockInput(st2);
        inputStock.value.push(stockInput);
      }
      if (inputStock.value.length) {
        if (!inputShapes.value.length) {
          nextTick$1(() => addInputShape(1));
        } else {
          nextTick$1(() => {
            inputShapes.value.forEach((shape) => {
              if (shape.material) {
                const materialData = materials.value.find((m2) => m2.name === shape.material);
                if (materialData) {
                  if (!materialData.thicknesses.includes(convertUnit(shape.t))) {
                    shape.t = materialData.thicknesses[0];
                  }
                  if (shape.t == null) {
                    shape.t = materialData.thicknesses[0];
                  }
                }
              } else {
                shape.t = inputStock.value[0].t;
              }
            });
          });
        }
      }
    }, { immediate: true });
    watch(inputShapes, (shapes) => {
      emit("inputs-changed");
      shapes.forEach((s2) => {
        var _a3;
        if (sawData.stockType === "linear") {
          s2.w = (_a3 = inputStock.value[0]) == null ? void 0 : _a3.w;
        }
        const materialOption = materials.value.find((m2) => m2.name === s2.material);
        if (materialOption) {
          if (!materialOption.thicknesses.includes(convertUnit(s2.t))) {
            s2.t = materialOption.thicknesses[0];
          }
        }
      });
    }, { deep: true });
    watch(jobId, (val) => {
      if (!val) return;
      if (visInit.value) updateVisSize();
      if (!metadata.value) {
        emit("error", "SmartCut - no metadata received from server");
      }
      updatePartQuantitiesBasedOnThickness();
      const result = {
        jobId: jobId.value,
        metadata: metadata.value,
        parts: uniqueAddedShapes.value.map((p2) => {
          var _a3, _b2;
          return {
            l: p2.l,
            w: p2.w,
            t: p2 == null ? void 0 : p2.t,
            material: p2.material,
            orientationLock: p2.orientationLock,
            q: (_b2 = (_a3 = metadata.value) == null ? void 0 : _a3.addedPartTally) == null ? void 0 : _b2[p2.parentID],
            name: p2.name,
            banding: p2.banding,
            finish: p2.finish,
            customData: p2.customData
          };
        }),
        stock: uniqueUsedStock.value.map((s2) => {
          var _a3, _b2;
          return {
            name: s2 == null ? void 0 : s2.name,
            l: s2.l,
            w: s2.w,
            t: s2 == null ? void 0 : s2.t,
            material: s2.material,
            q: (_b2 = (_a3 = metadata.value) == null ? void 0 : _a3.usedStockTally) == null ? void 0 : _b2[s2.parentID],
            trim: s2 == null ? void 0 : s2.trim,
            cost: s2 == null ? void 0 : s2.cost,
            analysis: s2 == null ? void 0 : s2.analysis,
            type: s2 == null ? void 0 : s2.type
          };
        }),
        offcuts: offcuts.value.map((s2) => ({
          l: s2.l,
          w: s2.w,
          t: (s2 == null ? void 0 : s2.t) ?? null,
          q: s2.q
        })),
        inputs: {
          parts: inputs.value.parts.map((s2) => {
            const newS = { ...s2 };
            delete newS.listId;
            return newS;
          })
        }
      };
      if (metadata.value.unplacedParts.length) {
        const parts2 = metadata.value.unplacedParts.map((s2) => s2.id).join();
        showMessage(t2("The following parts did not fit") + ": " + parts2);
      }
      emit("result", result);
    });
    watch(viewportWidth, () => {
      if (visInit.value) updateVisSize();
    });
    watch(activeStockId, () => {
      if (visInit.value) nextTick$1(() => refresh());
    });
    const cleanupSocket = () => {
      if (socket) {
        socket.disconnect();
        socket = null;
      }
    };
    onMounted(() => {
      if (mounted.value) return;
      const url2 = new URL(window.location.href);
      const queryParams = url2.searchParams.toString();
      const newURL = url2.origin + url2.pathname + (queryParams ? `?${queryParams}` : "");
      if (currentURL.value !== newURL) {
        inputShapes.value.length = 0;
        addInputShape(1);
      }
      currentURL.value = newURL;
      locale2.value = options.locale;
      const socketContext = {
        socket: null,
        connected,
        maintenanceMode,
        jobId,
        progress,
        thinking,
        user,
        saw,
        stockList,
        shapeList,
        cutList,
        offcuts,
        metadata,
        usedStock,
        addedShapes,
        activeStockId
      };
      socket = initSocket.call(socketContext, "http://localhost:5000/");
      socket.connect();
      socket.emit("getUserFromDomain");
      window.addEventListener("resize", debouncedHandleResize, { passive: true });
      window.addEventListener("smartcut/load", handleSmartcutLoad);
      mounted.value = true;
      if (props.debug) {
        emit("log", [
          "SmartCut - ready...",
          "fields:",
          relevantFieldDefinitions.value.map((f2) => f2.id)
        ]);
      }
      if (typeof window !== "undefined") {
        window.smartcutCheckout = { init };
      }
    });
    onUnmounted(() => {
      window.removeEventListener("resize", debouncedHandleResize);
      window.removeEventListener("smartcut/load", handleSmartcutLoad);
      cleanupSocket();
      delete window.smartcutCheckout;
    });
    __expose({
      init,
      getAvailablePricingOptions,
      getExtrasPrice: getExtrasPrice$1,
      formatPrice: props.formatPrice,
      findExtrasPrice: props.findExtrasPrice,
      inputShapes,
      initExtrasOptions,
      createShapeInput
    });
    return (_ctx, _cache) => {
      var _a3, _b2, _c, _d, _e, _f, _g;
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      return openBlock(), createElementBlock(Fragment, null, [
        unref(env) === "development" && showDevInfo$1 ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
          _cache[5] || (_cache[5] = createBaseVNode("div", null, "Developer information", -1)),
          createVNode(unref(ObjectViewer), {
            data: [inputStock.value[0]],
            paths: ["inputStock[0]"]
          }, null, 8, ["data"])
        ])) : createCommentVNode("", true),
        machiningEnabled.value && ((_a3 = currentInputShape.value) == null ? void 0 : _a3.machining) ? (openBlock(), createBlock(unref(Machining2), {
          key: 1,
          shape: currentInputShape.value,
          "onUpdate:shape": _cache[0] || (_cache[0] = ($event) => currentInputShape.value = $event),
          translate: true,
          options: machiningOptions,
          env: unref(env),
          "find-extras-price": __props.findExtrasPrice,
          "get-extras-price": getExtrasPrice$1,
          "get-available-pricing-options": getAvailablePricingOptions,
          "format-price": __props.formatPrice,
          onClose: closeMachining
        }, null, 8, ["shape", "options", "env", "find-extras-price", "format-price"])) : createCommentVNode("", true),
        !loaded.value ? (openBlock(), createElementBlock("div", _hoisted_2, [
          createVNode(Spinner, {
            size: 50,
            "show-number": false
          })
        ])) : createCommentVNode("", true),
        loaded.value ? (openBlock(), createElementBlock("div", {
          key: 3,
          id: "smartcut-checkout",
          class: normalizeClass({ fullscreen: isFullScreen.value })
        }, [
          canGoFullScreen.value && !__props.readonly ? (openBlock(), createElementBlock("div", {
            key: 0,
            id: "smartcut-full-screen",
            class: "icon-left",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleFullScreen())
          }, [
            createVNode(_component_font_awesome_icon, { icon: ["fasr", "expand"] }),
            createTextVNode(" " + toDisplayString(unref(t2)("full screen")), 1)
          ])) : createCommentVNode("", true),
          !((_c = (_b2 = user.value) == null ? void 0 : _b2.api) == null ? void 0 : _c.whiteLabel) ? (openBlock(), createElementBlock("div", {
            key: 1,
            id: "credit",
            style: normalizeStyle(creditStyles.value)
          }, [
            createBaseVNode("a", {
              title: "SmartCut | Cut list optimization software",
              style: normalizeStyle(creditLinkStyles.value),
              target: "_blank",
              href: "https://smartcut.dev/"
            }, toDisplayString(unref(t2)("Powered by SmartCut")), 5)
          ], 4)) : createCommentVNode("", true),
          createBaseVNode("div", {
            id: "part-input",
            class: "inputs no-margin-top grid-table",
            style: normalizeStyle({ "grid-template-columns": partColumnsStyle.value })
          }, [
            unref(inputShapes).length ? (openBlock(), createElementBlock("div", _hoisted_3, [
              _cache[6] || (_cache[6] = createBaseVNode("div", { class: "cell id" }, null, -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(relevantFieldDefinitions.value, (f2) => {
                return openBlock(), createElementBlock("div", {
                  key: f2.id,
                  class: normalizeClass(["cell", { center: ["orientationLock", "banding", "finish", "machining"].includes(f2.id) || f2.type === "checkbox" }])
                }, toDisplayString(f2.label), 3);
              }), 128)),
              unref(env) === "development" ? (openBlock(), createElementBlock("div", _hoisted_4, " Info ")) : createCommentVNode("", true),
              unref(inputShapes).length > 1 ? (openBlock(), createElementBlock("div", _hoisted_5)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(inputShapes), (shape, shapeIndex) => {
              return openBlock(), createElementBlock("div", {
                key: shapeIndex,
                class: "row inputs"
              }, [
                createBaseVNode("div", _hoisted_6, [
                  createBaseVNode("div", {
                    class: "id",
                    style: normalizeStyle({
                      background: colors.partA,
                      color: colors.text
                    })
                  }, toDisplayString(shapeIndex + 1), 5)
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList(relevantFieldDefinitions.value, (f2) => {
                  return openBlock(), createElementBlock("div", {
                    key: f2.fieldMap,
                    class: normalizeClass(["cell", [`${f2.id}`, { center: ["orientationLock", "banding", "finish", "machining"].includes(f2.id) || f2.type === "checkbox" }]])
                  }, [
                    !["orientationLock", "banding", "finish", "machining"].includes(f2.id) ? (openBlock(), createBlock(InputField, {
                      key: 0,
                      id: f2.id + "-" + shapeIndex,
                      focus: !__props.readonly && options.enable.focus && shapeIndex === unref(inputShapes).length - 1 && f2.id === "l",
                      warning: showShapeInputIssue$1("warnings", shape, f2.fieldMap),
                      issue: showShapeInputIssue$1("issues", shape, f2.fieldMap),
                      type: f2.type,
                      output: f2.output,
                      label: f2.label,
                      units: __props.units,
                      readonly: __props.readonly,
                      placeholder: f2 == null ? void 0 : f2.placeholder,
                      options: f2.id === "t" ? getShapeThicknessOptions(shape) : f2 == null ? void 0 : f2.options,
                      "true-value": f2 == null ? void 0 : f2.trueValue,
                      "false-value": f2 == null ? void 0 : f2.falseValue,
                      default: f2 == null ? void 0 : f2.default,
                      min: typeof (f2 == null ? void 0 : f2.min) === "number" ? f2.min : null,
                      max: typeof (f2 == null ? void 0 : f2.max) === "number" ? f2.max : null,
                      custom: f2 == null ? void 0 : f2.custom,
                      value: getNestedValue$1(shape, f2 == null ? void 0 : f2.fieldMap),
                      text: {
                        delete: unref(t2)("delete"),
                        select: unref(t2)("select")
                      },
                      onUpdate: (value2) => {
                        if (f2.fieldMap) {
                          setNestedValue$1(shape, f2.fieldMap, value2);
                        }
                      }
                    }, null, 8, ["id", "focus", "warning", "issue", "type", "output", "label", "units", "readonly", "placeholder", "options", "true-value", "false-value", "default", "min", "max", "custom", "value", "text", "onUpdate"])) : f2.id === "orientationLock" ? (openBlock(), createBlock(_sfc_main$8, {
                      key: 1,
                      id: "orientation-" + shapeIndex,
                      rectangle: shape,
                      disabled: __props.readonly,
                      "stock-grain": getShapeStockGrainSummary(shape),
                      "button-background": colors.button,
                      "icon-color": colors.buttonText,
                      "orientation-model": options.orientationModel,
                      onUpdateOrientation: ($event) => updateShapeOrientation(shape, $event)
                    }, null, 8, ["id", "rectangle", "disabled", "stock-grain", "button-background", "icon-color", "orientation-model", "onUpdateOrientation"])) : f2.id === "banding" ? (openBlock(), createBlock(_sfc_main$7, {
                      key: 2,
                      id: "banding-" + shapeIndex,
                      "input-shape": shape,
                      disabled: __props.readonly,
                      "stock-grain": getShapeStockGrainSummary(shape),
                      open: extrasIndex.banding === shapeIndex,
                      "orientation-model": options.orientationModel,
                      onClicked: ($event) => openExtra("banding", shape)
                    }, null, 8, ["id", "input-shape", "disabled", "stock-grain", "open", "orientation-model", "onClicked"])) : f2.id === "finish" ? (openBlock(), createBlock(_sfc_main$4, {
                      key: 3,
                      id: "finish-" + shapeIndex,
                      "input-shape": shape,
                      disabled: __props.readonly,
                      open: extrasIndex.finish === shapeIndex,
                      onClicked: ($event) => openExtra("finish", shape)
                    }, null, 8, ["id", "input-shape", "disabled", "open", "onClicked"])) : f2.fieldMap === "machining" && canGoFullScreen.value ? (openBlock(), createBlock(MachiningButton, {
                      key: 4,
                      id: "machining-" + shapeIndex,
                      disabled: __props.readonly,
                      "input-shape": shape,
                      onOpen: ($event) => openMachining(shape)
                    }, null, 8, ["id", "disabled", "input-shape", "onOpen"])) : createCommentVNode("", true)
                  ], 2);
                }), 128)),
                unref(env) === "development" ? (openBlock(), createElementBlock("div", _hoisted_7, [
                  createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass({ selected: extrasIndex.info === shapeIndex }),
                    onClick: ($event) => openExtra("info", shape)
                  }, " i ", 10, _hoisted_8)
                ])) : createCommentVNode("", true),
                unref(inputShapes).length > 1 ? (openBlock(), createElementBlock("div", _hoisted_9, [
                  createBaseVNode("button", {
                    type: "button",
                    disabled: __props.readonly,
                    class: "delete",
                    "aria-label": unref(t2)("remove part"),
                    onClick: ($event) => removeShape(shapeIndex)
                  }, [
                    createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] })
                  ], 8, _hoisted_10)
                ])) : createCommentVNode("", true),
                extrasIndex.banding === shapeIndex && bandingData.options.length > 0 ? (openBlock(), createBlock(_sfc_main$5, {
                  key: 2,
                  env: unref(env),
                  shape,
                  "shape-index": shapeIndex,
                  "extra-type": "banding",
                  "extra-label": "banding",
                  "extra-keys": bandingData.keys,
                  "all-options": bandingData.options,
                  pricing: bandingData.pricing,
                  labels: bandingData.labels,
                  "user-friendly-field-map": unref(userFriendlyFieldMap),
                  "part-columns": partColumns.value,
                  "get-price": getExtrasPrice$1,
                  "format-price": __props.formatPrice,
                  "orientation-model": options.orientationModel,
                  "get-available-pricing-options": getAvailablePricingOptions,
                  onUpdateAll: setAllExtrasOptions$1,
                  onSet: setExtrasOption$1
                }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : createCommentVNode("", true),
                extrasIndex.finish === shapeIndex && finishData.options.length > 0 ? (openBlock(), createBlock(_sfc_main$5, {
                  key: 3,
                  env: unref(env),
                  shape,
                  "shape-index": shapeIndex,
                  "extra-type": "finish",
                  "extra-label": "finish",
                  "extra-keys": finishData.keys,
                  "all-options": finishData.options,
                  pricing: finishData.pricing,
                  labels: finishData.labels,
                  "user-friendly-field-map": unref(userFriendlyFieldMap),
                  "part-columns": partColumns.value,
                  "get-price": getExtrasPrice$1,
                  "format-price": __props.formatPrice,
                  "orientation-model": options.orientationModel,
                  "get-available-pricing-options": getAvailablePricingOptions,
                  onUpdateAll: setAllExtrasOptions$1,
                  onSet: setExtrasOption$1
                }, null, 8, ["env", "shape", "shape-index", "extra-keys", "all-options", "pricing", "labels", "user-friendly-field-map", "part-columns", "format-price", "orientation-model"])) : createCommentVNode("", true),
                extrasIndex.info === shapeIndex ? (openBlock(), createElementBlock("div", {
                  key: 4,
                  id: "shape-info",
                  style: normalizeStyle({ "grid-column-end": "span " + (partColumns.value + 1) })
                }, [
                  createVNode(unref(ObjectViewer), {
                    data: [shape == null ? void 0 : shape.machining],
                    paths: ["machining"]
                  }, null, 8, ["data"])
                ], 4)) : createCommentVNode("", true)
              ]);
            }), 128))
          ], 4),
          createBaseVNode("div", _hoisted_11, [
            !__props.readonly ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              "aria-label": unref(t2)("add part"),
              style: normalizeStyle({ background: colors.button, color: colors.buttonText }),
              class: "add c-btn icon-left",
              onClick: _cache[2] || (_cache[2] = ($event) => addInputShape(1))
            }, [
              createVNode(_component_font_awesome_icon, { icon: ["fasr", "plus-large"] }),
              createTextVNode(" " + toDisplayString(unref(t2)("add part")), 1)
            ], 12, _hoisted_12)) : createCommentVNode("", true),
            createBaseVNode("button", {
              id: "calculate-button",
              type: "button",
              class: "c-btn calculate icon-left",
              "aria-label": unref(t2)("calculate"),
              style: normalizeStyle({
                background: colors.button,
                color: colors.buttonText
              }),
              disabled: !((_d = inputStock.value) == null ? void 0 : _d.length) || thinking.value,
              onClick: _cache[3] || (_cache[3] = ($event) => calculate())
            }, [
              createVNode(_component_font_awesome_icon, { icon: ["fass", "calculator"] }),
              createTextVNode(toDisplayString(unref(t2)("calculate")), 1)
            ], 12, _hoisted_13),
            !__props.readonly ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "c-btn clear",
              "aria-label": unref(t2)("clear"),
              onClick: _cache[4] || (_cache[4] = ($event) => clear())
            }, [
              createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] })
            ], 8, _hoisted_14)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_15, toDisplayString(totalInputShapes.value) + toDisplayString((options == null ? void 0 : options.maxParts) ? "/" + options.maxParts : ""), 1)
          ]),
          CSVImportEnabled.value && !__props.readonly ? (openBlock(), createBlock(unref(ImportCSV), {
            key: 2,
            ref: "import",
            units: __props.units,
            "custom-fields": customFieldDefinitions.value,
            "banding-options": bandingData.options,
            "banding-labels": bandingData.labels,
            "finish-options": finishData.options,
            "finish-labels": finishData.labels,
            options: {
              locale: options.locale
            },
            onImport: importParts
          }, null, 8, ["units", "custom-fields", "banding-options", "banding-labels", "finish-options", "finish-labels", "options"])) : createCommentVNode("", true),
          messageVisible.value ? (openBlock(), createElementBlock("div", _hoisted_16, [
            messageHeading.value ? (openBlock(), createElementBlock("div", _hoisted_17, toDisplayString(messageHeading.value), 1)) : createCommentVNode("", true),
            createBaseVNode("pre", _hoisted_18, toDisplayString(messageContent.value), 1)
          ])) : createCommentVNode("", true),
          (options.enable.diagram ? thinking.value && !progress.value.complete : thinking.value || progress.value.complete) ? (openBlock(), createElementBlock("div", _hoisted_19, [
            createVNode(Spinner, {
              size: 50,
              number: progress.value.shapeCount,
              complete: progress.value.complete,
              "show-number": options.enable.progressNumber
            }, null, 8, ["number", "complete", "show-number"])
          ])) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", _hoisted_20, [
            ((_e = activeStock.value) == null ? void 0 : _e.type) !== "roll" ? (openBlock(), createElementBlock("div", _hoisted_21, toDisplayString(((_f = activeStock.value) == null ? void 0 : _f.stack) ? (_g = activeStock.value) == null ? void 0 : _g.stack : 1), 1)) : createCommentVNode("", true)
          ], 512), [
            [vShow, options.enable.diagram && jobId.value > 0]
          ]),
          options.enable.diagram && visInit.value && usedStock.value.length > 1 && jobId.value > 0 && progress.value.complete ? (openBlock(), createBlock(StockNavigation, {
            key: 5,
            ref: "stockNavigation",
            "active-stock-id": activeStockId.value,
            "stock-list": stackedStock.value,
            "stock-count": stockList.value.length,
            "viewport-width": viewportWidth.value,
            onShowStock: showStock$1
          }, null, 8, ["active-stock-id", "stock-list", "stock-count", "viewport-width"])) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true)
      ], 64);
    };
  }
});
function block0(Component) {
  const _Component = Component;
  _Component.__i18n = _Component.__i18n || [];
  _Component.__i18n.push({
    "locale": "",
    "resource": {
      "en_US": {
        "N/A": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "N/A" } },
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Length" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Width" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "W" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Thickness" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "T" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Name" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Quantity" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Q" } },
        "material": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Material" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Orientation" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Machining" } },
        "grain": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Grain" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Add part" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Remove part" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Calculate" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Full screen" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Banding" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Delete banding" } },
        "finish": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Finish" } },
        "delete finish": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Delete finish" } },
        "select": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Select" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Delete" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Clear" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "W1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "W2" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "All" } },
        "a": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A" } },
        "b": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "B" } },
        "c": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "C" } },
        "d": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "D" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Drop CSV file here" } },
        "Powered by SmartCut": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Powered by SmartCut" } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Part" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Issue" } },
        "Part issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Part issue" } },
        "Issue with part inputs": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Issue with part inputs" } },
        "No parts": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No parts" } },
        "No parts in list": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No parts in list" } },
        "No quantity of parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No quantity of parts found" } },
        "No parts were added - please double check your list.": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No parts were added - please double check your list." } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "The following parts did not fit" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "The maximum number of parts is" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No valid parts found" } },
        "Hardware": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Hardware" } },
        "Hardware total": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Hardware total" } },
        "Panels": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Panels" } },
        "pdf": {
          "orderSummary": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Order summary" } },
          "stockRequirements": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Stock requirements" } },
          "totals": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Totals" } },
          "item": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Item" } },
          "totalParts": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Total parts" } },
          "partArea": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Part area" } },
          "totalStockRequired": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Total stock required" } },
          "totalBandingLength": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Total banding length" } },
          "totalFinishArea": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Total finish area" } }
        }
      },
      "ca": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Llarg" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Ample" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Gruix" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "G" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Nom" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Quantitat" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Q" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Mecanitzat" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Gir" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Afegeix" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Calcula" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pantalla completa" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Cantell" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina cantell" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Neteja" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Todos" } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Peça" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tema" } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Les peces següents no encaixaven" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "El número màxim de peces és" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No s'han trobat peces vàlides" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No s'han trobat peces vàlides" } },
        "Powered by SmartCut": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Desenvolupat per SmartCut" } }
      },
      "es_ES": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Largo" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Ancho" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Grueso" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "G" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Nombre" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Cantidad" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "C" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Mecanizado" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Giro" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Añade" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Calcula" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pantalla completa" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Canto" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina canto" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Borra" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Todos" } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pieza" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tema" } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Las siguientes piezas no encajaban" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "El número máximo de piezas es" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No se encontraron piezas válidas" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Carga el archivo CSV aquí" } },
        "Powered by SmartCut": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Desarrollado por SmartCut" } }
      },
      "fr_FR": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Longueur" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Largeur" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "la" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Epaisseur" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "ep" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Nom" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Quantité" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Qt" } },
        "material": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Matèriel" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Machinage" } },
        "grain": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Sens de fil" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Orientation" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Ajouter pièce" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Supprimer pièce" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Optimiser" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Plein écran" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Chants" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Supprimer chants" } },
        "select": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Sélectionner" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Supprimer" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Effacer" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "la1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "la2" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tous" } },
        "N/A": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "N/A" } },
        "Powered by SmartCut": { "t": 0, "b": { "static": "", "t": 2, "i": [] } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pièce" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Télécharger CSV" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Erreur" } },
        "Part issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pièce erreur" } },
        "Issue with part inputs": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Erreur avec l'importation de pièces" } },
        "No parts": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pièce" } },
        "No parts in list": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pièce dans la liste" } },
        "No quantity of parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune quantité trouvé pour certaines pièces" } },
        "No parts were added - please double check your list.": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pièce n'a été ajoutée - veuillez vérifier votre liste." } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Les pièces suivantes ne s'adaptent pas" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Le nombre maximum de pièces est" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pièce valide trouvée" } }
      }
    }
  });
}
if (typeof block0 === "function") block0(_sfc_main$2);
const CheckoutCalculator = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-acc3f94c"]]);
const _hoisted_1 = {
  key: 0,
  class: "debug"
};
const showDevInfo = false;
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "WordPress",
  setup(__props) {
    const priceTypes = ["banding", "finish", "cutLength", "perPart", "surcharge", "machining", "stock", "custom"];
    const isPriceType = (price) => priceTypes.includes(price);
    const FormulaPricing = defineAsyncComponent(() => import("./FormulaPricing-lTJqhUQI.js"));
    const ObjectViewer = defineAsyncComponent(() => import("./ObjectViewer-BiwJbooS.js"));
    const env = "development";
    const elements = {};
    const inputs = {};
    let settings = {};
    const extrasData = {
      banding: null,
      finish: null
    };
    let product = null;
    let variations = [];
    let machiningPricing = null;
    let formatting = {};
    const debug2 = ref(false);
    const inputType = ref("manual");
    const formulaURL = ref("");
    const stock = ref([]);
    const selectedVariation = ref(null);
    const quantityPricing = ref(true);
    const hardwareResult = ref(null);
    const metadata = ref(null);
    const checkoutEnabled = ref(false);
    const calculator = ref(null);
    const smartcutConfigUnits = computed(() => {
      return window.smartcutConfig.settings.units ?? "decimal";
    });
    provide("calculator", () => calculator.value);
    const log = (messages) => {
      if (debug2.value) {
        console.log("SmartCut -", ...messages);
      }
    };
    const error = (message) => {
      console.error(`SmartCut - ${message}`);
    };
    const enableCutToSize = (enableQuantity = false) => {
      checkoutEnabled.value = true;
      const relevantElements = ["checkout", "intro_text", "offcuts", "banding_key"];
      relevantElements.forEach((e) => {
        const element = elements[e];
        if (element) element.style.display = "block";
      });
      if (isPricingTableNeeded()) {
        elements["pricing_table"].style.display = "table";
      }
      if (enableQuantity) {
        enableQuantityMethod(true);
      } else {
        disableQuantity();
      }
      disableAddToCart();
    };
    const disableCutToSize = (enableQuantity = true, enableCartButton = true) => {
      checkoutEnabled.value = false;
      const relevantElements = ["checkout", "intro_text", "offcuts", "banding_key", "pricing_table"];
      relevantElements.forEach((e) => {
        const element = elements[e];
        if (element) element.style.display = "none";
      });
      if (enableCartButton === true) {
        enableAddToCart();
      } else if (enableCartButton === false) {
        disableAddToCart();
      }
      if (enableQuantity) {
        enableQuantityMethod();
      } else if (enableQuantity === false) {
        disableQuantity();
      }
    };
    const enableQuantityMethod = (readonly2 = false) => {
      elements.quantity.style.display = "inline-block";
      elements.quantity.readOnly = readonly2;
    };
    const disableQuantity = () => {
      if (checkoutEnabled.value === false) return;
      elements.quantity.value = "1";
      elements.quantity.style.display = "none";
      elements.quantity.readOnly = true;
    };
    const setPrice = (type3, price) => {
      if (!isPriceType(type3)) return;
      const fieldMappings = {
        custom: {
          visible: null,
          hidden: "smartcut-custom-price"
        },
        perPart: {
          hidden: "smartcut-per-part-price",
          visible: "per_part_price"
        },
        banding: {
          hidden: "smartcut-banding-price",
          visible: "banding_total_price"
        },
        finish: {
          hidden: "smartcut-finish-price",
          visible: "finish_total_price"
        },
        machining: {
          hidden: "smartcut-machining-price",
          visible: "machining_total_price"
        },
        surcharge: {
          hidden: "smartcut-cut-to-size-surcharge",
          visible: "surcharge_price"
        },
        cutLength: {
          hidden: "smartcut-cut-length-price",
          visible: "cut_length_price"
        },
        stock: {
          hidden: null,
          visible: "stock_total_price"
        }
      };
      const mapping = fieldMappings[type3];
      if ((mapping == null ? void 0 : mapping.hidden) && inputs[mapping.hidden]) {
        log([`setting hidden price ${type3}`, price]);
        inputs[mapping.hidden].value = price;
      } else if (mapping == null ? void 0 : mapping.hidden) {
        log(["hidden price field not found", mapping, type3]);
      }
      if ((mapping == null ? void 0 : mapping.visible) && elements[mapping.visible]) {
        log(["setting visible price", type3, formatPrice(price)]);
        elements[mapping.visible].innerText = formatPrice(price);
      } else if (mapping == null ? void 0 : mapping.visible) {
        log(["visible price field not found", mapping, type3]);
      }
    };
    const enableAddToCart = () => {
      if (!elements.cart_button) {
        error("Cart button not found");
        return;
      }
      elements.cart_button.disabled = false;
    };
    const disableAddToCart = () => {
      if (checkoutEnabled.value === false) return;
      if (!elements.cart_button) {
        error("Cart button not found");
        return;
      }
      elements.cart_button.disabled = true;
    };
    const setCartQuantity = (quantity, decimalPlaces = 0) => {
      if (!elements.quantity) {
        error("Quantity field not found when trying to set");
        return;
      }
      elements.quantity.value = quantity.toFixed(decimalPlaces);
    };
    const setVariationPrice = (price) => {
      log(["setting variation price", price]);
      const variationPriceEl = document.querySelector(".woocommerce-variation-price .smartcut-price-selector");
      if (variationPriceEl) {
        variationPriceEl.innerText = formatPrice(price);
      }
      selectedVariation.value.display_price = price;
    };
    const initCheckout = () => {
      if (!(window == null ? void 0 : window.smartcutConfig)) {
        error("SmartCut config not found");
        return;
      }
      const config2 = window.smartcutConfig;
      settings = config2.settings;
      const banding = getExtrasData(getNestedObjectData(window, ["smartcutConfig", "banding_data"]));
      const finish = getExtrasData(getNestedObjectData(window, ["smartcutConfig", "finish_data"]));
      const options = {
        debug: settings.debug,
        units: settings.units,
        locale: config2.locale,
        decimalPlaces: 2,
        //saw
        stockType: settings.stock_type,
        bladeWidth: settings.blade_width,
        cutPreference: settings.cut_preference,
        stackHeight: settings.stack_height,
        stockSelection: settings.stock_selection,
        stockGrain: settings.stock_grain,
        minSpacing: settings.min_spacing,
        maxParts: settings.max_parts ?? null,
        orientationModel: settings.orientation_model,
        minDimension: settings.min_dimension,
        enable: {
          banding: !settings.disable_banding,
          finish: !settings.disable_finish,
          orientation: !settings.disable_orientation,
          diagram: !settings.hide_diagram,
          focus: true,
          machining: settings.enable_machining,
          csvImport: settings.enable_import,
          click: true,
          partName: !settings.disable_part_name,
          progressNumber: settings.pricing_strategy === "part_area" ? false : true
        },
        colors: {
          partA: (settings == null ? void 0 : settings.part_a_color) ?? "#1d9bc4",
          partB: (settings == null ? void 0 : settings.part_b_color) ?? "#065d7a",
          partHover: (settings == null ? void 0 : settings.part_hover_color) ?? "#f8b029",
          partSelected: (settings == null ? void 0 : settings.part_selected_color) ?? "#5bc85b",
          stock: (settings == null ? void 0 : settings.stock_color) ?? "#ffd166",
          button: (settings == null ? void 0 : settings.button_color) ?? "#118ab2",
          buttonText: (settings == null ? void 0 : settings.button_text_color) ?? "#ffffff",
          text: (settings == null ? void 0 : settings.text_color) ?? "#ffffff"
        }
      };
      debug2.value = options.debug;
      const machining = {
        units: "decimal",
        faces: {
          enabled: settings.machining_sides
        },
        holes: {
          enabled: settings.machining_holes,
          defaultDiameter: settings.machining_holes_default_diameter,
          diameters: settings.machining_holes_diameters.split(",").map((v2) => v2.trim()).filter(Boolean),
          minDiameter: settings.machining_holes_min_diameter,
          maxDiameter: settings.machining_holes_max_diameter,
          enableDepth: settings.machining_holes_depth,
          depths: settings.machining_holes_depths.split(",").map((v2) => v2.trim()).filter(Boolean),
          defaultDepth: settings.machining_holes_default_depth,
          minDepth: settings.machining_holes_min_depth,
          maxDepth: settings.machining_holes_max_depth
        },
        hingeHoles: {
          enabled: settings.machining_hinge_holes,
          minimumHoleDistance: settings.machining_hinge_holes_minimum_hole_distance,
          defaultDistanceFromEdge: settings.machining_hinge_holes_default_distance_from_edge,
          defaultOuterSpacing: settings.machining_hinge_holes_default_outer_spacing,
          defaultHingeLength: settings.machining_hinge_holes_default_hinge_length
        },
        corners: {
          enabled: settings.machining_radius_corners || settings.machining_bevel_corners,
          types: [
            settings.machining_radius_corners ? "radius" : null,
            settings.machining_bevel_corners ? "bevel" : null
          ].filter(Boolean),
          minValue: settings.machining_corners_min_value,
          maxValue: settings.machining_corners_max_value,
          enableBanding: settings.machining_corners_enable_banding
        }
      };
      quantityPricing.value = isQuantityPricing();
      if (quantityPricing.value) {
        enableQuantityMethod(true);
      } else {
        disableQuantity();
      }
      if (product.type === "variable") {
        disableCutToSize(false, false);
      } else {
        enableCutToSize(true);
      }
      const initData = {
        type: product.type,
        stock: stock.value,
        variations: variations ?? null,
        options,
        banding,
        finish,
        machining
      };
      nextTick$1(() => {
        if (calculator.value) calculator.value.init(initData);
      });
    };
    const configureProduct = (smartcutConfig) => {
      const multiple_sizes = (smartcutConfig == null ? void 0 : smartcutConfig.multiple_sizes) === true;
      product = {
        type: smartcutConfig == null ? void 0 : smartcutConfig.product_type,
        multiple_sizes,
        size: (smartcutConfig == null ? void 0 : smartcutConfig.size) ? smartcutConfig.size.split(" | ") : [],
        l: !multiple_sizes && (smartcutConfig == null ? void 0 : smartcutConfig.l) ? parseFloat(smartcutConfig.l) : null,
        w: !multiple_sizes && (smartcutConfig == null ? void 0 : smartcutConfig.w) ? parseFloat(smartcutConfig.w) : null,
        t: (smartcutConfig == null ? void 0 : smartcutConfig.t) ?? null,
        price: parseFloat(smartcutConfig == null ? void 0 : smartcutConfig.price) ?? null,
        stock_name: smartcutConfig.stock_name
      };
      if (!product.multiple_sizes) {
        if (!product.l) {
          error("product 'length' attribute not available");
        }
        if (!product.w) {
          error("product 'width' attribute not available");
        }
      }
    };
    const configurePricing = (smartcutConfig) => {
      inputType.value = getNestedObjectData(window, ["smartcutConfig", "settings", "enable_formula"]) === true ? "formula" : "manual";
      formulaURL.value = getNestedObjectData(window, ["smartcutConfig", "settings", "formula_url"]);
      log([`Input type: ${inputType.value}`]);
      log([`Input type: ${inputType.value}`]);
      formatting = {
        thousands_separator: smartcutConfig == null ? void 0 : smartcutConfig.thousands_separator,
        decimal_separator: smartcutConfig == null ? void 0 : smartcutConfig.decimal_separator,
        number_of_decimals: smartcutConfig == null ? void 0 : smartcutConfig.number_of_decimals,
        currency_symbol: smartcutConfig == null ? void 0 : smartcutConfig.currency_symbol,
        currency_position: smartcutConfig == null ? void 0 : smartcutConfig.currency_position
      };
    };
    const cacheElements = () => {
      const elementIds = {
        checkout: "#smartcut-app",
        intro_text: "#smartcut-intro-text",
        pricing_table: "#smartcut-pricing-table",
        offcuts: "#include_offcuts_field",
        banding_key: "#smartcut-banding-key",
        finish_key: "#smartcut-finish-key",
        banding_total_price: "#smartcut-banding-total bdi .smartcut-price-selector",
        finish_total_price: "#smartcut-finish-total bdi .smartcut-price-selector",
        cut_length_price: "#smartcut-cut-length-total bdi .smartcut-price-selector",
        per_part_price: "#smartcut-per-part-total bdi .smartcut-price-selector",
        surcharge_price: "#smartcut-surcharge-total bdi .smartcut-price-selector",
        machining_total_price: "#smartcut-machining-total bdi .smartcut-price-selector",
        stock_total_price: "#smartcut-stock-total bdi .smartcut-price-selector",
        quantity: ".smartcut-stock-quantity",
        //this is the add to cart quantity element(s)
        cart_button: ".single_add_to_cart_button"
      };
      for (const [key, selector2] of Object.entries(elementIds)) {
        elements[key] = document.querySelector(selector2);
      }
      if (!elements.checkout) {
        return error("checkout iframe not found");
      }
      if (!elements.quantity) {
        return error("quantity field not found");
      }
      if (!elements.cart_button) {
        return error("cart button not found");
      }
      elements.quantity.readOnly = true;
      disableAddToCart();
    };
    const getStockTrim = () => {
      return {
        x1: settings.stock_trim_x1 ?? 0,
        x2: settings.stock_trim_x2 ?? 0,
        y1: settings.stock_type === "linear" ? 0 : settings.stock_trim_y1 ?? 0,
        y2: settings.stock_type === "linear" ? 0 : settings.stock_trim_y2 ?? 0
      };
    };
    const createStock = (l2 = null, w2 = null, t2 = null, cost = null, attributes = null) => {
      let notes;
      if (attributes && typeof attributes === "object") {
        notes = [];
        for (const [key, value2] of Object.entries(attributes)) {
          if (key === "attribute_size") continue;
          if (key === "attribute_thickness") continue;
          notes.push(`${key.replace("attribute_", "")}: ${value2}`);
        }
        notes = notes.join(" - ");
      }
      const inputStockData = {
        name: product.stock_name,
        type: settings.stock_type,
        l: l2,
        w: w2,
        t: t2,
        grain: settings.stock_grain,
        cost: parseFloat((cost == null ? void 0 : cost.toString()) || "0"),
        trim: getStockTrim(),
        allowExactFitShapes: true,
        notes
      };
      return inputStockData;
    };
    const configureStock = () => {
      if (!(product == null ? void 0 : product.stock_name)) {
        error("product name not specified");
      }
      stock.value = [];
      if (product.multiple_sizes) {
        product.size.forEach((size) => {
          const [l2, w2] = size.split("x");
          const newStock = createStock(
            parseFloat(l2),
            parseFloat(w2),
            product == null ? void 0 : product.t,
            size.price
          );
          stock.value.push(newStock);
        });
      } else {
        stock.value.push(createStock(
          product.l,
          product.w,
          product == null ? void 0 : product.t,
          product == null ? void 0 : product.price
        ));
      }
    };
    const addThousandsSeparators = (numStr, separator) => {
      const parts2 = numStr.split(".");
      parts2[0] = parts2[0].replace(/\B(?=(\d{3})+(?!\d))/g, separator);
      return parts2.join(".");
    };
    const formatPrice = (price = 0, locale2 = "") => {
      if (!price) {
        if (!locale2) return "0.00";
        return addCurrencySymbol("0.00");
      }
      if (typeof price === "string") price = parseFloat(price);
      const formattedPrice = price.toFixed(formatting.number_of_decimals).replace(".", formatting.decimal_separator);
      const withSeparators = addThousandsSeparators(formattedPrice, formatting.thousands_separator);
      if (!locale2) return withSeparators;
      return addCurrencySymbol(withSeparators);
    };
    const formatNumber = (number2) => {
      if (number2 === null || number2 === void 0) return "";
      if (typeof number2 === "string") number2 = parseFloat(number2);
      const hasDecimals = number2 % 1 !== 0;
      const decimals = hasDecimals ? formatting.number_of_decimals : 0;
      const formatted = number2.toFixed(decimals).replace(".", formatting.decimal_separator);
      return addThousandsSeparators(formatted, formatting.thousands_separator);
    };
    const addCurrencySymbol = (price) => {
      switch (formatting.currency_position) {
        case "left":
          return `${formatting.currency_symbol}${price}`;
        case "right":
          return `${price}${formatting.currency_symbol}`;
        default:
          return `${formatting.currency_symbol}${price}`;
      }
    };
    const formatExtrasKey = (key) => {
      const processString = (str) => {
        return truncateString(sanitiseString(str), 100).replace("|", "_");
      };
      if (Array.isArray(key)) {
        return key.map(processString).join(",");
      } else {
        return processString(key);
      }
    };
    const getExtrasData = (wcExtrasData) => {
      if (!wcExtrasData) return null;
      const extrasData2 = {
        labels: [],
        pricing: {}
      };
      const items = Object.values(wcExtrasData);
      for (const item of items) {
        if (item == null ? void 0 : item.variations) {
          extrasData2.labels.push(...Object.keys(item.options));
          Object.values(item.variations).forEach((variation) => {
            const { options } = variation;
            const key = Object.values(options).map((o2) => formatExtrasKey(o2)).join("|");
            extrasData2.pricing[key] = parseInt(variation.price);
          });
        } else if (item == null ? void 0 : item.options) {
          Object.keys(item.options).forEach((option) => {
            extrasData2.pricing[formatExtrasKey(option)] = parseInt(item.price);
          });
        }
      }
      if (!extrasData2.labels.length) extrasData2.labels.push("type");
      return extrasData2;
    };
    const findExtrasPrice = (extraType, selectedExtrasOptions) => {
      if (!selectedExtrasOptions.length) return null;
      if (!checkObjectPathExists(extrasData, [extraType])) return null;
      const extraData = getNestedObjectData(extrasData, [extraType]);
      if (!objectValuesPresent(extraData)) return null;
      const allVariations = Object.values(extraData).map((i2) => {
        if (i2 == null ? void 0 : i2.variations) {
          return Object.values(i2.variations).map((i22) => {
            i22.type = "variable";
            return i22;
          });
        } else {
          i2.type = "simple";
          return i2;
        }
      }).flat();
      const foundVariation = allVariations.find((variation) => {
        let variationOptions;
        if (variation.type === "simple") {
          variationOptions = Object.keys(variation.options);
        } else {
          variationOptions = Object.values(variation.options);
        }
        if (!variationOptions) return false;
        return variationOptions.every((option, index) => formatExtrasKey(option) === formatExtrasKey(selectedExtrasOptions[index]));
      });
      return (foundVariation == null ? void 0 : foundVariation.price) ? parseFloat(foundVariation.price) : null;
    };
    const getTotalFinishPrice = (totalFinish) => {
      let total = 0;
      if (typeof totalFinish === "object") {
        for (let [finishKey, area] of Object.entries(totalFinish)) {
          if (typeof area === "string") {
            area = parseFloat(area);
          }
          const finishOptions = finishKey.split("|");
          const price = findExtrasPrice("finish", finishOptions);
          if (price === null) continue;
          const areaInSquareMeters = Number(area) / 1e6;
          const cost = areaInSquareMeters * parseFloat(price.toString());
          total += cost;
        }
        if ("min_finish_charge" in settings) {
          const minFinishCharge = parseFloat(settings == null ? void 0 : settings.min_finish_charge);
          if (minFinishCharge > 0 && total > 0 && total < minFinishCharge) {
            return minFinishCharge;
          }
        }
      }
      return total;
    };
    const getTotalBandingPrice = (totalBanding) => {
      let total = 0;
      if (typeof totalBanding === "object") {
        for (let [bandingKey, length] of Object.entries(totalBanding)) {
          if (typeof length === "string") length = parseFloat(length);
          const bandingOptions = bandingKey.split("|");
          const price = findExtrasPrice("banding", bandingOptions);
          if (price === null) continue;
          const cost = length / (settings.units === "fraction" ? 12 : 1e3) * parseFloat(price.toString());
          total += cost;
        }
        if ("min_banding_charge" in settings) {
          const minBandingCharge = parseFloat(settings == null ? void 0 : settings.min_banding_charge);
          if (minBandingCharge > 0 && total > 0 && total < minBandingCharge) {
            return minBandingCharge;
          }
        }
      }
      return total;
    };
    const getTotalMachiningPrice = (data) => {
      return (machiningPricing.holes ?? 0) * (data.metadata.numHoles ?? 0) + (machiningPricing.corners ?? 0) * (data.metadata.numCorners ?? 0);
    };
    const reset = () => {
      elements.quantity.value = "1";
      disableAddToCart();
      inputs["smartcut-cut-to-size-surcharge"].value = 0;
      for (const price of priceTypes) setPrice(price, 0);
      for (const key in inputs) {
        if (key === "smartcut-hardware-price") continue;
        inputs[key].value = null;
      }
    };
    const isQuantityPricing = () => {
      var _a3;
      if (((_a3 = window.smartcutConfig) == null ? void 0 : _a3.product_type) === "variable") {
        return false;
      }
      switch (settings.pricing_strategy) {
        case "full_sheet":
        case "part_area":
        case "full_sheet_plus_cut_length":
        case "full_sheet_plus_num_parts":
          return true;
        case "cut_length":
          return false;
        default:
          return false;
      }
    };
    const isExtraEnabled = (extraType) => {
      if (checkObjectPathExists(settings, ["enable", extraType]) && getNestedObjectData(settings, ["enable", extraType]) === false) {
        return false;
      }
      const extraData = getNestedObjectData(extrasData, [extraType]);
      return !!(extraData && Object.values(extraData).length);
    };
    const isMachiningEnabled = () => {
      return settings.enable_machining === true;
    };
    const issurchargeEnabled = () => {
      if ((settings == null ? void 0 : settings.surcharge_type) === "none") return false;
      if (!(settings == null ? void 0 : settings.surcharge) || settings.surcharge === "0.00") return false;
      return true;
    };
    const isPricingTableNeeded = () => {
      if (settings.pricing_strategy === "full_sheet_plus_cut_length") return true;
      if (settings.pricing_strategy === "full_sheet_plus_num_parts") return true;
      if (issurchargeEnabled()) return true;
      if (isExtraEnabled("banding")) return true;
      if (isExtraEnabled("finish")) return true;
      if (isMachiningEnabled()) return true;
      return false;
    };
    const getSizes = (variation) => {
      var _a3;
      let sizes = (_a3 = variation == null ? void 0 : variation.attributes) == null ? void 0 : _a3.attribute_size;
      if (!sizes) sizes = product == null ? void 0 : product.size;
      return sizes;
    };
    const isFullSheetSize = (size) => {
      return /\d+x\d+/.test(size);
    };
    const cacheInputFields = () => {
      window.smartcutConfig.input_fields.forEach((f2) => {
        const fieldId = f2.replaceAll("_", "-");
        inputs[fieldId] = document.getElementById(fieldId);
      });
    };
    const handleVariationFound = (e, variation) => {
      reset();
      selectedVariation.value = variation;
      log(["variation selected", variation.attributes]);
      stock.value = [];
      const thickness = getNestedObjectData(variation, ["attributes", "attribute_thickness"]);
      product.selected_thickness = thickness;
      if (product.multiple_sizes) {
        const size = getSizes(variation);
        log([`variation found with size: ${size} & thickness: ${thickness}`]);
        if (!size) {
          disableCutToSize(false);
          return error("The size of this multiple size product could not be found");
        }
        if (!Array.isArray(size)) {
          if (isFullSheetSize(size)) disableCutToSize(true, true);
          else enableCutToSize(false);
        } else {
          enableCutToSize(false);
        }
        if ((variations == null ? void 0 : variations.length) && thickness) {
          let stockSizes;
          if (Array.isArray(size)) {
            const v2 = variations.find((v22) => v22.attributes.thickness === thickness);
            if (!v2) {
              return error(`variation not found for thickness ${thickness}`);
            }
            stockSizes = size.map((size2) => ({
              size: size2,
              l: size2.split("x")[0],
              w: size2.split("x")[1],
              t: thickness,
              price: v2 == null ? void 0 : v2.price
            }));
          } else {
            stockSizes = variations.filter((v2) => {
              var _a3, _b2;
              if (/\d+x\d+/.test((_a3 = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _a3.size)) {
                return thickness === ((_b2 = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _b2.thickness);
              }
              return false;
            }).map((v2) => {
              var _a3, _b2, _c, _d;
              const exactMatchVariation = variations.find((v22) => {
                var _a4, _b3;
                return thickness === ((_a4 = v22 == null ? void 0 : v22.attributes) == null ? void 0 : _a4.thickness) && size === ((_b3 = v22 == null ? void 0 : v22.attributes) == null ? void 0 : _b3.size);
              });
              if (!exactMatchVariation) {
                error(`exactMatchVariation not found for thickness ${thickness}, size: ${size} in variations`);
              }
              let price = !(exactMatchVariation == null ? void 0 : exactMatchVariation.price) || parseFloat(exactMatchVariation.price) === 0 ? (v2 == null ? void 0 : v2.price) ?? "0" : exactMatchVariation == null ? void 0 : exactMatchVariation.price;
              log([
                `size attribute: '${(_a3 = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _a3.size}'`,
                `price for 'thickness ${thickness}, size: ${size}' detected as ${price}`
              ]);
              return {
                size: (_b2 = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _b2.size,
                l: (_c = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _c.size.split("x")[0],
                w: (_d = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _d.size.split("x")[1],
                t: product.selected_thickness,
                price
              };
            });
          }
          if (checkoutEnabled.value === true) {
            stockSizes.forEach((size2) => {
              const newStock = createStock(
                size2.l,
                size2.w,
                size2.t,
                size2.price,
                variation == null ? void 0 : variation.attributes
              );
              stock.value.push(newStock);
            });
          }
        }
      } else {
        const v2 = variations.find((v22) => v22.attributes.thickness === thickness);
        if (!v2) return error(`variation not found for thickness ${thickness}`);
        stock.value.push(createStock(
          product.l,
          product.w,
          thickness,
          v2.price,
          variation == null ? void 0 : variation.attributes
        ));
        enableCutToSize(false);
      }
    };
    const result = async (resultData) => {
      var _a3, _b2;
      reset();
      let totalPrice = 0;
      const quantityPricing2 = isQuantityPricing();
      if (!quantityPricing2) setCartQuantity(1);
      log(["result event received", resultData]);
      if (!(resultData == null ? void 0 : resultData.jobId)) return;
      if (debug2.value) {
        console.table([
          { Property: "multiple sized stock", Value: product.multiple_sizes },
          { Property: "quantity based pricing", Value: quantityPricing2 ? "Y" : "N" }
        ]);
      }
      metadata.value = markRaw(resultData.metadata);
      switch (settings.pricing_strategy) {
        case "full_sheet": {
          log(["calculating cost by full sheet"]);
          if (!quantityPricing2) {
            totalPrice = parseFloat(resultData.metadata.totalStockCost);
          } else {
            setCartQuantity(resultData.metadata.totalUsedStock);
          }
          enableAddToCart();
          break;
        }
        case "part_area": {
          log(["calculating cost by part area in meters / sq feet"]);
          const area = settings.units === "fraction" ? resultData.metadata.totalPartArea / 144 : resultData.metadata.totalPartArea / 1e6;
          log([`part area in square ${settings.units === "fraction" ? "feet" : "meters"}`, area]);
          if (!quantityPricing2) {
            log([`totalPrice is area: ${area} * price: ${selectedVariation.value.display_price}`]);
            totalPrice = area * parseFloat(selectedVariation.value.display_price);
          } else {
            setCartQuantity(area, 2);
          }
          enableAddToCart();
          break;
        }
        case "cut_length": {
          log(["calculating cost by cut length in feet / meters"]);
          const cutLength = resultData.metadata.totalCutLength / (settings.units === "fraction" ? 12 : 1e3);
          setCartQuantity(cutLength, 2);
          enableAddToCart();
          break;
        }
        case "full_sheet_plus_cut_length": {
          log(["calculating cost by full sheet plus cut length"]);
          if (!quantityPricing2) {
            totalPrice = parseFloat(resultData.metadata.totalStockCost);
          } else {
            elements.quantity.value = resultData.metadata.totalUsedStock;
          }
          const cutLength = resultData.metadata.totalCutLength / (settings.units === "fraction" ? 12 : 1e3);
          const cutLengthTotal = cutLength * settings.cut_length_price;
          setPrice("cutLength", cutLengthTotal);
          totalPrice += cutLengthTotal;
          enableAddToCart();
          break;
        }
        case "full_sheet_plus_num_parts": {
          log(["calculating cost by full sheet plus number of parts"]);
          if (!quantityPricing2) {
            const stockCost = parseFloat(resultData.metadata.totalStockCost);
            setPrice("stock", stockCost);
            totalPrice = stockCost;
          } else {
            elements.quantity.value = resultData.metadata.totalUsedStock;
          }
          const partPrice = resultData.metadata.totalPartsProduced * settings.per_part_price;
          setPrice("perPart", partPrice);
          totalPrice += partPrice;
          enableAddToCart();
          break;
        }
      }
      if (!quantityPricing2) {
        if (!resultData.metadata.totalStockCost) {
          return error("Total stock cost not returned for a multiple size product");
        }
        log([`total cost is ${totalPrice}`]);
        setPrice("custom", totalPrice);
      }
      if (isExtraEnabled("banding") && ((_a3 = resultData == null ? void 0 : resultData.metadata) == null ? void 0 : _a3.bandingLengthByType)) {
        const bandingPrice = getTotalBandingPrice(resultData.metadata.bandingLengthByType);
        setPrice("banding", bandingPrice);
        totalPrice += bandingPrice;
      }
      if (isExtraEnabled("finish") && ((_b2 = resultData == null ? void 0 : resultData.metadata) == null ? void 0 : _b2.bandingLengthByType)) {
        const finishPrice = getTotalFinishPrice(resultData.metadata.finishAreaByType);
        setPrice("finish", finishPrice);
        totalPrice += finishPrice;
      }
      if (inputType.value === "formula") {
        const hardwarePrice = parseFloat(inputs["smartcut-hardware-price"].value);
        if (!isNaN(hardwarePrice)) totalPrice += hardwarePrice;
      }
      if (isMachiningEnabled()) {
        const machiningPrice = getTotalMachiningPrice(resultData);
        setPrice("machining", machiningPrice);
        totalPrice += machiningPrice;
      }
      if (issurchargeEnabled() && (settings == null ? void 0 : settings.surcharge)) {
        let surcharge = 0;
        if ((settings == null ? void 0 : settings.surcharge_type) === "per_sheet") {
          surcharge = parseFloat(settings == null ? void 0 : settings.surcharge) * parseFloat(resultData.metadata.totalUsedStock);
        } else {
          surcharge = parseFloat(settings == null ? void 0 : settings.surcharge);
        }
        setPrice("surcharge", surcharge);
        log(["added surcharge", surcharge]);
        totalPrice += surcharge;
      }
      if (selectedVariation.value) {
        setVariationPrice(totalPrice);
      }
      const cartFields = {
        "smartcut-job-id": resultData == null ? void 0 : resultData.jobId,
        "smartcut-dimensions": resultData == null ? void 0 : resultData.parts.map((p2) => `${p2 == null ? void 0 : p2.l}x${p2 == null ? void 0 : p2.w} [${p2 == null ? void 0 : p2.q}]`).join(", "),
        "smartcut-total-cut-length": resultData.metadata.totalCutLength,
        "smartcut-part-area": resultData.metadata.totalPartArea,
        "smartcut-total-cuts": resultData.metadata.totalCuts,
        "smartcut-total-parts": resultData.metadata.totalPartsProduced,
        "smartcut-machining": resultData.metadata.hasMachining
      };
      Object.entries(cartFields).forEach(([field, value2]) => {
        if (inputs == null ? void 0 : inputs[field]) inputs[field].value = value2;
      });
      if (inputs == null ? void 0 : inputs["smartcut-stock-summary"]) {
        const stockSummary = resultData.stock.map((s2) => `${s2 == null ? void 0 : s2.l}x${s2 == null ? void 0 : s2.w}${(s2 == null ? void 0 : s2.t) ? "x" + s2.t : ""} [${s2 == null ? void 0 : s2.q}]`).join(", ");
        inputs["smartcut-stock-summary"].value = stockSummary;
      }
      await createPDFSummary(resultData);
    };
    const createPDFSummary = async (resultData) => {
      const blob = await generateOrderSummaryPDF(resultData, hardwareResult.value, formatNumber);
      const base64PDF = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(",")[1]);
        reader.readAsDataURL(blob);
      });
      inputs["smartcut-order-summary-pdf"].value = base64PDF;
    };
    const setHardwareResult = (result2, total) => {
      disableAddToCart();
      hardwareResult.value = markRaw(result2);
      inputs["smartcut-hardware-price"].value = total;
    };
    onMounted(() => {
      console.log("💥 Powered by https://smartcut.dev", window.smartcutConfig.version);
      log(["Launching WordPress checkout..."]);
      extrasData.banding = getNestedObjectData(window, ["smartcutConfig", "banding_data"]);
      extrasData.finish = getNestedObjectData(window, ["smartcutConfig", "finish_data"]);
      machiningPricing = getNestedObjectData(window, ["smartcutConfig", "machining_pricing"]);
      variations = getNestedObjectData(window, ["smartcutConfig", "variations"]);
      cacheElements();
      cacheInputFields();
      configureProduct(window.smartcutConfig);
      configurePricing(window.smartcutConfig);
      initCheckout();
      configureStock();
      jQuery(".variations_form").on("reset_data", () => disableCutToSize(false, false));
      jQuery(".variations_form").on("found_variation", handleVariationFound);
      const elementsToHide = [
        "div.quantity > input.plus",
        "div.quantity > input.minus",
        "div.quantity .qty-plus",
        "div.quantity .qty-minus"
      ];
      elementsToHide.forEach((e) => {
        const element = document.querySelector(e);
        if (element) element.style.display = "none";
      });
      const event = new CustomEvent("smartcut/ready");
      window.dispatchEvent(event);
      log(["Wordpress checkout ready"]);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        unref(env) === "development" && showDevInfo ? (openBlock(), createElementBlock("div", _hoisted_1, [
          _cache[0] || (_cache[0] = createBaseVNode("div", null, "WP - developer information", -1)),
          createVNode(unref(ObjectViewer), {
            data: [unref(product)],
            paths: ["product"]
          }, null, 8, ["data"]),
          createVNode(unref(ObjectViewer), {
            data: [stock.value],
            paths: ["stock"]
          }, null, 8, ["data"]),
          createVNode(unref(ObjectViewer), {
            data: [extrasData],
            paths: ["extrasData"]
          }, null, 8, ["data"])
        ])) : createCommentVNode("", true),
        inputType.value === "formula" && formulaURL.value ? (openBlock(), createBlock(unref(FormulaPricing), {
          key: 1,
          ref: "formulapricing",
          units: smartcutConfigUnits.value,
          "format-price": formatPrice,
          url: formulaURL.value,
          debug: debug2.value,
          onHardwareResult: setHardwareResult,
          onPanelResult: disableAddToCart
        }, null, 8, ["units", "url", "debug"])) : createCommentVNode("", true),
        inputType.value === "manual" || inputType.value === "formula" && formulaURL.value ? (openBlock(), createBlock(CheckoutCalculator, {
          key: 2,
          ref_key: "calculator",
          ref: calculator,
          readonly: inputType.value === "formula",
          debug: debug2.value,
          stock: stock.value,
          "find-extras-price": findExtrasPrice,
          "format-price": formatPrice,
          units: smartcutConfigUnits.value,
          onLog: log,
          onError: error,
          onResult: result,
          onInputsChanged: disableAddToCart
        }, null, 8, ["readonly", "debug", "stock", "units"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Launch",
  props: {
    type: { default: "" }
  },
  setup(__props) {
    const Vanilla = defineAsyncComponent(() => import("./Vanilla-cZeTVB6U.js"));
    const components = {
      wordpress: _sfc_main$1,
      vanilla: Vanilla
    };
    const props = __props;
    const currentComponent = computed(() => {
      const componentKey = props.type.toLowerCase();
      return components[componentKey] || null;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(currentComponent.value), { ref: "checkout" }, null, 512);
    };
  }
});
const Launch = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _sfc_main
}, Symbol.toStringTag, { value: "Module" }));
export {
  CheckoutCalculator as C,
  InputField as I,
  Launch as L,
  _export_sfc as _,
  commonjsGlobal as a,
  _typeof as b,
  checkObjectPathExists as c,
  getDefaultExportFromCjs as d,
  d3 as e,
  convertUnit as f,
  getNestedObjectData as g,
  mainSides as h,
  hasMachining as i,
  getOptions as j,
  extrasValidation as k,
  _sfc_main$5 as l,
  mapLegacyInitData as m,
  setAllExtrasOptions as n,
  localeParseFloat as o,
  removeSingleExtra as r,
  setExtrasOption as s,
  userFriendlyFieldMap as u,
  valueSet as v
};
//# sourceMappingURL=Launch-CIMl3I9R.js.map
