var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
/**
* @vue/shared v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
var _a;
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map2[key] = 1;
  return (val) => val in map2;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove$1 = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$c = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$c.call(val, key);
const isArray$3 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$3 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$6 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$6(val) || isFunction$3(val)) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$3 = Object.prototype.toString;
const toTypeString$1 = (value2) => objectToString$3.call(value2);
const toRawType = (value2) => {
  return toTypeString$1(value2).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value2, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value: value2
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value2) {
  if (isArray$3(value2)) {
    const res = {};
    for (let i = 0; i < value2.length; i++) {
      const item = value2[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value2) || isObject$6(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$2(value2)) {
    res = value2;
  } else if (isArray$3(value2)) {
    for (let i = 0; i < value2.length; i++) {
      const normalized = normalizeClass(value2[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$6(value2)) {
    for (const name in value2) {
      if (value2[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
function looseCompareArrays(a2, b) {
  if (a2.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a2.length; i++) {
    equal = looseEqual(a2[i], b[i]);
  }
  return equal;
}
function looseEqual(a2, b) {
  if (a2 === b) return true;
  let aValidType = isDate$1(a2);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a2);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a2 === b;
  }
  aValidType = isArray$3(a2);
  bValidType = isArray$3(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b) : false;
  }
  aValidType = isObject$6(a2);
  bValidType = isObject$6(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$3(val) || isObject$6(val) && (val.toString === objectToString$3 || !isFunction$3(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol$1(val)) {
    return stringifySymbol(val);
  } else if (isObject$6(val) && !isArray$3(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a2;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
  );
};
/**
* @vue/reactivity v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= ~16;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  const dep = computed2.dep;
  computed2.flags |= 2;
  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
    computed2.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value2 = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value2, computed2._value)) {
      computed2._value = value2;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
  }
  if (!dep.subs && dep.computed) {
    dep.computed.flags &= ~4;
    for (let l = dep.computed.deps; l; l = l.nextDep) {
      removeSub(l, true);
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type3, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type3, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type3 === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$3(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type3) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array2) {
  const raw = toRaw(array2);
  if (raw === array2) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array2) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$3(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value2) => {
      value2[1] = toReactive(value2[1]);
      return value2;
    });
  },
  every(fn, thisArg) {
    return apply$3(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply$3(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply$3(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply$3(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply$3(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply$3(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply$3(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply$3(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce$1(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce$1(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply$3(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto$1 = Array.prototype;
function apply$3(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto$1[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce$1(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
function hasOwnProperty$b(key) {
  if (!isSymbol$1(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$3(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$b;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$6(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value2, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray$3(target) && isRef(oldValue) && !isRef(value2)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value2;
          return true;
        }
      }
    }
    const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(
      target,
      key,
      value2,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger(target, "set", key, value2);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$3(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value2) => value2;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value2, _isShallow = false) {
  if (!_isShallow && !isShallow(value2) && !isReadonly(value2)) {
    value2 = toRaw(value2);
  }
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value2);
  if (!hadKey) {
    target.add(value2);
    trigger(target, "add", value2, value2);
  }
  return this;
}
function set$1(key, value2, _isShallow = false) {
  if (!_isShallow && !isShallow(value2) && !isReadonly(value2)) {
    value2 = toRaw(value2);
  }
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get22.call(target, key);
  target.set(key, value2);
  if (!hadKey) {
    trigger(target, "add", key, value2);
  } else if (hasChanged(value2, oldValue)) {
    trigger(target, "set", key, value2);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get22 ? get22.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value2, key) => {
      return callback.call(thisArg, wrap(value2), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type3) {
  return function(...args) {
    return type3 === "delete" ? false : type3 === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add(value2) {
      return add.call(this, value2, true);
    },
    set(key, value2) {
      return set$1.call(this, key, value2, true);
    },
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$6(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return value2 ? !!value2["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  if (!hasOwn$1(value2, "__v_skip") && Object.isExtensible(value2)) {
    def(value2, "__v_skip", true);
  }
  return value2;
}
const toReactive = (value2) => isObject$6(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$6(value2) ? readonly(value2) : value2;
function isRef(r2) {
  return r2 ? r2["__v_isRef"] === true : false;
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value2 : toRaw(value2);
    this._value = isShallow2 ? value2 : toReactive(value2);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value2, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$3(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call: call2 } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$3(s)) {
        return call2 ? call2(s, 2) : s();
      } else ;
    });
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = call2 ? () => call2(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call2 ? call2(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope) {
      remove$1(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call2 ? call2(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call2) {
        call2(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value2, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$6(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value2)) {
    return value2;
  }
  seen.add(value2);
  depth--;
  if (isRef(value2)) {
    traverse(value2.value, depth, seen);
  } else if (isArray$3(value2)) {
    for (let i = 0; i < value2.length; i++) {
      traverse(value2[i], depth, seen);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject$1(value2)) {
    for (const key in value2) {
      traverse(value2[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value2)) {
      if (Object.prototype.propertyIsEnumerable.call(value2, key)) {
        traverse(value2[key], depth, seen);
      }
    }
  }
  return value2;
}
/**
* @vue/runtime-core v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a2) => {
          var _a2, _b;
          return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value2, raw) {
  if (isString$2(value2)) {
    value2 = JSON.stringify(value2);
    return raw ? value2 : [`${key}=${value2}`];
  } else if (typeof value2 === "number" || typeof value2 === "boolean" || value2 == null) {
    return raw ? value2 : [`${key}=${value2}`];
  } else if (isRef(value2)) {
    value2 = formatProp(key, toRaw(value2.value), true);
    return raw ? value2 : [`${key}=Ref<`, value2, `>`];
  } else if (isFunction$3(value2)) {
    return [`${key}=fn${value2.name ? `<${value2.name}>` : ``}`];
  } else {
    value2 = toRaw(value2);
    return raw ? value2 : [`${key}=`, value2];
  }
}
function callWithErrorHandling(fn, instance, type3, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type3);
  }
}
function callWithAsyncErrorHandling(fn, instance, type3, args) {
  if (isFunction$3(fn)) {
    const res = callWithErrorHandling(fn, instance, type3, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type3);
      });
    }
    return res;
  }
  if (isArray$3(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type3, args));
    }
    return values;
  }
}
function handleError(err, instance, type3, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type3}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type3, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type3, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end2 = queue.length;
  while (start < end2) {
    const middle = start + end2 >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end2 = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$3(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b) => getId(a2) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$3(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type3) => type3.__isTeleport;
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$3(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach(
      (r2, i) => setRef(
        r2,
        oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn$1(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$2(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$3(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value2;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value2;
          }
        } else if (_isRef) {
          ref3.value = value2;
          if (rawRef.k) refs[rawRef.k] = value2;
        } else ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const isComment = (node) => node.nodeType === 8;
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction$3(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          hydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded2 = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded2.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded2.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded2.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref22, props, children: children2, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children2);
  vnode.ref = ref22;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type3, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type3, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type3, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type3, target, keepAliveRoot) {
  const injected = injectHook(
    type3,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type3], injected);
  }, target);
}
function injectHook(type3, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type3] || (target[type3] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type3, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type3, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type3] || Component[type3], name) || // global registration
      resolve(instance.appContext[type3], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2;
  const sourceIsArray = isArray$3(source);
  if (sourceIsArray || isString$2(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$6(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick$1.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type: type3, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type3.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value2) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value2;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$3(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$3(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$6(data)) ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get3 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set3 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get3,
        set: set3
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$6(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type3) {
  callWithAsyncErrorHandling(
    isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type3
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$3(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$3(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$6(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$6(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$3(to) ? to.call(this, this) : to,
      isFunction$3(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$3(to) && isArray$3(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$6(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$3(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$3(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else ;
        return app2;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace2) {
        if (!isMounted) {
          const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace2 === true) {
            namespace2 = "svg";
          } else if (namespace2 === false) {
            namespace2 = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, namespace2);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app2._instance,
            16
          );
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context.provides[key] = value2;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value2) {
  if (!currentInstance) ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value2,
              instance,
              false
            );
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value2 = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value2);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$6(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$3(opt) ? { type: opt } : extend$1({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$3(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type3 = propType[index];
            const typeName = isFunction$3(type3) && type3.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$3(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn$1(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$6(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value2) => isArray$3(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value2 = rawSlots[key];
    if (isFunction$3(value2)) {
      slots[key] = normalizeSlot(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children2) => {
  const normalized = normalizeSlotValue(children2);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children2, optimized) => {
  for (const key in children2) {
    if (optimized || key !== "_") {
      slots[key] = children2[key];
    }
  }
};
const initSlots = (instance, children2, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type3 = children2._;
    if (type3) {
      assignSlots(slots, children2, optimized);
      if (optimized) {
        def(slots, "_", type3, true);
      }
    } else {
      normalizeObjectSlots(children2, slots);
    }
  } else if (children2) {
    normalizeVNodeSlots(instance, children2);
  }
};
const updateSlots = (instance, children2, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type3 = children2._;
    if (type3) {
      if (optimized && type3 === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children2, optimized);
      }
    } else {
      needDeletionCheck = !children2.$stable;
      normalizeObjectSlots(children2, slots);
    }
    deletionComparisonTarget = children2;
  } else if (children2) {
    normalizeVNodeSlots(instance, children2);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type3, ref: ref3, shapeFlag } = n2;
    switch (type3) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace2);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type3.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type3.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace2) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace2,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace2 = "svg";
    } else if (n2.type === "math") {
      namespace2 = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace2,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace2),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace2, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace2);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children2.length; i++) {
      const child = children2[i] = optimized ? cloneIfMounted(children2[i]) : normalizeVNode(children2[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace2),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace2),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace2);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace2);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace2, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace2);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace2) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace2,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace2, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace2,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace2,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root: root2, type: type3 } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type3.__asyncHydrate) {
            type3.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root2.ce) {
            root2.ce._injectChildStyle(type3);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace2
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace2
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace2,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e22 = l2 - 1;
    while (i <= e1 && i <= e22) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e22) {
      const n1 = c1[e1];
      const n2 = c2[e22] = optimized ? cloneIfMounted(c2[e22]) : normalizeVNode(c2[e22]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e22--;
    }
    if (i > e1) {
      if (i <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e22) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e22) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e22; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e22 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e22; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type3, transition, children: children2, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type3.move(vnode, container, anchor, internals);
      return;
    }
    if (type3 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children2.length; i++) {
        move(children2[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type3 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type: type3,
      props,
      ref: ref3,
      children: children2,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type3 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type3 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children2, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type3, el, anchor, transition } = vnode;
    if (type3 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type3 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end2) => {
    let next;
    while (cur !== end2) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end2);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a: a2 } = instance;
    invalidateMount(m);
    invalidateMount(a2);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children2.length; i++) {
      unmount(children2[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render2 = (vnode, container, namespace2) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace2
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function resolveChildrenNamespace({ type: type3, props }, currentNamespace) {
  return currentNamespace === "svg" && type3 === "foreignObject" || currentNamespace === "mathml" && type3 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c2 = u + v >> 1;
        if (arr[result[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend$1({}, options);
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!cb || immediate) {
      baseWatchOptions.once = true;
    } else {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type3, args) => callWithAsyncErrorHandling(fn, instance, type3, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (ssrCleanup) ssrCleanup.push(watchHandle);
  return watchHandle;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a2) => isString$2(a2) ? a2.trim() : a2);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$6(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$6(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false) ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root2 = cloneVNode(root2, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2, null, false, true);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root2, vnode.transition);
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root2 = parent.subTree;
    if (root2.suspense && root2.suspense.activeBranch === vnode) {
      root2.el = vnode.el;
    }
    if (root2 === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type3) => type3.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2) {
  isBlockTreeEnabled += value2;
  if (value2 < 0 && currentBlock) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type3, props, children2, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type3,
      props,
      children2,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type3, props, children2, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type3,
      props,
      children2,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type3, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type3 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type3,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: children2,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children2);
    if (shapeFlag & 128) {
      type3.normalize(vnode);
    }
  } else if (children2) {
    vnode.shapeFlag |= isString$2(children2) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type3, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type3 || type3 === NULL_DYNAMIC_COMPONENT) {
    type3 = Comment;
  }
  if (isVNode$1(type3)) {
    const cloned = cloneVNode(
      type3,
      props,
      true
      /* mergeRef: true */
    );
    if (children2) {
      normalizeChildren(cloned, children2);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type3)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type3)) {
    type3 = type3.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$6(style)) {
      if (isProxy(style) && !isArray$3(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type3) ? 1 : isSuspense(type3) ? 128 : isTeleport(type3) ? 64 : isObject$6(type3) ? 4 : isFunction$3(type3) ? 2 : 0;
  return createBaseVNode(
    type3,
    props,
    children2,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children: children2, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$3(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children2,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag3 = 0) {
  return createVNode(Text, null, text, flag3);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$1(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children2) {
  let type3 = 0;
  const { shapeFlag } = vnode;
  if (children2 == null) {
    children2 = null;
  } else if (isArray$3(children2)) {
    type3 = 16;
  } else if (typeof children2 === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children2.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type3 = 32;
      const slotFlag = children2._;
      if (!slotFlag && !isInternalObject(children2)) {
        children2._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children2._ = 1;
        } else {
          children2._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children2)) {
    children2 = { default: children2, _ctx: currentRenderingInstance };
    type3 = 32;
  } else {
    children2 = String(children2);
    if (shapeFlag & 64) {
      type3 = 16;
      children2 = [createTextVNode(children2)];
    } else {
      type3 = 8;
    }
  }
  vnode.children = children2;
  vnode.shapeFlag |= type3;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type3 = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type: type3,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type3, appContext),
    emitsOptions: normalizeEmitsOptions(type3, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type3.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set3) => set3(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children: children2 } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children2, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup: setup3 } = Component;
  if (setup3) {
    const setupContext = instance.setupContext = setup3.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup3,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$1(setupResult)) {
      if (!isAsyncWrapper(instance)) markAsyncBoundary(instance);
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$6(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value2) {
  return isFunction$3(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h(type3, propsOrChildren, children2) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$6(propsOrChildren) && !isArray$3(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type3, null, [propsOrChildren]);
      }
      return createVNode(type3, propsOrChildren);
    } else {
      return createVNode(type3, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children2 = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children2)) {
      children2 = [children2];
    }
    return createVNode(type3, propsOrChildren, children2);
  }
}
const version = "3.5.11";
/**
* @vue/runtime-dom v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace2, is, props) => {
    const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector2) => doc.querySelector(selector2),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace2, start, end2) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end2 || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end2 || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace2 === "svg" || namespace2 === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const vtcKey = Symbol("_vtc");
function patchClass(el, value2, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value: value2 }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value2) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value2);
    }
  },
  mounted(el, { value: value2 }, { transition }) {
    if (transition && value2) {
      transition.enter(el);
    }
  },
  updated(el, { value: value2, oldValue }, { transition }) {
    if (!value2 === !oldValue) return;
    if (transition) {
      if (value2) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value2);
    }
  },
  beforeUnmount(el, { value: value2 }) {
    setDisplay(el, value2);
  }
};
function setDisplay(el, value2) {
  el.style.display = value2 ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value2;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$2(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$2(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$3(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes$2 = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes$2.length; i++) {
    const prefixed = prefixes$2[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol$1(value2) ? String(value2) : value2
      );
    }
  }
}
function patchDOMProp(el, key, value2, parentComponent) {
  if (key === "innerHTML" || key === "textContent") {
    if (value2 != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value2) : value2;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value2 == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value2);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    el._value = value2;
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type3 = typeof el[key];
    if (type3 === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type3 === "string") {
      value2 = "";
      needRemove = true;
    } else if (type3 === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value2) {
  if (isArray$3(value2)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value2.map(
      (fn) => (e22) => !e22._stopped && fn && fn(e22)
    );
  } else {
    return value2;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace2, parentComponent) => {
  const isSVG = namespace2 === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$2(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value2, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$3(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$2(value2)) {
    return false;
  }
  return key in el;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$3(fn) ? (value2) => invokeArrayFns(fn, value2) : fn;
};
const assignKey = Symbol("_assign");
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value: value2, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value2);
    addEventListener$1(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map(
        (o2) => number2 ? looseToNumber(getValue$2(o2)) : getValue$2(o2)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick$1(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value: value2 }) {
    setSelected(el, value2);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value: value2 }) {
    if (!el._assigning) {
      setSelected(el, value2);
    }
  }
};
function setSelected(el, value2) {
  const isMultiple = el.multiple;
  const isArrayValue = isArray$3(value2);
  if (isMultiple && !isArrayValue && !isSet(value2)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue$2(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value2.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value2, optionValue) > -1;
        }
      } else {
        option.selected = value2.has(optionValue);
      }
    } else if (looseEqual(getValue$2(option), value2)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue$2(el) {
  return "_value" in el ? el._value : el.value;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
/*!
  * shared v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale2, key, source) => friendlyJSONstringify({ l: locale2, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp$1 = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$2 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty$a = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty$a.call(obj, key);
}
const isArray$2 = Array.isArray;
const isFunction$2 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$5 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$5(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString = (value2) => objectToString$2.call(value2);
const isPlainObject = (val) => {
  if (!isObject$5(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray$2(val) || isPlainObject(val) && val.toString === objectToString$2 ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const isNotObjectOrIsArray = (val) => !isObject$5(val) || isArray$2(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isObject$5(src2[key]) && !isObject$5(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : {};
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end2, source) {
  const loc = { start, end: end2 };
  return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$2(message, ...args) {
  if (args.length === 1 && isObject$4(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign$1 = Object.assign;
const isString = (val) => typeof val === "string";
const isObject$4 = (val) => val !== null && typeof val === "object";
function join(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$2(warnMessages[code2], ...args || []);
  const message = { message: String(msg), code: code2 };
  if (loc) {
    message.location = loc;
  }
  return message;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages: messages2, args } = options;
  const msg = format$2((messages2 || errorMessages)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type3, value2) {
    context2.endLoc = currentPosition();
    context2.currentType = type3;
    const token = { type: type3 };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value2 != null) {
      token.value = value2;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value2 = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value2 += `-${getDigits(scnr)}`;
    } else {
      value2 += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value2;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code2, start, offset, ...args) {
    const end2 = tokenzer.currentPosition();
    end2.offset += offset;
    end2.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start, end2) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code2, start, offset, ...args) {
    const end2 = tokenzer.currentPosition();
    end2.offset += offset;
    end2.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start, end2) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  function startNode(type3, offset, loc) {
    const node = { type: type3 };
    if (location2) {
      node.start = offset;
      node.end = offset;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type3) {
    if (location2) {
      node.end = offset;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value2) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value2;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value2.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value2) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value2;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign$1({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer2) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer2);
  }
}
function traverseNode(node, transformer2) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer2);
      transformer2.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer2);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer2);
      transformer2.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer2.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer2.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer2.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer2.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer2.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer2 = createTransformer(ast);
  transformer2.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer2);
  const context = transformer2.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c2) => optimizeMessageNode(c2));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join(values);
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named2 = node;
      named2.k = named2.key;
      delete named2.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const location2 = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code2, node) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length2 = node.items.length;
  for (let i = 0; i < length2; i++) {
    generateNode(generator, node.items[i]);
    if (i === length2 - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length2 = node.cases.length;
    for (let i = 0; i < length2; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length2 - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
const generate = (ast, options = {}) => {
  const mode = isString(options.mode) ? options.mode : "normal";
  const filename = isString(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map: map2 } = generator.context();
  return {
    ast,
    code: code2,
    map: map2 ? map2.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options = {}) {
  const assignedOptions = assign$1({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser2 = createParser(assignedOptions);
  const ast = parser2.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a2 = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a2 === b && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path2) {
  const trimmed = path2.trim();
  if (path2.charAt(0) === "0" && isNaN(parseInt(path2))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse$4(path2) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c2;
  let key;
  let newChar;
  let type3;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path2[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c2 = path2[index];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type3 = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type3] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c2;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache$1 = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path2) {
  return isObject$5(obj) ? obj[path2] : null;
}
function resolveValue(obj, path2) {
  if (!isObject$5(obj)) {
    return null;
  }
  let hit = cache$1.get(path2);
  if (!hit) {
    hit = parse$4(path2);
    if (hit) {
      cache$1.set(path2, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    if (isFunction$2(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale2 = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$5(options.pluralRules) && isString$1(locale2) && isFunction$2(options.pluralRules[locale2]) ? options.pluralRules[locale2] : pluralDefault;
  const orgPluralRule = isObject$5(options.pluralRules) && isString$1(locale2) && isFunction$2(options.pluralRules[locale2]) ? pluralDefault : void 0;
  const plural = (messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || {};
  isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named2 = (key) => _named[key];
  function message(key) {
    const msg = isFunction$2(options.messages) ? options.messages(key) : isObject$5(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize2 = isPlainObject(options.processor) && isFunction$2(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate2 = isPlainObject(options.processor) && isFunction$2(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type3 = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type22 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$5(arg1)) {
        modifier = arg1.modifier || modifier;
        type22 = arg1.type || type22;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type22 = arg2 || type22;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type22 === "vnode" && isArray$2(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type22) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named2,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type3,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate2,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize2,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$2({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale2) {
  if (isString$1(locale2)) {
    return locale2;
  } else {
    if (isFunction$2(locale2)) {
      if (locale2.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale2.constructor.name === "Function") {
        const resolve2 = locale2();
        if (isPromise(resolve2)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve2;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray$2(fallback) ? fallback : isObject$5(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray$2(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults2 = isArray$2(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults2) ? [defaults2] : defaults2;
    if (isArray$2(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale2 = block[i];
    if (isString$1(locale2)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale2, blocks) {
  let follow;
  const tokens = locale2.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale2 = target.replace(/!/g, "");
      chain.push(locale2);
      if ((isArray$2(blocks) || isPlainObject(blocks)) && blocks[locale2]) {
        follow = blocks[locale2];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.14.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type3) => {
      return type3 === "text" && isString$1(val) ? val.toUpperCase() : type3 === "vnode" && isObject$5(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type3) => {
      return type3 === "text" && isString$1(val) ? val.toLowerCase() : type3 === "vnode" && isObject$5(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type3) => {
      return type3 === "text" && isString$1(val) ? capitalize(val) : type3 === "vnode" && isObject$5(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction$2(options.onWarn) ? options.onWarn : warn;
  const version2 = isString$1(options.version) ? options.version : VERSION$1;
  const locale2 = isString$1(options.locale) || isFunction$2(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction$2(locale2) ? DEFAULT_LOCALE : locale2;
  const fallbackLocale = isArray$2(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages2 = isPlainObject(options.messages) ? options.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
  const modifiers = assign$2({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction$2(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp$1(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp$1(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction$2(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction$2(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction$2(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$2(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$5(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$5(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$5(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$5(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale: locale2,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key, locale2, missingWarn, type3) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale2, key, type3);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale2, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale2);
}
function isAlmostSameLocale(locale2, compareLocale) {
  if (locale2 === compareLocale)
    return false;
  return locale2.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i = index + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format$1(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages2, c2) => [
      ...messages2,
      formatMessageParts(ctx, c2)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const _static = node.s || node.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages2 = (node.i || node.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
    return ctx.normalize(messages2);
  }
}
function formatMessagePart(ctx, node) {
  const type3 = node.t || node.type;
  switch (type3) {
    case 3: {
      const text = node;
      return text.v || text.value;
    }
    case 9: {
      const literal = node;
      return literal.v || literal.value;
    }
    case 4: {
      const named2 = node;
      return ctx.interpolate(ctx.named(named2.k || named2.key));
    }
    case 5: {
      const list = node;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type3}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = /* @__PURE__ */ Object.create(null);
const isMessageAST = (val) => isObject$5(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options), detectError };
}
function compile(message, context) {
  if (isString$1(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format$1(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format$1(message);
    } else {
      return format$1(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction$2(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale2 = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale2,
    messages2[locale2] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$2({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray$2(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$5(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale2);
  let message = {};
  let targetLocale;
  let format2 = null;
  const type3 = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages2[targetLocale] || {};
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type3
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$1(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray$2(arg2)) {
    options.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$2(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale2, key, source, warnHtmlMessage, onError) {
  return {
    locale: locale2,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale2, key, source2)
  };
}
function getMessageContextOptions(context, locale2, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale2, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale2, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale: locale2,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber$1(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value2, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale2 = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale2, overrides).format(value2);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type3 = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type3);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value2) : formatter.formatToParts(value2);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value2;
  if (isString$1(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value2 = new Date(dateTime);
    try {
      value2.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value2 = arg1;
  } else if (isNumber$1(arg1)) {
    value2 = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value2, options, overrides];
}
function clearDateTimeFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale2}__${key}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number$3(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value2, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale2 = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale2
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale2, overrides).format(value2);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type3 = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type3);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value2) : formatter.formatToParts(value2);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value2 = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value2, options, overrides];
}
function clearNumberFormat(ctx, locale2, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale2}__${key}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.14.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.14.1";
function initFeatureFlags() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$5(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$5(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        if (!isObject$5(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$5(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale2, options) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages2) ? messages2 : isArray$2(__i18n) ? {} : { [locale2]: {} };
  if (isArray$2(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale22, resource } = custom;
        if (locale22) {
          ret[locale22] = ret[locale22] || {};
          deepCopy(resource, ret[locale22]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages2 = isObject$5(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale2) => {
      gl.mergeLocaleMessage(locale2, messages2[locale2]);
    });
  }
  {
    if (isObject$5(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeDateTimeFormat(locale2, options.datetimeFormats[locale2]);
        });
      }
    }
    if (isObject$5(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale2) => {
          gl.mergeNumberFormat(locale2, options.numberFormats[locale2]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale2, key, type3) => {
    return missing(locale2, key, getCurrentInstance() || void 0, type3);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray$2(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp$1(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp$1(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction$2(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction$2(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction$2(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale2 = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$2(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t2(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$5(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number$3, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize2(values) {
    return values.map((val) => isString$1(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate2 = (val) => val;
  const processor = {
    normalize: normalize2,
    interpolate: interpolate2,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root2) => root2[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray$2(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number$3, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root2) => root2[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray$2(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root2) => root2[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray$2(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale22) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale22) ? locale22 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root2) => {
      return Reflect.apply(root2.te, root2, [key, locale22]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages22 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages22 = messageValue;
        break;
      }
    }
    return messages22;
  }
  function tm(key) {
    const messages22 = resolveMessages(key);
    return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale22) {
    return _messages.value[locale22] || {};
  }
  function setLocaleMessage(locale22, message) {
    if (flatJson) {
      const _message = { [locale22]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale22];
    }
    _messages.value[locale22] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale22, message) {
    _messages.value[locale22] = _messages.value[locale22] || {};
    const _message = { [locale22]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale22];
    deepCopy(message, _messages.value[locale22]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale22) {
    return _datetimeFormats.value[locale22] || {};
  }
  function setDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  function mergeDateTimeFormat(locale22, format2) {
    _datetimeFormats.value[locale22] = assign$2(_datetimeFormats.value[locale22] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale22, format2);
  }
  function getNumberFormat(locale22) {
    return _numberFormats.value[locale22] || {};
  }
  function setNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  function mergeNumberFormat(locale22, format2) {
    _numberFormats.value[locale22] = assign$2(_numberFormats.value[locale22] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale22, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale: locale2,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$2({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber$1(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children2 = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$2({}, attrs);
      const tag = isString$1(props.tag) || isObject$5(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children2);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray$2(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$5(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$2({}, options2, { [prop]: props.format[prop] }) : options2;
      }, {});
    }
    const parts2 = partFormatter(...[props.value, options, overrides]);
    let children2 = [options.key];
    if (isArray$2(parts2)) {
      children2 = parts2.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts: parts2 }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts2)) {
      children2 = [parts2];
    }
    const assignedAttrs = assign$2({}, attrs);
    const tag = isString$1(props.tag) || isObject$5(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children2);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$2({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$2({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance, modifiers, value: value2 } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    const parsedValue = parseValue(value2);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value: value2 }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value2);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value2) {
  if (isString$1(value2)) {
    return { path: value2 };
  } else if (isPlainObject(value2)) {
    if (!("path" in value2)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value2;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value2) {
  const { path: path2, locale: locale2, args, choice, plural } = value2;
  const options = {};
  const named2 = args || {};
  if (isString$1(locale2)) {
    options.locale = locale2;
  }
  if (isNumber$1(choice)) {
    options.plural = choice;
  }
  if (isNumber$1(plural)) {
    options.plural = plural;
  }
  return [path2, named2, options];
}
function apply$2(app2, i18n2, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options2) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (__globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        {
          apply$2(app2, i18n2, ...options2);
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$2({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root2 = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    }
    if (composer != null) {
      break;
    }
    if (root2 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n2, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
{
  registerMessageCompiler(compile);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const en_US = {
  length: "Length",
  l: "L",
  width: "Width",
  w: "W",
  thickness: "Thickness",
  t: "T",
  name: "Name",
  quantity: "Quantity",
  q: "Q",
  material: "Material",
  orientation: "Orientation",
  machining: "Machining",
  grain: "Grain",
  "add part": "Add part",
  "remove part": "Remove part",
  calculate: "Calculate",
  "full screen": "Full screen",
  banding: "Banding",
  "delete banding": "Delete banding",
  select: "Select",
  "delete": "Delete",
  clear: "Clear",
  l1: "L1",
  l2: "L2",
  w1: "W1",
  w2: "W2",
  all: "All",
  "Drop CSV file here": "Drop CSV file here",
  "Powered by SmartCut": "Powered by SmartCut",
  Part: "Part",
  Issue: "Issue",
  "Part issue": "Part issue",
  "Issue with part inputs:": "Issue with part inputs:",
  "No parts": "No parts",
  "No parts in list": "No parts in list",
  "No quantity of parts found": "No quantity of parts found",
  "No parts were added - please double check your list": "No parts were added - please double check your list",
  "The following parts did not fit": "The following parts did not fit",
  "The maximum number of parts is": "The maximum number of parts is",
  "No valid parts found": "No valid parts found"
};
const ca = {
  length: "Llarg",
  l: "L",
  width: "Ample",
  w: "A",
  thickness: "Gruix",
  t: "G",
  name: "Nom",
  quantity: "Quantitat",
  q: "Q",
  machining: "Mecanitzat",
  orientation: "Gir",
  "add part": "Afegeix",
  "remove part": "Elimina",
  calculate: "Calcula",
  "full screen": "Pantalla completa",
  banding: "Cantell",
  "delete banding": "Elimina cantell",
  "delete": "Elimina",
  clear: "Neteja",
  l1: "L1",
  l2: "L2",
  w1: "A1",
  w2: "A1",
  all: "Todos",
  Part: "Pea",
  Issue: "Tema",
  "The following parts did not fit": "Les peces segents no encaixaven",
  "The maximum number of parts is": "El nmero mxim de peces s",
  "No valid parts found": "No s'han trobat peces vlides",
  "Drop CSV file here": "No s'han trobat peces vlides",
  "Powered by SmartCut": "Desenvolupat per SmartCut"
};
const es_ES = {
  length: "Largo",
  l: "L",
  width: "Ancho",
  w: "A",
  thickness: "Grueso",
  t: "G",
  name: "Nombre",
  quantity: "Cantidad",
  q: "C",
  machining: "Mecanizado",
  orientation: "Giro",
  "add part": "Aade",
  "remove part": "Elimina",
  calculate: "Calcula",
  "full screen": "Pantalla completa",
  banding: "Canto",
  "delete banding": "Elimina canto",
  "delete": "Elimina",
  clear: "Borra",
  l1: "L1",
  l2: "L2",
  w1: "A1",
  w2: "A1",
  all: "Todos",
  Part: "Pieza",
  Issue: "Tema",
  "The following parts did not fit": "Las siguientes piezas no encajaban",
  "The maximum number of parts is": "El nmero mximo de piezas es",
  "No valid parts found": "No se encontraron piezas vlidas",
  "Drop CSV file here": "Carga el archivo CSV aqu",
  "Powered by SmartCut": "Desarrollado por SmartCut"
};
const fr_FR = {
  length: "Longueur",
  l: "L",
  width: "Largeur",
  w: "la",
  thickness: "Epaisseur",
  t: "ep",
  name: "Nom",
  quantity: "Quantit",
  q: "Qt",
  material: "Matriel",
  machining: "Machinage",
  grain: "Sens de fil",
  orientation: "Orientation",
  "add part": "Ajouter pice",
  "remove part": "Supprimer pice",
  calculate: "Optimiser",
  "full screen": "Plein cran",
  banding: "Chants",
  "delete banding": "Supprimer chants",
  select: "Slectionner",
  "delete": "Supprimer",
  clear: "Effacer",
  l1: "L1",
  l2: "L2",
  w1: "la1",
  w2: "la2",
  "Powered by SmartCut": "",
  Part: "Pice",
  "Drop CSV file here": "Tlcharger CSV",
  Issue: "Erreur",
  "Part issue": "Pice erreur",
  "Issue with part inputs": "Erreur avec l'importation de pices",
  "No parts": "Aucune pice",
  "No parts in list": "Aucune pice dans la liste",
  "No quantity of parts found": "Aucune quantit trouv pour certaines pices",
  "No parts were added - please double check your list": "Aucune pice n'a t ajoute - veuillez vrifier votre liste",
  "The following parts did not fit": "Les pices suivantes ne s'adaptent pas",
  "The maximum number of parts is": "Le nombre maximum de pices est",
  "No valid parts found": "Aucune pice valide trouve"
};
const messages = {
  en_US,
  ca,
  es_ES,
  fr_FR
};
var freeGlobal$1 = typeof global == "object" && global && global.Object === Object && global;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal$1 || freeSelf$1 || Function("return this")();
var Symbol$3 = root$2.Symbol;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$3 = objectProto$c.toString;
var symToStringTag$3 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$3), tag = value2[symToStringTag$3];
  try {
    value2[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$3.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$3] = tag;
    } else {
      delete value2[symToStringTag$3];
    }
  }
  return result;
}
var objectProto$b = Object.prototype;
var nativeObjectToString$2 = objectProto$b.toString;
function objectToString$1(value2) {
  return nativeObjectToString$2.call(value2);
}
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$1(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value2) ? getRawTag$1(value2) : objectToString$1(value2);
}
function isObjectLike$1(value2) {
  return value2 != null && typeof value2 == "object";
}
var symbolTag = "[object Symbol]";
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike$1(value2) && baseGetTag$1(value2) == symbolTag;
}
function arrayMap(array2, iteratee) {
  var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array2[index], index, array2);
  }
  return result;
}
var isArray$1 = Array.isArray;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray$1(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$1 ? "-0" : result;
}
function isObject$3(value2) {
  var type3 = typeof value2;
  return value2 != null && (type3 == "object" || type3 == "function");
}
var asyncTag$1 = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$1(value2) {
  if (!isObject$3(value2)) {
    return false;
  }
  var tag = baseGetTag$1(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
}
var coreJsData$1 = root$2["__core-js_shared__"];
var maskSrcKey$1 = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$3 = Function.prototype;
var funcToString$3 = funcProto$3.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$2 = Function.prototype, objectProto$a = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$8).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value2) {
  if (!isObject$3(value2) || isMasked$1(value2)) {
    return false;
  }
  var pattern = isFunction$1(value2) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value2));
}
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative$1(object2, key) {
  var value2 = getValue$1(object2, key);
  return baseIsNative$1(value2) ? value2 : void 0;
}
var defineProperty$1 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value2, length2) {
  var type3 = typeof value2;
  length2 = length2 == null ? MAX_SAFE_INTEGER$2 : length2;
  return !!length2 && (type3 == "number" || type3 != "symbol" && reIsUint$1.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
}
function baseAssignValue(object2, key, value2) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object2[key] = value2;
  }
}
function eq$1(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function assignValue(object2, key, value2) {
  var objValue = object2[key];
  if (!(hasOwnProperty$7.call(object2, key) && eq$1(objValue, value2)) || value2 === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value2);
  }
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value2, object2) {
  if (isArray$1(value2)) {
    return false;
  }
  var type3 = typeof value2;
  if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value2 == null || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
}
var nativeCreate = getNative$1(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
function Hash(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array2, key) {
  var length2 = array2.length;
  while (length2--) {
    if (eq$1(array2[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative$1(root$2, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type3 = typeof value2;
  return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value2);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
function toString$3(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function castPath(value2, object2) {
  if (isArray$1(value2)) {
    return value2;
  }
  return isKey(value2, object2) ? [value2] : stringToPath(toString$3(value2));
}
var INFINITY = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function baseGet(object2, path2) {
  path2 = castPath(path2, object2);
  var index = 0, length2 = path2.length;
  while (object2 != null && index < length2) {
    object2 = object2[toKey(path2[index++])];
  }
  return index && index == length2 ? object2 : void 0;
}
function get(object2, path2, defaultValue) {
  var result = object2 == null ? void 0 : baseGet(object2, path2);
  return result === void 0 ? defaultValue : result;
}
function baseSet(object2, path2, value2, customizer) {
  if (!isObject$3(object2)) {
    return object2;
  }
  path2 = castPath(path2, object2);
  var index = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
  while (nested != null && ++index < length2) {
    var key = toKey(path2[index]), newValue = value2;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object2;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = void 0;
      if (newValue === void 0) {
        newValue = isObject$3(objValue) ? objValue : isIndex$1(path2[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object2;
}
function set(object2, path2, value2) {
  return object2 == null ? object2 : baseSet(object2, path2, value2);
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace$1(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace$1(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function") select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
function empty$1() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function") select2 = arrayAll(select2);
  else select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$3(x) {
  return function() {
    return x;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value2, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value2 !== "function") value2 = constant$3(value2);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value2.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare2) {
  if (!compare2) compare2 = ascending$1;
  function compareNode(a2, b) {
    return a2 && b ? compare2(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending$1(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node of this) ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value2) {
  return function() {
    this.setAttribute(name, value2);
  };
}
function attrConstantNS(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value2) {
  var fullname = namespace$1(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value2 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value2));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value2, priority) {
  return function() {
    this.style.setProperty(name, value2, priority);
  };
}
function styleFunction(name, value2, priority) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove : typeof value2 === "function" ? styleFunction : styleConstant)(name, value2, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value2) {
  return function() {
    this[name] = value2;
  };
}
function propertyFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function selection_property(name, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
}
function classArray$1(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList$1(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray$1(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList$1(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList$1(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value2) {
  var names = classArray$1(name + "");
  if (arguments.length < 2) {
    var list = classList$1(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}
function textRemove() {
  this.textContent = "";
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction : textConstant)(value2)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}
function contextListener(listener2) {
  return function(event) {
    listener2.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i = t2.indexOf(".");
    if (i >= 0) name = t2.slice(i + 1), t2 = t2.slice(0, i);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2) return;
    for (var j = 0, i = -1, m = on2.length, o2; j < m; ++j) {
      if (o2 = on2[j], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on2[++i] = o2;
      }
    }
    if (++i) on2.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value2, options) {
  return function() {
    var on2 = this.__on, o2, listener2 = contextListener(value2);
    if (on2) for (var j = 0, m = on2.length; j < m; ++j) {
      if ((o2 = on2[j]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener2, o2.options = options);
        o2.value = value2;
        return;
      }
    }
    this.addEventListener(typename.type, listener2, options);
    o2 = { type: typename.type, name: typename.name, value: value2, listener: listener2, options };
    if (!on2) this.__on = [o2];
    else on2.push(o2);
  };
}
function selection_on(typename, value2, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t2;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) for (var j = 0, m = on2.length, o2; j < m; ++j) {
      for (i = 0, o2 = on2[j]; i < n; ++i) {
        if ((t2 = typenames[i]).type === o2.type && t2.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on2 = value2 ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on2(typenames[i], value2, options));
  return this;
}
function dispatchEvent(node, type3, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type3, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type3, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type3, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params);
  };
}
function dispatchFunction(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params.apply(this, arguments));
  };
}
function selection_dispatch(type3, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type3, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}
var root$1 = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection_selection() {
  return this;
}
Selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root$1);
}
function selectAll(selector2) {
  return typeof selector2 === "string" ? new Selection([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection([array(selector2)], root$1);
}
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left2(a2, x, lo2 = 0, hi = a2.length) {
    if (lo2 < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = lo2 + hi >>> 1;
        if (compare2(a2[mid], x) < 0) lo2 = mid + 1;
        else hi = mid;
      } while (lo2 < hi);
    }
    return lo2;
  }
  function right2(a2, x, lo2 = 0, hi = a2.length) {
    if (lo2 < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = lo2 + hi >>> 1;
        if (compare2(a2[mid], x) <= 0) lo2 = mid + 1;
        else hi = mid;
      } while (lo2 < hi);
    }
    return lo2;
  }
  function center2(a2, x, lo2 = 0, hi = a2.length) {
    const i = left2(a2, x, lo2, hi - 1);
    return i > lo2 && delta(a2[i - 1], x) > -delta(a2[i], x) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$1() {
  return 0;
}
function number$2(x) {
  return x === null ? NaN : +x;
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc2;
  if (power < 0) {
    inc2 = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc2);
    i2 = Math.round(stop * inc2);
    if (i1 / inc2 < start) ++i1;
    if (i2 / inc2 > stop) --i2;
    inc2 = -inc2;
  } else {
    inc2 = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc2);
    i2 = Math.round(stop / inc2);
    if (i1 * inc2 < start) ++i1;
    if (i2 * inc2 > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc2];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc2] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc2;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc2;
  } else {
    if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc2;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc2;
  }
  return ticks2;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc2 = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
}
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b, a2) {
  if (a2 <= 0) r2 = g = b = NaN;
  return new Rgb(r2, g, b, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb$1(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex$1(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h2, s, l, a2) {
  if (a2 <= 0) h2 = s = l = NaN;
  else if (l <= 0 || l >= 1) h2 = s = NaN;
  else if (s <= 0) h2 = NaN;
  return new Hsl(h2, s, l, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g = o2.g / 255, b = o2.b / 255, min2 = Math.min(r2, g, b), max2 = Math.max(r2, g, b), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r2 === max2) h2 = (g - b) / s + (g < b) * 6;
    else if (g === max2) h2 = (b - r2) / s + 2;
    else h2 = (r2 - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s, l, o2.opacity);
}
function hsl(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$2 = (x) => () => x;
function linear$1(a2, d) {
  return function(t2) {
    return a2 + t2 * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant$2(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear$1(a2, d) : constant$2(isNaN(a2) ? b : a2);
}
const rgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end2) {
    var r2 = color2((start = rgb$1(start)).r, (end2 = rgb$1(end2)).r), g = color2(start.g, end2.g), b = color2(start.b, end2.b), opacity = nogamma(start.opacity, end2.opacity);
    return function(t2) {
      start.r = r2(t2);
      start.g = g(t2);
      start.b = b(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a2, b) {
  if (!b) b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t2) {
    for (i = 0; i < n; ++i) c2[i] = a2[i] * (1 - t2) + b[i] * t2;
    return c2;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i) x[i] = interpolate(a2[i], b[i]);
  for (; i < nb; ++i) c2[i] = b[i];
  return function(t2) {
    for (i = 0; i < na; ++i) c2[i] = x[i](t2);
    return c2;
  };
}
function date(a2, b) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t2) {
    return d.setTime(a2 * (1 - t2) + b * t2), d;
  };
}
function interpolateNumber(a2, b) {
  return a2 = +a2, b = +b, function(t2) {
    return a2 * (1 - t2) + b * t2;
  };
}
function object(a2, b) {
  var i = {}, c2 = {}, k;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a2) {
      i[k] = interpolate(a2[k], b[k]);
    } else {
      c2[k] = b[k];
    }
  }
  return function(t2) {
    for (k in i) c2[k] = i[k](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t2) {
    return b(t2) + "";
  };
}
function string(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t2) {
    for (var i2 = 0, o2; i2 < b; ++i2) s[(o2 = q[i2]).i] = o2.x(t2);
    return s.join("");
  });
}
function interpolate(a2, b) {
  var t2 = typeof b, c2;
  return b == null || t2 === "boolean" ? constant$2(b) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c2 = color(b)) ? (b = c2, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a2, b);
}
function interpolateRound(a2, b) {
  return a2 = +a2, b = +b, function(t2) {
    return Math.round(a2 * (1 - t2) + b * t2);
  };
}
function constants(x) {
  return function() {
    return x;
  };
}
function number$1(x) {
  return +x;
}
var unit = [0, 1];
function identity$3(x) {
  return x;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x) {
    return (x - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t2;
  if (a2 > b) t2 = a2, a2 = b, b = t2;
  return function(x) {
    return Math.max(a2, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate2) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r2[i] = interpolate2(range[i], range[i + 1]);
  }
  return function(x) {
    var i2 = bisectRight(domain, x, 1, j) - 1;
    return r2[i2](d[i2](x));
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$1() {
  var domain = unit, range = unit, interpolate$1 = interpolate, transform2, untransform, unknown, clamp = identity$3, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform2), range, interpolate$1)))(transform2(clamp(x)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform2), interpolateNumber)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t2, u) {
    transform2 = t2, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer$1()(identity$3, identity$3);
}
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p2) {
  if ((i = (x = p2 ? x.toExponential(p2 - 1) : x.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t2 = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width) g = Math.max(1, width - length2);
      t2.push(value2.substring(i -= g, i + g));
      if ((length2 += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re$1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re$1.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x, p2) {
  var d = formatDecimalParts(x, p2);
  if (!d) return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p2 + i - 1))[0];
}
function formatRounded(x, p2) {
  var d = formatDecimalParts(x, p2);
  if (!d) return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x, p2) => (x * 100).toFixed(p2),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p2) => x.toExponential(p2),
  "f": (x, p2) => x.toFixed(p2),
  "g": (x, p2) => x.toPrecision(p2),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p2) => formatRounded(x * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};
function identity$2(x) {
  return x;
}
var map = Array.prototype.map, prefixes$1 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type3 = specifier.type;
    if (type3 === "n") comma = true, type3 = "g";
    else if (!formatTypes[type3]) precision === void 0 && (precision = 12), trim = true, type3 = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
    var formatType = formatTypes[type3], maybeSuffix = /[defgprs%]/.test(type3);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type3 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim(value2);
        if (valueNegative && +value2 === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type3 === "s" ? prefixes$1[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c2 = value2.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value2 = group(value2, Infinity);
      var length2 = valuePrefix.length + value2.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill) : "";
      if (comma && zero2) value2 = group(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length2);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes$1[8 + e / 3];
    return function(value3) {
      return f(k * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value2))) specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null) count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy$1(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function transformer() {
  var x0 = 0, x1 = 1, t0, t1, k10, transform2, interpolator = identity$3, clamp = false, unknown;
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform2(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform2(x0 = +x0), t1 = transform2(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range(interpolate);
  scale.rangeRound = range(interpolateRound);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t2) {
    transform2 = t2, t0 = t2(x0), t1 = t2(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer()(identity$3));
  scale.copy = function() {
    return copy(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function identity$1(x) {
  return x;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon$2 = 1e-6;
function translateX(x) {
  return "translate(" + x + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round()) offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + offset, range1 = +range[range.length - 1] + offset, position = (scale.bandwidth ? center : number)(scale.copy(), offset), selection = context.selection ? context.selection() : context, path2 = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$2).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$2).attr("transform", function(d) {
        var p2 = this.parentNode.__axis;
        return transform2((p2 && isFinite(p2 = p2(d)) ? p2 : position(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position(d) + offset);
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format2);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
const pi$1 = Math.PI, tau$1 = 2 * pi$1, epsilon$1 = 1e-6, tauEpsilon = tau$1 - epsilon$1;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y2) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y2) {
    this._append`L${this._x1 = +x},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon$1)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r2) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y2, r2, a0, a1, ccw) {
    x = +x, y2 = +y2, r2 = +r2, ccw = !!ccw;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._append`L${x0},${y0}`;
    }
    if (!r2) return;
    if (da < 0) da = da % tau$1 + tau$1;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw},${x - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon$1) {
      this._append`A${r2},${r2},0,${+(da >= pi$1)},${cw},${this._x1 = x + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x, y2, w, h2) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y2}h${w = +w}v${+h2}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function constant$1(x) {
  return function constant2() {
    return x;
  };
}
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;
const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t2 = y32 * x10 - x32 * y10;
  if (t2 * t2 < epsilon) return;
  t2 = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t2;
  return [x0 + t2 * x10, y0 + t2 * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo2 = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo2 * y01, oy = -lo2 * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r2 * r2 * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$1(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc2);
  function arc2() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min(rc, (r0 - lc) / (kc - 1));
            rc1 = min(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a2) * r2, sin(a2) * r2];
  };
  arc2.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc2) : padRadius;
  };
  arc2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc2) : startAngle;
  };
  arc2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc2) : endAngle;
  };
  arc2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc2) : padAngle;
  };
  arc2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc2) : context;
  };
  return arc2;
}
const circle = {
  draw(context, size2) {
    const r2 = sqrt(size2 / pi);
    context.moveTo(r2, 0);
    context.arc(0, 0, r2, 0, tau);
  }
};
const symbolSquare = {
  draw(context, size2) {
    const w = sqrt(size2);
    const x = -w / 2;
    context.rect(x, x, w, w);
  }
};
const sqrt3 = sqrt(3);
const symbolTriangle = {
  draw(context, size2) {
    const y2 = -sqrt(size2 / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
function Symbol$2(type3, size2) {
  let context = null, path2 = withPath(symbol);
  type3 = typeof type3 === "function" ? type3 : constant$1(type3 || circle);
  size2 = typeof size2 === "function" ? size2 : constant$1(size2 === void 0 ? 64 : +size2);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path2();
    type3.apply(this, arguments).draw(context, +size2.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type3 = typeof _ === "function" ? _ : constant$1(_), symbol) : type3;
  };
  symbol.size = function(_) {
    return arguments.length ? (size2 = typeof _ === "function" ? _ : constant$1(+_), symbol) : size2;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}
const d3 = {
  precisionFixed,
  format,
  select,
  selectAll,
  scaleLinear: linear,
  scaleSequential: sequential,
  axisTop,
  axisBottom,
  axisRight,
  axisLeft,
  symbol: Symbol$2,
  path,
  arc,
  symbolTriangle,
  symbolSquare
};
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
const TOLERANCE = 1e-10;
const DECIMAL_PLACES = 10;
function compare(a2, b, tolerance = TOLERANCE) {
  const diff = a2 - b;
  return Math.abs(diff) < tolerance ? 0 : diff;
}
const isNumber = (value2) => typeof value2 === "number" && Number.isFinite(value2);
const maths = {
  greaterThan: (a2, b, tolerance = TOLERANCE) => compare(a2, b, tolerance) > 0,
  greaterThanOrEqualTo: (a2, b, tolerance = TOLERANCE) => compare(a2, b, tolerance) >= 0,
  lessThan: (a2, b, tolerance = TOLERANCE) => compare(a2, b, tolerance) < 0,
  lessThanOrEqualTo: (a2, b, tolerance = TOLERANCE) => compare(a2, b, tolerance) <= 0,
  equalTo: (a2, b, tolerance = TOLERANCE) => compare(a2, b, tolerance) === 0,
  isNumber,
  round: (number2) => isNumber(number2) ? Number(number2.toFixed(DECIMAL_PLACES)) : false,
  getRandom: (length2) => Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / (4294967295 + 1) * length2),
  getRandomSample(array2, size2) {
    const shuffled = array2.slice();
    let i = array2.length;
    const min2 = i - size2;
    while (i-- > min2) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled.slice(min2);
  },
  calculateStandardDeviation(numbers, mean = null) {
    if (!mean) {
      mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    }
    const squaredDifferences = numbers.map((num) => Math.pow(num - mean, 2));
    const variance = squaredDifferences.reduce((sum, num) => sum + num, 0) / numbers.length;
    const standardDeviation = Math.sqrt(variance);
    return standardDeviation;
  },
  calculateCoefficientOfVariation(numbers) {
    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    const sd = this.calculateStandardDeviation(numbers);
    return sd / mean;
  }
};
function valueSet(value2) {
  if (value2 === void 0) return false;
  if (value2 === null || value2 === "") return false;
  if (typeof value2 === "object" && !Object.values(value2).length) return false;
  return true;
}
function objectValuesPresent(object2, truthy = true) {
  if (!valueSet(object2)) return false;
  if (typeof object2 !== "object") return false;
  const values = Object.values(object2);
  if (values.some((val) => {
    if (!valueSet(val)) return false;
    if (truthy && !val) return false;
    return true;
  })) {
    return true;
  }
  return false;
}
function totalQuantity(items) {
  if (!items) return 0;
  return items.reduce((total, s) => {
    let q = 0;
    if (isInputStock(s) && s.autoAdd) q = 1;
    else {
      q = valueSet(s.q) && typeof s.q === "string" ? parseInt(s.q) : s.q;
    }
    if (!isNaN(q) && q > 0) return total + q;
    return total;
  }, 0);
}
function unplacedShapeTally(shapeList) {
  if (!(shapeList == null ? void 0 : shapeList.length)) return [];
  const unplacedShapes = shapeList.filter((shape) => !shape.added).map((shape) => {
    shape.parentID = shape.getParentID();
    return shape;
  });
  const uniques = {};
  unplacedShapes.forEach((item) => {
    if (!uniques[item.parentID]) {
      uniques[item.parentID] = {};
      uniques[item.parentID].count = 1;
      uniques[item.parentID].id = item.parentID;
      uniques[item.parentID].name = (item == null ? void 0 : item.name) ? item.name : item.id;
      uniques[item.parentID].l = item.l;
      uniques[item.parentID].w = item.w;
      uniques[item.parentID].t = item.t;
      uniques[item.parentID].material = item.material;
      uniques[item.parentID].rot = item.rot;
    } else ++uniques[item.parentID].count;
  });
  return Object.values(uniques);
}
function getStackedStock(stockList) {
  if (!(stockList == null ? void 0 : stockList.length)) return [];
  return stockList.filter((stock) => stock.used && (stock.stack === false || typeof stock.stack === "number"));
}
function isElementFullScreenSupported() {
  const elem = document.documentElement;
  if ("requestFullscreen" in elem || "webkitRequestFullscreen" in elem || "mozRequestFullScreen" in elem || "msRequestFullscreen" in elem) {
    return true;
  }
  return false;
}
function sanitiseString(str) {
  if (!str) return null;
  str = str.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^ a-z0-9._\-|]/gim, "");
  return str.trim();
}
function truncateString(str, length2 = 100) {
  if (!str) return "";
  str = str.trim();
  str = str.substring(0, length2);
  return str;
}
const sort = {
  //sort by width then length - use .sort(sortHeightDescWidthDesc)
  WDLD(a2, b) {
    if (a2.w < b.w) return 1;
    if (a2.w > b.w) return -1;
    if (a2.l === b.l) return 0;
    if (a2.l < b.l) return 1;
    if (a2.l > b.l) return -1;
  },
  WALA(a2, b) {
    if (a2.w > b.w) return 1;
    if (a2.w < b.w) return -1;
    if (a2.l === b.l) return 0;
    if (a2.l > b.l) return 1;
    if (a2.l < b.l) return -1;
  },
  //sort by length d then width d
  LDWD(a2, b) {
    if (a2.l < b.l) return 1;
    if (a2.l > b.l) return -1;
    if (a2.w === b.w) return 0;
    if (a2.w < b.w) return 1;
    if (a2.w > b.w) return -1;
  },
  LAWA(a2, b) {
    if (a2.l > b.l) return 1;
    if (a2.l < b.l) return -1;
    if (a2.w === b.w) return 0;
    if (a2.w > b.w) return 1;
    if (a2.w < b.w) return -1;
  },
  //sort by width d
  WD(a2, b) {
    if (a2.w < b.w) return 1;
    if (a2.w > b.w) return -1;
    if (a2.w === b.w) return 0;
  },
  LD(a2, b) {
    if (a2.l < b.l) return 1;
    if (a2.l > b.l) return -1;
    if (a2.l === b.l) return 0;
  },
  LDIDA(a2, b) {
    if (a2.l < b.l) return 1;
    if (a2.l > b.l) return -1;
    const aID = a2.id.toString().split(".");
    const bID = b.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    } else {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
  },
  WDIDA(a2, b) {
    if (a2.w < b.w) return 1;
    if (a2.w > b.w) return -1;
    const aID = a2.id.toString().split(".");
    const bID = b.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    } else {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
  },
  //sort by proportion
  /* sortProportion: function(a, b) {
  
  		if (a.proportion < b.proportion) return 1;
  		if (a.proportion > b.proportion) return -1;
  
  		if (a.proportion === b.proportion) return a.index - b.index;
  
  	} */
  //area descending
  AD(a2, b) {
    const aArea = a2.getArea();
    const bArea = b.getArea();
    if (aArea < bArea) return 1;
    if (aArea > bArea) return -1;
    if (aArea === bArea) return 0;
  },
  AA(a2, b) {
    const aArea = a2.getArea();
    const bArea = b.getArea();
    if (aArea < bArea) return -1;
    if (aArea > bArea) return 1;
    if (aArea === bArea) return 0;
  },
  AAID(a2, b) {
    const aArea = a2.getArea();
    const bArea = b.getArea();
    if (aArea < bArea) return -1;
    if (aArea > bArea) return 1;
    if (aArea === bArea) {
      const aID = a2.id.toString().split(".");
      const bID = b.id.toString().split(".");
      if (aID[0] !== bID[0]) {
        return parseInt(aID[0]) - parseInt(bID[0]);
      }
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    return 0;
  },
  ADID(a2, b) {
    const aArea = a2.getArea();
    const bArea = b.getArea();
    if (aArea < bArea) return 1;
    if (aArea > bArea) return -1;
    if (aArea === bArea) return 0;
    if (aArea === bArea) {
      const aID = a2.id.toString().split(".");
      const bID = b.id.toString().split(".");
      if (aID[0] !== bID[0]) {
        return parseInt(aID[0]) - parseInt(bID[0]);
      }
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    return 0;
  },
  //by id ascending
  ID(a2, b) {
    const aID = a2.id.toString().split(".");
    const bID = b.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    return parseInt(aID[1]) - parseInt(bID[1]);
  },
  IDDesc(a2, b) {
    const aID = a2.id.toString().split(".");
    const bID = b.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(bID[0]) - parseInt(aID[0]);
    }
    return parseInt(bID[1]) - parseInt(aID[1]);
  },
  StockID(a2, b) {
    const aID = a2.stock.id.toString().split(".");
    const bID = b.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    return parseInt(aID[1]) - parseInt(bID[1]);
  },
  StockIDAD(a2, b) {
    const aID = a2.stock.id.toString().split(".");
    const bID = b.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    } else if (aID[1] !== bID[1]) {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    const aArea = a2.getArea();
    const bArea = b.getArea();
    if (aArea < bArea) return 1;
    if (aArea > bArea) return -1;
  },
  parentID(a2, b) {
    return a2.parentID - b.parentID;
  },
  YX(a2, b) {
    if (a2.y < b.y) return -1;
    if (a2.y > b.y) return 1;
    if (a2.y === b.y) return 0;
    if (a2.x < b.x) return -1;
    if (a2.x > b.x) return 1;
  },
  XY(a2, b) {
    if (a2.x < b.x) return -1;
    if (a2.x > b.x) return 1;
    if (a2.x === b.x) return 0;
    if (a2.y < b.y) return -1;
    if (a2.y > b.y) return 1;
  },
  subset(a2, b) {
    if (a2.totalLength < b.totalLength) return 1;
    if (a2.totalLength > b.totalLength) return -1;
    if (a2.area === b.area) return 0;
    if (a2.area < b.area) return 1;
    if (a2.area > b.area) return -1;
  },
  placementOrder(a2, b) {
    return (a2 == null ? void 0 : a2.placementOrder) - (b == null ? void 0 : b.placementOrder);
  },
  typePlacementOrder(a2, b) {
    if (a2.offcut && !b.offcut) return 1;
    else if (!a2.offcut && b.offcut) return 0;
    if (a2.offcut === b.offcut) return a2.placementOrder - b.placementOrder;
  },
  stockIDTypePlacementOrder(a2, b) {
    const aID = a2.stock.id.toString().split(".");
    const bID = b.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    if (aID[1] !== bID[1]) {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    if (a2.offcut && !b.offcut) return 1;
    else if (!a2.offcut && b.offcut) return 0;
    if (a2.offcut === b.offcut) return a2.placementOrder - b.placementOrder;
  },
  offcutPlacementOrder(a2, b) {
    var _a2, _b;
    if (!((_a2 = a2 == null ? void 0 : a2.stock) == null ? void 0 : _a2.id) || !((_b = b == null ? void 0 : b.stock) == null ? void 0 : _b.id)) return 0;
    const aID = a2.stock.id.toString().split(".");
    const bID = b.stock.id.toString().split(".");
    if (aID[0] !== bID[0]) {
      return parseInt(aID[0]) - parseInt(bID[0]);
    }
    if (aID[1] !== bID[1]) {
      return parseInt(aID[1]) - parseInt(bID[1]);
    }
    return (a2 == null ? void 0 : a2.placementOrder) - (b == null ? void 0 : b.placementOrder);
  },
  groupPlacementOrder(a2, b) {
    if (a2.placementOrder > b.placementOrder) return 1;
    if (a2.placementOrder < b.placementOrder) return -1;
    if (a2.groupPlacementOrder === b.groupPlacementOrder) return 0;
    if (a2.groupPlacementOrder > b.groupPlacementOrder) return 1;
    if (a2.groupPlacementOrder < b.groupPlacementOrder) return -1;
  },
  swapFirstTwo(array2) {
    const second = array2[1];
    array2[1] = array2[0];
    array2[0] = second;
  },
  //Fisher-Yates shuffle
  shuffle(array2) {
    for (let i = array2.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array2[i], array2[j]] = [array2[j], array2[i]];
    }
  },
  /**
      * generator function which accepts a dimension to cater for shape rotation lock
      */
  fillThenArea(dimension) {
    return function(a2, b) {
      if (a2.getLongSide(dimension) > b.getLongSide(dimension)) return -1;
      else if (a2.getLongSide(dimension) < b.getLongSide(dimension))
        return 1;
      if (a2.getArea() > b.getArea()) return -1;
      if (a2.getArea() < b.getArea()) return 1;
      return 0;
    };
  },
  aspect(a2, b) {
    const aAspect = a2.getAspect();
    const bAspect = b.getAspect();
    if (aAspect > bAspect) return -1;
    if (aAspect < bAspect) return 1;
    return 0;
  }
};
function getAxisFromDimension(dimension) {
  if (dimension === "l") return "x";
  if (dimension === "w") return "y";
}
function getReverseDimension(dimension) {
  if (!dimension) return null;
  return dimension === "l" ? "w" : "l";
}
function getReverseAxis(axis2) {
  if (!axis2) return null;
  return axis2 === "x" ? "y" : "x";
}
class Line {
  constructor(data) {
    __publicField(this, "x1");
    __publicField(this, "x2");
    __publicField(this, "y1");
    __publicField(this, "y2");
    __publicField(this, "direction");
    __publicField(this, "shapeCollisions");
    __publicField(this, "type");
    this.x1 = data.x1;
    this.x2 = data.x2;
    this.y1 = data.y1;
    this.y2 = data.y2;
    this.direction = getLineDirection(this);
    this.type = (data == null ? void 0 : data.type) ? data.type : null;
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
}
function getLineDirection(line) {
  if (typeof line === "undefined") return null;
  if (!maths.isNumber(line.x1) || !maths.isNumber(line.x2) || !maths.isNumber(line.y1) || !maths.isNumber(line.y2)) {
    return null;
  }
  if (line.x1 === line.x2 && line.y1 !== line.y2) return "w";
  else if (line.y1 === line.y2 && line.x1 !== line.x2) return "l";
  else return null;
}
var __defProp2 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value2) => __defProp2(target, "name", { value: value2, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var require_util = __commonJS({
  "(disabled):util"() {
  }
});
var utils_exports = {};
__export(utils_exports, {
  addChainableMethod: () => addChainableMethod,
  addLengthGuard: () => addLengthGuard,
  addMethod: () => addMethod,
  addProperty: () => addProperty,
  checkError: () => check_error_exports,
  compareByInspect: () => compareByInspect,
  eql: () => deep_eql_default,
  expectTypes: () => expectTypes,
  flag: () => flag,
  getActual: () => getActual,
  getMessage: () => getMessage2,
  getName: () => getName,
  getOperator: () => getOperator,
  getOwnEnumerableProperties: () => getOwnEnumerableProperties,
  getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
  getPathInfo: () => getPathInfo,
  hasProperty: () => hasProperty,
  inspect: () => inspect2,
  isNaN: () => isNaN2,
  isProxyEnabled: () => isProxyEnabled,
  isRegExp: () => isRegExp2,
  objDisplay: () => objDisplay,
  overwriteChainableMethod: () => overwriteChainableMethod,
  overwriteMethod: () => overwriteMethod,
  overwriteProperty: () => overwriteProperty,
  proxify: () => proxify,
  test: () => test$1,
  transferFlags: () => transferFlags,
  type: () => type$1
});
var check_error_exports = {};
__export(check_error_exports, {
  compatibleConstructor: () => compatibleConstructor,
  compatibleInstance: () => compatibleInstance,
  compatibleMessage: () => compatibleMessage,
  getConstructorName: () => getConstructorName,
  getMessage: () => getMessage
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  if (isErrorInstance(errorLike)) {
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if ((typeof errorLike === "object" || typeof errorLike === "function") && errorLike.prototype) {
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }
  return false;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  const comparisonString = typeof thrown === "string" ? thrown : thrown.message;
  if (isRegExp(errMatcher)) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === "string") {
    return comparisonString.indexOf(errMatcher) !== -1;
  }
  return false;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName(errorLike) {
  let constructorName = errorLike;
  if (isErrorInstance(errorLike)) {
    constructorName = errorLike.constructor.name;
  } else if (typeof errorLike === "function") {
    constructorName = errorLike.name;
    if (constructorName === "") {
      const newConstructorName = new errorLike().name;
      constructorName = newConstructorName || constructorName;
    }
  }
  return constructorName;
}
__name(getConstructorName, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === "string") {
    msg = errorLike;
  }
  return msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value2) {
  var flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value2;
  } else {
    return flags[key];
  }
}
__name(flag, "flag");
function test$1(obj, args) {
  var negate = flag(obj, "negate"), expr = args[0];
  return negate ? !expr : expr;
}
__name(test$1, "test");
function type$1(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  const stringTag2 = obj[Symbol.toStringTag];
  if (typeof stringTag2 === "string") {
    return stringTag2;
  }
  const type3 = Object.prototype.toString.call(obj).slice(8, -1);
  return type3;
}
__name(type$1, "type");
var canElideFrames = "captureStackTrace" in Error;
var AssertionError = (_a = class extends Error {
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message);
    __publicField(this, "message");
    this.message = message;
    if (canElideFrames) {
      Error.captureStackTrace(this, ssf || _a);
    }
    for (const key in props) {
      if (!(key in this)) {
        this[key] = props[key];
      }
    }
  }
  get name() {
    return "AssertionError";
  }
  get ok() {
    return false;
  }
  toJSON(stack2) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: false,
      stack: stack2 !== false ? this.stack : void 0
    };
  }
}, __name(_a, "AssertionError"), _a);
function expectTypes(obj, types) {
  var flagMsg = flag(obj, "message");
  var ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  obj = flag(obj, "object");
  types = types.map(function(t2) {
    return t2.toLowerCase();
  });
  types.sort();
  var str = types.map(function(t2, index) {
    var art = ~["a", "e", "i", "o", "u"].indexOf(t2.charAt(0)) ? "an" : "a";
    var or = types.length > 1 && index === types.length - 1 ? "or " : "";
    return or + art + " " + t2;
  }).join(", ");
  var objType = type$1(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  })) {
    throw new AssertionError(
      flagMsg + "object tested must be " + str + ", but " + objType + " given",
      void 0,
      ssfi
    );
  }
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles$3 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "";
function colorise(value2, styleType) {
  const color2 = ansiColors[styles$3[styleType]] || ansiColors[styleType] || "";
  if (!color2) {
    return String(value2);
  }
  return `\x1B[${color2[0]}m${String(value2)}\x1B[${color2[1]}m`;
}
__name(colorise, "colorise");
function normaliseOptions({
  showHidden = false,
  depth = 2,
  colors = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = Infinity,
  breakLength = Infinity,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate2 = Infinity,
  stylize = String
} = {}, inspect3) {
  const options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate2),
    seen,
    inspect: inspect3,
    stylize
  };
  if (options.colors) {
    options.stylize = colorise;
  }
  return options;
}
__name(normaliseOptions, "normaliseOptions");
function truncate(string2, length2, tail = truncator) {
  string2 = String(string2);
  const tailLength = tail.length;
  const stringLength = string2.length;
  if (tailLength > length2 && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length2 && stringLength > tailLength) {
    return `${string2.slice(0, length2 - tailLength)}${tail}`;
  }
  return string2;
}
__name(truncate, "truncate");
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  const size2 = list.length;
  if (size2 === 0)
    return "";
  const originalLength = options.truncate;
  let output = "";
  let peek = "";
  let truncated = "";
  for (let i = 0; i < size2; i += 1) {
    const last = i + 1 === list.length;
    const secondToLast = i + 2 === list.length;
    truncated = `${truncator}(${list.length - i})`;
    const value2 = list[i];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    const string2 = peek || inspectItem(value2, options) + (last ? "" : separator);
    const nextLength = output.length + string2.length;
    const truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string2;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList, "inspectList");
function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey, "quoteComplexKey");
function inspectProperty([key, value2], options) {
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = `[${options.inspect(key, options)}]`;
  }
  options.truncate -= key.length;
  value2 = options.inspect(value2, options);
  return `${key}: ${value2}`;
}
__name(inspectProperty, "inspectProperty");
function inspectArray(array2, options) {
  const nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  const listContents = inspectList(array2, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty);
  }
  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray, "inspectArray");
var getArrayName = /* @__PURE__ */ __name((array2) => {
  if (typeof Buffer === "function" && array2 instanceof Buffer) {
    return "Buffer";
  }
  if (array2[Symbol.toStringTag]) {
    return array2[Symbol.toStringTag];
  }
  return array2.constructor.name;
}, "getArrayName");
function inspectTypedArray(array2, options) {
  const name = getArrayName(array2);
  options.truncate -= name.length + 4;
  const nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i = 0; i < array2.length; i++) {
    const string2 = `${options.stylize(truncate(array2[i], options.truncate), "number")}${i === array2.length - 1 ? "" : ", "}`;
    options.truncate -= string2.length;
    if (array2[i] !== array2.length && options.truncate <= 3) {
      output += `${truncator}(${array2.length - array2[i] + 1})`;
      break;
    }
    output += string2;
  }
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty);
  }
  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray, "inspectTypedArray");
function inspectDate(dateObject, options) {
  const stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  const split = stringRepresentation.split("T");
  const date2 = split[0];
  return options.stylize(`${date2}T${truncate(split[1], options.truncate - date2.length - 1)}`, "date");
}
__name(inspectDate, "inspectDate");
function inspectFunction(func, options) {
  const functionType = func[Symbol.toStringTag] || "Function";
  const name = func.name;
  if (!name) {
    return options.stylize(`[${functionType}]`, "special");
  }
  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
}
__name(inspectFunction, "inspectFunction");
function inspectMapEntry([key, value2], options) {
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value2 = options.inspect(value2, options);
  return `${key} => ${value2}`;
}
__name(inspectMapEntry, "inspectMapEntry");
function mapToEntries(map2) {
  const entries = [];
  map2.forEach((value2, key) => {
    entries.push([key, value2]);
  });
  return entries;
}
__name(mapToEntries, "mapToEntries");
function inspectMap(map2, options) {
  const size2 = map2.size - 1;
  if (size2 <= 0) {
    return "Map{}";
  }
  options.truncate -= 7;
  return `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`;
}
__name(inspectMap, "inspectMap");
var isNaN$1 = Number.isNaN || ((i) => i !== i);
function inspectNumber(number2, options) {
  if (isNaN$1(number2)) {
    return options.stylize("NaN", "number");
  }
  if (number2 === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number2 === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number2 === 0) {
    return options.stylize(1 / number2 === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate(String(number2), options.truncate), "number");
}
__name(inspectNumber, "inspectNumber");
function inspectBigInt(number2, options) {
  let nums = truncate(number2.toString(), options.truncate - 1);
  if (nums !== truncator)
    nums += "n";
  return options.stylize(nums, "bigint");
}
__name(inspectBigInt, "inspectBigInt");
function inspectRegExp(value2, options) {
  const flags = value2.toString().split("/")[2];
  const sourceLength = options.truncate - (2 + flags.length);
  const source = value2.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp, "inspectRegExp");
function arrayFromSet(set22) {
  const values = [];
  set22.forEach((value2) => {
    values.push(value2);
  });
  return values;
}
__name(arrayFromSet, "arrayFromSet");
function inspectSet(set22, options) {
  if (set22.size === 0)
    return "Set{}";
  options.truncate -= 7;
  return `Set{ ${inspectList(arrayFromSet(set22), options)} }`;
}
__name(inspectSet, "inspectSet");
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex = 16;
var unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
__name(escape, "escape");
function inspectString(string2, options) {
  if (stringEscapeChars.test(string2)) {
    string2 = string2.replace(stringEscapeChars, escape);
  }
  return options.stylize(`'${truncate(string2, options.truncate - 2)}'`, "string");
}
__name(inspectString, "inspectString");
function inspectSymbol(value2) {
  if ("description" in Symbol.prototype) {
    return value2.description ? `Symbol(${value2.description})` : "Symbol()";
  }
  return value2.toString();
}
__name(inspectSymbol, "inspectSymbol");
var getPromiseValue = /* @__PURE__ */ __name(() => "Promise{}", "getPromiseValue");
try {
  const { getPromiseDetails, kPending, kRejected } = process.binding("util");
  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
    getPromiseValue = /* @__PURE__ */ __name((value2, options) => {
      const [state, innerValue] = getPromiseDetails(value2);
      if (state === kPending) {
        return "Promise{<pending>}";
      }
      return `Promise${state === kRejected ? "!" : ""}{${options.inspect(innerValue, options)}}`;
    }, "getPromiseValue");
  }
} catch (notNode) {
}
var promise_default = getPromiseValue;
function inspectObject(object2, options) {
  const properties = Object.getOwnPropertyNames(object2);
  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.indexOf(object2) >= 0) {
    return "[Circular]";
  }
  options.seen.push(object2);
  const propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options, inspectProperty);
  const symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject, "inspectObject");
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value2, options) {
  let name = "";
  if (toStringTag && toStringTag in value2) {
    name = value2[toStringTag];
  }
  name = name || value2.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return `${name}${inspectObject(value2, options)}`;
}
__name(inspectClass, "inspectClass");
function inspectArguments(args, options) {
  if (args.length === 0)
    return "Arguments[]";
  options.truncate -= 13;
  return `Arguments[ ${inspectList(args, options)} ]`;
}
__name(inspectArguments, "inspectArguments");
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description"
];
function inspectObject2(error, options) {
  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
  const name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? `: ${message}` : "";
  options.truncate -= message.length + 5;
  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject2, "inspectObject");
function inspectAttribute([key, value2], options) {
  options.truncate -= 3;
  if (!value2) {
    return `${options.stylize(String(key), "yellow")}`;
  }
  return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value2}"`, "string")}`;
}
__name(inspectAttribute, "inspectAttribute");
function inspectHTMLCollection(collection, options) {
  return inspectList(collection, options, inspectHTML, "\n");
}
__name(inspectHTMLCollection, "inspectHTMLCollection");
function inspectHTML(element, options) {
  const properties = element.getAttributeNames();
  const name = element.tagName.toLowerCase();
  const head = options.stylize(`<${name}`, "special");
  const headClose = options.stylize(`>`, "special");
  const tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
  }
  options.truncate -= propertyContents.length;
  const truncate2 = options.truncate;
  let children2 = inspectHTMLCollection(element.children, options);
  if (children2 && children2.length > truncate2) {
    children2 = `${truncator}(${element.children.length})`;
  }
  return `${head}${propertyContents}${headClose}${children2}${tail}`;
}
__name(inspectHTML, "inspectHTML");
var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = false;
try {
  const nodeUtil2 = require_util();
  nodeInspect = nodeUtil2.inspect ? nodeUtil2.inspect.custom : false;
} catch (noNodeInspect) {
  nodeInspect = false;
}
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: (value2, options) => options.stylize("undefined", "undefined"),
  null: (value2, options) => options.stylize("null", "null"),
  boolean: (value2, options) => options.stylize(String(value2), "boolean"),
  Boolean: (value2, options) => options.stylize(String(value2), "boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value2, options) => options.stylize("WeakSet{}", "special"),
  WeakMap: (value2, options) => options.stylize("WeakMap{}", "special"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject2,
  HTMLCollection: inspectHTMLCollection,
  NodeList: inspectHTMLCollection
};
var inspectCustom = /* @__PURE__ */ __name((value2, options, type3) => {
  if (chaiInspect in value2 && typeof value2[chaiInspect] === "function") {
    return value2[chaiInspect](options);
  }
  if (nodeInspect && nodeInspect in value2 && typeof value2[nodeInspect] === "function") {
    return value2[nodeInspect](options.depth, options);
  }
  if ("inspect" in value2 && typeof value2.inspect === "function") {
    return value2.inspect(options.depth, options);
  }
  if ("constructor" in value2 && constructorMap.has(value2.constructor)) {
    return constructorMap.get(value2.constructor)(value2, options);
  }
  if (stringTagMap[type3]) {
    return stringTagMap[type3](value2, options);
  }
  return "";
}, "inspectCustom");
var toString$2 = Object.prototype.toString;
function inspect(value2, opts = {}) {
  const options = normaliseOptions(opts, inspect);
  const { customInspect } = options;
  let type3 = value2 === null ? "null" : typeof value2;
  if (type3 === "object") {
    type3 = toString$2.call(value2).slice(8, -1);
  }
  if (type3 in baseTypesMap) {
    return baseTypesMap[type3](value2, options);
  }
  if (customInspect && value2) {
    const output = inspectCustom(value2, options, type3);
    if (output) {
      if (typeof output === "string")
        return output;
      return inspect(output, options);
    }
  }
  const proto = value2 ? Object.getPrototypeOf(value2) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject(value2, options);
  }
  if (value2 && typeof HTMLElement === "function" && value2 instanceof HTMLElement) {
    return inspectHTML(value2, options);
  }
  if ("constructor" in value2) {
    if (value2.constructor !== Object) {
      return inspectClass(value2, options);
    }
    return inspectObject(value2, options);
  }
  if (value2 === Object(value2)) {
    return inspectObject(value2, options);
  }
  return options.stylize(String(value2), type3);
}
__name(inspect, "inspect");
var config$2 = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: false,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: true,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: true,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function inspect2(obj, showHidden, depth, colors) {
  var options = {
    colors,
    depth: typeof depth === "undefined" ? 2 : depth,
    showHidden,
    truncate: config$2.truncateThreshold ? config$2.truncateThreshold : Infinity
  };
  return inspect(obj, options);
}
__name(inspect2, "inspect");
function objDisplay(obj) {
  var str = inspect2(obj), type3 = Object.prototype.toString.call(obj);
  if (config$2.truncateThreshold && str.length >= config$2.truncateThreshold) {
    if (type3 === "[object Function]") {
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    } else if (type3 === "[object Array]") {
      return "[ Array(" + obj.length + ") ]";
    } else if (type3 === "[object Object]") {
      var keys = Object.keys(obj), kstr = keys.length > 2 ? keys.splice(0, 2).join(", ") + ", ..." : keys.join(", ");
      return "{ Object (" + kstr + ") }";
    } else {
      return str;
    }
  } else {
    return str;
  }
}
__name(objDisplay, "objDisplay");
function getMessage2(obj, args) {
  var negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, "message");
  if (typeof msg === "function")
    msg = msg();
  msg = msg || "";
  msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object2, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  if (!object2.__flags) {
    object2.__flags = /* @__PURE__ */ Object.create(null);
  }
  includeAll = arguments.length === 3 ? includeAll : true;
  for (var flag3 in flags) {
    if (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") {
      object2.__flags[flag3] = flags[flag3];
    }
  }
}
__name(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  const stringTag2 = obj[Symbol.toStringTag];
  if (typeof stringTag2 === "string") {
    return stringTag2;
  }
  const sliceStart = 8;
  const sliceEnd = -1;
  return Object.prototype.toString.call(obj).slice(sliceStart, sliceEnd);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: /* @__PURE__ */ __name(function get2(key) {
    return key[this._key];
  }, "get"),
  set: /* @__PURE__ */ __name(function set2(key, value2) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value2,
        configurable: true
      });
    }
  }, "set")
};
var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result === "boolean") {
      return result;
    }
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  if (simpleResult !== null) {
    return simpleResult;
  }
  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  if (leftHandOperand === rightHandOperand) {
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  }
  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand) {
    return true;
  }
  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return false;
  }
  return null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator;
  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  }
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    }
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
      return simpleResult;
    }
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  }
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }
  if (leftHandOperand.size === 0) {
    return true;
  }
  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value2) {
    leftHandItems.push([key, value2]);
  }, "gatherEntries"));
  rightHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value2) {
    rightHandItems.push([key, value2]);
  }, "gatherEntries"));
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length2 = leftHandOperand.length;
  if (length2 !== rightHandOperand.length) {
    return false;
  }
  if (length2 === 0) {
    return true;
  }
  var index = -1;
  while (++index < length2) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }
  return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];
  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys = [];
  for (var key in target) {
    keys.push(key);
  }
  return keys;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  var keys = [];
  var allKeys = Object.getOwnPropertySymbols(target);
  for (var i = 0; i < allKeys.length; i += 1) {
    var key = allKeys[i];
    if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
      keys.push(key);
    }
  }
  return keys;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length2 = keys.length;
  if (length2 === 0) {
    return true;
  }
  for (var i = 0; i < length2; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }
  return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);
  var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
  var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  leftHandKeys = leftHandKeys.concat(leftHandSymbols);
  rightHandKeys = rightHandKeys.concat(rightHandSymbols);
  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
      return false;
    }
    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }
  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);
  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }
  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }
  return false;
}
__name(objectEqual, "objectEqual");
function isPrimitive(value2) {
  return value2 === null || typeof value2 !== "object";
}
__name(isPrimitive, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(/* @__PURE__ */ __name(function mapSymbol(entry) {
    if (typeof entry === "symbol") {
      return entry.toString();
    }
    return entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
  if (typeof obj === "undefined" || obj === null) {
    return false;
  }
  return name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path2) {
  const str = path2.replace(/([^\\])\[/g, "$1.[");
  const parts2 = str.match(/(\\\.|[^.]+?)+/g);
  return parts2.map((value2) => {
    if (value2 === "constructor" || value2 === "__proto__" || value2 === "prototype") {
      return {};
    }
    const regexp = /^\[(\d+)\]$/;
    const mArr = regexp.exec(value2);
    let parsed = null;
    if (mArr) {
      parsed = { i: parseFloat(mArr[1]) };
    } else {
      parsed = { p: value2.replace(/\\([.[\]])/g, "$1") };
    }
    return parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj;
  let res = null;
  pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
  for (let i = 0; i < pathDepth; i++) {
    const part = parsed[i];
    if (temporaryValue) {
      if (typeof part.p === "undefined") {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }
      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path2) {
  const parsed = parsePath(path2);
  const last = parsed[parsed.length - 1];
  const info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
__name(getPathInfo, "getPathInfo");
function Assertion(obj, msg, ssfi, lockSsfi) {
  flag(this, "ssfi", ssfi || Assertion);
  flag(this, "lockSsfi", lockSsfi);
  flag(this, "object", obj);
  flag(this, "message", msg);
  flag(this, "eql", config$2.deepEqual || deep_eql_default);
  return proxify(this);
}
__name(Assertion, "Assertion");
Object.defineProperty(Assertion, "includeStack", {
  get: function() {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
    return config$2.includeStack;
  },
  set: function(value2) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
    config$2.includeStack = value2;
  }
});
Object.defineProperty(Assertion, "showDiff", {
  get: function() {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
    return config$2.showDiff;
  },
  set: function(value2) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
    config$2.showDiff = value2;
  }
});
Assertion.addProperty = function(name, fn) {
  addProperty(this.prototype, name, fn);
};
Assertion.addMethod = function(name, fn) {
  addMethod(this.prototype, name, fn);
};
Assertion.addChainableMethod = function(name, fn, chainingBehavior) {
  addChainableMethod(this.prototype, name, fn, chainingBehavior);
};
Assertion.overwriteProperty = function(name, fn) {
  overwriteProperty(this.prototype, name, fn);
};
Assertion.overwriteMethod = function(name, fn) {
  overwriteMethod(this.prototype, name, fn);
};
Assertion.overwriteChainableMethod = function(name, fn, chainingBehavior) {
  overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
};
Assertion.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
  var ok = test$1(this, arguments);
  if (false !== showDiff)
    showDiff = true;
  if (void 0 === expected && void 0 === _actual)
    showDiff = false;
  if (true !== config$2.showDiff)
    showDiff = false;
  if (!ok) {
    msg = getMessage2(this, arguments);
    var actual = getActual(this, arguments);
    var assertionErrorObjectProperties = {
      actual,
      expected,
      showDiff
    };
    var operator = getOperator(this, arguments);
    if (operator) {
      assertionErrorObjectProperties.operator = operator;
    }
    throw new AssertionError(
      msg,
      assertionErrorObjectProperties,
      config$2.includeStack ? this.assert : flag(this, "ssfi")
    );
  }
};
Object.defineProperty(
  Assertion.prototype,
  "_obj",
  {
    get: function() {
      return flag(this, "object");
    },
    set: function(val) {
      flag(this, "object", val);
    }
  }
);
function isProxyEnabled() {
  return config$2.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function() {
  } : getter;
  Object.defineProperty(
    ctx,
    name,
    {
      get: /* @__PURE__ */ __name(function propertyGetter() {
        if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
          flag(this, "ssfi", propertyGetter);
        }
        var result = getter.call(this);
        if (result !== void 0)
          return result;
        var newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "propertyGetter"),
      configurable: true
    }
  );
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable)
    return fn;
  Object.defineProperty(fn, "length", {
    get: function() {
      if (isChainable) {
        throw Error("Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }
      throw Error("Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object2) {
  var result = Object.getOwnPropertyNames(object2);
  function addProperty2(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }
  __name(addProperty2, "addProperty");
  var proto = Object.getPrototypeOf(object2);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty2);
    proto = Object.getPrototypeOf(proto);
  }
  return result;
}
__name(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled())
    return obj;
  return new Proxy(obj, {
    get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
      if (typeof property === "string" && config$2.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName) {
          throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        }
        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function(prop) {
          if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(
              property,
              prop,
              suggestionDistance
            );
            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });
        if (suggestion !== null) {
          throw Error("Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error("Invalid Chai property: " + property);
        }
      }
      if (builtins.indexOf(property) === -1 && !flag(target, "lockSsfi")) {
        flag(target, "ssfi", proxyGetter);
      }
      return Reflect.get(target, property);
    }, "proxyGetter")
  });
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }
  var memo = [];
  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }
  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }
  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);
    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }
      memo[i][j] = Math.min(
        memo[i - 1][j] + 1,
        memo[i][j - 1] + 1,
        memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1)
      );
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
  var methodWrapper = /* @__PURE__ */ __name(function() {
    if (!flag(this, "lockSsfi")) {
      flag(this, "ssfi", methodWrapper);
    }
    var result = method.apply(this, arguments);
    if (result !== void 0)
      return result;
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {
  }, "_super");
  if (_get && "function" === typeof _get.get)
    _super = _get.get;
  Object.defineProperty(
    ctx,
    name,
    {
      get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
        if (!isProxyEnabled() && !flag(this, "lockSsfi")) {
          flag(this, "ssfi", overwritingPropertyGetter);
        }
        var origLockSsfi = flag(this, "lockSsfi");
        flag(this, "lockSsfi", true);
        var result = getter(_super).call(this);
        flag(this, "lockSsfi", origLockSsfi);
        if (result !== void 0) {
          return result;
        }
        var newAssertion = new Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      }, "overwritingPropertyGetter"),
      configurable: true
    }
  );
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
  var _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
    throw new Error(name + " is not a function");
  }, "_super");
  if (_method && "function" === typeof _method)
    _super = _method;
  var overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
    if (!flag(this, "lockSsfi")) {
      flag(this, "ssfi", overwritingMethodWrapper);
    }
    var origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", true);
    var result = method(_super).apply(this, arguments);
    flag(this, "lockSsfi", origLockSsfi);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf === "function";
var testFn = /* @__PURE__ */ __name(function() {
}, "testFn");
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  if (typeof propDesc !== "object")
    return true;
  return !propDesc.configurable;
});
var call = Function.prototype.call;
var apply$1 = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== "function") {
    chainingBehavior = /* @__PURE__ */ __name(function() {
    }, "chainingBehavior");
  }
  var chainableBehavior = {
    method,
    chainingBehavior
  };
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(
    ctx,
    name,
    {
      get: /* @__PURE__ */ __name(function chainableMethodGetter() {
        chainableBehavior.chainingBehavior.call(this);
        var chainableMethodWrapper = /* @__PURE__ */ __name(function() {
          if (!flag(this, "lockSsfi")) {
            flag(this, "ssfi", chainableMethodWrapper);
          }
          var result = chainableBehavior.method.apply(this, arguments);
          if (result !== void 0) {
            return result;
          }
          var newAssertion = new Assertion();
          transferFlags(this, newAssertion);
          return newAssertion;
        }, "chainableMethodWrapper");
        addLengthGuard(chainableMethodWrapper, name, true);
        if (canSetPrototype) {
          var prototype = Object.create(this);
          prototype.call = call;
          prototype.apply = apply$1;
          Object.setPrototypeOf(chainableMethodWrapper, prototype);
        } else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function(asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }
            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }
        transferFlags(this, chainableMethodWrapper);
        return proxify(chainableMethodWrapper);
      }, "chainableMethodGetter"),
      configurable: true
    }
  );
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodGetter");
  var _method = chainableBehavior.method;
  chainableBehavior.method = /* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);
    if (result !== void 0) {
      return result;
    }
    var newAssertion = new Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a2, b) {
  return inspect2(a2) < inspect2(b) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== "function")
    return [];
  return Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
function _isNaN(value2) {
  return value2 !== value2;
}
__name(_isNaN, "_isNaN");
var isNaN2 = Number.isNaN || _isNaN;
function isObjectType(obj) {
  var objectType = type$1(obj);
  var objectTypes = ["Array", "Object", "Function"];
  return objectTypes.indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
  var operator = flag(obj, "operator");
  var negate = flag(obj, "negate");
  var expected = args[3];
  var msg = negate ? args[2] : args[1];
  if (operator) {
    return operator;
  }
  if (typeof msg === "function")
    msg = msg();
  msg = msg || "";
  if (!msg) {
    return void 0;
  }
  if (/\shave\s/.test(msg)) {
    return void 0;
  }
  var isObject2 = isObjectType(expected);
  if (/\snot\s/.test(msg)) {
    return isObject2 ? "notDeepStrictEqual" : "notStrictEqual";
  }
  return isObject2 ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
function getName(fn) {
  return fn.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
var { flag: flag2 } = utils_exports;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", true);
  flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", true);
  flag2(this, "any", false);
});
var functionTypes = {
  "function": ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  "asyncfunction": ["asyncfunction", "asyncgeneratorfunction"],
  "generatorfunction": ["generatorfunction", "asyncgeneratorfunction"],
  "asyncgeneratorfunction": ["asyncgeneratorfunction"]
};
function an(type3, msg) {
  if (msg)
    flag2(this, "message", msg);
  type3 = type3.toLowerCase();
  var obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type3.charAt(0)) ? "an " : "a ";
  const detectedType = type$1(obj).toLowerCase();
  if (functionTypes["function"].includes(type3)) {
    this.assert(
      functionTypes[type3].includes(detectedType),
      "expected #{this} to be " + article + type3,
      "expected #{this} not to be " + article + type3
    );
  } else {
    this.assert(
      type3 === detectedType,
      "expected #{this} to be " + article + type3,
      "expected #{this} not to be " + article + type3
    );
  }
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a2, b) {
  return isNaN2(a2) && isNaN2(b) || a2 === b;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type$1(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var included = false;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep) {
        throw new AssertionError(
          flagMsg + "unable to use .deep.include with WeakSet",
          void 0,
          ssfi
        );
      }
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      if (isDeep) {
        obj.forEach(function(item) {
          included = included || isEql(item, val);
        });
      } else {
        included = obj.has(val);
      }
      break;
    case "array":
      if (isDeep) {
        included = obj.some(function(item) {
          return isEql(item, val);
        });
      } else {
        included = obj.indexOf(val) !== -1;
      }
      break;
    default:
      if (val !== Object(val)) {
        throw new AssertionError(
          flagMsg + "the given combination of arguments (" + objType + " and " + type$1(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type$1(val).toLowerCase(),
          void 0,
          ssfi
        );
      }
      var props = Object.keys(val), firstErr = null, numErrs = 0;
      props.forEach(function(prop) {
        var propAssertion = new Assertion(obj);
        transferFlags(this, propAssertion, true);
        flag2(propAssertion, "lockSsfi", true);
        if (!negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err) {
          if (!check_error_exports.compatibleConstructor(err, AssertionError)) {
            throw err;
          }
          if (firstErr === null)
            firstErr = err;
          numErrs++;
        }
      }, this);
      if (negate && props.length > 1 && numErrs === props.length) {
        throw firstErr;
      }
      return;
  }
  this.assert(
    included,
    "expected #{this} to " + descriptor + "include " + inspect2(val),
    "expected #{this} to not " + descriptor + "include " + inspect2(val)
  );
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(
    flag2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
Assertion.addProperty("true", function() {
  this.assert(
    true === flag2(this, "object"),
    "expected #{this} to be true",
    "expected #{this} to be false",
    flag2(this, "negate") ? false : true
  );
});
Assertion.addProperty("callable", function() {
  const val = flag2(this, "object");
  const ssfi = flag2(this, "ssfi");
  const message = flag2(this, "message");
  const msg = message ? `${message}: ` : "";
  const negate = flag2(this, "negate");
  const assertionMessage = negate ? `${msg}expected ${inspect2(val)} not to be a callable function` : `${msg}expected ${inspect2(val)} to be a callable function`;
  const isCallable = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(type$1(val));
  if (isCallable && negate || !isCallable && !negate) {
    throw new AssertionError(
      assertionMessage,
      void 0,
      ssfi
    );
  }
});
Assertion.addProperty("false", function() {
  this.assert(
    false === flag2(this, "object"),
    "expected #{this} to be false",
    "expected #{this} to be true",
    flag2(this, "negate") ? true : false
  );
});
Assertion.addProperty("null", function() {
  this.assert(
    null === flag2(this, "object"),
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
Assertion.addProperty("undefined", function() {
  this.assert(
    void 0 === flag2(this, "object"),
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
Assertion.addProperty("NaN", function() {
  this.assert(
    isNaN2(flag2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function assertExist() {
  var val = flag2(this, "object");
  this.assert(
    val !== null && val !== void 0,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  var val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  switch (type$1(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(
        flagMsg + ".empty was passed a weak collection",
        void 0,
        ssfi
      );
    case "function":
      var msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    default:
      if (val !== Object(val)) {
        throw new AssertionError(
          flagMsg + ".empty was passed non-string primitive " + inspect2(val),
          void 0,
          ssfi
        );
      }
      itemsCount = Object.keys(val).length;
  }
  this.assert(
    0 === itemsCount,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function checkArguments() {
  var obj = flag2(this, "object"), type3 = type$1(obj);
  this.assert(
    "Arguments" === type3,
    "expected #{this} to be arguments but got " + type3,
    "expected #{this} to not be arguments"
  );
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    var prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", true);
    this.eql(val);
    flag2(this, "lockSsfi", prevLockSsfi);
  } else {
    this.assert(
      val === obj,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      val,
      this._obj,
      true
    );
  }
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  if (msg)
    flag2(this, "message", msg);
  var eql = flag2(this, "eql");
  this.assert(
    eql(obj, flag2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    obj,
    this._obj,
    true
  );
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type$1(obj).toLowerCase(), nType = type$1(n).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to above must be a date";
  } else if (nType !== "number" && (doLength || objType === "number")) {
    errorMessage = msgPrefix + "the argument to above must be a number";
  } else if (!doLength && (objType !== "date" && objType !== "number")) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount > n,
      "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " above #{exp}",
      n,
      itemsCount
    );
  } else {
    this.assert(
      obj > n,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n
    );
  }
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type$1(obj).toLowerCase(), nType = type$1(n).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to least must be a date";
  } else if (nType !== "number" && (doLength || objType === "number")) {
    errorMessage = msgPrefix + "the argument to least must be a number";
  } else if (!doLength && (objType !== "date" && objType !== "number")) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount >= n,
      "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " below #{exp}",
      n,
      itemsCount
    );
  } else {
    this.assert(
      obj >= n,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n
    );
  }
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type$1(obj).toLowerCase(), nType = type$1(n).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to below must be a date";
  } else if (nType !== "number" && (doLength || objType === "number")) {
    errorMessage = msgPrefix + "the argument to below must be a number";
  } else if (!doLength && (objType !== "date" && objType !== "number")) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount < n,
      "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " below #{exp}",
      n,
      itemsCount
    );
  } else {
    this.assert(
      obj < n,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n
    );
  }
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type$1(obj).toLowerCase(), nType = type$1(n).toLowerCase(), errorMessage, shouldThrow = true;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && nType !== "date")) {
    errorMessage = msgPrefix + "the argument to most must be a date";
  } else if (nType !== "number" && (doLength || objType === "number")) {
    errorMessage = msgPrefix + "the argument to most must be a number";
  } else if (!doLength && (objType !== "date" && objType !== "number")) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount <= n,
      "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " above #{exp}",
      n,
      itemsCount
    );
  } else {
    this.assert(
      obj <= n,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n
    );
  }
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type$1(obj).toLowerCase(), startType = type$1(start).toLowerCase(), finishType = type$1(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set") {
    new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
  }
  if (!doLength && (objType === "date" && (startType !== "date" || finishType !== "date"))) {
    errorMessage = msgPrefix + "the arguments to within must be dates";
  } else if ((startType !== "number" || finishType !== "number") && (doLength || objType === "number")) {
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  } else if (!doLength && (objType !== "date" && objType !== "number")) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else {
    shouldThrow = false;
  }
  if (shouldThrow) {
    throw new AssertionError(errorMessage, void 0, ssfi);
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    if (objType === "map" || objType === "set") {
      descriptor = "size";
      itemsCount = obj.size;
    } else {
      itemsCount = obj.length;
    }
    this.assert(
      itemsCount >= start && itemsCount <= finish,
      "expected #{this} to have a " + descriptor + " within " + range,
      "expected #{this} to not have a " + descriptor + " within " + range
    );
  } else {
    this.assert(
      obj >= start && obj <= finish,
      "expected #{this} to be within " + range,
      "expected #{this} to not be within " + range
    );
  }
});
function assertInstanceOf(constructor, msg) {
  if (msg)
    flag2(this, "message", msg);
  var target = flag2(this, "object");
  var ssfi = flag2(this, "ssfi");
  var flagMsg = flag2(this, "message");
  try {
    var isInstanceOf = target instanceof constructor;
  } catch (err) {
    if (err instanceof TypeError) {
      flagMsg = flagMsg ? flagMsg + ": " : "";
      throw new AssertionError(
        flagMsg + "The instanceof assertion needs a constructor but " + type$1(constructor) + " was given.",
        void 0,
        ssfi
      );
    }
    throw err;
  }
  var name = getName(constructor);
  if (name == null) {
    name = "an unnamed constructor";
  }
  this.assert(
    isInstanceOf,
    "expected #{this} to be an instance of " + name,
    "expected #{this} to not be an instance of " + name
  );
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  if (msg)
    flag2(this, "message", msg);
  var isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  if (isNested) {
    if (nameType !== "string") {
      throw new AssertionError(
        flagMsg + "the argument to property must be a string when using nested syntax",
        void 0,
        ssfi
      );
    }
  } else {
    if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") {
      throw new AssertionError(
        flagMsg + "the argument to property must be a string, number, or symbol",
        void 0,
        ssfi
      );
    }
  }
  if (isNested && isOwn) {
    throw new AssertionError(
      flagMsg + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      ssfi
    );
  }
  if (obj === null || obj === void 0) {
    throw new AssertionError(
      flagMsg + "Target cannot be null or undefined.",
      void 0,
      ssfi
    );
  }
  var isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value2 = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  var descriptor = "";
  if (isDeep)
    descriptor += "deep ";
  if (isOwn)
    descriptor += "own ";
  if (isNested)
    descriptor += "nested ";
  descriptor += "property ";
  var hasProperty2;
  if (isOwn)
    hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name);
  else if (isNested)
    hasProperty2 = pathInfo.exists;
  else
    hasProperty2 = hasProperty(obj, name);
  if (!negate || arguments.length === 1) {
    this.assert(
      hasProperty2,
      "expected #{this} to have " + descriptor + inspect2(name),
      "expected #{this} to not have " + descriptor + inspect2(name)
    );
  }
  if (arguments.length > 1) {
    this.assert(
      hasProperty2 && isEql(val, value2),
      "expected #{this} to have " + descriptor + inspect2(name) + " of #{exp}, but got #{act}",
      "expected #{this} to not have " + descriptor + inspect2(name) + " of #{act}",
      val,
      value2
    );
  }
  flag2(this, "object", value2);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(name, value2, msg) {
  flag2(this, "own", true);
  assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  if (typeof descriptor === "string") {
    msg = descriptor;
    descriptor = null;
  }
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
  var eql = flag2(this, "eql");
  if (actualDescriptor && descriptor) {
    this.assert(
      eql(descriptor, actualDescriptor),
      "expected the own property descriptor for " + inspect2(name) + " on #{this} to match " + inspect2(descriptor) + ", got " + inspect2(actualDescriptor),
      "expected the own property descriptor for " + inspect2(name) + " on #{this} to not match " + inspect2(descriptor),
      descriptor,
      actualDescriptor,
      true
    );
  } else {
    this.assert(
      actualDescriptor,
      "expected #{this} to have an own property descriptor for " + inspect2(name),
      "expected #{this} to not have an own property descriptor for " + inspect2(name)
    );
  }
  flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type$1(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size";
      itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
      itemsCount = obj.length;
  }
  this.assert(
    itemsCount == n,
    "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + descriptor + " of #{act}",
    n,
    itemsCount
  );
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(
    re2.exec(obj),
    "expected #{this} to match " + re2,
    "expected #{this} not to match " + re2
  );
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("string");
  this.assert(
    ~obj.indexOf(str),
    "expected #{this} to contain " + inspect2(str),
    "expected #{this} to not contain " + inspect2(str)
  );
});
function assertKeys(keys) {
  var obj = flag2(this, "object"), objType = type$1(obj), keysType = type$1(keys), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set") {
    deepStr = isDeep ? "deeply " : "";
    actual = [];
    obj.forEach(function(val, key) {
      actual.push(key);
    });
    if (keysType !== "Array") {
      keys = Array.prototype.slice.call(arguments);
    }
  } else {
    actual = getOwnEnumerableProperties(obj);
    switch (keysType) {
      case "Array":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        break;
      case "Object":
        if (arguments.length > 1) {
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        }
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }
    keys = keys.map(function(val) {
      return typeof val === "symbol" ? val : String(val);
    });
  }
  if (!keys.length) {
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  }
  var len = keys.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all) {
    all = true;
  }
  if (any) {
    ok = expected.some(function(expectedKey) {
      return actual.some(function(actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
  }
  if (all) {
    ok = expected.every(function(expectedKey) {
      return actual.some(function(actualKey) {
        return isEql(expectedKey, actualKey);
      });
    });
    if (!flag2(this, "contains")) {
      ok = ok && keys.length == actual.length;
    }
  }
  if (len > 1) {
    keys = keys.map(function(key) {
      return inspect2(key);
    });
    var last = keys.pop();
    if (all) {
      str = keys.join(", ") + ", and " + last;
    }
    if (any) {
      str = keys.join(", ") + ", or " + last;
    }
  } else {
    str = inspect2(keys[0]);
  }
  str = (len > 1 ? "keys " : "key ") + str;
  str = (flag2(this, "contains") ? "contain " : "have ") + str;
  this.assert(
    ok,
    "expected #{this} to " + deepStr + str,
    "expected #{this} to not " + deepStr + str,
    expected.slice(0).sort(compareByInspect),
    actual.sort(compareByInspect),
    true
  );
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
  new Assertion(obj, flagMsg, ssfi, true).is.a("function");
  if (isRegExp2(errorLike) || typeof errorLike === "string") {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  let caughtErr;
  let errorWasThrown = false;
  try {
    obj();
  } catch (err) {
    errorWasThrown = true;
    caughtErr = err;
  }
  var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
  var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
  var errorLikeFail = false;
  var errMsgMatcherFail = false;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    var errorLikeString = "an error";
    if (errorLike instanceof Error) {
      errorLikeString = "#{exp}";
    } else if (errorLike) {
      errorLikeString = check_error_exports.getConstructorName(errorLike);
    }
    let actual = caughtErr;
    if (caughtErr instanceof Error) {
      actual = caughtErr.toString();
    } else if (typeof caughtErr === "string") {
      actual = caughtErr;
    } else if (caughtErr && (typeof caughtErr === "object" || typeof caughtErr === "function")) {
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch (_err) {
      }
    }
    this.assert(
      errorWasThrown,
      "expected #{this} to throw " + errorLikeString,
      "expected #{this} to not throw an error but #{act} was thrown",
      errorLike && errorLike.toString(),
      actual
    );
  }
  if (errorLike && caughtErr) {
    if (errorLike instanceof Error) {
      var isCompatibleInstance = check_error_exports.compatibleInstance(caughtErr, errorLike);
      if (isCompatibleInstance === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(
            negate,
            "expected #{this} to throw #{exp} but #{act} was thrown",
            "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
            errorLike.toString(),
            caughtErr.toString()
          );
        }
      }
    }
    var isCompatibleConstructor = check_error_exports.compatibleConstructor(caughtErr, errorLike);
    if (isCompatibleConstructor === negate) {
      if (everyArgIsDefined && negate) {
        errorLikeFail = true;
      } else {
        this.assert(
          negate,
          "expected #{this} to throw #{exp} but #{act} was thrown",
          "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
          errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
          caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
        );
      }
    }
  }
  if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    var placeholder = "including";
    if (isRegExp2(errMsgMatcher)) {
      placeholder = "matching";
    }
    var isCompatibleMessage = check_error_exports.compatibleMessage(caughtErr, errMsgMatcher);
    if (isCompatibleMessage === negate) {
      if (everyArgIsDefined && negate) {
        errMsgMatcherFail = true;
      } else {
        this.assert(
          negate,
          "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
          "expected #{this} to throw error not " + placeholder + " #{exp}",
          errMsgMatcher,
          check_error_exports.getMessage(caughtErr)
        );
      }
    }
  }
  if (errorLikeFail && errMsgMatcherFail) {
    this.assert(
      negate,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
      errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
      caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
    );
  }
  flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), itself = flag2(this, "itself"), context = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
  this.assert(
    "function" === typeof context,
    "expected #{this} to respond to " + inspect2(method),
    "expected #{this} to not respond to " + inspect2(method)
  );
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", true);
});
function satisfy(matcher2, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  var result = matcher2(obj);
  this.assert(
    result,
    "expected #{this} to satisfy " + objDisplay(matcher2),
    "expected #{this} to not satisfy" + objDisplay(matcher2),
    flag2(this, "negate") ? false : true,
    result
  );
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).is.a("number");
  if (typeof expected !== "number" || typeof delta !== "number") {
    flagMsg = flagMsg ? flagMsg + ": " : "";
    var deltaMessage = delta === void 0 ? ", and a delta is required" : "";
    throw new AssertionError(
      flagMsg + "the arguments to closeTo or approximately must be numbers" + deltaMessage,
      void 0,
      ssfi
    );
  }
  this.assert(
    Math.abs(obj - expected) <= delta,
    "expected #{this} to be close to " + expected + " +/- " + delta,
    "expected #{this} not to be close to " + expected + " +/- " + delta
  );
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  let superset = Array.from(_superset);
  let subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length)
      return false;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered)
      return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      var matchIdx = superset.indexOf(elem);
      if (matchIdx === -1)
        return false;
      if (!contains)
        superset.splice(matchIdx, 1);
      return true;
    }
    return superset.some(function(elem2, matchIdx2) {
      if (!cmp(elem, elem2))
        return false;
      if (!contains)
        superset.splice(matchIdx2, 1);
      return true;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
  new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
  var contains = flag2(this, "contains");
  var ordered = flag2(this, "ordered");
  var subject, failMsg, failNegateMsg;
  if (contains) {
    subject = ordered ? "an ordered superset" : "a superset";
    failMsg = "expected #{this} to be " + subject + " of #{exp}";
    failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
  } else {
    subject = ordered ? "ordered members" : "members";
    failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
    failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
  }
  var cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(
    isSubsetOf(subset, obj, cmp, contains, ordered),
    failMsg,
    failNegateMsg,
    subset,
    obj,
    true
  );
});
Assertion.addProperty("iterable", function(msg) {
  if (msg)
    flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(
    obj != void 0 && obj[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    obj
  );
});
function oneOf(list, msg) {
  if (msg)
    flag2(this, "message", msg);
  var expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
  if (contains) {
    this.assert(
      list.some(function(possibility) {
        return expected.indexOf(possibility) > -1;
      }),
      "expected #{this} to contain one of #{exp}",
      "expected #{this} to not contain one of #{exp}",
      list,
      expected
    );
  } else {
    if (isDeep) {
      this.assert(
        list.some(function(possibility) {
          return eql(expected, possibility);
        }),
        "expected #{this} to deeply equal one of #{exp}",
        "expected #{this} to deeply equal one of #{exp}",
        list,
        expected
      );
    } else {
      this.assert(
        list.indexOf(expected) > -1,
        "expected #{this} to be one of #{exp}",
        "expected #{this} to not be one of #{exp}",
        list,
        expected
      );
    }
  }
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  if (msg)
    flag2(this, "message", msg);
  var fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial2;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial2 = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial2 = subject[prop];
  }
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial2 : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial2);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "change");
  flag2(this, "realDelta", final !== initial2);
  this.assert(
    initial2 !== final,
    "expected " + msgObj + " to change",
    "expected " + msgObj + " to not change"
  );
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  if (msg)
    flag2(this, "message", msg);
  var fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial2;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial2 = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial2 = subject[prop];
  }
  new Assertion(initial2, flagMsg, ssfi, true).is.a("number");
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial2 : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial2);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "increase");
  flag2(this, "realDelta", final - initial2);
  this.assert(
    final - initial2 > 0,
    "expected " + msgObj + " to increase",
    "expected " + msgObj + " to not increase"
  );
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  if (msg)
    flag2(this, "message", msg);
  var fn = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn, flagMsg, ssfi, true).is.a("function");
  var initial2;
  if (!prop) {
    new Assertion(subject, flagMsg, ssfi, true).is.a("function");
    initial2 = subject();
  } else {
    new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
    initial2 = subject[prop];
  }
  new Assertion(initial2, flagMsg, ssfi, true).is.a("number");
  fn();
  var final = prop === void 0 || prop === null ? subject() : subject[prop];
  var msgObj = prop === void 0 || prop === null ? initial2 : "." + prop;
  flag2(this, "deltaMsgObj", msgObj);
  flag2(this, "initialDeltaValue", initial2);
  flag2(this, "finalDeltaValue", final);
  flag2(this, "deltaBehavior", "decrease");
  flag2(this, "realDelta", initial2 - final);
  this.assert(
    final - initial2 < 0,
    "expected " + msgObj + " to decrease",
    "expected " + msgObj + " to not decrease"
  );
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  if (msg)
    flag2(this, "message", msg);
  var msgObj = flag2(this, "deltaMsgObj");
  var initial2 = flag2(this, "initialDeltaValue");
  var final = flag2(this, "finalDeltaValue");
  var behavior = flag2(this, "deltaBehavior");
  var realDelta = flag2(this, "realDelta");
  var expression;
  if (behavior === "change") {
    expression = Math.abs(final - initial2) === Math.abs(delta);
  } else {
    expression = realDelta === Math.abs(delta);
  }
  this.assert(
    expression,
    "expected " + msgObj + " to " + behavior + " by " + delta,
    "expected " + msgObj + " to not " + behavior + " by " + delta
  );
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  var obj = flag2(this, "object");
  var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(
    isExtensible,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
Assertion.addProperty("sealed", function() {
  var obj = flag2(this, "object");
  var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
  this.assert(
    isSealed,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
Assertion.addProperty("frozen", function() {
  var obj = flag2(this, "object");
  var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
  this.assert(
    isFrozen,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
Assertion.addProperty("finite", function(msg) {
  var obj = flag2(this, "object");
  this.assert(
    typeof obj === "number" && isFinite(obj),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "expect.fail()";
  throw new AssertionError(message, {
    actual,
    expected,
    operator
  }, expect.fail);
};
var should_exports = {};
__export(should_exports, {
  Should: () => Should,
  should: () => should
});
function loadShould() {
  function shouldGetter() {
    if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) {
      return new Assertion(this.valueOf(), null, shouldGetter);
    }
    return new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value2) {
    Object.defineProperty(this, "should", {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  }
  __name(shouldSetter, "shouldSetter");
  Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: true
  });
  var should2 = {};
  should2.fail = function(actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = void 0;
    }
    message = message || "should.fail()";
    throw new AssertionError(message, {
      actual,
      expected,
      operator
    }, should2.fail);
  };
  should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  };
  should2.Throw = function(fn, errt, errs, msg) {
    new Assertion(fn, msg).to.Throw(errt, errs);
  };
  should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  };
  should2.not = {};
  should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  };
  should2.not.Throw = function(fn, errt, errs, msg) {
    new Assertion(fn, msg).to.not.Throw(errt, errs);
  };
  should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  };
  should2["throw"] = should2["Throw"];
  should2.not["throw"] = should2.not["Throw"];
  return should2;
}
__name(loadShould, "loadShould");
var should = loadShould;
var Should = loadShould;
function assert(express, errmsg) {
  var test2 = new Assertion(null, null, assert, true);
  test2.assert(
    express,
    errmsg,
    "[ negation message unavailable ]"
  );
}
__name(assert, "assert");
assert.fail = function(actual, expected, message, operator) {
  if (arguments.length < 2) {
    message = actual;
    actual = void 0;
  }
  message = message || "assert.fail()";
  throw new AssertionError(message, {
    actual,
    expected,
    operator
  }, assert.fail);
};
assert.isOk = function(val, msg) {
  new Assertion(val, msg, assert.isOk, true).is.ok;
};
assert.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
};
assert.equal = function(act, exp, msg) {
  var test2 = new Assertion(act, msg, assert.equal, true);
  test2.assert(
    exp == flag(test2, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    exp,
    act,
    true
  );
};
assert.notEqual = function(act, exp, msg) {
  var test2 = new Assertion(act, msg, assert.notEqual, true);
  test2.assert(
    exp != flag(test2, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    exp,
    act,
    true
  );
};
assert.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
};
assert.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
};
assert.deepEqual = assert.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
};
assert.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
};
assert.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
};
assert.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
};
assert.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
};
assert.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
};
assert.isTrue = function(val, msg) {
  new Assertion(val, msg, assert.isTrue, true).is["true"];
};
assert.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
};
assert.isFalse = function(val, msg) {
  new Assertion(val, msg, assert.isFalse, true).is["false"];
};
assert.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
};
assert.isNull = function(val, msg) {
  new Assertion(val, msg, assert.isNull, true).to.equal(null);
};
assert.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
};
assert.isNaN = function(val, msg) {
  new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
};
assert.isNotNaN = function(value2, message) {
  new Assertion(value2, message, assert.isNotNaN, true).not.to.be.NaN;
};
assert.exists = function(val, msg) {
  new Assertion(val, msg, assert.exists, true).to.exist;
};
assert.notExists = function(val, msg) {
  new Assertion(val, msg, assert.notExists, true).to.not.exist;
};
assert.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert.isUndefined, true).to.equal(void 0);
};
assert.isDefined = function(val, msg) {
  new Assertion(val, msg, assert.isDefined, true).to.not.equal(void 0);
};
assert.isCallable = function(value2, message) {
  new Assertion(value2, message, assert.isCallable, true).is.callable;
};
assert.isNotCallable = function(value2, message) {
  new Assertion(value2, message, assert.isNotCallable, true).is.not.callable;
};
assert.isObject = function(val, msg) {
  new Assertion(val, msg, assert.isObject, true).to.be.a("object");
};
assert.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert.isNotObject, true).to.not.be.a("object");
};
assert.isArray = function(val, msg) {
  new Assertion(val, msg, assert.isArray, true).to.be.an("array");
};
assert.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert.isNotArray, true).to.not.be.an("array");
};
assert.isString = function(val, msg) {
  new Assertion(val, msg, assert.isString, true).to.be.a("string");
};
assert.isNotString = function(val, msg) {
  new Assertion(val, msg, assert.isNotString, true).to.not.be.a("string");
};
assert.isNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNumber, true).to.be.a("number");
};
assert.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a("number");
};
assert.isFinite = function(val, msg) {
  new Assertion(val, msg, assert.isFinite, true).to.be.finite;
};
assert.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isBoolean, true).to.be.a("boolean");
};
assert.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a("boolean");
};
assert.typeOf = function(val, type3, msg) {
  new Assertion(val, msg, assert.typeOf, true).to.be.a(type3);
};
assert.notTypeOf = function(value2, type3, message) {
  new Assertion(value2, message, assert.notTypeOf, true).to.not.be.a(type3);
};
assert.instanceOf = function(val, type3, msg) {
  new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type3);
};
assert.notInstanceOf = function(val, type3, msg) {
  new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type3);
};
assert.include = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.include, true).include(inc2);
};
assert.notInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.notInclude, true).not.include(inc2);
};
assert.deepInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc2);
};
assert.notDeepInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc2);
};
assert.nestedInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc2);
};
assert.notNestedInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc2);
};
assert.deepNestedInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc2);
};
assert.notDeepNestedInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc2);
};
assert.ownInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.ownInclude, true).own.include(inc2);
};
assert.notOwnInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc2);
};
assert.deepOwnInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc2);
};
assert.notDeepOwnInclude = function(exp, inc2, msg) {
  new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc2);
};
assert.match = function(exp, re2, msg) {
  new Assertion(exp, msg, assert.match, true).to.match(re2);
};
assert.notMatch = function(exp, re2, msg) {
  new Assertion(exp, msg, assert.notMatch, true).to.not.match(re2);
};
assert.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.property, true).to.have.property(prop);
};
assert.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
};
assert.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
};
assert.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
};
assert.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
};
assert.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
};
assert.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
};
assert.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
};
assert.ownPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value2);
};
assert.notOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value2);
};
assert.deepOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value2);
};
assert.notDeepOwnPropertyVal = function(obj, prop, value2, msg) {
  new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value2);
};
assert.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
};
assert.notNestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
};
assert.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
};
assert.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
};
assert.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
};
assert.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
};
assert.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
};
assert.hasAnyKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
};
assert.hasAllKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
};
assert.containsAllKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
};
assert.doesNotHaveAnyKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
};
assert.doesNotHaveAllKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
};
assert.hasAnyDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
};
assert.hasAllDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
};
assert.containsAllDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
};
assert.doesNotHaveAnyDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
};
assert.doesNotHaveAllDeepKeys = function(obj, keys, msg) {
  new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
};
assert.throws = function(fn, errorLike, errMsgMatcher, msg) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
  return flag(assertErr, "object");
};
assert.doesNotThrow = function(fn, errorLike, errMsgMatcher, message) {
  if ("string" === typeof errorLike || errorLike instanceof RegExp) {
    errMsgMatcher = errorLike;
    errorLike = null;
  }
  new Assertion(fn, message, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
};
assert.operator = function(val, operator, val2, msg) {
  var ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      msg = msg ? msg + ": " : msg;
      throw new AssertionError(
        msg + 'Invalid operator "' + operator + '"',
        void 0,
        assert.operator
      );
  }
  var test2 = new Assertion(ok, msg, assert.operator, true);
  test2.assert(
    true === flag(test2, "object"),
    "expected " + inspect2(val) + " to be " + operator + " " + inspect2(val2),
    "expected " + inspect2(val) + " to not be " + operator + " " + inspect2(val2)
  );
};
assert.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
};
assert.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
};
assert.sameMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set22);
};
assert.notSameMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set22);
};
assert.sameDeepMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set22);
};
assert.notSameDeepMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set22);
};
assert.sameOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set22);
};
assert.notSameOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set22);
};
assert.sameDeepOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set22);
};
assert.notSameDeepOrderedMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set22);
};
assert.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
};
assert.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
};
assert.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
};
assert.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
};
assert.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
};
assert.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
};
assert.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
};
assert.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
};
assert.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
};
assert.isIterable = function(obj, msg) {
  if (obj == void 0 || !obj[Symbol.iterator]) {
    msg = msg ? `${msg} expected ${inspect2(obj)} to be an iterable` : `expected ${inspect2(obj)} to be an iterable`;
    throw new AssertionError(
      msg,
      void 0,
      assert.isIterable
    );
  }
};
assert.changes = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
};
assert.changesBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
};
assert.doesNotChange = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
};
assert.changesButNotBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert.increases = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
};
assert.increasesBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert.doesNotIncrease = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
};
assert.increasesButNotBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert.decreases = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
};
assert.decreasesBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert.doesNotDecrease = function(fn, obj, prop, msg) {
  if (arguments.length === 3 && typeof obj === "function") {
    msg = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
};
assert.doesNotDecreaseBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert.decreasesButNotBy = function(fn, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj === "function") {
    var tmpMsg = delta;
    delta = prop;
    msg = tmpMsg;
  } else if (arguments.length === 3) {
    delta = prop;
    prop = null;
  }
  new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert.ifError = function(val) {
  if (val) {
    throw val;
  }
};
assert.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
};
assert.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
};
assert.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
};
assert.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
};
assert.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
};
assert.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
};
assert.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
};
assert.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
};
(/* @__PURE__ */ __name(function alias(name, as) {
  assert[as] = assert[name];
  return alias;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var used = [];
function use(fn) {
  const exports2 = {
    AssertionError,
    util: utils_exports,
    config: config$2,
    expect,
    assert,
    Assertion,
    ...should_exports
  };
  if (!~used.indexOf(fn)) {
    fn(exports2, utils_exports);
    used.push(fn);
  }
  return exports2;
}
__name(use, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$1 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y2 = d * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type3 = (match[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
function setup$1(env) {
  createDebug2.debug = createDebug2;
  createDebug2.default = createDebug2;
  createDebug2.coerce = coerce2;
  createDebug2.disable = disable;
  createDebug2.enable = enable;
  createDebug2.enabled = enabled;
  createDebug2.humanize = requireMs$1();
  createDebug2.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug2[key] = env[key];
  });
  createDebug2.names = [];
  createDebug2.skips = [];
  createDebug2.formatters = {};
  function selectColor(namespace2) {
    let hash = 0;
    for (let i = 0; i < namespace2.length; i++) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i);
      hash |= 0;
    }
    return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
  }
  createDebug2.selectColor = selectColor;
  function createDebug2(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug2.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug2.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug2.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.useColors = createDebug2.useColors();
    debug2.color = createDebug2.selectColor(namespace2);
    debug2.extend = extend2;
    debug2.destroy = createDebug2.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug2.namespaces) {
          namespacesCache = createDebug2.namespaces;
          enabledCache = createDebug2.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug2.init === "function") {
      createDebug2.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace2, delimiter) {
    const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces2) {
    createDebug2.save(namespaces2);
    createDebug2.namespaces = namespaces2;
    createDebug2.names = [];
    createDebug2.skips = [];
    let i;
    const split = (typeof namespaces2 === "string" ? namespaces2 : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces2 = split[i].replace(/\*/g, ".*?");
      if (namespaces2[0] === "-") {
        createDebug2.skips.push(new RegExp("^" + namespaces2.slice(1) + "$"));
      } else {
        createDebug2.names.push(new RegExp("^" + namespaces2 + "$"));
      }
    }
  }
  function disable() {
    const namespaces2 = [
      ...createDebug2.names.map(toNamespace),
      ...createDebug2.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug2.enable("");
    return namespaces2;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug2.skips.length; i < len; i++) {
      if (createDebug2.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug2.names.length; i < len; i++) {
      if (createDebug2.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug2.enable(createDebug2.load());
  return createDebug2;
}
var common$1 = setup$1;
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces2) {
    try {
      if (namespaces2) {
        exports2.storage.setItem("debug", namespaces2);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = void 0;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = common$1(exports2);
  const { formatters } = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser$1, browser$1.exports);
var browserExports$1 = browser$1.exports;
const createDebug$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
const config$1 = {
  cacheResults: true,
  successMetric: "efficiency",
  calculateCuts: true,
  stack: true,
  findDuplicatePatterns: true,
  //dev specific
  captureProfile: false,
  runTests: false,
  throwErrorsOnFailedTests: false,
  recordPlacementPositions: false,
  sample: {
    enable: true,
    groupSize: 6,
    efficiency: 5,
    guillotine: 1
  },
  priority: {
    enable: true,
    variationThreshold: 0.3
  },
  secondRun: {
    enabled: false,
    efficiencyCutoff: 0.5,
    stack: false
  },
  efficiency: {
    tidy: false,
    //[] issue with picking winner when tidy is enabled
    rayCasting: true
  },
  groups: {
    shapeAreaCutOff: 0.7,
    tolerance: 0.04,
    guillotine: {
      strips: true,
      segments: true,
      runWithout: false
    },
    efficiency: {
      firstShapes: true,
      position: true,
      limit: 100
    }
  },
  guillotine: {
    viableShapeArea: 0.5,
    secondPass: true,
    strips: {
      rearrange: true,
      efficiencyThreshold: 0.7
    },
    stripShapes: {
      allocation: true,
      iterations: 6,
      numPriorityShapes: 1
    }
  },
  subset: {
    shuffles: 80,
    //this is the default - can be overwritten (for example when creating groups)
    guillotine: {
      shuffles: 80
    },
    efficiency: {
      limit: 0.5
    }
  },
  evo: {
    disable: false,
    stockLimit: 40
  }
};
config$2.showDiff = true;
const debug = createDebug$1("tests");
createDebug$1("timers");
function isDev() {
  if (typeof process !== "undefined" && (process == null ? void 0 : process.env)) {
    return false;
  }
  return false;
}
function test(tests, issueMessage = null) {
  if (!(tests == null ? void 0 : tests.length)) return;
  if (isDev() && config$1.runTests) {
    tests.forEach((test2) => {
      try {
        test2();
      } catch (e) {
        if (issueMessage) {
          debug(issueMessage, e.message);
        } else {
          debug(e.message);
        }
      }
    });
  }
}
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y2 = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type3 = (match[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
function setup(env) {
  createDebug2.debug = createDebug2;
  createDebug2.default = createDebug2;
  createDebug2.coerce = coerce2;
  createDebug2.disable = disable;
  createDebug2.enable = enable;
  createDebug2.enabled = enabled;
  createDebug2.humanize = requireMs();
  createDebug2.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug2[key] = env[key];
  });
  createDebug2.names = [];
  createDebug2.skips = [];
  createDebug2.formatters = {};
  function selectColor(namespace2) {
    let hash = 0;
    for (let i = 0; i < namespace2.length; i++) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i);
      hash |= 0;
    }
    return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
  }
  createDebug2.selectColor = selectColor;
  function createDebug2(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug2.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug2.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug2.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.useColors = createDebug2.useColors();
    debug2.color = createDebug2.selectColor(namespace2);
    debug2.extend = extend2;
    debug2.destroy = createDebug2.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug2.namespaces) {
          namespacesCache = createDebug2.namespaces;
          enabledCache = createDebug2.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug2.init === "function") {
      createDebug2.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace2, delimiter) {
    const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces2) {
    createDebug2.save(namespaces2);
    createDebug2.namespaces = namespaces2;
    createDebug2.names = [];
    createDebug2.skips = [];
    let i;
    const split = (typeof namespaces2 === "string" ? namespaces2 : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces2 = split[i].replace(/\*/g, ".*?");
      if (namespaces2[0] === "-") {
        createDebug2.skips.push(new RegExp("^" + namespaces2.slice(1) + "$"));
      } else {
        createDebug2.names.push(new RegExp("^" + namespaces2 + "$"));
      }
    }
  }
  function disable() {
    const namespaces2 = [
      ...createDebug2.names.map(toNamespace),
      ...createDebug2.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug2.enable("");
    return namespaces2;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug2.skips.length; i < len; i++) {
      if (createDebug2.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug2.names.length; i < len; i++) {
      if (createDebug2.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug2.enable(createDebug2.load());
  return createDebug2;
}
var common = setup;
(function(module2, exports2) {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces2) {
    try {
      if (namespaces2) {
        exports2.storage.setItem("debug", namespaces2);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = void 0;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = common(exports2);
  const { formatters } = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const createDebug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
createDebug.colors = [
  2,
  3,
  4,
  5,
  7,
  9,
  10,
  11,
  14,
  159
];
createDebug("logs");
createDebug("cuts");
createDebug("guillotine");
createDebug("results");
createDebug("scoring");
createDebug("calculations");
createDebug("subset");
createDebug("secondRun");
createDebug("stack");
const errorDebug = createDebug("errors");
createDebug("allStock");
errorDebug.color = 1;
function getCutLength(cut) {
  if (cut == null ? void 0 : cut.direction) {
    switch (cut.direction) {
      case "l":
        return cut.x2 - cut.x1;
      case "w":
        return cut.y2 - cut.y1;
    }
  }
  switch (cut.type) {
    case "top":
    case "bottom":
      return cut.x2 - cut.x1;
    case "left":
    case "right":
      return cut.y2 - cut.y1;
  }
  return 0;
}
class Cut extends Line {
  //used to mark for removal
  constructor(data) {
    var _a2, _b, _c, _d;
    if (data.x2 < data.x1) [data.x1, data.x2] = [data.x2, data.x1];
    if (data.y2 < data.y1) [data.y1, data.y2] = [data.y2, data.y1];
    super(data);
    __publicField(this, "stock");
    __publicField(this, "stockId");
    __publicField(this, "guillotine");
    __publicField(this, "guillotineData");
    __publicField(this, "isTrim");
    __publicField(this, "distances");
    __publicField(this, "beamTrimX1");
    __publicField(this, "beamTrimY1");
    __publicField(this, "type", null);
    __publicField(this, "remove");
    if (valueSet(data == null ? void 0 : data.stock)) {
      if (((_b = (_a2 = data.stock) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name) === "Stock")
        this.stock = data.stock;
      else this.stock = new Stock(data.stock);
      this.stockId = this.stock.id;
    }
    this.stockId = (_c = data == null ? void 0 : data.stock) == null ? void 0 : _c.id;
    this.type = data.type ?? null;
    this.guillotine = data.guillotine;
    this.guillotineData = valueSet(data.guillotineData) ? data.guillotineData : {};
    this.guillotineData.ptxDummyCut = (data == null ? void 0 : data.ptxDummyCut) || ((_d = data == null ? void 0 : data.guillotineData) == null ? void 0 : _d.ptxDummyCut) || false;
    this.isTrim = valueSet(data.isTrim) ? data.isTrim : false;
    this.distances = valueSet(data.distances) ? data.distances : {};
    this.beamTrimX1 = data.beamTrimX1;
    this.beamTrimY1 = data.beamTrimY1;
  }
  //compress for saving / transfer
  compress() {
    var _a2;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((_a2 = this == null ? void 0 : this.stock) == null ? void 0 : _a2.id);
    delete this.shapeCollisions;
    delete this.stock;
  }
  clone() {
    const data = structuredClone(this);
    return new Cut(data);
  }
  getCoordinates() {
    return {
      x1: this.x1,
      x2: this.x2,
      y1: this.y1,
      y2: this.y2
    };
  }
  trim() {
    if (this.direction === "l") {
      this.x1 = this.x1 < 0 ? 0 : this.x1;
      this.x2 = this.x2 > this.stock.l ? this.stock.l : this.x2;
    } else if (this.direction === "w") {
      this.y1 = this.y1 < 0 ? 0 : this.y1;
      this.y2 = this.y2 > this.stock.w ? this.stock.w : this.y2;
    }
  }
  lookupDirectionByType(type3) {
    const directionLookup = {
      top: "l",
      bottom: "l",
      left: "w",
      right: "w"
    };
    const result = directionLookup[type3];
    if (result) return result;
    throw new Error("no direction found in lookupDirectionByType");
  }
  isInsideStock() {
    switch (this.type) {
      case "bottom":
        return maths.greaterThan(
          this.y1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "left":
        return maths.greaterThan(
          this.x1 + this.stock.getBladeWidth() / 2,
          0
        );
      case "top":
        return maths.lessThan(
          this.y1 - this.stock.getBladeWidth() / 2,
          this.stock.w
        );
      case "right":
        return maths.lessThan(
          this.x1 - this.stock.getBladeWidth() / 2,
          this.stock.l
        );
      default:
        return true;
    }
  }
  /**
      * the cuts are visualised differently from their exact dimensions
      * @param {string} coord
      */
  getVisCoords(coord) {
    return this[coord];
  }
  getLength() {
    return getCutLength(this);
  }
  getArea() {
    const cutLength = this.getLength();
    if (cutLength) return cutLength * this.stock.getBladeWidth();
    return 0;
  }
}
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
var MAX_CYCLE_LEN = 2e3;
var P = {
  "s": 1,
  "n": 0,
  "d": 1
};
function assign(n, s) {
  if (isNaN(n = parseInt(n, 10))) {
    throw InvalidParameter();
  }
  return n * s;
}
function newFraction(n, d) {
  if (d === 0) {
    throw DivisionByZero();
  }
  var f = Object.create(Fraction.prototype);
  f["s"] = n < 0 ? -1 : 1;
  n = n < 0 ? -n : n;
  var a2 = gcd(n, d);
  f["n"] = n / a2;
  f["d"] = d / a2;
  return f;
}
function factorize(num) {
  var factors = {};
  var n = num;
  var i = 2;
  var s = 4;
  while (s <= n) {
    while (n % i === 0) {
      n /= i;
      factors[i] = (factors[i] || 0) + 1;
    }
    s += 1 + 2 * i++;
  }
  if (n !== num) {
    if (n > 1)
      factors[n] = (factors[n] || 0) + 1;
  } else {
    factors[num] = (factors[num] || 0) + 1;
  }
  return factors;
}
var parse$3 = function(p1, p2) {
  var n = 0, d = 1, s = 1;
  var v = 0, w = 0, x = 0, y2 = 1, z = 1;
  var A = 0, B = 1;
  var C = 1, D = 1;
  var N = 1e7;
  var M;
  if (p1 === void 0 || p1 === null) ;
  else if (p2 !== void 0) {
    n = p1;
    d = p2;
    s = n * d;
    if (n % 1 !== 0 || d % 1 !== 0) {
      throw NonIntegerParameter();
    }
  } else
    switch (typeof p1) {
      case "object": {
        if ("d" in p1 && "n" in p1) {
          n = p1["n"];
          d = p1["d"];
          if ("s" in p1)
            n *= p1["s"];
        } else if (0 in p1) {
          n = p1[0];
          if (1 in p1)
            d = p1[1];
        } else {
          throw InvalidParameter();
        }
        s = n * d;
        break;
      }
      case "number": {
        if (p1 < 0) {
          s = p1;
          p1 = -p1;
        }
        if (p1 % 1 === 0) {
          n = p1;
        } else if (p1 > 0) {
          if (p1 >= 1) {
            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
            p1 /= z;
          }
          while (B <= N && D <= N) {
            M = (A + C) / (B + D);
            if (p1 === M) {
              if (B + D <= N) {
                n = A + C;
                d = B + D;
              } else if (D > B) {
                n = C;
                d = D;
              } else {
                n = A;
                d = B;
              }
              break;
            } else {
              if (p1 > M) {
                A += C;
                B += D;
              } else {
                C += A;
                D += B;
              }
              if (B > N) {
                n = C;
                d = D;
              } else {
                n = A;
                d = B;
              }
            }
          }
          n *= z;
        } else if (isNaN(p1) || isNaN(p2)) {
          d = n = NaN;
        }
        break;
      }
      case "string": {
        B = p1.match(/\d+|./g);
        if (B === null)
          throw InvalidParameter();
        if (B[A] === "-") {
          s = -1;
          A++;
        } else if (B[A] === "+") {
          A++;
        }
        if (B.length === A + 1) {
          w = assign(B[A++], s);
        } else if (B[A + 1] === "." || B[A] === ".") {
          if (B[A] !== ".") {
            v = assign(B[A++], s);
          }
          A++;
          if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
            w = assign(B[A], s);
            y2 = Math.pow(10, B[A].length);
            A++;
          }
          if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
            x = assign(B[A + 1], s);
            z = Math.pow(10, B[A + 1].length) - 1;
            A += 3;
          }
        } else if (B[A + 1] === "/" || B[A + 1] === ":") {
          w = assign(B[A], s);
          y2 = assign(B[A + 2], 1);
          A += 3;
        } else if (B[A + 3] === "/" && B[A + 1] === " ") {
          v = assign(B[A], s);
          w = assign(B[A + 2], s);
          y2 = assign(B[A + 4], 1);
          A += 5;
        }
        if (B.length <= A) {
          d = y2 * z;
          s = /* void */
          n = x + d * v + z * w;
          break;
        }
      }
      default:
        throw InvalidParameter();
    }
  if (d === 0) {
    throw DivisionByZero();
  }
  P["s"] = s < 0 ? -1 : 1;
  P["n"] = Math.abs(n);
  P["d"] = Math.abs(d);
};
function modpow(b, e, m) {
  var r2 = 1;
  for (; e > 0; b = b * b % m, e >>= 1) {
    if (e & 1) {
      r2 = r2 * b % m;
    }
  }
  return r2;
}
function cycleLen(n, d) {
  for (; d % 2 === 0; d /= 2) {
  }
  for (; d % 5 === 0; d /= 5) {
  }
  if (d === 1)
    return 0;
  var rem = 10 % d;
  var t2 = 1;
  for (; rem !== 1; t2++) {
    rem = rem * 10 % d;
    if (t2 > MAX_CYCLE_LEN)
      return 0;
  }
  return t2;
}
function cycleStart(n, d, len) {
  var rem1 = 1;
  var rem2 = modpow(10, len, d);
  for (var t2 = 0; t2 < 300; t2++) {
    if (rem1 === rem2)
      return t2;
    rem1 = rem1 * 10 % d;
    rem2 = rem2 * 10 % d;
  }
  return 0;
}
function gcd(a2, b) {
  if (!a2)
    return b;
  if (!b)
    return a2;
  while (1) {
    a2 %= b;
    if (!a2)
      return b;
    b %= a2;
    if (!b)
      return a2;
  }
}
function Fraction(a2, b) {
  parse$3(a2, b);
  if (this instanceof Fraction) {
    a2 = gcd(P["d"], P["n"]);
    this["s"] = P["s"];
    this["n"] = P["n"] / a2;
    this["d"] = P["d"] / a2;
  } else {
    return newFraction(P["s"] * P["n"], P["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  "s": 1,
  "n": 0,
  "d": 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a2, b) {
    parse$3(a2, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a2, b) {
    parse$3(a2, b);
    return newFraction(
      this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a2, b) {
    parse$3(a2, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["n"],
      this["d"] * P["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a2, b) {
    parse$3(a2, b);
    return newFraction(
      this["s"] * P["s"] * this["n"] * P["d"],
      this["d"] * P["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  "mod": function(a2, b) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    if (a2 === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], 1);
    }
    parse$3(a2, b);
    if (0 === P["n"] && 0 === this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
      P["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a2, b) {
    parse$3(a2, b);
    return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a2, b) {
    parse$3(a2, b);
    if (P["n"] === 0 && this["n"] === 0) {
      return newFraction(0, 1);
    }
    return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  "roundTo": function(a2, b) {
    parse$3(a2, b);
    return newFraction(this["s"] * Math.round(this["n"] * P["d"] / (this["d"] * P["n"])) * P["n"], P["d"]);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a2, b) {
    parse$3(a2, b);
    if (P["d"] === 1) {
      if (P["s"] < 0) {
        return newFraction(Math.pow(this["s"] * this["d"], P["n"]), Math.pow(this["n"], P["n"]));
      } else {
        return newFraction(Math.pow(this["s"] * this["n"], P["n"]), Math.pow(this["d"], P["n"]));
      }
    }
    if (this["s"] < 0) return null;
    var N = factorize(this["n"]);
    var D = factorize(this["d"]);
    var n = 1;
    var d = 1;
    for (var k in N) {
      if (k === "1") continue;
      if (k === "0") {
        n = 0;
        break;
      }
      N[k] *= P["n"];
      if (N[k] % P["d"] === 0) {
        N[k] /= P["d"];
      } else return null;
      n *= Math.pow(k, N[k]);
    }
    for (var k in D) {
      if (k === "1") continue;
      D[k] *= P["n"];
      if (D[k] % P["d"] === 0) {
        D[k] /= P["d"];
      } else return null;
      d *= Math.pow(k, D[k]);
    }
    if (P["s"] < 0) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a2, b) {
    parse$3(a2, b);
    return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "compare": function(a2, b) {
    parse$3(a2, b);
    var t2 = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
    return (0 < t2) - (t2 < 0);
  },
  "simplify": function(eps) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return this;
    }
    eps = eps || 1e-3;
    var thisABS = this["abs"]();
    var cont = thisABS["toContinued"]();
    for (var i = 1; i < cont.length; i++) {
      var s = newFraction(cont[i - 1], 1);
      for (var k = i - 2; k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a2, b) {
    parse$3(a2, b);
    return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return this["s"] * this["n"] / this["d"];
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  "toFraction": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        str += " ";
        n %= d;
      }
      str += n;
      str += "/";
      str += d;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        n %= d;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    var t2;
    var a2 = this["n"];
    var b = this["d"];
    var res = [];
    if (isNaN(a2) || isNaN(b)) {
      return res;
    }
    do {
      res.push(Math.floor(a2 / b));
      t2 = a2 % b;
      a2 = b;
      b = t2;
    } while (a2 !== 1);
    return res;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec) {
    var N = this["n"];
    var D = this["d"];
    if (isNaN(N) || isNaN(D)) {
      return "NaN";
    }
    dec = dec || 15;
    var cycLen = cycleLen(N, D);
    var cycOff = cycleStart(N, D, cycLen);
    var str = this["s"] < 0 ? "-" : "";
    str += N / D | 0;
    N %= D;
    N *= 10;
    if (N)
      str += ".";
    if (cycLen) {
      for (var i = cycOff; i--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
      str += "(";
      for (var i = cycLen; i--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
      str += ")";
    } else {
      for (var i = dec; N && i--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
    }
    return str;
  }
};
function localeParseFloat(s) {
  if (!s) return null;
  s = s.toString().trim();
  if (typeof navigator === "undefined" || typeof navigator.language === "undefined")
    return parseFloat(s);
  const { thousandsSeparator, decimalSeparator } = getSeparators();
  s = Array.from(s, (c2) => c2 === thousandsSeparator ? "" : c2 === decimalSeparator ? "." : c2).join("");
  return parseFloat(s);
}
function getSeparators() {
  const locale2 = navigator.language;
  const formattedNumber = 123456789e-2.toLocaleString(locale2);
  const withoutDigits = formattedNumber.replace(/\d/g, "");
  const uniqueCharacters = Array.from(new Set(withoutDigits.split("")));
  let thousandsSeparator = "";
  let decimalSeparator = "";
  if (uniqueCharacters.length === 1) {
    decimalSeparator = uniqueCharacters[0];
  } else if (uniqueCharacters.length === 2) {
    const lastCharacter = formattedNumber[formattedNumber.length - 3];
    if (uniqueCharacters.includes(lastCharacter)) {
      decimalSeparator = lastCharacter;
      thousandsSeparator = uniqueCharacters.find((char) => char !== lastCharacter);
    } else {
      decimalSeparator = uniqueCharacters[1];
      thousandsSeparator = uniqueCharacters[0];
    }
  }
  return { thousandsSeparator, decimalSeparator };
}
function detectFraction(inputString) {
  if (!inputString) return false;
  if (typeof inputString === "number") return false;
  inputString = inputString.toString().replace(/[^0-9/ ]/g, "");
  const fractionRegex = /\b\d+\/\d+\b/g;
  return inputString.match(fractionRegex);
}
function cleanNumericInput(input, parseLocale = false) {
  if (!valueSet(input)) return null;
  if (input === 0) return "0";
  let cleanValue = input.toString().trim();
  if (!cleanValue) return null;
  if (detectFraction(input)) {
    cleanValue = cleanValue.replace(/[^0-9/,. -]/g, "").replace(/  +/g, " ");
    return cleanValue;
  } else {
    cleanValue = cleanValue.replace(/[^0-9,. -]/g, "");
    if (cleanValue.startsWith(".")) cleanValue = "0" + cleanValue;
    let parsed;
    if (parseLocale) {
      parsed = localeParseFloat(cleanValue);
    } else {
      parsed = parseFloat(cleanValue);
    }
    if (parsed) return parsed.toString();
    return null;
  }
}
function convertUnit(value2, to = "decimal", decimalPlaces = false, parseLocale = false, fractionRoundTo = 0) {
  if (!valueSet(value2) || !to) return null;
  if (to !== "decimal" && to !== "fraction") {
    console.error("incorrect conversion type specified for convertUnit");
    return null;
  }
  try {
    const stringValue = cleanNumericInput(value2, parseLocale);
    if (!stringValue) return 0;
    let parsed;
    if (to === "fraction") {
      if (detectFraction(stringValue)) {
        parsed = new Fraction(stringValue);
      } else {
        const number2 = parseFloat(stringValue);
        if (Number.isInteger(number2)) {
          parsed = new Fraction(stringValue);
        } else {
          parsed = new Fraction(number2);
        }
      }
    } else parsed = new Fraction(stringValue);
    switch (to) {
      case "fraction":
        if (fractionRoundTo > 0) {
          const decimalValue = parsed.valueOf();
          const rounded = Math.round(decimalValue * fractionRoundTo) / fractionRoundTo;
          parsed = new Fraction(rounded);
        }
        return parsed.toFraction(true);
      case "decimal":
        if (decimalPlaces === false || typeof decimalPlaces !== "number") {
          return parsed.valueOf();
        } else {
          const value22 = parsed.valueOf();
          if (value22 === 0) {
            return 0;
          }
          return parseFloat(value22.toFixed(decimalPlaces));
        }
      default:
        return 0;
    }
  } catch (e) {
    console.error(e);
    return 0;
  }
}
function isDecimal(num) {
  let parsed = num;
  if (typeof num !== "number") {
    parsed = parseFloat(num);
  }
  return parsed % 1 !== 0;
}
const validation = {
  customData: (val) => {
    const issues = [];
    if (typeof val !== "object") {
      issues.push("Custom data must be an object.");
      return issues;
    }
    Object.entries(val).forEach(([key, value2]) => {
      if (valueSet(value2)) {
        if (!["string", "number", "boolean"].includes(typeof value2)) {
          issues.push(`Custom data ${key} must be a string, number or boolean.`);
        }
      }
    });
    return issues;
  },
  banding: (val) => {
    const issues = [];
    if (!valueSet(val)) return [];
    if (typeof val !== "object") {
      issues.push("Banding must be an object.");
      return issues;
    }
    Object.entries(val).forEach(([key, value2]) => {
      if (valueSet(value2)) {
        if (value2 !== true && value2 !== false) {
          issues.push(`Banding ${key} must be a boolean.`);
        }
      }
    });
  },
  //when trim provided as number
  partTrim(s, partTrim) {
    partTrim = convertUnit(partTrim);
    const l = convertUnit(s.l);
    const w = convertUnit(s.w);
    const trimmedL = l - partTrim * 2;
    const trimmedW = w - partTrim * 2;
    if (trimmedL < 0 || trimmedW < 0) {
      return [
        `When applying trim of ${partTrim}, part is ${trimmedL} x ${trimmedW}.`
      ];
    }
    return [];
  },
  //when trim provided as object
  trim: (s) => {
    const issues = [];
    if (!valueSet(s.trim)) return issues;
    ["x1", "x2", "y1", "y2"].forEach((key) => {
      if (!valueSet(s.trim[key])) {
        s.trim[key] = 0;
      }
    });
    if (!isStock(s) || isStock(s) && !(s == null ? void 0 : s.trimmed)) {
      const l = convertUnit(s.l);
      const w = convertUnit(s.w);
      const x1 = convertUnit(s.trim.x1);
      const x2 = convertUnit(s.trim.x2);
      const y1 = convertUnit(s.trim.y1);
      const y2 = convertUnit(s.trim.y2);
      const variables = { x1, x2, y1, y2 };
      Object.entries(variables).forEach(([key, value2]) => {
        if (isNaN(value2)) {
          issues.push(`The value of trim ${userFriendlyFieldMap[key]} is not understood.`);
        }
      });
      if (l && w && l > 0 && w > 0) {
        if (x1 + x2 >= s.l)
          issues.push(`Trim W1 + W2 = ${x1 + x2}, which is greater than or equal to total length of ${l}.`);
        if (y2 + y2 >= s.w)
          issues.push(`Trim L1 + L2 = ${y1 + y2}, which is greater than or equal to total width of ${w}.`);
      }
    }
    return issues;
  },
  x: (val) => {
    const issues = [];
    if (!valueSet(val)) {
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push("X value is not understood.");
      return issues;
    }
    if (val < 0) issues.push("X must be greater than or equal to zero.");
    return issues;
  },
  y: (val) => {
    const issues = [];
    if (!valueSet(val)) {
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) issues.push("Y value is not understood.");
    if (val < 0) issues.push("Y must be greater than or equal to zero.");
    return issues;
  },
  l: (val) => {
    const issues = [];
    if (!valueSet(val)) {
      issues.push("Length is required.");
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push("Width value is not understood.");
      return issues;
    }
    if (val <= 0) issues.push(`Length must be greater than zero, got ${val}`);
    return issues;
  },
  w: (val) => {
    const issues = [];
    if (!valueSet(val)) {
      issues.push("Width is required.");
      return issues;
    }
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push("Width value is not understood.");
      return issues;
    }
    if (val <= 0) issues.push(`Width must be greater than zero, got ${val}`);
    return issues;
  },
  t: (val) => {
    const issues = [];
    if (!valueSet(val) || val === "") return issues;
    val = convertUnit(val);
    if (isNaN(val)) {
      issues.push("Thickness value is not understood.");
      return issues;
    }
    if (val && val <= 0) issues.push(`Thickness must be greater than zero, got ${val}`);
    return issues;
  },
  q: (val, autoAdd = null) => {
    const issues = [];
    if (!valueSet(val)) {
      issues.push("Quantity should be set.");
      return issues;
    }
    val = parseInt(val);
    if (isNaN(val)) {
      issues.push("Quantity value is not understood.");
      return issues;
    }
    if (isDecimal(val)) {
      issues.push("Quantity should be an integer.");
    }
    if (val <= 0) {
      if (!autoAdd) {
        issues.push("Quantity should be greater than or equal to zero.");
      }
    }
    return issues;
  },
  orientationLock: (val) => {
    const issues = [];
    if (!valueSet(val)) return issues;
    val = val.toLowerCase();
    if (val !== "l" && val !== "w")
      issues.push(`Orientation lock must be l or w, got ${val}`);
    return issues;
  },
  grain: (val) => {
    const issues = [];
    if (!valueSet(val)) return issues;
    val = val.toLowerCase();
    if (val !== "l" && val !== "w") issues.push("Grain must be l or w.");
    return issues;
  },
  stockMatch: (inputShape, inputStockList, stockType, partTrim = 0) => {
    if (!inputShape.q) return [];
    inputShape.applyPartTrim(partTrim);
    if (inputShape.issues.length) return [];
    const matchResult = stockMatch([inputShape], inputStockList, stockType);
    if (!matchResult) return [];
    const issues = [];
    if (matchResult.unusableShapes.length) {
      const s = matchResult.unusableShapes[0];
      const stockMatchData = s.stockMatch;
      if (!stockMatchData.fit) {
        const dims = s.getTrimmedDimensions();
        issues.push(`${dims.l.toFixed(0)}x${dims.w.toFixed(0)} will not fit on any stock - check trim, dimensions & orientation lock.`);
      }
      if (!stockMatchData.material) {
        issues.push("No matching stock material found.");
      }
      if (!stockMatchData.thickness) {
        issues.push("No matching stock thickness found.");
      }
      if (!stockMatchData.width && stockType === "linear") {
        issues.push("No matching stock width found - required for linear calculations.");
      }
    }
    return issues;
  },
  machining: (inputShape) => {
    inputShape.machining.validateEverything(inputShape);
  }
};
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
var nativeObjectToString$1 = objectProto$6.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$4.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$5 = Object.prototype;
var nativeObjectToString = objectProto$5.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var isArray = Array.isArray;
function isObject$2(value2) {
  var type3 = typeof value2;
  return value2 != null && (type3 == "object" || type3 == "function");
}
function identity(value2) {
  return value2;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject$2(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$4 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject$2(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative(object2, key) {
  var value2 = getValue(object2, key);
  return baseIsNative(value2) ? value2 : void 0;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value2) {
  return function() {
    return value2;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var baseSetToString = !defineProperty ? identity : function(func, string2) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string2),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length2) {
  var type3 = typeof value2;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type3 == "number" || type3 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var nativeMax = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array2 = Array(length2);
    while (++index < length2) {
      array2[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform2(array2);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction(value2);
}
function isIterateeCall(value2, index, object2) {
  if (!isObject$2(object2)) {
    return false;
  }
  var type3 = typeof index;
  if (type3 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type3 == "string" && index in object2) {
    return eq(object2[index], value2);
  }
  return false;
}
var objectProto$3 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value2 === proto;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var argsTag$1 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$1;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
  for (var key in value2) {
    if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject$2(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeysIn(object2);
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var defaults = baseRest(function(object2, sources) {
  object2 = Object(object2);
  var index = -1;
  var length2 = sources.length;
  var guard = length2 > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length2 = 1;
  }
  while (++index < length2) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value2 = object2[key];
      if (value2 === void 0 || eq(value2, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
        object2[key] = source[key];
      }
    }
  }
  return object2;
});
function extrasValidation(item, extras, issues, index) {
  Object.keys(extras).forEach((key) => {
    var _a2, _b;
    if (key in item) {
      if (((_a2 = extras[key]) == null ? void 0 : _a2.min) && convertUnit(item[key]) < convertUnit(extras[key].min)) {
        issues.push({
          index,
          message: `${key.charAt(0).toUpperCase() + key.slice(1)} cannot be less than ${extras[key].min}.`,
          fields: [key]
        });
      } else if (((_b = extras[key]) == null ? void 0 : _b.max) && convertUnit(item[key]) > convertUnit(extras[key].max)) {
        issues.push({
          index,
          message: `${key.charAt(0).toUpperCase() + key.slice(1)} cannot be greater than ${extras[key].max}.`,
          fields: [key]
        });
      }
    }
  });
}
class Hole {
  constructor({ x, y: y2, diameter, depth = 0, side = 0, type: type3 = null }) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "diameter");
    __publicField(this, "depth");
    __publicField(this, "side");
    __publicField(this, "valid");
    __publicField(this, "type");
    this.x = x;
    this.y = y2;
    this.diameter = diameter;
    this.depth = depth;
    this.side = side;
    this.type = type3;
  }
  getXDrawPosition(shape) {
    let position = 0;
    const x = convertUnit(this.x);
    if (shape.rot) {
      position = shape.l - convertUnit(this.y) + ("x" in shape ? convertUnit(shape.x) : 0);
    } else {
      position = x + ("x" in shape ? convertUnit(shape.x) : 0);
    }
    return position;
  }
  getYDrawPosition(shape, viewingSide, stock) {
    let position = shape.rot ? convertUnit(this.x) : convertUnit(this.y);
    position += "y" in shape ? convertUnit(shape.y) : 0;
    if (viewingSide === 1)
      if (stock) {
        position = convertUnit(stock.w) - position;
      } else {
        position = convertUnit(shape.w) - position;
      }
    return position;
  }
  shouldShow(shape, side) {
    if (this.side === side) return true;
    if (this.isThroughShape(shape) === true) return true;
    return false;
  }
  isThroughShape(shape) {
    return !this.depth || convertUnit(this.depth) >= convertUnit(shape.t);
  }
  getDistanceToEdge(shape) {
    const holeCenterX = this.x;
    const holeCenterY = this.y;
    const holeRadius = this.diameter / 2;
    const shapeLength = convertUnit(shape.getLongSide());
    const shapeWidth = convertUnit(shape.getShortSide());
    const cornerRadii = shape.machining.corners.map((c2) => c2.type ? c2.size : 0);
    const edgeDistances = [
      {
        edge: "left",
        distance: holeCenterX - holeRadius
      },
      {
        edge: "right",
        distance: shapeLength - holeCenterX - holeRadius
      },
      {
        edge: "bottom",
        distance: shapeWidth - holeCenterY - holeRadius
      },
      {
        edge: "top",
        distance: holeCenterY - holeRadius
      }
    ];
    const cornerDistances = shape.machining.corners.map((c2, index) => {
      const isLeft = index === 0 || index === 3;
      const isBottom = index < 2;
      const x = isLeft ? holeCenterX : shapeLength - holeCenterX;
      let y2 = null;
      if (this.side === 0) {
        y2 = isBottom ? holeCenterY : shapeWidth - holeCenterY;
      } else if (this.side === 1) {
        y2 = isBottom ? shapeWidth - holeCenterY : holeCenterY;
      }
      const distance = Math.sqrt(x * x + y2 * y2);
      return {
        c: c2,
        distance
      };
    });
    const distanceToNearestEdge = Math.min(...edgeDistances.map((d) => d.distance));
    const distanceToNearestCorner = Math.min(...cornerDistances.map((d) => d.distance));
    const closestCornerIndex = cornerDistances.findIndex((d) => d.distance === distanceToNearestCorner);
    const closestCorner = shape.machining.corners[closestCornerIndex];
    if (closestCorner && closestCorner.type === "radius") {
      let cornerCenterX = closestCornerIndex === 0 || closestCornerIndex === 3 ? 0 : shapeLength;
      let cornerCenterY = closestCornerIndex < 2 ? 0 : shapeWidth;
      const isBottomCorner = closestCornerIndex < 2;
      const isLeftCorner = closestCornerIndex === 0 || closestCornerIndex === 3;
      cornerCenterX += isLeftCorner ? cornerRadii[closestCornerIndex] : -cornerRadii[closestCornerIndex];
      cornerCenterY += isBottomCorner ? cornerRadii[closestCornerIndex] : -cornerRadii[closestCornerIndex];
      const dx = holeCenterX - cornerCenterX;
      const isBottom = closestCornerIndex < 2;
      let y2;
      if (this.side === 0) {
        y2 = isBottom ? holeCenterY : shapeWidth - holeCenterY;
      } else if (this.side === 1) {
        y2 = isBottom ? shapeWidth - holeCenterY : holeCenterY;
      }
      const dy = y2 - cornerCenterY;
      const distanceToCornerCenter = Math.sqrt(dx * dx + dy * dy);
      const distanceToCornerEdge = cornerRadii[closestCornerIndex] - distanceToCornerCenter - holeRadius;
      let inCorrectQuadrant = false;
      if (closestCorner.index === 0) {
        inCorrectQuadrant = holeCenterX <= cornerCenterX && y2 <= cornerCenterY;
      } else if (closestCorner.index === 1) {
        inCorrectQuadrant = holeCenterX >= cornerCenterX && y2 <= cornerCenterY;
      } else if (closestCorner.index === 2) {
        inCorrectQuadrant = holeCenterX >= cornerCenterX && y2 >= cornerCenterY;
      } else if (closestCorner.index === 3) {
        inCorrectQuadrant = holeCenterX <= cornerCenterX && y2 >= cornerCenterY;
      }
      return inCorrectQuadrant && distanceToCornerEdge < distanceToNearestEdge ? distanceToCornerEdge : distanceToNearestEdge;
    } else if (closestCorner && closestCorner.type === "bevel") {
      let A, B, C;
      if (closestCorner.index === 0) {
        A = 1;
        B = 1;
        C = -closestCorner.size;
      } else if (closestCorner.index === 1) {
        A = 1;
        B = -1;
        C = -shapeLength + closestCorner.size;
      } else if (closestCorner.index === 2) {
        A = 1;
        B = 1;
        C = -shapeLength - shapeWidth + closestCorner.size;
      } else if (closestCorner.index === 3) {
        A = -1;
        B = 1;
        C = -shapeWidth + closestCorner.size;
      }
      const multiplier = closestCorner.index === 0 ? 1 : -1;
      const distanceToBevelEdge = (A * holeCenterX + B * holeCenterY + C) / Math.sqrt(A * A + B * B) * multiplier - holeRadius;
      return distanceToBevelEdge < distanceToNearestEdge ? distanceToBevelEdge : distanceToNearestEdge;
    } else {
      return distanceToNearestEdge;
    }
  }
  validate(shape, index, extras = null) {
    const issues = [];
    if (!valueSet(this.x) || !valueSet(this.y) || !valueSet(this.diameter)) {
      const issue = {
        index,
        message: "X, Y & diameter are all required.",
        fields: []
      };
      if (!this.x) issue.fields.push("x");
      if (!this.y) issue.fields.push("y");
      if (!this.diameter) issue.fields.push("diameter");
      issues.push(issue);
    }
    if (convertUnit(this.diameter) <= 0) {
      issues.push({
        index,
        message: "Diameter cannot be negative or zero.",
        fields: ["diameter"]
      });
    }
    if (convertUnit(this.depth) < 0) {
      issues.push({
        index,
        message: "Depth cannot be negative.",
        fields: ["depth"]
      });
    }
    if ("t" in shape && convertUnit(shape.t) > 0) {
      if (convertUnit(this.depth) > convertUnit(shape.t)) {
        issues.push({
          index,
          message: "Depth cannot be greater than part thickness.",
          fields: ["depth"]
        });
      }
    }
    if (!("t" in shape) || !shape.t) {
      if (convertUnit(this.depth) > 0) {
        issues.push({
          index,
          message: "Part thickness is not defined.",
          fields: ["depth"]
        });
      }
    }
    const distanceToEdge = this.getDistanceToEdge(shape);
    if (distanceToEdge < 0) {
      issues.push({
        index,
        message: "Outside of part."
      });
    }
    if (extras) {
      extrasValidation(this, extras, issues, index);
    }
    if (!issues.length) this.valid = true;
    else this.valid = false;
    return issues;
  }
}
class HingeHoles {
  constructor({
    position = null,
    //from left or bottom
    edge = "x1",
    side = 0,
    numHoles = null,
    diameter = 0,
    depth = 0,
    distanceFromEdge = 0,
    outerSpacing = 0,
    hingeLength = 0,
    minimumHoleDistance = 0,
    positionLimit = 0
  }, shape) {
    __publicField(this, "position");
    __publicField(this, "edge");
    __publicField(this, "side");
    __publicField(this, "numHoles");
    __publicField(this, "holes", []);
    __publicField(this, "diameter");
    __publicField(this, "depth");
    __publicField(this, "distanceFromEdge");
    //from edge to center of hole
    __publicField(this, "outerSpacing");
    //from edge to center of hole
    __publicField(this, "hingeLength");
    __publicField(this, "minimumHoleDistance");
    __publicField(this, "positionLimit");
    __publicField(this, "valid");
    this.position = position;
    this.edge = edge;
    this.side = side;
    this.numHoles = numHoles;
    this.diameter = diameter;
    this.depth = depth;
    this.distanceFromEdge = distanceFromEdge;
    this.outerSpacing = outerSpacing;
    this.hingeLength = hingeLength;
    this.minimumHoleDistance = minimumHoleDistance;
    this.positionLimit = positionLimit;
    if (shape) {
      this.createHoles(shape);
    }
  }
  getHoleSpacing() {
    const totalSpace = convertUnit(this.hingeLength) - convertUnit(this.outerSpacing) * 2;
    const numSpaces = this.numHoles - 1;
    const holeSpacing = totalSpace / numSpaces;
    return holeSpacing;
  }
  getHoleXPosition(shape, index) {
    let position = 0;
    const spacing = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
        position = this.distanceFromEdge;
        break;
      case "x2":
        position = shape.getLongSide() - convertUnit(this.distanceFromEdge);
        break;
      case "y1":
      case "y2":
        position = convertUnit(this.position) + convertUnit(this.outerSpacing) + spacing * index;
        break;
    }
    return position;
  }
  getHoleYPosition(shape, index) {
    let position = 0;
    const spacing = this.getHoleSpacing();
    switch (this.edge) {
      case "x1":
      case "x2":
        position = convertUnit(this.position) + convertUnit(this.outerSpacing) + spacing * index;
        break;
      case "y1":
        position = convertUnit(this.distanceFromEdge);
        break;
      case "y2":
        position = shape.getShortSide() - convertUnit(this.distanceFromEdge);
        break;
    }
    return position;
  }
  createHoles(shape) {
    this.holes = [];
    for (let i = 0; i < this.numHoles; i++) {
      const hole = new Hole({
        x: this.getHoleXPosition(shape, i),
        y: this.getHoleYPosition(shape, i),
        diameter: this.diameter,
        depth: this.depth,
        side: this.side,
        type: "hinge"
      });
      this.holes.push(hole);
    }
    return this.holes;
  }
  validate(shape, index, extras = null) {
    const issues = [];
    this.holes.forEach((h2, i) => {
      const holeIssues = h2.validate(shape, i).map((m) => {
        m.index = index;
        m.message = `Hole ${i + 1}: ${m.message}`;
        return m;
      });
      issues.push(...holeIssues);
    });
    if (extras) {
      extrasValidation(this, extras, issues, index);
    }
    if (!issues.length) this.valid = true;
    else this.valid = false;
    return issues;
  }
}
class Corner {
  constructor({ type: type3 = "radius", size: size2, index }) {
    __publicField(this, "type");
    __publicField(this, "size");
    __publicField(this, "index");
    __publicField(this, "valid");
    this.type = type3;
    this.size = size2;
    this.index = index;
  }
  validate(shape, index) {
    const shortSide = shape.getShortSide();
    const messages2 = [];
    if (this.type === null) {
      this.size = null;
      const corner = ["a", "b", "c", "d"][this.index];
      shape.banding[corner] = false;
      shape.bandingType[corner] = "";
    }
    if (this.type && convertUnit(this.size) <= 0) {
      messages2.push({
        index,
        message: "Corner size cannot be zero or negative"
      });
    }
    if (this.type && convertUnit(this.size) > shortSide / 2) {
      this.size = shortSide / 2;
    }
    if (!messages2.length) this.valid = true;
    else this.valid = false;
    return messages2;
  }
  //get the coordinates of a corner in the clockwise direction
  /* getCoords( shape: Shape | InputShape, side: 0 | 1 ): { x1; x2; y1; y2 }
  	{
  		let x1, x2, y1, y2;
  		switch ( this.index )
  		{
  		case 0:
  			x1 = 0;
  			x2 = cu( this.size );
  			y1 = side === 0 ? cu( this.size ) : shape.getShortSide() - cu( this.size );
  			y2 = side === 0 ? 0 : shape.getShortSide();
  			break;
  		case 1:
  			x1 = shape.getLongSide() - cu( this.size );
  			x2 = shape.getLongSide();
  			y1 = side === 0 ? 0 : shape.getShortSide();
  			y2 = side === 0 ? cu( this.size ) : shape.getShortSide() - cu( this.size );
  			break;
  		case 2:
  			x1 = shape.getLongSide();
  			x2 = shape.getLongSide() - cu( this.size );
  			y1 = side === 0 ? shape.getShortSide() - cu( this.size ) : cu( this.size );
  			y2 = side === 0 ? shape.getShortSide() : 0;
  			break;
  		case 3:
  			x1 = cu( this.size );
  			x2 = 0;
  			y1 = side === 0 ? shape.getShortSide() : 0;
  			y2 = side === 0 ? shape.getShortSide() - cu( this.size ) : cu( this.size );
  			break;
  		}
  
  		return {
  			x1,
  			x2,
  			y1,
  			y2
  		};
  	} */
}
let Machining$1 = class Machining {
  //shelfHoles?: ShelfHoles[] = [];
  constructor({
    holes = [],
    hingeHoles = [],
    corners = []
  } = {}) {
    __publicField(this, "holes", []);
    __publicField(this, "corners", []);
    __publicField(this, "hingeHoles", []);
    if (corners && corners.length === 4) {
      this.corners = corners.map((c2) => new Corner(c2));
    } else {
      [0, 1, 2, 3].forEach((i) => {
        this.corners.push(new Corner({
          type: null,
          size: null,
          index: i
        }));
      });
    }
    if (holes) this.holes = holes.map((h2) => new Hole(h2));
    if (hingeHoles)
      this.hingeHoles = hingeHoles.map((h2) => new HingeHoles(h2));
  }
  validateEverything(shape) {
    const holeMessages = this.validate(shape, "holes");
    const hingeHolesMessages = this.validate(shape, "hingeHoles");
    const cornersMessages = this.validate(shape, "corners");
    shape.issues.push(...holeMessages.map((m) => {
      if (isShape(shape))
        return `Part ${shape.id} hole issue: ${m.message}`;
      return `Hole issue: ${m.message}`;
    }));
    shape.issues.push(...hingeHolesMessages.map((m) => {
      if (isShape(shape))
        return `Part ${shape.id} hinge hole issue: ${m.message}`;
      return `Hinge hole issue: ${m.message}`;
    }));
    shape.issues.push(...cornersMessages.map((m) => {
      if (isShape(shape))
        return `Part ${shape.id} corner issue: ${m.message}`;
      return `Corner issue: ${m.message}`;
    }));
  }
  validate(shape, type3, extras = null) {
    if (!shape) return [];
    if (!type3) return [];
    const messages2 = [];
    messages2.push(...this.validateAll(shape, type3, extras));
    return messages2;
  }
  validateAll(shape, item, extras = null) {
    if (!shape) return [];
    const messages2 = [];
    this[item].forEach((i, index) => messages2.push(...i.validate(shape, index, extras)));
    return messages2;
  }
  createHole(x, y2, diameter, depth = 0, side = 0) {
    const hole = new Hole({
      x,
      y: y2,
      diameter,
      depth,
      side
    });
    this.holes.push(hole);
    return hole;
  }
  createHingeHoles({
    numHoles,
    position,
    diameter,
    depth = 0,
    edge = "x1",
    side = 0,
    distanceFromEdge = 0,
    outerSpacing = 0,
    minimumHoleDistance = 0,
    hingeLength = 0
  }) {
    const hingeHoles = new HingeHoles({
      numHoles,
      position,
      //from left or bottom
      edge,
      side,
      diameter,
      depth,
      distanceFromEdge,
      outerSpacing,
      minimumHoleDistance,
      hingeLength
    });
    this.hingeHoles.push(hingeHoles);
    return hingeHoles;
  }
  updateHingeHoles(shape) {
    this.hingeHoles.forEach((h2) => h2.createHoles(shape));
  }
  getAllHingeHoles(shape) {
    const holes = [];
    this.hingeHoles.forEach((h2) => {
      if (h2.holes.length) holes.push(...h2.holes);
      else {
        h2.createHoles(shape);
        holes.push(...h2.holes);
      }
    });
    return holes;
  }
  getNumHoles() {
    return this.holes.length + this.hingeHoles.reduce(
      (total, hingeHoles) => total + hingeHoles.numHoles,
      0
    );
  }
  getNumCorners() {
    return this.corners.filter((c2) => c2.type !== null).length;
  }
};
function hasMachining(shape) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  if (!shape) return false;
  if (!(shape == null ? void 0 : shape.machining)) return false;
  if ((_b = (_a2 = shape.machining) == null ? void 0 : _a2.holes) == null ? void 0 : _b.length) return true;
  if ((_d = (_c = shape.machining) == null ? void 0 : _c.hingeHoles) == null ? void 0 : _d.length) return true;
  if ((_f = (_e = shape.machining) == null ? void 0 : _e.corners) == null ? void 0 : _f.length) {
    return (_h = (_g = shape.machining) == null ? void 0 : _g.corners) == null ? void 0 : _h.some((c2) => c2.type && c2.size);
  }
  return false;
}
class InputUserGroup {
  constructor(data = null) {
    __publicField(this, "id");
    //api
    __publicField(this, "listId");
    __publicField(this, "shapeListIds", []);
    __publicField(this, "shapes");
    __publicField(this, "direction");
    __publicField(this, "q");
    __publicField(this, "duplicate", false);
    __publicField(this, "issues", []);
    __publicField(this, "stockMatch");
    var _a2;
    this.listId = (data == null ? void 0 : data.listId) ? data.listId : Date.now().toString() + Math.ceil(Math.random() * 1e16);
    this.id = data == null ? void 0 : data.id;
    this.shapes = valueSet(data == null ? void 0 : data.shapes) ? data.shapes.map((s) => s.toString()) : [];
    this.shapeListIds = valueSet(data == null ? void 0 : data.shapeListIds) ? data.shapeListIds : [];
    this.direction = valueSet(data == null ? void 0 : data.direction) ? data.direction : "l";
    this.q = valueSet(data == null ? void 0 : data.q) ? data.q : 1;
    if (valueSet(data == null ? void 0 : data.shapeList) && ((_a2 = data.shapeList) == null ? void 0 : _a2.length)) {
      this.validate(data.shapeList);
    }
  }
  validate(shapeList = []) {
    var _a2, _b;
    this.issues = [];
    if (!(shapeList == null ? void 0 : shapeList.length))
      throw new Error("shapeList is required to validate user group");
    const allShapes = this.findShapes(shapeList);
    if (!allShapes.length) {
      this.issues.push("Must have 2 or more parts.");
      return this.issues;
    }
    const referenceShape = allShapes[0];
    if (isShape(referenceShape)) {
      if (!(this == null ? void 0 : this.shapes) || ((_a2 = this.shapes) == null ? void 0 : _a2.length) < 2) {
        this.issues.push("Must have 2 or more parts.");
        return this.issues;
      }
    } else {
      if (!(this == null ? void 0 : this.shapeListIds) || ((_b = this.shapeListIds) == null ? void 0 : _b.length) < 2) {
        this.issues.push("Must have 2 or more parts.");
        return this.issues;
      }
    }
    allShapes.forEach((s, i) => {
      if (!s.isSquare() && !["l", "w"].includes(s.orientationLock)) {
        this.issues.push(`Part in position ${i + 1} must have orientation lock set to be part of a group.`);
      }
    });
    if (this.issues.length) return this.issues;
    const joinDimension = getReverseDimension(this.direction);
    const referenceDimension = referenceShape.getTrimmedDimensions(true)[joinDimension];
    allShapes.forEach((s, i) => {
      if (s.id === referenceShape.id) return;
      const shapeDimension = s.getTrimmedDimensions(true)[joinDimension];
      if (!maths.equalTo(shapeDimension, referenceDimension)) {
        this.issues.push(`Part in position ${i + 1} final ${joinDimension === "l" ? "length" : "width"} is not correct for the group. Expected ${referenceDimension} and is ${shapeDimension}. Check the dimensions, trim & orientation lock.`);
      }
    });
    return this.issues;
  }
  findShapes(shapeList = []) {
    var _a2, _b;
    if (!shapeList.length) return [];
    let foundShapes = [];
    if (isInputShape(shapeList[0])) {
      if (!((_a2 = this.shapeListIds) == null ? void 0 : _a2.length)) return [];
      foundShapes = this.shapeListIds.map((s) => shapeList.find((shape) => {
        return shape.listId === s;
      })).filter((s) => s);
      if (!foundShapes.length)
        throw new Error("could not map group shapes to shape list");
      return foundShapes;
    } else {
      if (!((_b = this.shapes) == null ? void 0 : _b.length)) return [];
      const foundShapeIds = /* @__PURE__ */ new Set();
      foundShapes = this.shapes.map((s) => {
        const shape = shapeList.find((shape2) => shape2.parentID === s && !shape2.inUserGroup && !foundShapeIds.has(shape2.id));
        if (shape) {
          foundShapeIds.add(shape.id);
          return shape;
        }
        return null;
      }).filter((s) => s);
    }
    if (!foundShapes.length)
      throw new Error("could not map group shapes to shape list");
    return foundShapes;
  }
  populateParentID(shapeList) {
    var _a2;
    if (!(shapeList == null ? void 0 : shapeList.length)) return;
    if (!((_a2 = this == null ? void 0 : this.shapeListIds) == null ? void 0 : _a2.length)) return;
    this.shapes = this.shapeListIds.map((s) => {
      const index = shapeList.findIndex((shape) => shape.listId === s);
      return (index + 1).toString();
    });
  }
  //create a group from a user group
  createGroup(groupParentID = 0, groupIndex = 0, shapeList = [], stock = null) {
    if (!(shapeList == null ? void 0 : shapeList.length))
      throw new Error("some parts are required to create a user group");
    if (!isShape(shapeList[0]))
      throw new Error("shapeList must be of type Shape[]");
    const shapes = this.findShapes(shapeList);
    if (!shapes.length) return false;
    const referenceShape = shapes[0];
    shapes.forEach((s) => {
      const shapeIndex = shapeList.findIndex((sh) => !sh.inUserGroup && sh.parentID === s.parentID);
      if (shapeIndex === -1)
        throw new Error("shape not found in shapeList while creating user group.");
      shapeList.splice(shapeIndex, 1);
      s.setRotationToOrientationLockWithoutContainer();
      s.inUserGroup = true;
    });
    let l = 0;
    let w = 0;
    if (this.direction === "l") w = referenceShape.w;
    else l = referenceShape.l;
    let group;
    try {
      const groupData = {
        id: `ug${groupParentID}.${groupIndex}`,
        shapes,
        l,
        w,
        t: referenceShape == null ? void 0 : referenceShape.t,
        material: referenceShape == null ? void 0 : referenceShape.material,
        // joinDimension:
        //     referenceShape.l === l ? referenceShape.l : referenceShape.w,
        direction: this.direction,
        preventAutoRotation: true,
        container: stock,
        type: "user"
      };
      group = new Group(groupData);
    } catch (err) {
      console.error(err);
      return false;
    }
    group.parentID = `ug${groupParentID}`;
    if (stock) {
      group.updateShapeSpacing(stock);
    }
    return group;
  }
}
const userFriendlyFieldMap = {
  x: "x",
  y: "y",
  l: "length",
  w: "width",
  t: "thickness",
  q: "quantity",
  orientationLock: "rotation",
  name: "name",
  material: "material",
  banding: "banding",
  cost: "cost",
  grain: "grain",
  trim: "trim",
  x1: "w1",
  x2: "w2",
  y1: "l1",
  y2: "l2",
  all: "all"
};
function sanitiseData(object2) {
  if (!valueSet(object2) || typeof object2 !== "object") return {};
  object2 = { ...object2 };
  for (const [key, value2] of Object.entries(object2)) {
    if (key === "_id") continue;
    if (key.startsWith("_")) {
      object2[key.substring(1)] = value2;
      delete object2[key];
    }
  }
  return object2;
}
function recreateInputShapes(inputObjects, units = null) {
  return inputObjects.map((s) => {
    var _a2;
    delete s.id;
    if (units) s.units = units;
    else if (!s.units) s.units = ((_a2 = this == null ? void 0 : this.optionsStore) == null ? void 0 : _a2.units) ?? "decimal";
    return new InputShape(s);
  });
}
function recreateStockList({
  stockList,
  removeScores = false,
  saw = null,
  preventAutoRotation = false,
  preventGrainRotation = false
}) {
  if (!stockList || !(stockList == null ? void 0 : stockList.length)) return [];
  return stockList.map((s) => {
    if (saw) s.saw = saw;
    if (preventAutoRotation) s.preventAutoRotation = true;
    if (preventGrainRotation) s.preventGrainRotation = true;
    const stock = new Stock(s);
    if (stock.issues.length) {
      throw new Error(
        `Issues found when attempting to recreate stock list - ${stock.issues.join()}`,
        { cause: stock.issues }
      );
    }
    if (removeScores) delete stock.algoBenchmark;
    return stock;
  }).sort(sort.ID);
}
function recreateShapeList({
  shapeList,
  stockList,
  preventAutoRotation = false
}) {
  if (typeof stockList === "undefined")
    throw new Error("recreateShapeList requires stockList");
  if (!shapeList || !(shapeList == null ? void 0 : shapeList.length)) return [];
  return shapeList.map((s) => {
    var _a2;
    if (preventAutoRotation) s.preventAutoRotation = true;
    let shape;
    if (isGroupData(s) && ((_a2 = s == null ? void 0 : s.shapes) == null ? void 0 : _a2.length)) {
      s.shapes = s.shapes.map((shapeData) => new Shape(shapeData));
      try {
        shape = new Group(s);
      } catch {
        throw new Error("error creating group from shape data");
      }
    } else {
      shape = new Shape(s);
    }
    if (shape.issues.length)
      throw new Error(`Issues found when attempting to recreate shape list - ${shape.issues.join()}`);
    const stock = stockList.find((stock2) => {
      var _a3;
      return stock2.id === (((_a3 = s == null ? void 0 : s.stock) == null ? void 0 : _a3.id) ?? (s == null ? void 0 : s.stockId));
    });
    shape.stock = stock;
    return shape;
  }).sort(sort.ID);
}
function recreateCutList({
  cutList,
  stockList
}) {
  if (typeof stockList === "undefined")
    throw new Error("recreateCutList requires stockList");
  if (!cutList || !(cutList == null ? void 0 : cutList.length)) return [];
  return cutList.map((cutObject) => {
    const cut = new Cut(cutObject);
    const stock = stockList.find((stock2) => {
      var _a2;
      return stock2.id === (((_a2 = cutObject == null ? void 0 : cutObject.stock) == null ? void 0 : _a2.id) ?? (cutObject == null ? void 0 : cutObject.stockId));
    });
    cut.stock = stock;
    return cut;
  });
}
function recreateSegmentList({
  segmentList,
  stockList
}) {
  if (!segmentList || !(segmentList == null ? void 0 : segmentList.length)) return [];
  return segmentList.map((segmentObject) => {
    const stock = stockList.find((stock2) => {
      var _a2;
      return stock2.id === (((_a2 = segmentObject == null ? void 0 : segmentObject.stock) == null ? void 0 : _a2.id) ?? (segmentObject == null ? void 0 : segmentObject.stockId));
    });
    segmentObject.stock = stock;
    const segment = new Segment(segmentObject);
    return segment;
  });
}
function willItFit(container = null, shape = null, rotation = null) {
  if (!container) throw new Error("no container supplied to willItFit");
  if (!shape) throw new Error("no shape supplied to willItFit");
  const originalRotation = shape.rot;
  function checkDimension(reverse = false, dimension = "l") {
    var _a2, _b;
    return maths.equalTo(
      shape[reverse ? getReverseDimension(dimension) : dimension],
      container[dimension]
    ) || maths.lessThanOrEqualTo(shape[reverse ? getReverseDimension(dimension) : dimension], container[dimension] - (isContainer(container) ? (_b = (_a2 = container == null ? void 0 : container.saw) == null ? void 0 : _a2.options) == null ? void 0 : _b.minSpacing : 0));
  }
  function resetShape(success = true) {
    shape.forceRotate(originalRotation);
    return success;
  }
  const requiredOrientation = shape.getNecessaryOrientation(container);
  let requiredRotation = null;
  if (requiredOrientation) {
    requiredRotation = requiredOrientation === "l" ? 0 : 1;
  }
  if (shape.orientationLock) {
    if (valueSet(rotation) && rotation !== requiredRotation)
      return resetShape(false);
    shape.forceRotate(requiredRotation);
  } else if (valueSet(rotation)) {
    shape.forceRotate(rotation);
  }
  if (requiredRotation) {
    if (shape.rot !== requiredRotation) return resetShape(false);
  }
  const lengthCheck = checkDimension(false, "l");
  const widthCheck = checkDimension(false, "w");
  const lengthCheckReverse = checkDimension(true, "l");
  const widthCheckReverse = checkDimension(true, "w");
  if (valueSet(rotation) || requiredOrientation) {
    return resetShape(lengthCheck && widthCheck);
  }
  return resetShape(lengthCheck && widthCheck || lengthCheckReverse && widthCheckReverse);
}
function processInputUnitValue(data, key, units = "decimal", parseLocale = false) {
  return valueSet(data == null ? void 0 : data[key]) ? convertUnit(data[key], units, false, parseLocale) : null;
}
class InputStock {
  constructor(data, parseLocale = false) {
    __publicField(this, "readonly");
    __publicField(this, "id");
    __publicField(this, "listId");
    __publicField(this, "units", "decimal");
    __publicField(this, "l");
    __publicField(this, "w");
    __publicField(this, "t");
    __publicField(this, "q");
    __publicField(this, "name");
    __publicField(this, "material");
    __publicField(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    __publicField(this, "cost", null);
    __publicField(this, "grain", "");
    __publicField(this, "selected", false);
    //used for multiple editing
    __publicField(this, "multiEdit", false);
    //is this the multi-select stock
    __publicField(this, "type", null);
    __publicField(this, "autoAdd", false);
    __publicField(this, "used");
    __publicField(this, "saw");
    __publicField(this, "preventGrainRotation");
    __publicField(this, "issues", []);
    __publicField(this, "warnings", []);
    __publicField(this, "notes", "");
    var _a2, _b;
    data = sanitiseData(data);
    if (!valueSet(data.units))
      console.warn("Attempting to create InputStock without units");
    this.units = data.units;
    this.readonly = data.readonly;
    this.id = data.id;
    this.listId = (data == null ? void 0 : data.listId) ? data.listId : Date.now().toString() + v4();
    const keys = ["l", "w", "t"];
    keys.forEach((key) => {
      this[key] = processInputUnitValue(data, key, this.units, parseLocale);
    });
    this.q = valueSet(data.q) ? typeof data.q === "string" ? parseInt(data.q) : data.q : null;
    this.autoAdd = valueSet(data.autoAdd) ? data.autoAdd : false;
    this.name = valueSet(data.name) ? sanitiseString(data.name).toUpperCase() : "";
    this.material = valueSet(data.material) ? data.material.trim().toUpperCase() : "";
    const trimKeys = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    };
    trimKeys.forEach((key) => {
      this.trim[key] = processInputUnitValue(data.trim, key, this.units, parseLocale);
    });
    this.cost = valueSet(data.cost) ? data.cost : null;
    this.grain = valueSet(data.grain) ? (_a2 = data == null ? void 0 : data.grain) == null ? void 0 : _a2.toLowerCase() : "";
    this.multiEdit = data.multiEdit;
    this.type = data.type;
    this.preventGrainRotation = true;
    this.notes = (data == null ? void 0 : data.notes) ? (_b = data.notes) == null ? void 0 : _b.replace(/,/g, "") : "";
  }
  //change the units of the stock
  changeUnits(newUnits, decimalPlaces, fractionRoundTo) {
    if (!(newUnits === "decimal" || newUnits === "fraction")) return;
    this.units = newUnits;
    function convertUnit$1(value2) {
      return value2 ? convertUnit(value2, newUnits, false, false, fractionRoundTo) : null;
    }
    this.l = convertUnit$1(this.l);
    this.w = convertUnit$1(this.w);
    this.t = convertUnit$1(this.t);
    const trimKeys = ["x1", "x2", "y1", "y2"];
    trimKeys.forEach((key) => {
      var _a2;
      this.trim[key] = valueSet((_a2 = this.trim) == null ? void 0 : _a2[key]) ? convertUnit$1(this.trim[key]) : null;
    });
  }
  //change the type of stock
  changeType(newType) {
    if (newType !== "sheet") this.grain = "";
    switch (newType) {
      case "linear":
        this.trim.y1 = 0;
        this.trim.y2 = 0;
        break;
      case "roll":
        this.trim.x1 = 0;
        this.trim.x2 = 0;
        this.trim.y1 = 0;
        this.trim.y2 = 0;
        this.t = null;
        break;
    }
  }
  //create an id from an index
  createId(index, secondaryIndex = 0) {
    this.id = `${index + 1}.${secondaryIndex}`;
  }
  isSquare() {
    if (this.l === this.w) return true;
    return false;
  }
  getWarnings() {
    this.warnings = [];
    ["q"].forEach((key) => this.warnings.push(...validation[key](this[key])));
  }
  validate() {
    this.issues = [];
    ["l", "w", "t"].forEach((key) => this.issues.push(...validation[key](this[key])));
    this.issues.push(...validation.trim(this));
    this.getWarnings();
    return this.issues;
  }
}
class InputShape {
  constructor(data, parseLocale = false) {
    __publicField(this, "readonly");
    __publicField(this, "id");
    __publicField(this, "listId");
    __publicField(this, "units", "decimal");
    __publicField(this, "l");
    __publicField(this, "w");
    __publicField(this, "t");
    __publicField(this, "q", 1);
    __publicField(this, "name", "");
    __publicField(this, "material", "");
    __publicField(this, "trim", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    });
    __publicField(this, "cost");
    __publicField(this, "banding", {
      a: false,
      b: false,
      c: false,
      d: false,
      x1: false,
      x2: false,
      y1: false,
      y2: false
    });
    __publicField(this, "bandingType", {
      a: "",
      b: "",
      c: "",
      d: "",
      x1: "",
      x2: "",
      y1: "",
      y2: ""
    });
    __publicField(this, "bandingOptions");
    __publicField(this, "orientationLock");
    __publicField(this, "selectedMaterial");
    __publicField(this, "selected");
    //used for multiple editing
    __publicField(this, "multiEdit", false);
    __publicField(this, "machining");
    __publicField(this, "issues", []);
    __publicField(this, "warnings", []);
    __publicField(this, "notes", "");
    __publicField(this, "stockLock");
    __publicField(this, "stockMatch");
    __publicField(this, "customData");
    var _a2;
    data = data = sanitiseData(data);
    this.units = data.units;
    this.readonly = data.readonly;
    this.id = data.id;
    this.listId = (data == null ? void 0 : data.listId) ? data.listId : Date.now().toString() + v4();
    const keys = ["l", "w", "t"];
    keys.forEach((key) => {
      this[key] = processInputUnitValue(data, key, this.units, parseLocale);
    });
    this.q = valueSet(data == null ? void 0 : data.q) ? typeof data.q === "string" ? parseInt(data.q) : data.q : null;
    this.name = valueSet(data.name) ? sanitiseString(data.name).toUpperCase() : "";
    this.material = valueSet(data.material) ? data.material.trim().toUpperCase() : "";
    const trimKeys = ["x1", "x2", "y1", "y2"];
    this.trim = {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    };
    trimKeys.forEach((key) => {
      this.trim[key] = processInputUnitValue(data.trim, key, this.units, parseLocale);
    });
    const bandingOptionsKeys = ["a", "b", "c", "d", "x1", "x2", "y1", "y2", "all"];
    this.bandingOptions = {
      a: {},
      b: {},
      c: {},
      d: {},
      x1: {},
      x2: {},
      y1: {},
      y2: {},
      all: {}
    };
    bandingOptionsKeys.forEach((key) => {
      var _a3;
      this.bandingOptions[key] = valueSet((_a3 = data == null ? void 0 : data.bandingOptions) == null ? void 0 : _a3[key]) ? data.bandingOptions[key] : {};
    });
    const bandingKeys = ["a", "b", "c", "d", "x1", "x2", "y1", "y2"];
    this.banding = {
      a: false,
      b: false,
      c: false,
      d: false,
      x1: false,
      x2: false,
      y1: false,
      y2: false
    };
    bandingKeys.forEach((key) => {
      var _a3;
      this.banding[key] = valueSet((_a3 = data == null ? void 0 : data.banding) == null ? void 0 : _a3[key]) ? data.banding[key] : false;
    });
    this.bandingType = {
      a: "",
      b: "",
      c: "",
      d: "",
      x1: "",
      x2: "",
      y1: "",
      y2: ""
    };
    bandingKeys.forEach((key) => {
      var _a3;
      this.bandingType[key] = valueSet((_a3 = data == null ? void 0 : data.bandingType) == null ? void 0 : _a3[key]) ? data.bandingType[key] : "";
    });
    this.orientationLock = valueSet(data.orientationLock) ? data.orientationLock.toLowerCase() : "";
    this.selected = false;
    this.multiEdit = data.multiEdit;
    this.machining = new Machining$1(data.machining ?? {
      holes: [],
      corners: []
    });
    this.notes = (data == null ? void 0 : data.notes) ? (_a2 = data.notes) == null ? void 0 : _a2.replace(/,/g, "") : "";
    this.stockLock = (data == null ? void 0 : data.stockLock) ?? [];
    this.customData = (data == null ? void 0 : data.customData) ?? {};
  }
  /**
   * change the units of the shape
   * @param {String} newUnits
   */
  changeUnits(newUnits, decimalPlaces, fractionRoundTo) {
    if (!(newUnits === "decimal" || newUnits === "fraction")) return;
    this.units = newUnits;
    function convertUnit$1(value2) {
      return value2 ? convertUnit(value2, newUnits, false, false, fractionRoundTo) : null;
    }
    this.l = convertUnit$1(this.l);
    this.w = convertUnit$1(this.w);
    this.t = convertUnit$1(this.t);
    const trimKeys = ["x1", "x2", "y1", "y2"];
    trimKeys.forEach((key) => {
      var _a2;
      this.trim[key] = valueSet((_a2 = this.trim) == null ? void 0 : _a2[key]) ? convertUnit$1(this.trim[key]) : null;
    });
  }
  isSquare() {
    if (this.l === this.w) return true;
    return false;
  }
  /**
   * change the type of the stock
   * @param {String} newType
   */
  changeStockType(newType) {
    switch (newType) {
      case "sheet":
      case "roll":
        this.orientationLock = "";
        if (newType === "roll") this.t = null;
        break;
      case "linear":
        this.orientationLock = "";
        this.banding = {
          x1: false,
          x2: false,
          y1: false,
          y2: false
        };
        this.bandingType = {
          x1: "",
          x2: "",
          y1: "",
          y2: ""
        };
        break;
    }
  }
  /**
   * create an id from an index
   * @param {Integer} index
   * @param {Integer} secondaryIndex
   */
  createId(index, secondaryIndex = 0) {
    this.id = `${index + 1}.${secondaryIndex}`;
  }
  getLongSide() {
    return convertUnit(this.l) > convertUnit(this.w) ? convertUnit(this.l) : convertUnit(this.w);
  }
  getShortSide() {
    return convertUnit(this.l) < convertUnit(this.w) ? convertUnit(this.l) : convertUnit(this.w);
  }
  getRotatedDimensions() {
    if (["l", "w"].includes(this.orientationLock)) {
      return {
        name: this.name,
        listId: this.listId,
        l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
        w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
        orientationLock: this.orientationLock
      };
    }
    return {
      name: this.name,
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  getTrimmedDimensions(rotated = false) {
    let dimensions = { l: convertUnit(this.l), w: convertUnit(this.w) };
    if (rotated) {
      dimensions = this.getRotatedDimensions();
    }
    return {
      name: this.name,
      listId: this.listId,
      l: dimensions.l - (this.trim.x1 + this.trim.x2),
      w: dimensions.w - (this.trim.y1 + this.trim.y2),
      orientationLock: this.orientationLock
    };
  }
  //used to apply a single trim value to all sides
  applyPartTrim(partTrim, stockType) {
    if (this.readonly) return;
    partTrim = convertUnit(partTrim);
    if (this.trim) {
      for (const key in this.trim) {
        this.trim[key] = partTrim;
      }
      if (stockType === "linear") {
        this.trim.y1 = 0;
        this.trim.y2 = 0;
      }
    } else {
      this.trim = {
        x1: partTrim,
        x2: partTrim,
        y1: stockType !== "linear" ? partTrim : 0,
        y2: stockType !== "linear" ? partTrim : 0
      };
    }
  }
  /**
   * to align with Shape
   * @remarks input shapes are always 0
   */
  get rot() {
    return 0;
  }
  validate(inputStockList, cutType, partTrim = 0, useInventory = false) {
    this.issues = [];
    ["l", "w", "t"].forEach((key) => {
      this.issues.push(...validation[key](this[key]));
    });
    partTrim = convertUnit(partTrim);
    this.issues.push(...validation.partTrim(this, partTrim));
    this.issues.push(...validation.trim(this));
    validation.machining(this);
    this.getWarnings(inputStockList, cutType, partTrim, useInventory);
    return this.issues;
  }
  getWarnings(inputStockList, stockType, partTrim = 0, useInventory = false) {
    this.warnings = [];
    ["q"].forEach((key) => {
      this.warnings.push(...validation[key](this[key]));
    });
    if (inputStockList.length && !useInventory) {
      this.warnings.push(...validation.stockMatch(this, inputStockList, stockType, partTrim));
    }
  }
  convertBandingOptionsToBanding() {
    for (const side in this.bandingOptions) {
      if (side === "all") continue;
      const bandingValues = Object.values(this.bandingOptions[side]);
      if (bandingValues.some((o2) => o2)) {
        if (!bandingValues.every((o2) => o2)) {
          this.issues.push("If using banding, all options must be set.");
        }
      }
      if (bandingValues.length === 1 && typeof bandingValues[0] === "boolean") {
        const key = Object.keys(this.bandingOptions[side])[0];
        if (key && bandingValues[0] === true) {
          this.banding[side] = true;
          this.bandingType[side] = key;
        } else {
          this.banding[side] = false;
          this.bandingType[side] = "";
        }
      } else {
        const setBandingValues = bandingValues.filter((o2) => o2).map((o2) => o2.toString().trim().replace("|", "_"));
        if (!setBandingValues.length) {
          this.banding[side] = false;
          this.bandingType[side] = "";
          continue;
        }
        this.banding[side] = true;
        this.bandingType[side] = setBandingValues.join("|");
      }
    }
  }
  removeBandingApartFromBandingOptions() {
    const sides = ["a", "b", "c", "d", "x1", "x2", "y1", "y2"];
    for (const side of sides) {
      this.banding[side] = false;
      this.bandingType[side] = "";
    }
  }
  setAllBandingOptions(key, value2, sides = ["x1", "x2", "y1", "y2"]) {
    for (const side of sides) {
      if (valueSet(value2)) {
        this.banding[side] = true;
        this.bandingOptions[side][key] = value2;
      } else {
        this.banding[side] = false;
        this.bandingOptions[side][key] = "";
      }
    }
  }
  removeBanding() {
    const sides = ["a", "b", "c", "d", "x1", "x2", "y1", "y2", "all"];
    for (const side of sides) {
      this.bandingOptions[side] = {};
      if (side === "all") continue;
      this.banding[side] = false;
      this.bandingType[side] = "";
    }
  }
}
class Rectangle {
  constructor(data) {
    __publicField(this, "id");
    __publicField(this, "parentID");
    __publicField(this, "name");
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "l");
    __publicField(this, "w");
    __publicField(this, "t");
    __publicField(this, "q");
    __publicField(this, "material");
    __publicField(this, "grain");
    __publicField(this, "orientationLock");
    __publicField(this, "duplicate");
    __publicField(this, "_trim");
    __publicField(this, "trimmed");
    __publicField(this, "preventAutoRotation");
    __publicField(this, "preventGrainRotation");
    __publicField(this, "units");
    __publicField(this, "issues", []);
    __publicField(this, "stock");
    __publicField(this, "stockId");
    //used when object is compressed
    __publicField(this, "cost");
    __publicField(this, "offcut");
    __publicField(this, "notes");
    //for user notes
    __publicField(this, "customData");
    this.initRectangle(data);
  }
  validateRectangle(data) {
    if (!isGroup(this)) {
      ["x", "y", "l", "w", "t"].forEach((key) => {
        this.createIssues(validation[key](data[key]));
      });
    }
    if (isStock(this)) {
      if ("q" in data) {
        this.createIssues(validation.q((data == null ? void 0 : data.q) ?? 0, data.autoAdd));
      }
    }
    if ("q" in data && this.isShape() && !this.isGroup() && !this.isUserGroup()) {
      this.createIssues(validation.q((data == null ? void 0 : data.q) ?? 0));
    }
    if ("customData" in data) {
      this.createIssues(validation.customData((data == null ? void 0 : data.customData) ?? {}));
    }
  }
  initRectangle(data, update = false) {
    var _a2, _b, _c;
    if (!update) {
      this.validateRectangle(data);
      if (this.issues.length) return;
      this.id = valueSet(data.id) ? data.id.toString() : this.id || null;
      this.setParentID();
      if (valueSet(data == null ? void 0 : data.q)) {
        if (typeof data.q === "string") {
          this.q = parseInt(data.q);
        } else {
          this.q = data.q;
        }
      } else {
        this.q = 0;
      }
      this.name = valueSet(data.name) && ((_a2 = data == null ? void 0 : data.name) == null ? void 0 : _a2.length) ? (_b = truncateString(sanitiseString(data == null ? void 0 : data.name))) == null ? void 0 : _b.toUpperCase() : null;
      if (valueSet(data == null ? void 0 : data.cost)) {
        if (typeof data.cost === "string") {
          this.cost = parseFloat(data.cost);
        } else if (typeof data.cost === "number") {
          this.cost = data.cost;
        }
      } else {
        this.cost = 0;
      }
      this.material = valueSet(data.material) ? data.material.trim().toLowerCase() : null;
      this.duplicate = valueSet(data == null ? void 0 : data.duplicate) ? data.duplicate : false;
      this.grain = typeof data.grain !== "undefined" && valueSet(data == null ? void 0 : data.grain) ? data.grain.toLowerCase() : null;
      try {
        this.trim = data == null ? void 0 : data.trim;
      } catch (error) {
        if ((_c = error == null ? void 0 : error.cause) == null ? void 0 : _c.issues) this.issues.push(...error.cause.issues);
        else throw new Error("error when attempting to set trim");
      }
      this.trimmed = valueSet(data == null ? void 0 : data.trimmed) ? data.trimmed : false;
      this.offcut = valueSet(data == null ? void 0 : data.offcut) ? data.offcut : false;
      this.notes = typeof (data == null ? void 0 : data.notes) === "string" && data.notes.length ? data.notes.replace(/,/g, "").substring(0, 200) : "";
      this.customData = (data == null ? void 0 : data.customData) ?? {};
    }
    const unitBasedValues = [
      {
        key: "x",
        default: 0,
        required: false
      },
      {
        key: "y",
        default: 0,
        required: false
      },
      {
        key: "l",
        default: null,
        required: true
      },
      {
        key: "w",
        default: 1,
        //for linear
        required: true
      },
      {
        key: "t",
        default: null,
        required: false
      }
    ];
    unitBasedValues.forEach((item) => {
      let value2 = data[item.key];
      if (!valueSet(value2)) {
        return this[item.key] = this[item.key] || item.default;
      }
      if (typeof value2 === "string") value2 = convertUnit(value2);
      this[item.key] = value2;
    });
    if (!(data == null ? void 0 : data.preventAutoRotation) && !data.trimmed && this.w > this.l) {
      [this.l, this.w] = [this.w, this.l];
      if (this.grain && !(data == null ? void 0 : data.preventGrainRotation))
        this.grain = getReverseDimension(this.grain);
    }
    if (valueSet(data == null ? void 0 : data.stock)) {
      if (isStock(data.stock)) {
        this.stock = data.stock;
      } else {
        this.stock = new Stock(data.stock);
      }
      this.stockId = this.stock.id;
    }
  }
  updateRectangle(data) {
    data.preventAutoRotation = true;
    this.initRectangle(data, true);
  }
  set trim(val) {
    this._trim = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
    if (!valueSet(val)) return;
    Object.keys(val).forEach((key) => {
      let value2;
      if (typeof val[key] === "string") {
        const converted = convertUnit(val[key]);
        if (isNaN(converted) || converted < 0) {
          this.issues.push(this.createIssue(`${val[key] ?? "N/A"} is not a valid value for trim: ${key}`));
          value2 = 0;
        } else value2 = converted;
      } else {
        value2 = val[key];
      }
      this._trim[key] = value2;
    });
  }
  get trim() {
    return this._trim;
  }
  get rot() {
    return this.w > this.l ? 1 : 0;
  }
  setParentID() {
    this.parentID = this.getParentID();
  }
  getParentID() {
    if (!this.id) return null;
    if (this.parentID) return this.parentID;
    if (typeof this.id !== "number" && this.id.includes(".")) {
      return this.id.split(".")[0];
    } else if (typeof this.id !== "number" && !this.id.includes(".")) {
      return null;
    } else return (this == null ? void 0 : this.id) ? this.id.toString() : null;
  }
  getCopyNumber() {
    if (typeof this.id !== "number" && this.id.includes(".")) {
      return parseInt(this.id.split(".")[1]);
    }
    return 0;
  }
  createIssues(issues) {
    if (!(issues == null ? void 0 : issues.length)) return;
    issues.forEach((issue) => {
      this.issues.push(this.createIssue(issue));
    });
  }
  createIssue(message) {
    var _a2;
    let type3 = "";
    const thisClass = this.getClass();
    switch (thisClass) {
      case "Shape":
        type3 = "part";
        break;
      case "Stock":
        type3 = "stock";
        break;
      default:
        type3 = thisClass.toLowerCase();
        break;
    }
    const itemIdentifier = ((_a2 = this == null ? void 0 : this.name) == null ? void 0 : _a2.length) ? this.name.toUpperCase() : this.parentID;
    if (itemIdentifier) {
      return `${message} [${type3.charAt(0).toUpperCase() + type3.slice(1)} ${itemIdentifier}]`;
    } else {
      return message;
    }
  }
  dimensions() {
    return {
      id: this.id,
      l: this.l,
      w: this.w,
      t: this.t
    };
  }
  getRotatedDimensions() {
    if (["l", "w"].includes(this.orientationLock)) {
      return {
        l: this.orientationLock === "l" ? this.getLongSide() : this.getShortSide(),
        w: this.orientationLock === "l" ? this.getShortSide() : this.getLongSide(),
        orientationLock: this.orientationLock
      };
    }
    return {
      l: this.getLongSide(),
      w: this.getShortSide(),
      orientationLock: this.orientationLock
    };
  }
  coords() {
    return {
      id: this.id,
      x: this.x,
      y: this.y
    };
  }
  hasCoords(x, y2) {
    if (this.x === x && this.y === y2) return true;
    return false;
  }
  getAspect() {
    return this.l > this.w ? this.w / this.l : this.l / this.w;
  }
  getPerimeter() {
    return this.w * 2 + this.l * 2;
  }
  getLongSide() {
    return this.l > this.w ? this.l : this.w;
  }
  getShortSide() {
    return this.l < this.w ? this.l : this.w;
  }
  getSides() {
    return [
      this.getSide("bottom"),
      this.getSide("right"),
      this.getSide("top"),
      this.getSide("left")
    ];
  }
  getSide(side) {
    switch (side) {
      case "bottom":
        return new Line({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y,
          type: "bottom"
          // parentID: this.id
        });
      case "right":
        return new Line({
          x1: this.x + this.l,
          x2: this.x + this.l,
          y1: this.y,
          y2: this.y + this.w,
          type: "right"
          // parentID: this.id
        });
      case "top":
        return new Line({
          x1: this.x,
          x2: this.x + this.l,
          y1: this.y + this.w,
          y2: this.y + this.w,
          type: "top"
          // parentID: this.id
        });
      case "left":
        return new Line({
          x1: this.x,
          x2: this.x,
          y1: this.y,
          y2: this.y + this.w,
          type: "left"
          // parentID: this.id
        });
    }
  }
  getTopPosition(addBladeWidth = true, bladeWidth = null) {
    var _a2;
    if (addBladeWidth && typeof ((_a2 = this.stock) == null ? void 0 : _a2.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.y + this.w + ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.y + this.w;
  }
  getRightPosition(addBladeWidth = true, bladeWidth = null) {
    var _a2;
    if (addBladeWidth && typeof ((_a2 = this.stock) == null ? void 0 : _a2.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.x + this.l + ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.x + this.l;
  }
  getBottomPosition(addBladeWidth = true, bladeWidth = null) {
    var _a2;
    if (addBladeWidth && typeof ((_a2 = this.stock) == null ? void 0 : _a2.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.y - ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.y;
  }
  getLeftPosition(addBladeWidth = true, bladeWidth = null) {
    var _a2;
    if (addBladeWidth && typeof ((_a2 = this.stock) == null ? void 0 : _a2.getBladeWidth) === "undefined" && bladeWidth === null)
      throw new Error("not able to detect blade width in getTopPosition");
    return addBladeWidth ? this.x - ((this.stock.getBladeWidth() || bladeWidth) ?? 0) : this.x;
  }
  sharesSide(rectangle, bladeWidth = 0, side = null) {
    switch (side) {
      case "left":
        return rectangle.x + rectangle.l + bladeWidth === this.x;
      case "right":
        return rectangle.x === this.x + this.l + bladeWidth;
      case "bottom":
        return rectangle.y + rectangle.w + bladeWidth === this.y;
      case "top":
        return rectangle.y === this.y + this.w + bladeWidth;
    }
    return false;
  }
  sameSide(rectangle, side = null) {
    switch (side) {
      case "left":
        return rectangle.x === this.x;
      case "right":
        return rectangle.x + rectangle.l === this.x + this.l;
      case "bottom":
        return rectangle.y === this.y;
      case "top":
        return rectangle.y + rectangle.w === this.y + this.w;
    }
    return false;
  }
  //considers if the shape can rotate
  getLongestDimension(dimension) {
    if (this.orientationLock) return this[dimension];
    else return this.getLongSide();
  }
  getArea() {
    return this.w * this.l;
  }
  getCoords(container, getAll = false) {
    const bottomRight = new Point(this.x + this.l, this.y);
    bottomRight.corner = "bottomRight";
    const topLeft = new Point(this.x, this.y + this.w);
    topLeft.corner = "topLeft";
    if ((container == null ? void 0 : container.cutType) !== "efficiency" && !getAll) {
      return [topLeft, bottomRight];
    }
    const bottomLeft = new Point(this.x, this.y);
    bottomLeft.corner = "bottomLeft";
    const topRight = new Point(this.x + this.l, this.y + this.w);
    topRight.corner = "topRight";
    return [bottomLeft, topLeft, topRight, bottomRight];
  }
  getCorners() {
    return {
      bottomLeft: new Point(this.x, this.y),
      topLeft: new Point(this.x, this.y + this.w),
      topRight: new Point(this.x + this.l, this.y + this.w),
      bottomRight: new Point(this.x + this.l, this.y)
    };
  }
  round() {
    return {
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  getClass() {
    return this.constructor.name;
  }
  getTrimmedDimensions(rotated = false) {
    let dimensions = { l: this.l, w: this.w };
    if (rotated) {
      dimensions = this.getRotatedDimensions();
    }
    if (!this.trimmed) {
      return {
        l: dimensions.l - (this.trim.x1 + this.trim.x2),
        w: dimensions.w - (this.trim.y1 + this.trim.y2)
      };
    }
    return dimensions;
  }
  //trim the rectangle
  trimDimensions() {
    var _a2, _b, _c, _d;
    if (this.trimmed) return false;
    if (this.trim && Object.values(this.trim).filter((value2) => !isNaN(parseFloat(String(value2)))).length) {
      if (valueSet(this.l)) {
        this.l -= (((_a2 = this == null ? void 0 : this.trim) == null ? void 0 : _a2.x1) ? this.trim.x1 : 0) + (((_b = this == null ? void 0 : this.trim) == null ? void 0 : _b.x2) ? this.trim.x2 : 0);
        if (this.l <= 0) {
          console.error(this);
          this.issues.push(this.createIssue("Applying trim has produced a negative length"));
        }
      }
      if (valueSet(this.w)) {
        this.w -= (((_c = this == null ? void 0 : this.trim) == null ? void 0 : _c.y1) ? this.trim.y1 : 0) + (((_d = this == null ? void 0 : this.trim) == null ? void 0 : _d.y2) ? this.trim.y2 : 0);
        if (this.w <= 0) {
          console.error(this);
          this.issues.push(this.createIssue("Applying trim has produced a negative width"));
        }
      }
    }
    this.trimmed = true;
    return true;
  }
  /**
   * change the size of the rectangle back to the original size
   */
  removeTrim() {
    var _a2, _b, _c, _d;
    if (!this.trimmed) return;
    this.l += (typeof ((_a2 = this == null ? void 0 : this.trim) == null ? void 0 : _a2.x1) === "number" ? this.trim.x1 : 0) + (typeof ((_b = this == null ? void 0 : this.trim) == null ? void 0 : _b.x2) === "number" ? this.trim.x2 : 0);
    this.w += (typeof ((_c = this == null ? void 0 : this.trim) == null ? void 0 : _c.y1) === "number" ? this.trim.y1 : 0) + (typeof ((_d = this == null ? void 0 : this.trim) == null ? void 0 : _d.y2) === "number" ? this.trim.y2 : 0);
    if (this.l <= 0)
      throw new Error(`trimming this ${this.id} has produced a negative length`);
    if (this.w <= 0)
      throw new Error(`trimming this ${this.id} has produced a negative width`);
    this.trimmed = false;
  }
  getUntrimmedDimensions() {
    var _a2, _b, _c, _d;
    if (!this.trimmed) return { l: this.l, w: this.w };
    const l = this.getLongSide();
    const w = this.getShortSide();
    return {
      l: l + (typeof ((_a2 = this == null ? void 0 : this.trim) == null ? void 0 : _a2.x1) === "number" ? this.trim.x1 : 0) + (typeof ((_b = this == null ? void 0 : this.trim) == null ? void 0 : _b.x2) === "number" ? this.trim.x2 : 0),
      w: w + (typeof ((_c = this == null ? void 0 : this.trim) == null ? void 0 : _c.y1) === "number" ? this.trim.y1 : 0) + (typeof ((_d = this == null ? void 0 : this.trim) == null ? void 0 : _d.y2) === "number" ? this.trim.y2 : 0)
    };
  }
  isIdentical(rectangle) {
    if (this.constructor !== rectangle.constructor) return false;
    if (!isGroup(this)) {
      if (rectangle.parentID === this.parentID) return true;
    } else {
      if (rectangle.id === this.id) return true;
    }
    if (this.t !== rectangle.t || this.orientationLock !== rectangle.orientationLock) return false;
    const dimensionsMatch = this.w === rectangle.w && this.l === rectangle.l || this.w === rectangle.l && this.l === rectangle.w;
    if (!dimensionsMatch) return false;
    const thisTrim = this.trim;
    const rectTrim = rectangle.trim;
    if (!thisTrim || !rectTrim) return thisTrim === rectTrim;
    const result = thisTrim.x1 === rectTrim.x1 && thisTrim.x2 === rectTrim.x2 && thisTrim.y1 === rectTrim.y1 && thisTrim.y2 === rectTrim.y2;
    return result;
  }
  /**
   * is this rectangle a square
   */
  isSquare() {
    if (this.l === this.w) return true;
    return false;
  }
  getDistancesToContainerEdges(container) {
    return [
      this.x - container.x,
      container.l - (this.x + this.l),
      container.w - (this.y + this.w),
      this.y - container.y
    ];
  }
  isInsideStock(stock) {
    if (this.x + this.l > stock.l) return false;
    if (this.y + this.w > stock.w) return false;
    if (this.x < 0) return false;
    if (this.y < 0) return false;
    return true;
  }
  //create a rectangle used to detect proximity to other shapes
  createProximityRectangle(distance) {
    if (!distance || distance < 0) return null;
    let x = this.x - distance;
    let y2 = this.y - distance;
    let l = this.l + distance * 2;
    let w = this.w + distance * 2;
    if (x < 0) {
      l += x;
      x = 0;
    }
    if (y2 < 0) {
      w += y2;
      y2 = 0;
    }
    l = Math.max(0, l);
    w = Math.max(0, w);
    const proxRect = new Rectangle({
      id: `${this.id}-proximity`,
      name: "proximity",
      x,
      y: y2,
      l,
      w,
      preventAutoRotation: true
    });
    test([
      () => expect(proxRect.x).to.be.greaterThanOrEqual(0),
      () => expect(proxRect.y).to.be.greaterThanOrEqual(0),
      () => expect(proxRect.l).to.be.greaterThan(this.l),
      () => expect(proxRect.w).to.be.greaterThan(this.w)
    ]);
    return proxRect;
  }
  isShape() {
    return isShape(this);
  }
  isSegment() {
    return isSegment(this);
  }
  isStock() {
    return isStock(this);
  }
  isGroup() {
    return isGroup(this);
  }
  isUserGroup() {
    return isUserGroup(this);
  }
}
class Container extends Rectangle {
  constructor(data) {
    super(data);
    __publicField(this, "type");
    __publicField(this, "saw");
    __publicField(this, "algoBenchmark");
    //used by evo
    __publicField(this, "shapes", []);
    this.shapes = data.shapes;
    if (!["sheet", "linear", "roll", null, void 0, ""].includes(data.type)) {
      this.issues.push(`Container type ${data.type ?? "N/A"} is not valid`);
    } else this.type = data.type;
    if (!this.type) this.type = "sheet";
    this.setSaw(data);
    switch (this.cutType) {
      case "beam":
        if (!valueSet(this.t) || this.t <= 0) {
          this.issues.push(this.createIssue("Stock for beam saws must have a thickness set"));
        }
        break;
    }
  }
  setSaw(data) {
    var _a2, _b, _c, _d;
    if (!valueSet(data)) this.saw = new Saw(null);
    if (!valueSet(data == null ? void 0 : data.saw)) {
      data.saw = {};
      const { cutType, cutPreference } = mapLegacyCutPreference(data.cutPreference);
      data.saw.cutType = cutType;
      data.saw.cutPreference = cutPreference;
      if (valueSet(data == null ? void 0 : data.bladeWidth))
        data.saw.bladeWidth = data.bladeWidth;
      if (valueSet((_a2 = data == null ? void 0 : data.blade) == null ? void 0 : _a2.width))
        data.saw.bladeWidth = data.blade.width;
      if (valueSet(data == null ? void 0 : data.efficiencyOptions))
        data.saw.efficiencyOptions = data.efficiencyOptions;
      if (valueSet(data == null ? void 0 : data.guillotineOptions))
        data.saw.guillotineOptions = data.guillotineOptions;
      if (valueSet(data == null ? void 0 : data.stackHeight))
        data.saw.stackHeight = data.stackHeight;
    } else {
      if (!((_b = data == null ? void 0 : data.saw) == null ? void 0 : _b.cutType)) {
        const { cutType, cutPreference } = mapLegacyCutPreference(data.saw.cutPreference);
        data.saw.cutType = cutType;
        data.saw.cutPreference = cutPreference;
      }
    }
    try {
      if (valueSet(data == null ? void 0 : data.saw)) {
        if (isSaw(data.saw)) {
          this.saw = data.saw;
        } else {
          this.saw = new Saw(data.saw, this.type);
        }
      }
      if ((_d = (_c = this.saw) == null ? void 0 : _c.issues) == null ? void 0 : _d.length) this.issues.push(...this.saw.issues);
    } catch (error) {
      throw new Error("error creating saw", { cause: error });
    }
  }
  get cutType() {
    var _a2, _b, _c, _d;
    if (valueSet((_a2 = this == null ? void 0 : this.saw) == null ? void 0 : _a2.cutType)) return this.saw.cutType;
    if (!((_b = this.stock) == null ? void 0 : _b.isStock())) return ((_d = (_c = this == null ? void 0 : this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.cutType) ?? null;
    return null;
  }
  get cutPreference() {
    var _a2, _b, _c, _d;
    if (valueSet((_a2 = this.saw) == null ? void 0 : _a2.cutPreference)) return this.saw.cutPreference;
    if (!((_b = this.stock) == null ? void 0 : _b.isStock()))
      return ((_d = (_c = this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.cutPreference) ?? null;
    return null;
  }
  get guillotineOptions() {
    var _a2, _b, _c, _d;
    if (valueSet((_a2 = this.saw) == null ? void 0 : _a2.guillotineOptions))
      return this.saw.guillotineOptions;
    if (!((_b = this.stock) == null ? void 0 : _b.isStock()))
      return ((_d = (_c = this == null ? void 0 : this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.guillotineOptions) ?? null;
    return null;
  }
  get efficiencyOptions() {
    var _a2, _b, _c, _d;
    if (valueSet((_a2 = this.saw) == null ? void 0 : _a2.efficiencyOptions))
      return this.saw.efficiencyOptions;
    if (!((_b = this.stock) == null ? void 0 : _b.isStock()))
      return ((_d = (_c = this == null ? void 0 : this.stock) == null ? void 0 : _c.saw) == null ? void 0 : _d.efficiencyOptions) ?? null;
    return null;
  }
  get primaryCompression() {
    var _a2, _b;
    if (this.cutType === "efficiency") {
      if ((_b = (_a2 = this.saw) == null ? void 0 : _a2.efficiencyOptions) == null ? void 0 : _b.primaryCompression) {
        return this.efficiencyOptions.primaryCompression;
      }
      return "y";
    }
    return null;
  }
  getHalfBladeWidth() {
    const bladeWidth = this.getBladeWidth();
    return bladeWidth ? bladeWidth / 2 : 0;
  }
  getBladeWidth() {
    var _a2, _b, _c;
    const bladeWidth = (((_a2 = this == null ? void 0 : this.saw) == null ? void 0 : _a2.bladeWidth) || ((_c = (_b = this == null ? void 0 : this.stock) == null ? void 0 : _b.saw) == null ? void 0 : _c.bladeWidth)) ?? 0;
    return isNaN(bladeWidth) ? 0 : bladeWidth;
  }
  getStock() {
    if (isStock(this)) return this;
    return (this == null ? void 0 : this.stock) ? this.stock : null;
  }
}
function mapLegacyCutPreference(originalCutPreference) {
  let cutType;
  let cutPreference;
  switch (originalCutPreference) {
    case "l":
    case "length":
      cutType = "guillotine";
      cutPreference = "l";
      break;
    case "w":
    case "width":
      cutType = "guillotine";
      cutPreference = "w";
      break;
    case "flex":
      cutType = "guillotine";
      cutPreference = "flex";
      break;
    case "efficiency":
      cutType = "efficiency";
      cutPreference = null;
      break;
    case "beam":
      cutType = "beam";
      cutPreference = "l";
      break;
    default:
      cutType = null;
      cutPreference = null;
      break;
  }
  return {
    cutPreference,
    cutType
  };
}
class Saw {
  constructor(data, stockType = "sheet") {
    __publicField(this, "issues");
    __publicField(this, "bladeWidth");
    __publicField(this, "cutType");
    __publicField(this, "cutPreference");
    __publicField(this, "guillotineOptions");
    __publicField(this, "efficiencyOptions");
    __publicField(this, "stackHeight");
    __publicField(this, "stockType");
    __publicField(this, "options");
    data = sanitiseData(data);
    this.options = defaults({}, data == null ? void 0 : data.options, {
      stockSelection: "efficiency",
      minSpacing: 0,
      minSpacingDimension: {}
    });
    this.stackHeight = (data == null ? void 0 : data.stackHeight) ?? null;
    this.stockType = (data == null ? void 0 : data.stockType) ?? stockType;
    this.issues = [];
    if (!["sheet", "linear", "roll"].includes(this.stockType))
      this.issues.push(`Saw stock type: ${this.stockType} not valid`);
    if (!this.stockType) this.stockType = "sheet";
    this.cutType = data == null ? void 0 : data.cutType;
    switch (this.stockType) {
      case "sheet":
        if (![
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType)) {
          this.issues.push(`Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}`);
        }
        break;
      case "roll":
        if (!["efficiency", "guillotine", null, void 0].includes(this.cutType)) {
          this.issues.push(`Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}`);
        }
        break;
      default:
        if (!["none", null, void 0].includes(this.cutType)) {
          this.issues.push(`Saw cut type: ${this.cutType} not valid for stock type: ${this.stockType}`);
        }
        break;
    }
    this.cutPreference = data == null ? void 0 : data.cutPreference;
    switch (this.cutType) {
      case "guillotine":
        if (!["l", "w", "flex"].includes(this.cutPreference)) {
          this.issues.push(`Saw cut preference: ${this.cutPreference} not valid for cut type: ${this.cutType}`);
        }
        if (this.cutType === "guillotine" && this.cutPreference === "l" && this.stockType === "roll") {
          this.issues.push(`Cut preference: ${this.cutPreference} not valid for cut type: ${this.cutType} and stock type: ${this.stockType}`);
        }
        this.options.minSpacing = 0;
        break;
      case "beam":
        if (!["l", null, void 0].includes(this.cutPreference)) {
          this.issues.push(`Saw cut preference: ${this.cutPreference} not valid for cut type: ${this.cutType}`);
        }
        this.options.minSpacing = 0;
        break;
      default:
        if (!["none", null, void 0].includes(this.cutPreference)) {
          this.issues.push(`Saw cut preference: ${this.cutPreference} not valid for cut type: ${this.cutType}`);
        }
        break;
    }
    if (valueSet(data == null ? void 0 : data.bladeWidth)) {
      if (typeof data.bladeWidth === "string") {
        this.bladeWidth = convertUnit(data.bladeWidth);
      } else {
        this.bladeWidth = data.bladeWidth;
      }
    } else this.bladeWidth = 0;
    if (isNaN(this.bladeWidth) || this.bladeWidth < 0) {
      this.issues.push(`Blade width: ${this.bladeWidth ?? "N/A"} is not valid`);
      this.bladeWidth = 0;
    }
    switch (this.stockType) {
      case "sheet":
        if (![
          "efficiency",
          "guillotine",
          "beam",
          null,
          void 0
        ].includes(this.cutType)) {
          this.issues.push(`Invalid cut type: ${this.cutType} for stock type: ${stockType}, cut preference: ${this.cutPreference}`);
        }
        if (this.cutType === "guillotine") {
          if (!["l", "w", "flex"].includes(this.cutPreference)) {
            this.issues.push(`Invalid cut preference: ${this.cutPreference} for stock type: ${stockType}, cut type: ${this.cutType}`);
          }
        }
        if (this.cutType === "beam") {
          if ([null, void 0].includes(this.stackHeight)) {
            this.issues.push("Beam saws require a stack height to be set");
          }
        }
        if (this.cutType === "beam") this.cutPreference = "l";
        if (!this.cutType) this.cutType = "efficiency";
        break;
      case "linear":
        this.cutType = null;
        this.cutPreference = null;
        break;
    }
    switch (this.cutType) {
      case "efficiency":
        this.efficiencyOptions = defaults({}, data == null ? void 0 : data.efficiencyOptions, { primaryCompression: "y" });
        break;
      case "guillotine":
        this.guillotineOptions = defaults({}, data == null ? void 0 : data.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        break;
      case "beam":
        this.guillotineOptions = defaults({}, data == null ? void 0 : data.guillotineOptions, { strategy: "efficiency", maxPhase: null });
        this.cutPreference = "l";
        if ([null, void 0].includes(this.stackHeight)) {
          this.issues.push("Beam saws require a stack height to be set");
        }
        break;
    }
  }
  clone() {
    const data = structuredClone(this);
    return new Saw(data);
  }
}
class Stock extends Container {
  constructor(data) {
    data = sanitiseData(data);
    data.preventAutoRotation = (data == null ? void 0 : data.type) === "roll";
    if (data.autoAdd && !data.q) data.q = 1;
    super(data);
    __publicField(this, "_id");
    //used for mongo
    __publicField(this, "autoAdd");
    __publicField(this, "allowExactFitShapes");
    __publicField(this, "analysis");
    __publicField(this, "tidy");
    __publicField(this, "used");
    __publicField(this, "stack");
    __publicField(this, "winningStrategy");
    //used for reporting
    __publicField(this, "unusable");
    //used by stock matching
    __publicField(this, "duplicatePattern");
    __publicField(this, "score");
    __publicField(this, "rootSegment");
    delete this.stock;
    this._id = data == null ? void 0 : data._id;
    this.autoAdd = valueSet(data == null ? void 0 : data.autoAdd) ? data.autoAdd : false;
    this.allowExactFitShapes = valueSet(data == null ? void 0 : data.allowExactFitShapes) ? data.allowExactFitShapes : false;
    this.analysis = valueSet(data.analysis) ? data.analysis : null;
    this.tidy = valueSet(data == null ? void 0 : data.tidy) ? data.tidy : false;
    this.algoBenchmark = null;
    this.used = valueSet(data == null ? void 0 : data.used) ? data.used : false;
    this.stack = valueSet(data == null ? void 0 : data.stack) ? data.stack : false;
    this.duplicatePattern = (data == null ? void 0 : data.duplicatePattern) ?? null;
    this.initStock(data);
  }
  initStock(data) {
    switch (this.type) {
      case "linear":
      case "roll":
        this.trim.y1 = 0;
        this.trim.y2 = 0;
        this.grain = null;
        break;
    }
    this.validateStock(data);
    if (this.issues.length) return;
  }
  reset() {
    this.used = false;
    this.stack = null;
    this.score = null;
    this.rootSegment = null;
    this.tidy = null;
    this.analysis = null;
    this.duplicatePattern = null;
    this.shapes = [];
  }
  validateStock(data) {
    ["grain"].forEach((key) => {
      this.createIssues(validation[key](data[key]));
    });
    this.createIssues(validation.trim(this));
  }
  /**
   * compress for saving / transfer
   */
  save() {
    var _a2;
    delete this.tidy;
    delete this.score;
    delete this.rootSegment;
    delete this.shapes;
    this == null ? true : delete this.algoBenchmark;
    this.stack = typeof this.stack === "number" || this.stack === false ? this.stack : (_a2 = this.stack) == null ? void 0 : _a2.id;
    if (!this.trim.x1 && !this.trim.x2 && !this.trim.y1 && !this.trim.y2) {
      this.trim = null;
    }
  }
  resetStrategies() {
    this.algoBenchmark = null;
  }
  isIdentical(stock) {
    let material = false;
    let thickness = false;
    let length2 = false;
    let width = false;
    if (this.material === stock.material) material = true;
    if (this.t === stock.t) thickness = true;
    if (this.l === stock.l) length2 = true;
    if (this.w === stock.w) width = true;
    if (material && thickness && length2 && width) return true;
  }
  clone(version2 = null) {
    const id = this.id.split(".");
    if (!version2) {
      version2 = parseInt(id.pop());
      version2++;
    } else {
      id.pop();
    }
    id.push(version2.toString());
    const newId = id.join(".");
    const data = structuredClone(this);
    data.id = newId;
    data.used = false;
    data.duplicate = true;
    data.stack = false;
    data.saw = this.saw;
    const stock = new Stock(data);
    return stock;
  }
}
class Offcut extends Rectangle {
  constructor(data) {
    super(data);
    __publicField(this, "addToInventory");
    //for front end selection
    __publicField(this, "added");
    //for adding to inputStock
    __publicField(this, "placementOrder");
    __publicField(this, "flex");
    this.cost = this.getCost();
    this.addToInventory = (data == null ? void 0 : data.addToInventory) ?? true;
    this.added = false;
    this.placementOrder = (data == null ? void 0 : data.placementOrder) ?? null;
    this.offcut = true;
  }
  compressForSaving() {
    var _a2;
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((_a2 = this == null ? void 0 : this.stock) == null ? void 0 : _a2.id);
    delete this.stock;
    delete this._trim;
    delete this.trimmed;
  }
  getCost() {
    var _a2;
    if ((_a2 = this.stock) == null ? void 0 : _a2.isStock())
      return this.stock ? parseFloat((this.getArea() / this.stock.getArea() * this.stock.cost).toFixed(2)) : 0;
    return 0;
  }
}
function recreateOffcuts({
  offcuts,
  stockList,
  preventAutoRotation = true
}) {
  if (!offcuts || !(offcuts == null ? void 0 : offcuts.length)) return [];
  return offcuts.map((offcutObject) => {
    const stock = stockList.find((stock2) => {
      var _a2;
      return stock2.id === (((_a2 = offcutObject == null ? void 0 : offcutObject.stock) == null ? void 0 : _a2.id) ?? (offcutObject == null ? void 0 : offcutObject.stockId));
    });
    offcutObject.stock = stock;
    if (preventAutoRotation) offcutObject.preventAutoRotation = true;
    const offcut = new Offcut(offcutObject);
    return offcut;
  });
}
class Shape extends Rectangle {
  constructor(data) {
    data = sanitiseData(data);
    super(data);
    __publicField(this, "added");
    __publicField(this, "guillotineData");
    __publicField(this, "_banding");
    __publicField(this, "_bandingType");
    __publicField(this, "stockLock");
    __publicField(this, "orientationModel");
    __publicField(this, "score");
    __publicField(this, "bestScore");
    __publicField(this, "placementOrder");
    //groups
    __publicField(this, "groupPlacementOrder");
    __publicField(this, "group");
    __publicField(this, "groupID");
    __publicField(this, "inGroup");
    //is the shape currently part of at least one group
    __publicField(this, "inUserGroup");
    //is the shape currently part of a user group`
    __publicField(this, "addedAsGroup");
    __publicField(this, "isFirstShape");
    __publicField(this, "firstShapeSampleRotations", []);
    //used for setting the rotation of the first shape (guillotine)
    __publicField(this, "index");
    //used for ptx
    __publicField(this, "patternMatch");
    //used for stack detection
    __publicField(this, "stockMatch");
    __publicField(this, "machining");
    __publicField(this, "weighting");
    __publicField(this, "minSpacing");
    __publicField(this, "priority");
    this.initShape(data);
  }
  initGuillotineData(data) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    this.guillotineData = defaults({}, data == null ? void 0 : data.guillotineData, {
      firstShape: ((_a2 = this == null ? void 0 : this.guillotineData) == null ? void 0 : _a2.firstShape) || null,
      myPhase: ((_b = this == null ? void 0 : this.guillotineData) == null ? void 0 : _b.myPhase) || null,
      myStripParent: ((_c = this == null ? void 0 : this.guillotineData) == null ? void 0 : _c.myStripParent) || null,
      myStripDirection: ((_d = this == null ? void 0 : this.guillotineData) == null ? void 0 : _d.myStripDirection) || null,
      stripShapeBatches: {
        subsetUsed: ((_f = (_e = this == null ? void 0 : this.guillotineData) == null ? void 0 : _e.stripShapeBatches) == null ? void 0 : _f.subsetUsed) || false,
        groups: ((_h = (_g = this == null ? void 0 : this.guillotineData) == null ? void 0 : _g.stripShapeBatches) == null ? void 0 : _h.groups) || {}
      }
    });
  }
  cloneGuillotineData() {
    var _a2;
    if (((_a2 = this.guillotineData) == null ? void 0 : _a2.myStripParent) && (isShape(this.guillotineData.myStripParent) || isGroup(this.guillotineData.myStripParent))) {
      this.guillotineData.myStripParent = this.guillotineData.myStripParent.compress();
    }
    return structuredClone(this.guillotineData);
  }
  initShape(data, update = false) {
    var _a2;
    if (!update) {
      this.validateShape(data);
      if (this.issues.length) throw new Error(this.issues.join("\n"));
      data.orientationLock = (_a2 = data == null ? void 0 : data.orientationLock) == null ? void 0 : _a2.toLowerCase();
      if ((data == null ? void 0 : data.orientationLock) === " ") {
        data.orientationLock = "";
      }
      this.orientationLock = valueSet(data == null ? void 0 : data.orientationLock) && this.l !== this.w ? data.orientationLock : null;
      this.banding = data == null ? void 0 : data.banding;
      this.bandingType = data == null ? void 0 : data.bandingType;
      if (valueSet(data == null ? void 0 : data.stockLock)) {
        if (Array.isArray(data == null ? void 0 : data.stockLock))
          this.stockLock = data.stockLock.map((sl) => sl.toString());
      } else {
        this.stockLock = [];
      }
      this.weighting = {};
      this.machining = valueSet(data == null ? void 0 : data.machining) ? new Machining$1(data.machining) : null;
    }
    this.added = valueSet(data == null ? void 0 : data.added) ? data.added : false;
    this.initGuillotineData(data);
    this.inGroup = valueSet(data == null ? void 0 : data.inGroup) ? data.inGroup : this.inGroup || false;
    this.inUserGroup = valueSet(data == null ? void 0 : data.inUserGroup) ? data.inUserGroup : this.inUserGroup || false;
    this.groupID = valueSet(data == null ? void 0 : data.groupID) ? data.groupID : this.groupID || null;
    this.addedAsGroup = valueSet(data == null ? void 0 : data.addedAsGroup) ? data.addedAsGroup : this.addedAsGroup || false;
    this.score = valueSet(data == null ? void 0 : data.score) ? data.score : this.score || null;
    this.bestScore = valueSet(data == null ? void 0 : data.bestScore) ? data.bestScore : this.bestScore || {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.placementOrder = valueSet(data == null ? void 0 : data.placementOrder) ? data.placementOrder : this.placementOrder || null;
    this.groupPlacementOrder = valueSet(data == null ? void 0 : data.groupPlacementOrder) ? data.groupPlacementOrder : this.groupPlacementOrder || null;
    this.minSpacing = (data == null ? void 0 : data.minSpacing) ?? (this.minSpacing || 0);
    this.priority = (data == null ? void 0 : data.priority) ?? {};
  }
  getCopyNumber() {
    return parseInt(this.id.split(".").pop());
  }
  getMinSpacing(container, removeBlade = false) {
    var _a2, _b;
    if (!container) return 0;
    let minSpacing = (this == null ? void 0 : this.minSpacing) || ((_b = (_a2 = container.saw) == null ? void 0 : _a2.options) == null ? void 0 : _b.minSpacing) || 0;
    const bladeWidth = container.getBladeWidth();
    if (bladeWidth > minSpacing) minSpacing = bladeWidth;
    if (removeBlade) {
      minSpacing -= bladeWidth;
    }
    if (minSpacing < 0) minSpacing = 0;
    return minSpacing;
  }
  validateShape(data) {
    ["orientationLock", "banding"].forEach((key) => {
      this.createIssues(validation[key](data[key]));
    });
    if (this.machining) {
      this.machining.validateEverything(this);
    }
  }
  //individual shape weighting
  calculateWeighting() {
  }
  update(data) {
    data = sanitiseData(data);
    this.initShape(data, true);
    this.updateRectangle(data);
  }
  set banding(val) {
    this._banding = {
      a: false,
      b: false,
      c: false,
      d: false,
      x1: false,
      x2: false,
      y1: false,
      y2: false
    };
    if (!valueSet(val)) return;
    Object.keys(val).forEach((key) => this._banding[key] = valueSet(val == null ? void 0 : val[key]) ? val[key] : false);
  }
  get banding() {
    return this._banding;
  }
  set bandingType(val) {
    this._bandingType = {
      a: "",
      b: "",
      c: "",
      d: "",
      x1: "",
      x2: "",
      y1: "",
      y2: ""
    };
    if (!valueSet(val)) return;
    Object.keys(val).forEach((key) => this._bandingType[key] = valueSet(val[key]) ? truncateString(sanitiseString(val[key])) : "");
    for (const [key] of Object.entries(this._bandingType)) {
      if (this._bandingType[key] || this._banding[key])
        this._banding[key] = true;
    }
  }
  get bandingType() {
    return this._bandingType;
  }
  //get an array of banding in the order L1, L2, W1, W2
  get bandingArray() {
    return [
      this.banding.y1,
      this.banding.y2,
      this.banding.x1,
      this.banding.x2
    ];
  }
  //get an array of banding types in the order L1, L2, W1, W2
  get bandingTypeArray() {
    return [
      this.bandingType.y1,
      this.bandingType.y2,
      this.bandingType.x1,
      this.bandingType.x2
    ];
  }
  //compress for saving / transfer
  save() {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    delete this.group;
    {
      (_a2 = this == null ? void 0 : this.guillotineData) == null ? true : delete _a2.stripShapeBatches;
    }
    this.stockId = (_b = this == null ? void 0 : this.stock) == null ? void 0 : _b.id;
    delete this.stock;
    delete this.score;
    {
      delete this.bestScore;
    }
    if (!((_c = this._banding) == null ? void 0 : _c.x1) && !((_d = this._banding) == null ? void 0 : _d.x2) && !((_e = this._banding) == null ? void 0 : _e.y1) && !((_f = this._banding) == null ? void 0 : _f.y2)) {
      this._banding = null;
    }
    if (!((_g = this._bandingType) == null ? void 0 : _g.x1) && !((_h = this._bandingType) == null ? void 0 : _h.x2) && !((_i = this._bandingType) == null ? void 0 : _i.y1) && !((_j = this._bandingType) == null ? void 0 : _j.y2)) {
      this._bandingType = null;
    }
    {
      (_k = this.guillotineData) == null ? true : delete _k.myStripParent;
      delete this.score;
      delete this.inGroup;
      delete this.groupID;
      delete this.addedAsGroup;
    }
  }
  isExactFit(container) {
    return this.orientationLock === "w" && this.w === container.w || this.orientationLock === "l" && this.l === container.l || !this.orientationLock && (this.w === container.w && this.l === container.l);
  }
  addToStock(stock) {
    this.stock = stock;
    this.stockId = stock.id;
    this.added = true;
    this.inGroup = false;
    stock.used = true;
    this.grain = stock.grain;
    if ((stock == null ? void 0 : stock.grain) && this.rot) {
      this.grain = getReverseDimension(stock.grain);
    }
  }
  removeFromStock() {
    this.placementOrder = null;
    this.stock = null;
    this.stockId = null;
    this.added = false;
    this.addedAsGroup = false;
    if (isGroup(this)) {
      this.shapes.forEach((s) => s.removeFromStock());
    }
  }
  setBestScore(winner, point = null) {
    const bestScore = {
      x: winner.x,
      y: winner.y,
      rot: winner.rot,
      total: winner.score.total,
      score: winner.score,
      group: winner.group,
      weighting: null,
      point
    };
    this.bestScore = bestScore;
  }
  resetPosition() {
    this.x = 0;
    this.y = 0;
    this.placementOrder = null;
    this.resetGuillotineData(true);
  }
  resetScore() {
    this.score = null;
    this.resetGuillotineData(true);
  }
  resetBestScore() {
    const bestScore = {
      x: 0,
      y: 0,
      rot: null,
      total: null,
      group: null
    };
    this.bestScore = bestScore;
    this.resetGuillotineData(true);
  }
  resetBothScores() {
    this.resetBestScore();
    this.resetScore();
    this.placementOrder = null;
  }
  reset(keepScores = false, keepGuillotineBatchData = true) {
    this.removeFromStock();
    if (!keepScores) this.resetBothScores();
    this.resetPosition();
    this.setRotation(0);
    this.resetGuillotineData(keepGuillotineBatchData);
    this.placementOrder = null;
    this == null ? true : delete this.isFirstShape;
    this.patternMatch = false;
    this.isFirstShape = false;
    if (this.group) this.group.destroy();
    this.groupID = null;
    this.group = null;
    this.inGroup = false;
    this.groupPlacementOrder = null;
    this.grain = null;
  }
  resetGuillotineData(keepStripShapeBatches = false) {
    var _a2, _b;
    const data = {
      firstShape: false,
      myPhase: null,
      myStripDirection: null,
      stripShapeBatches: {
        subsetUsed: false,
        groups: {}
      }
    };
    if (keepStripShapeBatches) {
      data.stripShapeBatches.groups = (_b = (_a2 = this.guillotineData) == null ? void 0 : _a2.stripShapeBatches) == null ? void 0 : _b.groups;
    }
    this.guillotineData = data;
  }
  round() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y),
      l: Math.round(this.l),
      w: Math.round(this.w)
    };
  }
  //get an array of allowed rotations for this container
  getAllowedRotations(container) {
    const rotations = [];
    for (let i = 0; i <= 1; i++) {
      if (this.canRotate(i, container) && this.willItFit(container, i)) {
        rotations.push(i);
      }
    }
    return rotations;
  }
  /**
   * checks if a shape can rotate
   * checks for fit and grain
   * does not change the shape's rotation during the checks
   * @returns false if cannot rotate or can rotate but won't fit
   */
  canRotate(rotation = null, container = null) {
    if (!valueSet(rotation))
      throw new Error("no rotation provided to canRotate");
    if (rotation === true) rotation = 1;
    if (rotation === false) rotation = 0;
    if (this.isSquare() && rotation) return false;
    if (container) {
      if (!this.willItFit(container, rotation)) return false;
    }
    const orientationLock = this.getNecessaryOrientation(container);
    if (orientationLock === "l" && rotation === 1) return false;
    if (orientationLock === "w" && rotation === 0) return false;
    return true;
  }
  /**
   * can a shape rotate to produce the specified dimensions on a specific side
   * @todo tests
   */
  canRotateToDimension(value2, requiredSide, container = null) {
    if (!requiredSide) throw new Error("requiredSide not supplied to canRotateToDimension");
    if (this.l !== value2 && this.w !== value2) return false;
    if (this.l === this.w) return true;
    const long = this.getLongSide();
    const short = this.getShortSide();
    if (container) {
      if (requiredSide === "l") {
        if (long === value2 && this.canRotate(0, container)) return true;
        if (short === value2 && this.canRotate(1, container)) return true;
      } else if (requiredSide === "w") {
        if (short === value2 && this.canRotate(0, container)) return true;
        if (long === value2 && this.canRotate(1, container)) return true;
      }
    } else if (this.orientationLock) {
      if (this.orientationLock === "l") {
        return requiredSide === "l" && value2 === long;
      } else if (this.orientationLock === "w") {
        return requiredSide === "l" && value2 === short;
      }
    }
    return false;
  }
  canRotateToDimensionRange(minValue, maxValue, requiredSide, container = null) {
    if (!requiredSide) throw new Error("requiredSide not supplied to canRotateToDimensionRange");
    if (this.l >= minValue && this.l <= maxValue || this.w >= minValue && this.w <= maxValue) {
      if (this.l === this.w) return true;
      const long = this.getLongSide();
      const short = this.getShortSide();
      if (container) {
        if (requiredSide === "l") {
          if (long >= minValue && long <= maxValue && this.canRotate(0, container)) return true;
          if (short >= minValue && short <= maxValue && this.canRotate(1, container)) return true;
        } else if (requiredSide === "w") {
          if (short >= minValue && short <= maxValue && this.canRotate(0, container)) return true;
          if (long >= minValue && long <= maxValue && this.canRotate(1, container)) return true;
        }
      } else if (this.orientationLock) {
        if (this.orientationLock === "l") {
          return requiredSide === "l" && long >= minValue && long <= maxValue;
        } else if (this.orientationLock === "w") {
          return requiredSide === "l" && short >= minValue && short <= maxValue;
        }
      }
    }
    return false;
  }
  rotateToDimension(value2, requiredSide, stock) {
    if (!requiredSide) throw new Error("requiredSide not supplied to rotateToDimension");
    if (this.l !== value2 && this.w !== value2) return false;
    if (this.l === this.w) return true;
    const long = this.getLongSide();
    const short = this.getShortSide();
    if (requiredSide === "l") {
      if (long === value2 && this.canRotate(0, stock)) return this.setRotation(0);
      if (short === value2 && this.canRotate(1, stock)) return this.setRotation(1);
    } else if (requiredSide === "w") {
      if (short === value2 && this.canRotate(0, stock)) return this.setRotation(0);
      if (long === value2 && this.canRotate(1, stock)) return this.setRotation(1);
    }
    return false;
  }
  //get the orientation lock catering for container grain
  convertShapeGrainToOrientationLock(container) {
    if (!container) throw new Error("container not supplied to convertShapeGrainToOrientationLock");
    if (!isContainer(container)) throw new Error("container is not a container");
    if (isGroup(this)) return this.orientationLock;
    if (!valueSet(this.orientationLock)) return null;
    const stock = container.getStock();
    if (!valueSet(stock.grain)) return this.orientationLock;
    if (this.orientationLock === stock.grain) return "l";
    return "w";
  }
  /**
   * get the orientation lock catering for container grain
   */
  getNecessaryOrientation(container) {
    if (!container) return this.orientationLock;
    if (isGroup(this)) return this.orientationLock;
    if (!valueSet(this.orientationLock)) return null;
    if (isContainer(container)) {
      return this.convertShapeGrainToOrientationLock(container);
    } else if (isGroup(this) || isUserGroup(this)) {
      return valueSet(this.orientationLock) ? this.orientationLock : null;
    }
  }
  /**
   * get the required grain rotation
   * checks for stock grain and part orientationLock
   * does not check for fit
   */
  getGrainRotation(container) {
    if (isGroup(this)) return this.rot;
    if (!valueSet(this.orientationLock)) return null;
    const stock = container.getStock();
    if (!this.orientationLock) return null;
    if (!valueSet(stock == null ? void 0 : stock.grain)) return null;
    if (this.isGroup()) return this.orientationLock === "l" ? 0 : 1;
    if (this.orientationLock === (stock == null ? void 0 : stock.grain)) return 0;
    return 1;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  rotate(rot = null, container = null) {
    if (rot === null) rot = this.rot === 0 ? 1 : 0;
    if (!this.canRotate(rot, container)) return false;
    if (this.rot === rot) return true;
    this.swapDimensions();
    return true;
  }
  swapDimensions() {
    [this.l, this.w] = [this.w, this.l];
  }
  forceRotate(rot) {
    if (rot === null) rot = this.rot === 0 ? 1 : 0;
    if (this.rot === rot) return true;
    this.swapDimensions();
    return true;
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotation(rot = null, container = null) {
    if (rot) rot = 1;
    else rot = 0;
    if (container && rot && !this.willItFit(container, rot)) return false;
    return this.rotate(rot, container);
  }
  /**
   * rotates the shape if allowed
   * checks for fit and grain
   * @returns false if cannot rotate or can rotate but won't fit
   */
  setRotationToOrientationLock(container) {
    if (!container)
      throw new Error("container not supplied to setRotationToOrientationLock");
    const requiredOrientation = this.getNecessaryOrientation(container);
    if (requiredOrientation === "l") return this.setRotation(0);
    if (requiredOrientation === "w") return this.setRotation(1);
  }
  setRotationToOrientationLockWithoutContainer() {
    if (this.orientationLock === "l") return this.setRotation(0);
    if (this.orientationLock === "w") return this.setRotation(1);
  }
  getBandingLength(key) {
    if (key === "x1" || key === "x2") return this.getShortSide();
    if (key === "y1" || key === "y2") return this.getLongSide();
  }
  getPriority(stock) {
    var _a2;
    if (!stock) return 0;
    const id = stock.parentID;
    if ((_a2 = this.priority) == null ? void 0 : _a2[id]) return this.priority[id];
    return 0;
  }
  clearPriority() {
    this.priority = {};
  }
  getPerimeterCutVectors() {
    var _a2;
    const offset = ((_a2 = this.stock) == null ? void 0 : _a2.isStock()) ? this.stock.getBladeWidth() / 2 : null;
    const vectors = [
      //bottom
      {
        x1: this.x - offset,
        x2: this.x + this.l + offset,
        y1: this.y - offset,
        y2: this.y - offset,
        type: "bottom"
      },
      //right
      {
        x1: this.x + this.l + offset,
        x2: this.x + this.l + offset,
        y1: this.y - offset,
        y2: this.y + this.w + offset,
        type: "right"
      },
      //top
      {
        x1: this.x - offset,
        x2: this.x + this.l + offset,
        y1: this.y + this.w + offset,
        y2: this.y + this.w + offset,
        type: "top"
      },
      //left
      {
        x1: this.x - offset,
        x2: this.x - offset,
        y1: this.y - offset,
        y2: this.y + this.w + offset,
        type: "left"
      }
    ];
    return vectors;
  }
  /* getTrimmedDimensions()
  	{
  		if ( this.trimmed )
  			return {
  				l: this.l,
  				w: this.w
  			};
  
  		return {
  			l: this.l - this.trim.x1 - this.trim.x2,
  			w: this.w - this.trim.y1 - this.trim.y2
  		};
  	} */
  /**
   * create cuts around the perimeter of a shape
   * @param {Stock} stock
   * @returns {Array} cuts
   */
  createPerimeterCuts(stock = null) {
    let perimeterCuts = [];
    stock = stock ? stock : this.stock;
    if (!stock) throw new Error("stock is required to create a cut");
    const vectors = this.getPerimeterCutVectors();
    vectors.forEach((vector) => {
      var _a2;
      return perimeterCuts.push(new Cut({
        stock: ((_a2 = this.stock) == null ? void 0 : _a2.isStock()) ? this.stock : stock,
        x1: vector.x1,
        x2: vector.x2,
        y1: vector.y1,
        y2: vector.y2,
        type: vector.type
      }));
    });
    perimeterCuts = perimeterCuts.filter((cut) => cut.isInsideStock());
    return perimeterCuts;
  }
  createOffset(amount) {
    if (!this.stock) throw new Error("createOffset - stock not defined");
    const offset = {
      x: this.x - amount,
      y: this.y - amount,
      l: this.l + amount * 2,
      w: this.w + amount * 2
    };
    if (offset.x < 0) {
      offset.x = 0;
      offset.l -= amount;
    }
    if (offset.y < 0) {
      offset.y = 0;
      offset.w -= amount;
    }
    if (offset.x + offset.l > this.stock.l) {
      offset.l = this.stock.l - offset.x;
    }
    if (offset.y + offset.w > this.stock.w) {
      offset.w = this.stock.w - offset.y;
    }
    return offset;
  }
  setPositionToBestScore() {
    this.setRotation(this.bestScore.rot);
    this.x = this.bestScore.x;
    this.y = this.bestScore.y;
  }
  /**
   * will this shape fit in a container
   */
  willItFit(container, rotation = null) {
    return willItFit(container, this, rotation);
  }
  clone(version2 = null) {
    const id = this.id.split(".");
    if (!version2) {
      version2 = id.pop();
      version2++;
    } else {
      id.pop();
    }
    id.push(version2);
    const newId = id.join(".");
    const data = structuredClone(this);
    data.id = newId;
    data.added = false;
    data.duplicate = true;
    delete data.score;
    delete data.bestScore;
    delete data.stock;
    delete data.placementOrder;
    delete data.inGroup;
    delete data.addedAsGroup;
    delete data.groupID;
    delete data.isFirstShape;
    const shape = new Shape(data);
    return shape;
  }
  //this is a compressed version of the shape to help with memory management
  compress() {
    const guillotineData = this.cloneGuillotineData();
    guillotineData.myStripParent = isShapeOrGroup(this.guillotineData.myStripParent) ? this.guillotineData.myStripParent.id : this.guillotineData.myStripParent;
    const clone = {
      id: this.id,
      x: this.added ? this.x : 0,
      y: this.added ? this.y : 0,
      l: this.l,
      w: this.w,
      added: this.added,
      guillotineData,
      placementOrder: this.placementOrder,
      bestScore: this.bestScore,
      inGroup: this.inGroup,
      groupID: this.groupID,
      addedAsGroup: this.addedAsGroup,
      groupPlacementOrder: this.groupPlacementOrder,
      minSpacing: this.minSpacing,
      cloneType: "shape",
      priority: Object.assign({}, this.priority)
    };
    return clone;
  }
  isTooCloseToEdges(container) {
    var _a2, _b;
    const minSpacing = ((_b = (_a2 = container.saw) == null ? void 0 : _a2.options) == null ? void 0 : _b.minSpacing) || this.minSpacing;
    if (!minSpacing) return false;
    return this.getDistancesToContainerEdges(container).some((d) => d > 0 && d <= minSpacing);
  }
  validateStripShapeBatches() {
    const groups = Object.values(this.guillotineData.stripShapeBatches.groups);
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      if (group.id !== this.id) {
        throw new Error(`strip shape group id does not match shape id ${this.id} ${group.id} ${i}`);
      }
      if (![this.l, this.w].includes(group.dimension)) {
        throw new Error(`strip shape group dimension does not match shape dimensions ${this.id} ${group.id} ${i} ${this.l} ${this.w} ${group.dimension}`);
      }
    }
  }
  getStripShapeBatchData(batchNumber) {
    var _a2;
    if (typeof batchNumber !== "number") return false;
    if (!((_a2 = this == null ? void 0 : this.guillotineData) == null ? void 0 : _a2.stripShapeBatches)) return false;
    if (!this.guillotineData.stripShapeBatches.groups) return false;
    if (!(batchNumber in this.guillotineData.stripShapeBatches.groups))
      return false;
    return this.guillotineData.stripShapeBatches.groups[batchNumber];
  }
  isInStripShapeBatch(batchNumber) {
    const batchInfo = this.getStripShapeBatchData(batchNumber);
    if (!batchInfo) return false;
    return true;
  }
}
class Segment extends Container {
  constructor(data) {
    if (!data) return;
    data.preventAutoRotation = true;
    super(data);
    __publicField(this, "firstShape");
    __publicField(this, "cuts");
    __publicField(this, "phase");
    __publicField(this, "merged");
    __publicField(this, "children");
    __publicField(this, "siblings");
    //used by vis only
    __publicField(this, "parent");
    __publicField(this, "segmentType");
    __publicField(this, "completed");
    //used by vis only
    __publicField(this, "rowSegment");
    //used by cuts
    __publicField(this, "placementOrder");
    __publicField(this, "hasBeamTrim");
    __publicField(this, "cutDirection");
    this.validateSegment(data);
    if (this.issues.length)
      throw new Error(`Segment validation failed - ${this.issues.join(" ")}`);
    delete this.trim;
    delete this.trimmed;
    this.shapes = valueSet(data == null ? void 0 : data.shapes) ? data.shapes : [];
    this.firstShape = valueSet(data == null ? void 0 : data.firstShape) ? data.firstShape : null;
    this.cuts = [];
    this.phase = valueSet(data == null ? void 0 : data.phase) ? data.phase : null;
    this.merged = valueSet(data == null ? void 0 : data.merged) ? data.merged : false;
    this.parent = valueSet(data == null ? void 0 : data.parent) ? data.parent : null;
    this.children = valueSet(data == null ? void 0 : data.children) ? data.children : [];
    this.siblings = valueSet(data == null ? void 0 : data.siblings) ? data.siblings : [];
    this.offcut = valueSet(data == null ? void 0 : data.offcut) ? data.offcut : false;
    this.segmentType = valueSet(data == null ? void 0 : data.segmentType) ? data.segmentType : null;
    this.placementOrder = null;
    this.cutDirection = valueSet(data == null ? void 0 : data.cutDirection) ? data.cutDirection : "l";
    this.hasBeamTrim = valueSet(data == null ? void 0 : data.hasBeamTrim) ? data.hasBeamTrim : false;
  }
  validateSegment(data) {
    var _a2, _b;
    if (maths.lessThanOrEqualTo(data.w, 0) || maths.lessThanOrEqualTo(data.l, 0)) {
      this.issues.push(`Zero / negative dimension - l: ${data.l}, w: ${data.w}.`);
    }
    if (maths.lessThan(data.x, 0) || maths.lessThan(data.y, 0)) {
      this.issues.push(`Negative position - x: ${data == null ? void 0 : data.x}, y: ${data == null ? void 0 : data.y}.`);
    }
    if (data == null ? void 0 : data.stock) {
      if (maths.greaterThan(data.x + data.l, data.stock.l) || maths.greaterThan(data.y + data.w, data.stock.w)) {
        this.issues.push(`Outside of stock ${data.stock.id} - x: ${data.x}, y: ${data.y}, l: ${data.l}, w: ${data.w}, sl: ${(_a2 = data == null ? void 0 : data.stock) == null ? void 0 : _a2.l}, sw: ${(_b = data == null ? void 0 : data.stock) == null ? void 0 : _b.w}.`);
      }
    }
  }
  //compress for saving / transfer
  save() {
    var _a2;
    this.children = this.children.map((c2) => {
      return {
        id: c2.id,
        x: c2.x,
        y: c2.y,
        l: c2.l,
        w: c2.w,
        offcut: c2.offcut
      };
    });
    this.stockId = (this == null ? void 0 : this.stockId) ?? ((_a2 = this == null ? void 0 : this.stock) == null ? void 0 : _a2.id);
    delete this.stock;
    delete this.shapes;
    delete this.saw;
    delete this.siblings;
    delete this.parent;
    delete this.trim;
    this.algoBenchmark = null;
  }
  getBladeWidth() {
    return this.stock.getBladeWidth();
  }
  /**
   * create a normalised shape list to allow searching for duplicates
   */
  getNormalisedShapes(shapes) {
    return shapes.map((shape) => {
      const normalisedShape = {
        x: shape.x - this.x,
        y: shape.y - this.y,
        l: shape.l,
        w: shape.w
      };
      return normalisedShape;
    });
  }
  reset() {
    this.stock.used = false;
    this.children = [];
    this.siblings = [];
    this.parent = null;
    this.cuts = [];
    this.phase = null;
  }
}
class Group extends Shape {
  //used for sorting
  constructor(data) {
    var _a2, _b;
    data = sanitiseData(data);
    if (!((_a2 = data == null ? void 0 : data.shapes) == null ? void 0 : _a2.length))
      throw new Error("attempting to create a group with no shapes");
    data.preventAutoRotation = true;
    super(data);
    __publicField(this, "shapes");
    __publicField(this, "positions");
    __publicField(this, "direction");
    __publicField(this, "container");
    __publicField(this, "outOfBounds");
    __publicField(this, "collision");
    __publicField(this, "counter", 0);
    __publicField(this, "type");
    __publicField(this, "efficiency");
    this.q = 1;
    delete this._banding;
    delete this._bandingType;
    delete this._trim;
    this.shapes = data.shapes;
    this.positions = ((_b = data == null ? void 0 : data.positions) == null ? void 0 : _b.length) ? data.positions : [];
    this.direction = data.direction;
    this.container = data.container;
    this.type = (data == null ? void 0 : data.type) ?? "auto";
    this.initGroup();
  }
  initGroup() {
    var _a2;
    if (!((_a2 = this == null ? void 0 : this.shapes) == null ? void 0 : _a2.length)) return;
    this.setShapePositions();
    if (this.w > this.l) this.orientationLock = "w";
    else this.orientationLock = "l";
    if (this.container) {
      this.efficiency = this[this.direction] / this.container[this.direction];
    }
  }
  setShapePositions() {
    if (!this.container) return;
    this.positions = [];
    if (this.type !== "user") this.sortShapes();
    let currentPosition = 0;
    const groupAxis = getAxisFromDimension(this.direction);
    this.shapes.forEach((s, i) => {
      this.positions.push({
        shape: s.id,
        [groupAxis]: currentPosition,
        [getReverseAxis(groupAxis)]: 0,
        rot: s.rot.valueOf()
      });
      s.inGroup = true;
      currentPosition += i === this.shapes.length - 1 ? s[this.direction] : s[this.direction] + s.getMinSpacing(this.container);
    });
    this[this.direction] = currentPosition;
    const secondaryDimension = getReverseDimension(this.direction);
    const largestShapeInOtherDirection = this.shapes.reduce((max2, shape) => shape[secondaryDimension] > max2 ? shape[secondaryDimension] : max2, 0);
    this[secondaryDimension] = largestShapeInOtherDirection;
    if (isDev()) {
      const totalSpacing = this.shapes.slice(0, -1).reduce((total, shape) => total + shape.getMinSpacing(this.container), 0);
      const totalShapeDimension = this.shapes.reduce((total, shape) => total + shape[this.direction], 0);
      const totalInDirection = totalShapeDimension + totalSpacing;
      test([
        () => expect(maths.equalTo(totalInDirection, this[this.direction]), "group dimension is incorrect in direction").to.be.true,
        () => expect(currentPosition, "currentPosition is incorrect in direction").to.equal(this[this.direction]),
        () => expect(largestShapeInOtherDirection, "group dimension in other direction is not correct").to.equal(this[secondaryDimension])
      ]);
    }
    if (this.w > this.container.w || this.l > this.container.l) {
      throw new Error(`group ${this.id} is bigger than container - group ${this.l}x${this.w}, container ${this.container.l}x${this.container.w}`);
    }
  }
  //update the shape spacing and overall group dimensions to account for min spacing
  updateShapeSpacing(container) {
    this.container = container;
    this.setShapePositions();
    if (this.w > this.l) this.orientationLock = "w";
    else this.orientationLock = "l";
    if (this.container) {
      this.efficiency = this[this.direction] / this.container[this.direction];
    }
  }
  //get the area of the shapes (does not include blade width) - overwrites the rectangle method
  getArea() {
    return this.shapes.reduce((total, shape) => {
      return total + shape.getArea();
    }, 0);
  }
  destroy() {
    this.shapes.forEach((s) => {
      s.inGroup = false;
      s.addedAsGroup = false;
      s == null ? true : delete s.group;
      s == null ? true : delete s.groupID;
      s == null ? true : delete s.groupPlacementOrder;
    });
  }
  /**
   * orientate all the shapes correctly to fit in the group
   */
  orientateShapes(stock) {
    this.shapes.forEach((s) => {
      const position = this.positions.find((p2) => p2.shape === s.id);
      if (!position) throw new Error("position not found for shape in group");
      const result = s.rotate(position.rot, stock);
      if (!result) throw new Error("orientateShapes - unable to rotate shape in group");
    });
  }
  /**
   * sort the shapes by size
   */
  sortShapes() {
    const sortDimension = getReverseDimension(this.direction);
    this.shapes.sort((a2, b) => {
      if (b[sortDimension] === a2[sortDimension]) {
        if (b[this.direction] === a2[this.direction]) {
          return a2.id.localeCompare(b.id, void 0, { numeric: true });
        }
        return b[this.direction] - a2[this.direction];
      }
      return b[sortDimension] - a2[sortDimension];
    });
  }
  /**
   * place the group shapes on the stock
   */
  placeMyShapes(stock) {
    if (!stock) throw new Error("placeShapes requires stock");
    this.addToStock(stock);
    for (let i = 0; i < this.shapes.length; i++) {
      const s = this.shapes[i];
      s.addToStock(stock);
      const position = this.positions.find((p2) => p2.shape === s.id);
      if (!position) throw new Error("position not found for shape in group");
      s.x = this.x + position.x;
      s.y = this.y + position.y;
      const rotationResult = s.rotate(position.rot, stock);
      if (!rotationResult) throw new Error("placeMyShapes - unable to rotate shape in group");
      if (i === 0 && this.x === 0 && this.y === 0) {
        s.isFirstShape = true;
      }
      s.addedAsGroup = this.id;
      s.inGroup = false;
      s.score = this.score;
      const stripShapeBatchesData = s.guillotineData.stripShapeBatches;
      s.guillotineData = this.cloneGuillotineData();
      s.guillotineData.stripShapeBatches = stripShapeBatchesData;
      s.bestScore = this.bestScore;
      if (typeof this.placementOrder === "number") {
        s.groupPlacementOrder = i;
        s.placementOrder = this.placementOrder + i / 1e6;
      }
    }
  }
  //this is for groups which are created once and reused between stock e.g. user groups
  orientateCorrectly(container) {
    this.orientateShapes(container);
    this.setRotationToOrientationLock(container);
  }
  clone(shapes = []) {
    const groupNumber = parseInt(this.id.split("g")[1]);
    const newID = `g${groupNumber + 1}`;
    const originalShapes = this.shapes;
    const originalContainer = this.container;
    delete this.shapes;
    delete this.container;
    const data = structuredClone(this);
    this.shapes = originalShapes;
    this.container = originalContainer;
    data.container = this.container;
    data.shapes = shapes;
    data.id = newID;
    return new Group(data);
  }
  compress() {
    const clone = Shape.prototype.compress.call(this);
    clone.direction = this.direction;
    clone.positions = structuredClone(this.positions);
    clone.shapes = this.shapes.map((s) => s.compress());
    clone.type = this.type;
    clone.cloneType = "group";
    return clone;
  }
}
function getMatchingStock(shape, stockList, stockMaterialPresent, stockThicknessPresent) {
  return stockList.filter((stock, stockIndex) => {
    shape.stockMatch.material[stockIndex] = null;
    shape.stockMatch.thickness[stockIndex] = null;
    shape.stockMatch.width[stockIndex] = null;
    shape.stockMatch.fit[stockIndex] = null;
    if (isShape(shape) || isUserGroup(shape)) {
      if (willItFit(stock, shape)) {
        shape.stockMatch.fit[stockIndex] = true;
      } else {
        shape.stockMatch.fit[stockIndex] = false;
      }
    }
    if (!stockMaterialPresent) {
      shape.stockMatch.material[stockIndex] = true;
    } else if (stock.material === shape.material) {
      shape.stockMatch.material[stockIndex] = true;
    } else {
      shape.stockMatch.material[stockIndex] = false;
    }
    if (!stockThicknessPresent) {
      shape.stockMatch.thickness[stockIndex] = true;
    } else if (valueSet(shape.t) && valueSet(stock.t)) {
      if (isShape(shape) && maths.equalTo(shape.t, stock.t)) {
        shape.stockMatch.thickness[stockIndex] = true;
      } else if (shape.t === stock.t) {
        shape.stockMatch.thickness[stockIndex] = true;
      }
    } else {
      shape.stockMatch.thickness[stockIndex] = false;
    }
    if (stock.type === "linear") {
      if (isShape(shape)) {
        if (shape.canRotate(0, stock) && maths.equalTo(shape.w, stock.w) || shape.canRotate(1, stock) && maths.equalTo(shape.l, stock.w))
          shape.stockMatch.width[stockIndex] = true;
        else {
          shape.stockMatch.width[stockIndex] = false;
        }
      }
    } else {
      shape.stockMatch.width[stockIndex] = true;
    }
    return shape.stockMatch.fit[stockIndex] && shape.stockMatch.material[stockIndex] && shape.stockMatch.thickness[stockIndex] && shape.stockMatch.width[stockIndex];
  });
}
function stockMatch(shapeList, stockList, stockType) {
  const isInputs = isInputShape(shapeList[0]);
  if (isInputs) {
    shapeList = shapeList.map((s) => {
      const shape = new Shape(s);
      shape.trimDimensions();
      return shape;
    });
  }
  if (isInputStock(stockList[0])) {
    stockList = stockList.map((s, i) => {
      s.id = `${i.toString()}.0`;
      return new Stock(s);
    });
  }
  const stockLockSetManually = shapeList.some((s) => valueSet(s.stockLock) && s.stockLock.length);
  if (stockLockSetManually) return;
  stockList = stockList.filter((s) => s.autoAdd === true || valueSet(s.q) && s.q > 0);
  const stockMaterialSet = stockList.some((s) => valueSet(s.material));
  const stockThicknessSet = stockList.some((s) => valueSet(s.t));
  const allocatedStock = /* @__PURE__ */ new Set();
  for (let i = 0; i < shapeList.length; i++) {
    const shape = shapeList[i];
    shape.stockMatch = {
      material: [],
      thickness: [],
      width: [],
      fit: []
    };
    const matchingStock = getMatchingStock(shape, stockList, stockMaterialSet, stockThicknessSet);
    shape.stockMatch.fit = !shape.stockMatch.fit.every((v) => v === false);
    shape.stockMatch.material = !shape.stockMatch.material.every((v) => v === false);
    shape.stockMatch.thickness = !shape.stockMatch.thickness.every((v) => v === false);
    shape.stockMatch.width = !shape.stockMatch.width.every((v) => v === false);
    if (!isInputs) {
      if (matchingStock.length) {
        const stockParentIds = matchingStock.map((stock) => stock.getParentID());
        shape.stockLock = stockParentIds;
        stockParentIds.forEach((id) => allocatedStock.add(id));
      } else {
        if (!shape.stockMatch.fit) {
          const dims = shape.getTrimmedDimensions();
          shape.issues.push(`${dims.l.toFixed()}x${dims.w.toFixed()} will not fit on any stock - check dimensions, min spacing, trim & orientation lock`);
        } else {
          if (!shape.stockMatch.material) {
            shape.issues.push(`materials must match - could not find any stock with ${shape.material ? shape.material + " material" : "no material set"}`);
          }
          if (!shape.stockMatch.thickness) {
            shape.issues.push(`thicknesses must match - could not find any stock with ${shape.t ? "thickness " + shape.t : "no thickness set"}`);
          }
          if (stockType === "linear" && !shape.stockMatch.width) {
            shape.issues.push(`widths must match for linear calculations - could not find any stock with ${shape.w ? "width " + shape.w : "no width set"}`);
          }
        }
      }
      shape.stockMatch = null;
    }
  }
  const unusableShapes = shapeList.filter((s) => !s.stockLock || !s.stockLock.length).sort(sort.ID);
  const unusableStock = stockList.filter((s) => !allocatedStock.has(s.parentID)).sort(sort.ID);
  stockList = stockList.filter((s) => isStock(s)).filter((s) => allocatedStock.has(s.parentID));
  if (stockMaterialSet || stockThicknessSet)
    shapeList = shapeList.filter((s) => {
      var _a2;
      return (_a2 = s == null ? void 0 : s.stockLock) == null ? void 0 : _a2.length;
    });
  return {
    stockList,
    unusableShapes,
    shapeList,
    unusableStock
  };
}
function getStockGrainSummary(inputStock) {
  const grainValues = inputStock.map((s) => s.grain).filter((v) => v);
  if (!grainValues.length) return "n";
  if (grainValues.every((v) => v === "l")) {
    return "l";
  } else if (grainValues.every((v) => v === "w")) {
    return "w";
  } else if (grainValues.some((v) => v === "l" || v === "w")) {
    return "y";
  } else {
    return "n";
  }
}
function isGroupData(data) {
  return data.shapes !== void 0;
}
function isGroup(object2) {
  return object2 instanceof Group && object2.type !== "user";
}
function isUserGroup(object2) {
  return object2 instanceof Group && object2.type === "user";
}
function isInputUserGroup(object2) {
  return object2 instanceof InputUserGroup;
}
function isInputStock(s) {
  return s instanceof InputStock;
}
function isInputShape(s) {
  return s instanceof InputShape;
}
function isStock(s) {
  return s instanceof Stock;
}
function isContainer(s) {
  return s instanceof Container;
}
function isShape(s) {
  return s instanceof Shape && !(s instanceof Group);
}
function isShapeOrGroup(s) {
  return s instanceof Shape || s instanceof Group;
}
function isSegment(s) {
  return s instanceof Segment;
}
function isSaw(s) {
  return s instanceof Saw;
}
class Point {
  constructor(x, y2, z = null) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "z");
    __publicField(this, "a");
    //shape id
    __publicField(this, "b");
    //shape id
    __publicField(this, "fromDirection");
    __publicField(this, "type");
    __publicField(this, "corner");
    __publicField(this, "grid");
    __publicField(this, "stockID");
    __publicField(this, "raycast");
    __publicField(this, "collision");
    __publicField(this, "tooClose");
    __publicField(this, "adjustedForMinSpacing");
    this.x = parseFloat(x);
    this.y = parseFloat(y2);
    this.z = parseFloat(z) || 0;
    this.validate();
  }
  //clone with the ability to change the coordinates
  clone(x = null, y2 = null) {
    const data = structuredClone(this);
    const point = new Point(
      x === null ? data.x : x,
      y2 === null ? data.y : y2
    );
    for (const key in data) {
      if (key === "x" || key === "y") continue;
      point[key] = data[key];
    }
    return point;
  }
  validate() {
    if (isNaN(this.x) || isNaN(this.y))
      throw new Error("invalid point coordinates");
  }
  coords() {
    return {
      x: this.x,
      y: this.y
    };
  }
  collidesWith(shape) {
    return this.x >= shape.x && this.x <= shape.x + shape.l && this.y >= shape.y && this.y <= shape.y + shape.w;
  }
  isIdenticalTo(point) {
    return this.x === point.x && this.y === point.y;
  }
  /* given a grid point, get the available positions for this shape
     does not cater for diagonals */
  getAvailableShapePositions(container) {
    const availableShapePositions = /* @__PURE__ */ new Set();
    if ((container == null ? void 0 : container.cutType) !== "efficiency") {
      if (this.corner === "topLeft") {
        if (this.grid === "top" || !this.grid) {
          availableShapePositions.add("topRight");
        }
      }
      if (this.corner === "bottomRight") {
        if (this.grid === "right" || !this.grid) {
          availableShapePositions.add("topRight");
        }
      }
      return availableShapePositions;
    }
    if (this.corner === "topRight") {
      if (this.grid === "top" || !this.grid) {
        availableShapePositions.add("topLeft");
      }
      if (this.grid === "right" || !this.grid) {
        availableShapePositions.add("bottomRight");
      }
    }
    if (this.corner === "topLeft") {
      if (this.grid === "top" || !this.grid) {
        availableShapePositions.add("topRight");
      }
      if (this.grid === "left" || !this.grid) {
        availableShapePositions.add("bottomLeft");
      }
    }
    if (this.corner === "bottomRight") {
      if (this.grid === "bottom" || !this.grid) {
        availableShapePositions.add("bottomLeft");
      }
      if (this.grid === "right" || !this.grid) {
        availableShapePositions.add("topRight");
      }
    }
    if (this.corner === "bottomLeft") {
      if (this.grid === "bottom" || !this.grid) {
        availableShapePositions.add("bottomRight");
      }
      if (this.grid === "left" || !this.grid) {
        availableShapePositions.add("topLeft");
      }
    }
    return availableShapePositions;
  }
}
class PointCollection {
  constructor(points = []) {
    __publicField(this, "points", /* @__PURE__ */ new Map());
    points.forEach((p2) => this.addPoint(p2));
  }
  addPoint(p2, type3 = null) {
    if (!(p2 instanceof Point)) {
      throw new Error("p is not an instance of Point");
    }
    if (this.contains(p2)) {
      const existingPoint = this.getPoint(p2);
      if (existingPoint.type === "group" && !type3) {
        existingPoint.type = void 0;
      }
      return;
    }
    p2.validate();
    if (type3) p2.type = type3;
    this.points.set(this.createKey(p2), p2);
  }
  addPoints(points, type3 = null) {
    points.forEach((p2) => {
      if (!p2) return;
      p2.validate();
      this.addPoint(p2, type3);
    });
  }
  createKey(p2) {
    return `${p2.x},${p2.y}`;
  }
  getPoint(p2) {
    return this.points.get(this.createKey(p2));
  }
  deletePoint(p2) {
    p2.validate();
    this.points.delete(this.createKey(p2));
  }
  deletePoints(points) {
    points.forEach((p2) => {
      p2.validate();
      this.deletePoint(p2);
    });
  }
  clear() {
    this.points.clear();
  }
  toArray() {
    return Array.from(this.points.values());
  }
  contains(p2) {
    return this.points.has(this.createKey(p2));
  }
}
const grid = {
  bottom: (p2, corner, bladeWidth) => {
    const gridPoint = new Point(p2.x, p2.y - bladeWidth);
    gridPoint.corner = corner;
    gridPoint.grid = "bottom";
    return gridPoint;
  },
  left: (p2, corner, bladeWidth) => {
    const gridPoint = new Point(p2.x - bladeWidth, p2.y);
    gridPoint.corner = corner;
    gridPoint.grid = "left";
    return gridPoint;
  },
  right: (p2, corner, bladeWidth) => {
    const gridPoint = new Point(p2.x + bladeWidth, p2.y);
    gridPoint.corner = corner;
    gridPoint.grid = "right";
    return gridPoint;
  },
  top: (p2, corner, bladeWidth) => {
    const gridPoint = new Point(p2.x, p2.y + bladeWidth);
    gridPoint.corner = corner;
    gridPoint.grid = "top";
    return gridPoint;
  }
};
function createGrid(placedShapes, container, cornerCollection, bladeWidth) {
  var _a2, _b, _c, _d, _e, _f;
  const gridCollection = new PointCollection();
  const sortedCorners = cornerCollection.toArray().sort(pointsSort);
  sortedCorners.forEach((cornerPoint) => {
    const corner = cornerPoint.corner;
    const cornerType = cornerPoint.type;
    if (!bladeWidth) {
      gridCollection.addPoint(cornerPoint);
    } else {
      switch (corner) {
        case "topRight":
          gridCollection.addPoint(
            grid.top(cornerPoint, corner, bladeWidth),
            cornerType
          );
          gridCollection.addPoint(
            grid.right(cornerPoint, corner, bladeWidth),
            cornerType
          );
          break;
        case "topLeft":
          gridCollection.addPoint(
            grid.top(cornerPoint, corner, bladeWidth),
            cornerType
          );
          gridCollection.addPoint(
            grid.left(cornerPoint, corner, bladeWidth),
            cornerType
          );
          break;
        case "bottomRight":
          gridCollection.addPoint(
            grid.bottom(cornerPoint, corner, bladeWidth),
            cornerType
          );
          gridCollection.addPoint(
            grid.right(cornerPoint, corner, bladeWidth),
            cornerType
          );
          break;
        case "bottomLeft":
          gridCollection.addPoint(
            grid.bottom(cornerPoint, corner, bladeWidth),
            cornerType
          );
          gridCollection.addPoint(
            grid.left(cornerPoint, corner, bladeWidth),
            cornerType
          );
          break;
      }
    }
    const gridCollectionArray = gridCollection.toArray();
    if (bladeWidth) {
      for (let i = gridCollectionArray.length; i--; ) {
        const gridPoint = gridCollectionArray[i];
        if (cornerCollection.contains(gridPoint)) {
          gridCollection.deletePoint(gridPoint);
        }
      }
    } else {
      for (let i = gridCollectionArray.length; i--; ) {
        const gridPoint = gridCollectionArray[i];
        for (let j = placedShapes.length; j--; ) {
          const placedShape = placedShapes[j];
          if (gridPoint.x === placedShape.x && gridPoint.y === placedShape.y) {
            gridCollection.deletePoint(gridPoint);
            break;
          }
        }
      }
    }
  });
  if (bladeWidth) {
    const pointsToRemove = /* @__PURE__ */ new Set();
    let minX, minY, maxX, maxY;
    if (((_a2 = container == null ? void 0 : container.constructor) == null ? void 0 : _a2.name) === "Stock" && (container == null ? void 0 : container.trimmed) || ((_b = container == null ? void 0 : container.constructor) == null ? void 0 : _b.name) === "Segment") {
      minX = container.x;
      minY = container.y;
      maxX = container.x + container.l;
      maxY = container.y + container.w;
    } else {
      minX = container.x + ((_c = container == null ? void 0 : container.trim) == null ? void 0 : _c.x1);
      minY = container.y + ((_d = container == null ? void 0 : container.trim) == null ? void 0 : _d.y1);
      maxX = container.x + container.l - ((_e = container == null ? void 0 : container.trim) == null ? void 0 : _e.x2);
      maxY = container.y + container.w - ((_f = container == null ? void 0 : container.trim) == null ? void 0 : _f.y2);
    }
    let gridArray = gridCollection.toArray();
    for (let i = gridArray.length; i--; ) {
      const point = gridArray[i];
      if (maths.lessThan(point.x, minX) || maths.lessThan(point.y, minY) || maths.greaterThan(point.x, maxX) || maths.greaterThan(point.y, maxY)) {
        gridArray.splice(i, 1);
      }
    }
    gridCollection.clear();
    gridCollection.addPoints(gridArray);
    pointsToRemove.clear();
    gridArray = gridCollection.toArray();
    for (let i = gridArray.length; i--; ) {
      const point = gridArray[i];
      for (let j = placedShapes.length; j--; ) {
        const placedShape = placedShapes[j];
        if (point.collidesWith(placedShape)) {
          gridCollection.deletePoint(point);
          break;
        }
      }
    }
  }
  return gridCollection;
}
function getCorners(shapes, container) {
  const cornerCollection = new PointCollection();
  shapes.sort(pointsSort);
  shapes.forEach((s) => {
    if (isGroup(s)) {
      cornerCollection.addPoints(s.getCoords(container));
      s.shapes.forEach((gs) => {
        const points = gs.getCoords(container);
        cornerCollection.addPoints(points, "group");
      });
    } else {
      cornerCollection.addPoints(s.getCoords(container));
    }
  });
  cornerCollection.points.forEach((p2) => {
    p2.stockID = container.getStock().id;
  });
  return cornerCollection;
}
function getPlacementPositions(addedShapes = [], placedShapes, container) {
  const bladeWidth = container.getBladeWidth();
  const cornerCollection = getCorners(
    addedShapes === null ? placedShapes : addedShapes,
    container
  );
  const gridCollection = createGrid(
    placedShapes,
    container,
    cornerCollection,
    bladeWidth
  );
  return gridCollection;
}
function pointsSort(a2, b) {
  if (a2.y === b.y) return b.x - a2.x;
  return b.y - a2.y;
}
function adjustPointForMimumSpacing(point, position, shape, container) {
  if (container.saw.cutType !== "efficiency") return point;
  const minSpacing = shape.getMinSpacing(container);
  if (!minSpacing) return point;
  const bladeWidth = container.getBladeWidth();
  let newPoint;
  if (!minSpacing) return point;
  if (!point.grid) return point;
  switch (point.grid) {
    case "bottom":
      newPoint = point.clone(point.x, point.y - minSpacing + bladeWidth);
      break;
    case "top":
      newPoint = point.clone(point.x, point.y + minSpacing - bladeWidth);
      break;
    case "left":
      newPoint = point.clone(point.x - minSpacing + bladeWidth, point.y);
      break;
    case "right":
      newPoint = point.clone(point.x + minSpacing - bladeWidth, point.y);
      break;
  }
  if (newPoint.x < 0) newPoint.x = 0;
  if (newPoint.y < 0) newPoint.y = 0;
  newPoint.adjustedForMinSpacing = true;
  return newPoint;
}
function convertPointToShapePositions(shape, point, container) {
  const collection = new PointCollection();
  const availableShapePositions = point.getAvailableShapePositions(container);
  availableShapePositions.forEach((position) => {
    switch (position) {
      case "bottomLeft":
        {
          let p2 = adjustPointForMimumSpacing(point, position, shape, container);
          p2 = p2.clone(p2.x - shape.l, p2.y - shape.w);
          collection.addPoint(p2);
        }
        break;
      case "bottomRight":
        {
          let p2 = adjustPointForMimumSpacing(point, position, shape, container);
          p2 = p2.clone(p2.x, p2.y - shape.w);
          collection.addPoint(p2);
        }
        break;
      case "topLeft":
        {
          let p2 = adjustPointForMimumSpacing(point, position, shape, container);
          p2 = p2.clone(p2.x - shape.l, p2.y);
          collection.addPoint(p2);
        }
        break;
      case "topRight":
        {
          let p2 = adjustPointForMimumSpacing(point, position, shape, container);
          p2 = p2.clone(p2.x, p2.y);
          collection.addPoint(p2);
        }
        break;
    }
  });
  removeOutOfBoundsPoints(shape, container, collection);
  return collection;
}
function removeOutOfBoundsPoints(shape, container, collection) {
  var _a2, _b, _c, _d, _e, _f;
  let minX, minY, maxX, maxY;
  if (((_a2 = container == null ? void 0 : container.constructor) == null ? void 0 : _a2.name) === "Stock" && (container == null ? void 0 : container.trimmed) || ((_b = container == null ? void 0 : container.constructor) == null ? void 0 : _b.name) === "Segment") {
    minX = 0;
    minY = 0;
    maxX = container.x + container.l - shape.l;
    maxY = container.y + container.w - shape.w;
  } else {
    minX = (_c = container == null ? void 0 : container.trim) == null ? void 0 : _c.x1;
    minY = (_d = container == null ? void 0 : container.trim) == null ? void 0 : _d.y1;
    maxX = container.l - ((_e = container == null ? void 0 : container.trim) == null ? void 0 : _e.x2) - shape.l;
    maxY = container.w - ((_f = container == null ? void 0 : container.trim) == null ? void 0 : _f.y2) - shape.w;
  }
  const pointsArray = collection.toArray();
  for (let i = pointsArray.length; i--; ) {
    const p2 = pointsArray[i];
    if (maths.lessThan(p2.x, minX) || maths.lessThan(p2.y, minY) || maths.greaterThan(p2.x, maxX) || maths.greaterThan(p2.y, maxY) || p2.x < 0 || p2.y < 0)
      collection.deletePoint(p2);
  }
}
function isHexColor(hex2) {
  return typeof hex2 === "string" && hex2.length === 6 && !isNaN(Number("0x" + hex2.replace("#", "")));
}
class Vis {
  constructor({
    elementID,
    env = "production",
    main = true,
    units = "decimal",
    decimalPlaces = 2,
    fractionRoundTo = 0,
    saw = null,
    app: app2 = false,
    embed = false,
    height = 0,
    width = 0,
    flipY = false,
    flipX = false,
    colors = {
      partA: "#1d9bc4",
      partB: "#127da1",
      partHover: "#29c778",
      partSelected: "#1bc319",
      stock: "#ffd166",
      text: "#ffffff"
    },
    options = {
      disableClick: false,
      enableStretch: true
    },
    vueComponent
  }) {
    __publicField(this, "env");
    __publicField(this, "main");
    //is this the main vis or not
    __publicField(this, "units", "decimal");
    __publicField(this, "decimalPlaces");
    __publicField(this, "fractionRoundTo");
    __publicField(this, "formatNumber", (val) => {
      return convertUnit(
        val,
        this.units,
        this.decimalPlaces ?? 2,
        false,
        this.fractionRoundTo ?? 0
      ).toString();
    });
    __publicField(this, "saw");
    __publicField(this, "stockType");
    __publicField(this, "numUniqueShapes");
    __publicField(this, "app");
    __publicField(this, "embed");
    __publicField(this, "height");
    __publicField(this, "width");
    __publicField(this, "device");
    __publicField(this, "vueComponent");
    __publicField(this, "elWidth");
    __publicField(this, "elHeight");
    __publicField(this, "w");
    __publicField(this, "h");
    __publicField(this, "padding");
    __publicField(this, "mobileBreakpoint");
    //scales
    __publicField(this, "xScale", d3.scaleLinear());
    __publicField(this, "yScale", d3.scaleLinear());
    __publicField(this, "yPositionScale", d3.scaleLinear());
    __publicField(this, "xPositionScale", d3.scaleLinear());
    __publicField(this, "yAxisScale", d3.scaleLinear());
    __publicField(this, "measurementScale", d3.scaleLinear());
    __publicField(this, "xAxis");
    __publicField(this, "yAxis");
    __publicField(this, "stretched");
    __publicField(this, "shapeXAxis");
    __publicField(this, "shapeYAxis");
    __publicField(this, "cutMeasurementXAxes");
    __publicField(this, "cutMeasurementYAxes");
    __publicField(this, "axisSpacing");
    __publicField(this, "flipY");
    __publicField(this, "flipX");
    __publicField(this, "colors");
    __publicField(this, "options");
    __publicField(this, "moveMode");
    __publicField(this, "moveRotation");
    __publicField(this, "moving");
    __publicField(this, "shape");
    __publicField(this, "shapeColorScale");
    __publicField(this, "scoreColorScale");
    __publicField(this, "hasTouch");
    __publicField(this, "highlightguillotine");
    __publicField(this, "debug", "");
    //groups | guillotine | positions
    __publicField(this, "elementID");
    //the id of the element to draw the vis in
    __publicField(this, "el");
    __publicField(this, "htmlEl");
    __publicField(this, "svgCanvas");
    __publicField(this, "axisGroup");
    __publicField(this, "stockGroup");
    __publicField(this, "stockWrappers");
    __publicField(this, "stock");
    __publicField(this, "shapeGroup");
    __publicField(this, "shapeWrappers");
    __publicField(this, "shapes");
    __publicField(this, "shapeIDText");
    __publicField(this, "shapeNameText");
    __publicField(this, "shapeLengthText");
    __publicField(this, "shapeWidthText");
    __publicField(this, "groupGroup");
    __publicField(this, "groups");
    __publicField(this, "bandingGroup");
    __publicField(this, "bandingWrappers");
    __publicField(this, "banding");
    __publicField(this, "segmentGroup");
    __publicField(this, "segments");
    __publicField(this, "segment");
    __publicField(this, "positionGroup");
    __publicField(this, "position");
    __publicField(this, "dotGroup");
    __publicField(this, "placementPositionGroup");
    __publicField(this, "dot");
    __publicField(this, "cutGroup");
    __publicField(this, "cuts");
    __publicField(this, "cut");
    var _a2;
    if (!elementID) throw new Error("elementID is required");
    this.el = d3.select(elementID);
    if (this.el === null) return;
    const htmlElement = this.el.node();
    if (htmlElement === null) return;
    this.htmlEl = htmlElement;
    this.vueComponent = vueComponent;
    this.env = ((_a2 = vueComponent == null ? void 0 : vueComponent.gs) == null ? void 0 : _a2.env) === "development" ? "development" : "production";
    this.debug = this.env === "development" ? "guillotine" : "";
    this.app = app2 ? app2 : false;
    this.embed = embed ? embed : false;
    this.height = height;
    this.width = width;
    this.device = app2 ? "app" : "desktop";
    this.stretched = false;
    this.elWidth = this.htmlEl.offsetWidth;
    this.elHeight = this.htmlEl.offsetHeight;
    this.w = 0;
    this.h = 0;
    this.padding = 0;
    this.mobileBreakpoint = 450;
    this.main = main;
    this.saw = saw;
    this.cutMeasurementXAxes = [];
    this.cutMeasurementYAxes = [];
    this.axisSpacing = 16;
    this.flipY = flipY;
    this.flipX = flipX;
    colors = {
      ...colors
    };
    for (const [key, value2] of Object.entries(colors)) {
      if (value2) colors[key] = value2.replace("#", "");
    }
    this.colors = {
      partA: isHexColor(colors == null ? void 0 : colors.partA) ? rgb$1("#" + colors.partA) : rgb$1("#1d9bc4"),
      partB: isHexColor(colors == null ? void 0 : colors.partB) ? rgb$1("#" + colors.partB) : rgb$1("#127da1"),
      partHover: isHexColor(colors == null ? void 0 : colors.partHover) ? rgb$1("#" + colors.partHover) : rgb$1("#29c778"),
      partSelected: isHexColor(colors == null ? void 0 : colors.partSelected) ? rgb$1("#" + colors.partSelected) : rgb$1("#1bc319"),
      stock: isHexColor(colors == null ? void 0 : colors.stock) ? rgb$1("#" + colors.stock) : rgb$1("#ffd166"),
      text: isHexColor(colors == null ? void 0 : colors.text) ? rgb$1("#" + colors.text) : rgb$1("#ffffff")
    };
    this.shapeColorScale = d3.scaleSequential([
      this.colors.partA,
      this.colors.partB
    ]);
    this.env = env;
    this.moveMode = false;
    this.moving = false;
    this.moveRotation = false;
    this.units = units;
    this.decimalPlaces = decimalPlaces;
    this.fractionRoundTo = fractionRoundTo;
    this.hasTouch = false;
    this.options = options;
    this.init();
  }
  /**
      * sets up the various wrappers - only needs to be called once
      * the z index is set by the order drawn
      */
  init() {
    if (!this.el) return false;
    if (this.decimalPlaces === null || this.decimalPlaces === void 0 || isNaN(this.decimalPlaces))
      this.decimalPlaces = 2;
    if (this.fractionRoundTo === null || this.fractionRoundTo === void 0 || isNaN(this.fractionRoundTo))
      this.fractionRoundTo = 0;
    if (!this.svgCanvas) {
      const svgElement = this.htmlEl.querySelector("svg");
      if (svgElement === null) {
        const svg = this.el.append("svg").attr("class", "vis");
        if (svg === null) return;
        svg.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").attr("id", "stripes").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1");
        svg.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(90)").attr("id", "grain-l").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1");
        svg.append("defs").append("pattern").attr("patternUnits", "userSpaceOnUse").attr("id", "grain-w").attr("width", 6).attr("height", 6).append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 6).attr("stroke", "#a1a1a1").attr("stroke-width", "1");
        this.svgCanvas = svg;
      }
      this.axisGroup = this.svgCanvas.append("g").attr("class", "axis-group");
      this.stockGroup = this.svgCanvas.append("g").attr("class", "stock-group");
      this.shapeGroup = this.svgCanvas.append("g").attr("class", "shapes");
      this.bandingGroup = this.svgCanvas.append("g").attr("class", "banding-group");
      this.segmentGroup = this.svgCanvas.append("g").attr("class", "segments").attr("display", "none");
      this.groupGroup = this.svgCanvas.append("g").attr("class", "groups").attr("display", "none");
      this.positionGroup = this.svgCanvas.append("g").attr("class", "positions");
      this.dotGroup = this.svgCanvas.append("g").attr("class", "dots");
      if (this.env === "development") {
        this.placementPositionGroup = this.svgCanvas.append("g").attr("class", "placements");
      }
      this.cutGroup = this.svgCanvas.append("g").attr("class", "cuts");
    }
    if (this.elWidth > 0) this.updateSize(true);
    this.hasTouch = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
  updateUnits(newUnits, decimalPlaces, fractionRoundTo) {
    if (newUnits) this.units = newUnits;
    if (decimalPlaces) this.decimalPlaces = decimalPlaces;
    if (fractionRoundTo) this.fractionRoundTo = fractionRoundTo;
    this.refreshShapes();
    this.refreshStock();
  }
  trimNameToFit(shapes, vis) {
    function trim(shape, index, items) {
      const item = items[index];
      const self2 = d3.select(item);
      self2.text(shape.name);
      let text = self2.text();
      const node = self2.node();
      if (!node) return;
      let textLength = node.getComputedTextLength();
      const space = this.getWidthAttribute(shape) - 20;
      while (textLength > space && text.length > 0) {
        text = text.slice(0, -1);
        self2.text(text.length ? text + "..." : "");
        textLength = self2.node().getComputedTextLength();
      }
    }
    shapes.each(trim.bind(vis));
  }
  getShapeColor(shape) {
    if (this.env === "development") {
      switch (this.debug) {
        case "guillotine":
          if (shape.guillotineData.firstShape) {
            return rgb$1(252, 3, 182);
          }
          if (shape.addedAsGroup) {
            return rgb$1(53, 186, 20);
          }
          if (typeof shape.guillotineData.myPhase === "number") {
            const startColor = [0, 115, 255];
            const endColor = [176, 255, 231];
            const color2 = startColor.map((start, i) => {
              return Math.round(start + shape.guillotineData.myPhase / 5 * (endColor[i] - start));
            });
            return `rgb(${color2.join(",")})`;
          }
          break;
        case "groups":
          if (shape.addedAsGroup !== false) {
            return rgb$1(53, 186, 20);
          }
          break;
        case "priorityShapes":
          if (shape.priority.includes(shape.stock.parentID)) {
            return rgb$1(139, 171, 46);
          }
          break;
        case "score":
          return this.scoreColorScale(shape.bestScore.total);
      }
    }
    return this.shapeColorScale(shape.parentID - 1);
  }
  setDevice() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    if (!this.htmlEl.offsetWidth) return;
    this.elWidth = this.htmlEl.offsetWidth;
    this.elHeight = this.htmlEl.offsetHeight;
    if (this.elWidth === 0) return false;
    if (!this.main) {
      this.padding = 0;
    } else {
      if (this.elWidth <= this.mobileBreakpoint || this.app) {
        this.device = "mobile";
        this.padding = 0;
      } else {
        this.device = "desktop";
        this.padding = 50;
      }
    }
    this.w = this.elWidth;
  }
  //find the largest dimensions of all the stock (not just the active one)
  findLargestStockDimensions() {
    const stockList = getData.call(this.vueComponent, ["stockList"]).filter((s) => s.used);
    if (!(stockList == null ? void 0 : stockList.length)) return [null, null];
    const longestStock = stockList.reduce((prev, current) => prev.l > current.l ? prev : current);
    const widestStock = stockList.reduce((prev, current) => prev.w > current.w ? prev : current);
    return [longestStock, widestStock];
  }
  debounce(func, wait, immediate = false) {
    let timeout;
    return (...args) => {
      return new Promise((resolve2) => {
        const later = () => {
          timeout = null;
          if (!immediate) {
            resolve2(func.apply(this, args));
          }
        };
        clearTimeout(timeout);
        if (immediate) {
          const callNow = !timeout;
          if (callNow) resolve2(func.apply(this, args));
        }
        timeout = setTimeout(later, wait);
      });
    };
  }
  updateSize(immediate = false) {
    return this.debounce(this._updateSize.bind(this), 10, immediate)();
  }
  requiresStretch(activeStock, aspectRatio = null) {
    if (!activeStock) return false;
    if (aspectRatio === null) aspectRatio = activeStock.w / activeStock.l;
    if (aspectRatio < 0.15) return true;
    return false;
  }
  setAspectRatio(activeStock) {
    if (activeStock) {
      this.w = this.elWidth;
      const aspectRatio = activeStock.w / activeStock.l;
      this.xScale.domain([0, activeStock.l]).range([this.padding, this.w - this.padding]);
      if (this.requiresStretch(activeStock, aspectRatio) && this.options.enableStretch) {
        this.h = this.htmlEl.clientWidth * 0.15 + this.padding * 2;
        this.stretched = true;
      } else {
        this.h = this.xScale(activeStock.getShortSide()) + this.padding;
        this.stretched = false;
      }
      this.yScale.domain([0, activeStock.w]).range([this.padding, this.h - this.padding]);
      this.yAxisScale.domain(this.flipY ? [0, activeStock.w] : [activeStock.w, 0]).range([this.padding, this.h - this.padding]);
      this.yPositionScale.domain([0, activeStock.w]).range(this.flipY ? [this.padding, this.h - this.padding] : [this.h - this.padding, this.padding]);
      if (aspectRatio > 2) {
        this.w = this.htmlEl.clientWidth / aspectRatio + this.padding * 2;
        this.xScale.domain([0, activeStock.l]).range([this.padding, this.w - this.padding]);
        this.h = this.xScale(activeStock.getShortSide()) + this.padding;
      }
      this.xPositionScale.domain([0, activeStock.l]).range(this.flipX ? [this.w - this.padding, this.padding] : [this.padding, this.w - this.padding]);
      this.measurementScale.domain([0, activeStock.l]).range([0, this.w - this.padding * 2]);
      if (this.w > 0 && this.h > 0) {
        if (aspectRatio > 2) this.el.style("width", this.w + "px");
        else this.el.style("width", "");
        this.el.style("height", this.h + "px");
      }
    }
  }
  _updateSize() {
    if (!this.htmlEl || this.htmlEl.style.display === "none") return;
    if (this.vueComponent && "suppressResizeObserver" in this.vueComponent) {
      this.vueComponent.suppressResizeObserver = true;
    }
    const stockList = getData.call(this.vueComponent, ["stockList"]);
    const shapeList = getData.call(this.vueComponent, ["shapeList"]);
    if (!(stockList == null ? void 0 : stockList.length) || !(shapeList == null ? void 0 : shapeList.length)) return false;
    this.setDevice();
    this.refreshStock();
    this.refreshShapes();
    if (this.env === "development") {
      this.refreshPlacementPositions();
    }
  }
  refreshCuts() {
    const activeCuts = getData.call(this.vueComponent, ["activeCuts"]);
    this.resetSegments();
    this.initCuts(activeCuts);
  }
  refreshStock() {
    const stockList = getData.call(this.vueComponent, ["stockList"]);
    if (!(stockList == null ? void 0 : stockList.length)) return false;
    const activeStock = getData.call(this.vueComponent, ["activeStock"]);
    this.initStock(activeStock);
    this.refreshCuts();
    const activeSegments = getData.call(this.vueComponent, ["activeSegments"]);
    this.initSegments(activeSegments);
    this.resetPositions();
    if (typeof this.vueComponent.toggleSegments === "function")
      this.vueComponent.toggleSegments(false);
  }
  refreshShapes() {
    const shapeList = getData.call(this.vueComponent, ["shapeList"]);
    if (!(shapeList == null ? void 0 : shapeList.length)) return false;
    this.resetPositions();
    const activeShapes = getData.call(this.vueComponent, ["activeShapes"]);
    this.initShapes(activeShapes, shapeList);
  }
  refreshPlacementPositions() {
    const placementPositions = getData.call(this.vueComponent, ["placementPositions"]);
    if (!(placementPositions == null ? void 0 : placementPositions.length)) return false;
    this.resetPlacementPositions();
    const activePositions = placementPositions.filter((p2) => p2.stockID === getData.call(this.vueComponent, ["activeStock"]).id);
    this.initPlacementPositions(activePositions);
  }
  recreateUerGroups(activeShapes) {
    activeShapes.filter((s) => s.inUserGroup);
    const groupedShapes = [];
    for (let i = 0; i < activeShapes.length; i++) {
      const shape = activeShapes[i];
      const groupId = shape.addedAsGroup;
      const groupShapes = activeShapes.filter((s) => s.addedAsGroup === groupId);
      groupedShapes.push(groupShapes);
      i += groupShapes.length;
    }
    const groups = [];
    groupedShapes.forEach((gs) => {
      const x = Math.min(...gs.map((s) => s.x));
      const y2 = Math.min(...gs.map((s) => s.y));
      const l = Math.max(...gs.map((s) => s.x + s.l)) - x;
      const w = Math.max(...gs.map((s) => s.y + s.w)) - y2;
      const group = {
        x,
        y: y2,
        l,
        w,
        shapes: gs
      };
      groups.push(group);
    });
    this.initGroups(groups);
  }
  //init or update the stock
  initStock(activeStock) {
    this.resetStock();
    this.setAspectRatio(activeStock);
    if (!activeStock || !(activeStock == null ? void 0 : activeStock.w) || !(activeStock == null ? void 0 : activeStock.l) || !this.elWidth)
      return false;
    this.stockType = activeStock.type;
    let stock;
    if (typeof activeStock === "object") stock = [activeStock];
    if (this.device === "desktop") {
      if (this.main) {
        this.xAxis = this.axisGroup.append("g").attr("transform", `translate(0, ${this.padding})`).attr("class", "axis stock x").call(d3.axisTop(this.xScale).ticks(5).tickSize(5)).selectAll("text").attr("dy", -5);
        const requiresStretch = this.requiresStretch(activeStock);
        if (!requiresStretch || requiresStretch && this.stretched) {
          this.yAxis = this.axisGroup.append("g").attr(
            "transform",
            `translate(${this.w - this.padding}, 0)`
          ).attr("class", "axis stock y").call(d3.axisRight(this.yAxisScale).ticks(5).tickSize(5)).selectAll("text").attr("dx", 5);
        }
      }
    }
    this.stockGroup.data(stock).attr(
      "transform",
      () => `translate(${this.padding},${this.padding})`
    );
    this.stockGroup.append("rect").attr("class", "background stock").style("fill", this.colors.stock).attr("width", (s) => this.getWidthAttribute(s)).attr("height", (s) => this.getHeightAttribute(s)).attr("x", (s) => {
      s.x = 0;
      const original = s.x;
      s.x = 0;
      const pos = this.getRectangleCoordinate(s, "x") - this.padding;
      s.x = original;
      return pos;
    }).attr("y", (s) => {
      s.y = 0;
      const original = s.y;
      s.y = 0;
      const pos = this.getRectangleCoordinate(s, "y") - this.padding;
      s.y = original;
      return pos;
    });
    this.stock = this.stockGroup.append("rect").attr("width", (s) => this.getWidthAttribute(s)).attr("height", (s) => this.getHeightAttribute(s)).attr(
      "x",
      (s) => this.getRectangleCoordinate(s, "x") - this.padding
    ).attr(
      "y",
      (s) => this.getRectangleCoordinate(s, "y") - this.padding
    ).attr("class", "stock-pattern").style("fill", (s) => (s == null ? void 0 : s.grain) ? `url(#grain-${s.grain.toLowerCase()})` : "url(#stripes)");
  }
  getWidthAttribute(item) {
    return this.xScale(item.l) - this.padding;
  }
  getHeightAttribute(item) {
    return this.yScale(item.w) - this.padding;
  }
  //init or update the shapes
  initShapes(shapeList, allShapes) {
    var _a2, _b, _c;
    this.resetShapes();
    if (!shapeList || !shapeList.length || !this.elWidth) return;
    this.numUniqueShapes = allShapes.filter((shape) => !shape.duplicate).length;
    this.shapeColorScale.domain([0, this.numUniqueShapes]);
    if ((_a2 = this == null ? void 0 : this.vueComponent) == null ? void 0 : _a2.gs) {
      this.vueComponent.gs.shapeColors = {};
      for (let i = shapeList.length; i--; ) {
        const s = shapeList[i];
        if (s.parentID && this.vueComponent.gs.shapeColors[s.parentID])
          continue;
        if (s.parentID) {
          this.vueComponent.gs.shapeColors[s.parentID] = color(this.shapeColorScale(parseInt(s.parentID) - 1)).formatHex();
        }
      }
    }
    if (this.env === "development") {
      let initialMin = Infinity;
      let initialMax = -Infinity;
      for (const shape of shapeList) {
        const score = (_b = shape == null ? void 0 : shape.bestScore) == null ? void 0 : _b.total;
        if (score !== 0 && score !== null && score !== void 0) {
          initialMin = score;
          initialMax = score;
          break;
        }
      }
      const minBestScore = shapeList.reduce((min2, shape) => {
        var _a3;
        const score = (_a3 = shape == null ? void 0 : shape.bestScore) == null ? void 0 : _a3.total;
        if (score === 0 || score === null || score === void 0)
          return min2;
        return score < min2 ? score : min2;
      }, initialMin);
      const maxBestScore = shapeList.reduce((max2, shape) => {
        var _a3;
        const score = (_a3 = shape == null ? void 0 : shape.bestScore) == null ? void 0 : _a3.total;
        if (score === null || score === void 0) return max2;
        return score > max2 ? score : max2;
      }, initialMax);
      this.scoreColorScale = d3.scaleSequential([rgb$1(251, 224, 255), rgb$1(122, 0, 138)]).domain([minBestScore, maxBestScore]);
    }
    if (!shapeList || !shapeList.length) return false;
    this.shapeWrappers = this.shapeGroup.selectAll("g").data(shapeList).join("g").attr("class", "shape-group");
    if (!this.shapeWrappers.size()) return false;
    this.shapes = this.shapeWrappers.append("rect").attr("class", "shape").attr("fill", (s) => this.getShapeColor(s)).attr("stroke-width", () => this.env === "development" ? 3 : 0).attr("width", (s) => this.getWidthAttribute(s)).attr("height", (s) => this.getHeightAttribute(s));
    if (this.main) {
      const bandingData = [];
      shapeList.forEach((shape) => {
        if (shape == null ? void 0 : shape._banding) {
          for (const [key, value2] of Object.entries(shape._banding)) {
            if (!value2) continue;
            if (["a", "b", "c", "d"].includes(key)) continue;
            let side = key;
            if (shape.rot) {
              switch (key) {
                case "x1":
                  side = "y1";
                  break;
                case "x2":
                  side = "y2";
                  break;
                case "y1":
                  side = "x2";
                  break;
                case "y2":
                  side = "x1";
                  break;
              }
            }
            switch (side) {
              case "x1":
                bandingData.push({
                  x1: shape.x,
                  x2: shape.x,
                  y1: shape.y,
                  y2: shape.y + shape.w,
                  type: "x1"
                });
                break;
              case "x2":
                bandingData.push({
                  x1: shape.x + shape.l,
                  x2: shape.x + shape.l,
                  y1: shape.y,
                  y2: shape.y + shape.w,
                  type: "x2"
                });
                break;
              case "y1":
                bandingData.push({
                  x1: shape.x,
                  x2: shape.x + shape.l,
                  y1: shape.y,
                  y2: shape.y,
                  type: "y1"
                });
                break;
              case "y2":
                bandingData.push({
                  x1: shape.x,
                  x2: shape.x + shape.l,
                  y1: shape.y + shape.w,
                  y2: shape.y + shape.w,
                  type: "y2"
                });
                break;
            }
          }
        }
      });
      this.bandingWrappers = this.bandingGroup.selectAll("g").data(bandingData).join("line").attr("class", "banding").attr(
        "x1",
        (d) => this.xPositionScale(d.x1) + this.getBandingAdjustment(d.type, "x")
      ).attr(
        "x2",
        (d) => this.xPositionScale(d.x2) + this.getBandingAdjustment(d.type, "x")
      ).attr(
        "y1",
        (d) => this.yPositionScale(d.y1) + this.getBandingAdjustment(d.type, "y")
      ).attr(
        "y2",
        (d) => this.yPositionScale(d.y2) + this.getBandingAdjustment(d.type, "y")
      ).attr("stroke-width", 2).attr("stroke", "white");
      this.shapeIDText = this.shapeWrappers.append("text").attr("class", "shape-text id").text((shape) => {
        var _a3, _b2;
        if (this.env === "development") {
          switch (this.debug) {
            case "guillotine": {
              const stripDirection = shape.guillotineData.myStripDirection;
              const group = shape.addedAsGroup;
              let shapeText = "";
              if (stripDirection === "l") {
                shapeText = ` ${shape.parentID}`;
              } else if (stripDirection === "w") {
                shapeText = ` ${shape.parentID}`;
              }
              if ((_b2 = shape == null ? void 0 : shape.priotity) == null ? void 0 : _b2[(_a3 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a3.parentID]) {
                shapeText += "P";
              }
              if (group) shapeText += "G";
              if (shapeText.length) return shapeText;
              return this.shapeNameText;
            }
            case "groups": {
              const group = shape.addedAsGroup;
              if (group) return "G" + shape.getParentID();
            }
          }
        }
        return shape.parentID ? shape.parentID : shape.getParentID();
      }).classed("hidden", (shape, b, c2) => {
        const bbox = c2[b].getBBox();
        if (bbox.width >= this.measurementScale(shape.l))
          return true;
        if (bbox.height >= this.yScale(shape.w) - this.padding)
          return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      this.shapeNameText = this.shapeWrappers.append("text").attr("class", "shape-text name").text((shape) => {
        if (!(shape == null ? void 0 : shape.name)) return null;
        if (typeof (shape == null ? void 0 : shape.name) !== "string") return null;
        const result = shape.name.toUpperCase().trim();
        return result;
      }).call(this.trimNameToFit, this).classed("hidden", (shape, b, c2) => {
        const bbox = c2[b].getBBox();
        if (bbox.width >= this.measurementScale(shape.l))
          return true;
        if (this.measurementScale(shape.w) < 40) return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      this.shapeLengthText = this.shapeWrappers.append("text").attr("class", "shape-text length").text((shape) => {
        if (this.debug === "guillotine") return "";
        return convertUnit(
          shape.l,
          this.units,
          this.decimalPlaces,
          false,
          this.fractionRoundTo
        );
      }).classed("hidden", (shape, b, c2) => {
        var _a3;
        if (this.app)
          return this.measurementScale(shape.l) < 50 || this.measurementScale(shape.w) < 50;
        if (((_a3 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a3.type) === "linear") return false;
        const bbox = c2[b].getBBox();
        if (bbox.width >= this.measurementScale(shape.l))
          return true;
        if (this.measurementScale(shape.w) < 30) return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
      this.shapeWidthText = this.shapeWrappers.append("text").attr("class", "shape-text width").text((shape) => {
        if (this.debug === "guillotine") return "";
        return convertUnit(
          shape.w,
          this.units,
          this.decimalPlaces,
          false,
          this.fractionRoundTo
        );
      }).classed("hidden", (shape, b, c2) => {
        if (this.app) {
          return this.measurementScale(shape.l) < 50 || this.measurementScale(shape.w) < 50;
        }
        const bbox = c2[b].getBBox();
        if (this.measurementScale(shape.l) < 30) return true;
        if (bbox.height >= this.measurementScale(shape.w))
          return true;
        return false;
      }).attr("dominant-baseline", "middle").attr("fill", this.colors.text);
    }
    if ((this.main || this.app) && !((_c = this == null ? void 0 : this.options) == null ? void 0 : _c.disableClick)) {
      this.shapes.on("mousedown", (event, shape) => {
        var _a3, _b2, _c2, _d, _e, _f;
        if (this.moving) return false;
        if (this.env === "development") {
          console.clear();
          if (shape) {
            let logProperties = ["id", "placementOrder", "priority", "addedAsGroup"];
            if (this.debug === "guillotine") {
              logProperties = [
                "id",
                "placementOrder",
                "priority",
                "guillotineData.myPhase",
                "guillotineData.myStripDirection",
                "guillotineData.myStripParent",
                "guillotineData.firstShape",
                "addedAsGroup"
              ];
            } else if (this.debug === "groups") {
              logProperties = [
                "id",
                "addedAsGroup"
              ];
            }
            console.table(logProperties.reduce((obj, prop) => {
              const value2 = getNestedProperty(shape, prop);
              obj[prop] = Array.isArray(value2) ? value2.join(", ") : value2;
              return obj;
            }, {}));
          }
          if (this.debug === "guillotine") {
            this.shapeWrappers.selectAll(".highlight-a").classed("highlight-a", false);
            this.shapeWrappers.selectAll(".highlight-b").classed("highlight-b", false);
            this.shapeWrappers.selectAll(".highlight-c").classed("highlight-c", false);
            const stripParentId = (_a3 = shape.guillotineData) == null ? void 0 : _a3.myStripParent;
            const stripParentParentId = (_c2 = (_b2 = shapeList.find((s) => s.id === stripParentId)) == null ? void 0 : _b2.guillotineData) == null ? void 0 : _c2.myStripParent;
            if (stripParentId) {
              const el = this.shapeWrappers.filter((d) => d.id === stripParentId || d.addedAsGroup === stripParentId);
              const rect = el.select("rect");
              rect.classed("highlight-a", true);
            }
            if (stripParentParentId) {
              const el = this.shapeWrappers.filter((d) => d.id === stripParentParentId || d.addedAsGroup === stripParentId);
              const rect = el.select("rect");
              rect.classed("highlight-b", true);
            }
          }
        }
        if (this.app || this.embed) {
          const eventData = {
            name: shape.name,
            id: shape.id,
            x: shape.x,
            y: shape.y,
            l: shape.l,
            w: shape.w,
            banding: (shape == null ? void 0 : shape.banding) && typeof shape.banding === "object" ? shape.banding : null,
            rot: shape.rot,
            stock: (_d = shape == null ? void 0 : shape.stock) == null ? void 0 : _d.id,
            color: (_e = this.getShapeColor(shape)) == null ? void 0 : _e.toString(),
            notes: shape == null ? void 0 : shape.notes
          };
          const partClickEvent = new CustomEvent("partClick", {
            detail: eventData
          });
          if (this.env === "development") {
            console.log(eventData);
          }
          this.htmlEl.dispatchEvent(partClickEvent);
          if (this.app) return false;
        }
        if (!this.moveMode && ((_f = this.vueComponent) == null ? void 0 : _f.gs)) {
          this.vueComponent.gs.examineShape = shape;
        }
        if (this.device === "desktop") {
          this.resetCutMeasurementAxes();
          this.addShapeAxes(shape);
        }
        this.shapes.classed("selected", false);
        this.shapes.style("fill", (s) => this.getShapeColor(s));
        if (this.moveMode) {
          if (shape.stock.cutType === "efficiency" || shape.stock.type === "linear") {
            const partsBin = getRef.call(this.vueComponent, "partsBin");
            if (partsBin) partsBin.addToPartBin(shape);
          }
        } else {
          d3.select(event.target).classed("selected", true);
          d3.select(event.target).style(
            "fill",
            this.colors.partSelected.toString()
          );
        }
      });
      if (!this.app && !this.hasTouch) {
        this.shapes.on(
          "mouseover",
          (event) => {
            if ((this == null ? void 0 : this.moveMode) && this.moving) return;
            d3.select(event.target).classed("hover", true);
            if (!d3.select(event.target).classed("selected")) {
              d3.select(event.target).style(
                "fill",
                this.colors.partHover.toString()
              );
            }
          },
          {
            passive: true
          }
        ).on(
          "mouseout",
          (event, s) => {
            var _a3;
            d3.select(event.target).classed("hover", false);
            if (!d3.select(event.target).classed("selected")) {
              d3.select(event.target).style(
                "fill",
                (_a3 = this.getShapeColor(s)) == null ? void 0 : _a3.toString()
              );
            }
          },
          {
            passive: true
          }
        );
      }
    }
    this.setShapePosition();
  }
  /**
      * update SHAPE visibility - used for replay
      * @param {Number} number
      */
  updateShapeVisibility(number2) {
    var _a2;
    (_a2 = this == null ? void 0 : this.shapeWrappers) == null ? void 0 : _a2.style("visibility", (shape) => {
      if ((shape == null ? void 0 : shape.placementOrder) >= number2) return "hidden";
      else return "visible";
    });
  }
  isCutComplete(c2, parentSegmentID, segmentCutOrder) {
    return c2.guillotineData.parentSegmentID === parentSegmentID && segmentCutOrder && c2.guillotineData.segmentCutOrder < segmentCutOrder;
  }
  isCutInsideSegment(c2, parentSegmentID) {
    var _a2;
    return ((_a2 = c2.guillotineData) == null ? void 0 : _a2.parentSegmentID) !== null && !(c2 == null ? void 0 : c2.isTrim) ? c2.guillotineData.parentSegmentID === parentSegmentID : false;
  }
  //update CUT visibility
  updateCutVisibility(cut, index = null, sorting = "") {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    if (index === null) return;
    if (cut === void 0 || cut === null) return;
    if (this == null ? void 0 : this.cuts.empty()) return;
    this.resetShapeAxes();
    this.resetCutMeasurementAxes();
    d3.select(this.cuts.nodes()[index].parentNode).raise();
    const parentSegmentID = (_a2 = cut.guillotineData) == null ? void 0 : _a2.parentSegmentID;
    const halfBladeWidth = this.getHalfBladeWidth(cut.stock);
    const axis2 = cut.direction === "l" ? "y" : "x";
    const trim = (_b = cut == null ? void 0 : cut.stock) == null ? void 0 : _b.trim;
    const orderKey = sorting === "ptx" ? "ptxOrder" : "order";
    if ((((_c = cut == null ? void 0 : cut.stock) == null ? void 0 : _c.cutType) === "guillotine" || ((_d = cut == null ? void 0 : cut.stock) == null ? void 0 : _d.cutType) === "beam") && parentSegmentID !== null && typeof parentSegmentID !== "undefined") {
      this.cuts.style("visibility", (c2) => {
        if (typeof cut.guillotineData[orderKey] === "number" && c2.guillotineData[orderKey] <= cut.guillotineData[orderKey]) {
          return "visible";
        }
        if (!sorting && c2.guillotineData.parentSegmentID === parentSegmentID) {
          return "visible";
        }
        return "hidden";
      });
      this.cuts.classed("highlight", (c2) => {
        if (cut.stock.cutType === "guillotine" && c2.isTrim)
          return c2.type === cut.type;
        return c2.guillotineData[orderKey] === cut.guillotineData[orderKey];
      });
      this.cuts.classed("ptx-dummy", (c2) => {
        return c2.guillotineData.ptxDummyCut;
      });
      if (!sorting) {
        const segmentCutOrder = (_e = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _e.segmentCutOrder;
        if (segmentCutOrder === void 0 || segmentCutOrder === null)
          return;
        this.cuts.classed("completed", (c2) => this.isCutComplete(c2, parentSegmentID, segmentCutOrder));
        this.cuts.classed("inside-segment", (c2) => this.isCutInsideSegment(c2, parentSegmentID));
        let measurements, values;
        const segments = this.getCutSegments(cut);
        if (segments === false) return;
        const relevantSegment = (_g = segments == null ? void 0 : segments.siblings) == null ? void 0 : _g[((_f = segments.main) == null ? void 0 : _f.hasBeamTrim) ? segmentCutOrder - 1 : segmentCutOrder];
        if (relevantSegment) {
          if ((cut == null ? void 0 : cut.direction) === "l") {
            measurements = [
              [
                relevantSegment.y,
                relevantSegment.y + relevantSegment.w
              ],
              [
                cut.y1 + halfBladeWidth,
                (segments == null ? void 0 : segments.main.y) + (segments == null ? void 0 : segments.main.w)
              ]
            ];
          } else if ((cut == null ? void 0 : cut.direction) === "w") {
            measurements = [
              [
                relevantSegment.x,
                relevantSegment.x + relevantSegment.l
              ],
              [
                cut.x1 + halfBladeWidth,
                (segments == null ? void 0 : segments.main.x) + (segments == null ? void 0 : segments.main.l)
              ]
            ];
          }
          if ((cut == null ? void 0 : cut.direction) === "l") {
            values = [(_h = cut == null ? void 0 : cut.distances) == null ? void 0 : _h.bottom, cut == null ? void 0 : cut.distances.top];
          } else if ((cut == null ? void 0 : cut.direction) === "w") {
            values = [cut == null ? void 0 : cut.distances.left, (_i = cut == null ? void 0 : cut.distances) == null ? void 0 : _i.right];
          }
          if (this.device === "desktop" && !cut.isTrim)
            this.addCutMeasurementAxes(measurements, values, axis2);
        }
      }
    } else {
      this.cuts.style("visibility", (c2, thisIndex) => thisIndex <= index ? "visible" : "hidden");
      let measurements;
      if ((cut == null ? void 0 : cut.direction) === "l") {
        measurements = [
          [0 + (trim.y1 ?? 0), cut.y1 - halfBladeWidth],
          [
            cut.y1 + halfBladeWidth,
            cut.stock.w - ((trim == null ? void 0 : trim.y2) ? trim.y2 : 0)
          ]
        ];
      } else if ((cut == null ? void 0 : cut.direction) === "w") {
        measurements = [
          [0 + (trim.x1 ?? 0), cut.x1 - halfBladeWidth],
          [
            cut.x1 + halfBladeWidth,
            cut.stock.l - ((trim == null ? void 0 : trim.x2) ? trim.x2 : 0)
          ]
        ];
      }
      if (measurements == null ? void 0 : measurements.length) {
        const values = [
          measurements[0][1] - measurements[0][0],
          measurements[1][1] - measurements[1][0]
        ];
        if (this.device === "desktop" && !cut.isTrim)
          this.addCutMeasurementAxes(measurements, values, axis2);
      }
      this.cuts.classed(
        "highlight",
        (cut2, cutIndex) => cutIndex === index
      );
    }
    this.cuts.attr("stroke-width", (c2, cutIndex) => {
      var _a3;
      let width = Math.ceil(this.measurementScale(this.getBladeWidth(c2.stock)));
      const segmentCutOrder = (_a3 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _a3.segmentCutOrder;
      if (this.isCutComplete(c2, parentSegmentID, segmentCutOrder)) {
        width += 1;
      } else if (this.isCutInsideSegment(c2, parentSegmentID)) {
        width += 1;
      }
      if (cutIndex === index && Math.ceil(this.measurementScale(this.getBladeWidth(c2.stock))) < 5) {
        width = 5;
      }
      return width;
    });
  }
  //highlight a specific cut (by order or index), segments and related measurements
  showCut(cut, index = null, sorting = "") {
    var _a2;
    if (index === null) return false;
    this.updateCutVisibility(cut, index, sorting);
    if (sorting === "ptx") {
      this.resetSegments();
      return;
    }
    const cutSegments = this.getCutSegments(cut);
    if (cutSegments === false) return;
    const { main, siblings } = cutSegments;
    if (!((_a2 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _a2.parentSegmentID)) {
      return this.initSegments([main]);
    }
    const numSiblings = siblings == null ? void 0 : siblings.length;
    let segments = [];
    if (numSiblings) {
      for (let i = numSiblings; i--; ) {
        if (siblings[i]) siblings[i].completed = false;
      }
      if (cut.guillotineData.segmentCutOrder === void 0 || cut.guillotineData.segmentCutOrder === null)
        return;
      const order = cut.guillotineData.segmentCutOrder;
      for (let i = 0; i < numSiblings; i++) {
        if (i < order) siblings[i].completed = true;
      }
      segments.push(...siblings);
      segments = segments.filter((s) => s);
    }
    if (segments.length) {
      this.resetSegments();
      this.initSegments(segments);
    }
  }
  /**
      * toggle the visibility of the shapes
      * @param {Boolean} show
      */
  toggleShapes(show = false) {
    if (show) {
      this.shapeGroup.attr("display", "block");
      this.bandingGroup.attr("display", "block");
    } else {
      this.shapeGroup.attr("display", "none");
      this.bandingGroup.attr("display", "none");
    }
  }
  /**
      * add measurements to an axis
      * @param {Array} measurements array of arrays
      * @param {Array} values array of values
      * @param {String} axis x | y
      */
  addCutMeasurementAxes(measurements, values, axis2) {
    if (!axis2 || !(measurements == null ? void 0 : measurements.length)) return;
    measurements.forEach((measurement, index) => {
      const start = measurement[0];
      const end2 = measurement[1];
      if (axis2 === "x") {
        const xScale = d3.scaleLinear().domain([start, end2]).range([
          this.xPositionScale(start),
          this.xPositionScale(end2)
        ]);
        const tickPosition = (xScale.domain()[1] - xScale.domain()[0]) / 2 + xScale.domain()[0];
        const axis22 = this.axisGroup.append("g").attr(
          "transform",
          `translate(0, ${this.h - this.padding + this.axisSpacing})`
        ).attr("class", "axis measurement x").call(d3.axisBottom(xScale).tickValues([tickPosition]).tickSize(4).tickFormat(() => this.formatNumber(values[index])));
        axis22.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (text, index2, list) => list[index2].getBBox().height + 10
        );
        this.cutMeasurementXAxes.push(axis22);
      } else {
        const yScale = d3.scaleLinear().domain([start, end2]).range([
          this.yPositionScale(start),
          this.yPositionScale(end2)
        ]);
        const tickPosition = (yScale.domain()[1] - yScale.domain()[0]) / 2 + yScale.domain()[0];
        const axis22 = this.axisGroup.append("g").attr(
          "transform",
          `translate(${this.padding - this.axisSpacing}, 0)`
        ).attr("class", "axis measurement y").call(d3.axisLeft(yScale).tickValues([tickPosition]).tickSize(4).tickFormat(() => this.formatNumber(values[index])));
        axis22.selectAll("text").attr("x", 0).attr("y", 0).attr(
          "dy",
          (text, index2, list) => list[index2].getBBox().height + 10
        ).attr(
          "dx",
          (text, index2, list) => list[index2].getBBox().width / 4
        ).attr(
          "transform",
          (text, index2, list) => "rotate(90) translate(" + list[index2].getBBox().width / 4 + ")"
        );
        this.cutMeasurementYAxes.push(axis22);
      }
    });
  }
  /**
      * add the shape axes
      * @param {Shape} shape
      */
  addShapeAxes(shape) {
    var _a2;
    if (this.shapeXAxis) this.shapeXAxis.remove();
    if (this.shapeYAxis) this.shapeYAxis.remove();
    const x1 = shape.x;
    const x2 = shape.x + shape.l;
    const xScale = d3.scaleLinear().domain([x1, x2]).range([this.xPositionScale(x1), this.xPositionScale(x2)]);
    const y1 = shape.y;
    const y2 = shape.y + shape.w;
    const yScale = d3.scaleLinear().domain([y1, y2]).range([this.yPositionScale(y1), this.yPositionScale(y2)]);
    this.shapeXAxis = this.axisGroup.append("g").attr(
      "transform",
      `translate(0, ${this.h - this.padding + this.axisSpacing})`
    ).attr("class", "axis shape x").call(d3.axisBottom(xScale).tickValues(xScale.domain()).tickSize(4).tickFormat(this.formatNumber));
    this.shapeXAxis.selectAll("text").attr("dx", (text, index, list) => {
      const thisEl = list[index];
      if (thisEl === null) return;
      const bbox = thisEl.getBBox();
      if (index === 0) return -bbox.width / 2;
      else return bbox.width / 2;
    });
    if (((_a2 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a2.type) !== "linear") {
      this.shapeYAxis = this.axisGroup.append("g").attr(
        "transform",
        `translate(${this.padding - this.axisSpacing}, 0)`
      ).attr("class", "axis shape y").call(d3.axisLeft(yScale).tickValues(yScale.domain()).tickSize(4).tickFormat(this.formatNumber));
      this.shapeYAxis.selectAll("text").attr("x", 0).attr("y", 0).attr(
        "dy",
        (text, index, list) => {
          var _a3, _b;
          return ((_b = (_a3 = list[index]) == null ? void 0 : _a3.getBBox()) == null ? void 0 : _b.height) + 2;
        }
      ).attr(
        "dx",
        (text, index, list) => {
          var _a3, _b;
          return ((_b = (_a3 = list[index]) == null ? void 0 : _a3.getBBox()) == null ? void 0 : _b.width) / 2;
        }
      ).attr("transform", (text, index, list) => {
        var _a3, _b, _c, _d, _e, _f, _g, _h;
        if (this.flipY) {
          if (index === 0)
            return "rotate(90) translate(-" + ((_b = (_a3 = list[index]) == null ? void 0 : _a3.getBBox()) == null ? void 0 : _b.width) / 2 + ")";
          return "rotate(90) translate(" + ((_d = (_c = list[index]) == null ? void 0 : _c.getBBox()) == null ? void 0 : _d.width) / 2 + ")";
        } else {
          if (index === 0)
            return "rotate(90) translate(" + ((_f = (_e = list[index]) == null ? void 0 : _e.getBBox()) == null ? void 0 : _f.width) / 2 + ")";
          else
            return "rotate(90) translate(-" + ((_h = (_g = list[index]) == null ? void 0 : _g.getBBox()) == null ? void 0 : _h.width) / 2 + ")";
        }
      });
    }
  }
  getBandingAdjustment(type3, coordinate) {
    switch (type3) {
      case "y1":
        if (coordinate === "x") return 0;
        if (coordinate === "y") return this.flipY ? 1 : -1;
        break;
      case "y2":
        if (coordinate === "x") return 0;
        if (coordinate === "y") return this.flipY ? -1 : 1;
        break;
      case "x1":
        if (coordinate === "x") return this.flipX ? -1 : 1;
        if (coordinate === "y") return 0;
        break;
      case "x2":
        if (coordinate === "x") return this.flipX ? 1 : -1;
        if (coordinate === "y") return 0;
        break;
    }
    return 0;
  }
  getRectangleCoordinate(rectangle, coordinate, position, adjustment) {
    let coord;
    if (coordinate === "x") {
      let x;
      switch (position) {
        case "center":
          x = this.xPositionScale(rectangle.x + rectangle.l / 2);
          if (adjustment) x += adjustment;
          break;
        case "right":
          x = this.xPositionScale(rectangle.x + rectangle.l);
          if (adjustment) x -= adjustment;
          break;
        case "left":
        default:
          x = this.xPositionScale(this.flipX ? rectangle.x - rectangle.l : rectangle.x);
          if (adjustment) x -= adjustment;
      }
      coord = x;
    } else if (coordinate === "y") {
      let y2;
      switch (position) {
        case "center":
          y2 = this.yPositionScale(rectangle.y + rectangle.w / 2);
          if (adjustment) y2 += adjustment;
          break;
        case "bottom":
          y2 = this.yPositionScale(this.flipY ? rectangle.y + rectangle.w : rectangle.y);
          if (adjustment) y2 += adjustment;
          break;
        case "top":
        default:
          y2 = this.yPositionScale(this.flipY ? rectangle.y : rectangle.y + rectangle.w);
          if (adjustment) y2 -= adjustment;
      }
      coord = y2;
    }
    return coord;
  }
  getRotatedSide(position) {
    switch (position) {
      case "x1":
      case "l1":
        return "w1";
      case "x2":
      case "l2":
        return "w2";
      case "y1":
      case "w1":
        return "l2";
      case "y2":
      case "w2":
        return "l1";
    }
  }
  /**
      * update the position of the shapes and the content within
      */
  setShapePosition() {
    if (!this.shapes) return false;
    this.shapes.attr("x", (s) => this.getRectangleCoordinate(s, "x")).attr("y", (s) => this.getRectangleCoordinate(s, "y")).attr("width", (s) => this.getWidthAttribute(s)).attr("height", (s) => this.getHeightAttribute(s));
    if (this.main) {
      this.shapeIDText.attr("x", (s) => this.getRectangleCoordinate(s, "x", "center")).attr("y", (s) => this.getRectangleCoordinate(s, "y", "center")).attr("dy", 1);
      if (this.shapeNameText) {
        this.shapeNameText.attr("x", (s) => this.getRectangleCoordinate(s, "x", "center")).attr("y", (s, b, c2) => this.getRectangleCoordinate(
          s,
          "y",
          "bottom",
          -(c2[b].getBBox().height / 2 + 1)
        ));
      }
      this.shapeLengthText.attr("x", (s) => this.getRectangleCoordinate(s, "x", "center")).attr("y", (s, b, c2) => this.getRectangleCoordinate(
        s,
        "y",
        "top",
        -(c2[b].getBBox().height / 2 + 2)
      ));
      this.shapeWidthText.attr(
        "transform",
        (s, b, c2) => `translate(${this.getRectangleCoordinate(
          s,
          "x",
          "left",
          -(c2[b].getBBox().height / 2 + 2)
        )},${this.getRectangleCoordinate(s, "y", "center")}) ${this.device === "mobile" ? "rotate(90)" : "rotate(-90)"}`
      );
    }
  }
  //init or update the cuts
  initCuts(cutList) {
    this.resetCuts();
    if (!cutList || !(cutList == null ? void 0 : cutList.length) || !this.main || !this.elWidth)
      return false;
    this.cuts = this.cutGroup.selectAll("line").data(cutList).join("line").attr("class", "cut").attr("stroke-width", (cut) => {
      const width = this.measurementScale(this.getBladeWidth(cut.stock));
      if (width < 1) return 1;
      return Math.ceil(width);
    }).attr("x1", (cut) => this.xPositionScale(cut.getVisCoords("x1"))).attr("x2", (cut) => this.xPositionScale(cut.getVisCoords("x2"))).attr("y1", (cut) => this.yPositionScale(cut.getVisCoords("y1"))).attr("y2", (cut) => this.yPositionScale(cut.getVisCoords("y2"))).classed("trim", (cut) => cut.isTrim);
  }
  //init or update the segments
  initSegments(segments) {
    if (!segments || !(segments == null ? void 0 : segments.length) || !this.main || !this.elWidth)
      return false;
    this.resetSegments();
    this.segments = this.segmentGroup.selectAll("rect").data(segments).join("rect").attr("class", "segment").style("opacity", (segment) => {
      if ((segment == null ? void 0 : segment.offcut) === true) return 0.5;
    }).classed("offcut", (segment) => segment.offcut).classed("merged", (segment) => segment.merged).classed("near", (segment) => segment.shapePosition === "near").classed("far", (segment) => segment.shapePosition === "far").classed("completed", (segment) => segment.completed).attr("x", (segment) => this.getRectangleCoordinate(segment, "x")).attr("y", (segment) => this.getRectangleCoordinate(segment, "y")).attr("width", (segment) => this.getWidthAttribute(segment)).attr("height", (segment) => this.getHeightAttribute(segment));
    this.segmentGroup.selectAll("text").data(segments).join("text").attr("class", "segment-text").attr("x", (segment) => this.getRectangleCoordinate(segment, "x", "center")).attr("y", (s) => this.getRectangleCoordinate(s, "y", "center")).attr("text-anchor", "middle").text((segment) => {
      if (this.env !== "development") return null;
      if (segment.offcut) return null;
      if (segment.cutDirection === "l") {
        return this.env === "development" ? ` ${segment.id}` : "";
      } else if (segment.cutDirection === "w") {
        return this.env === "development" ? ` ${segment.id}` : "";
      }
    }).attr("dominant-baseline", "middle");
    if (!this.app && this.env === "development") {
      this.segments.on("mousedown", function(event, segment) {
        const logSegment = structuredClone(segment);
        const logProperties = [
          "id",
          "x",
          "y",
          "l",
          "w",
          "cutDirection",
          "cutPreference"
        ];
        console.log(logProperties.reduce((obj, prop) => {
          obj[prop] = getNestedProperty(logSegment, prop);
          return obj;
        }, {}));
      });
    }
  }
  initGroups(groups) {
    if (!groups || !(groups == null ? void 0 : groups.length) || !this.main || !this.elWidth)
      return false;
    this.resetGroups();
    this.groups = this.groupGroup.selectAll("rect").data(groups).join("rect").attr("class", "group").attr("x", (g) => this.getRectangleCoordinate(g, "x")).attr("y", (g) => this.getRectangleCoordinate(g, "y")).attr("width", (g) => this.getWidthAttribute(g)).attr("height", (g) => this.getHeightAttribute(g));
    this.groupGroup.attr("display", "block");
  }
  //get relevant segments for a specific cut
  getCutSegments(cut) {
    var _a2, _b, _c, _d;
    const parentSegmentID = (_a2 = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _a2.parentSegmentID;
    const activeSegments = ((_c = (_b = this.vueComponent) == null ? void 0 : _b.gs) == null ? void 0 : _c.activeSegments) ?? ((_d = this.vueComponent) == null ? void 0 : _d.activeSegments);
    if (!activeSegments.length) return false;
    let mainSegment;
    if (parentSegmentID) {
      mainSegment = activeSegments.find((s) => s.id === parentSegmentID);
    } else {
      mainSegment = activeSegments.find((s) => s.segmentType === "root");
    }
    if (mainSegment === void 0) return false;
    const children2 = mainSegment == null ? void 0 : mainSegment.children;
    if (children2 == null ? void 0 : children2.length) {
      const siblings = children2.map((child) => {
        const s = activeSegments.find((segment) => {
          return segment.x === child.x && segment.y === child.y && segment.l === child.l && segment.w === child.w;
        });
        if (s !== void 0) return s;
        return null;
      }).filter((s) => s !== null);
      const segments = {
        main: mainSegment,
        siblings
      };
      return segments;
    }
    return false;
  }
  /**
      * toggle the visibility of the segments
      * @param {Boolean} show
      */
  toggleSegments(show = true) {
    if (show) this.segmentGroup.attr("display", "block");
    else this.segmentGroup.attr("display", "none");
  }
  /**
      * show a list of possible movement positions
      */
  initPositions(shape, stock) {
    if (!stock) return false;
    if (!shape || !this.main) return false;
    let positions;
    stock.trimDimensions();
    if (!shape.willItFit(stock, shape.rot)) return false;
    stock.removeTrim();
    const placedShapes = getData.call(this.vueComponent, ["shapeList"]).filter((otherShape) => {
      var _a2;
      return otherShape.added && ((_a2 = otherShape == null ? void 0 : otherShape.stock) == null ? void 0 : _a2.id) === stock.id;
    });
    const placementCollection = getPlacementPositions(
      null,
      placedShapes,
      stock
    );
    const positionCollection = new PointCollection();
    placementCollection.toArray().forEach((p2) => {
      positionCollection.addPoints(convertPointToShapePositions(shape, p2, stock).toArray());
    });
    if (stock.cutType === "efficiency") {
      [
        new Point(0 + (stock.trim.x1 ?? 0), 0 + (stock.trim.y1 ?? 0)),
        new Point(0 + (stock.trim.x1 ?? 0), 0 + (stock.trim.y1 ?? 0)),
        new Point(
          stock.l - shape.l - (stock.trim.x2 ?? 0),
          0 + (stock.trim.y1 ?? 0)
        ),
        new Point(
          0 + (stock.trim.x1 ?? 0),
          stock.w - shape.w - (stock.trim.y2 ?? 0)
        ),
        new Point(
          stock.l - shape.l - (stock.trim.x2 ?? 0),
          stock.w - shape.w - (stock.trim.y2 ?? 0)
        )
      ].forEach((c2) => positionCollection.addPoint(c2));
      positions = positionCollection.toArray();
    } else {
      positionCollection.addPoint(new Point(0 + (stock.trim.x1 ?? 0), 0 + (stock.trim.y1 ?? 0)));
      positions = positionCollection.toArray();
    }
    for (let i = positions.length; i--; ) {
      shape.x = positions[i].x;
      shape.y = positions[i].y;
      for (let j = placedShapes.length; j--; ) {
        if (this.collision(shape, placedShapes[j], stock)) {
          positions.splice(i, 1);
          break;
        }
      }
    }
    this.positionGroup.selectAll("rect").data(positions).join("rect").attr("data-id", (_p, index) => index).attr("class", "shape ghost").attr("x", (p2) => {
      shape.x = p2.x;
      return this.getRectangleCoordinate(shape, "x");
    }).attr("y", (p2) => {
      shape.y = p2.y;
      return this.getRectangleCoordinate(shape, "y");
    }).attr("width", this.getWidthAttribute(shape)).attr("height", this.getHeightAttribute(shape)).on("mousedown", (event, position) => {
      event.stopPropagation();
      const partsBin = getRef.call(this.vueComponent, "partsBin");
      if (partsBin) partsBin.moveShape(
        event.currentTarget,
        shape,
        position
      );
    });
    if (!this.hasTouch) {
      this.positionGroup.selectAll("rect").on(
        "mouseover",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", true);
          d3.select(this).raise();
        },
        {
          passive: true
        }
      ).on(
        "mouseout",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", false);
        },
        {
          passive: true
        }
      );
    }
    this.dotGroup.selectAll("circle").data(positions).join("circle").attr("data-id", (_p, index) => index).attr("class", "dot").attr("cx", (p2) => {
      shape.x = p2.x;
      return this.getRectangleCoordinate(shape, "x");
    }).attr("cy", (p2) => {
      shape.y = p2.y;
      return this.getRectangleCoordinate(shape, "y");
    }).attr("r", 8).on("mousedown", (event, p2) => {
      event.stopPropagation();
      const partsBin = getRef.call(this.vueComponent, "partsBin");
      if (partsBin) partsBin.moveShape(
        event.currentTarget,
        shape,
        p2
      );
    });
    shape.x = 0;
    shape.y = 0;
    if (!this.hasTouch) {
      this.dotGroup.selectAll("circle").on(
        "mouseover",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", true);
          const id = d3.select(this).attr("data-id");
          const ghost = d3.select(`.ghost[data-id="${id}"]`);
          ghost.raise();
          ghost.classed("highlight", true);
        },
        {
          passive: true
        }
      ).on(
        "mouseout",
        function(event) {
          event.stopPropagation();
          d3.select(this).classed("hover", false);
          const id = d3.select(this).attr("data-id");
          d3.select(`.ghost[data-id="${id}"]`).classed(
            "highlight",
            false
          );
        },
        {
          passive: true
        }
      );
    }
    if (!(positions == null ? void 0 : positions.length)) return false;
    return true;
  }
  /**
      * show a list of placement positions
      */
  initPlacementPositions(placementPositions) {
    if (this.env !== "development" || this.debug !== "positions") return;
    if (!(placementPositions == null ? void 0 : placementPositions.length)) return false;
    this.placementPositionGroup.selectAll("circle").data(placementPositions).join("circle").attr("data-id", (_p, index) => index).attr("class", "dot").attr("cx", (p2) => {
      return this.xPositionScale(p2.x);
    }).attr("cy", (p2) => {
      return this.yPositionScale(p2.y);
    }).attr("r", 3).on("mousedown", (event, p2) => {
      event.stopPropagation();
      console.log(p2);
    });
  }
  /**
      * toggle the visibility of the cuts
      * @param {Boolean} show
      */
  toggleCuts(show = true) {
    if (show) this.cutGroup.attr("display", "block");
    else this.cutGroup.attr("display", "none");
  }
  clearSelection() {
    var _a2;
    if (this == null ? void 0 : this.shapes) {
      this.shapes.classed("selected", false);
      this.shapes.classed("hover", false);
      this.shapes.style("fill", (s) => this.getShapeColor(s));
    }
    if (this == null ? void 0 : this.cuts) {
      this.cuts.classed("selected", false);
      this.cuts.classed("highlight", false);
      this.cuts.classed("inside-segment", false);
      this.cuts.style("visibility", "visible");
      this.cuts.attr("stroke-width", (cut) => {
        const width = this.measurementScale(this.getBladeWidth(cut.stock));
        if (width < 1) return 1;
        return Math.ceil(width);
      });
    }
    if ((_a2 = this == null ? void 0 : this.shapes) == null ? void 0 : _a2.length) this.shapes.classed("selected", false);
  }
  /**
      * add padding
      * this.padding will be 0 when necessary
      * @param {number} value
      */
  addPadding(value2) {
    return value2 + this.padding;
  }
  /**
      * @param {Container} container
      * @returns {number} blade width
      */
  getBladeWidth(container = null) {
    var _a2, _b;
    if (valueSet((_a2 = this == null ? void 0 : this.saw) == null ? void 0 : _a2.bladeWidth)) {
      return (_b = this.saw) == null ? void 0 : _b.bladeWidth;
    } else if (valueSet(container) && container !== null) {
      return container.getBladeWidth();
    }
    return 0;
  }
  getHalfBladeWidth(container = null) {
    const bladeWidth = this.getBladeWidth(container);
    if (bladeWidth !== void 0 && bladeWidth > 0) return bladeWidth / 2;
    return 0;
  }
  resetShapes() {
    if (this.shapeGroup) this.shapeGroup.selectAll("*").remove();
    if (this.bandingGroup) this.bandingGroup.selectAll("*").remove();
    this.resetShapeAxes();
  }
  resetShapeAxes() {
    if (this.shapeXAxis) this.shapeXAxis.remove();
    if (this.shapeYAxis) this.shapeYAxis.remove();
  }
  resetStock() {
    if (this.stockGroup) this.stockGroup.selectAll("*").remove();
    if (this.axisGroup) this.axisGroup.selectAll("*").remove();
    this.resetStockAxes();
  }
  resetStockAxes() {
    if (this.xAxis) this.xAxis.remove();
    if (this.yAxis) this.yAxis.remove();
  }
  resetCuts() {
    if (this.cutGroup) this.cutGroup.selectAll("*").remove();
    this.resetCutMeasurementAxes();
  }
  resetSegments() {
    if (this.segmentGroup) this.segmentGroup.selectAll("*").remove();
  }
  resetGroups() {
    if (this.groupGroup) this.groupGroup.selectAll("*").remove();
  }
  resetCutMeasurementAxes() {
    var _a2, _b;
    if ((_a2 = this.cutMeasurementXAxes) == null ? void 0 : _a2.length) {
      this.cutMeasurementXAxes.forEach((axis2) => axis2.remove());
      this.cutMeasurementXAxes.length = 0;
    }
    if ((_b = this.cutMeasurementYAxes) == null ? void 0 : _b.length) {
      this.cutMeasurementYAxes.forEach((axis2) => axis2.remove());
      this.cutMeasurementYAxes.length = 0;
    }
  }
  resetPositions() {
    if (this.positionGroup) this.positionGroup.selectAll("*").remove();
    if (this.dotGroup) this.dotGroup.selectAll("*").remove();
  }
  resetPlacementPositions() {
    if (this.placementPositionGroup) this.dotGroup.selectAll("*").remove();
  }
  reset() {
    this.resetPositions();
    this.resetPlacementPositions();
    this.resetShapes();
    this.resetStock();
    this.resetCuts();
    this.resetSegments();
  }
  /**
      * detect collision - required for move mode
      * @param {object} thisShape
      * @param {object} testShape
      * @param {object} container
      * @returns {boolean} true if collision
      */
  collision(thisShape, testShape, container) {
    if (thisShape.id === testShape.id)
      throw new Error("collision comparing to self");
    return (
      // 1 left
      thisShape.x < testShape.x + testShape.l + this.getBladeWidth(container) && // 2 right
      thisShape.x + thisShape.l + this.getBladeWidth(container) > testShape.x && // 3 bottom
      thisShape.y < testShape.y + testShape.w + this.getBladeWidth(container) && // 4 top
      thisShape.y + thisShape.w + this.getBladeWidth(container) > testShape.y
    );
  }
}
function getNestedProperty(obj, prop) {
  return prop.split(".").reduce((res, prop2) => res[prop2], obj);
}
function setData(path2, value2, type3 = null) {
  var _a2;
  if (!(path2 == null ? void 0 : path2[0])) return false;
  switch (type3) {
    case "shallow":
      value2 = shallowRef(value2);
      break;
    case "raw":
      value2 = markRaw(value2);
      break;
  }
  if (typeof ((_a2 = this == null ? void 0 : this.gs) == null ? void 0 : _a2[path2[0]]) !== "undefined") set(this.gs, path2, value2);
  else if (typeof (this == null ? void 0 : this[path2[0]]) !== "undefined") set(this, path2, value2);
  return true;
}
function getData(path2) {
  var _a2;
  if (!(path2 == null ? void 0 : path2[0])) return null;
  if ("gs" in this && typeof ((_a2 = this == null ? void 0 : this.gs) == null ? void 0 : _a2[path2[0]]) !== "undefined")
    return get(this.gs, path2);
  else if (typeof (this == null ? void 0 : this[path2[0]]) !== "undefined") return get(this, path2);
}
function getOptions(path2) {
  var _a2;
  if (!(path2 == null ? void 0 : path2[0])) return null;
  if ("optionsStore" in this && typeof ((_a2 = this == null ? void 0 : this.optionsStore) == null ? void 0 : _a2[path2[0]]) !== "undefined")
    return get(this.optionsStore, path2);
  else if (typeof (this == null ? void 0 : this[path2[0]]) !== "undefined") return get(this, path2);
}
function resetProgress(progress) {
  progress.queue = 0;
  progress.stockCount = 0;
  progress.shapeCount = 0;
  progress.resultCount = 0;
  progress.complete = false;
}
function toggleWidget(name, show = null) {
  var _a2, _b;
  if (typeof ((_a2 = this.$refs) == null ? void 0 : _a2[name]) === "undefined" || ((_b = this.$refs) == null ? void 0 : _b[name]) === null)
    return;
  if (show !== null) this.$refs[name].visible = show;
  else {
    this.$refs[name].visible = !this.$refs[name].visible;
  }
}
function getActiveStock(stockList, activeStockId) {
  if (!(stockList == null ? void 0 : stockList.length)) return null;
  return stockList.find((stock) => stock.id === activeStockId);
}
function getActiveCuts(cutList, activeStock, sorting = "") {
  if (!(cutList == null ? void 0 : cutList.length) || !activeStock) return [];
  const cuts = cutList.filter((cut) => {
    var _a2, _b, _c;
    if (!sorting) return (((_a2 = cut == null ? void 0 : cut.stock) == null ? void 0 : _a2.id) ?? (cut == null ? void 0 : cut.stockId)) === activeStock.id && !((_b = cut == null ? void 0 : cut.guillotineData) == null ? void 0 : _b.ptxDummyCut);
    else if (sorting === "ptx") return (((_c = cut == null ? void 0 : cut.stock) == null ? void 0 : _c.id) ?? (cut == null ? void 0 : cut.stockId)) === activeStock.id;
  });
  cuts.sort((a2, b) => {
    var _a2, _b;
    return ((_a2 = a2 == null ? void 0 : a2.guillotineData) == null ? void 0 : _a2.order) - ((_b = b == null ? void 0 : b.guillotineData) == null ? void 0 : _b.order);
  });
  return cuts;
}
function getUsedStock(stockList) {
  if (!(stockList == null ? void 0 : stockList.length)) return [];
  return stockList.filter((stock) => stock.used === true);
}
function initVis(config2 = {
  app: false,
  env: "production",
  main: true,
  elementID: "#smartcut-svg-wrapper",
  units: this.units,
  decimalPlaces: 2,
  saw: this.optionsStore.saw,
  embed: false,
  colors: this.colors,
  options: this.visOptions,
  vueComponent: this
}) {
  if (this.visInit) return false;
  this.vis = markRaw(new Vis(config2));
  this.vis.initStock(this.activeStock);
  this.vis.initShapes(this.activeShapes, this.shapeList);
  this.vis.initCuts(this.activeCuts, this.activeStock);
  this.visInit = true;
}
function createStockList(globalAutoAdd = false) {
  var _a2;
  let inputStock = ((_a2 = this == null ? void 0 : this.gs) == null ? void 0 : _a2.inputStock) || (this == null ? void 0 : this.inputStock);
  if (!(inputStock == null ? void 0 : inputStock.length)) return ["No stock input"];
  const stockList = getData.call(this, ["stockList"]);
  if (stockList) stockList.length = 0;
  const issues = [];
  if (globalAutoAdd) inputStock = [inputStock[0]];
  for (let i = 0; i < inputStock.length; i++) {
    const stock = inputStock[i];
    if (!(stock == null ? void 0 : stock.q) && !stock.autoAdd && !globalAutoAdd) continue;
    issues.push(...this.createStock(stock, i));
  }
  return issues;
}
function calculate(orientationModel = 0) {
  var _a2, _b, _c, _d;
  if (this.thinking) return false;
  this.thinking = true;
  this.success = false;
  const issues = [];
  issues.push(...validateInputShapes.call(this));
  if (issues.length) {
    this.showMessage({
      heading: "Part issue",
      main: "Issue with part inputs:",
      list: issues.slice(0, 5)
    });
    this.thinking = false;
    return;
  }
  this.reset();
  issues.push(...this.createStockList());
  if (issues.length) {
    this.showMessage({
      heading: `Stock issue${issues.length > 1 ? "s" : ""}`,
      main: `${issues.length} issue${issues.length > 1 ? "s" : ""} found with stock inputs`,
      list: issues.slice(0, 5)
    });
    this.thinking = false;
    return;
  }
  issues.push(...this.createShapeList(orientationModel));
  if (issues.length) {
    this.showMessage({
      heading: "Part issue",
      main: "Issue with part inputs:",
      list: issues.slice(0, 5)
    });
    this.thinking = false;
    return;
  }
  const saw = new Saw(
    this.saw,
    ((_a2 = this.saw) == null ? void 0 : _a2.stockType) ?? ((_b = this.stockList) == null ? void 0 : _b[0].type)
  );
  if (saw.issues.length) {
    this.showMessage({
      heading: `Saw issue${saw.issues.length > 1 ? "s" : ""}`,
      main: `${saw.issues.length} issue${saw.issues.length > 1 ? "s" : ""} found with saw inputs:`,
      list: saw.issues.slice(0, 5)
    });
    this.thinking = false;
    return;
  }
  this.saw = saw;
  if (!((_c = this.stockList) == null ? void 0 : _c.length)) {
    this.showMessage({
      heading: "No stock",
      main: "No stock items were found."
    });
    this.thinking = false;
    return;
  }
  if (!((_d = this.shapeList) == null ? void 0 : _d.length)) {
    this.showMessage({
      heading: "No parts",
      main: "No parts in list."
    });
    this.thinking = false;
    return;
  }
  if (this.debug)
    console.log(
      "SmartCut - calculating",
      "stock",
      this.stockList.map((s) => s.dimensions()),
      "parts",
      this.shapeList.map((s) => s.dimensions())
    );
  this.socket.connect();
  this.socket.compress(true).emit(
    "calculate",
    {
      inputs: {
        shapeList: this.inputShapes,
        stockList: this.inputStock,
        saw: this.saw
      },
      saw: this.saw,
      shapeList: this.shapeList,
      stockList: this.stockList,
      enableEvo: this.enableEvo,
      domain: this.domain
    }
  );
}
function refreshShapes() {
  const vis = getData.call(this, ["vis"]);
  if (!vis) return;
  const shapeList = getData.call(this, ["shapeList"]);
  if (!(shapeList == null ? void 0 : shapeList.length)) return false;
  vis.resetPositions();
  vis.resetShapes();
  const activeShapes = getData.call(this, ["activeShapes"]);
  vis.initShapes(activeShapes, shapeList);
  const PartsBin = getRef.call(this, "PartsBin");
  if (PartsBin) PartsBin.clear(false);
}
function refreshStock() {
  const vis = getData.call(this, ["vis"]);
  if (!vis) return;
  const stockList = getData.call(this, ["stockList"]);
  if (!(stockList == null ? void 0 : stockList.length)) return false;
  const activeStock = getData.call(this, ["activeStock"]);
  vis.initStock(activeStock);
  const activeCuts = getData.call(this, ["activeCuts"]);
  vis.initCuts(activeCuts);
  const activeSegments = getData.call(this, ["activeSegments"]);
  vis.initSegments(activeSegments);
  vis.resetPositions();
  if (typeof this.toggleSegments === "function") this.toggleSegments(false);
  if (this == null ? void 0 : this.cutMode) this == null ? void 0 : this.showCut(0);
}
function clearSelection() {
  var _a2;
  const vis = ((_a2 = this == null ? void 0 : this.gs) == null ? void 0 : _a2.vis) ?? (this == null ? void 0 : this.vis);
  if (!vis) return;
  vis.clearSelection();
  vis.resetShapeAxes();
  vis.resetCutMeasurementAxes();
  vis.resetPositions();
}
function showStock(id) {
  const examineShape = getData.call(this, ["examineShape"]);
  if (examineShape) this.examineShape = null;
  setData.call(this, ["activeStockId"], id);
}
function validateInputShapes() {
  var _a2;
  const issues = [];
  const inputShapes = ((_a2 = this == null ? void 0 : this.gs) == null ? void 0 : _a2.inputShapes) ?? (this == null ? void 0 : this.inputShapes);
  if (!inputShapes.length) issues.push("No parts found");
  const totalQ = totalQuantity(inputShapes);
  if (!(inputShapes == null ? void 0 : inputShapes.length) || !totalQ) {
    issues.push("No quantity of parts found");
    return issues;
  }
  return issues;
}
function getRef(id, levelsUp = 0) {
  var _a2;
  let currentInstance2 = this;
  for (let i = 0; i < levelsUp; i++) {
    if (!currentInstance2.$parent) {
      return null;
    }
    currentInstance2 = currentInstance2.$parent;
  }
  const ref2 = (_a2 = currentInstance2 == null ? void 0 : currentInstance2.$refs) == null ? void 0 : _a2[id];
  return ref2 ? ref2 : null;
}
function online(val) {
  if (val === false && this.allowOnlineMessages) {
    const message = {
      heading: "Offline",
      main: "<p>Looks like you have just gone offline.</p><p>Calculations are disabled for now.</p>"
    };
    if (typeof this.showModalMessage === "function") {
      this.showModalMessage(message);
    }
    this.allowOnlineMessages = false;
    this.onlineTimer = setTimeout(() => {
      this.allowOnlineMessages = true;
    }, 3e4);
  }
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const toString$1 = Object.prototype.toString;
const isObject$1 = (val) => toString$1.call(val) === "[object Object]";
const noop$3 = () => {
};
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    return new Promise((resolve2, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function getLifeCycleTarget(target) {
  return getCurrentInstance();
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter2,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick$1(fn);
}
function unrefElement(elRef) {
  var _a2;
  const plain = toValue(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let events2;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events2, listeners, options] = args;
  }
  if (!target)
    return noop$3;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener2, options2) => {
    el.addEventListener(event, listener2, options2);
    return () => el.removeEventListener(event, listener2, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener2) => register(el, event, listener2, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    },
    initOnMounted
  } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = toValue(defaults2);
  const type3 = guessSerializerType(rawInit);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type3];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data,
    () => write(data.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      useEventListener(window2, "storage", update);
      useEventListener(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update();
    });
  }
  if (!initOnMounted)
    update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      window2.dispatchEvent(new CustomEvent(customStorageEventName, {
        detail: {
          key,
          oldValue,
          newValue,
          storageArea: storage
        }
      }));
    }
  }
  function write(v) {
    try {
      const oldValue = storage.getItem(key);
      if (v == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value2 = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value2, rawInit);
      else if (type3 === "object" && !Array.isArray(value2))
        return { ...rawInit, ...value2 };
      return value2;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
        data.value = read(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event)
        nextTick$1(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type: type3, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type3] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray$1(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray$1).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray$1(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup$1[chars.charCodeAt(i)] = i;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i)];
    encoded2 = lookup$1[base64.charCodeAt(i + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type3 = encodedPacket.charAt(0);
  if (type3 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type3];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type3],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type3]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size2) {
  if (chunks[0].length === size2) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size2);
  let j = 0;
  for (let i = 0; i < size2; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length2 = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c2 = str.charCodeAt(i);
    if (c2 < 128) {
      length2 += 1;
    } else if (c2 < 2048) {
      length2 += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length2 += 3;
    } else {
      i++;
      length2 += 4;
    }
  }
  return length2;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a2;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a3;
        if (xhr.readyState === 3) {
          (_a3 = this._opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this._onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request.requestsCount++;
      Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
const hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a2;
    (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$2(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener2) => listener2());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse$2(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse$2(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t2) => {
      const transportName = t2.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t2;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data = this.writeBuffer[i].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type3, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type: type3,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i = 0; i < this._upgrades.length; i++) {
        this._probe(this._upgrades[i]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i = 0; i < upgrades.length; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o2 = typeof uri === "object" ? uri : opts;
    if (!o2.transports || o2.transports && typeof o2.transports[0] === "string") {
      o2.transports = (o2.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t2) => !!t2);
    }
    super(uri, o2);
  }
};
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse$2(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer2) {
    this.replacer = replacer2;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf = str.substring(start, i);
      if (buf != Number(buf) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i + 1)) {
      const start = i + 1;
      while (++i) {
        const c2 = str.charAt(i);
        if ("," === c2)
          break;
        if (i === str.length)
          break;
      }
      p2.nsp = str.substring(start, i);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start = i + 1;
      while (++i) {
        const c2 = str.charAt(i);
        if (null == c2 || Number(c2) != c2) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type3, payload) {
    switch (type3) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a2, _b, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a2 = this.io.engine) === null || _a2 === void 0 ? void 0 : _a2.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) ;
    else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a2;
    const timeout = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve2, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve2(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener2 of listeners) {
        listener2.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener2) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener2);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener2) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener2);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener2) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener2) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener2 === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener2) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener2);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener2) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener2);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener2) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener2) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener2 === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener2 of listeners) {
        listener2.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min2) {
  this.ms = min2;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    if (!v) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a2;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a2;
    this.cleanup();
    (_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache[id] && path2 in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
function initSocket(server = void 0) {
  this.socket = lookup(server, {
    withCredentials: true,
    //this is required to send passport user data
    autoConnect: false
  });
  this.socket.on("connect", () => {
    setData.call(this, ["connected"], true);
  });
  this.socket.on("maintenance", () => {
    setData.call(this, ["maintenanceMode"], true);
    this.socket.disconnect();
    if (this.env === "development")
      console.log("SmartCut - maintenance mode flag received from server");
  });
  this.socket.on("connect_error", (err) => {
    setData.call(this, ["connected"], false);
    console.warn(`SmartCut - socket connect_error: ${err.message}`);
    if (typeof alert !== "undefined")
      alert("We are having trouble connecting to the server. Please try again later.");
    this.socket.close();
  });
  this.socket.on("message", (data) => console.log(data));
  this.socket.on("user", (data) => {
    setData.call(this, ["user"], data, "shallow");
  });
  this.socket.on("queued", () => {
    setData.call(this, ["progress", "queue"], 1);
  });
  this.socket.on("jobInProgess", (jobID) => {
    alert(`You already have a job in progress, please wait for it to finish

Job ID: ${jobID}`);
    return false;
  });
  this.socket.on("jobStart", () => setData.call(this, ["progress", "queue"], 2));
  this.socket.on("progress", (res) => {
    const data = res.data;
    if (typeof data.shapeCount !== "undefined") {
      setData.call(this, ["progress", "shapeCount"], data.shapeCount);
    }
    if (typeof data.stockCount !== "undefined") {
      setData.call(this, ["progress", "stockCount"], data.stockCount);
    }
    if (!data.stockCount && !data.shapeCount) {
      const originalResultCount = getData.call(this, ["progress", "resultCount"]);
      setData.call(this, ["progress", "resultCount"], originalResultCount + 1);
    }
  });
  this.socket.on("upgrade", () => {
    if ("showUpgradeModal" in this && typeof this.showUpgradeModal === "function") {
      this.showUpgradeModal();
    }
    setData.call(this, ["thinking"], false);
  });
  this.socket.on("error", (data) => {
    var _a2;
    setData.call(this, ["thinking"], false);
    const reset = getData.call(this, ["reset"]);
    if (typeof reset === "function") reset();
    console.error("SmartCut error:", data);
    (_a2 = window == null ? void 0 : window.top) == null ? void 0 : _a2.postMessage(
      {
        type: "scError",
        message: data
      },
      "*"
    );
    if ("showMessage" in this && typeof this.showMessage === "function") {
      this.showMessage(data);
    }
    if (typeof this.showModalMessage === "function") {
      this.showModalMessage({
        heading: "Issue",
        main: data ? `<p>${data}</p>` : "<p>We are having trouble connecting to the server.</p><p>Please try again later and let us know.</p>"
      });
    }
  });
  this.socket.on("result", (data) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    this.socket.disconnect();
    const result = data.result;
    const resetProgress2 = getData.call(this, ["resetProgress"]);
    setData.call(this, ["placementPositions"], result.placementPositions ?? []);
    setData.call(this, ["metadata"], result.metadata ?? {});
    setData.call(this, ["unusableShapes"], result.unusableShapes ?? []);
    setData.call(this, ["unavailableStock"], result.unavailableStock ?? []);
    if (!((_a2 = result.shapeList) == null ? void 0 : _a2.length) || !((_b = result.stockList) == null ? void 0 : _b.length)) {
      resetProgress2();
      if (typeof this.showModalMessage === "function") {
        let message = "<p>We did not manage to fit any parts.</p>";
        if ((_c = result == null ? void 0 : result.unusableShapes) == null ? void 0 : _c.length) {
          message = "<p>No parts were usable.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>";
          this.showModalMessage({
            heading: "Parts unusable",
            main: message,
            buttonText: "Show me",
            buttonCallback: (modal) => {
              modal.showInputPanel(
                "parts",
                "inputs-unusable-parts"
              );
            }
          });
        } else {
          message += "<p>Please double check your list.</p>";
          this.$nextTick(() => {
            this.showModalMessage({
              heading: "Parts unusable",
              main: message
            });
          });
        }
      }
      (_d = window == null ? void 0 : window.top) == null ? void 0 : _d.postMessage(
        {
          type: "scError",
          message: "No parts were added - please double check your list."
        },
        "*"
      );
      if ("showMessage" in this && typeof this.showMessage === "function") {
        this.showMessage("No parts were added - please double check your list.");
      }
      setData.call(this, ["thinking"], false);
      if (typeof this.toggleWidget === "function")
        this.toggleWidget.call(this, "inputs", true);
      return false;
    }
    if (result.shapeList.find((s) => !s.added)) {
      if (typeof this.showModalMessage === "function") {
        this.$nextTick(() => {
          this.showModalMessage({
            heading: "Parts not used",
            main: "<p>We did not use all your parts.</p><p>Click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>",
            buttonText: "Show me",
            buttonCallback: (modal) => {
              modal.showInputPanel(
                "parts",
                "inputs-unusable-parts"
              );
            }
          });
        });
      }
    }
    setData.call(this, ["progress", "complete"], true);
    setData.call(this, ["jobId"], data == null ? void 0 : data.jobId);
    this.toggleWidget("updateStock", false);
    this.toggleWidget("options", false);
    this.toggleWidget("offcuts", false);
    this.toggleWidget("results", false);
    this.toggleWidget("cutlist", false);
    this.toggleWidget("export", false);
    this.toggleWidget("labels", false);
    let saw;
    if (result == null ? void 0 : result.saw) {
      saw = new Saw(
        result == null ? void 0 : result.saw,
        ((_e = result == null ? void 0 : result.saw) == null ? void 0 : _e.stockType) ?? ((_g = (_f = result.stockList) == null ? void 0 : _f[0]) == null ? void 0 : _g.type)
      );
      setData.call(this, ["saw"], saw, "shallow");
    }
    const stockList = recreateStockList({
      saw,
      stockList: result.stockList,
      removeScores: true,
      preventAutoRotation: true
    });
    setData.call(this, ["stockList"], stockList, "shallow");
    const usedStock = getData.call(this, ["usedStock"], "shallow");
    if (usedStock.length) {
      this.$nextTick(() => {
        setData.call(this, ["activeStockId"], usedStock[0].id);
      });
    }
    setData.call(
      this,
      ["shapeList"],
      recreateShapeList({
        shapeList: result.shapeList,
        stockList,
        preventAutoRotation: true
      }),
      "shallow"
    );
    if (result == null ? void 0 : result.cutList) {
      setData.call(
        this,
        ["cutList"],
        recreateCutList({
          cutList: result.cutList,
          stockList
        }),
        "shallow"
      );
    }
    if (result == null ? void 0 : result.segmentList)
      setData.call(
        this,
        ["segmentList"],
        recreateSegmentList({
          segmentList: result.segmentList,
          stockList
        }),
        "shallow"
      );
    if (result == null ? void 0 : result.offcuts)
      setData.call(
        this,
        ["offcuts"],
        recreateOffcuts({
          offcuts: result.offcuts,
          stockList,
          preventAutoRotation: true
        })
      );
    if (result == null ? void 0 : result.metadata) setData.call(this, ["metadata"], result.metadata, "shallow");
    if (result == null ? void 0 : result.inputs) setData.call(this, ["inputs"], result.inputs, "raw");
    if ((_h = result == null ? void 0 : result.evolutionVisData) == null ? void 0 : _h.length) {
      setData.call(this, ["evolutionVisData"], result.evolutionVisData, "raw");
    } else if (typeof this.toggleWidget === "function") {
      this.toggleWidget.call(this, "evolution", false);
    }
    if (typeof this.toggleWidget === "function")
      this.toggleWidget.call(this, "workbench", true);
    setData.call(this, ["thinking"], false);
    const inputs = getRef.call(this, "inputs");
    if (inputs && (inputs == null ? void 0 : inputs.success)) inputs.success = false;
    this.$nextTick(() => {
      var _a3, _b2;
      const addedShapes = getData.call(this, ["addedShapes"]);
      if (addedShapes.length === 0) {
        resetProgress2();
        if (typeof this.showModalMessage === "function") {
          let message = "<p>We could not fit any parts.</p>";
          if ((_a3 = result == null ? void 0 : result.unusableShapes) == null ? void 0 : _a3.length) {
            message += "<p>Some parts were not usable - click below to view the <strong>Unusable parts</strong> message in the <strong>Inputs panel</stong>.</p>";
            this.showModalMessage({
              heading: "No layouts",
              main: message,
              buttonText: "More info",
              buttonCallback: (modal) => {
                modal.showInputPanel(
                  "parts",
                  "inputs-unusable-parts"
                );
              }
            });
          } else {
            message += "<p>Please double check your list.</p>";
            this.showModalMessage({
              heading: "No layouts",
              main: message
            });
          }
        }
        (_b2 = window == null ? void 0 : window.top) == null ? void 0 : _b2.postMessage(
          {
            type: "scError",
            message: "No parts were added."
          },
          "*"
        );
        console.warn("No parts were added.");
        if (typeof this.toggleWidget === "function")
          this.toggleWidget.call(this, "inputs", true);
      }
    });
  });
}
function shouldRotateDiagram(orientationModel = 0, stockGrainSummary, rectangle = null, rectangleType = null, shapeOrientation = null) {
  if (!isInputShape(rectangle) && !isInputUserGroup || rectangleType === "stock") return false;
  let orientation, rotate;
  if (isInputShape(rectangle)) {
    orientation = rectangle.orientationLock;
  } else if (isInputUserGroup(rectangle)) {
    orientation = rectangle.direction;
  } else if (rectangleType === "shape") {
    orientation = shapeOrientation;
  }
  if (orientationModel === 0 || isInputUserGroup(rectangle)) {
    switch (stockGrainSummary) {
      case "n":
        rotate = orientation === "w" || shapeOrientation === "w";
        break;
      case "l":
      case "y":
        rotate = orientation === "w" || shapeOrientation === "w";
        break;
      case "w":
        rotate = orientation === "l" || shapeOrientation === "l";
        break;
      default:
        rotate = shapeOrientation === "w";
    }
  } else if (orientationModel === 1) {
    rotate = rectangle.w > rectangle.l;
  } else if (orientationModel === 2) {
    switch (stockGrainSummary) {
      case "n":
        rotate = rectangle.w > rectangle.l;
        break;
      case "y":
      case "l":
        rotate = rectangle.w > rectangle.l;
        break;
      case "w":
        rotate = rectangle.w > rectangle.l;
        break;
      default:
        rotate = false;
    }
  }
  return rotate;
}
function shouldRotateSides(orientationModel, stockGrainSummary, rectangle = null, rectangleType = null, shapeOrientation = null) {
  if (!isInputShape(rectangle) || rectangleType === "shape") return false;
  let rotate;
  if (orientationModel === 0) {
    return shouldRotateDiagram(orientationModel, stockGrainSummary, rectangle, rectangleType, shapeOrientation);
  } else if (orientationModel === 1) {
    return shouldRotateDiagram(orientationModel, stockGrainSummary, rectangle, rectangleType, shapeOrientation);
  } else if (orientationModel === 2) {
    return false;
  }
  return rotate;
}
function mapOrientation(shape, orientationModel = 0) {
  if (!orientationModel) return shape;
  if (orientationModel === 1 || orientationModel === 2) {
    shape.preventAutoRotation = true;
    switch (shape.orientationLock) {
      case "l":
        if (shape.l < shape.w) {
          if (orientationModel === 2) {
            rotateShapeProperties(shape);
          }
          shape.orientationLock = "w";
        }
        break;
      case "w":
        if (shape.l < shape.w) {
          shape.orientationLock = "l";
        }
        break;
      default:
        if (shape.l < shape.w) {
          if (orientationModel === 2) {
            rotateShapeProperties(shape);
          }
        }
        shape.orientationLock = "";
    }
    return shape;
  }
}
function rotateShapeProperties(shape) {
  if (shape.banding) {
    shape.banding = rotateSides(shape.banding);
  }
  if (shape.bandingType) {
    shape.bandingType = rotateSides(shape.bandingType);
  }
  if (shape.trim) {
    shape.trim = rotateSides(shape.trim);
  }
}
function rotateSides(sidesObject, reverse = false) {
  const newObject = {
    x1: null,
    x2: null,
    y1: null,
    y2: null
  };
  if (reverse) {
    [newObject.x1, newObject.x2, newObject.y1, newObject.y2] = [sidesObject.x2, sidesObject.x1, sidesObject.y2, sidesObject.y1];
    if ("a" in sidesObject && "b" in sidesObject && "c" in sidesObject && "d" in sidesObject) {
      [newObject.d, newObject.a, newObject.b, newObject.c] = [sidesObject.a, sidesObject.b, sidesObject.c, sidesObject.d];
    }
  } else {
    [newObject.y1, newObject.y2, newObject.x2, newObject.x1] = [sidesObject.x1, sidesObject.x2, sidesObject.y1, sidesObject.y2];
    if ("a" in sidesObject && "b" in sidesObject && "c" in sidesObject && "d" in sidesObject) {
      [newObject.a, newObject.b, newObject.c, newObject.d] = [sidesObject.d, sidesObject.a, sidesObject.b, sidesObject.c];
    }
  }
  return newObject;
}
const _sfc_main$7 = {
  name: "StockNavigation",
  props: {
    stockList: {
      type: Array,
      default: () => []
    },
    primaryColor: {
      type: String,
      default: ""
    },
    secondaryColor: {
      type: String,
      default: ""
    },
    activeStockId: {
      type: String,
      default: null
    }
  },
  emits: ["show-stock"],
  methods: {
    showStock(stockID) {
      this.$emit("show-stock", stockID);
    }
  }
};
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$3 = { id: "mini-stock-nav" };
const _hoisted_2$2 = ["onMousedown"];
const _hoisted_3$2 = { class: "id" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.stockList, (stock, index) => {
      return openBlock(), createElementBlock("button", {
        key: index,
        class: normalizeClass(["nav-button", { selected: stock.id === $props.activeStockId }]),
        type: "button",
        style: normalizeStyle({
          backgroundColor: stock.id === $props.activeStockId ? "#" + $props.secondaryColor : "#" + $props.primaryColor
        }),
        onMousedown: ($event) => $options.showStock(stock.id)
      }, [
        createBaseVNode("div", _hoisted_3$2, toDisplayString$1(index + 1), 1),
        withDirectives(createBaseVNode("div", { class: "stack legibility" }, toDisplayString$1(stock.stack), 513), [
          [vShow, typeof stock.stack === "number" && stock.stack > 1]
        ])
      ], 46, _hoisted_2$2);
    }), 128))
  ]);
}
const StockNavigation = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = {
  name: "Spinner",
  props: {
    size: {
      type: Number,
      default: 100
    },
    showNumber: {
      type: Boolean,
      default: true
    },
    number: {
      type: Number,
      default: 0
    },
    complete: {
      type: Boolean,
      default: false
    }
  }
};
const _hoisted_1$2 = { id: "spinner" };
const _hoisted_2$1 = ["width", "height"];
const _hoisted_3$1 = {
  key: 2,
  id: "spinner-number",
  class: "stock-number"
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    !$props.complete ? (openBlock(), createElementBlock("svg", {
      key: 0,
      class: "loading",
      style: normalizeStyle({ width: $props.size + "px", height: $props.size + "px" }),
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 300 300"
    }, _cache[0] || (_cache[0] = [
      createStaticVNode('<rect class="square s1" x="0" y="0"></rect><rect class="square s2" x="100" y="0"></rect><rect class="square s3" x="200" y="0"></rect><rect class="square s4" x="0" y="100"></rect><rect class="square s5" x="200" y="100"></rect><rect class="square s6" x="0" y="200"></rect><rect class="square s7" x="100" y="200"></rect>', 7)
    ]), 12, _hoisted_2$1)) : createCommentVNode("", true),
    $props.complete ? (openBlock(), createElementBlock("svg", {
      key: 1,
      class: "complete",
      style: normalizeStyle({ width: $props.size + "px", height: $props.size + "px" }),
      viewBox: "0 0 448 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[1] || (_cache[1] = [
      createBaseVNode("path", { d: "m203.3 331.3c-6.2 6.3-16.4 6.3-22.6 0l-64-64c-6.3-6.2-6.3-16.4 0-22.6 6.2-6.3 16.4-6.3 22.6 0l52.7 52.7 116.7-116.7c6.2-6.3 16.4-6.3 22.6 0 6.3 6.2 6.3 16.4 0 22.6zm-203.3-235.3c0-35.35 28.65-64 64-64h320c35.3 0 64 28.65 64 64v320c0 35.3-28.7 64-64 64h-320c-35.35 0-64-28.7-64-64zm32 0v320c0 17.7 14.33 32 32 32h320c17.7 0 32-14.3 32-32v-320c0-17.67-14.3-32-32-32h-320c-17.67 0-32 14.33-32 32z" }, null, -1)
    ]), 4)) : createCommentVNode("", true),
    $props.showNumber ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString$1($props.number), 1)) : createCommentVNode("", true)
  ]);
}
const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
function getInputMode(type3, units) {
  if (type3 === "unitDependent") {
    return units === "decimal" ? "decimal" : "text";
  }
  if (type3 === "float") return "decimal";
  if (type3 === "integer") return "numeric";
  return "text";
}
function getInputType(type3, units) {
  if (type3 === "unitDependent") {
    return units === "decimal" ? "number" : "text";
  }
  if (type3 === "checkbox") return "checkbox";
  if (type3 === "float") return "number";
  if (type3 === "integer") return "number";
  return "text";
}
function getOutputType(type3, outputType = null, units = "decimal") {
  switch (type3) {
    case "float":
    case "integer":
    case "string":
      return type3;
    case "unitDependent":
      return units === "decimal" ? "float" : "string";
    case "checkbox":
      if (outputType) return outputType;
      return "boolean";
    case "select":
      if (outputType) return outputType;
      return "string";
    default:
      return "string";
  }
}
function parseBoolean(val) {
  if (val) return true;
  return false;
}
function getMinValue(fieldDef) {
  if (typeof fieldDef.min === "undefined") return null;
  if (typeof fieldDef.min === "function") return fieldDef.min();
  if (typeof fieldDef.min === "number") return fieldDef.min;
  return null;
}
function getMaxValue(fieldDef) {
  if (typeof fieldDef.max === "undefined") return null;
  if (typeof fieldDef.max === "function") return fieldDef.max();
  if (typeof fieldDef.max === "number") return fieldDef.max;
  return null;
}
function getNestedValue(obj, path2) {
  if (!path2) return null;
  const keys = path2.split(".");
  return keys.reduce((acc, key) => acc && acc[key] !== "undefined" ? acc[key] : void 0, obj);
}
function setNestedValue(obj, path2, value2, force = true) {
  const keys = path2.split(".");
  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    if (!current[keys[i]]) {
      current[keys[i]] = {};
    }
    current = current[keys[i]];
  }
  if (force || !valueSet(current[keys[keys.length - 1]])) {
    current[keys[keys.length - 1]] = value2;
  }
}
function setFieldEnabled(allFields, group, type3, fieldId, enabled = true) {
  var _a2;
  if (!((_a2 = allFields == null ? void 0 : allFields[group]) == null ? void 0 : _a2[type3])) return;
  const field = allFields[group][type3].find((f) => f.id === fieldId);
  if (!field) return;
  if (enabled) {
    field.enabled = true;
  } else {
    field.enabled = false;
  }
}
function isFieldEnabled(allFields, group, type3, fieldId) {
  var _a2;
  if (!((_a2 = allFields == null ? void 0 : allFields[group]) == null ? void 0 : _a2[type3])) return false;
  const field = allFields[group][type3].find((f) => f.id === fieldId);
  if (!field) return false;
  return field.enabled;
}
function isFieldPresent(allFields, group, type3, fieldId) {
  var _a2;
  if (!((_a2 = allFields == null ? void 0 : allFields[group]) == null ? void 0 : _a2[type3])) return false;
  return allFields[group][type3].findIndex((f) => f.id === fieldId) > -1;
}
function getEnabledFields(allFields, group, type3) {
  var _a2;
  if (!((_a2 = allFields == null ? void 0 : allFields[group]) == null ? void 0 : _a2[type3])) return [];
  return allFields[group][type3].filter((f) => f.enabled === true).map((f) => f.id);
}
function getRelevantFieldDefinitions(allFields, fieldDefinitions, group, type3, order = []) {
  const enabledFields = getEnabledFields(allFields, group, type3);
  if (!enabledFields.length) return [];
  const relevantFieldDefinitions = fieldDefinitions.filter((def2) => enabledFields.includes(def2.id) || def2.custom === true);
  if (enabledFields.length !== relevantFieldDefinitions.filter((f) => (f == null ? void 0 : f.fieldMap) && !f.fieldMap.startsWith("customData.")).length) {
    console.warn("Not all enabled fields are present in the field definitions");
  }
  if (!order.length) return relevantFieldDefinitions;
  relevantFieldDefinitions.sort((a2, b) => {
    const indexA = order.indexOf(a2.id);
    const indexB = order.indexOf(b.id);
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
  return relevantFieldDefinitions;
}
const _sfc_main$5 = {
  name: "OrientationButton",
  props: {
    //obsidian://open?vault=SmartCut%20documentation&file=Orientation%20philosophy
    orientationModel: {
      type: Number,
      default: 0
    },
    //allows use without passing a rectangle
    rectangleType: {
      type: String,
      default: null
    },
    rectangle: {
      type: Object,
      default: () => {
        return null;
      }
    },
    //if a shape object is not available, use shapeOrientation
    shapeOrientation: {
      type: String,
      default: ""
    },
    stockGrain: {
      type: String,
      default: "n"
    },
    buttonBackground: {
      type: String,
      default: "#848484"
    },
    iconColor: {
      type: String,
      default: "#FFFFFF"
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["updateOrientation"],
  computed: {
    orientationOptions() {
      if (!this.rectangle) return ["l", "w"];
      if (isInputUserGroup(this.rectangle)) return ["l", "w"];
      let orientationOptions = ["", "l", "w"];
      if (this.rectangle.multiEdit) orientationOptions = [" ", "", "l", "w"];
      if (isInputStock(this.rectangle)) return orientationOptions;
      if (this.orientationModel === 1) {
        if (this.stockGrain !== "n") {
          return orientationOptions = ["", "l", "w"];
        }
        return orientationOptions = [""];
      }
      if (this.orientationModel === 2) {
        if (this.stockGrain !== "n") {
          return orientationOptions = ["", "l"];
        }
        return orientationOptions = [""];
      }
      return orientationOptions;
    },
    isSquare() {
      var _a2;
      if (typeof ((_a2 = this.rectangle) == null ? void 0 : _a2.isSquare) === "function") {
        return this.rectangle.isSquare();
      }
      return false;
    },
    iconType() {
      var _a2;
      if (isInputStock(this.rectangle) || this.rectangleType === "stock") {
        if (!this.rectangle) return "noGrain";
      } else {
        if (!this.rectangle && !this.shapeOrientation)
          return "freeRotation";
      }
      if (isInputStock(this.rectangle) || this.rectangleType === "stock") {
        switch ((_a2 = this.rectangle) == null ? void 0 : _a2.grain) {
          case " ":
            return "delete";
          case "l":
            return "grainLeftRight";
          case "w":
            return "grainTopBottom";
          default:
            return "noGrain";
        }
      } else {
        return this.getIconType();
      }
    },
    shouldRotate() {
      return shouldRotateDiagram(
        this.orientationModel,
        this.stockGrain,
        this.rectangle,
        this.rectangleType,
        this.shapeOrientation
      );
    }
  },
  mounted() {
    this.$el.addEventListener("keydown", this.handleKeyDown);
  },
  unmounted() {
    this.$el.removeEventListener("keydown", this.handleKeyDown);
  },
  methods: {
    getIconType() {
      var _a2, _b, _c;
      const iconTypeMap = {
        n: {
          " ": "delete",
          l: "leftRight",
          w: "leftRight",
          default: "freeRotation"
        },
        y: {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom",
          default: "freeRotation"
        },
        l: {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom",
          default: "freeRotation"
        },
        w: {
          " ": "delete",
          l: "grainLeftRight",
          w: "grainTopBottom",
          default: "freeRotation"
        },
        default: {
          " ": "delete",
          l: "leftRight",
          w: "topBottom",
          default: "freeRotation"
        }
      };
      const grain = this.stockGrain || "default";
      let iconKey = "default";
      if (isInputShape(this.rectangle)) {
        switch (this.orientationModel) {
          case 0:
            if (!((_a2 = this.rectangle) == null ? void 0 : _a2.orientationLock)) {
              iconKey = "default";
              break;
            }
            if (this.stockGrain === "n") {
              iconKey = ((_b = this.rectangle) == null ? void 0 : _b.orientationLock) || this.shapeOrientation || "default";
              break;
            }
            switch (this.stockGrain) {
              case "w":
                iconKey = this.rectangle.orientationLock === "w" ? "w" : "l";
                break;
              case "l":
              case "y":
                iconKey = this.rectangle.orientationLock === "l" ? "l" : "w";
                break;
            }
            break;
          case 1:
            if (this.stockGrain === "n" || !this.rectangle.orientationLock) {
              iconKey = "default";
              break;
            }
            switch (this.stockGrain) {
              case "l":
              case "y":
              case "w":
                if (this.shouldRotate) {
                  iconKey = this.rectangle.orientationLock === "l" ? "w" : "l";
                  break;
                }
                iconKey = this.rectangle.orientationLock === "l" ? "l" : "w";
                break;
              default:
                iconKey = "default";
                break;
            }
            break;
          case 2: {
            if (this.stockGrain === "n") {
              iconKey = "default";
              break;
            }
            switch (this.rectangle.orientationLock) {
              case "l":
                iconKey = this.shouldRotate ? "w" : "l";
                break;
              default:
                iconKey = "default";
                break;
            }
            break;
          }
        }
      } else if (isInputUserGroup(this.rectangle)) {
        iconKey = this.rectangle.direction || "default";
      } else if (this.rectangleType === "shape" && this.stockGrain !== "n") {
        switch (this.shapeOrientation) {
          case "l":
            switch (this.stockGrain) {
              case "y":
              case "l":
                iconKey = "l";
                break;
              case "w":
                iconKey = "w";
                break;
              default:
                iconKey = "l";
                break;
            }
            break;
          case "w":
            switch (this.stockGrain) {
              case "y":
              case "l":
                iconKey = "w";
                break;
              case "w":
                iconKey = "l";
                break;
              default:
                iconKey = "l";
                break;
            }
            break;
          default:
            iconKey = "default";
            break;
        }
      }
      const icon2 = ((_c = iconTypeMap[grain]) == null ? void 0 : _c[iconKey]) || iconTypeMap[grain].default;
      return icon2;
    },
    click() {
      if (this.orientationOptions.length <= 1) return;
      let currentOrientation = "";
      if (isInputUserGroup(this.rectangle)) {
        currentOrientation = this.rectangle.direction;
      } else if (isInputShape(this.rectangle)) {
        currentOrientation = this.rectangle.orientationLock;
      } else if (isInputStock(this.rectangle)) {
        currentOrientation = this.rectangle.grain;
      }
      let index = this.orientationOptions.findIndex((o2) => o2 === currentOrientation);
      index++;
      if (index > this.orientationOptions.length - 1) index = 0;
      this.$emit("updateOrientation", this.orientationOptions[index]);
    },
    handleKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        this.click();
      }
    }
  }
};
const _hoisted_1$1 = {
  key: 0,
  class: "delete",
  viewBox: "0 0 512 512",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["orientation-button", { rot: $options.shouldRotate, square: $options.isSquare, disabled: $props.disabled, [$options.iconType]: true }]),
    tabindex: "0",
    "aria-label": "Part orientation",
    style: normalizeStyle({
      backgroundColor: $props.buttonBackground
    }),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.click && $options.click(...args))
  }, [
    $options.iconType === "delete" ? (openBlock(), createElementBlock("svg", _hoisted_1$1, _cache[1] || (_cache[1] = [
      createBaseVNode("path", { d: "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z" }, null, -1)
    ]))) : createCommentVNode("", true),
    $options.iconType === "freeRotation" ? (openBlock(), createElementBlock("svg", {
      key: 1,
      class: "arrow",
      style: normalizeStyle({
        stroke: $props.iconColor ? $props.iconColor : "#ffffff"
      }),
      viewBox: "0 0 67 63",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[2] || (_cache[2] = [
      createBaseVNode("g", null, [
        createBaseVNode("path", { d: "m9.296 31.378c0-3.305.67-6.455 1.88-9.322 3.642-8.621 12.179-14.678 22.12-14.678 10.63 0 19.656 6.927 22.806 16.509" }),
        createBaseVNode("path", { d: "m57.296 31.378c0 13.246-10.754 24-24 24-10.631 0-19.656-6.926-22.806-16.508" }),
        createBaseVNode("path", { d: "m61.183 5.408-4.622 17.851-18.347-1.838" }),
        createBaseVNode("path", { d: "m5.408 57.349 4.622-17.851 18.348 1.838" })
      ], -1)
    ]), 4)) : createCommentVNode("", true),
    $options.iconType === "leftRight" ? (openBlock(), createElementBlock("svg", {
      key: 2,
      class: "arrow",
      style: normalizeStyle({
        stroke: $props.iconColor ? $props.iconColor : "#ffffff"
      }),
      viewBox: "0 0 72 39",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[3] || (_cache[3] = [
      createBaseVNode("g", null, [
        createBaseVNode("path", { d: "m5.408 19.408h61.095" }),
        createBaseVNode("g", null, [
          createBaseVNode("path", { d: "m52.695 5.408 13.808 14-13.808 14" }),
          createBaseVNode("path", { d: "m17.408 33.408-12-14 12-14" })
        ])
      ], -1)
    ]), 4)) : createCommentVNode("", true),
    $options.iconType === "topBottom" ? (openBlock(), createElementBlock("svg", {
      key: 3,
      class: "arrow",
      style: normalizeStyle({
        stroke: $props.iconColor ? $props.iconColor : "#ffffff"
      }),
      viewBox: "0 0 39 72",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[4] || (_cache[4] = [
      createBaseVNode("g", null, [
        createBaseVNode("path", { d: "m19.408 66.503v-61.095" }),
        createBaseVNode("g", null, [
          createBaseVNode("path", { d: "m5.408 19.216 14-13.808 14 13.808" }),
          createBaseVNode("path", { d: "m33.408 54.503-14 12-14-12" })
        ])
      ], -1)
    ]), 4)) : createCommentVNode("", true),
    $options.iconType === "grainLeftRight" ? (openBlock(), createElementBlock("svg", {
      key: 4,
      class: "grain",
      style: normalizeStyle({
        stroke: $props.iconColor ? $props.iconColor : "#ffffff"
      }),
      viewBox: "0 0 106 64",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[5] || (_cache[5] = [
      createBaseVNode("g", null, [
        createBaseVNode("path", { d: "m3 3h99.887" }),
        createBaseVNode("path", { d: "m3.113 32h99.887" }),
        createBaseVNode("path", { d: "m3.113 61h99.887" })
      ], -1)
    ]), 4)) : createCommentVNode("", true),
    $options.iconType === "grainTopBottom" ? (openBlock(), createElementBlock("svg", {
      key: 5,
      class: "grain",
      style: normalizeStyle({
        stroke: $props.iconColor ? $props.iconColor : "#ffffff"
      }),
      viewBox: "0 0 64 106",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[6] || (_cache[6] = [
      createBaseVNode("g", null, [
        createBaseVNode("path", { d: "m61 3v99.887" }),
        createBaseVNode("path", { d: "m32 3.113v99.887" }),
        createBaseVNode("path", { d: "m3 3.113v99.887" })
      ], -1)
    ]), 4)) : createCommentVNode("", true)
  ], 6);
}
const OrientationButton = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  name: "BandingButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    },
    open: {
      type: Boolean,
      default: false
    },
    //obsidian://open?vault=SmartCut%20documentation&file=Orientation%20philosophy
    orientationModel: {
      type: Number,
      default: 0
    },
    stockGrain: {
      type: String,
      default: "n"
    }
  },
  emits: ["clicked"],
  computed: {
    x1() {
      const allOptions = objectValuesPresent(this.inputShape.bandingOptions.x1) ? Object.values(this.inputShape.bandingOptions.x1).every((o2) => o2) : null;
      const banding = this.inputShape.banding.x1;
      return allOptions || banding;
    },
    x2() {
      const allOptions = objectValuesPresent(this.inputShape.bandingOptions.x2) ? Object.values(this.inputShape.bandingOptions.x2).every((o2) => o2) : null;
      const banding = this.inputShape.banding.x2;
      return allOptions || banding;
    },
    y1() {
      const allOptions = objectValuesPresent(this.inputShape.bandingOptions.y1) ? Object.values(this.inputShape.bandingOptions.y1).every((o2) => o2) : null;
      const banding = this.inputShape.banding.y1;
      return allOptions || banding;
    },
    y2() {
      const allOptions = objectValuesPresent(this.inputShape.bandingOptions.y2) ? Object.values(this.inputShape.bandingOptions.y2).every((o2) => o2) : null;
      const banding = this.inputShape.banding.y2;
      return allOptions || banding;
    },
    mappedBanding() {
      let bandingObject = {
        x1: this.x1,
        x2: this.x2,
        y1: this.y1,
        y2: this.y2
      };
      if (shouldRotateSides(this.orientationModel, this.stockGrain, this.inputShape)) {
        bandingObject = rotateSides(bandingObject);
      }
      return bandingObject;
    }
  },
  mounted() {
    this.$el.addEventListener("keydown", this.handleKeyDown);
  },
  unmounted() {
    this.$el.removeEventListener("keydown", this.handleKeyDown);
  },
  methods: {
    handleKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        this.click();
      }
    },
    click() {
      this.$emit("clicked");
    }
  }
  /* watch: {
  	'inputShape.bandingOptions': {
  		deep: true,
  		immediate: true,
  		handler( v )
  		{
  			console.table( v )
  		}
  	}
  }, */
});
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["banding-button", { open: _ctx.open }]),
    tabindex: "0",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.click && _ctx.click(...args))
  }, [
    createBaseVNode("div", {
      class: normalizeClass(["outer", { x1: _ctx.mappedBanding.x1, x2: _ctx.mappedBanding.x2, y1: _ctx.mappedBanding.y1, y2: _ctx.mappedBanding.y2 }])
    }, _cache[1] || (_cache[1] = [
      createBaseVNode("div", { class: "inner" }, null, -1)
    ]), 2)
  ], 2);
}
const BandingButton = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  name: "MachiningButton",
  props: {
    inputShape: {
      type: Object,
      default: null
    }
  },
  emits: ["open"],
  computed: {
    hasMachining() {
      return hasMachining(this.inputShape);
    },
    disabled() {
      var _a2;
      return ((_a2 = this.inputShape) == null ? void 0 : _a2.readonly) ? true : false;
    }
  },
  methods: {
    openMachining() {
      if (this.disabled) return;
      this.$emit("open");
    }
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  return openBlock(), createElementBlock("button", {
    class: normalizeClass(["machining-button", { disabled: _ctx.disabled, "has-machining": _ctx.hasMachining }]),
    type: "button",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openMachining && _ctx.openMachining(...args))
  }, [
    createVNode(_component_font_awesome_icon, { icon: ["fass", "hammer"] })
  ], 2);
}
const MachiningButton = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const Machining2 = /* @__PURE__ */ defineAsyncComponent(() => import("./Machining-BMtEtAnh.js"));
const ImportCSV = /* @__PURE__ */ defineAsyncComponent(() => import("./ImportCSV-Dw-a1pM6.js"));
const InputField = /* @__PURE__ */ defineAsyncComponent(() => import("./InputField-xEsDa5i1.js"));
const _sfc_main$2 = {
  name: "CheckoutCalculator",
  components: {
    StockNavigation,
    OrientationButton,
    Spinner,
    Machining: Machining2,
    BandingButton,
    MachiningButton,
    ImportCSV,
    InputField
    // Offcuts,
  },
  props: {
    debug: {
      type: Boolean,
      default: false
    },
    units: {
      type: String,
      default: "decimal"
    },
    //stock is passed as a prop, which allows it to be changed after init (e.g. variations in WP)
    stock: {
      type: Array,
      default: () => []
    }
  },
  emits: ["calculating", "result", "log", "error", "debug"],
  setup() {
    const { t: t2, locale: locale2, fallbackLocale } = useI18n({
      locale: "en_US"
    });
    return {
      t: t2,
      locale: locale2,
      fallbackLocale
    };
  },
  data() {
    const inputShapesRef = useLocalStorage(
      "Checkout/inputShapes",
      [],
      {
        serializer: {
          read: (v) => {
            const inputs = v ? JSON.parse(v) : [];
            return recreateInputShapes(inputs, this.units);
          },
          write: (v) => {
            return JSON.stringify(v);
          }
        },
        listenToStorageChanges: false
      }
    );
    return {
      domain: window.location.hostname,
      connected: false,
      maintenanceMode: false,
      creditVisible: true,
      currentURL: useLocalStorage(
        "Checkout/currentURL",
        window.location.href
      ),
      online: true,
      onlineTimer: null,
      allowOnlineMessages: true,
      socket: null,
      mounted: false,
      loaded: false,
      thinking: false,
      jobId: 0,
      //used for watchers to reset results
      height: null,
      successMetric: "areaEfficiency",
      enableEvo: false,
      saw: {
        bladeWidth: 1,
        cutPreference: "l",
        cutType: "guillotine",
        stockType: "sheet",
        stackHeight: 0
      },
      inputShapes: inputShapesRef.value,
      inputStock: [],
      stockList: shallowRef([]).value,
      shapeList: shallowRef([]).value,
      cutList: shallowRef([]).value,
      offcuts: shallowRef([]).value,
      inputs: shallowRef({}),
      //used to save inputs
      currentInputShape: null,
      activeStockId: null,
      selectedShapeId: null,
      metadata: null,
      //messages
      messageVisible: false,
      messageHeading: "",
      messageContent: "",
      vis: markRaw({}),
      visInit: false,
      isFullScreen: false,
      //special sections
      machiningEnabled: false,
      bandingEnabled: null,
      //index of the shape with banding dropdowns
      CSVImportEnabled: false,
      allFields: {
        parts: {
          sheet: [
            { id: "material", enabled: false },
            { id: "l", enabled: true },
            { id: "w", enabled: true },
            { id: "t", enabled: true },
            { id: "q", enabled: true },
            { id: "name", enabled: true },
            { id: "orientationLock", enabled: true },
            { id: "banding", enabled: true },
            { id: "machining", enabled: false }
          ],
          linear: [
            { id: "l", enabled: true },
            { id: "q", enabled: true },
            { id: "name", enabled: true }
          ]
        }
      },
      //default options
      options: {
        decimalPlaces: 2,
        stackHeight: 100,
        maxParts: null,
        disableBanding: false,
        disableOrientation: false,
        showDiagram: true,
        showProgressNumber: true,
        locale: "en_US",
        orientationModel: 0,
        customFields: [],
        enableFocus: true
      },
      //styles are declared here to prevent tampering
      creditStyles: {
        fontSize: "11px",
        textAlign: "right",
        width: "100%",
        height: "auto",
        position: "relative",
        display: "flex",
        visibility: "visible",
        opacity: "1",
        flexDirection: "row",
        flexWrap: "wrap",
        justifyContent: "flex-end",
        paddingRight: "10px",
        marginTop: "10px",
        marginBottom: "2px",
        userSelect: "none",
        alignItems: "center"
      },
      creditLinkStyles: {
        width: "auto",
        height: "auto",
        display: "inline-block",
        position: "relative",
        visibility: "visible",
        opacity: "1",
        color: "#4e4e4e"
      },
      materials: [],
      thicknesses: [],
      bondedThicknesses: [],
      bandingChoices: {},
      machiningOptions: {
        units: "decimal",
        sides: {
          enabled: true
        },
        holes: {
          enabled: false
        },
        corners: {
          enabled: false,
          types: []
        },
        banding: {
          enabled: false
        },
        hingeHoles: {
          enabled: false
        },
        shelfHoles: {
          enabled: false
        }
      },
      canGoFullScreen: isElementFullScreenSupported(),
      progress: {
        queue: 0,
        stockCount: 0,
        shapeCount: 0,
        complete: false
      },
      //colors must be in hex format (e.g. not 'green' but '#00ff00')
      colors: {
        partA: "#118ab2",
        //also used for id - needs to be set
        partB: null,
        partHover: null,
        partSelected: null,
        stock: "#ffd166",
        //also used for stock-number
        button: "#118ab2",
        buttonText: "#ffffff",
        text: "#ffffff"
      },
      visOptions: {
        disableClick: false,
        enableStretch: true
      },
      viewportWidth: null,
      w: 0,
      h: 0,
      userFriendlyFieldMap,
      customFieldDefinitions: [],
      user: null
    };
  },
  computed: {
    fieldDefinitions() {
      var _a2;
      const fieldDefinitions = [
        {
          id: "material",
          fieldMap: "material",
          label: this.t("material"),
          w: "minmax(20px, max-content)",
          type: "select",
          output: "string",
          default: (_a2 = this.materials[0]) == null ? void 0 : _a2.name,
          options: this.materials.map((m) => {
            return {
              value: m.name,
              label: m.name
            };
          })
        },
        {
          //options are set on the InputField directly as related to individual shape material
          id: "t",
          fieldMap: "t",
          w: "minmax(20px, max-content)",
          type: "select",
          output: this.units === "decimal" ? "float" : "string",
          label: this.t("thickness")
        },
        {
          id: "l",
          fieldMap: "l",
          type: "unitDependent",
          label: this.t("length"),
          min: 0
        },
        {
          id: "w",
          fieldMap: "w",
          type: "unitDependent",
          label: this.t("width"),
          min: 0
        },
        {
          id: "q",
          fieldMap: "q",
          type: "integer",
          default: 1,
          label: this.t("quantity"),
          min: 0
        },
        {
          id: "name",
          fieldMap: "name",
          type: "string",
          label: this.t("name")
        },
        {
          id: "orientationLock",
          w: "32px",
          label: this.t("orientation"),
          fieldMap: "orientationLock"
        },
        {
          id: "banding",
          w: "32px",
          label: this.t("banding"),
          fieldMap: "bandingOptions"
        },
        {
          id: "machining",
          w: "28px",
          label: this.t("machining"),
          fieldMap: "machining"
        }
      ];
      const definitions = [
        ...fieldDefinitions,
        ...this.customFieldDefinitions
      ];
      return definitions;
    },
    relevantFieldDefinitions() {
      return getRelevantFieldDefinitions(this.allFields, this.fieldDefinitions, "parts", this.saw.stockType, this.options.fieldOrder);
    },
    selectedShape() {
      if (!this.selectedShapeId) {
        return null;
      } else {
        return this.inputShapes.find((shape) => shape.id === this.selectedShapeId);
      }
    },
    inputType() {
      return this.units === "decimal" ? "number" : "string";
    },
    inputMode() {
      return this.units === "decimal" ? "decimal" : "text";
    },
    partColumns() {
      let number2 = this.relevantFieldDefinitions.length;
      if (this.inputShapes.length > 1) number2++;
      return number2;
    },
    partColumnsStyle() {
      const widthValues = {
        id: "34px",
        del: "30px"
      };
      const widths = [];
      for (let i = 0; i < this.relevantFieldDefinitions.length; i++) {
        const field = this.relevantFieldDefinitions[i];
        if (field.id === "trim") continue;
        widths.push(field.w ?? "minmax(20px, 1fr)");
      }
      widths.unshift(widthValues.id);
      if (this.inputShapes.length > 1) widths.push(widthValues.del);
      const style = widths.join(" ");
      return style;
    },
    bandingColumnsStyle() {
      if (!this.bandingChoices) return "auto";
      const numOptions = Object.keys(this.bandingChoices).length;
      if (!numOptions) return "auto";
      const cols = numOptions + 2;
      return `repeat(${cols - 1}, minmax(20px, max-content)) 1fr`;
    },
    addedShapes() {
      return this.shapeList.filter((shape) => shape.added);
    },
    uniqueShapes() {
      return this.shapeList.filter((shape) => shape.added && !shape.duplicate);
    },
    numUniqueShapes() {
      return this.uniqueShapes.length;
    },
    uniqueAddedShapes() {
      return this.uniqueShapes.filter((s) => s.added);
    },
    uniqueStock() {
      return this.stockList.filter((stock) => stock.used && !stock.duplicate);
    },
    uniqueUsedStock() {
      return this.uniqueStock.filter((s) => s.used).map((s) => {
        s.q = this.uniqueStock.filter((u) => u.parentID === s.parentID).reduce(
          (total, s2) => total + (s2 == null ? void 0 : s2.stack) > 0 ? s2.stack : 1,
          0
        );
        return s;
      });
    },
    usedStock() {
      return getUsedStock(this.stockList);
    },
    activeStock() {
      if (!this.activeStockId) return null;
      return getActiveStock(this.stockList, this.activeStockId);
    },
    activeStockArea() {
      return this.activeStock.getArea();
    },
    stackedStock() {
      return getStackedStock(this.stockList);
    },
    activeShapes() {
      return this.shapeList.filter((shape) => {
        var _a2, _b;
        return shape.added && ((_a2 = shape == null ? void 0 : shape.stock) == null ? void 0 : _a2.id) === ((_b = this.activeStock) == null ? void 0 : _b.id);
      });
    },
    activeCuts() {
      return getActiveCuts(this.cutList, this.activeStock);
    },
    unplacedShapes() {
      return unplacedShapeTally(this.shapeList);
    },
    totalCutLength() {
      if (!this.cutList.length || !this.metadata.totalCutLength) return 0;
      return this.metadata.totalCutLength;
    },
    totalInputShapes() {
      return this.inputShapes.reduce((total, s) => total + s.q, 0);
    },
    materialNames() {
      return this.materials.map((m) => m.name);
    }
  },
  watch: {
    online(val) {
      online.call(this, val);
    },
    jobId(val) {
      if (!val) return;
      if (this.visInit) this.updateVisSize();
      if (!this.metadata) {
        this.$emit(
          "error",
          "SmartCut - no metadata received from server"
        );
      }
      this.updatePartQuantitiesBasedOnThickness();
      const result = {
        jobId: this.jobId,
        metadata: this.metadata,
        parts: this.uniqueAddedShapes.map((p2) => {
          var _a2, _b;
          return {
            l: p2.l,
            w: p2.w,
            t: p2 == null ? void 0 : p2.t,
            material: p2.material,
            orientationLock: p2.orientationLock,
            q: (_b = (_a2 = this == null ? void 0 : this.metadata) == null ? void 0 : _a2.addedPartTally) == null ? void 0 : _b[p2.parentID],
            name: p2.name,
            banding: p2.banding,
            bandingType: p2.bandingType,
            customData: p2.customData
          };
        }),
        stock: this.uniqueUsedStock.map((s) => {
          var _a2, _b;
          return {
            name: s == null ? void 0 : s.name,
            l: s.l,
            w: s.w,
            t: s == null ? void 0 : s.t,
            material: s.material,
            q: (_b = (_a2 = this == null ? void 0 : this.metadata) == null ? void 0 : _a2.usedStockTally) == null ? void 0 : _b[s.parentID],
            trim: s == null ? void 0 : s.trim,
            cost: s == null ? void 0 : s.cost,
            analysis: s == null ? void 0 : s.analysis
          };
        }),
        offcuts: this.offcuts.map((s) => {
          return {
            l: s.l,
            w: s.w,
            t: (s == null ? void 0 : s.t) ?? null,
            q: s.q
          };
        }),
        inputs: {
          parts: this.inputs.shapeList.map((s) => {
            delete s.listId;
            return s;
          })
        }
      };
      if (this.unplacedShapes.length) {
        const parts2 = this.unplacedShapes.map((s) => s.id).join();
        this.showMessage(this.$t("The following parts did not fit") + ": " + parts2);
      }
      this.$emit("result", result);
    },
    viewportWidth() {
      if (this.visInit) this.updateVisSize();
    },
    activeStockId() {
      if (this.visInit) this.$nextTick(() => this.refresh());
    },
    //stock changes when a thickness is selected in WC, or when the page loads and a thickness is pre-selected
    stock(stock) {
      if (!Array.isArray(stock))
        console.warn("SmartCut - stock must be passed as an array");
      if (!stock || !stock.length) {
        console.warn("SmartCut - stock updated but nothing found");
        return;
      }
      this.inputStock = [];
      if (!this.materials.length) {
        this.getThicknessesFromStock(stock);
      }
      for (const st of stock) {
        st.type = this.saw.stockType;
        const stock2 = this.createStockInput(st);
        this.inputStock.push(stock2);
      }
      if (this.inputStock.length) {
        if (!this.inputShapes.length) {
          this.addInputShape(1);
        } else {
          this.inputShapes.forEach((s) => s.t = this.inputStock[0].t);
        }
      }
    },
    inputShapes: {
      handler(inputShapes) {
        inputShapes.forEach((s) => {
          const materialOption = this.materials.find((m) => m.name === s.material);
          if (materialOption) {
            if (!materialOption.thicknesses.includes(s.t)) {
              s.t = materialOption.thicknesses[0];
            }
          }
        });
      },
      deep: true
    }
  },
  mounted() {
    if (this.mounted) return;
    const url2 = new URL(window.location.href);
    const queryParams = url2.searchParams.toString();
    const newURL = url2.origin + url2.pathname + (queryParams ? `?${queryParams}` : "");
    if (this.currentURL !== newURL) {
      this.inputShapes.length = 0;
    }
    this.currentURL = newURL;
    this.locale = this.options.locale;
    {
      initSocket.call(this, "https://api.cutlistevo.com/");
    }
    this.socket.connect();
    this.socket.emit("getUserFromDomain");
    this.viewportWidth = window.innerWidth;
    this.resizeTimer = null;
    const debouncedHandleResize = this.debounce(this.handleResize, 30);
    window.addEventListener("resize", debouncedHandleResize, {
      passive: true
    });
    window.addEventListener("smartcut/load", (e) => {
      this.parseInputs(e.detail);
    });
    this.mounted = true;
    if (this.debug) {
      this.$emit("log", ["SmartCut - ready...", "fields:", this.relevantFieldDefinitions.map((f) => f.id)]);
    }
  },
  methods: {
    parseInputs(detail) {
      this.$nextTick(() => {
        var _a2, _b;
        if (!detail || !((_b = (_a2 = detail == null ? void 0 : detail.inputs) == null ? void 0 : _a2.parts) == null ? void 0 : _b.length)) return;
        detail.inputs.parts.forEach((p2) => {
          this.inputShapes = [];
          const inputShape = new InputShape(p2);
          if (inputShape) {
            this.inputShapes.push(inputShape);
          }
        });
      });
    },
    getEnabledFields(group) {
      return getEnabledFields(this.allFields, group, this.saw.stockType);
    },
    setFieldEnabled(fieldId, enabled = true) {
      setFieldEnabled(this.allFields, "parts", this.saw.stockType, fieldId, enabled);
    },
    importParts(inputData) {
      this.inputShapes.length = 0;
      this.$nextTick(() => {
        inputData.forEach((d) => {
          var _a2, _b;
          d.t = ((_b = (_a2 = this.inputStock) == null ? void 0 : _a2[0]) == null ? void 0 : _b.t) ?? null;
          this.inputShapes.push(this.createShapeInput(d));
        });
      });
    },
    isCreditVisible() {
      var _a2, _b;
      if ((_b = (_a2 = this.user) == null ? void 0 : _a2.api) == null ? void 0 : _b.whiteLabel) return true;
      let visible = true;
      const wrapper = document.querySelector("#smartcut-app #credit");
      const link = document.querySelector("#smartcut-app #credit a");
      [wrapper, link].forEach((el, index) => {
        if (!el) return visible = false;
        const style = window.getComputedStyle(el);
        if (style.display === "none") return visible = false;
        if (style.display === "hidden") return visible = false;
        if (style.opacity === "0") return visible = false;
        if (style.color === "transparent") return visible = false;
        if (style.position !== "relative") return visible = false;
        if (index === 1) {
          if (style.color !== "#4e4e4e" && style.color !== "rgb(78, 78, 78)")
            return visible = false;
        }
      });
      this.creditVisible = visible;
      return visible;
    },
    getNestedValue(obj, path2) {
      return getNestedValue(obj, path2);
    },
    setNestedValue(obj, path2, value2, force = true) {
      setNestedValue(obj, path2, value2, force);
    },
    toggleFullScreen() {
      if (this.isFullScreen) this.closeFullScreen();
      else this.openFullScreen();
    },
    openFullScreen() {
      document.getElementById("smartcut-checkout").requestFullscreen();
      this.isFullScreen = true;
    },
    closeFullScreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
      this.isFullScreen = false;
    },
    openMachining(shape = null) {
      this.currentInputShape = shape;
      if (shape && shape.l && shape.w) {
        this.machiningEnabled = true;
      } else {
        alert("Please enter dimensions first");
      }
    },
    openBanding(shape = null) {
      if (this.currentInputShape === shape) {
        this.currentInputShape = null;
        this.bandingEnabled = null;
      } else {
        this.currentInputShape = shape;
        this.bandingEnabled = this.inputShapes.indexOf(shape);
      }
    },
    closeMachining() {
      this.machiningEnabled = false;
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    },
    hasMachining(shape = null) {
      if (!shape) return false;
      return hasMachining(shape);
    },
    resetProgress() {
      resetProgress(this.progress);
    },
    reset() {
      resetProgress(this.progress);
      this.stockList = [];
      this.shapeList = [];
      this.cutList = [];
      this.jobId = 0;
    },
    async updateVisSize(immediate = false) {
      if (!this.vis) return false;
      await this.vis.updateSize(immediate);
      this.clearSelection();
    },
    clear() {
      this.inputShapes.length = 0;
      this.addInputShape(1);
    },
    addBondedThicknesses(bonded, material) {
      console.log("bonded", bonded);
      if (!Array.isArray(bonded)) {
        this.$emit("error", "addBondedThicknesses expects an array");
        return;
      }
      const bondexIndexes = [];
      for (let i = 0; i < bonded.length; i++) {
        let bondedThickness = bonded[i];
        if (this.units === "decimal") {
          bondedThickness = parseFloat(bondedThickness);
        }
        this.thicknesses.push(bondedThickness);
        if (material) {
          material.thicknesses.push(bondedThickness);
        }
        bondexIndexes.push(this.thicknesses.length - 1);
      }
      this.bondedThicknesses.push(bondexIndexes);
      console.log("thicknesses", this.thicknesses);
      console.log("bondedThicknesses", this.bondedThicknesses);
    },
    init(initData) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      if (this.debug) {
        this.$emit("log", ["SmartCut - init...", initData]);
      }
      if (initData == null ? void 0 : initData.type) delete initData.type;
      if (initData == null ? void 0 : initData.options) {
        const options = initData.options;
        const requiredOptions = [
          "stockType",
          "cutPreference",
          "bladeWidth"
        ];
        requiredOptions.forEach((o2) => {
          if (!(o2 in options))
            this.$emit("error", `${o2} is a required option`);
        });
        const nextSteps = {
          stockType: () => {
            const validOptions = ["sheet", "linear"];
            if (!validOptions.includes(options.stockType)) {
              console.warn(`${options.stockType} is not a valid stockType, expected ${validOptions.join("|")}`);
            }
            this.saw.stockType = options.stockType;
          },
          cutPreference: () => {
            const allowedCutPreferences = [
              "efficiency",
              "length",
              "width",
              "beam"
            ];
            if (allowedCutPreferences.includes(options.cutPreference)) {
              const { cutType, cutPreference } = mapLegacyCutPreference(options.cutPreference);
              this.saw.cutType = cutType;
              this.saw.cutPreference = cutPreference;
              this.saw.stackHeight = options.stackHeight;
              if (options.stockType === "linear") {
                this.saw.cutType = null;
                this.saw.cutPreference = null;
              }
              if (options.cutPreference === "beam") {
                this.saw.stackHeight = options.stackHeight;
              }
            } else {
              console.warn(`SmartCut - ${options.cutPreference} is not one of ${allowedCutPreferences.join("|")}`);
            }
          },
          bladeWidth: () => {
            if (options.bladeWidth >= 0) {
              this.saw.bladeWidth = options.bladeWidth;
            } else {
              console.warn(`SmartCut - you provided an incorrect blade width of: ${options.bladeWidth}`);
            }
          },
          disableClick: () => {
            this.visOptions.disableClick = options.disableClick;
          },
          colors: () => {
            for (const [key, value2] of Object.entries(options == null ? void 0 : options.colors)) {
              if (value2) this.colors[key] = value2;
            }
          },
          maxParts: () => {
            this.options.maxParts = options.maxParts;
          },
          disableOrientation: () => {
            this.setFieldEnabled(
              "orientationLock",
              !options.disableOrientation
            );
          },
          disablePartName: () => {
            this.setFieldEnabled(
              "name",
              !options.disablePartName
            );
          },
          enableCSVImport: () => {
            this.CSVImportEnabled = options.enableCSVImport;
          },
          locale: () => {
            this.locale = options.locale;
          },
          disableBanding: () => {
            this.setFieldEnabled("banding", false);
          },
          enableMachining: () => {
            this.setFieldEnabled(
              "machining",
              options.enableMachining ?? false
            );
          },
          customFields: () => {
            var _a3;
            if (!Array.isArray(options.customFields) || !((_a3 = options.customFields) == null ? void 0 : _a3.length)) return;
            const customFieldDefinitions = [];
            options.customFields.forEach((cf, index) => {
              customFieldDefinitions.push(cf);
              customFieldDefinitions[index].custom = true;
              const id = this.getCustomFieldId(cf.id);
              customFieldDefinitions[index].id = id;
              customFieldDefinitions[index].fieldMap = "customData." + id;
              if (cf.type === "checkbox") {
                customFieldDefinitions[index].w = "32px";
              }
              if (cf.type === "select") {
                customFieldDefinitions[index].output = cf.output ?? "string";
                customFieldDefinitions[index].options = cf.options;
              }
            });
            this.customFieldDefinitions = customFieldDefinitions;
            this.inputShapes.forEach((s) => {
              s.customData = options.customFields.reduce((acc, cf) => {
                const id = this.getCustomFieldId(cf.id);
                acc[id] = s.customData[id] || cf.default || "";
                return acc;
              }, {});
            });
          }
        };
        for (const option in initData == null ? void 0 : initData.options) {
          this.options[option] = initData.options[option];
          if (option in nextSteps) nextSteps[option]();
        }
      }
      if (!((_a2 = this == null ? void 0 : this.options) == null ? void 0 : _a2.disableBanding)) {
        [initData == null ? void 0 : initData.banding, initData == null ? void 0 : initData.bandingPricing].forEach((data) => {
          if (!data) return;
          if (typeof data !== "object") this.$emit("error", "banding and bandingPricing data must be an object");
        });
        if (initData == null ? void 0 : initData.banding) {
          for (const key in initData.banding) {
            const value2 = initData.banding[key];
            if (!Array.isArray(value2)) {
              this.$emit("error", "banding values must be an array");
            }
          }
          const bandingKeys = Object.keys(initData.banding);
          const commaRegex = /,/;
          for (let i = 0; i < length; i++) {
            if (commaRegex.test(bandingKeys[i])) {
              this.$emit("error", "banding keys must not contain commas");
            }
          }
        }
        if (initData == null ? void 0 : initData.bandingPricing) {
          for (const key in initData.bandingPricing) {
            const value2 = initData.bandingPricing[key];
            if (isNaN(value2)) {
              this.$emit("error", "bandingPricing values must be a number");
            }
          }
          const pricingKeys = Object.keys(initData.bandingPricing);
          const commaRegex = /,/;
          for (let i = 0; i < length; i++) {
            if (commaRegex.test(pricingKeys[i])) {
              this.$emit("error", "bandingPricing keys must not contain commas");
            }
          }
        }
        this.bandingChoices = initData.banding;
        const productBandingKeys = Object.keys(this.bandingChoices);
        const allBandingOptions = Object.values(this.bandingChoices).flat();
        this.inputShapes.forEach((inputShape) => {
          inputShape.removeBandingApartFromBandingOptions();
          if (inputShape.bandingOptions) {
            for (const sideKey in inputShape.bandingOptions) {
              const sideBandingKeys = Object.keys(inputShape.bandingOptions[sideKey]);
              sideBandingKeys.forEach((bandingKey) => {
                if (!productBandingKeys.includes(bandingKey)) {
                  delete inputShape.bandingOptions[sideKey][bandingKey];
                }
              });
              productBandingKeys.forEach((name) => {
                var _a3, _b2;
                if (!allBandingOptions.length) {
                  const allBandingChoices = Object.keys(this.bandingChoices);
                  if (!allBandingChoices.includes(name)) {
                    delete inputShape.bandingOptions[sideKey][name];
                  }
                  return;
                }
                if (!allBandingOptions.includes((_b2 = (_a3 = inputShape.bandingOptions) == null ? void 0 : _a3[sideKey]) == null ? void 0 : _b2[name])) {
                  inputShape.bandingOptions[sideKey][name] = "";
                }
              });
            }
          }
        });
        this.inputShapes.forEach((inputShape) => {
          inputShape.removeBandingApartFromBandingOptions();
        });
        if (this.bandingChoices && Object.values(this.bandingChoices).length > 0) {
          this.setFieldEnabled("banding", true);
        } else {
          this.setFieldEnabled("banding", false);
        }
      }
      if ((_b = initData == null ? void 0 : initData.stock) == null ? void 0 : _b.some((s) => s == null ? void 0 : s.material)) {
        const materials = Object.values(initData.stock.reduce((acc, s) => {
          const material = s.material.toUpperCase();
          if (!acc[material]) {
            acc[material] = { name: material, thicknesses: [] };
          }
          if (!acc[material].thicknesses.includes(s.t)) {
            acc[material].thicknesses.push(s.t);
          }
          return acc;
        }, {}));
        this.materials = materials;
        this.thicknesses = [];
        this.bondedThicknesses = [];
        materials.forEach((m) => {
          const thicknesses = m.thicknesses;
          for (let i = thicknesses.length; i--; ) {
            const t2 = thicknesses[i];
            const bonded = this.getBondedThicknesses(t2);
            if (!bonded.length) {
              return this.thicknesses.push(t2);
            }
            thicknesses.splice(i, 1);
            this.addBondedThicknesses(bonded, m);
          }
        });
        this.setFieldEnabled("t", true);
        if (materials.length > 1) {
          this.setFieldEnabled("material", true);
        }
      } else {
        this.getThicknessesFromStock(initData.stock);
      }
      if (!((_c = this == null ? void 0 : this.thicknesses) == null ? void 0 : _c.length) && !((_d = this == null ? void 0 : this.materials) == null ? void 0 : _d.length)) {
        this.setFieldEnabled("t", false);
      } else {
        this.setFieldEnabled("t", true);
      }
      if ((_e = this == null ? void 0 : this.options) == null ? void 0 : _e.enableMachining) {
        this.machiningOptions = initData == null ? void 0 : initData.machining;
        ["holes", "hingeHoles"].forEach((m) => {
          var _a3, _b2;
          if ((_a3 = initData == null ? void 0 : initData.machining) == null ? void 0 : _a3[m]) {
            this.machiningOptions[m].enabled = (_b2 = initData == null ? void 0 : initData.machining) == null ? void 0 : _b2[m].enabled;
          }
        });
        if ((_h = (_g = (_f = initData == null ? void 0 : initData.machining) == null ? void 0 : _f.corners) == null ? void 0 : _g.types) == null ? void 0 : _h.length) {
          this.machiningOptions.corners.enabled = true;
          this.machiningOptions.corners.types = (_j = (_i = initData == null ? void 0 : initData.machining) == null ? void 0 : _i.corners) == null ? void 0 : _j.types;
        }
      }
      this.loaded = true;
      this.$nextTick(() => {
        if (this.visInit === false) {
          const visData = {
            elementID: "#smartcut-svg-wrapper",
            env: "production",
            main: true,
            units: this.units,
            decimalPlaces: this.options.decimalPlaces,
            saw: this.saw,
            app: false,
            embed: true,
            colors: this.colors,
            options: this.visOptions,
            vueComponent: this
          };
          initVis.call(this, visData);
        }
        if (!this.isCreditVisible()) {
          alert("The SmartCut credit seems to have been tampered with - this is against our terms of service. Please contact support.");
        }
      });
    },
    getThicknessesFromStock(stockList = []) {
      this.thicknesses = [];
      this.bondedThicknesses = [];
      this.setFieldEnabled("t", false);
      if (!stockList.length) return;
      for (const st of stockList) {
        if (!(st == null ? void 0 : st.t)) continue;
        if (typeof st.t === "string" && st.t.includes(",")) {
          const bondedThickness = this.getBondedThicknesses(st.t, true);
          if (bondedThickness.length === 2) {
            this.addBondedThicknesses(bondedThickness);
            this.setFieldEnabled("t", true);
            st.t = this.thicknesses[0];
          } else {
            this.$emit("error", "bonded thickness found which does not have 2 options");
          }
        } else if (!this.thicknesses.includes(st.t)) {
          this.thicknesses.push(st.t);
        }
      }
      if (this.thicknesses.length > 1) this.setFieldEnabled("t", true);
    },
    calculate() {
      var _a2;
      this.clearMessage();
      if (((_a2 = this.options) == null ? void 0 : _a2.maxParts) && this.totalInputShapes > this.options.maxParts) {
        this.showMessage(this.$t("The maximum number of parts is") + " " + this.options.maxParts);
        return;
      }
      this.$emit("calculating");
      calculate.call(this);
    },
    showMessage(content = {
      main: null,
      heading: null,
      list: []
    }) {
      var _a2;
      if (typeof content === "object") {
        this.messageContent = content == null ? void 0 : content.main;
        this.messageHeading = content.heading;
        if ((_a2 = content == null ? void 0 : content.list) == null ? void 0 : _a2.length) {
          content.list.forEach((item) => {
            this.messageContent += `

${this.$t(item)}`;
          });
        }
      } else {
        this.messageContent = content;
      }
      this.messageVisible = true;
    },
    clearMessage() {
      this.messageVisible = false;
      this.messageContent = "";
      this.messageHeading = "";
    },
    createStockInput({
      name = "",
      l = null,
      w = null,
      t: t2 = null,
      material = "",
      q = 1,
      trim = {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      grain = "",
      cost = 0,
      notes = ""
    }) {
      const stockInput = new InputStock({
        id: (this.inputStock.length + 1).toString(),
        name,
        units: this.units,
        l,
        w,
        t: t2,
        material,
        q,
        autoAdd: true,
        trim,
        grain,
        cost,
        notes
      });
      return stockInput;
    },
    createShapeInput({
      l = null,
      w = this.saw.stockType === "linear" ? ((_b) => (_b = this.inputStock[0]) == null ? void 0 : _b.w)() : null,
      t: t2 = this.thicknesses.length ? this.thicknesses[0] : null,
      q = 1,
      material = ((_c) => (_c = this == null ? void 0 : this.materials) == null ? void 0 : _c.length)() === 1 ? this.materials[0].name : "",
      name = null,
      orientationLock = this.options.orientationModel === 2 ? "l" : null,
      bandingOptions = null,
      customData = null
    } = {}) {
      const inputShape = new InputShape({
        id: (this.inputShapes.length + 1).toString(),
        units: this.units,
        l,
        w,
        t: t2,
        q,
        material,
        name,
        orientationLock,
        bandingOptions,
        customData
      });
      if (!this.bandingChoices) return inputShape;
      const allBandingKeys = Object.keys(this.bandingChoices);
      allBandingKeys.forEach((name2) => {
        var _a2, _b2;
        for (const bandingKey in inputShape.bandingOptions) {
          if (!((_b2 = (_a2 = inputShape.bandingOptions) == null ? void 0 : _a2[bandingKey]) == null ? void 0 : _b2[name2])) {
            inputShape.bandingOptions[bandingKey][name2] = "";
          }
        }
      });
      return inputShape;
    },
    addInputShape(number2 = 1) {
      for (let i = number2; i--; ) {
        let newInputShape;
        if (this.inputShapes.length > 0) {
          const lastShape = this.inputShapes[this.inputShapes.length - 1];
          newInputShape = this.createShapeInput({
            material: lastShape.material,
            t: lastShape.t
          });
        } else {
          newInputShape = this.createShapeInput();
        }
        this.inputShapes.push(newInputShape);
      }
    },
    removeShape(index) {
      var _a2;
      if (this.inputShapes.length === 1) return;
      const listId = this.inputShapes[index].listId;
      this.inputShapes.splice(index, 1);
      if (((_a2 = this.currentInputShape) == null ? void 0 : _a2.listId) === listId) this.currentInputShape = null;
      resetProgress(this.progress);
    },
    createStock(stock, i) {
      const l = convertUnit(stock.l);
      const w = convertUnit(stock.w);
      const t2 = stock.t ? convertUnit(stock.t) : null;
      const newStock = new Stock({
        id: (i + 1).toString() + ".0",
        name: (stock == null ? void 0 : stock.name) ? stock.name : `${l}x${w}`,
        l,
        w,
        t: t2,
        saw: new Saw(this.saw),
        material: stock.material,
        grain: stock.grain,
        autoAdd: true,
        cost: stock == null ? void 0 : stock.cost,
        trim: stock.trim,
        allowExactFitShapes: stock.allowExactFitShapes,
        type: this.saw.stockType,
        notes: stock == null ? void 0 : stock.notes
      });
      this.stockList.push(newStock);
      return newStock.issues;
    },
    createStockList() {
      return createStockList.call(this, false);
    },
    createShapeList() {
      var _a2, _b;
      const issues = [];
      for (let index = 0; index < this.inputShapes.length; index++) {
        const inputShape = this.inputShapes[index];
        inputShape.convertBandingOptionsToBanding();
        if ((_a2 = inputShape == null ? void 0 : inputShape.issues) == null ? void 0 : _a2.length)
          issues.push(...inputShape.issues.map((i) => this.$t("Part") + ` ${index + 1}: ${i}`));
        if (!inputShape.l || !inputShape.w || !inputShape.q) continue;
        const s = new Shape(mapOrientation({
          id: (index + 1).toString() + ".0",
          l: convertUnit(inputShape == null ? void 0 : inputShape.l),
          w: convertUnit(inputShape == null ? void 0 : inputShape.w),
          t: (inputShape == null ? void 0 : inputShape.t) ? convertUnit(inputShape.t) : null,
          material: (inputShape == null ? void 0 : inputShape.material) ? inputShape.material : null,
          q: typeof inputShape.q !== "number" ? parseInt(inputShape.q) : inputShape.q,
          name: inputShape.name,
          orientationLock: inputShape.orientationLock,
          banding: inputShape.banding,
          bandingType: inputShape.bandingType,
          machining: inputShape.machining,
          customData: inputShape.customData
        }, this.options.orientationModel));
        this.shapeList.push(s);
        if ((_b = s == null ? void 0 : s.issues) == null ? void 0 : _b.length) issues.push(...s.issues);
      }
      this.updatePartQuantitiesBasedOnThickness();
      return issues;
    },
    /* toggleShapeOrientation( shape )
    		{
    			let orientations = ['', 'l', 'w'];
    
    			//cater for orientation model
    			if ( this.options.orientationModel === 2 ) orientations = ['', 'l'];
    
    			let index = orientations.findIndex( ( o ) => o === shape.orientationLock );
    			index++;
    			if ( index > 2 ) index = 0;
    			shape.orientationLock = orientations[index];
    		}, */
    refresh() {
      this.refreshStock();
      this.refreshShapes();
    },
    refreshStock() {
      refreshStock.call(this);
    },
    refreshShapes() {
      refreshShapes.call(this, this.uniqueShapes.length);
    },
    toggleWidget(name, show = null) {
      toggleWidget.call(this, name, show);
    },
    clearSelection() {
      clearSelection.call(this);
    },
    showStock(id) {
      showStock.call(this, id);
    },
    updateAllBanding(key, value2, inputShape) {
      inputShape.setAllBandingOptions(key, value2);
    },
    deleteBanding(inputShape) {
      inputShape.removeBandingApartFromBandingOptions();
      const allBandingKeys = Object.keys(this.bandingChoices);
      allBandingKeys.forEach((name) => {
        for (const bandingKey in inputShape.bandingOptions) {
          inputShape.bandingOptions[bandingKey][name] = "";
        }
      });
    },
    getBandingPrice(bandingOptions) {
      const options = Object.values(bandingOptions || {});
      if (!Array.isArray(options) || !options.every((b) => b)) return "";
      if (!this.$parent.findBandingPrice || typeof this.$parent.findBandingPrice !== "function" || !this.$parent.formatPrice || typeof this.$parent.formatPrice !== "function")
        return "";
      const price = this.$parent.findBandingPrice(options);
      return this.$parent.formatPrice(price, this.locale);
    },
    //update the thickness data and return
    getShapeThicknesses(shape) {
      var _a2;
      if (!shape)
        return {
          thicknesses: [],
          bondedThicknesses: []
        };
      if (!((_a2 = this.materials) == null ? void 0 : _a2.length)) {
        return {
          thicknesses: this.thicknesses,
          bondedThicknesses: []
        };
      }
      if (!shape.material)
        return {
          thicknesses: [],
          bondedThicknesses: []
        };
      const material = this.materials.find((m) => m.name === shape.material);
      if (!material)
        return {
          thicknesses: [],
          bondedThicknesses: []
        };
      const thicknesses = material.thicknesses;
      const bondedThicknesses = [];
      for (let i = 0; i < thicknesses.length; i++) {
        const t2 = thicknesses[i];
        const bonded = this.getBondedThicknesses(t2);
        const bondedIndexes = [];
        if (bonded.length) {
          bonded.forEach((b) => {
            thicknesses.splice(i, 1, b);
            bondedIndexes.push(i);
          });
          i++;
        }
        if (bondedIndexes.length) {
          bondedThicknesses.push(bondedIndexes);
        }
      }
      return {
        thicknesses,
        bondedThicknesses
      };
    },
    getShapeThicknessOptions(shape) {
      const thicknesses = this.getShapeThicknesses(shape).thicknesses;
      const thicknessOptions = thicknesses.map((t2) => {
        return {
          label: t2.toString(),
          value: t2
        };
      });
      return thicknessOptions;
    },
    getBondedThicknesses(t2, cu = false) {
      if (typeof t2 === "string" && t2.includes(",")) {
        const bonded = t2.split(",");
        if (cu) return bonded.map((t22) => convertUnit(t22));
        return bonded;
      }
      return [];
    },
    getShapeStockGrainSummary(shape) {
      const thisMaterial = shape.material;
      const thisThickness = shape.t;
      const matchingStock = this.inputStock.filter((s) => s.material === thisMaterial && s.t === thisThickness);
      const grainSummary = getStockGrainSummary(matchingStock);
      return grainSummary;
    },
    //this is for bonded thicknesses
    updatePartQuantitiesBasedOnThickness() {
      if (!this.thicknesses.length) return;
      this.shapeList.forEach((s) => {
        if (!s.t) return;
        const thicknessIndex = this.thicknesses.findIndex((t2) => convertUnit(t2) === s.t);
        const bondedIndexes = this.bondedThicknesses.find((bonded) => {
          return bonded.includes(thicknessIndex);
        });
        if (!bondedIndexes) {
          return;
        }
        const smallestThickness = Math.min(...bondedIndexes.map((i) => this.thicknesses[i]));
        if (s.t > smallestThickness) {
          s.q = s.q * (s.t / smallestThickness);
          s.t = smallestThickness;
        }
      });
    },
    debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },
    handleResize() {
      this.viewportWidth = window.innerWidth;
    },
    getCustomFieldId(id) {
      if (!id) return null;
      return sanitiseString(id).toLowerCase();
    }
  }
};
function block0(Component) {
  const _Component = Component;
  _Component.__i18n = _Component.__i18n || [];
  _Component.__i18n.push({
    "locale": "",
    "resource": {
      "en_US": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Length" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Width" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "W" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Thickness" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "T" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Name" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Quantity" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Q" } },
        "material": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Material" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Orientation" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Machining" } },
        "grain": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Grain" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Add part" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Remove part" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Calculate" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Full screen" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Banding" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Delete banding" } },
        "select": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Select" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Delete" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Clear" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "W1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "W2" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "All" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Drop CSV file here" } },
        "Powered by SmartCut": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Powered by SmartCut" } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Part" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Issue" } },
        "Part issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Part issue" } },
        "Issue with part inputs:": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Issue with part inputs:" } },
        "No parts": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No parts" } },
        "No parts in list": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No parts in list" } },
        "No quantity of parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No quantity of parts found" } },
        "No parts were added - please double check your list": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No parts were added - please double check your list" } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "The following parts did not fit" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "The maximum number of parts is" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No valid parts found" } }
      },
      "ca": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Llarg" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Ample" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Gruix" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "G" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Nom" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Quantitat" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Q" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Mecanitzat" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Gir" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Afegeix" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Calcula" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pantalla completa" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Cantell" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina cantell" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Neteja" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Todos" } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pea" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tema" } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Les peces segents no encaixaven" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "El nmero mxim de peces s" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No s'han trobat peces vlides" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No s'han trobat peces vlides" } },
        "Powered by SmartCut": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Desenvolupat per SmartCut" } }
      },
      "es_ES": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Largo" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Ancho" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Grueso" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "G" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Nombre" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Cantidad" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "C" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Mecanizado" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Giro" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aade" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Calcula" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pantalla completa" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Canto" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina canto" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Elimina" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Borra" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "A1" } },
        "all": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Todos" } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pieza" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tema" } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Las siguientes piezas no encajaban" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "El nmero mximo de piezas es" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "No se encontraron piezas vlidas" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Carga el archivo CSV aqu" } },
        "Powered by SmartCut": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Desarrollado por SmartCut" } }
      },
      "fr_FR": {
        "length": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Longueur" } },
        "l": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L" } },
        "width": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Largeur" } },
        "w": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "la" } },
        "thickness": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Epaisseur" } },
        "t": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "ep" } },
        "name": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Nom" } },
        "quantity": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Quantit" } },
        "q": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Qt" } },
        "material": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Matriel" } },
        "machining": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Machinage" } },
        "grain": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Sens de fil" } },
        "orientation": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Orientation" } },
        "add part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Ajouter pice" } },
        "remove part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Supprimer pice" } },
        "calculate": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Optimiser" } },
        "full screen": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Plein cran" } },
        "banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Chants" } },
        "delete banding": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Supprimer chants" } },
        "select": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Slectionner" } },
        "delete": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Supprimer" } },
        "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Effacer" } },
        "l1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L1" } },
        "l2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "L2" } },
        "w1": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "la1" } },
        "w2": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "la2" } },
        "Powered by SmartCut": { "t": 0, "b": { "static": "", "t": 2, "i": [] } },
        "Part": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pice" } },
        "Drop CSV file here": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tlcharger CSV" } },
        "Issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Erreur" } },
        "Part issue": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pice erreur" } },
        "Issue with part inputs": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Erreur avec l'importation de pices" } },
        "No parts": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pice" } },
        "No parts in list": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pice dans la liste" } },
        "No quantity of parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune quantit trouv pour certaines pices" } },
        "No parts were added - please double check your list": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pice n'a t ajoute - veuillez vrifier votre liste" } },
        "The following parts did not fit": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Les pices suivantes ne s'adaptent pas" } },
        "The maximum number of parts is": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Le nombre maximum de pices est" } },
        "No valid parts found": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Aucune pice valide trouve" } }
      }
    }
  });
}
const _hoisted_1 = { key: 1 };
const _hoisted_2 = {
  key: 0,
  class: "row table-heading"
};
const _hoisted_3 = {
  key: 0,
  class: "cell delete"
};
const _hoisted_4 = { class: "cell" };
const _hoisted_5 = {
  key: 0,
  class: "cell"
};
const _hoisted_6 = ["aria-label", "onClick"];
const _hoisted_7 = {
  key: 0,
  class: "inputs"
};
const _hoisted_8 = ["onUpdate:modelValue", "onChange"];
const _hoisted_9 = ["value"];
const _hoisted_10 = { class: "banding-price" };
const _hoisted_11 = ["aria-label", "onClick"];
const _hoisted_12 = { class: "button-wrapper main" };
const _hoisted_13 = ["aria-label"];
const _hoisted_14 = ["aria-label", "disabled"];
const _hoisted_15 = ["aria-label"];
const _hoisted_16 = { id: "part-count" };
const _hoisted_17 = {
  key: 3,
  id: "messages"
};
const _hoisted_18 = {
  key: 0,
  class: "heading"
};
const _hoisted_19 = { class: "content" };
const _hoisted_20 = {
  key: 4,
  id: "progress"
};
const _hoisted_21 = {
  id: "smartcut-svg-wrapper",
  class: "svg-wrapper production"
};
const _hoisted_22 = {
  key: 0,
  id: "stack"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const _component_Machining = resolveComponent("Machining");
  const _component_Spinner = resolveComponent("Spinner");
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  const _component_InputField = resolveComponent("InputField");
  const _component_OrientationButton = resolveComponent("OrientationButton");
  const _component_BandingButton = resolveComponent("BandingButton");
  const _component_MachiningButton = resolveComponent("MachiningButton");
  const _component_ImportCSV = resolveComponent("ImportCSV");
  const _component_StockNavigation = resolveComponent("StockNavigation");
  return openBlock(), createElementBlock(Fragment, null, [
    $data.machiningEnabled ? (openBlock(), createBlock(_component_Machining, {
      key: 0,
      shape: $data.currentInputShape,
      options: $data.machiningOptions,
      onClose: $options.closeMachining
    }, null, 8, ["shape", "options", "onClose"])) : createCommentVNode("", true),
    !$data.loaded ? (openBlock(), createElementBlock("div", _hoisted_1, [
      createVNode(_component_Spinner, {
        size: 50,
        "show-number": false
      })
    ])) : createCommentVNode("", true),
    $data.loaded ? (openBlock(), createElementBlock("div", {
      key: 2,
      id: "smartcut-checkout",
      class: normalizeClass({ fullscreen: $data.isFullScreen })
    }, [
      $data.canGoFullScreen ? (openBlock(), createElementBlock("div", {
        key: 0,
        id: "smartcut-full-screen",
        class: "icon-left",
        onClick: _cache[0] || (_cache[0] = ($event) => $options.toggleFullScreen())
      }, [
        createVNode(_component_font_awesome_icon, { icon: ["fasr", "expand"] }),
        createTextVNode(" " + toDisplayString$1($setup.t("full screen")), 1)
      ])) : createCommentVNode("", true),
      !((_b = (_a2 = $data.user) == null ? void 0 : _a2.api) == null ? void 0 : _b.whiteLabel) ? (openBlock(), createElementBlock("div", {
        key: 1,
        id: "credit",
        style: normalizeStyle($data.creditStyles)
      }, [
        createBaseVNode("a", {
          title: "SmartCut | Cut list optimization software",
          style: normalizeStyle($data.creditLinkStyles),
          target: "_blank",
          href: "https://smartcut.dev/"
        }, toDisplayString$1($setup.t("Powered by SmartCut")), 5)
      ], 4)) : createCommentVNode("", true),
      createBaseVNode("div", {
        id: "part-input",
        class: "inputs no-margin-top grid-table",
        style: normalizeStyle({ "grid-template-columns": $options.partColumnsStyle })
      }, [
        $data.inputShapes.length ? (openBlock(), createElementBlock("div", _hoisted_2, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "cell id" }, null, -1)),
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.relevantFieldDefinitions, (f) => {
            return openBlock(), createElementBlock("div", {
              key: f.id,
              class: normalizeClass(["cell", { center: ["orientationLock", "banding", "machining"].includes(f.id) || f.type === "checkbox" }])
            }, toDisplayString$1(f.label), 3);
          }), 128)),
          $data.inputShapes.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_3)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.inputShapes, (shape, shapeIndex) => {
          return openBlock(), createElementBlock("div", {
            key: shapeIndex,
            class: "row"
          }, [
            createBaseVNode("div", _hoisted_4, [
              createBaseVNode("div", {
                class: "id",
                style: normalizeStyle({
                  background: $data.colors.partA,
                  color: $data.colors.text
                })
              }, toDisplayString$1(shapeIndex + 1), 5)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.relevantFieldDefinitions, (f) => {
              return openBlock(), createElementBlock("div", {
                key: f.fieldMap,
                class: normalizeClass(["cell", { center: ["orientationLock", "banding", "machining"].includes(f.id) || f.type === "checkbox" }])
              }, [
                !["orientationLock", "banding", "machining"].includes(f.id) ? (openBlock(), createBlock(_component_InputField, {
                  key: 0,
                  id: f.id + "-" + shapeIndex,
                  focus: $data.options.enableFocus && shapeIndex === $data.inputShapes.length - 1 && f.id === "l",
                  type: f.type,
                  output: f.output,
                  label: f.label,
                  units: $props.units,
                  placeholder: f == null ? void 0 : f.placeholder,
                  options: f.id === "t" ? $options.getShapeThicknessOptions(shape) : f == null ? void 0 : f.options,
                  "true-value": f == null ? void 0 : f.trueValue,
                  "false-value": f == null ? void 0 : f.falseValue,
                  default: f == null ? void 0 : f.default,
                  min: typeof (f == null ? void 0 : f.min) === "number" ? f.min : null,
                  max: typeof (f == null ? void 0 : f.max) === "number" ? f.max : null,
                  custom: f == null ? void 0 : f.custom,
                  value: $options.getNestedValue(shape, f.fieldMap),
                  text: {
                    delete: $setup.t("delete"),
                    select: $setup.t("select")
                  },
                  onUpdate: (value2) => $options.setNestedValue(shape, f.fieldMap, value2)
                }, null, 8, ["id", "focus", "type", "output", "label", "units", "placeholder", "options", "true-value", "false-value", "default", "min", "max", "custom", "value", "text", "onUpdate"])) : f.id === "orientationLock" ? (openBlock(), createBlock(_component_OrientationButton, {
                  key: 1,
                  rectangle: shape,
                  "stock-grain": $options.getShapeStockGrainSummary(shape),
                  "button-background": $data.colors.button,
                  "icon-color": $data.colors.buttonText,
                  "orientation-model": $data.options.orientationModel,
                  onUpdateOrientation: ($event) => shape.orientationLock = $event
                }, null, 8, ["rectangle", "stock-grain", "button-background", "icon-color", "orientation-model", "onUpdateOrientation"])) : f.id === "banding" ? (openBlock(), createBlock(_component_BandingButton, {
                  key: 2,
                  "input-shape": shape,
                  "stock-grain": $options.getShapeStockGrainSummary(shape),
                  open: $data.bandingEnabled === shapeIndex,
                  "orientation-model": $data.options.orientationModel,
                  onClicked: ($event) => $options.openBanding(shape)
                }, null, 8, ["input-shape", "stock-grain", "open", "orientation-model", "onClicked"])) : f.fieldMap === "machining" && $data.canGoFullScreen ? (openBlock(), createBlock(_component_MachiningButton, {
                  key: 3,
                  "input-shape": shape,
                  onOpen: ($event) => $options.openMachining(shape)
                }, null, 8, ["input-shape", "onOpen"])) : createCommentVNode("", true)
              ], 2);
            }), 128)),
            $data.inputShapes.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_5, [
              createBaseVNode("button", {
                type: "button",
                class: "delete",
                "aria-label": $setup.t("remove part"),
                onClick: ($event) => $options.removeShape(shapeIndex)
              }, [
                createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] })
              ], 8, _hoisted_6)
            ])) : createCommentVNode("", true),
            $data.bandingEnabled === shapeIndex && Object.values($data.bandingChoices).length > 0 ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "group banding",
              style: normalizeStyle({ "grid-column-end": "span " + ($options.partColumns + 1) })
            }, [
              Object.values($data.bandingChoices).length === 1 && $data.bandingChoices[Object.keys($data.bandingChoices)[0]].length === 0 ? (openBlock(), createElementBlock("div", _hoisted_7, [
                createVNode(_component_InputField, {
                  id: "banding-all-" + shapeIndex,
                  type: "checkbox",
                  label: $setup.t("all"),
                  "true-value": true,
                  "false-value": "",
                  value: shape.bandingOptions["all"][Object.keys($data.bandingChoices)[0]],
                  onUpdate: (value2) => $options.updateAllBanding(Object.keys($data.bandingChoices)[0], value2, shape)
                }, null, 8, ["id", "label", "value", "onUpdate"]),
                (openBlock(), createElementBlock(Fragment, null, renderList(["y1", "y2", "x1", "x2"], (axis2) => {
                  return createVNode(_component_InputField, {
                    key: axis2,
                    id: "banding-" + axis2 + "-" + shapeIndex,
                    type: "checkbox",
                    label: $setup.t($data.userFriendlyFieldMap[axis2]),
                    "true-value": true,
                    "false-value": "",
                    value: shape.bandingOptions[axis2][Object.keys($data.bandingChoices)[0]],
                    onUpdate: (value2) => shape.bandingOptions[axis2][Object.keys($data.bandingChoices)[0]] = value2
                  }, null, 8, ["id", "label", "value", "onUpdate"]);
                }), 64))
              ])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: "grid",
                style: normalizeStyle({
                  "grid-template-columns": $options.bandingColumnsStyle
                })
              }, [
                createBaseVNode("div", null, toDisplayString$1($setup.t("all")), 1),
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.bandingChoices, (bandingOption, name, bandingOptionsIndex) => {
                  return withDirectives((openBlock(), createElementBlock("select", {
                    key: name + bandingOptionsIndex.toString(),
                    "onUpdate:modelValue": ($event) => shape.bandingOptions["all"][name] = $event,
                    onChange: ($event) => $options.updateAllBanding(name, shape.bandingOptions["all"][name], shape)
                  }, [
                    _cache[5] || (_cache[5] = createBaseVNode("option", { value: "" }, "  ", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(bandingOption, (bandingChoice, optionIndex) => {
                      return openBlock(), createElementBlock("option", {
                        key: optionIndex,
                        value: bandingChoice
                      }, toDisplayString$1(bandingChoice), 9, _hoisted_9);
                    }), 128))
                  ], 40, _hoisted_8)), [
                    [vModelSelect, shape.bandingOptions["all"][name]]
                  ]);
                }), 128)),
                _cache[6] || (_cache[6] = createBaseVNode("div", null, null, -1)),
                (openBlock(), createElementBlock(Fragment, null, renderList(["y1", "y2", "x1", "x2"], (axis2) => {
                  return openBlock(), createElementBlock(Fragment, { key: axis2 }, [
                    createBaseVNode("div", null, toDisplayString$1($setup.t($data.userFriendlyFieldMap[axis2])), 1),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.bandingChoices, (bandingOption, name, bandingOptionsIndex) => {
                      return openBlock(), createBlock(_component_InputField, {
                        id: "banding-" + name + "-" + axis2 + "-" + bandingOptionsIndex + "-" + shapeIndex,
                        key: axis2 + name + bandingOptionsIndex.toString(),
                        type: "select",
                        options: bandingOption.map((option) => ({
                          value: option,
                          label: option
                        })),
                        text: { select: "" },
                        "select-first-option-disabled": false,
                        value: shape.bandingOptions[axis2][name],
                        onUpdate: (value2) => shape.bandingOptions[axis2][name] = value2
                      }, null, 8, ["id", "options", "value", "onUpdate"]);
                    }), 128)),
                    createBaseVNode("div", _hoisted_10, toDisplayString$1($options.getBandingPrice(shape.bandingOptions[axis2])), 1)
                  ], 64);
                }), 64))
              ], 4)),
              createBaseVNode("button", {
                type: "button",
                class: "delete icon-left",
                "aria-label": $setup.t("delete banding"),
                onClick: ($event) => $options.deleteBanding(shape)
              }, [
                createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] }),
                createTextVNode(" " + toDisplayString$1($setup.t("delete banding")), 1)
              ], 8, _hoisted_11)
            ], 4)) : createCommentVNode("", true)
          ]);
        }), 128))
      ], 4),
      createBaseVNode("div", _hoisted_12, [
        createBaseVNode("button", {
          type: "button",
          "aria-label": $setup.t("add part"),
          style: normalizeStyle({ background: $data.colors.button, color: $data.colors.buttonText }),
          class: "add c-btn icon-left",
          onClick: _cache[1] || (_cache[1] = ($event) => $options.addInputShape(1))
        }, [
          createVNode(_component_font_awesome_icon, { icon: ["fasr", "plus-large"] }),
          createTextVNode(" " + toDisplayString$1($setup.t("add part")), 1)
        ], 12, _hoisted_13),
        createBaseVNode("button", {
          class: "c-btn calculate icon-left",
          type: "button",
          "aria-label": $setup.t("calculate"),
          style: normalizeStyle({
            background: $data.colors.button,
            color: $data.colors.buttonText
          }),
          disabled: !((_c = $data.inputStock) == null ? void 0 : _c.length) || $data.thinking,
          onClick: _cache[2] || (_cache[2] = ($event) => $options.calculate())
        }, [
          createVNode(_component_font_awesome_icon, { icon: ["fass", "calculator"] }),
          createTextVNode(toDisplayString$1($setup.t("calculate")), 1)
        ], 12, _hoisted_14),
        createBaseVNode("button", {
          type: "button",
          class: "c-btn clear",
          "aria-label": $setup.t("clear"),
          onClick: _cache[3] || (_cache[3] = ($event) => $options.clear())
        }, [
          createVNode(_component_font_awesome_icon, { icon: ["fass", "trash"] })
        ], 8, _hoisted_15),
        createBaseVNode("div", _hoisted_16, toDisplayString$1($options.totalInputShapes) + toDisplayString$1(((_d = $data.options) == null ? void 0 : _d.maxParts) ? "/" + $data.options.maxParts : ""), 1)
      ]),
      $data.CSVImportEnabled ? (openBlock(), createBlock(_component_ImportCSV, {
        key: 2,
        ref: "import",
        units: $props.units,
        "custom-fields": $data.customFieldDefinitions,
        "banding-choices": $data.bandingChoices,
        options: {
          locale: $data.options.locale
        },
        onImport: $options.importParts
      }, null, 8, ["units", "custom-fields", "banding-choices", "options", "onImport"])) : createCommentVNode("", true),
      $data.messageVisible ? (openBlock(), createElementBlock("div", _hoisted_17, [
        $data.messageHeading ? (openBlock(), createElementBlock("div", _hoisted_18, toDisplayString$1($data.messageHeading), 1)) : createCommentVNode("", true),
        createBaseVNode("pre", _hoisted_19, toDisplayString$1($data.messageContent), 1)
      ])) : createCommentVNode("", true),
      ($data.options.showDiagram ? $data.thinking && !$data.progress.complete : $data.thinking || $data.progress.complete) ? (openBlock(), createElementBlock("div", _hoisted_20, [
        createVNode(_component_Spinner, {
          size: 50,
          number: $data.progress.shapeCount,
          complete: $data.progress.complete,
          "show-number": $data.options.showProgressNumber
        }, null, 8, ["number", "complete", "show-number"])
      ])) : createCommentVNode("", true),
      withDirectives(createBaseVNode("div", _hoisted_21, [
        ((_e = $options.activeStock) == null ? void 0 : _e.type) !== "roll" ? (openBlock(), createElementBlock("div", _hoisted_22, toDisplayString$1(((_f = $options.activeStock) == null ? void 0 : _f.stack) ? (_g = $options.activeStock) == null ? void 0 : _g.stack : 1), 1)) : createCommentVNode("", true)
      ], 512), [
        [vShow, $data.options.showDiagram && $data.jobId > 0]
      ]),
      $data.options.showDiagram && $data.visInit && $options.usedStock.length > 1 && $data.jobId > 0 && $data.progress.complete ? (openBlock(), createBlock(_component_StockNavigation, {
        key: 5,
        ref: "stockNavigation",
        "active-stock-id": $data.activeStockId,
        "stock-list": $options.stackedStock,
        "stock-count": $data.stockList.length,
        "viewport-width": $data.viewportWidth,
        onShowStock: $options.showStock
      }, null, 8, ["active-stock-id", "stock-list", "stock-count", "viewport-width", "onShowStock"])) : createCommentVNode("", true)
    ], 2)) : createCommentVNode("", true)
  ], 64);
}
if (typeof block0 === "function") block0(_sfc_main$2);
const CheckoutCalculator = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-39170cf2"]]);
const _sfc_main$1 = {
  name: "Wordpress",
  //needs to be Wordpress not WordPress
  components: {
    CheckoutCalculator
  },
  data() {
    return {
      debug: true,
      el: {},
      settings: {},
      options: {},
      inputs: {},
      formatting: {},
      product: {},
      stock: [],
      bandingData: {},
      variations: []
    };
  },
  computed: {
    smartcutConfigUnits() {
      return window.smartcutConfig.settings.units ?? "decimal";
    }
  },
  created() {
    console.log(
      " Powered by https://smartcut.dev",
      window.smartcutConfig.version
    );
  },
  mounted() {
    var _a2, _b, _c;
    console.log("Launching WordPress checkout...");
    this.bandingData = ((_a2 = window.smartcutConfig) == null ? void 0 : _a2.banding_data) ?? null;
    this.machiningPricing = ((_b = window.smartcutConfig) == null ? void 0 : _b.machining_pricing) ?? null;
    this.variations = ((_c = window.smartcutConfig) == null ? void 0 : _c.variations) ?? null;
    this.cacheElements();
    this.cacheInputFields();
    this.configureProduct(window.smartcutConfig);
    this.configurePricing(window.smartcutConfig);
    this.initCheckout();
    this.configureStock();
    jQuery(".variations_form").on("reset_data", () => {
      this.disableCutToSize();
    });
    jQuery(".variations_form").on("found_variation", (e, variation) => {
      var _a3, _b2;
      this.reset();
      this.log(["variation selected", variation.attributes]);
      this.stock = [];
      const thickness = (_a3 = variation == null ? void 0 : variation.attributes) == null ? void 0 : _a3.attribute_thickness;
      this.product.selected_thickness = thickness;
      if (this.product.multiple_sizes) {
        const size2 = this.getSizes(variation);
        if (!size2) {
          this.disableCutToSize();
          this.el.cart_button.disabled = true;
          this.el.quantity.readOnly = true;
          return this.error("The size of this multiple size product could not be found");
        }
        if (!Array.isArray(size2)) {
          if (this.isFullSheetSize(size2)) {
            this.disableCutToSize();
            this.enableFullSheet();
            this.el.quantity.style.display = "inline-block";
          } else {
            this.enableCutToSize();
            this.el.quantity.style.display = "none";
          }
        } else {
          this.enableCutToSize();
        }
        this.log([`variation found, size ${size2}, thickness ${thickness}`]);
        let stockSizes;
        if (((_b2 = this.variations) == null ? void 0 : _b2.length) && thickness) {
          if (Array.isArray(size2)) {
            const v = this.variations.find((v2) => v2.attributes.thickness === thickness);
            if (!v) {
              return this.error(`variation not found for thickness ${thickness}`);
            }
            stockSizes = size2.map((size22) => {
              return {
                size: size22,
                l: size22.split("x")[0],
                w: size22.split("x")[1],
                t: thickness,
                price: v == null ? void 0 : v.price
              };
            });
          } else {
            stockSizes = this.variations.filter((v) => {
              var _a4, _b3;
              if (/\d+x\d+/.test((_a4 = v == null ? void 0 : v.attributes) == null ? void 0 : _a4.size)) {
                return thickness === ((_b3 = v == null ? void 0 : v.attributes) == null ? void 0 : _b3.thickness);
              }
              return false;
            }).map((v) => {
              var _a4, _b3, _c2;
              const exactMatchVariation = this.variations.find((v2) => {
                var _a5, _b4;
                return thickness === ((_a5 = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _a5.thickness) && size2 === ((_b4 = v2 == null ? void 0 : v2.attributes) == null ? void 0 : _b4.size);
              });
              if (!exactMatchVariation) {
                this.error(`exactMatchVariation not found for thickness ${thickness}, size: ${size2} in variations`);
              }
              let price;
              if (!(exactMatchVariation == null ? void 0 : exactMatchVariation.price) || parseFloat(exactMatchVariation.price) === 0) {
                price = (v == null ? void 0 : v.price) ?? "0";
              } else {
                price = exactMatchVariation == null ? void 0 : exactMatchVariation.price;
              }
              this.log([
                `price for thickness ${thickness}, size: ${size2} detected as ${price}`
              ]);
              return {
                size: (_a4 = v == null ? void 0 : v.attributes) == null ? void 0 : _a4.size,
                l: (_b3 = v == null ? void 0 : v.attributes) == null ? void 0 : _b3.size.split("x")[0],
                w: (_c2 = v == null ? void 0 : v.attributes) == null ? void 0 : _c2.size.split("x")[1],
                t: this.product.selected_thickness,
                price
              };
            });
          }
          stockSizes.forEach((size22) => {
            const newStock = this.createStock(
              size22.l,
              size22.w,
              size22.t,
              size22.price,
              variation == null ? void 0 : variation.attributes
            );
            this.stock.push(newStock);
          });
        }
      } else {
        this.el.quantity.style.display = "inline-block";
        const v = this.variations.find((v2) => v2.attributes.thickness === thickness);
        if (!v)
          return this.error(`variation not found for thickness ${thickness}`);
        this.stock.push(this.createStock(
          this.product.l,
          this.product.w,
          thickness,
          v.price,
          variation == null ? void 0 : variation.attributes
        ));
        this.enableCutToSize();
      }
    });
    const elements = [
      "div.quantity > input.plus",
      "div.quantity > input.minus",
      "div.quantity .qty-plus",
      "div.quantity .qty-minus"
    ];
    elements.forEach((e) => {
      const el = document.querySelector(e);
      if (el) el.style.display = "none";
    });
  },
  methods: {
    toggleDebug(e) {
      this.debug = e;
    },
    log(messages2) {
      if (this.debug) {
        console.log("SmartCut -", ...messages2);
      }
    },
    enableCutToSize() {
      const elements = [
        "checkout",
        "intro_text",
        "offcuts",
        "banding_key"
      ];
      elements.forEach((e) => {
        const el = this.el[e];
        if (el) el.style.display = "block";
      });
      if (this.isPricingTableNeeded()) {
        this.el["pricing_table"].style.display = "table";
      }
      this.el.cart_button.disabled = true;
      this.el.quantity.readOnly = true;
      this.el.quantity.style.display = "inline-block";
    },
    disableCutToSize() {
      var _a2;
      const elements = [
        "checkout",
        "intro_text",
        "offcuts",
        "banding_key",
        "pricing_table"
      ];
      elements.forEach((e) => {
        const el = this.el[e];
        if (el) el.style.display = "none";
      });
      if ((_a2 = this.el) == null ? void 0 : _a2.quantity) {
        this.el.quantity.style.display = "inline-block";
      }
    },
    enableFullSheet() {
      this.el.cart_button.disabled = false;
      this.el.quantity.readOnly = false;
    },
    parseValue(val, type3) {
      let parsed;
      switch (type3) {
        case "string":
        case "hex":
          parsed = this.parseString(val);
          break;
        case "boolean":
          parsed = this.parseBoolean(val);
          break;
        case "int":
          parsed = this.parseInt(val);
          break;
        case "float":
          parsed = this.parseFloat(val);
          break;
        default:
          parsed = this.parseString(val);
          break;
      }
      return parsed;
    },
    parseInt(val) {
      if (!val) return 0;
      return parseInt(val);
    },
    parseFloat(val) {
      if (!val) return 0;
      return parseFloat(val);
    },
    parseBoolean(val) {
      if (!val) return false;
      return val === "1";
    },
    parseString(val) {
      if (!val) return "";
      return val;
    },
    initCheckout() {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
      if (!(window == null ? void 0 : window.smartcutConfig)) {
        console.error("SmartCut config not found");
        return;
      }
      for (const key in window.smartcutConfig.settings_fields) {
        this.settings[key] = this.parseValue(
          window.smartcutConfig.settings[key],
          window.smartcutConfig.settings_fields[key]
        );
      }
      const banding = this.getBandingOptions((_a2 = window.smartcutConfig) == null ? void 0 : _a2.banding_data);
      const options = {
        debug: this.settings.debug,
        units: this.settings.units,
        locale: window.smartcutConfig.locale,
        //saw settings
        bladeWidth: this.settings.blade_width,
        stockType: this.settings.stock_type,
        cutPreference: this.settings.cut_preference,
        stackHeight: this.settings.stack_height,
        maxParts: this.settings.max_parts ?? null,
        //disable default options
        disableBanding: this.settings.disable_banding,
        disableOrientation: this.settings.disable_orientation,
        disablePartName: this.settings.disable_part_name,
        enableCSVImport: this.settings.enable_import,
        //diagram
        showDiagram: !this.settings.hide_diagram,
        showProgressNumber: this.settings.pricing_strategy === "part_area" ? false : true,
        enableMachining: this.settings.enable_machining,
        disableClick: false,
        orientationModel: 0,
        decimalPlaces: 2,
        enableFocus: true,
        //colors
        colors: {
          partA: ((_b = this.settings) == null ? void 0 : _b.part_a_color) ? (_c = this.settings) == null ? void 0 : _c.part_a_color : "#1d9bc4",
          partB: ((_d = this.settings) == null ? void 0 : _d.part_b_color) ? (_e = this.settings) == null ? void 0 : _e.part_b_color : "#065d7a",
          partHover: ((_f = this.settings) == null ? void 0 : _f.part_hover_color) ? (_g = this.settings) == null ? void 0 : _g.part_hover_color : "#f8b029",
          partSelected: ((_h = this.settings) == null ? void 0 : _h.part_selected_color) ? (_i = this.settings) == null ? void 0 : _i.part_selected_color : "#5bc85b",
          stock: ((_j = this.settings) == null ? void 0 : _j.stock_color) ? (_k = this.settings) == null ? void 0 : _k.stock_color : "#ffd166",
          button: ((_l = this.settings) == null ? void 0 : _l.button_color) ? (_m = this.settings) == null ? void 0 : _m.button_color : "#118ab2",
          buttonText: ((_n = this.settings) == null ? void 0 : _n.button_text_color) ? (_o = this.settings) == null ? void 0 : _o.button_text_color : "#ffffff",
          text: ((_p = this.settings) == null ? void 0 : _p.text_color) ? (_q = this.settings) == null ? void 0 : _q.text_color : "#ffffff"
        }
      };
      const machining = {
        units: "decimal",
        sides: {
          enabled: this.settings.machining_sides
        },
        holes: {
          enabled: this.settings.machining_holes,
          defaultDiameter: this.settings.machining_holes_default_diameter,
          diameters: this.settings.machining_holes_diameters.split(",").map((v) => v.trim()).filter((v) => v),
          minDiameter: this.settings.machining_holes_min_diameter,
          maxDiameter: this.settings.machining_holes_max_diameter,
          enableDepth: this.settings.machining_holes_depth,
          depths: this.settings.machining_holes_depths.split(",").map((v) => v.trim()).filter((v) => v),
          defaultDepth: this.settings.machining_holes_default_depth,
          minDepth: this.settings.machining_holes_min_depth,
          maxDepth: this.settings.machining_holes_max_depth
        },
        hingeHoles: {
          enabled: this.settings.machining_hinge_holes,
          minimumHoleDistance: this.settings.machining_hinge_holes_minimum_hole_distance,
          defaultDistanceFromEdge: this.settings.machining_hinge_holes_default_distance_from_edge,
          defaultOuterSpacing: this.settings.machining_hinge_holes_default_outer_spacing,
          defaultHingeLength: this.settings.machining_hinge_holes_default_hinge_length
        },
        corners: {
          enabled: this.settings.machining_radius_corners || this.settings.machining_bevel_corners,
          types: [
            this.settings.machining_radius_corners ? "radius" : null,
            this.settings.machining_bevel_corners ? "bevel" : null
          ].filter((v) => v),
          minValue: this.settings.machining_corners_min_value,
          maxValue: this.settings.machining_corners_max_value,
          enableBanding: this.settings.machining_corners_enable_banding
        },
        banding: {
          enabled: !this.settings.disable_banding && ((_s = (_r = window.smartcutConfig) == null ? void 0 : _r.banding_data) == null ? void 0 : _s.length) ? true : false,
          enableCorners: this.settings.machining_corners_enable_banding,
          types: window.smartcutConfig.banding_data ? Object.values(window.smartcutConfig.banding_data).map((option) => option.name) : [],
          enableTypes: ((_t = window.smartcutConfig) == null ? void 0 : _t.banding_data) ? true : false
        }
      };
      const calculator = getRef.call(this, "calculator");
      if (calculator) {
        calculator.init({
          type: this.product.type,
          stock: this.stock,
          variations: this.variations ?? null,
          options,
          banding,
          machining
        });
      }
    },
    formatPrice(price = 0, locale2 = false) {
      if (!price) {
        if (!locale2) return "0.00";
        return this.addCurrencySymbol("0.00");
      }
      if (typeof price === "string") price = parseFloat(price);
      const formattedPrice = price.toFixed(this.formatting.number_of_decimals).replace(".", this.formatting.decimal_separator);
      if (!locale2) return formattedPrice;
      return this.addCurrencySymbol(formattedPrice);
    },
    addCurrencySymbol(price) {
      switch (this.formatting.currency_position) {
        case "left":
          return `${this.formatting.currency_symbol}${price}`;
        case "right":
          return `${price}${this.formatting.currency_symbol}`;
        default:
          return `${this.formatting.currency_symbol}${price}`;
      }
    },
    configureProduct(smartcutConfig) {
      const multiple_sizes = (smartcutConfig == null ? void 0 : smartcutConfig.multiple_sizes) === "1";
      this.product = {
        type: smartcutConfig == null ? void 0 : smartcutConfig.product_type,
        multiple_sizes,
        size: (smartcutConfig == null ? void 0 : smartcutConfig.size) ? smartcutConfig.size.split(" | ") : [],
        l: !multiple_sizes && (smartcutConfig == null ? void 0 : smartcutConfig.l) ? this.parseFloat(smartcutConfig.l) : null,
        w: !multiple_sizes && (smartcutConfig == null ? void 0 : smartcutConfig.w) ? this.parseFloat(smartcutConfig.w) : null,
        t: (smartcutConfig == null ? void 0 : smartcutConfig.t) ?? null
        //do not parse to allow for multiple thicknesses separated by a comma
      };
      this.product.stock_name = smartcutConfig.stock_name;
      if (!this.product.multiple_sizes) {
        if (!this.product.l) {
          this.error("product 'length' attribute not available");
        }
        if (!this.product.w) {
          this.error("product 'width' attribute not available");
        }
      }
    },
    configurePricing(smartcutConfig) {
      this.formatting = {
        thousands_separator: smartcutConfig == null ? void 0 : smartcutConfig.thousands_separator,
        decimal_separator: smartcutConfig == null ? void 0 : smartcutConfig.decimal_separator,
        number_of_decimals: smartcutConfig == null ? void 0 : smartcutConfig.number_of_decimals,
        currency_symbol: smartcutConfig == null ? void 0 : smartcutConfig.currency_symbol,
        currency_position: smartcutConfig == null ? void 0 : smartcutConfig.currency_position
      };
    },
    cacheElements() {
      this.el.checkout = document.getElementById("smartcut-app");
      if (!this.el.checkout)
        return this.error("checkout iframe not found");
      this.el.intro_text = document.getElementById("smartcut-intro-text");
      this.el.pricing_table = document.getElementById("smartcut-pricing-table");
      this.el.offcuts = document.getElementById("include_offcuts_field");
      this.el.banding_key = document.getElementById("smartcut-banding-key");
      this.el.banding_total_price = document.querySelector("#smartcut-banding-total bdi .smartcut-price-selector");
      this.el.cut_length_price = document.querySelector("#smartcut-cut-length-total bdi .smartcut-price-selector");
      this.el.per_part_price = document.querySelector("#smartcut-per-part-total bdi .smartcut-price-selector");
      this.el.surcharge_price = document.querySelector("#smartcut-surcharge-total bdi .smartcut-price-selector");
      this.el.machining_total_price = document.querySelector("#smartcut-machining-total bdi .smartcut-price-selector");
      this.el.quantity = document.querySelector(".smartcut-stock-quantity");
      this.el.cart_button = document.querySelector(".single_add_to_cart_button");
      if (!this.el.quantity)
        return this.error("quantity field not found");
      if (!this.el.cart_button)
        return this.error("cart button not found");
      this.el.quantity.readOnly = true;
      this.el.cart_button.disabled = true;
    },
    getStockTrim() {
      const trim = {
        x1: this.settings.stock_trim_x1 ?? 0,
        x2: this.settings.stock_trim_x2 ?? 0,
        y1: this.settings.stock_type === "linear" ? 0 : this.settings.stock_trim_y1 ?? 0,
        y2: this.settings.stock_type === "linear" ? 0 : this.settings.stock_trim_y2 ?? 0
      };
      return trim;
    },
    createStock(l = null, w = null, t2 = null, cost = null, attributes = null) {
      let notes;
      if (attributes && typeof attributes === "object") {
        notes = [];
        if (attributes && typeof attributes === "object") {
          for (const [key, value2] of Object.entries(attributes)) {
            if (key === "attribute_size") continue;
            if (key === "attribute_thickness") continue;
            notes.push(`${key.replace("attribute_", "")}: ${value2}`);
          }
        }
        notes = notes.join(" - ");
      }
      const stock = {
        name: this.product.stock_name,
        type: this.settings.stock_type,
        l,
        w,
        t: t2,
        cost: parseFloat(cost),
        trim: this.getStockTrim(),
        notes
      };
      return stock;
    },
    configureStock() {
      var _a2, _b;
      if (!((_a2 = this.product) == null ? void 0 : _a2.stock_name))
        this.error("product name not specified");
      if (this.product.type === "variable") {
        this.disableCutToSize();
      } else {
        this.enableCutToSize();
        this.stock = [];
        if (this.product.multiple_sizes) {
          this.product.size.forEach((size2) => {
            var _a3;
            const [l, w] = size2.split("x");
            const newStock = this.createStock(
              l,
              w,
              (_a3 = this.product) == null ? void 0 : _a3.t,
              size2.price
            );
            this.stock.push(newStock);
          });
        } else {
          this.stock.push(this.createStock(
            this.product.l,
            this.product.w,
            (_b = this.product) == null ? void 0 : _b.t
          ));
        }
      }
    },
    formatBandingKey(key) {
      return truncateString(sanitiseString(key), 100).replace("|", "_");
    },
    //map the banding data into options and ensure the keys are formatted correctly
    getBandingOptions(bandingData) {
      if (!bandingData) return null;
      const bandingOptions = {};
      for (const data of Object.values(bandingData)) {
        const options = data == null ? void 0 : data.options;
        const variations = data == null ? void 0 : data.variations;
        if (!variations) {
          if ("simple" in bandingOptions) {
            bandingOptions.simple.push(...Object.values(options).flat());
          } else {
            bandingOptions.simple = Object.values(options).flat();
          }
          continue;
        }
        for (const [optionName, theseOptions] of Object.entries(options)) {
          bandingOptions[optionName] = Array.isArray(theseOptions) ? theseOptions : [theseOptions];
        }
      }
      for (const [key, options] of Object.entries(bandingOptions)) {
        bandingOptions[key] = options.map((o2) => this.formatBandingKey(o2));
      }
      return bandingOptions;
    },
    //find the price of a banding option based on an array of options
    findBandingPrice(selectedBandingOptions) {
      const allVariations = Object.values(this.bandingData).map((i) => {
        if (i == null ? void 0 : i.variations) {
          return Object.values(i.variations);
        } else {
          return i;
        }
      }).flat();
      const foundVariation = allVariations.find((variation) => {
        const variationOptions = Object.values(variation.options);
        if (!variationOptions) return false;
        return selectedBandingOptions.every((option, index) => {
          const variationOption = variationOptions == null ? void 0 : variationOptions[index];
          if (!variationOption) return false;
          if (this.formatBandingKey(variationOption) === selectedBandingOptions[index]) {
            return true;
          } else {
            return false;
          }
        });
      });
      if (foundVariation) {
        return foundVariation.price;
      } else {
        return null;
      }
    },
    //get the total price of the banding based on the bandingLengthByType metadata
    getTotalBandingPrice(totalBanding) {
      var _a2;
      let total = 0;
      if (typeof totalBanding === "object") {
        for (let [bandingKey, length2] of Object.entries(totalBanding)) {
          if (typeof length2 === "string") length2 = parseFloat(length2);
          const bandingOptions = bandingKey.split("|");
          const price = this.findBandingPrice(bandingOptions);
          if (price === null) continue;
          const cost = length2 / (this.settings.units === "fraction" ? 12 : 1e3) * parseFloat(price);
          total += cost;
        }
        if ("min_banding_charge" in this.settings) {
          const minBandingCharge = parseFloat((_a2 = this.settings) == null ? void 0 : _a2.min_banding_charge);
          if (minBandingCharge > 0) {
            if (total > 0 && total < minBandingCharge) {
              return minBandingCharge;
            }
          }
        }
        return total;
      } else {
        return 0;
      }
    },
    getTotalMachiningPrice(data) {
      const total = (this.machiningPricing.holes ?? 0) * (data.metadata.numHoles ?? 0) + (this.machiningPricing.corners ?? 0) * (data.metadata.numCorners ?? 0);
      return total;
    },
    reset() {
      this.el.quantity.value = 1;
      this.el.cart_button.disabled = true;
      this.inputs["smartcut-cut-to-size-surcharge"].value = 0;
      if (this.el.banding_total_price) {
        this.el.banding_total_price.innerText = this.formatPrice(0);
      }
      if (this.el.machining_total_price) {
        this.el.machining_total_price.innerText = this.formatPrice(0);
      }
      if (this.el.cut_length_price) {
        this.el.cut_length_price.innerText = this.formatPrice(0);
      }
      if (this.el.per_part_price) {
        this.el.per_part_price.innerText = this.formatPrice(0);
      }
      for (const key in this.inputs) {
        this.inputs[key].value = null;
      }
    },
    error(message) {
      console.error(`SmartCut - ${message}`);
      return;
    },
    isQuantityPricing() {
      var _a2;
      if (((_a2 = window.smartcutConfig) == null ? void 0 : _a2.product_type) === "variable")
        return false;
      switch (this.settings.pricing_strategy) {
        case "full_sheet":
        case "full_sheet_plus_cut_length":
        case "full_sheet_plus_num_parts":
          return true;
      }
      return false;
    },
    isBandingEnabled() {
      var _a2;
      if (((_a2 = this.settings) == null ? void 0 : _a2.disable_banding) === true) return false;
      if (!this.bandingData || !Object.values(this.bandingData).length)
        return false;
      return true;
    },
    isMachiningEnabled() {
      if (this.settings.enable_machining === true) return true;
      return false;
    },
    isSurchargeEnabled() {
      var _a2, _b;
      if (((_a2 = this.settings) == null ? void 0 : _a2.surcharge_type) === "none") return false;
      if (!((_b = this == null ? void 0 : this.settings) == null ? void 0 : _b.surcharge) || this.settings.surcharge === "0.00")
        return false;
      return true;
    },
    isPricingTableNeeded() {
      if (this.settings.pricing_strategy === "full_sheet_plus_cut_length")
        return true;
      if (this.settings.pricing_strategy === "full_sheet_plus_num_parts")
        return true;
      if (this.isSurchargeEnabled()) return true;
      if (this.isBandingEnabled()) return true;
      if (this.isMachiningEnabled()) return true;
      return false;
    },
    /**
           * @param {WC_Product_Variation} variation
           * @returns {string[] | string}
           */
    getSizes(variation) {
      var _a2, _b;
      let sizes = null;
      if (variation) {
        sizes = (_a2 = variation == null ? void 0 : variation.attributes) == null ? void 0 : _a2.attribute_size;
      }
      if (!sizes) sizes = (_b = this.product) == null ? void 0 : _b.size;
      return sizes;
    },
    isFullSheetSize(size2) {
      return /\d+x\d+/.test(size2);
    },
    cacheInputFields() {
      window.smartcutConfig.input_fields.forEach((f) => {
        const fieldId = f.replaceAll("_", "-");
        this.inputs[fieldId] = document.getElementById(fieldId);
      });
    },
    result(data) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      this.reset();
      const quantityPricing = this.isQuantityPricing();
      let totalPrice = quantityPricing ? data.metadata.totalStockCost / data.metadata.totalUsedStock : 0;
      this.log(["result event received", data]);
      if (!(data == null ? void 0 : data.jobId)) return;
      if (this.product.multiple_sizes) {
        this.log(["result event received for multiple sizes"]);
      }
      switch (this.settings.pricing_strategy) {
        case "full_sheet":
          {
            this.log(["calculating cost by full sheet"]);
            if (!quantityPricing) {
              this.el.quantity.value = 1;
            } else {
              this.el.quantity.value = data.metadata.totalUsedStock;
            }
            this.el.cart_button.disabled = false;
          }
          break;
        case "part_area":
          {
            this.log([
              "calculating cost by part area in meters / sq feet"
            ]);
            const area = this.settings.units === "fraction" ? data.metadata.totalPartArea / 144 : data.metadata.totalPartArea / 1e6;
            this.log([
              `part area in square ${this.settings.units === "fraction" ? "feet" : "meters"}`,
              area
            ]);
            this.el.quantity.value = area.toFixed(2);
            this.el.cart_button.disabled = false;
          }
          break;
        case "cut_length":
          {
            this.log([
              "calculating cost by cut length in feet / meters"
            ]);
            const cutLength = data.metadata.totalCutLength / (this.settings.units === "fraction" ? 12 : 1e3);
            this.el.quantity.value = cutLength.toFixed(2);
            this.el.cart_button.disabled = false;
          }
          break;
        case "full_sheet_plus_cut_length":
          {
            this.log([
              "calculating cost by full sheet plus cut length"
            ]);
            if (!quantityPricing) {
              this.el.quantity.value = 1;
              this.el.quantity.style.display = "none";
            } else {
              this.el.quantity.style.display = "inline-block";
              this.el.quantity.value = data.metadata.totalUsedStock;
            }
            const cutLength = data.metadata.totalCutLength / (this.settings.units === "fraction" ? 12 : 1e3);
            const cutLengthTotal = cutLength * this.settings.cut_length_price;
            if (this.el.cut_length_price) {
              this.el.cut_length_price.innerText = this.formatPrice(cutLengthTotal);
            }
            this.inputs["smartcut-cut-length-price"].value = cutLengthTotal;
            totalPrice += cutLengthTotal;
            this.el.cart_button.disabled = false;
          }
          break;
        case "full_sheet_plus_num_parts":
          {
            this.log([
              "calculating cost by full sheet plus number of parts"
            ]);
            if (!quantityPricing) {
              this.el.quantity.value = 1;
              this.el.quantity.style.display = "none";
            } else {
              this.el.quantity.style.display = "inline-block";
              this.el.quantity.value = data.metadata.totalUsedStock;
            }
            const partPrice = data.metadata.totalPartsProduced * this.settings.per_part_price;
            if (this.el.per_part_price) {
              this.el.per_part_price.innerText = this.formatPrice(partPrice);
            }
            this.inputs["smartcut-per-part-price"].value = partPrice;
            totalPrice += partPrice;
            this.el.cart_button.disabled = false;
          }
          break;
      }
      if (!quantityPricing) {
        if (!data.metadata.totalStockCost) {
          return this.error("Total stock cost not returned for a multiple size product");
        }
        const sizePrice = parseFloat(data.metadata.totalStockCost);
        this.log(["total price", sizePrice]);
        document.getElementById("smartcut-custom-price").value = sizePrice.toString();
        totalPrice += sizePrice;
      }
      if (this.isBandingEnabled()) {
        const bandingPrice = this.getTotalBandingPrice(data.metadata.bandingLengthByType);
        if ((_a2 = this.inputs) == null ? void 0 : _a2["smartcut-banding-price"]) {
          this.inputs["smartcut-banding-price"].value = bandingPrice;
        }
        if (this.el.banding_total_price) {
          this.el.banding_total_price.innerText = this.formatPrice(bandingPrice);
        }
        totalPrice += bandingPrice;
      }
      if (this.isMachiningEnabled()) {
        const machiningPrice = this.getTotalMachiningPrice(data);
        if ((_b = this.inputs) == null ? void 0 : _b["smartcut-machining-price"]) {
          this.inputs["smartcut-machining-price"].value = machiningPrice;
        }
        if (this.el.machining_total_price) {
          this.el.machining_total_price.innerText = this.formatPrice(machiningPrice);
        }
        totalPrice += machiningPrice;
      }
      if (this.isSurchargeEnabled()) {
        if ((_c = this.settings) == null ? void 0 : _c.surcharge) {
          let surCharge = 0;
          if (((_d = this.settings) == null ? void 0 : _d.surcharge_type) === "per_sheet") {
            surCharge = parseFloat((_e = this.settings) == null ? void 0 : _e.surcharge) * parseFloat(data.metadata.totalUsedStock);
          } else {
            surCharge = parseFloat((_f = this.settings) == null ? void 0 : _f.surcharge);
          }
          if ((_g = this.inputs) == null ? void 0 : _g["smartcut-cut-to-size-surcharge"]) {
            this.inputs["smartcut-cut-to-size-surcharge"].value = surCharge;
          }
          if (this.el.surcharge_price) {
            this.el.surcharge_price.innerText = this.formatPrice(surCharge);
          }
          this.log(["added surcharge", surCharge]);
          totalPrice += surCharge;
        }
      }
      const variationPriceEl = document.querySelector(".woocommerce-variation-price .smartcut-price-selector");
      if (variationPriceEl) {
        variationPriceEl.innerText = this.formatPrice(totalPrice);
      }
      const hiddenFields = {
        "smartcut-job-id": null,
        "smartcut-dimensions": null,
        "smartcut-total-cut-length": "totalCutLength",
        "smartcut-part-area": "totalPartArea",
        "smartcut-total-cuts": "totalCuts",
        "smartcut-total-parts": "totalPartsProduced",
        "smartcut-machining": "hasMachining"
      };
      if ((_h = this.inputs) == null ? void 0 : _h["smartcut-job-id"]) {
        this.inputs["smartcut-job-id"].value = data == null ? void 0 : data.jobId;
      }
      if ((_i = this.inputs) == null ? void 0 : _i["smartcut-dimensions"]) {
        const dimensions = data == null ? void 0 : data.parts.map((p2) => `${p2 == null ? void 0 : p2.l}x${p2 == null ? void 0 : p2.w} [${p2 == null ? void 0 : p2.q}]`).join(", ");
        this.inputs["smartcut-dimensions"].value = dimensions;
      }
      if ((_j = this.inputs) == null ? void 0 : _j["smartcut-stock-summary"]) {
        let stockSummary = "";
        stockSummary = data.stock.map((s) => `${s == null ? void 0 : s.l}x${s == null ? void 0 : s.w}${(s == null ? void 0 : s.t) ? "x" + s.t : ""} [${s == null ? void 0 : s.q}]`).join(", ");
        this.inputs["smartcut-stock-summary"].value = stockSummary;
      }
      const hiddenFieldsWithValue = Object.entries(hiddenFields).filter(([, value2]) => value2 !== null).map(([field]) => field);
      hiddenFieldsWithValue.forEach((field) => {
        var _a3;
        if ((_a3 = this.inputs) == null ? void 0 : _a3[field]) {
          this.inputs[field].value = data.metadata[hiddenFields[field]];
        }
      });
    }
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CheckoutCalculator = resolveComponent("CheckoutCalculator");
  return openBlock(), createBlock(_component_CheckoutCalculator, {
    ref: "calculator",
    debug: $data.debug,
    stock: $data.stock,
    units: $options.smartcutConfigUnits,
    onLog: $options.log,
    onError: $options.error,
    onDebug: $options.toggleDebug,
    onResult: $options.result
  }, null, 8, ["debug", "stock", "units", "onLog", "onError", "onDebug", "onResult"]);
}
const Wordpress = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const Vanilla = /* @__PURE__ */ defineAsyncComponent(() => import("./Vanilla-DOelkE19.js"));
const _sfc_main = /* @__PURE__ */ defineComponent({
  name: "Launch",
  components: {
    Wordpress,
    Vanilla
  },
  //props are passed from main.ts
  props: {
    type: {
      type: String,
      default: ""
    }
  },
  computed: {
    currentComponent() {
      return this.type.charAt(0).toUpperCase() + this.type.slice(1);
    }
  }
  //these will be exposed on window.smartcutCheckout
  /* methods: {
  	test()
  	{
  		console.log( 'test' );
  	}
  } */
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.currentComponent), { ref: "checkout" }, null, 512);
}
const Launch = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const noop = () => {
};
let _WINDOW = {};
let _DOCUMENT = {};
let _MUTATION_OBSERVER = null;
let _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e) {
}
const {
  userAgent = ""
} = _WINDOW.navigator || {};
const WINDOW = _WINDOW;
const DOCUMENT = _DOCUMENT;
const MUTATION_OBSERVER = _MUTATION_OBSERVER;
const PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
const IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
const IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var a = "classic", t = "duotone", r = "sharp", o = "sharp-duotone", c = [a, t, r, o];
var et$1 = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds"
  }
};
var bt = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, Ct = ["kit"];
var Dt = /fa(s|r|l|t|d|b|k|kd|ss|sr|sl|st|sds)?[\-\ ]/, Kt = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
var ao = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
var eo = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds"
  }
}, lo = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds"
  }
}, y = {
  classic: ["fas", "far", "fal", "fat"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds"]
}, no = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid"
  }
}, fo = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds"
  }
}, ho = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid"
  }
}, x$1 = ["solid", "regular", "light", "thin", "duotone", "brands"], u$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m$1 = u$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), t$1 = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, yo = [...Object.keys(y), ...x$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(u$1.map((o2) => "".concat(o2, "x"))).concat(m$1.map((o2) => "w-".concat(o2)));
var mo = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, Io = {
  kit: {
    "fa-kit": "fak"
  },
  "kit-duotone": {
    "fa-kit-duotone": "fakd"
  }
}, Fo = {
  kit: {
    fak: "fa-kit"
  },
  "kit-duotone": {
    fakd: "fa-kit-duotone"
  }
}, So = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
const NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
const UNITS_IN_GRID = 16;
const DEFAULT_CSS_PREFIX = "fa";
const DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
const DATA_FA_I2SVG = "data-fa-i2svg";
const DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
const DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
const DATA_PREFIX = "data-prefix";
const DATA_ICON = "data-icon";
const HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
const MUTATION_APPROACH_ASYNC = "async";
const TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
const PRODUCTION$1 = (() => {
  try {
    return true;
  } catch (e$$1) {
    return false;
  }
})();
const FAMILIES = [a, r, o];
function familyProxy(obj) {
  return new Proxy(obj, {
    get(target, prop) {
      return prop in target ? target[prop] : target[a];
    }
  });
}
const _PREFIX_TO_STYLE = {
  ...ho
};
_PREFIX_TO_STYLE[a] = {
  ...ho[a],
  ...bt["kit"],
  ...bt["kit-duotone"]
};
const PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
const _STYLE_TO_PREFIX = {
  ...fo
};
_STYLE_TO_PREFIX[a] = {
  ..._STYLE_TO_PREFIX[a],
  ...So["kit"],
  ...So["kit-duotone"]
};
const STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
const _PREFIX_TO_LONG_STYLE = {
  ...no
};
_PREFIX_TO_LONG_STYLE[a] = {
  ..._PREFIX_TO_LONG_STYLE[a],
  ...Fo["kit"]
};
const PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
const _LONG_STYLE_TO_PREFIX = {
  ...lo
};
_LONG_STYLE_TO_PREFIX[a] = {
  ..._LONG_STYLE_TO_PREFIX[a],
  ...Io["kit"]
};
const LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
const ICON_SELECTION_SYNTAX_PATTERN = Dt;
const LAYERS_TEXT_CLASSNAME = "fa-layers-text";
const FONT_FAMILY_PATTERN = Kt;
const _FONT_WEIGHT_TO_PREFIX = {
  ...et$1
};
familyProxy(_FONT_WEIGHT_TO_PREFIX);
const ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
const DUOTONE_CLASSES = t$1;
const prefixes = /* @__PURE__ */ new Set();
Object.keys(STYLE_TO_PREFIX[a]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[r]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[o]).map(prefixes.add.bind(prefixes));
const RESERVED_CLASSES = [...Ct, ...yo];
const initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  const attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach((_ref) => {
    let [attr, key] = _ref;
    const val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
const _default = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
const _config = {
  ..._default,
  ...initial
};
if (!_config.autoReplaceSvg) _config.observeMutations = false;
const config = {};
Object.keys(_default).forEach((key) => {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function(val) {
      _config[key] = val;
      _onChangeCb.forEach((cb) => cb(config));
    },
    get: function() {
      return _config[key];
    }
  });
});
Object.defineProperty(config, "familyPrefix", {
  enumerable: true,
  set: function(val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach((cb) => cb(config));
  },
  get: function() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
const _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return () => {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
const d$2 = UNITS_IN_GRID;
const meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  const style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css2;
  const headChildren = DOCUMENT.head.childNodes;
  let beforeChild = null;
  for (let i = headChildren.length - 1; i > -1; i--) {
    const child = headChildren[i];
    const tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css2;
}
const idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  let size2 = 12;
  let id = "";
  while (size2-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function toArray(obj) {
  const array2 = [];
  for (let i = (obj || []).length >>> 0; i--; ) {
    array2[i] = obj[i];
  }
  return array2;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute("class") || "").split(" ").filter((i) => i);
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce((acc, attributeName) => {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce((acc, styleName) => {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform2) {
  return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
}
function transformForSvg(_ref) {
  let {
    transform: transform2,
    containerWidth,
    iconWidth
  } = _ref;
  const outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  const innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
  const innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
  const innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
  const inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  const path2 = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path: path2
  };
}
function transformForCss(_ref2) {
  let {
    transform: transform2,
    width = UNITS_IN_GRID,
    height = UNITS_IN_GRID,
    startCentered = false
  } = _ref2;
  let val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform2.x / d$2 - width / 2, "em, ").concat(transform2.y / d$2 - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform2.x / d$2, "em), calc(-50% + ").concat(transform2.y / d$2, "em)) ");
  } else {
    val += "translate(".concat(transform2.x / d$2, "em, ").concat(transform2.y / d$2, "em) ");
  }
  val += "scale(".concat(transform2.size / d$2 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / d$2 * (transform2.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform2.rotate, "deg) ");
  return val;
}
var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
function css() {
  const dcp = DEFAULT_CSS_PREFIX;
  const drc = DEFAULT_REPLACEMENT_CLASS;
  const fp = config.cssPrefix;
  const rc = config.replacementClass;
  let s = baseStyles;
  if (fp !== dcp || rc !== drc) {
    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    const rPatt = new RegExp("\\.".concat(drc), "g");
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s;
}
let _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout() {
    return {
      dom: {
        css,
        insertCss: ensureCss
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg() {
        ensureCss();
      }
    };
  }
};
const w$1 = WINDOW || {};
if (!w$1[NAMESPACE_IDENTIFIER]) w$1[NAMESPACE_IDENTIFIER] = {};
if (!w$1[NAMESPACE_IDENTIFIER].styles) w$1[NAMESPACE_IDENTIFIER].styles = {};
if (!w$1[NAMESPACE_IDENTIFIER].hooks) w$1[NAMESPACE_IDENTIFIER].hooks = {};
if (!w$1[NAMESPACE_IDENTIFIER].shims) w$1[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w$1[NAMESPACE_IDENTIFIER];
const functions = [];
const listener = function() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener);
  loaded = 1;
  functions.map((fn) => fn());
};
let loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
function domready(fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}
function toHtml(abstractNodes) {
  const {
    tag,
    attributes = {},
    children: children2 = []
  } = abstractNodes;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children2.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix,
      iconName,
      icon: mapping[prefix][iconName]
    };
  }
}
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length2 = keys.length, iterator2 = fn, i, key, result;
  if (initialValue === void 0) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }
  for (; i < length2; i++) {
    key = keys[i];
    result = iterator2(result, subject[key], key, subject);
  }
  return result;
};
function ucs2decode(string2) {
  const output = [];
  let counter2 = 0;
  const length2 = string2.length;
  while (counter2 < length2) {
    const value2 = string2.charCodeAt(counter2++);
    if (value2 >= 55296 && value2 <= 56319 && counter2 < length2) {
      const extra = string2.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value2);
        counter2--;
      }
    } else {
      output.push(value2);
    }
  }
  return output;
}
function toHex(unicode) {
  const decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string2, index) {
  const size2 = string2.length;
  let first = string2.charCodeAt(index);
  let second;
  if (first >= 55296 && first <= 56319 && size2 > index + 1) {
    second = string2.charCodeAt(index + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce((acc, iconName) => {
    const icon2 = icons[iconName];
    const expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
}
function defineIcons(prefix, icons) {
  let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks = false
  } = params;
  const normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = {
      ...namespace.styles[prefix] || {},
      ...normalized
    };
  }
  if (prefix === "fas") {
    defineIcons("fa", icons);
  }
}
const {
  styles,
  shims
} = namespace;
const LONG_STYLE = {
  [a]: Object.values(PREFIX_TO_LONG_STYLE[a]),
  [r]: Object.values(PREFIX_TO_LONG_STYLE[r]),
  [o]: Object.values(PREFIX_TO_LONG_STYLE[o])
};
let _defaultUsablePrefix = null;
let _byUnicode = {};
let _byLigature = {};
let _byOldName = {};
let _byOldUnicode = {};
let _byAlias = {};
const PREFIXES = {
  [a]: Object.keys(PREFIX_TO_STYLE[a]),
  [r]: Object.keys(PREFIX_TO_STYLE[r]),
  [o]: Object.keys(PREFIX_TO_STYLE[o])
};
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  const parts2 = cls.split("-");
  const prefix = parts2[0];
  const iconName = parts2.slice(1).join("-");
  if (prefix === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
const build = () => {
  const lookup2 = (reducer) => {
    return reduce(styles, (o$$1, style, prefix) => {
      o$$1[prefix] = reduce(style, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup2((acc, icon2, iconName) => {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "number";
      });
      aliases.forEach((alias2) => {
        acc[alias2.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup2((acc, icon2, iconName) => {
    acc[iconName] = iconName;
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "string";
      });
      aliases.forEach((alias2) => {
        acc[alias2] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup2((acc, icon2, iconName) => {
    const aliases = icon2[2];
    acc[iconName] = iconName;
    aliases.forEach((alias2) => {
      acc[alias2] = iconName;
    });
    return acc;
  });
  const hasRegular = "far" in styles || config.autoFetchSvg;
  const shimLookups = reduce(shims, (acc, shim) => {
    const maybeNameMaybeUnicode = shim[0];
    let prefix = shim[1];
    const iconName = shim[2];
    if (prefix === "far" && !hasRegular) {
      prefix = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange((c$$1) => {
  _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias2) {
  return (_byAlias[prefix] || {})[alias2];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  const oldUnicode = _byOldUnicode[unicode];
  const newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
const emptyCanonicalIcon = () => {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family = a
  } = params;
  const style = PREFIX_TO_STYLE[family][styleOrPrefix];
  const prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
  const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  const result = prefix || defined || null;
  return result;
}
const PREFIXES_FOR_FAMILY = {
  [a]: Object.keys(PREFIX_TO_LONG_STYLE[a]),
  [r]: Object.keys(PREFIX_TO_LONG_STYLE[r]),
  [o]: Object.keys(PREFIX_TO_LONG_STYLE[o])
};
function getCanonicalIcon(values) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups = false
  } = params;
  const famProps = {
    [a]: "".concat(config.cssPrefix, "-").concat(a),
    [r]: "".concat(config.cssPrefix, "-").concat(r),
    [o]: "".concat(config.cssPrefix, "-").concat(o)
  };
  let givenPrefix = null;
  let family = a;
  const nonDuotoneFamilyIds = c.filter((familyId) => familyId !== t);
  nonDuotoneFamilyIds.forEach((familyId) => {
    if (values.includes(famProps[familyId]) || values.some((v$$1) => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
      family = familyId;
    }
  });
  const canonical = values.reduce((acc, cls) => {
    const iconName = getIconName(config.cssPrefix, cls);
    if (styles[cls]) {
      cls = LONG_STYLE[family].includes(cls) ? LONG_STYLE_TO_PREFIX[family][cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES[family].indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls, {
        family
      });
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass && !nonDuotoneFamilyIds.some((familyName) => cls === famProps[familyName])) {
      acc.rest.push(cls);
    }
    if (!skipLookups && acc.prefix && acc.iconName) {
      const shim = givenPrefix === "fa" ? byOldName(acc.iconName) : {};
      const aliasIconName = byAlias(acc.prefix, acc.iconName);
      if (shim.prefix) {
        givenPrefix = null;
      }
      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;
      if (acc.prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
        acc.prefix = "fas";
      }
    }
    return acc;
  }, emptyCanonicalIcon());
  if (values.includes("fa-brands") || values.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (values.includes("fa-duotone") || values.includes("fad")) {
    canonical.prefix = "fad";
  }
  if (!canonical.prefix && family === r && (styles["fass"] || config.autoFetchSvg)) {
    canonical.prefix = "fass";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (!canonical.prefix && family === o && (styles["fasds"] || config.autoFetchSvg)) {
    canonical.prefix = "fasds";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
class Library {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
      definitions[_key] = arguments[_key];
    }
    const additions = definitions.reduce(this._pullDefinitions, {});
    Object.keys(additions).forEach((key) => {
      this.definitions[key] = {
        ...this.definitions[key] || {},
        ...additions[key]
      };
      defineIcons(key, additions[key]);
      const longPrefix = PREFIX_TO_LONG_STYLE[a][key];
      if (longPrefix) defineIcons(longPrefix, additions[key]);
      build();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(additions, definition) {
    const normalized = definition.prefix && definition.iconName && definition.icon ? {
      0: definition
    } : definition;
    Object.keys(normalized).map((key) => {
      const {
        prefix,
        iconName,
        icon: icon2
      } = normalized[key];
      const aliases = icon2[2];
      if (!additions[prefix]) additions[prefix] = {};
      if (aliases.length > 0) {
        aliases.forEach((alias2) => {
          if (typeof alias2 === "string") {
            additions[prefix][alias2] = icon2;
          }
        });
      }
      additions[prefix][iconName] = icon2;
    });
    return additions;
  }
}
let _plugins = [];
let _hooks = {};
const providers = {};
const defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref) {
  let {
    mixoutsTo: obj
  } = _ref;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach((k) => {
    if (defaultProviderKeys.indexOf(k) === -1) {
      delete providers[k];
    }
  });
  _plugins.forEach((plugin) => {
    const mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach((tk) => {
      if (typeof mixout[tk] === "function") {
        obj[tk] = mixout[tk];
      }
      if (typeof mixout[tk] === "object") {
        Object.keys(mixout[tk]).forEach((sk) => {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      const hooks = plugin.hooks();
      Object.keys(hooks).forEach((hook) => {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    accumulator = hookFn.apply(null, [accumulator, ...args]);
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  const hook = arguments[0];
  const args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  let {
    iconName
  } = iconLookup;
  const prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
const library = new Library();
const noAuto = () => {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks("noAuto");
};
const dom = {
  i2svg: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject(new Error("Operation requires a DOM of some kind."));
    }
  },
  watch: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot
    } = params;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(() => {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks("watch", params);
    });
  }
};
const parse = {
  icon: (icon2) => {
    if (icon2 === null) {
      return null;
    }
    if (typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
      return {
        prefix: icon2.prefix,
        iconName: byAlias(icon2.prefix, icon2.iconName) || icon2.iconName
      };
    }
    if (Array.isArray(icon2) && icon2.length === 2) {
      const iconName = icon2[1].indexOf("fa-") === 0 ? icon2[1].slice(3) : icon2[1];
      const prefix = getCanonicalPrefix(icon2[0]);
      return {
        prefix,
        iconName: byAlias(prefix, iconName) || iconName
      };
    }
    if (typeof icon2 === "string" && (icon2.indexOf("".concat(config.cssPrefix, "-")) > -1 || icon2.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      const canonicalIcon = getCanonicalIcon(icon2.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof icon2 === "string") {
      const prefix = getDefaultUsablePrefix();
      return {
        prefix,
        iconName: byAlias(prefix, icon2) || icon2
      };
    }
  }
};
const api = {
  noAuto,
  config,
  dom,
  parse,
  library,
  findIconDefinition,
  toHtml
};
const autoReplace = function() {
  let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot = DOCUMENT
  } = params;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function() {
      return val.abstract.map((a2) => toHtml(a2));
    }
  });
  Object.defineProperty(val, "node", {
    get: function() {
      if (!IS_DOM) return;
      const container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref) {
  let {
    children: children2,
    main,
    mask,
    attributes,
    styles: styles2,
    transform: transform2
  } = _ref;
  if (transformIsMeaningful(transform2) && main.found && !mask.found) {
    const {
      width,
      height
    } = main;
    const offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles({
      ...styles2,
      "transform-origin": "".concat(offset.x + transform2.x / 16, "em ").concat(offset.y + transform2.y / 16, "em")
    });
  }
  return [{
    tag: "svg",
    attributes,
    children: children2
  }];
}
function asSymbol(_ref) {
  let {
    prefix,
    iconName,
    children: children2,
    attributes,
    symbol
  } = _ref;
  const id = symbol === true ? "".concat(prefix, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: {
        ...attributes,
        id
      },
      children: children2
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  const {
    icons: {
      main,
      mask
    },
    prefix,
    iconName,
    transform: transform2,
    symbol,
    title,
    maskId,
    titleId,
    extra,
    watchable = false
  } = params;
  const {
    width,
    height
  } = mask.found ? mask : main;
  const isUploadedIcon = prefix === "fak";
  const attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter((c2) => extra.classes.indexOf(c2) === -1).filter((c2) => c2 !== "" || !!c2).concat(extra.classes).join(" ");
  let content = {
    children: [],
    attributes: {
      ...extra.attributes,
      "data-prefix": prefix,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    }
  };
  const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  const args = {
    ...content,
    prefix,
    iconName,
    main,
    mask,
    maskId,
    transform: transform2,
    symbol,
    styles: {
      ...uploadedIconWidthStyle,
      ...extra.styles
    }
  };
  const {
    children: children2,
    attributes
  } = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  };
  args.children = children2;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  const {
    content,
    width,
    height,
    transform: transform2,
    title,
    extra,
    watchable = false
  } = params;
  const attributes = {
    ...extra.attributes,
    ...title ? {
      "title": title
    } : {},
    "class": extra.classes.join(" ")
  };
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  const styles2 = {
    ...extra.styles
  };
  if (transformIsMeaningful(transform2)) {
    styles2["transform"] = transformForCss({
      transform: transform2,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  const styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  const {
    content,
    title,
    extra
  } = params;
  const attributes = {
    ...extra.attributes,
    ...title ? {
      "title": title
    } : {},
    "class": extra.classes.join(" ")
  };
  const styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
const {
  styles: styles$1
} = namespace;
function asFoundIcon(icon2) {
  const width = icon2[0];
  const height = icon2[1];
  const [vectorData] = icon2.slice(4);
  let element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
const missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION$1 && !config.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix, '" is missing.'));
  }
}
function findIcon(iconName, prefix) {
  let givenPrefix = prefix;
  if (prefix === "fa" && config.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }
  return new Promise((resolve2, reject) => {
    if (givenPrefix === "fa") {
      const shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }
    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      const icon2 = styles$1[prefix][iconName];
      return resolve2(asFoundIcon(icon2));
    }
    maybeNotifyMissing(iconName, prefix);
    resolve2({
      ...missingIconResolutionMixin,
      icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    });
  });
}
const noop$1 = () => {
};
const p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
const preamble = 'FA "6.6.0"';
const begin = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return () => end(name);
};
const end = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
const noop$2 = () => {
};
function isWatched(node) {
  const i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === "string";
}
function hasPrefixAndIcon(node) {
  const prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  const icon2 = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon2;
}
function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  const mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn = abstractObj.tag === "svg" ? createElementNS : createElement
  } = params;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  const tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  const children2 = abstractObj.children || [];
  children2.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node) {
  let comment = " ".concat(node.outerHTML, " ");
  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  return comment;
}
const mutators = {
  replace: function(mutation) {
    const node = mutation[0];
    if (node.parentNode) {
      mutation[1].forEach((abstract) => {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });
      if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        let comment = DOCUMENT.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function(mutation) {
    const node = mutation[0];
    const abstract = mutation[1];
    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    const forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      const splitClasses = abstract[0].attributes.class.split(" ").reduce((acc, cls) => {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node.removeAttribute("class");
      } else {
        node.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    const newInnerHTML = abstract.map((a2) => toHtml(a2)).join("\n");
    node.setAttribute(DATA_FA_I2SVG, "");
    node.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  const callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    let frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(() => {
      const mutator = getMutator();
      const mark = perf.begin("mutate");
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
let disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
let mo$1 = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  const {
    treeCallback = noop$2,
    nodeCallback = noop$2,
    pseudoElementsCallback = noop$2,
    observeMutationsRoot = DOCUMENT
  } = options;
  mo$1 = new MUTATION_OBSERVER((objects) => {
    if (disabled) return;
    const defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach((mutationRecord) => {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          const {
            prefix,
            iconName
          } = getCanonicalIcon(classArray(mutationRecord.target));
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo$1.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo$1) return;
  mo$1.disconnect();
}
function styleParser(node) {
  const style = node.getAttribute("style");
  let val = [];
  if (style) {
    val = style.split(";").reduce((acc, style2) => {
      const styles2 = style2.split(":");
      const prop = styles2[0];
      const value2 = styles2.slice(1);
      if (prop && value2.length > 0) {
        acc[prop] = value2.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node) {
  const existingPrefix = node.getAttribute("data-prefix");
  const existingIconName = node.getAttribute("data-icon");
  const innerText = node.innerText !== void 0 ? node.innerText.trim() : "";
  let val = getCanonicalIcon(classArray(node));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }
  if (!val.iconName && config.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node.firstChild.data;
  }
  return val;
}
function attributesParser(node) {
  const extraAttributes = toArray(node.attributes).reduce((acc, attr) => {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  const title = node.getAttribute("title");
  const titleId = node.getAttribute("data-fa-title-id");
  if (config.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  let parser2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName,
    prefix,
    rest: extraClasses
  } = classParser(node);
  const extraAttributes = attributesParser(node);
  const pluginMeta = chainHooks("parseNodeAttributes", {}, node);
  let extraStyles = parser2.styleParser ? styleParser(node) : [];
  return {
    iconName,
    title: node.getAttribute("title"),
    titleId: node.getAttribute("data-fa-title-id"),
    prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    },
    ...pluginMeta
  };
}
const {
  styles: styles$2
} = namespace;
function generateMutation(node) {
  const nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node, nodeMeta);
  }
}
let knownPrefixes = /* @__PURE__ */ new Set();
FAMILIES.map((family) => {
  knownPrefixes.add("fa-".concat(family));
});
Object.keys(PREFIX_TO_STYLE[a]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[r]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[o]).map(knownPrefixes.add.bind(knownPrefixes));
knownPrefixes = [...knownPrefixes];
function onTree(root2) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  const htmlClassList = DOCUMENT.documentElement.classList;
  const hclAdd = (suffix) => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const hclRemove = (suffix) => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const prefixes2 = config.autoFetchSvg ? knownPrefixes : FAMILIES.map((f$$1) => "fa-".concat(f$$1)).concat(Object.keys(styles$2));
  if (!prefixes2.includes("fa")) {
    prefixes2.push("fa");
  }
  const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map((p$$1) => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  let candidates = [];
  try {
    candidates = toArray(root2.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  const mark = perf.begin("onTree");
  const mutations = candidates.reduce((acc, node) => {
    try {
      const mutation = generateMutation(node);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION$1) {
        if (e$$1.name === "MissingIcon") {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise((resolve2, reject) => {
    Promise.all(mutations).then((resolvedMutations) => {
      perform(resolvedMutations, () => {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function") callback();
        mark();
        resolve2();
      });
    }).catch((e$$1) => {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node).then((mutation) => {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    let {
      mask
    } = params;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, {
      ...params,
      mask
    });
  };
}
const render = function(iconDefinition) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: transform2 = meaninglessTransform,
    symbol = false,
    mask = null,
    maskId = null,
    title = null,
    titleId = null,
    classes = [],
    attributes = {},
    styles: styles2 = {}
  } = params;
  if (!iconDefinition) return;
  const {
    prefix,
    iconName,
    icon: icon2
  } = iconDefinition;
  return domVariants({
    type: "icon",
    ...iconDefinition
  }, () => {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix,
      iconName,
      transform: {
        ...meaninglessTransform,
        ...transform2
      },
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      const {
        node = DOCUMENT,
        callback = () => {
        }
      } = params;
      return onTree(node, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
      const {
        iconName,
        title,
        titleId,
        prefix,
        transform: transform2,
        symbol,
        mask,
        maskId,
        extra
      } = nodeMeta;
      return new Promise((resolve2, reject) => {
        Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then((_ref) => {
          let [main, mask2] = _ref;
          resolve2([node, makeInlineSvgAbstract({
            icons: {
              main,
              mask: mask2
            },
            prefix,
            iconName,
            transform: transform2,
            symbol,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref2) {
      let {
        children: children2,
        attributes,
        main,
        transform: transform2,
        styles: styles2
      } = _ref2;
      const styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes["style"] = styleString;
      }
      let nextChild;
      if (transformIsMeaningful(transform2)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main,
          transform: transform2,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children2.push(nextChild || main.icon);
      return {
        children: children2,
        attributes
      };
    };
  }
};
var Layers = {
  mixout() {
    return {
      layer(assembler) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes = []
        } = params;
        return domVariants({
          type: "layer"
        }, () => {
          callHooks("beforeDOMElementCreation", {
            assembler,
            params
          });
          let children2 = [];
          assembler((args) => {
            Array.isArray(args) ? args.map((a2) => {
              children2 = children2.concat(a2.abstract);
            }) : children2 = children2.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers"), ...classes].join(" ")
            },
            children: children2
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout() {
    return {
      counter(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "counter",
          content
        }, () => {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-counter"), ...classes]
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout() {
    return {
      text(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: transform2 = meaninglessTransform,
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "text",
          content
        }, () => {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: {
              ...meaninglessTransform,
              ...transform2
            },
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-text"), ...classes]
            }
          });
        });
      }
    };
  },
  provides(providers$$1) {
    providers$$1.generateLayersText = function(node, nodeMeta) {
      const {
        title,
        transform: transform2,
        extra
      } = nodeMeta;
      let width = null;
      let height = null;
      if (IS_IE) {
        const computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        const boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config.autoA11y && !title) {
        extra.attributes["aria-hidden"] = "true";
      }
      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width,
        height,
        transform: transform2,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};
const CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
const SECONDARY_UNICODE_RANGE = [1105920, 1112319];
const _FONT_FAMILY_WEIGHT_TO_PREFIX = {
  ...{
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  },
  ...eo,
  ...ao,
  ...mo
};
const FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
  acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
  return acc;
}, {});
const FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
  const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
  acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
  return acc;
}, {});
function hexValueFromContent(content) {
  const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  const codePoint = codePointAt(cleaned, 0);
  const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function getPrefix(fontFamily, fontWeight) {
  const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
  const fontWeightInteger = parseInt(fontWeight);
  const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node, position) {
  const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
  return new Promise((resolve2, reject) => {
    if (node.getAttribute(pendingAttribute) !== null) {
      return resolve2();
    }
    const children2 = toArray(node.children);
    const alreadyProcessedPseudoElement = children2.filter((c2) => c2.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position)[0];
    const styles2 = WINDOW.getComputedStyle(node, position);
    const fontFamily = styles2.getPropertyValue("font-family");
    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    const fontWeight = styles2.getPropertyValue("font-weight");
    const content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve2();
    } else if (fontFamilyMatch && content !== "none" && content !== "") {
      const content2 = styles2.getPropertyValue("content");
      let prefix = getPrefix(fontFamily, fontWeight);
      const {
        value: hexValue,
        isSecondary
      } = hexValueFromContent(content2);
      const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
      let iconName = byUnicode(prefix, hexValue);
      let iconIdentifier = iconName;
      if (isV4) {
        const iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node.removeChild(alreadyProcessedPseudoElement);
        }
        const meta = blankMeta();
        const {
          extra
        } = meta;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then((main) => {
          const abstract = makeInlineSvgAbstract({
            ...meta,
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix,
            iconName: iconIdentifier,
            extra,
            watchable: true
          });
          const element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position === "::before") {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }
          element.outerHTML = abstract.map((a2) => toHtml(a2)).join("\n");
          node.removeAttribute(pendingAttribute);
          resolve2();
        }).catch(reject);
      } else {
        resolve2();
      }
    } else {
      resolve2();
    }
  });
}
function replace(node) {
  return Promise.all([replaceForPosition(node, "::before"), replaceForPosition(node, "::after")]);
}
function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
}
function searchPseudoElements(root2) {
  if (!IS_DOM) return;
  return new Promise((resolve2, reject) => {
    const operations = toArray(root2.querySelectorAll("*")).filter(processable).map(replace);
    const end2 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(() => {
      end2();
      enableObservation();
      resolve2();
    }).catch(() => {
      end2();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.pseudoElements2svg = function(params) {
      const {
        node = DOCUMENT
      } = params;
      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};
let _unwatched = false;
var MutationObserver$1 = {
  mixout() {
    return {
      dom: {
        unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto() {
        disconnect();
      },
      watch(params) {
        const {
          observeMutationsRoot
        } = params;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
const parseTransformString = (transformString) => {
  let transform2 = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce((acc, n) => {
    const parts2 = n.toLowerCase().split("-");
    const first = parts2[0];
    let rest = parts2.slice(1).join("-");
    if (first && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform2);
};
var PowerTransforms = {
  mixout() {
    return {
      parse: {
        transform: (transformString) => {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const transformString = node.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref) {
      let {
        main,
        transform: transform2,
        containerWidth,
        iconWidth
      } = _ref;
      const outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      const innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
      const innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
      const innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
      const inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      const path2 = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      const operations = {
        outer,
        inner,
        path: path2
      };
      return {
        tag: "g",
        attributes: {
          ...operations.outer
        },
        children: [{
          tag: "g",
          attributes: {
            ...operations.inner
          },
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: {
              ...main.icon.attributes,
              ...operations.path
            }
          }]
        }]
      };
    };
  }
};
const ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const maskData = node.getAttribute("data-fa-mask");
        const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i) => i.trim()));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractMask = function(_ref) {
      let {
        children: children2,
        attributes,
        main,
        mask,
        maskId: explicitMaskId,
        transform: transform2
      } = _ref;
      const {
        width: mainWidth,
        icon: mainPath
      } = main;
      const {
        width: maskWidth,
        icon: maskPath
      } = mask;
      const trans = transformForSvg({
        transform: transform2,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      const maskRect = {
        tag: "rect",
        attributes: {
          ...ALL_SPACE,
          fill: "white"
        }
      };
      const maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      const maskInnerGroup = {
        tag: "g",
        attributes: {
          ...trans.inner
        },
        children: [fillBlack({
          tag: mainPath.tag,
          attributes: {
            ...mainPath.attributes,
            ...trans.path
          },
          ...maskInnerGroupChildrenMixin
        })]
      };
      const maskOuterGroup = {
        tag: "g",
        attributes: {
          ...trans.outer
        },
        children: [maskInnerGroup]
      };
      const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      const maskTag = {
        tag: "mask",
        attributes: {
          ...ALL_SPACE,
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        },
        children: [maskRect, maskOuterGroup]
      };
      const defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children2.push(defs, {
        tag: "rect",
        attributes: {
          fill: "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")"),
          ...ALL_SPACE
        }
      });
      return {
        children: children2,
        attributes
      };
    };
  }
};
var MissingIconIndicator = {
  provides(providers2) {
    let reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      const gChildren = [];
      const FILL = {
        fill: "currentColor"
      };
      const ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: {
          ...FILL,
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        }
      });
      const OPACITY_ANIMATE = {
        ...ANIMATION_BASE,
        attributeName: "opacity"
      };
      const dot = {
        tag: "circle",
        attributes: {
          ...FILL,
          cx: "256",
          cy: "364",
          r: "28"
        },
        children: []
      };
      if (!reduceMotion) {
        dot.children.push({
          tag: "animate",
          attributes: {
            ...ANIMATION_BASE,
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          }
        }, {
          tag: "animate",
          attributes: {
            ...OPACITY_ANIMATE,
            values: "1;0;1;1;0;1;"
          }
        });
      }
      gChildren.push(dot);
      gChildren.push({
        tag: "path",
        attributes: {
          ...FILL,
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        },
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: {
            ...OPACITY_ANIMATE,
            values: "1;0;0;0;0;1;"
          }
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: {
            ...FILL,
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          },
          children: [{
            tag: "animate",
            attributes: {
              ...OPACITY_ANIMATE,
              values: "0;0;1;1;0;0;"
            }
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          "class": "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const symbolData = node.getAttribute("data-fa-symbol");
        const symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol;
        return accumulator;
      }
    };
  }
};
var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins, {
  mixoutsTo: api
});
api.noAuto;
api.config;
const library$1 = api.library;
api.dom;
const parse$1 = api.parse;
api.findIconDefinition;
api.toHtml;
const icon = api.icon;
api.layer;
api.text;
api.counter;
function ownKeys(e, r2) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r22) {
      _defineProperty(e, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e;
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
    return typeof o22;
  } : function(o22) {
    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
  }, _typeof(o2);
}
function _defineProperty(obj, key, value2) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var humps$1 = { exports: {} };
(function(module2) {
  (function(global2) {
    var _processKeys = function(convert2, obj, options) {
      if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
        return obj;
      }
      var output, i = 0, l = 0;
      if (_isArray(obj)) {
        output = [];
        for (l = obj.length; i < l; i++) {
          output.push(_processKeys(convert2, obj[i], options));
        }
      } else {
        output = {};
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            output[convert2(key, options)] = _processKeys(convert2, obj[key], options);
          }
        }
      }
      return output;
    };
    var separateWords = function(string2, options) {
      options = options || {};
      var separator = options.separator || "_";
      var split = options.split || /(?=[A-Z])/;
      return string2.split(split).join(separator);
    };
    var camelize2 = function(string2) {
      if (_isNumerical(string2)) {
        return string2;
      }
      string2 = string2.replace(/[\-_\s]+(.)?/g, function(match, chr) {
        return chr ? chr.toUpperCase() : "";
      });
      return string2.substr(0, 1).toLowerCase() + string2.substr(1);
    };
    var pascalize = function(string2) {
      var camelized = camelize2(string2);
      return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
    };
    var decamelize = function(string2, options) {
      return separateWords(string2, options).toLowerCase();
    };
    var toString2 = Object.prototype.toString;
    var _isFunction = function(obj) {
      return typeof obj === "function";
    };
    var _isObject = function(obj) {
      return obj === Object(obj);
    };
    var _isArray = function(obj) {
      return toString2.call(obj) == "[object Array]";
    };
    var _isDate = function(obj) {
      return toString2.call(obj) == "[object Date]";
    };
    var _isRegExp = function(obj) {
      return toString2.call(obj) == "[object RegExp]";
    };
    var _isBoolean = function(obj) {
      return toString2.call(obj) == "[object Boolean]";
    };
    var _isNumerical = function(obj) {
      obj = obj - 0;
      return obj === obj;
    };
    var _processor = function(convert2, options) {
      var callback = options && "process" in options ? options.process : options;
      if (typeof callback !== "function") {
        return convert2;
      }
      return function(string2, options2) {
        return callback(string2, convert2, options2);
      };
    };
    var humps2 = {
      camelize: camelize2,
      decamelize,
      pascalize,
      depascalize: decamelize,
      camelizeKeys: function(object2, options) {
        return _processKeys(_processor(camelize2, options), object2);
      },
      decamelizeKeys: function(object2, options) {
        return _processKeys(_processor(decamelize, options), object2, options);
      },
      pascalizeKeys: function(object2, options) {
        return _processKeys(_processor(pascalize, options), object2);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    if (module2.exports) {
      module2.exports = humps2;
    } else {
      global2.humps = humps2;
    }
  })(commonjsGlobal);
})(humps$1);
var humps = humps$1.exports;
var _excluded = ["class", "style"];
function styleToObject(style) {
  return style.split(";").map(function(s) {
    return s.trim();
  }).filter(function(s) {
    return s;
  }).reduce(function(output, pair) {
    var idx = pair.indexOf(":");
    var prop = humps.camelize(pair.slice(0, idx));
    var value2 = pair.slice(idx + 1).trim();
    output[prop] = value2;
    return output;
  }, {});
}
function classToObject(classes) {
  return classes.split(/\s+/).reduce(function(output, className) {
    output[className] = true;
    return output;
  }, {});
}
function convert(abstractElement) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof abstractElement === "string") {
    return abstractElement;
  }
  var children2 = (abstractElement.children || []).map(function(child) {
    return convert(child);
  });
  var mixins = Object.keys(abstractElement.attributes || {}).reduce(function(mixins2, key) {
    var value2 = abstractElement.attributes[key];
    switch (key) {
      case "class":
        mixins2.class = classToObject(value2);
        break;
      case "style":
        mixins2.style = styleToObject(value2);
        break;
      default:
        mixins2.attrs[key] = value2;
    }
    return mixins2;
  }, {
    attrs: {},
    class: {},
    style: {}
  });
  attrs.class;
  var _attrs$style = attrs.style, aStyle = _attrs$style === void 0 ? {} : _attrs$style, otherAttrs = _objectWithoutProperties(attrs, _excluded);
  return h(abstractElement.tag, _objectSpread2(_objectSpread2(_objectSpread2({}, props), {}, {
    class: mixins.class,
    style: _objectSpread2(_objectSpread2({}, mixins.style), aStyle)
  }, mixins.attrs), otherAttrs), children2);
}
var PRODUCTION = false;
try {
  PRODUCTION = true;
} catch (e) {
}
function log() {
  if (!PRODUCTION && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function objectWithKey(key, value2) {
  return Array.isArray(value2) && value2.length > 0 || !Array.isArray(value2) && value2 ? _defineProperty({}, key, value2) : {};
}
function classList(props) {
  var _classes;
  var classes = (_classes = {
    "fa-spin": props.spin,
    "fa-pulse": props.pulse,
    "fa-fw": props.fixedWidth,
    "fa-border": props.border,
    "fa-li": props.listItem,
    "fa-inverse": props.inverse,
    "fa-flip": props.flip === true,
    "fa-flip-horizontal": props.flip === "horizontal" || props.flip === "both",
    "fa-flip-vertical": props.flip === "vertical" || props.flip === "both"
  }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classes, "fa-".concat(props.size), props.size !== null), "fa-rotate-".concat(props.rotation), props.rotation !== null), "fa-pull-".concat(props.pull), props.pull !== null), "fa-swap-opacity", props.swapOpacity), "fa-bounce", props.bounce), "fa-shake", props.shake), "fa-beat", props.beat), "fa-fade", props.fade), "fa-beat-fade", props.beatFade), "fa-flash", props.flash), _defineProperty(_defineProperty(_classes, "fa-spin-pulse", props.spinPulse), "fa-spin-reverse", props.spinReverse));
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function normalizeIconArgs(icon2) {
  if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (_typeof(icon2) === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return {
      prefix: icon2[0],
      iconName: icon2[1]
    };
  }
  if (typeof icon2 === "string") {
    return {
      prefix: "fas",
      iconName: icon2
    };
  }
}
var FontAwesomeIcon = /* @__PURE__ */ defineComponent({
  name: "FontAwesomeIcon",
  props: {
    border: {
      type: Boolean,
      default: false
    },
    fixedWidth: {
      type: Boolean,
      default: false
    },
    flip: {
      type: [Boolean, String],
      default: false,
      validator: function validator(value2) {
        return [true, false, "horizontal", "vertical", "both"].indexOf(value2) > -1;
      }
    },
    icon: {
      type: [Object, Array, String],
      required: true
    },
    mask: {
      type: [Object, Array, String],
      default: null
    },
    maskId: {
      type: String,
      default: null
    },
    listItem: {
      type: Boolean,
      default: false
    },
    pull: {
      type: String,
      default: null,
      validator: function validator2(value2) {
        return ["right", "left"].indexOf(value2) > -1;
      }
    },
    pulse: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function validator3(value2) {
        return [90, 180, 270].indexOf(Number.parseInt(value2, 10)) > -1;
      }
    },
    swapOpacity: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: null,
      validator: function validator4(value2) {
        return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(value2) > -1;
      }
    },
    spin: {
      type: Boolean,
      default: false
    },
    transform: {
      type: [String, Object],
      default: null
    },
    symbol: {
      type: [Boolean, String],
      default: false
    },
    title: {
      type: String,
      default: null
    },
    titleId: {
      type: String,
      default: null
    },
    inverse: {
      type: Boolean,
      default: false
    },
    bounce: {
      type: Boolean,
      default: false
    },
    shake: {
      type: Boolean,
      default: false
    },
    beat: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: false
    },
    beatFade: {
      type: Boolean,
      default: false
    },
    flash: {
      type: Boolean,
      default: false
    },
    spinPulse: {
      type: Boolean,
      default: false
    },
    spinReverse: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup2(props, _ref) {
    var attrs = _ref.attrs;
    var icon$1 = computed(function() {
      return normalizeIconArgs(props.icon);
    });
    var classes = computed(function() {
      return objectWithKey("classes", classList(props));
    });
    var transform2 = computed(function() {
      return objectWithKey("transform", typeof props.transform === "string" ? parse$1.transform(props.transform) : props.transform);
    });
    var mask = computed(function() {
      return objectWithKey("mask", normalizeIconArgs(props.mask));
    });
    var renderedIcon = computed(function() {
      return icon(icon$1.value, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes.value), transform2.value), mask.value), {}, {
        symbol: props.symbol,
        title: props.title,
        titleId: props.titleId,
        maskId: props.maskId
      }));
    });
    watch(renderedIcon, function(value2) {
      if (!value2) {
        return log("Could not find one or more icon(s)", icon$1.value, mask.value);
      }
    }, {
      immediate: true
    });
    var vnode = computed(function() {
      return renderedIcon.value ? convert(renderedIcon.value.abstract[0], {}, attrs) : null;
    });
    return function() {
      return vnode.value;
    };
  }
});
const faArrowsLeftRight = {
  prefix: "fasr",
  iconName: "arrows-left-right",
  icon: [512, 512, ["arrows-h"], "f07e", "M493.8 273l17-17-17-17-96-96-17-17L346.9 160l17 17 55 55L93.1 232l55-55 17-17-33.9-33.9-17 17-96 96-17 17 17 17 96 96 17 17L165.1 352l-17-17-55-55 325.7 0-55 55-17 17 33.9 33.9 17-17 96-96z"]
};
const faPlusLarge = {
  prefix: "fasr",
  iconName: "plus-large",
  icon: [512, 512, [], "e59e", "M488 232l24 0 0 48-24 0-208 0 0 208 0 24-48 0 0-24 0-208L24 280 0 280l0-48 24 0 208 0 0-208 0-24 48 0 0 24 0 208 208 0z"]
};
const faExpand = {
  prefix: "fasr",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M136 32l24 0 0 48-24 0L48 80l0 88 0 24L0 192l0-24L0 56 0 32l24 0 112 0zM0 344l0-24 48 0 0 24 0 88 88 0 24 0 0 48-24 0L24 480 0 480l0-24L0 344zM424 32l24 0 0 24 0 112 0 24-48 0 0-24 0-88-88 0-24 0 0-48 24 0 112 0zM400 344l0-24 48 0 0 24 0 112 0 24-24 0-112 0-24 0 0-48 24 0 88 0 0-88z"]
};
const faArrowsUpDown = {
  prefix: "fasr",
  iconName: "arrows-up-down",
  icon: [320, 512, ["arrows-v"], "f07d", "M177 18.2l-17-17-17 17-96 96-17 17L64 165.1l17-17 55-55 0 325.7-55-55-17-17L30.1 380.8l17 17 96 96 17 17 17-17 96-96 17-17L256 346.9l-17 17-55 55 0-325.7 55 55 17 17 33.9-33.9-17-17-96-96z"]
};
const faTrash = {
  prefix: "fass",
  iconName: "trash",
  icon: [448, 512, [], "f1f8", "M144 0L128 32 0 32 0 96l448 0 0-64L320 32 304 0 144 0zM416 128L32 128 56 512l336 0 24-384z"]
};
const faCalculator = {
  prefix: "fass",
  iconName: "calculator",
  icon: [384, 512, [128425], "f1ec", "M384 0L0 0 0 512l384 0L384 0zM320 64l0 96L64 160l0-96 256 0zM64 192l64 0 0 64-64 0 0-64zm64 96l0 64-64 0 0-64 64 0zM64 384l160 0 0 64L64 448l0-64zM224 192l0 64-64 0 0-64 64 0zm-64 96l64 0 0 64-64 0 0-64zm160-96l0 64-64 0 0-64 64 0zm-64 96l64 0 0 64-64 0 0-64zm64 96l0 64-64 0 0-64 64 0z"]
};
const faXmark = {
  prefix: "fass",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M326.6 166.6L349.3 144 304 98.7l-22.6 22.6L192 210.7l-89.4-89.4L80 98.7 34.7 144l22.6 22.6L146.7 256 57.4 345.4 34.7 368 80 413.3l22.6-22.6L192 301.3l89.4 89.4L304 413.3 349.3 368l-22.6-22.6L237.3 256l89.4-89.4z"]
};
const faHammer = {
  prefix: "fass",
  iconName: "hammer",
  icon: [576, 512, [128296], "f6e3", "M225.6 18.2L176 48l96 48 0 48L384 256l24-24 24 24-24 24 48 48L576 208l-48-48-24 24-24-24 24-24L405.5 37.5C381.5 13.5 348.9 0 315 0L291.5 0c-23.2 0-46 6.3-65.9 18.2zM0 416l96 96L330.7 248 264 181.3 0 416z"]
};
library$1.add(
  faXmark,
  faExpand,
  faArrowsLeftRight,
  faArrowsUpDown,
  faHammer,
  faTrash,
  faPlusLarge,
  faCalculator
);
const i18n = createI18n({
  locale: "en_US",
  fallbackLocale: "en_US",
  messages
});
const appElement = document.querySelector("#smartcut-app");
const type = appElement ? appElement.getAttribute("data-type") : "";
const app = createApp(Launch, { type });
app.use(i18n);
app.component("FontAwesomeIcon", FontAwesomeIcon);
app.mount("#smartcut-app");
export {
  renderList as A,
  withDirectives as B,
  CheckoutCalculator as C,
  vShow as D,
  withModifiers as E,
  Fragment as F,
  getDefaultExportFromCjs as G,
  commonjsGlobal$1 as H,
  useI18n as I,
  userFriendlyFieldMap as J,
  getSeparators as K,
  localeParseFloat as L,
  block0 as M,
  getOutputType as N,
  parseBoolean as O,
  _export_sfc as _,
  convertUnit as a,
  defineComponent as b,
  createBlock as c,
  d3 as d,
  getOptions as e,
  extrasValidation as f,
  getRef as g,
  hasMachining as h,
  getMinValue as i,
  getMaxValue as j,
  isFieldEnabled as k,
  isFieldPresent as l,
  markRaw as m,
  getInputMode as n,
  openBlock as o,
  getInputType as p,
  createElementBlock as q,
  resolveComponent as r,
  setFieldEnabled as s,
  createBaseVNode as t,
  createVNode as u,
  valueSet as v,
  toDisplayString$1 as w,
  createCommentVNode as x,
  normalizeClass as y,
  normalizeStyle as z
};
